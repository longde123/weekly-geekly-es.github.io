<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🤟🏾 🔋 O reverso do Neuromancer. Parte 4: Som, Animação, Huffman, Github 😮 💄 🚆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, como você já entendeu, esta é uma continuação da minha história de engenharia reversa e portabilidade do Neuromant. 

 O reverso do Neuromancer. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O reverso do Neuromancer. Parte 4: Som, Animação, Huffman, Github</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417639/"><p>  Olá, como você já entendeu, esta é uma continuação da minha história de engenharia reversa e portabilidade do Neuromant. </p><br><img src="https://habrastorage.org/webt/-g/ru/d_/-grud_xhetuzh4znt4rbkeakxyi.png"><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O reverso do Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Sprites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O reverso do Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Renderizar fonte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O reverso do Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Renderização finalizada, faça o jogo</a> </blockquote><p>  Hoje, vamos começar com duas boas notícias: </p><br><ul><li>  primeiro, não estou mais sozinho - o usuário do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">viiri</a> já entrou no projeto e já fez uma contribuição significativa; </li><li>  segundo, agora temos um repositório aberto no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>github</em></a> . </li></ul><br><p>  Em geral, as coisas estão indo muito bem, e talvez em breve teremos pelo menos alguma versão jogável.  E, como de costume, vamos falar sobre o que e <em>como</em> foram alcançados no momento. </p><a name="habracut"></a><br><hr><br><p>  Ele começou a lidar com o som.  Infelizmente, entre os recursos do jogo, não havia nada parecido com o áudio, e como eu não tinha idéia de como a música funciona no <em>MS-DOS</em> , não era muito claro por onde começar.  Depois de ler um pouco sobre todos os tipos de <em>SoundBlaster</em> , o melhor que descobri é rolar o código desmontado na esperança de ver algumas assinaturas familiares.  E quem procura, ele geralmente encontra, mesmo que não seja exatamente o que estava procurando (comentários de <em>Ida</em> ): </p><br><pre><code class="hljs vhdl">sub_20416: ... mov ax, [si+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ; <span class="hljs-number"><span class="hljs-number">8253</span></span>-<span class="hljs-number"><span class="hljs-number">5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span>-<span class="hljs-number"><span class="hljs-number">5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov bx, [si+<span class="hljs-number"><span class="hljs-number">0</span></span>Ah] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> bl, <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ; PC/XT PPI <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> B bits: ; <span class="hljs-number"><span class="hljs-number">0</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> gate ═╦═► <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span>H=spkr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ; <span class="hljs-number"><span class="hljs-number">1</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> data ═╝ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>fcH=spkr OFF ; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>=read high switches ; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable RAM parity checking ; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable I/O channel check ; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=hold keyboard clock low ; <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable kbrd <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">0</span></span>FCh <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, bl <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ; PC/XT PPI <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> B bits: ; <span class="hljs-number"><span class="hljs-number">0</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> gate ═╦═► <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span>H=spkr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ; <span class="hljs-number"><span class="hljs-number">1</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> data ═╝ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>fcH=spkr OFF ; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>=read high switches ; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable RAM parity checking ; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable I/O channel check ; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=hold keyboard clock low ; <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable kbrd</code> </pre> <br><p>  Tendo passado por esse <em>Timer 8253-5,</em> me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> que se tornou a primeira chave para entender o que estava acontecendo.  Abaixo vou tentar explicar o que é o quê. </p><br><p>  Portanto, na era do <em>IBM-PC</em> , antes do advento de placas de som acessíveis, o dispositivo de reprodução de som mais comum era o <em>PC Speaker</em> , também conhecido como "bip".  Este dispositivo nada mais é do que um alto-falante comum conectado à placa-mãe, na maioria dos casos, através de um conector de quatro pinos.  O sinal sonoro, de acordo com a idéia, possibilitou a reprodução de um pulso retangular de dois níveis (correspondente a dois níveis de tensão, geralmente 0V e + 5V) e foi controlado através da 61ª porta do controlador <em>PPI (Programmable Peripheral Interface)</em> .  Especificamente, os dois primeiros bits do valor enviado para a porta são responsáveis ​​por controlar o "alto-falante" (ver comentários nas linhas <code>in al, 61h</code> e <code>out 61h, al</code> ). </p><br><p>  Como eu disse (em poucas palavras diferentes), nosso falante pode estar em dois estados - <em>"dentro"</em> e <em>"fora"</em> ( <em>"baixo" - "alto"</em> , <em>"desligado" - "ligado"</em> , <em>"desligado" - "ligado"</em> , o que for).  Para criar <em>um</em> impulso, é necessário mudar o estado atual para o oposto e, depois de algum tempo, voltar.  Isso pode ser feito diretamente, manipulando o primeiro bit (contagem a partir do zero) da porta 61, por exemplo, assim: </p><br><pre> <code class="hljs vhdl">PULSE: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b ;    ... <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000010</span></span>b ;     ... ; ,        <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;    <span class="hljs-number"><span class="hljs-number">61</span></span>-  mov cx, <span class="hljs-number"><span class="hljs-number">100</span></span> ;   DELAY: <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> DELAY ;    <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b ;     <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;    <span class="hljs-number"><span class="hljs-number">61</span></span>- </code> </pre> <br><p>  O resultado da execução deste código será semelhante a este: </p><br><pre> <code class="hljs delphi"> loop DELAY +<span class="hljs-number"><span class="hljs-number">5</span></span>V +----------------------+ ! ! <span class="hljs-number"><span class="hljs-number">0</span></span>V ---+ +-------------------------- <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000010</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al</code> </pre> <br><p>  Repetindo <em>PULSO</em> com um atraso, obtemos um sinal retangular: </p><br><pre> <code class="hljs erlang-repl"> mov dx, <span class="hljs-number"><span class="hljs-number">100</span></span> ;  <span class="hljs-number"><span class="hljs-number">100</span></span>  PULSE: ... mov cx, <span class="hljs-number"><span class="hljs-number">100</span></span> WAIT: loop WAIT dec dx jnz PULSE PULSE +<span class="hljs-number"><span class="hljs-number">5</span></span>V +---------+ +---------+ +---------+ ! ! ! ! ! ! <span class="hljs-number"><span class="hljs-number">0</span></span>V ---+ +---------+ +---------+ +--- loop WAIT</code> </pre><br><p>  Se no primeiro caso dificilmente teríamos ouvido algo, no segundo obteremos um tom de frequência, dependendo da velocidade da máquina na qual esse código é executado.  Isso é ótimo, mas associado a certas dificuldades.  De qualquer forma, existe uma maneira mais conveniente de controlar o alto-falante. </p><br><p>  Aí vem o cronômetro programável de três canais para jogos - <em>Intel 8253</em> , cujo segundo canal (começando do zero) está conectado ao sinal sonoro.  Este timer recebe um sinal do relógio <em>Intel 8254</em> , enviando 1193180 pulsos por segundo (~ 1.193 MHz) e pode ser programado para uma reação específica após um número especificado de pulsos.  Uma dessas reações é enviar um pulso quadrado para o alto-falante.  Em outras palavras, o <em>8253</em> pode funcionar na forma de um gerador de um sinal retangular de frequência ajustável, o que torna relativamente fácil sintetizar vários efeitos sonoros no alto-falante.  E aqui está o que você precisa para isso: </p><br><ol><li>  Defina o segundo canal do temporizador para o modo de geração de sinal retangular.  Para fazer isso, escreva um valor especial de byte único na porta 43 ( <em>registrador de modo / comando 8253</em> ).  No meu caso, este é <code>10110110B</code> (mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ): </li></ol><br><pre> <code class="markdown hljs">Bits Usage 6 and 7 Select channel : 1 0 = Channel 2 4 and 5 Access mode : 1 1 = Access mode: lobyte/hibyte 1 to 3 Operating mode : 0 1 1 = Mode 3 (square wave generator) 0 BCD/Binary mode: 0 = 16-bit binary</code> </pre> <br><ol><li><p>  Defina a frequência desejada no segundo canal.  Para fazer isso, byte por bit, do mais novo ao mais antigo, enviamos para a 42ª porta ( <em>porta de dados 8253 Canal 2</em> ) um valor igual a <code>1193180 / freq</code> , em que <code>freq</code> é o valor de frequência necessário em Hertz. </p><br></li><li><p>  Permita que o alto-falante receba pulsos do timer.  Para fazer isso, defina os dois primeiros bits do valor na porta 61 ( <em>PPI</em> ) como unidade.  O fato é que, se o bit zero for definido como 1, o primeiro será interpretado como um "comutador": </p><br></li></ol><br><pre> <code class="markdown hljs">Bit 0 Effect ----------------------------------------------------------------- 0 The state of the speaker will follow bit 1 of port 61h 1 The speaker will be connected to PIT channel 2, bit 1 is used as switch ie 0 = not connected, 1 = connected.</code> </pre> <br><p>  Como resultado, temos a seguinte imagem: </p><br><pre> <code class="hljs vhdl"> mov al, <span class="hljs-number"><span class="hljs-number">10110110</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>h, al ;   mov ax, <span class="hljs-number"><span class="hljs-number">02E9</span></span>Bh ; <span class="hljs-number"><span class="hljs-number">1193180</span></span> / <span class="hljs-number"><span class="hljs-number">100</span></span> = ~<span class="hljs-number"><span class="hljs-number">0</span></span>x2E9B <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ;      mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ;      <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000011</span></span>b ;      <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;   ... ;       ~<span class="hljs-number"><span class="hljs-number">100</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;  </code> </pre> <br><p>  E é exatamente isso que o código que eu citei no início (exceto para a inicialização, mas eu o encontrei em outra função): no <code>si + 8</code> há um divisor de frequência enviado para a porta 42 e no <code>si + 0Ah</code> - status do alto-falante ( <em>“ligado” - “desligado”</em> ) gravado na porta 61. </p><br><p>  O mecanismo de reprodução é simples e direto, mas você teve que lidar com horários.  Tendo examinado o código próximo, vi que na mesma função em que o timer é inicializado ( <code>sub_2037A</code> , daqui em diante - <code>init_8253</code> ), o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">oitavo</a> manipulador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interrupções</a> é substituído pela função <code>sub_20416</code> (a seguir - <code>play_sample</code> ).  Logo ficou claro que essa interrupção é gerada aproximadamente 18,2 vezes por segundo e serve para atualizar a hora do sistema.  Substituir o manipulador dessa interrupção é uma prática comum se você precisar executar alguma ação 18 vezes por segundo (na verdade, o manipulador original também deve ser chamado dentro do gancho, caso contrário, a hora do sistema será interrompida).  Com base nisso, verifica-se que a próxima frequência é carregada no gerador a cada <code>(1 / 18.2) * 1000 ~ 55</code> . </p><br><p>  O plano era este: </p><br><ul><li>  coloque um ponto de interrupção na função <code>play_sample</code> , na linha em que o próximo divisor de frequência é extraído; </li><li>  calcular a frequência de acordo com a fórmula <code>freq = 1193180 / divisor</code> ; </li><li>  gerar 55ms de sinal de frequência quadrada em algum tipo de editor de áudio (usei o <em>Adobe Audition</em> ); </li><li>  repita os três primeiros passos até acumular pelo menos 3 segundos. </li></ul><br><p>  Então, eu peguei o começo da melodia no menu principal, mas toquei 10 vezes mais devagar do que o necessário.  Depois reduzi a duração da "amostra" de 55 ms para 5 ms - ela ficou muito melhor, mas ainda não é isso.  O problema de tempo permaneceu em aberto até eu encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> .  Descobriu-se que a oitava interrupção é gerada pela alimentação do mesmo <em>8253</em> , cujo canal zero está conectado ao controlador de interrupção ( <em>PIC</em> ).  Quando a máquina é inicializada, o <em>BIOS</em> define o canal zero para gerar pulsos com uma frequência de ~ 18,2 Hz (ou seja, uma interrupção é gerada a cada ~ 54,9 ms).  No entanto, o canal zero pode ser reprogramado para gerar pulsos com uma frequência mais alta; para isso, por analogia com o segundo canal, é necessário escrever um valor igual a <code>1193180 / freq</code> na 40ª porta, em que <code>freq</code> é o valor de frequência necessário em Hertz.  Isso acontece na função <code>init_8253</code> , mas inicialmente não prestei a devida atenção: </p><br><pre> <code class="hljs objectivec">init_8253: ... mov al, <span class="hljs-number"><span class="hljs-number">0</span></span>B6h ; <span class="hljs-number"><span class="hljs-number">10110110</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov ax, <span class="hljs-number"><span class="hljs-number">13</span></span>B1h <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>).</code> </pre> <br><p>  O valor <code>13B1h</code> traduzido para a frequência: <code>1193180 / 13B1h ~ 236.7</code> , então obtemos aproximadamente <code>(1 / 236.7) * 1000 ~ 4.2</code> por "amostra".  O quebra-cabeça se desenvolveu. </p><br><p>  Então é uma questão de tecnologia - implementar uma função que extrai as trilhas sonoras do jogo.  Mas eis que os valores dos divisores de frequência registrados na 42ª porta não são armazenados explicitamente.  Eles são calculados por algum algoritmo complicado, cujos dados de entrada e a área de trabalho estão diretamente no arquivo executável do jogo (no sétimo segmento, de acordo com <em>Ida</em> ).  Além disso, dos recursos, não há sinal do fim da faixa, quando não há mais nada para reproduzir, o algoritmo produz infinitamente um estado zero do alto-falante.  Mas eu não me incomodei e, como no caso do algoritmo de descompressão (a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> ), acabei de portar para o montador de 64 bits a função de definir a faixa para reprodução e o algoritmo para obter a próxima frequência (e eu peguei o sétimo segmento inteiramente). </p><br><p>  E funcionou.  Depois disso, implementei as funções de geração da trilha sonora para a faixa selecionada ( <em>PCM, 44100 Hz, 8 bits, mono</em> ; fiz algo como um gerador usado no emulador de alto-falante do <em>DosBox</em> ).  Resolvi o problema com o sinal do fim com um simples contador de silêncio: contei um segundo - concluímos o algoritmo.  Envolvendo a faixa resultante no cabeçalho <em>WAV</em> e salvando o resultado em um arquivo, obtive exatamente a faixa no menu principal.  E mais 13 faixas que você pode ouvir abaixo <em>[ou no visualizador de recursos, que agora possui um player embutido e a capacidade de salvar qualquer faixa em .WAV]</em> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>[Estudando a questão, aprendi sobre técnicas mais avançadas de "bip", como o uso da modulação por largura de pulso para uma reprodução de som PCM de baixa qualidade.</em>  <em>No final deste artigo, fornecerei uma lista de materiais com os quais você pode aprender mais.]</em> </p><br><hr><br><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda parte</a> , quando vários formatos de recursos foram considerados, sugeri que os arquivos <em>.ANH contenham</em> animações para planos de fundo do local (ou seja, para imagens armazenadas em <em>.PIC</em> ).  <em>[É assim.]</em> Depois de terminar o som, decidi dar uma olhada.  Apenas no pressuposto de que a animação é aplicada diretamente à imagem de fundo armazenada na memória (não na <em>memória de vídeo</em> , mas na <em>cadeia de sprites</em> ), decidi despejar essa memória, respectivamente, antes e depois de aplicar a animação (veja onde o cursor aponta para o topo letra da letra 'S'): </p><br><p><img src="https://habrastorage.org/webt/zp/9a/qn/zp9aqnvcvi-gn3pp0t1puzvhpti.gif" width="32%" height="32%"><img src="https://habrastorage.org/webt/jz/9l/ig/jz9ligummo9j_xwwatid-s0vcri.png" width="32%" height="32%"><img src="https://habrastorage.org/webt/sz/pd/uy/szpduyzc7lgsqum_np9sbvrq4qo.png" width="32%" height="32%"></p><br><pre> <code class="markdown hljs">3DE6:0E26 03 B4 44 B3 ... ;   3DE6:0E26 03 BC CC B3 ... ;  </code> </pre> <br><p>  Exatamente o que eu esperava - a cor vermelha escura (0x4) mudou para vermelho brilhante (0xC).  Agora você pode tentar definir o ponto de interrupção para alterar o valor no endereço, por exemplo, <code>3DE6:0E28</code> e, se tiver sorte, realizar um rastreamento reverso.  <em>[Eu tive sorte.]</em> O ponto de interrupção me levou a uma linha que altera diretamente o valor no endereço fornecido: <code>xor es:[bx], al</code> .  Tendo examinado o ambiente, <code>sub_1231E (xor es:[bx], al) &lt;- sub_12222 &lt;- sub_105F6 &lt;- sub_1038F ( )</code> facilmente uma cadeia de chamadas do loop de nível principal até este ponto: <code>sub_1231E (xor es:[bx], al) &lt;- sub_12222 &lt;- sub_105F6 &lt;- sub_1038F ( )</code> . </p><br><p>  Não vou entrar em detalhes sobre exatamente como invertei o processo de animação.  Este é um trabalho bastante rotineiro e metódico, mas não muito difícil se os limites forem claramente delineados (a volta recebida é esses limites).  Mas não posso deixar de falar sobre o que aconteceu no final. </p><br><p>  Primeiro sobre o formato <em>.ANH</em> .  Na verdade, é um conjunto de contêineres e a primeira palavra no arquivo <em>.ANH</em> é o número de contêineres dentro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_hdr_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> anh_entries; <span class="hljs-comment"><span class="hljs-comment">/* first entry hdr */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>;</code> </pre> <br><p>  O contêiner em si é uma animação separada do elemento background.  Você pode selecionar um cabeçalho para o contêiner que contém seu tamanho de byte e o número de quadros na animação que ele representa.  Ao lado do cabeçalho estão os valores da duração (atraso) do próximo quadro e o deslocamento de bytes do próprio quadro, em relação aos bytes do primeiro quadro.  O número de tais pares é obviamente igual ao número de quadros: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_entry_hdr_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> entry_size; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> total_frames; <span class="hljs-comment"><span class="hljs-comment">/* anh_frame_data_t first_frame_data */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* another frames data */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* anh_frame_hdr first_frame_hdr */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* another frames */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_frame_data_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_sleep; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_offset; } <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span> *hdr = (<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>*)anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span> *entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)(anh + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; anh-&gt;anh_entries; u++) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)entry; <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *first_frame_data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)(p + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_bytes = p + (entry-&gt;total_frames * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; entry-&gt;total_frames; k++) { <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *frame_data = first_frame_data + k; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *frame_bytes = first_frame_bytes + frame_data-&gt;frame_offset; ... } <span class="hljs-comment"><span class="hljs-comment">/* plus 2 bytes of padding */</span></span> p += (entry-&gt;entry_size + <span class="hljs-number"><span class="hljs-number">2</span></span>); entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)p; }</code> </pre><br><p>  Um quadro separado é composto por um cabeçalho de quatro bytes que contém suas dimensões e deslocamentos lineares em relação à imagem de plano de fundo e os pixels do quadro codificados pelo algoritmo que já me é familiar pelo <em>Comprimento da Execução</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_frame_hdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bg_x_offt; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bg_y_offt; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_width; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_height; <span class="hljs-comment"><span class="hljs-comment">/* rle encoded frame bytes */</span></span> };</code> </pre> <br><p>  A "sobreposição" do quadro no pano de fundo pode ser assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *level_bg; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_pix[<span class="hljs-number"><span class="hljs-number">8192</span></span>]; anh_frame_hdr *hdr = (anh_frame_hdr*)frame_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_len = hdr-&gt;frame_width * hdr-&gt;frame_height; decode_rle(frame + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(anh_frame_hdr), frame_len, frame_pix); <span class="hljs-comment"><span class="hljs-comment">/* 0xFB4E - some magic value, have no idea what is it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> bg_offt = (hdr-&gt;bg_y_offt * <span class="hljs-number"><span class="hljs-number">152</span></span>) + hdr-&gt;bg_x_offt + <span class="hljs-number"><span class="hljs-number">0xFB4E</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> bg_skip = <span class="hljs-number"><span class="hljs-number">152</span></span> - hdr-&gt;frame_width; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p1 = frame_pix, *p2 = level_bg; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = hdr-&gt;frame_height; i != <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> j = hdr-&gt;frame_width; j != <span class="hljs-number"><span class="hljs-number">0</span></span>; j--) { *p2++ ^= *p1++; } p2 += bg_skip; }</code> </pre> <br><p>  Este é o <em>formato .ANH</em> , mas há outra estrutura que faz tudo funcionar: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bg_animation_control_table_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> total_frames; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_data; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sleep; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> curr_frame; } <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span>;</code> </pre> <br><p>  No próprio jogo, uma matriz de pelo menos quatro estruturas desse tipo é declarada globalmente.  Depois de carregar o próximo arquivo <em>.ANH</em> , o número de animações dentro também é armazenado em uma variável global e os elementos da matriz são inicializados da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *anh; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> g_anim_amount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span> g_anim_ctl[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span> *hdr = (<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>*)anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span> *entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)(anh + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>)); g_anim_amount = hdr-&gt;anh_entries; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; g_anim_amount; u++) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)entry; g_anim_ctl[u].total_frames = entry-&gt;total_frames; g_anim_ctl[u].first_frame_data = p + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>); g_anim_ctl[u].first_frame_bytes = g_anim_ctl[u].first_frame_data + (entry-&gt;total_frames * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>)); g_anim_ctl[u].sleep = *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>*)(g_animation_control[u].first_frame_data); g_anim_ctl[u].curr_frame = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* plus 2 bytes of padding */</span></span> p += (entry-&gt;entry_size + <span class="hljs-number"><span class="hljs-number">2</span></span>); entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)p; }</code> </pre><br><p>  Por fim, aplique as animações: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; g_anim_amount; u++) { <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span> *anim = &amp;g_anim_ctl[u]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (anim-&gt;sleep-- == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)anim-&gt;first_frame_data + anim-&gt;curr_frame; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++anim-&gt;curr_frame == anim-&gt;total_frames) { anim-&gt;curr_frame = <span class="hljs-number"><span class="hljs-number">0</span></span>; data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)anim-&gt;first_frame_data; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data++; } anim-&gt;sleep = data-&gt;frame_sleep; } }</code> </pre> <br><p>  E temos o seguinte <em>[você pode ver muito mais no visualizador de recursos]</em> : </p><br><div class="spoiler">  <b class="spoiler_title">R2.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p7/lv/fn/p7lvfn5ytpjm5nsoctsumdncuaa.gif"></div></div><br><div class="spoiler">  <b class="spoiler_title">R6.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/nb/xp/j6nbxpj29jlrikbmjl8f62s4xmc.gif"></div></div><br><p>  Há alguns problemas com a animação no momento.  A primeira é que, no meu código, reproduzo todas as animações disponíveis, mas o original verifica se há alguns sinalizadores globais indicando se é necessário rolar o próximo.  E a segunda, devido ao fato de que algumas animações adicionam objetos à tela que não estão originalmente lá.  E como os quadros “brigam” no fundo, depois com uma rolagem cíclica, a cada segundo círculo o objeto simplesmente desaparece.  Aqui, por exemplo, como pode parecer: </p><br><div class="spoiler">  <b class="spoiler_title">R53.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d3/5l/iu/d35liujvu6ash9gcdrecvoq9kuc.gif"></div></div><br><p>  Mas, por enquanto, vamos deixar como está. </p><br><hr><br><p>  Lembre-se do algoritmo de descompressão desconhecido da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> ?  Tendo mal conectado ao desenvolvimento, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">viiri</a> não apenas determinou que tipo de algoritmo era, mas também escreveu sua própria versão do decodificador, substituindo a terrível peça de três linhas do Assembler na base de código.  A esse respeito, pedi à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">viiri</a> que escrevesse um pequeno ensaio sobre o trabalho realizado.  O que foi feito, mas antes que eu o cite, algumas palavras precisam ser ditas sobre a teoria. </p><br><p>  Para compactar recursos, os desenvolvedores <em>do Neuromancer</em> usaram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>o código Huffman</em></a> .  Este é um dos primeiros métodos eficazes de codificar informações usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>códigos de prefixo</em></a> .  Na teoria da codificação, códigos com uma palavra de comprimento variável e aqueles nos quais nenhuma palavra de código é um prefixo de outra são chamados códigos de <em>prefixo</em> .  Ou seja, se a palavra <em>"a"</em> estiver incluída no código do prefixo, a palavra <em>"ab"</em> não existe no código.  Essa propriedade permite que você divida exclusivamente em palavras a mensagem codificada por esse código. </p><br><p>  A idéia do algoritmo de Huffman é que, sabendo a probabilidade de ocorrência de caracteres de um determinado alfabeto na mensagem, podemos descrever o procedimento para construir códigos de comprimento variável, consistindo em um número inteiro de bits.  Símbolos com maior probabilidade de ocorrência recebem códigos mais curtos e símbolos com menor probabilidade, pelo contrário, códigos mais longos.  Em geral, o procedimento de codificação é reduzido para construir a árvore de código ideal e, com base em, mapear o símbolo da mensagem para o código correspondente.  A propriedade prefixo do código recebido permite decodificar exclusivamente a mensagem compactada. </p><br><div class="spoiler">  <b class="spoiler_title">Huffman.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fa/is/hb/faishbcvf0flxiao-mfmnx3llvu.gif"></div></div><br><p>  O algoritmo tem uma desvantagem significativa (de fato, não uma, mas agora apenas essa é importante).  O fato é que, para recuperar o conteúdo de uma mensagem compactada, o decodificador deve conhecer a tabela de frequências de ocorrência de caracteres usados ​​pelo codificador.  Nesse sentido, junto com a mensagem codificada, uma tabela de probabilidade ou a própria árvore de códigos (uma opção usada no jogo) devem ser transmitidas.  O tamanho dos dados adicionais pode ser relativamente grande e isso afeta significativamente a eficiência da compactação. </p><br><p>  Algo sobre como você pode lidar com isso, bem como sobre seu decodificador e o que é implementado no jogo, diz ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">viiri</a> : </p><br><blockquote>  Vale ressaltar que todo o jogo foi completamente escrito em Assembler, à mão, para que o código contenha soluções, truques e otimizações interessantes. <br><br>  De acordo com os procedimentos.  A função <code>sub_1ff94</code> ( <code>build_code_table</code> ) é necessária para carregar uma árvore Huffman compactada de um arquivo.  Para decodificar um Huffman estático (às vezes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dinâmico</a> , e esse requisito não se aplica a ele), juntamente com a mensagem, uma árvore de códigos deve ser transmitida, que é um mapeamento de códigos de Huffman para códigos de caracteres reais.  Esta árvore é grande o suficiente e, portanto, seria bom armazená-la de alguma forma eficiente.  A maneira mais correta é usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">códigos canônicos</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MOAR</a> ).  Devido às suas propriedades, existe uma maneira muito interessante e eficaz de armazenar a árvore (usada na implementação do método de compactação <em>Deflate</em> do arquivador <em>PKZip</em> ).  Mas no jogo, os códigos canônicos não são usados; em vez disso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">é</a> realizado um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deslocamento direto da árvore</a> e, para cada vértice, o bit 0 é gravado no fluxo de saída se o nó não for uma folha ou bit 1 se o nó for uma folha e os próximos 8 bits são o código de caractere. nó  Ao decodificar, uma travessia de árvore semelhante é executada, o que vemos no jogo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Há</a> um exemplo e alguma explicação. </blockquote><br><div class="spoiler">  <b class="spoiler_title">build_code_table</b> <div class="spoiler_text"><pre> <code class="hljs sql">build_code_table proc near <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> getbit ;     jb short loc_1FFA9 ;   ... shl dx, 1 inc bx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> build_code_table ;  build_code_table    or dl, 1 <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> build_code_table ;  build_code_table    shr dx, 1 dec bx ret loc_1FFA9: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> sub_1FFC2 ;      (8 ) ... ;     ret sub_1FF94 endp sub_1FFC2 proc near sub di, di mov ch, 8 loc_1FFC6: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> getbit rcl di, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">dec</span></span> ch jnz <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> loc_1FFC6 retn sub_1FFC2 endp</code> </pre> </div></div><br><blockquote>  <code>getbit</code> ( <code>sub_1ffd0</code> ) lê um pouco do fluxo de entrada.  Sua análise nos permite concluir que os bits individuais são extraídos do registro <code>ax</code> 16 bits, cujo valor é carregado da memória pela instrução <code>lodsw</code> , que carrega dois bytes do fluxo, mas como o <em>processador Intel</em> possui ordem de bytes <em>little-endian</em> , o <code>xchg</code> reorganiza metade do registro.  Além disso, a ordem dos bits no fluxo é um tanto ilógica - o primeiro não é o menos, mas o mais significativo.   ,   <code>shl</code>      ,        <code>jb</code> . </blockquote><br><div class="spoiler"> <b class="spoiler_title">getbit</b> <div class="spoiler_text"><pre> <code class="hljs delphi">getbit proc <span class="hljs-keyword"><span class="hljs-keyword">near</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> cl, cl jz short loc_1FFD9 dec cl <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn loc_1FFD9: cmp si, <span class="hljs-number"><span class="hljs-number">27</span></span>B6h jz short loc_1FFE7 ;   lodsw xchg al, ah mov cl, <span class="hljs-number"><span class="hljs-number">0</span></span>Fh <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn loc_1FFE7: call sub_202FC ;      lodsw xchg al, ah mov cl, <span class="hljs-number"><span class="hljs-number">0</span></span>Fh <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn getbit endp</code> </pre> </div></div><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">viiri</a>  ,    : </p><br><div class="spoiler"> <b class="spoiler_title">huffman_decompress</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class">;</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *g_src = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getbits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numbits)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getl_le</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*       4-    */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> node_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> *node = (<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>*)<span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getbits(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { node-&gt;right = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; node-&gt;left = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; node-&gt;value = getbits(<span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { node-&gt;right = build_tree(); node-&gt;left = build_tree(); node-&gt;value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">huffman_decompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> *root, *node; g_src = src; length = getl_le(); node = root = build_tree(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; length) { node = getbits(<span class="hljs-number"><span class="hljs-number">1</span></span>) ? node-&gt;left : node-&gt;right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node-&gt;left) { dst[i++] = node-&gt;value; node = root; } } ... }</code> </pre></div></div><br><p>       : </p><br><blockquote>    <code>build_code_table</code>    .     ,         ,                .     ,                 .     ,           ,    ,       —   (    <code>huffman_decompress</code> ). <br><br>     ? !       !  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,   .       ( <em> </em> ):          . ,         3- ,         <em>N</em>  ,  <em>(3 — N)</em>     . </blockquote><p>       <code>ABCD</code> : <code>A - 0b, B - 10b, C - 110b, D - 111b</code> .       (  ),      ,     : </p><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> <strong>0</strong> 00b </td><td>  1 </td><td> A </td></tr><tr><td> <strong>10</strong> 0b </td><td>  2 </td><td> B </td></tr><tr><td> <strong>110</strong> b </td><td>  3 </td><td>  C </td></tr><tr><td> <strong>111</strong> b </td><td>  3 </td><td> D </td></tr></tbody></table><br><p>       ,               .  , , ,      <code>010b</code> —     .       .  ,   'A'   <code>0b</code> ,     <em> </em>  ,    .     : </p><br><table><thead><tr><th>  </th><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td>  0 0 </td><td> <strong>0</strong> 00b </td><td>  1 </td><td> A </td></tr><tr><td>  1 </td><td> <strong>0</strong> 01b </td><td>  1 </td><td> A </td></tr><tr><td>  2 </td><td> <strong>0</strong> 10b </td><td>  1 </td><td> A </td></tr><tr><td>  3 </td><td> <strong>0</strong> 11b </td><td>  1 </td><td> A </td></tr><tr><td>  4 </td><td> <strong>10</strong> 0b </td><td>  2 </td><td> B </td></tr><tr><td>  5 </td><td> <strong>10</strong> 1b </td><td>  2 </td><td> B </td></tr><tr><td>  6 </td><td> <strong>110</strong> b </td><td>  3 </td><td>  C </td></tr><tr><td>  7 </td><td> <strong>111</strong> b </td><td>  3 </td><td> D </td></tr></tbody></table><br><p> ,    <code>011010111b</code> : </p><br><ul><li>     : <code>011b</code> ; </li><li>  ,   <code>011b (3)</code> ,   <code>A</code> ,     ; </li><li>   <code>011b</code>    1, ,                 : <code>110b</code> ; </li><li>  ,   <code>110b (6)</code> ,   <code></code> ,     ; </li><li>   ,     . </li></ul><br><p>  «»     8- .      256 .          8 .   ,    ,  : </p><br><blockquote>           :      —  ,          .   ,    .   4 —   32- . </blockquote><p>     ,   .  . </p><br><hr><br><p>       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>github</em></a> .     ,       ,     ,   -   <em>[ ,    README.md]</em> . </p><br><p>  ,    ,     2015- : </p><br><ul><li> <em>LibNeuroRoutines (, MASM)</em> — ,       ,    .    ( <code>neuro_routines.h</code> )           ,   .     , : <br><ul><li>   ( <code>huffman_decompression.c</code> , <code>decompression.c</code> ); </li><li>    ( <code>cp437.c</code> ); </li><li>     ( <code>dialog.c</code> ); </li><li>    ( <code>audio.c</code> ). </li></ul></li><li> <em>NeuromancerWin64 ()</em> —     .                .     ,       <em>«»</em> ,    ,       .       <em>CSFML</em> ( <em>SFML</em>   <em>C</em> ). </li><li> <em>ResourceBrowser (C++)</em> —  .    <em>MFC</em> -,         <em>.DAT</em> -.    : <br><ul><li>     <em>BMP (8bpp)</em>  ( <em>IMH</em> , <em>PIC</em> ); </li><li>   ( <em>ANH</em> ); </li><li>     <em>WAV (PCM, 44100Hz, 8bps, mono)</em>  ( <em>SOUND</em> ). </li></ul></li></ul><br><p>    <em>LibNeuroRoutines</em>   .    <em>LibNeuroRoutines</em>  <em>CSFML</em> ( <em>ResourceBrowser</em>   <em>SFML</em>   ). </p><br><p>       64- <em>Windows</em>     .   ,   <em>LibNeuroRoutines</em>  64- <em>MASM (Microsoft Macro Assembler)</em> .   —    ,      64- . ,      <em>NASM</em>  <em>FASM</em> ,    ,             .      <em>VS 2015</em> — <em>MASM</em>   . </p><br><p>      ,   .         <em>C</em> .     ,           (  ,   <em>MFC</em> ). </p><br><p>   ,       .   - ,      . </p><br><hr><br><p>           .  ? ,  .            ,   .    - ,      . ,    ,     ,     .  (). </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Make sound from the speaker using assembly</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programming the PC Speaker</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PC Speaker</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programmable Interval Timer</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Making C Sing</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Beyond Beep-Boop: Mastering the PC Speaker</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417639/">https://habr.com/ru/post/pt417639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417621/index.html">O que aconteceu quando quebramos a exibição?</a></li>
<li><a href="../pt417627/index.html">Hyper CRM ou Mini ERP? Negócios bagunçados</a></li>
<li><a href="../pt417629/index.html">Delphi e C ++ Builder Community Edition</a></li>
<li><a href="../pt417631/index.html">Tutorial em vídeo da grade CSS</a></li>
<li><a href="../pt417637/index.html">Desenvolvimento de um editor para criação de sites / desembarques (experiência)</a></li>
<li><a href="../pt417641/index.html">10 cursos de aprendizado de máquina em verão</a></li>
<li><a href="../pt417643/index.html">Cavaleiros da capa e rootkits: o que ver sobre hackers. Programas de TV</a></li>
<li><a href="../pt417645/index.html">Concurso de programação: negociação (resultados intermediários e anúncios)</a></li>
<li><a href="../pt417647/index.html">Um projeto de lei sobre a proteção de dados pessoais apresentado na Bielorrússia - o que está “dentro” dele</a></li>
<li><a href="../pt417649/index.html">OpenAI supera limitações significativas de IA para Dota 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>