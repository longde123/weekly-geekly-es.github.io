<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ•Ô∏è üßïüèª üëÜ ConfigureAwait, wer ist schuld und was zu tun? ü§µüèæ üé§ üöÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meiner Praxis sehe ich in einer anderen Umgebung h√§ufig Code wie den folgenden: 


[1] var x = FooWithResultAsync(/*...*/).Result; // [2] FooAsync(...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait, wer ist schuld und was zu tun?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463587/"><p>  In meiner Praxis sehe ich in einer <em>anderen</em> Umgebung h√§ufig Code wie den folgenden: </p><br><pre><code class="plaintext hljs">[1] var x = FooWithResultAsync(/*...*/).Result; // [2] FooAsync(/*...*/).Wait(); // [3] FooAsync(/*...*/).GetAwaiter().GetResult(); // [4] FooAsync(/*...*/) .ConfigureAwait(false) .GetAwaiter() .GetResult(); // [5] await FooAsync(/*...*/).ConfigureAwait(false) //  [6] await FooAsync(/*...*/)</code> </pre> <br><p>  Aus der Kommunikation mit den Autoren solcher Zeilen wurde deutlich, dass sie alle in drei Gruppen unterteilt sind: </p><br><ul><li>  Die erste Gruppe sind diejenigen, die nichts √ºber m√∂gliche Probleme beim Aufrufen von <code>Result/Wait/GetResult</code> .  Die Beispiele (1-3) und manchmal (6) sind typisch f√ºr Programmierer aus dieser Gruppe. </li><li>  Die zweite Gruppe umfasst Programmierer, die sich m√∂glicher Probleme bewusst sind, aber die Ursachen ihres Auftretens nicht kennen.  Entwickler aus dieser Gruppe versuchen einerseits, Zeilen wie (1-3 und 6) zu vermeiden, andererseits Missbrauchscode wie (4-5); </li><li>  Die dritte Gruppe, meiner Erfahrung nach die kleinste, sind diejenigen Programmierer, die wissen, wie der Code (1-6) funktioniert, und daher eine fundierte Entscheidung treffen k√∂nnen. </li></ul><br><p>  Ist das Risiko m√∂glich und wie gro√ü es ist, h√§ngt die Verwendung des Codes wie in den obigen Beispielen, wie bereits erw√§hnt, von der <em>Umgebung ab</em> . </p><br><p><img src="https://habrastorage.org/webt/j6/dr/vl/j6drvl4thcu_8wzj5t7qe8o0oew.jpeg"></p><a name="habracut"></a><br><h2 id="riski-i-ih-prichiny">  Risiken und ihre Ursachen </h2><br><p>  Die Beispiele (1-6) sind in zwei Gruppen unterteilt.  Die erste Gruppe ist Code, der den aufrufenden Thread blockiert.  Diese Gruppe umfasst (1-4). <br>  Das Blockieren eines Threads ist meistens eine schlechte Idee.  Warum?  Der Einfachheit halber nehmen wir an, dass alle Threads aus einem Thread-Pool zugeordnet sind.  Wenn das Programm eine Sperre hat, kann dies zur Auswahl aller Threads aus dem Pool f√ºhren.  Im besten Fall verlangsamt dies das Programm und f√ºhrt zu einer ineffizienten Ressourcennutzung.  Im schlimmsten Fall kann dies zu einem Deadlock f√ºhren, wenn ein zus√§tzlicher Thread zum Ausf√ºhren einer Aufgabe ben√∂tigt wird, der Pool ihn jedoch nicht zuordnen kann. <br>  Wenn ein Entwickler Code wie (1-4) schreibt, sollte er dar√ºber nachdenken, wie wahrscheinlich die oben beschriebene Situation ist. </p><br><p>  Aber es wird viel schlimmer, wenn wir in einer Umgebung arbeiten, in der es einen Synchronisationskontext gibt, der sich vom Standard unterscheidet.  Wenn es einen <em>speziellen</em> Synchronisationskontext gibt, erh√∂ht das Blockieren des aufrufenden Threads die Wahrscheinlichkeit, dass ein Deadlock h√§ufig auftritt.  Wenn der Code aus den Beispielen (1-3) im WinForms-UI-Thread ausgef√ºhrt wird, f√ºhrt dies fast garantiert zu einem Deadlock.  Ich schreibe "praktisch" weil  Es gibt eine Option, wenn dies nicht der Fall ist, aber dazu sp√§ter mehr.  Durch Hinzuf√ºgen von <code>ConfigureAwait(false)</code> wie in (4) wird keine 100% ige Garantie f√ºr den Schutz vor Deadlocks gegeben.  Das folgende Beispiel best√§tigt dies: </p><br><pre> <code class="plaintext hljs">[7] //   /  . async Task FooAsync() { // Delay   .     . await Task.Delay(5000); //       RestPartOfMethodCode(); } //  ""  ,   ,  WinForms . private void button1_Click(object sender, EventArgs e) { FooAsync() .ConfigureAwait(false) .GetAwaiter() .GetResult(); button1.Text = "new text"; }</code> </pre> <br><p>  Der Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Paralleles Rechnen - Alles dreht sich um den SynchronizationContext"</a> enth√§lt Informationen zu verschiedenen Synchronisationskontexten. </p><br><p>  Um die Ursache des Deadlocks zu verstehen, m√ºssen Sie den Code der Zustandsmaschine analysieren, in die der Aufruf der asynchronen Methode konvertiert wird, und anschlie√üend den Code der MS-Klassen.  Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async Await und der</a> Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generated StateMachine</a> bieten ein Beispiel f√ºr eine solche Zustandsmaschine. <br>  Ich werde nicht den vollst√§ndigen Quellcode angeben, der zum Beispiel (7) generiert wurde, sondern den Automaten. Ich werde nur die Zeilen anzeigen, die f√ºr die weitere Analyse wichtig sind: </p><br><pre> <code class="plaintext hljs">//  MoveNext. //... //  taskAwaiter    . taskAwaiter = Task.Delay(5000).GetAwaiter(); if(tasAwaiter.IsCompleted != true) { _awaiter = taskAwaiter; _nextState = ...; _builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter, ThisStateMachine&gt;(ref taskAwaiter, ref this); return; }</code> </pre> <br><p>  Die <code>if</code> Verzweigung wird ausgef√ºhrt, wenn der asynchrone Aufruf ( <code>Delay</code> ) noch nicht abgeschlossen ist und daher der aktuelle Thread freigegeben werden kann. <br>  Bitte beachten Sie, dass in <code>AwaitUnsafeOnCompleted</code> taskAwaiter von einem <strong>internen</strong> (relativ zu <code>FooAsync</code> ) asynchronen Aufruf ( <code>Delay</code> ) empfangen wird. </p><br><p>  Wenn Sie in den Dschungel der MS-Quellen <code>AwaitUnsafeOnCompleted</code> , die hinter dem Aufruf von <code>AwaitUnsafeOnCompleted</code> verborgen sind, gelangen wir am Ende zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SynchronizationContextAwaitTaskContinuation-</a> Klasse und ihrer Basisklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AwaitTaskContinuation</a> , in der sich die Antwort auf die Frage befindet. </p><br><p>  Der Code dieser und verwandter Klassen ist ziemlich verwirrend. Um die Wahrnehmung zu erleichtern, erlaube ich mir daher, ein sehr vereinfachtes "Analogon" zu schreiben, aus dem Beispiel (7) wird, aber ohne Zustandsmaschine und in Bezug auf TPL: </p><br><pre> <code class="plaintext hljs">[8] Task FooAsync() { //  methodCompleted    ,  , //    ,     " ". //    ,   methodCompleted.WaitOne()  , //   SetResult  AsyncTaskMethodBuilder, //       . var methodCompleted = new AutoResetEvent(false); SynchronizationContext current = SynchronizationContext.Current; return Task.Delay(5000).ContinueWith( t=&gt; { if(current == null) { RestPartOfMethodCode(methodCompleted); } else { current.Post(state=&gt;RestPartOfMethodCode(methodCompleted), null); methodCompleted.WaitOne(); } }, TaskScheduler.Current); } // // void RestPartOfMethodCode(AutoResetEvent methodCompleted) // { //      FooAsync. // methodCompleted.Set(); // }</code> </pre> <br><p>  In Beispiel (8) ist es wichtig zu beachten, dass bei einem Synchronisationskontext der gesamte Code der asynchronen Methode, der nach Abschluss des internen asynchronen Aufrufs kommt <strong>, √ºber diesen Kontext ausgef√ºhrt wird</strong> (call <code>current.Post(...)</code> ).  Diese Tatsache <strong>ist die Ursache</strong> f√ºr Deadlocks.  Wenn es sich beispielsweise um eine WinForms-Anwendung handelt, wird der darin enthaltene Synchronisationskontext dem UI-Stream zugeordnet.  Wenn der UI-Thread blockiert ist, in Beispiel (7), geschieht dies durch einen Aufruf von <code>.GetResult()</code> , dann kann der Rest des Codes der asynchronen Methode nicht ausgef√ºhrt werden, was bedeutet, dass die asynchrone Methode nicht abgeschlossen werden kann und den UI-Thread nicht freigeben kann Deadlock. </p><br><p>  In Beispiel (7) wurde der Aufruf von <code>FooAsync</code> √ºber <code>ConfigureAwait(false)</code> konfiguriert, dies hat jedoch nicht geholfen.  Tatsache ist, dass Sie genau das <code>AwaitUnsafeOnCompleted</code> konfigurieren m√ºssen, das an <code>AwaitUnsafeOnCompleted</code> wird. In unserem Beispiel ist dies das <code>AwaitUnsafeOnCompleted</code> aus dem <code>Delay</code> .  Mit anderen Worten, in diesem Fall ist es nicht sinnvoll, <code>ConfigureAwait(false)</code> im Clientcode aufzurufen.  Sie k√∂nnen das Problem l√∂sen, wenn der Entwickler der <code>FooAsync</code> Methode es wie folgt √§ndert: </p><br><pre> <code class="plaintext hljs">[9] async Task FooAsync() { await Task.Delay(5000).ConfigureAwait(false); //       RestPartOfMethodCode(); } private void button1_Click(object sender, EventArgs e) { FooAsync().GetAwaiter().GetResult(); button1.Text = "new text"; }</code> </pre> <br><p>  Oben haben wir die Risiken untersucht, die mit dem Code der ersten Gruppe entstehen - dem Code mit Sperre (Beispiele 1-4).  Nun zur zweiten Gruppe (Beispiele 5 und 6) - ein Code ohne Sperren.  In diesem Fall stellt sich die Frage, wann der Aufruf von <code>ConfigureAwait(false)</code> gerechtfertigt ist.  Beim Parsen von Beispiel (7) haben wir bereits herausgefunden, dass wir das wartende Objekt konfigurieren m√ºssen, auf dessen Grundlage die Fortsetzung der Ausf√ºhrung erstellt wird.  Das hei√üt,  Die Konfiguration ist (wenn Sie diese Entscheidung treffen) nur f√ºr <strong>interne</strong> asynchrone Aufrufe erforderlich. </p><br><h2 id="kto-vinovat">  Wer ist schuld? </h2><br><p>  Wie immer lautet die richtige Antwort "alles".  Beginnen wir mit den Programmierern von MS.  Einerseits haben Microsoft-Entwickler entschieden, dass bei Vorhandensein eines Synchronisationskontexts die Arbeit √ºber diesen Kontext ausgef√ºhrt werden sollte.  Und das ist logisch, sonst warum wird es noch gebraucht.  Und wie ich glaube, haben sie erwartet, dass die Entwickler des "Client" -Codes den Hauptthread <strong>nicht</strong> blockieren <strong>w√ºrden</strong> , insbesondere wenn der Synchronisationskontext daran gebunden ist.  Auf der anderen Seite gaben sie ein sehr einfaches Werkzeug, um "sich in den Fu√ü zu schie√üen" - es ist zu einfach und bequem, das Ergebnis durch Blockieren von <code>.Result/.GetResult</code> oder den Stream zu blockieren und auf das <code>.Wait</code> des Anrufs durch <code>.Wait</code> .  Das hei√üt,  MS-Entwickler haben es m√∂glich gemacht, dass die "falsche" (oder gef√§hrliche) Verwendung ihrer Bibliotheken keine Schwierigkeiten verursacht. </p><br><p>  Aber es gibt auch die Schuld an den Entwicklern des "Client" -Codes.  Es besteht darin, dass Entwickler h√§ufig nicht versuchen, ihr Tool zu verstehen und Warnungen zu vernachl√§ssigen.  Und dies ist ein direkter Weg zu Fehlern. </p><br><h2 id="chto-delat">  Was zu tun ist? </h2><br><p>  Unten gebe ich meine Empfehlungen. </p><br><h3 id="dlya-razrabotchikov-klientskogo-koda">  F√ºr Client-Code-Entwickler </h3><br><ol><li>  Geben Sie Ihr Bestes, um ein Blockieren zu vermeiden.  Mit anderen Worten, mischen Sie keinen synchronen und asynchronen Code ohne besondere Notwendigkeit. </li><li>  Wenn Sie eine Sperre durchf√ºhren m√ºssen, bestimmen Sie, in welcher Umgebung der Code ausgef√ºhrt wird: <br><ul><li>  Gibt es einen Synchronisationskontext?  Wenn ja, welches?  Welche Eigenschaften schafft er in seiner Arbeit? </li><li>  Wenn es keinen Synchronisationskontext gibt, dann: Was wird die Last sein?  Wie hoch ist die Wahrscheinlichkeit, dass Ihr Block zu einem "Leck" von Threads aus dem Pool f√ºhrt?  Reicht die Anzahl der zu Beginn erstellten Threads standardm√§√üig aus, oder sollte ich mehr zuweisen? </li></ul></li><li>  Wenn der Code asynchron ist, m√ºssen Sie den asynchronen Aufruf √ºber <code>ConfigureAwait</code> ? </li></ol><br><p>  Treffen Sie eine Entscheidung basierend auf allen erhaltenen Informationen.  M√∂glicherweise m√ºssen Sie Ihren Implementierungsansatz √ºberdenken.  Vielleicht hilft Ihnen <code>ConfigureAwait</code> , oder Sie brauchen es nicht. </p><br><h3 id="dlya-razrabotchikov-bibliotek">  F√ºr Bibliotheksentwickler </h3><br><ol><li>  Wenn Sie glauben, dass Ihr Code von "synchron" aufgerufen werden kann, m√ºssen Sie eine synchrone API implementieren.  Es muss wirklich synchron sein, d.h.  Sie m√ºssen die synchrone API von Bibliotheken von Drittanbietern verwenden. </li><li>  <code>ConfigureAwait(true / false)</code> . </li></ol><br><p>  Hier ist aus meiner Sicht ein subtilerer Ansatz erforderlich als normalerweise empfohlen.  In vielen Artikeln hei√üt es, dass im Bibliothekscode alle asynchronen Aufrufe √ºber <code>ConfigureAwait(false)</code> konfiguriert werden m√ºssen.  Dem kann ich nicht zustimmen.  Aus Sicht der Autoren haben Kollegen von Microsoft m√∂glicherweise die falsche Entscheidung getroffen, als sie das "Standard" -Verhalten in Bezug auf die Arbeit mit dem Synchronisationskontext gew√§hlt haben.  Sie (MS) lie√üen den Entwicklern des "Client" -Codes dennoch die M√∂glichkeit, dieses Verhalten zu √§ndern.  Die Strategie √§ndert das Standardverhalten, wenn der Bibliothekscode vollst√§ndig von <code>ConfigureAwait(false)</code> abgedeckt wird, und, was noch wichtiger ist, dieser Ansatz beraubt Entwickler des "Client" -Codes der Wahl. </p><br><p>  Meine Option besteht darin, bei der Implementierung der asynchronen API jeder API-Methode zwei zus√§tzliche Eingabeparameter hinzuzuf√ºgen: <code>CancellationToken token</code> und <code>bool continueOnCapturedContext</code> .  Und implementieren Sie den Code wie folgt: </p><br><pre> <code class="plaintext hljs">public async Task&lt;string&gt; FooAsync( /*  */, CancellationToken token, bool continueOnCapturedContext) { // ... await Task.Delay(30, token).ConfigureAwait(continueOnCapturedContext); // ... return result; }</code> </pre> <br><p>  Der erste Parameter, <code>token</code> , dient, wie Sie wissen, der M√∂glichkeit einer koordinierten L√∂schung (Bibliotheksentwickler vernachl√§ssigen diese Funktion manchmal).  Mit dem zweiten Befehl <code>continueOnCapturedContext</code> k√∂nnen Sie die Interaktion mit dem Synchronisationskontext interner asynchroner Aufrufe konfigurieren. </p><br><p>  Wenn die asynchrone API-Methode selbst Teil einer anderen asynchronen Methode ist, kann der "Client" -Code gleichzeitig bestimmen, wie er mit dem Synchronisationskontext interagieren soll: </p><br><pre> <code class="plaintext hljs">//     : async Task ClientFoo() { // ""  ClientFoo   ,     //   FooAsync   . await FooAsync( /*  */, ancellationToken.None, false); //     . await FooAsync( /*  */, ancellationToken.None, false).ConfigureAwait(false); //... } // ,  . private void button1_Click(object sender, EventArgs e) { FooAsync( /*  */, _source.Token, false).GetAwaiter().GetResult(); button1.Text = "new text"; }</code> </pre> <br><h2 id="v-kachestve-zaklyucheniya">  Abschlie√üend </h2><br><p>  Die Hauptschlussfolgerung aus dem Vorstehenden sind die folgenden drei Gedanken: </p><br><ol><li>  Schl√∂sser sind meistens die Wurzel allen √úbels.  Es ist das Vorhandensein von Sperren, die im besten Fall zu einer Verschlechterung der Leistung und einer ineffizienten Ressourcennutzung f√ºhren k√∂nnen, im schlimmsten Fall zu einem Deadlock.  √úberlegen Sie, ob dies erforderlich ist, bevor Sie Schl√∂sser verwenden.  Vielleicht gibt es in Ihrem Fall eine andere Art der Synchronisation, die akzeptabel ist. </li><li>  Lernen Sie das Tool kennen, mit dem Sie arbeiten. </li><li>  Wenn Sie Bibliotheken entwerfen, versuchen Sie sicherzustellen, dass ihre korrekte Verwendung einfach, fast intuitiv und die falsche mit Komplexit√§t behaftet ist. </li></ol><br><p>  Ich habe versucht, die mit async / await verbundenen Risiken und die Gr√ºnde f√ºr ihr Auftreten so einfach wie m√∂glich zu erkl√§ren.  Au√üerdem stellte ich meine Vision vor, diese Probleme zu l√∂sen.  Ich hoffe, dass es mir gelungen ist und das Material f√ºr den Leser n√ºtzlich sein wird.  Um besser zu verstehen, wie alles tats√§chlich funktioniert, m√ºssen Sie sich nat√ºrlich auf die Quelle beziehen.  Dies kann √ºber die MS-Repositories auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> oder noch bequemer √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MS-</a> Website selbst erfolgen. </p><br><p>  <em>PS</em> Ich w√§re dankbar f√ºr konstruktive Kritik. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/branding/e54/4c4/1ba/e544c41ba712b412e5347191ba90d0c8.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463587/">https://habr.com/ru/post/de463587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463577/index.html">Plastizit√§t und Festigkeit: Aush√§rtung des Intermetalls ohne Betonung der Versetzung</a></li>
<li><a href="../de463579/index.html">Windows: Finden Sie heraus, wer wo angemeldet ist</a></li>
<li><a href="../de463581/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 23. Erweiterte Routing-Technologien</a></li>
<li><a href="../de463583/index.html">Fantastische Plugins, vol. 1. Theorie</a></li>
<li><a href="../de463585/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 24. IPv6</a></li>
<li><a href="../de463591/index.html">BlueKeep-2 - Alle neuen Windows-Versionen sind jetzt anf√§llig</a></li>
<li><a href="../de463595/index.html">Wir steuern den Fokus oder eine Prise C # und STM32 f√ºr eine Webcam</a></li>
<li><a href="../de463597/index.html">Verwenden der Kontext-API in React zum Erstellen eines reaktionsschnellen Anwendungsdesigns</a></li>
<li><a href="../de463599/index.html">"Dies ist ein Albtraum": Astronauten teilen Meinungen dar√ºber, welche Fehler Hollywood macht, wenn er Filme √ºber den Weltraum dreht</a></li>
<li><a href="../de463601/index.html">Separate Methodenprotokollierung in Java / Logback</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>