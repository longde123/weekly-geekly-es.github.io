<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥” ğŸ¤¹ğŸ¾ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ Menguji proyek Node.js. Bagian 2. Tes evaluasi kinerja, integrasi berkelanjutan dan analisis kualitas kode ğŸ˜ ğŸ–ï¸ â—½ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="â†’ Menguji proyek Node.js. Bagian 1. Tes anatomi dan jenis tes 

 Hari ini, di bagian kedua dari terjemahan materi yang dikhususkan untuk menguji proye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji proyek Node.js. Bagian 2. Tes evaluasi kinerja, integrasi berkelanjutan dan analisis kualitas kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/435464/">  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menguji proyek Node.js.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Tes anatomi dan jenis tes</a> <br><br>  Hari ini, di bagian kedua dari terjemahan materi yang dikhususkan untuk menguji proyek Node.js, kita akan berbicara tentang mengevaluasi efektivitas tes dan menganalisis kualitas kode. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f16/1a0/3e2/f161a03e2b08ae35b31f718a083a39a0.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bagian 3. Evaluasi keefektifan tes</font> </h2><br><h3>  <font color="#3AC1EF">â–19.</font>  <font color="#3AC1EF">Mencapai tingkat cakupan kode yang cukup tinggi dengan pengujian untuk mendapatkan kepercayaan dalam operasi yang benar.</font>  <font color="#3AC1EF">Biasanya cakupan sekitar 80% memberikan hasil yang baik.</font> </h3><br><h4>  Rekomendasi </h4><br>  Tujuan pengujian adalah untuk memastikan bahwa programmer dapat terus bekerja secara produktif pada proyek, memastikan bahwa apa yang telah dilakukan sudah benar.  Jelas, semakin besar volume kode yang diuji, semakin kuat keyakinan bahwa semuanya berfungsi sebagaimana mestinya.  Indikator jangkauan kode dengan tes menunjukkan berapa banyak baris (cabang, perintah) diperiksa oleh tes.  Apa yang seharusnya indikator ini?  Jelas bahwa 10-30% terlalu sedikit untuk memberi keyakinan bahwa proyek akan bekerja tanpa kesalahan.  Di sisi lain, keinginan untuk cakupan 100% dari kode dengan tes bisa menjadi terlalu mahal dan dapat mengalihkan pengembang dari fragmen program yang paling penting, memaksanya untuk mencari di kode tempat-tempat yang tidak terjangkau oleh tes yang ada.  Jika Anda memberikan jawaban yang lebih lengkap untuk pertanyaan tentang apa yang harus menjadi cakupan kode dengan tes, maka kita dapat mengatakan bahwa indikator yang harus kita perjuangkan tergantung pada aplikasi yang dikembangkan.  Misalnya, jika Anda menulis perangkat lunak untuk Airbus A380 generasi berikutnya, maka 100% adalah indikator yang bahkan tidak dibahas.  Tetapi jika Anda membuat situs web di mana galeri karikatur akan ditampilkan, maka mungkin 50% sudah banyak.  Meskipun ahli pengujian mengatakan bahwa tingkat cakupan kode dengan tes yang harus Anda tuju tergantung pada proyek, banyak dari mereka menyebutkan angka 80%, yang mungkin cocok untuk sebagian besar aplikasi.  Sebagai contoh, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> kita berbicara tentang sesuatu di wilayah 80-90%, dan, menurut penulis materi ini, cakupan 100% dari kode dengan tes membuatnya curiga, karena itu mungkin menunjukkan bahwa programmer menulis tes hanya untuk mendapatkan angka yang indah dalam laporan. <br><br>  Untuk menggunakan indikator tes cakupan kode, Anda harus mengkonfigurasi sistem Anda dengan benar untuk integrasi berkelanjutan (CI, Integrasi Berkelanjutan).  Ini akan memungkinkan, jika indikator yang sesuai tidak mencapai ambang tertentu, untuk menghentikan perakitan proyek.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut cara</a> mengkonfigurasi Jest untuk mengumpulkan informasi cakupan tes.  Selain itu, Anda dapat mengonfigurasi batas cakupan bukan untuk seluruh kode, tetapi memfokuskan pada komponen individual.  Selain itu, pertimbangkan mendeteksi penurunan cakupan tes.  Ini terjadi, misalnya, ketika menambahkan kode baru ke proyek.  Kontrol indikator ini akan mendorong pengembang untuk meningkatkan volume kode yang diuji, atau setidaknya untuk mempertahankan volume ini pada level yang ada.  Dalam pandangan di atas, cakupan kode dengan pengujian hanya satu indikator, terkuantifikasi, yang tidak cukup untuk sepenuhnya mengevaluasi keandalan pengujian.  Selain itu, seperti yang akan ditunjukkan di bawah, levelnya yang tinggi belum berarti bahwa kode â€œditutupi dengan tesâ€ benar-benar diperiksa. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Keyakinan programmer pada kualitas tinggi kode dan indikator terkait yang terkait dengan pengujian berjalan seiring.  Seorang programmer tidak bisa tidak takut akan kesalahan jika dia tidak tahu bahwa sebagian besar kode dalam proyeknya dicakup oleh tes.  Kekhawatiran ini dapat memperlambat proyek Anda. <br><br><h4>  Contoh </h4><br>  Begini seperti apa laporan cakupan pengujian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96b/951/4fc/96b9514fc0e5d96553a4fc8551793d27.png"></div><br>  <i><font color="#999999">Laporan cakupan tes yang dihasilkan oleh Istanbul</font></i> <br><br><h4>  Pendekatan yang benar </h4><br>  Berikut adalah contoh pengaturan tingkat cakupan uji yang diinginkan dari kode komponen dan tingkat umum indikator ini di Jest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/feb/473/e23feb47399296324bb96b2109d4b360.jpg"></div><br>  <i><font color="#999999">Mengatur tingkat cakupan kode yang diinginkan dengan tes untuk seluruh proyek dan untuk komponen tertentu</font></i> <br><br><h3>  <font color="#3AC1EF">â–20.</font>  <font color="#3AC1EF">Periksa laporan cakupan kode dengan tes untuk mengidentifikasi bagian kode yang tidak terlindungi dan anomali lainnya</font> </h3><br><h4>  Rekomendasi </h4><br>  Beberapa masalah cenderung menyelinap melalui berbagai sistem deteksi kesalahan.  Hal-hal seperti itu bisa sulit dideteksi menggunakan alat tradisional.  Mungkin ini tidak berlaku untuk kesalahan nyata.  Sebaliknya, kita berbicara tentang perilaku aplikasi yang tidak terduga, yang dapat memiliki konsekuensi yang menghancurkan.  Misalnya, sering terjadi bahwa beberapa fragmen kode tidak pernah digunakan atau jarang dipanggil.  Misalnya, Anda berpikir bahwa mekanisme kelas <code>PricingCalculator</code> selalu digunakan untuk menetapkan harga suatu produk, tetapi ternyata kelas ini tidak digunakan sama sekali, dan ada catatan 10.000 produk dalam database, dan di toko online tempat sistem tersebut digunakan, banyak penjualan ... Laporan tentang cakupan kode dengan tes membantu pengembang memahami jika aplikasi berfungsi sebagaimana mestinya.  Selain itu, dari laporan Anda dapat mengetahui kode proyek mana yang tidak diuji.  Jika Anda fokus pada indikator umum yang menunjukkan bahwa pengujian mencakup 80% dari kode, Anda tidak dapat mengetahui apakah bagian-bagian penting dari aplikasi sedang diuji.  Untuk menghasilkan laporan seperti itu, cukup dengan mengkonfigurasi alat yang Anda gunakan untuk menjalankan tes dengan benar.  Laporan seperti itu biasanya terlihat sangat cantik, dan analisisnya, yang tidak memakan banyak waktu, memungkinkan Anda untuk mendeteksi segala macam kejutan. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Jika Anda tidak tahu tentang bagian mana dari kode Anda yang belum diuji, maka Anda tidak tahu di mana Anda bisa mendapatkan masalah. <br><br><h4>  Pendekatan yang salah </h4><br>  Lihatlah laporan berikutnya dan pikirkan tentang apa yang tampak tidak biasa di dalamnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/883/889/1ce88388923499c997c6fdc4606d3c10.png"></div><br>  <i><font color="#999999">Laporan yang menunjukkan perilaku sistem yang tidak biasa</font></i> <br><br>  Laporan ini didasarkan pada skenario penggunaan aplikasi nyata dan memungkinkan Anda untuk melihat perilaku program yang tidak biasa terkait dengan pengguna yang masuk ke sistem.  Yaitu, sejumlah besar upaya tidak berhasil yang gagal untuk memasuki sistem menarik perhatian Anda dibandingkan dengan yang sukses.  Setelah menganalisis proyek, ternyata alasan untuk ini adalah kesalahan di frontend, karena bagian antarmuka proyek terus-menerus mengirimkan permintaan yang sesuai ke server API untuk memasuki sistem. <br><br><h3>  <font color="#3AC1EF">â–21.</font>  <font color="#3AC1EF">Ukur cakupan kode logis dengan tes menggunakan pengujian mutasi</font> </h3><br><h4>  Rekomendasi </h4><br>  Metrik tolok ukur tradisional mungkin tidak dapat diandalkan.  Jadi, dalam laporan itu bisa ada angka 100%, tetapi pada saat yang sama, benar-benar semua fungsi proyek akan mengembalikan nilai yang salah.  Bagaimana menjelaskannya?  Faktanya adalah bahwa indikator cakupan kode dengan tes hanya menunjukkan baris kode mana yang dieksekusi di bawah kendali sistem pengujian, tetapi tidak tergantung pada apakah sesuatu telah benar-benar diverifikasi, yaitu, pada apakah ada pernyataan pengujian ditujukan untuk memeriksa kebenaran hasil kode.  Ini menyerupai seseorang yang, kembali dari perjalanan bisnis ke luar negeri, menunjukkan perangko di paspornya.  Perangko membuktikan bahwa dia pergi ke suatu tempat, tetapi mereka tidak mengatakan apa-apa tentang apakah dia melakukan apa yang dia lakukan dalam perjalanan bisnis. <br><br>  Di sini, tes mutasi dapat membantu kami, yang memungkinkan kami untuk mengetahui berapa banyak kode yang benar-benar diuji, dan tidak hanya dikunjungi oleh sistem pengujian.  Untuk pengujian mutasi, Anda dapat menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stryker</a> JS.  Berikut adalah prinsip-prinsip yang digunakannya: <br><br><ol><li>  Dia sengaja mengubah kode, membuat kesalahan di dalamnya.  Misalnya, kode <code>newOrder.price===0</code> berubah menjadi <code>newOrder.price!=0</code> .  "Kesalahan" ini disebut mutasi. </li><li>  Dia menjalankan tes.  Jika mereka ternyata lulus, maka kita memiliki masalah, karena tes tidak memenuhi tugas mereka mendeteksi kesalahan, dan "mutan", seperti yang mereka katakan, "bertahan".  Jika tes menunjukkan kesalahan dalam kode, maka semuanya dalam urutan - "mutan" "mati". </li></ol><br>  Jika ternyata semua "mutan" "terbunuh" (atau, paling tidak, sebagian besar dari mereka tidak bertahan hidup), ini memberikan tingkat kepercayaan yang lebih tinggi pada kualitas tinggi kode dan tes yang mengujinya daripada metrik tradisional untuk menutup kode dengan tes.  Pada saat yang sama, waktu yang diperlukan untuk mengonfigurasi dan melakukan pengujian mutasi sebanding dengan yang diperlukan saat menggunakan tes konvensional. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Jika indikator tradisional cakupan kode oleh tes menunjukkan bahwa 85% dari kode dicakup oleh tes, ini tidak berarti bahwa tes dapat mendeteksi kesalahan dalam kode ini. <br><br><h4>  Pendekatan yang salah </h4><br>  Berikut adalah contoh cakupan 100% dari kode dengan tes, di mana kode sama sekali tidak diuji. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newOrder</span></span></span><span class="hljs-function">) </span></span>{   logger.log(<span class="hljs-string"><span class="hljs-string">`Adding new order </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   DB.save(newOrder);   Mailer.sendMail(newOrder.assignee, <span class="hljs-string"><span class="hljs-string">`A new order was places </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">approved</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } it(<span class="hljs-string"><span class="hljs-string">"Test addNewOrder, don't use such test names"</span></span>, () =&gt; {   addNewOrder({<span class="hljs-attr"><span class="hljs-attr">asignee</span></span>: <span class="hljs-string"><span class="hljs-string">"John@mailer.com"</span></span>,<span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>}); });<span class="hljs-comment"><span class="hljs-comment">//    100%, ,   ,    </span></span></code> </pre> <br><h4>  Pendekatan yang benar </h4><br>  Berikut ini adalah laporan uji mutasi yang dihasilkan oleh perpustakaan Stryker.  Ini memungkinkan Anda untuk mengetahui berapa banyak kode yang tidak diuji (ini ditunjukkan oleh jumlah "yang bertahan" "mutan"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/f6c/9c0/037f6c9c038e09d219c1d06a1b255e4c.jpg"></div><br>  <i><font color="#999999">Laporan Stryker</font></i> <br><br>  Hasil laporan ini memungkinkan dengan keyakinan lebih dari indikator cakupan kode biasa dengan tes untuk mengatakan bahwa tes bekerja seperti yang diharapkan. <br><br><ul><li>  Mutasi adalah kode yang sengaja dimodifikasi oleh perpustakaan Stryker untuk menguji efektivitas tes. </li><li>  Jumlah "terbunuh" "mutan" (terbunuh) menunjukkan jumlah cacat kode yang sengaja dibuat ("mutan") yang diidentifikasi selama pengujian. </li><li>  Jumlah "selamat" "mutan" (selamat) memungkinkan Anda untuk mengetahui berapa banyak tes cacat kode belum ditemukan. </li></ul><br><h2>  <font color="#3AC1EF">Bagian 4. Integrasi Berkelanjutan, Indikator Kualitas Kode Lainnya</font> </h2><br><h3>  <font color="#3AC1EF">â– 22.</font>  <font color="#3AC1EF">Manfaatkan kemampuan linter dan sela proses pembangunan proyek ketika mendeteksi masalah yang mereka laporkan</font> </h3><br><h4>  Rekomendasi </h4><br>  Saat ini, linter adalah alat yang ampuh yang dapat mengidentifikasi masalah kode serius.  Disarankan, selain beberapa aturan dasar linting (seperti yang diterapkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint-plugin-standard</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint-config-airbnb plugins</a> ), gunakan aturan khusus.  Sebagai contoh, ini adalah aturan yang diterapkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin eslint-plugin-chai-expect</a> untuk memverifikasi kebenaran kode tes, ini adalah aturan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin eslint-plugin-janji</a> yang mengontrol pekerjaan dengan janji, ini adalah aturan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint-plugin-keamanan</a> yang memeriksa kode untuk kehadiran itu berisi ekspresi reguler yang berbahaya.  Di sini Anda juga dapat menyebutkan plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint-plugin-you-dont-need-lodash-garis bawah</a> , yang memungkinkan Anda untuk menemukan dalam kode penggunaan metode dari perpustakaan eksternal yang memiliki analog dalam JavaScript murni. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Suatu hari hujan telah tiba, proyek memberikan kegagalan terus menerus dalam produksi, dan tidak ada informasi tentang tumpukan kesalahan dalam log.  Apa yang terjadi  Ternyata, apa yang dilemparkan kode sebagai pengecualian bukanlah objek kesalahan.  Akibatnya, informasi tentang tumpukan tidak masuk ke log.  Sebagai soal fakta, dalam situasi seperti itu, programmer dapat membunuh dinding atau, lebih baik, menghabiskan 5 menit menyiapkan linter, yang akan dengan mudah mendeteksi masalah dan memastikan proyek dari masalah serupa yang mungkin timbul di masa depan. <br><br><h4>  Pendekatan yang salah </h4><br>  Berikut adalah kode yang, secara tidak sengaja, melempar objek biasa sebagai pengecualian, sementara di sini Anda memerlukan objek tipe <code>Error</code> .  Jika tidak, data tentang tumpukan tidak akan masuk ke log.  ESLint menemukan apa yang dapat menyebabkan masalah produksi, membantu menghindari masalah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6a/d40/bc0/d6ad40bc0f5e0c09840e3b52e2b878a6.jpg"></div><br>  <i><font color="#999999">ESLint membantu Anda menemukan bug dalam kode Anda</font></i> <br><br><h3>  <font color="#3AC1EF">â–23.</font>  <font color="#3AC1EF">Umpan Balik Lebih Cepat dengan Pengembang Menggunakan Integrasi Berkelanjutan Lokal</font> </h3><br><h4>  Rekomendasi </h4><br>  Menggunakan sistem integrasi terpusat yang terpusat, yang membantu mengontrol kualitas kode, mengujinya, menggunakan linter, memeriksa kerentanannya?  Jika demikian, pastikan pengembang dapat menjalankan sistem ini secara lokal.  Ini akan memungkinkan mereka untuk langsung memeriksa kode mereka, yang mempercepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">umpan balik</a> dan mengurangi waktu pengembangan proyek.  Kenapa begitu?  Proses pengembangan dan pengujian yang efektif melibatkan banyak operasi berulang yang berulang.  Kode diuji, kemudian pengembang menerima laporan, lalu, jika perlu, kode tersebut direaktor, setelah itu semuanya diulang.  Semakin cepat loop umpan balik bekerja, semakin cepat pengembang menerima laporan tentang pengujian kode, semakin banyak iterasi peningkatan kode ini yang dapat mereka lakukan.  Jika membutuhkan banyak waktu untuk mendapatkan laporan pengujian, ini dapat menyebabkan kualitas kode yang buruk.  Katakanlah seseorang sedang mengerjakan beberapa modul, kemudian mulai mengerjakan sesuatu yang lain, kemudian menerima laporan tentang modul, yang menunjukkan bahwa modul perlu ditingkatkan.  Namun, sudah sibuk dengan hal-hal yang sama sekali berbeda, pengembang tidak akan cukup memperhatikan modul masalah. <br><br>  Beberapa penyedia solusi CI (katakanlah ini berlaku untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CircleCI</a> ) memungkinkan Anda menjalankan pipa CI secara lokal.  Beberapa alat berbayar, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wallaby.js</a> (penulis mencatat bahwa ia tidak terhubung dengan proyek ini), dapat dengan cepat mendapatkan informasi berharga tentang kualitas kode.  Selain itu, pengembang hanya dapat menambahkan skrip npm yang sesuai ke <code>package.json</code> , yang melakukan pemeriksaan kualitas kode (tes, analisis dengan linter, mencari kerentanan), dan bahkan menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bersamaan</a> untuk mempercepat pemeriksaan.  Sekarang, untuk memeriksa kode secara komprehensif, itu akan cukup untuk menjalankan satu perintah, seperti <code>npm run quality</code> , dan segera mendapatkan laporan.  Selain itu, jika tes kode menunjukkan bahwa ia memiliki masalah, Anda dapat membatalkan komit menggunakan kait git (perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">husky</a> dapat berguna untuk menyelesaikan masalah ini). <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Jika pengembang menerima laporan tentang kualitas kode sehari setelah menulis kode ini, laporan seperti itu kemungkinan akan berubah menjadi seperti dokumen formal, dan tes kode akan dipisahkan dari pekerjaan, tidak menjadi bagian alami. <br><br><h4>  Pendekatan yang benar </h4><br>  Berikut ini adalah skrip npm yang memeriksa kualitas kode.  Melakukan pemeriksaan diparalelkan.  Script dieksekusi ketika mencoba mengirim kode baru ke repositori.  Selain itu, pengembang dapat meluncurkannya atas inisiatifnya sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"inspect:sanity-testing"</span></span>: <span class="hljs-string"><span class="hljs-string">"mocha **/**--test.js --grep \"sanity\""</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:lint"</span></span>: <span class="hljs-string"><span class="hljs-string">"eslint ."</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:vulnerabilities"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm audit"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:license"</span></span>: <span class="hljs-string"><span class="hljs-string">"license-checker --failOn GPLv2"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:complexity"</span></span>: <span class="hljs-string"><span class="hljs-string">"plato ."</span></span>,     <span class="hljs-string"><span class="hljs-string">"inspect:all"</span></span>: <span class="hljs-string"><span class="hljs-string">"concurrently -c \"bgBlue.bold,bgMagenta.bold,yellow\" \"npm:inspect:quick-testing\" \"npm:inspect:lint\" \"npm:inspect:vulnerabilities\" \"npm:inspect:license\""</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>,     <span class="hljs-string"><span class="hljs-string">"prepush"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>   } }</code> </pre> <br><h3>  <font color="#3AC1EF">â–24.</font>  <font color="#3AC1EF">Lakukan pengujian ujung ke ujung pada cermin lingkungan produksi yang realistis</font> </h3><br><h4>  Rekomendasi </h4><br>  Dalam ekosistem Kubernetes yang luas, masih ada konsensus untuk menggunakan alat yang cocok untuk menyebarkan lingkungan lokal, meskipun alat tersebut cukup sering muncul.  Salah satu pendekatan yang mungkin di sini adalah menjalankan Kubernet yang â€œdiperkecilâ€ menggunakan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minikube</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MicroK8s</a> , yang memungkinkan Anda untuk menciptakan lingkungan yang ringan yang menyerupai yang asli.  Pendekatan lain adalah menguji proyek di lingkungan Kubernetes "nyata" yang terpencil.  Beberapa penyedia CI (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codefresh</a> ) memungkinkan untuk berinteraksi dengan lingkungan bawaan Kubernetes, yang menyederhanakan pekerjaan pipa CI saat menguji proyek dunia nyata.  Yang lain memungkinkan Anda untuk bekerja dengan lingkungan Kubernetes yang jauh. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Penggunaan berbagai teknologi dalam produksi dan pengujian membutuhkan dukungan dari dua model pengembangan dan mengarah pada pemisahan tim pemrogram dan spesialis DevOps. <br><br><h4>  Pendekatan yang benar </h4><br>  Berikut ini adalah contoh dari rantai CI, yang, seperti yang mereka katakan, dengan cepat menciptakan cluster Kubernetes (ini diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ). <br><br><pre> <code class="javascript hljs">deploy: stage: deploy image: registry.gitlab.com/gitlab-examples/kubernetes-deploy script: - ./configureCluster.sh $KUBE_CA_PEM_FILE $KUBE_URL $KUBE_TOKEN - kubectl create ns $NAMESPACE - kubectl create secret -n $NAMESPACE docker-registry gitlab-registry --docker-server=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY"</span></span> --docker-username=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_USER"</span></span> --docker-password=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_PASSWORD"</span></span> --docker-email=<span class="hljs-string"><span class="hljs-string">"$GITLAB_USER_EMAIL"</span></span> - mkdir .generated - echo <span class="hljs-string"><span class="hljs-string">"$CI_BUILD_REF_NAME-$CI_BUILD_REF"</span></span> - sed -e <span class="hljs-string"><span class="hljs-string">"s/TAG/$CI_BUILD_REF_NAME-$CI_BUILD_REF/g"</span></span> templates/deals.yaml | tee <span class="hljs-string"><span class="hljs-string">".generated/deals.yaml"</span></span> - kubectl apply --namespace $NAMESPACE -f .generated/deals.yaml - kubectl apply --namespace $NAMESPACE -f templates/my-sock-shop.yaml environment: name: test-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-ci</code> </pre> <br><h3>  <font color="#3AC1EF">â–25.</font>  <font color="#3AC1EF">Berusaha untuk memparalelkan pelaksanaan pengujian</font> </h3><br><h4>  Rekomendasi </h4><br>  Jika sistem pengujian terorganisir dengan baik, itu akan menjadi teman setia Anda, 24 jam sehari siap melaporkan masalah dengan kode.  Untuk melakukan ini, tes harus dilakukan dengan sangat cepat.  Dalam praktiknya, ternyata menjalankan dalam mode single-threaded 500 unit tes yang menggunakan prosesor secara intensif membutuhkan terlalu banyak waktu.  Dan tes semacam itu perlu dilakukan cukup sering.  Untungnya, alat modern untuk menjalankan tes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jest</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVA</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi untuk Mocha</a> ) dan platform CI dapat menjalankan tes secara paralel menggunakan beberapa proses, yang secara signifikan dapat meningkatkan kecepatan menerima laporan pengujian.  Beberapa platform CI bahkan tahu bagaimana memparalelkan pengujian antar wadah, yang selanjutnya meningkatkan loop umpan balik.  Agar berhasil melakukan paralelisasi terhadap pengujian, lokal atau jarak jauh, pengujian tidak boleh saling bergantung.  Tes mandiri dapat dijalankan dalam proses yang berbeda tanpa masalah. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Mendapatkan hasil pengujian satu jam setelah mengirim kode ke repositori saat mengerjakan fitur proyek baru adalah cara yang bagus untuk mengurangi kegunaan hasil pengujian. <br><br><h4>  Pendekatan yang benar </h4><br>  Berkat pelaksanaan tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paralel,</a> perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mocha-parallel-test</a> dan kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jest</a> mudah memotong Mocha ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini adalah</a> sumber informasi ini). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5f/aa2/e8e/c5faa2e8ee900ae5d3447d510bc1bf8f.png"></div><br>  <i><font color="#999999">Uji alat pengujian kinerja</font></i> <br><br><h3>  <font color="#3AC1EF">â–26.</font>  <font color="#3AC1EF">Lindungi diri Anda dari masalah hukum dengan menggunakan verifikasi lisensi dan verifikasi kode plagiarisme</font> </h3><br><h4>  Rekomendasi </h4><br>  Mungkin sekarang Anda tidak terlalu khawatir tentang masalah dengan hukum dan plagiarisme.  Namun, mengapa tidak memeriksa proyek Anda untuk masalah yang sama?  Ada banyak alat yang tersedia untuk mengatur inspeksi semacam itu.  Sebagai contoh, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemeriksa lisensi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemeriksa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plagiarisme</a> (ini adalah paket komersial, tetapi ada kemungkinan penggunaannya gratis).  Mudah untuk mengintegrasikan pemeriksaan semacam itu ke dalam pipa CI dan memeriksa proyek, misalnya, untuk keberadaan dependensi dengan lisensi terbatas, atau untuk keberadaan kode yang disalin dari StackOverflow dan mungkin melanggar hak cipta orang lain. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Pengembang, secara tidak sengaja, dapat menggunakan paket dengan lisensi yang tidak cocok untuk proyeknya, atau menyalin kode komersial, yang dapat menyebabkan masalah hukum. <br><br><h4>  Pendekatan yang benar </h4><br>  Instal paket pemeriksa lisensi secara lokal atau dalam lingkungan CI: <br><br><pre> <code class="javascript hljs">npm install -g license-checker</code> </pre> <br>  Kami akan memeriksa lisensinya, dan jika dia menemukan sesuatu yang tidak sesuai dengan kami, kami akan menganggap cek itu tidak berhasil.  Sistem CI, setelah mendeteksi bahwa ada masalah ketika memeriksa lisensi, akan menghentikan perakitan proyek. <br><br><pre> <code class="javascript hljs">license-checker --summary --failOn BSD</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/791/cde/326/791cde326f7185df4c78479ef4ab5757.png"></div><br>  <i><font color="#999999">Pemeriksaan Lisensi</font></i> <br><br><h3>  <font color="#3AC1EF">â–27.</font>  <font color="#3AC1EF">Terus memeriksa proyek untuk dependensi rentan</font> </h3><br><h4>  Rekomendasi </h4><br>  Bahkan paket yang sangat dihormati dan andal, seperti Express, memiliki kerentanan.  Untuk mengidentifikasi kerentanan semacam itu, Anda dapat menggunakan alat khusus - seperti alat standar untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengaudit paket npm</a> atau proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snyk</a> komersial, yang memiliki versi gratis.  Pemeriksaan ini, bersama dengan yang lain, dapat menjadi bagian dari pipa CI. <br><br><h4>  Konsekuensi Penyimpangan dari Rekomendasi </h4><br>  Untuk melindungi proyek Anda dari kerentanan ketergantungannya tanpa menggunakan alat khusus, Anda harus terus memantau publikasi tentang kerentanan tersebut.  Ini adalah tugas yang sangat memakan waktu. <br><br><h4>  Pendekatan yang benar </h4><br>  Berikut adalah hasil verifikasi proyek menggunakan NPM Audit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/da1/3a9/9d5da13a900a066fbc6c15aba2cc0a0d.png"></div><br>  <i><font color="#999999">Laporan Paket Periksa Kerentanan</font></i> <br><br><h3>  <font color="#3AC1EF">â–28.</font>  <font color="#3AC1EF">Otomatis pembaruan ketergantungan</font> </h3><br><h4>  Rekomendasi </h4><br>  Jalan menuju neraka ditaburi dengan niat baik.  Ide ini sepenuhnya berlaku untuk file <code>package-lock.json</code> , yang penggunaannya, secara default, memblokir pembaruan paket.  Ini terjadi bahkan dalam kasus ketika proyek dibawa ke keadaan sehat oleh perintah <code>npm install</code> dan <code>npm update</code> .  Hal ini mengarah, paling baik, ke penggunaan paket yang sudah ketinggalan zaman, atau, paling buruk, ke tampilan kode rentan dalam proyek.  Tim pengembangan, sebagai akibatnya, bergantung pada pembaruan manual informasi tentang versi paket yang sesuai, atau pada utilitas seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ncu</a> , yang, sekali lagi, diluncurkan secara manual.  Proses memperbarui dependensi adalah yang terbaik secara otomatis, dengan fokus pada penggunaan versi yang paling dapat diandalkan dari paket yang digunakan dalam proyek.  Ini bukan satu-satunya solusi yang tepat, namun, dalam mengotomatisasi pembaruan paket, ada beberapa pendekatan yang patut diperhatikan.  Yang pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyuntikkan</a> sesuatu seperti memeriksa paket menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm-outdated</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm-check-updates</a> (ncu) ke dalam pipa CI.  Ini akan membantu mengidentifikasi paket-paket usang dan mendorong pengembang untuk memutakhirkannya.  Pendekatan kedua adalah menggunakan alat komersial yang memeriksa kode dan secara otomatis membuat permintaan tarik yang bertujuan memperbarui dependensi.  Di bidang pembaruan ketergantungan otomatis, kami dihadapkan dengan pertanyaan menarik lainnya mengenai kebijakan pembaruan.  Jika diperbarui dengan masing-masing tambalan baru, pembaruan tersebut dapat memberi terlalu banyak tekanan pada sistem.  Jika Anda memperbarui segera setelah rilis versi utama berikutnya dari paket, ini dapat menyebabkan penggunaan solusi yang tidak stabil dalam proyek (kerentanan dalam banyak paket ditemukan pada hari-hari pertama setelah rilis, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baca</a> tentang insiden dengan eslint-scope).         Â« Â»,             ,    . ,      1.3.1,             1.3.2,      1.3.8. <br><br><h4>     </h4><br>       ,    ,        ,     . <br><br><h4>   </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ncu</a>     ,   ,   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/b2a/dcf/e6eb2adcf8720657a4e5c09c34691704.png"></div><br> <i><font color="#999999">   ncu</font></i> <br><br><h3> <font color="#3AC1EF">â–29.        ,     Node.js</font> </h3><br><h4>  </h4><br>       ,     Node.js-,     ,   Node.js  . <br><br><ol><li>   .     â€”   , , ,    Jenkins      . </li><li>  ,  Docker. </li><li>       . ,    ,      .    (,    ),       , ,  ,     . </li><li>   ,    ,      ,    .  â€”   ,    ,   ,      . </li><li>     ,     . ,          feature,    â€”   master, ,                 (   ). </li><li>        .        ,    . </li><li>     . </li><li>         (,     Docker)  . </li><li>     , ,  ,  . ,        <code>node_modules</code> . </li></ol><br><h4>     </h4><br>      ,     ,     . <br><br><h3> <font color="#3AC1EF">â–30.    </font> </h3><br><h4>  </h4><br>      ,      .     ,      , ,    Node.js    ,            .  CI-,    ,    Â« Â». ,      ,    ,   . , ,      mySQL,   â€” Postgres.   ,        Node.js,  â€” 8, 9  10.          ,     .     CI-. <br><br><h4>     </h4><br>         ,     ,    ,      . ,  ,     . <br><br><h4>   </h4><br>    CI- Travis        Node.js. <br><br><pre> <code class="javascript hljs">language: node_js node_js: - <span class="hljs-string"><span class="hljs-string">"7"</span></span> - <span class="hljs-string"><span class="hljs-string">"6"</span></span> - <span class="hljs-string"><span class="hljs-string">"5"</span></span> - <span class="hljs-string"><span class="hljs-string">"4"</span></span> install: - npm install script: - npm run test</code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>      ,    ,       . ,   ,     . <br><br>  <b>Pembaca yang budiman!</b>      ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435464/">https://habr.com/ru/post/id435464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435452/index.html">Pengujian ujung ke ujung dari layanan microser dengan Catcher</a></li>
<li><a href="../id435454/index.html">AOP vs Fitur</a></li>
<li><a href="../id435456/index.html">Apakah berbahaya meninggalkan smartphone di sebelah Anda di malam hari?</a></li>
<li><a href="../id435460/index.html">Tur Foto Coworkidea Coworking (Barcelona)</a></li>
<li><a href="../id435462/index.html">Menguji proyek Node.js. Bagian 1. Tes anatomi dan jenis tes</a></li>
<li><a href="../id435466/index.html">React Tutorial Bagian 6: Beberapa Fitur Kursus, JSX, dan JavaScript</a></li>
<li><a href="../id435468/index.html">Bereaksi Tutorial Bagian 7: Gaya Inline</a></li>
<li><a href="../id435470/index.html">Bereaksi Tutorial, Bagian 8: Melanjutkan Pekerjaan pada Aplikasi TODO, Memperkenalkan Properti Komponen</a></li>
<li><a href="../id435476/index.html">Mkcert: sertifikat HTTPS yang valid untuk localhost</a></li>
<li><a href="../id435480/index.html">Microsoft dan Kroger akan memberikan perlawanan kepada Amazon di bidang ... perdagangan makanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>