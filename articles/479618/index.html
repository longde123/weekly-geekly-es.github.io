<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòù „äóÔ∏è üë∏üèø Postgres Pro Standard 12.1 lanzado üõÅ üêõ ‚õ≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El DBMS est√°ndar de Postgres Pro est√° dise√±ado para entregar nuestros productos a los usuarios m√°s r√°pido que nosotros a trav√©s de PostgreSQL. Aquella...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres Pro Standard 12.1 lanzado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479618/">  El DBMS est√°ndar de Postgres Pro est√° dise√±ado para entregar nuestros productos a los usuarios m√°s r√°pido que nosotros a trav√©s de PostgreSQL.  Aquellas caracter√≠sticas que a√∫n no est√°n incluidas en PostgreSQL, pero que est√°n en una ruta s√≥lida all√≠, las incluimos en Postgres Pro Standard.  Adem√°s, Postgres Pro Standard incluye algunas extensiones que nuestros clientes exigen, pero que no est√°n disponibles en la distribuci√≥n est√°ndar de PostgreSQL. <br><br>  A veces hay excepciones cuando en Postgres Pro Standard, a petici√≥n de los usuarios y para su satisfacci√≥n, se incluyen caracter√≠sticas menos triviales, que en un buen lugar solo en Postgres Pro Enterprise.  En particular, es PTRACK, sobre esto a continuaci√≥n. <br><br>  Postgres Professional desarroll√≥ una parte justa de las extensiones y utilidades adicionales incluidas en Standard.  Todos los parches Postgres Pro fueron inventados e implementados por nuestros propios esfuerzos.  Comencemos con las mejoras que requirieron intervenci√≥n en el motor de la base de datos. <br><a name="habracut"></a><br>  Postgres Pro Standard difiere de PostgreSQL en dos niveles: el conjunto de extensiones y utilidades que se encuentran en el ensamblado, y el n√∫cleo mismo.  Se han aplicado algunos parches √∫tiles al n√∫cleo que optimizan el rendimiento (por ejemplo, un detector de bloqueo sin frenado) y parches que aumentan la eficiencia de las utilidades y extensiones (por ejemplo, para hacer que pg_probackup funcione con toda su fuerza, se aplica el parche PTRACK 2.0).  Las diferencias entre la versi√≥n central de Standard y PostgreSQL se minimizan para la mayor compatibilidad posible.  Digamos que la extensi√≥n pg_pathman es parte de Standard, pero se puede descargar desde el github, construir e instalar en el PostgreSQL de Vanilla, no habr√° problemas de compatibilidad. <br>  Comencemos con los cambios en el n√∫cleo. <br><br><h3>  Comprobaci√≥n de versiones de ICU </h3><br>  En PostgreSQL, por defecto, se usan para comparar cadenas compar√°ndolas usando la biblioteca est√°ndar C. Pero tambi√©n existe la posibilidad de usar la biblioteca <a href="http://site.icu-project.org/">ICU</a> desarrollada por IBM para el mismo prop√≥sito.  Esta biblioteca es valiosa para nosotros principalmente porque proporciona una clasificaci√≥n independiente de la plataforma.  Es por eso que, por ejemplo, se usa en 1C, y los ensamblajes "para uno" de PostgreSQL han estado trabajando con esta biblioteca durante mucho tiempo. <br><br>  Adem√°s, las comparaciones de cadenas a trav√©s de la UCI a veces son m√°s r√°pidas que a trav√©s de libc, y la cantidad de caracteres conocidos es mayor.  En general, una biblioteca √∫til.  Postgres Pro Standard ha estado trabajando con √©l desde la primera versi√≥n (9.5).  En PostgreSQL, trabajar con ICU ha sido posible desde la versi√≥n 10. <br><br>  La biblioteca es √∫til, pero debe tener en cuenta algunas situaciones de emergencia.  Supongamos que un usuario de DBMS ha decidido actualizar el sistema operativo.  Junto con el sistema operativo, la biblioteca de la UCI tambi√©n se puede actualizar, y el orden de las palabras en la clasificaci√≥n cambiar√°.  Despu√©s de eso, inmediatamente todos los √≠ndices quedar√°n inutilizables: la b√∫squeda de √≠ndice dar√° resultados incorrectos.  En tales casos, la base dijo que la versi√≥n de la UCI hab√≠a cambiado y se detuvo. <br><br>  Pero esta es una decisi√≥n dolorosamente dif√≠cil.  Despu√©s de discusiones y una encuesta de clientes, se decidi√≥ suavizar el comportamiento.  Ahora solo se verifican las versiones de COLLATION (reglas de clasificaci√≥n).  Si las versiones de COLLATION que se usan en la base de datos han cambiado, la base de datos emite una advertencia cuando se inicia el DBMS, pero no se detiene.  Tambi√©n le recuerda al usuario al comienzo de cada sesi√≥n. <br><br><h3>  Optimizaci√≥n de cerraduras, uniones y GROUP BY </h3><br>  El mecanismo de detecci√≥n de punto muerto puede degradar el rendimiento.  Standard ya no puede: el parche del kernel le permite funcionar sin frenar.  Despu√©s de importantes mejoras en el mecanismo de verificaci√≥n, estos problemas aparecen solo en una gran cantidad de n√∫cleos y conexiones. <br><br>  Estimaci√≥n mejorada del n√∫mero de resultados de uniones en presencia de √≠ndices adecuados. <br><br>  Ahora puede usar √≠ndices adecuados para agrupar y ordenar campos.  Esta caracter√≠stica se incluy√≥ por primera vez en Standard 11.1.1 y Enterprise 11.2.1.  Nuestro est√°ndar 12 tambi√©n tiene uno. <br><br>  Fedor Sigaev, CTO de Postgres Professional, ha ofrecido estos parches √∫tiles a la comunidad, se est√°n considerando y, con suerte, se incluir√°n en la versi√≥n PG 13. <br><br>  Ilustramos la optimizaci√≥n de la operaci√≥n GROUP BY con ejemplos: son claros y f√°cilmente reproducibles. <br><br>  El punto de este parche es que Postgres no optimiz√≥ el orden de los campos enumerados en GROUP BY.  Y el tiempo de ejecuci√≥n depende de la secuencia de agrupaci√≥n (con el mismo resultado de la consulta).  Hay detalles en la <a href="https://postgrespro.ru/list/thread-id/2388982">discusi√≥n</a> sobre la lista de correo de los <a href="https://postgrespro.ru/list/pgsql-hackers">hackers</a> . <br><br>  Si el valor en la primera columna que se procesar√° es √∫nico, entonces no es necesario comparar nada m√°s.  Si comienzas desde otra columna, entonces tienes que comparar. <br><br><br>  Llegando a la prueba: <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> id, i/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p, format(<span class="hljs-string"><span class="hljs-string">'%60s'</span></span>, i%<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i;</code> </pre> <br><br>  En el campo de texto v, se generan 60 espacios, seguidos de los n√∫meros 0 o 1. Las entradas se ven as√≠: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; id | p | v <span class="hljs-comment"><span class="hljs-comment">---------+--------+-------------------------------------------------------------- 1000000 | 500000 | 0 999999 | 499999 | 1 999998 | 499999 | 0 (3 rows)</span></span></code> </pre> <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">ANALYSE</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_hashagg=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers_per_gather = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><br>  Agrupe los resultados: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p, v;</code> </pre> <br><br>  Plan PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=843.999..1194.985 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=843.990..946.769 rows=1000000 loops=1) Sort Key: p, v Sort Method: external sort Disk: 73320kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.158..151.645 rows=1000000 loops=1) Planning time: 0.317 ms Execution time: 1250.086 ms (8 rows)</span></span></code> </pre> <br><br>  Ahora en el orden inverso: v, y solo entonces p: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=2552.477..3353.890 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=2552.469..3111.516 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.082..126.578 rows=1000000 loops=1) Planning time: 0.060 ms Execution time: 3411.048 ms (8 rows)</span></span></code> </pre> <br><br>  Resulta que lo contrario es notablemente m√°s lento.  Esto se debe a que el primer campo <code>v</code> analiza con una peque√±a extensi√≥n de valores.  Debe hacer muchas comprobaciones en los campos restantes (aqu√≠, el campo p). <br><br>  Veamos c√≥mo funcionar√° la misma consulta con un parche que selecciona el orden √≥ptimo para procesar columnas: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------- GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=415.541..703.647 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=415.533..507.785 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 73488kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.059..139.587 rows=1000000 loops=1) Planning Time: 0.123 ms Execution Time: 742.118 ms (8 rows)</span></span></code> </pre> <br><br>  Y en orden inverso: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=414.322..714.593 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=414.312..517.707 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 76384kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.071..129.835 rows=1000000 loops=1) Planning Time: 0.140 ms Execution Time: 753.031 ms (8 rows)</span></span></code> </pre> <br><br>  El plan dice que all√≠ y all√° el orden de procesamiento es el mismo: Ordenar clave: p, v.  En consecuencia, el tiempo es aproximadamente el mismo.  Ahora compare lo que sucede cuando se usa el √≠ndice. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> btg(p, v); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_bitmapscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p ;</code> </pre> <br><br>  En PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------- GroupAggregate (cost=0.55..74660.04 rows=494408 width=73) (actual time=0.013..391.317 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.009..120.298 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.078 ms Execution time: 442.923 ms (6 rows)</span></span></code> </pre> <br><br>  Y en orden inverso: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=243904.22..258848.04 rows=494408 width=73) (actual time=2558.485..3352.240 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=243904.22..246404.16 rows=999974 width=65) (actual time=2558.478..3110.242 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.011..133.563 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.093 ms Execution time: 3409.335 ms (9 rows)</span></span></code> </pre> <br><br>  Ahora en est√°ndar: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.150..412.174 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.134..149.669 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.175 ms Execution Time: 448.635 ms (6 rows)</span></span></code> </pre> <br><br>  Y en orden inverso: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.014..307.258 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.008..89.204 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.054 ms Execution Time: 337.766 ms (6 rows)</span></span></code> </pre> <br><br>  El tiempo vuelve a ser el mismo, lo cual es natural: de hecho, las acciones son las mismas. <br><br><h3>  Sustituci√≥n de un byte nulo en el arranque </h3><br>  Postgres Pro no acepta cero bytes (0x00) en los datos, por lo que con COPY FROM deben ser reemplazados, de lo <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-compatible">contrario habr√° un error</a> .  Este es el verdadero problema que el cliente encontr√≥ al importar datos de un archivo CSV.  Su soluci√≥n es reemplazar bytes nulos con el car√°cter ASCII dado.  Debe ser diferente de los caracteres QUOTE y DELIMITER utilizados al ejecutar COPY FROM;  de lo contrario, el resultado puede ser inesperado.  De forma predeterminada, el valor de la variable nul_byte_replacement_on_import (string) '\ 0', es decir, no se realiza ning√∫n reemplazo. <br><br><h3>  WaitLSN </h3><br>  LSN es un <a href="https://postgrespro.ru/docs/postgrespro/12/sql-waitlsn">n√∫mero secuencial en el registro</a> , es decir, un puntero a una posici√≥n en el WAL (N√∫mero de secuencia de registro).  El comando WAITLSN est√° esperando para reproducir el LSN especificado.  Si la aplicaci√≥n funciona tanto con el maestro como con la r√©plica, debe asegurarse de que est√©n sincronizados de vez en cuando.  WAITLSN es un mecanismo entre procesos en PostgrePro que controla la sincronizaci√≥n durante <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-replication">la replicaci√≥n sincr√≥nica</a> .  Por defecto, el tiempo de espera es ilimitado.  Puede cancelar la espera presionando Ctrl + C o deteniendo el servidor postgres.  Tambi√©n puede establecer el tiempo de espera agregando la sugerencia TIMEOUT, o verificar el estado del LSN objetivo sin esperar utilizando la sugerencia NOWAIT. <br>  Supongamos que una aplicaci√≥n realiza una determinada acci√≥n, recibe el n√∫mero LSN del DBMS en el maestro y ahora quiere asegurarse de que las acciones en la r√©plica se sincronizar√°n con el maestro, es decir  la aplicaci√≥n puede estar segura de que lo que registr√≥ en el asistente ya lleg√≥ a la r√©plica y est√° listo para leer.  Por defecto, esto generalmente no est√° garantizado.  WAITLSN le permite controlar esta interacci√≥n y seleccionar un modo de suspensi√≥n desde INFINITAMENTE por defecto, hasta TIEMPO DE ESPERA y AHORA. <br><br><h3>  Releyendo variables de la antigua recovery.conf </h3><br>  En una se√±al SIGHUP, PostgreSQL vuelve a leer postgresql.conf, pero no recovery.conf.  Un parche de kernel relativamente nuevo introducido en Standard y Enterprise 10.4.1.  obligado a releer y recovery.conf.  Pero en Postgres 12 no hay ning√∫n archivo recovery.conf: todas las variables se transfieren a postgresql.conf.  Sin embargo, aunque todo el archivo se vuelve a leer, SIGHUP no redefini√≥ las variables de recovery.conf, sino que requiri√≥ un reinicio de Postgres.  En Standard, esto no es obligatorio: todo se lee y se redefine. <br><br><h3>  Soporte PTRACK </h3><br>  PTRACK 2.0 es un mecanismo PTRACK redise√±ado para las versiones Standard y Enterprise 11 y anteriores.  En el nivel DBMS, funcion√≥ gracias al parche del n√∫cleo, y ahora la extensi√≥n ptrack se ha agregado al <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">parche</a> .  PTRACK 2.0 rastrea los cambios en la p√°gina de datos y proporciona una interfaz para recuperar esta informaci√≥n.  Se puede usar tanto con fines de diagn√≥stico, por ejemplo, para tener una idea de cu√°n fuertemente "muta" la instancia en relaci√≥n con un punto espec√≠fico en el tiempo, establecerla como un n√∫mero secuencial en el registro (LSN) y crear copias de seguridad incrementales. <br><br>  La parte m√°s dif√≠cil y "costosa" de un procedimiento de copia de seguridad incremental, como regla, es aislar un subconjunto de p√°ginas cambiadas de todo el conjunto de p√°ginas en un cl√∫ster.  Debido al hecho de que el servidor puede asumir esta tarea y proporcionar r√°pidamente informaci√≥n sobre las p√°ginas modificadas, el tiempo de las copias de seguridad incrementales usando PTRACK se reduce significativamente. <br><br>  PTRACK 2.0 utiliza una tabla hash de un tama√±o especificado en la memoria compartida, sincronizada peri√≥dicamente con el archivo ptrack.map. <br><br>  Debido a una alteraci√≥n fundamental del mecanismo interno de operaci√≥n y una interfaz de usuario incompatible con versiones anteriores, la extensi√≥n ptrack solo est√° disponible en la versi√≥n 12 de PostgresPro Standard y Enterprise, y estar√° disponible como parche y extensi√≥n en PostgreSQL 12. <br><br><h3>  Edici√≥n de comandos en psql para Windows </h3><br>  El soporte avanzado para editar comandos de entrada en psql para Windows se implementa usando WinEditLine.  Ahora puede mostrar los caracteres de diferentes alfabetos simult√°neamente (en particular, el cir√≠lico normalmente se muestra en Windows no ruso). <br><br><h3>  Estructura de paquete unificado </h3><br><br>  La estructura de los paquetes binarios para todas las distribuciones de Linux est√° unificada para simplificar la migraci√≥n entre ellos y permitir la instalaci√≥n de varios productos basados ‚Äã‚Äãen PostgreSQL juntos sin ning√∫n conflicto.  Esto se puede encontrar en el <a href="https://postgrespro.ru/docs/postgrespro/12/installation-bin">Cap√≠tulo 16 de la</a> Documentaci√≥n. <br><br>  Ahora sobre las extensiones: <br><br><h3>  dump_stat </h3><br>  Apareci√≥ ya en 9.5.  Al transferir o restaurar datos, las estad√≠sticas acumuladas generalmente no se transfieren.  Si lo vuelve a ensamblar con el comando ANALIZAR, se ejecutar√° para todo el cl√∫ster y no para la base de datos especificada.  Esto puede requerir mucho tiempo extra para grandes bases de datos. <br><br>  La extensi√≥n dump_stat <a href="https://postgrespro.ru/docs/postgrespro/12/dump-stat">proporciona funciones</a> que le permiten descargar y restaurar el contenido de la tabla pg_statistic.  Al realizar la carga / recuperaci√≥n de datos, puede usar dump_stat para transferir estad√≠sticas existentes a un nuevo servidor, sin tener que ejecutar el comando ANALIZAR para todo el cl√∫ster. <br><br>  La funci√≥n dump_statistic descarga el contenido del cat√°logo del sistema pg_statistic.  Produce un INSERT para cada tupla en pg_statistic, excepto las que contienen estad√≠sticas sobre tablas en los esquemas information_schema y pg_catalog. <br><br><h3>  jsquery </h3><br>  Recuerde que <a href="https://postgrespro.ru/docs/postgrespro/12/jsquery">esta es una extensi√≥n</a> para trabajar con JSON (B), no con JS.  Proporciona un conjunto de funciones para procesar estos tipos de datos.  Este es un lenguaje de consulta especial para la b√∫squeda eficiente, mediante √≠ndices, en JSON (B).  En el <a href="https://habr.com/ru/company/postgrespro/blog/448612/">art√≠culo sobre el centro,</a> puede ver algunos ejemplos de jsquery y m√©todos alternativos para trabajar con JSON (B), por ejemplo, JSONPath (ambos desarrollos de nuestra compa√±√≠a). <br><br><h3>  online_analyze </h3><br>  Esta extensi√≥n <a href="https://postgrespro.ru/docs/postgrespro/12/online-analyze">proporciona un</a> conjunto de funciones que actualizan inmediatamente las estad√≠sticas en las tablas que se especifican despu√©s de las operaciones INSERT, UPDATE, DELETE o SELECT INTO en ellas.  El autor de la extensi√≥n es Fedor Sigaev. <br><br>  Para usar el m√≥dulo online_analyze, debe cargar la biblioteca compartida: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-string"><span class="hljs-string">'online_analyze'</span></span>;</code> </pre> <br><br>  Las actualizaciones de estad√≠sticas se pueden personalizar.  Por ejemplo, establezca un porcentaje del tama√±o de la tabla o el n√∫mero m√≠nimo (umbral) de cambios de fila, despu√©s de lo cual se recopilar√°n estad√≠sticas inmediatamente. <br><br><h3>  pg_pathman </h3><br>  La <a href="https://postgrespro.ru/docs/postgrespro/12/pg-pathman">extensi√≥n pg_pathman</a> en Postgres Professional se cre√≥ antes que en el n√∫cleo de PostgreSQL e implement√≥ un conjunto bastante completo de funciones para crear particiones.  Por lo tanto, muchas operaciones con secciones se pueden realizar con uno y otro mecanismo.  Solo es aconsejable no mezclar las secciones creadas por la partici√≥n declarativa y pg_pathman. <br><br>  Sin embargo, muchas operaciones de pg_pathman son a√∫n m√°s r√°pidas y faltan algunas caracter√≠sticas en PostgreSQL.  Por ejemplo, creaci√≥n autom√°tica (corte) de secciones.  En PostgreSQL, debe establecer los l√≠mites de cada secci√≥n.  Si completamos datos sobre los cuales no se sabe de antemano cu√°ntas secciones pueden y deben estar dispersas, entonces es conveniente simplemente establecer el intervalo y dejar que el software corte las secciones por s√≠ mismo, tanto como sea necesario.  pg_pathman sabe c√≥mo, PostgreSQL no.  Pero, comenzando con PG 11, hay una secci√≥n predeterminada (predeterminada), donde puede volcar todos los registros que no caen en secciones con l√≠mites espec√≠ficos. <br><br>  Existe un acuerdo b√°sico con los l√≠deres de la comunidad PostgreSQL que en el futuro ser√° el mejor, mientras que las caracter√≠sticas √∫nicas de pg_pathman caer√°n en la rama principal.  Pero hasta ese momento, pg_pathman puede hacer la vida m√°s f√°cil para los administradores de aplicaciones DB y los programadores de aplicaciones. <br><br>  Crea una extensi√≥n: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_pathman;</code> </pre> <br><br>  pg_pathman le permite dividir tablas grandes en secciones y proporciona una API conveniente: un conjunto de funciones para crear secciones y trabajar con ellas.  Por ejemplo, usando la funci√≥n <br><br><pre> <code class="pgsql hljs">create_range_partitions(relation <span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, expression <span class="hljs-type"><span class="hljs-type">TEXT</span></span>, start_value <span class="hljs-type"><span class="hljs-type">ANYELEMENT</span></span>, p_interval <span class="hljs-type"><span class="hljs-type">INTERVAL</span></span>, p_count <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, partition_data <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>);</code> </pre> <br>  podemos preguntar <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  despu√©s de lo cual agregamos secciones: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_archive'</span></span>, <span class="hljs-string"><span class="hljs-string">'ts0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-03-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span><span class="hljs-string"><span class="hljs-string">', log_2'</span></span>);</code> </pre> <br><br>  El registro de archivo se crear√° en el espacio de tabla ts0, el resto son por defecto.  Pero no puede especificar secciones expl√≠citamente, pero conf√≠e en esta operaci√≥n DBMS configurando el intervalo y creando secciones en un solo paso: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  En una tabla simple, se ver√° as√≠: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pg_pathmania(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, val <span class="hljs-type"><span class="hljs-type">float</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(val) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'pg_pathmania'</span></span>, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); test_parti=# \d+ pg_pathmania <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> "public.pg_pathmania" <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Collation</span></span> | Nullable | <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> | S tats target | Description <span class="hljs-comment"><span class="hljs-comment">--------+------------------+-----------+----------+-----------------------+---------+------+------ id | integer | | not null | nextval('pg_pathmania_id_seq'::regclass) | plain | | val | double precision | | | | plain | | Child tables: pg_pathmania_1, pg_pathmania_10, pg_pathmania_11, pg_pathmania_12, pg_pathmania_13, pg_pathmania_14, pg_pathmania_15, pg_pathmania_16, pg_pathmania_17, pg_pathmania_18, pg_pathmania_19, pg_pathmania_2, pg_pathmania_20, pg_pathmania_21, pg_pathmania_3, pg_pathmania_4, pg_pathmania_5, pg_pathmania_6, pg_pathmania_7, pg_pathmania_8, pg_pathmania_9</span></span></code> </pre> <br><br>  En PostgreSQL, tendr√≠amos que crear cada secci√≥n con nuestro propio equipo.  En tales casos, por supuesto, escriben un script que genera el c√≥digo DDL requerido autom√°ticamente.  No necesita escribir scripts en pg_pathman, todo ya est√° all√≠.  Pero esto no es lo m√°s interesante.  Insertaremos un registro que no solo no se obtiene por identificaci√≥n en ninguna de las secciones existentes, sino que tampoco se incluye en la m√°s cercana: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(id, val) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">277.835794724524</span></span>);</code> </pre> <br><br>  Nuevamente, verifique el contenido de la tabla con \ d + pg_pathmania: <br><br><pre> <code class="pgsql hljs">Child <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span>: pg_pathmania_1, pg_pathmania_10, ... pg_pathmania_39, pg_pathmania_4, pg_pathmania_40, pg_pathmania_41,</code> </pre> <br><br>  Esto es lo que sucedi√≥: pg_pathman vio que el registro con id = 2000 no cae en las secciones ya creadas, calcul√≥ cu√°ntas necesitan crearse, conociendo el intervalo de RANGO con el que se dividi√≥ la tabla antes, y cre√≥ la secci√≥n donde cae el nuevo registro y, por supuesto, todas las secciones entre el l√≠mite superior de las secciones antiguas y el l√≠mite inferior de la nueva secci√≥n.  Esto es muy conveniente, y en los casos en que los valores del campo de divisi√≥n de los datos actualizados no se predicen adecuadamente, esta es una gran ventaja de pg_pathman. <br><br><h3>  pg_query_state </h3><br>  Esta extensi√≥n que desarrollamos nos <a href="https://postgrespro.ru/docs/postgrespro/12/pg-query-state">permite conocer el</a> estado actual de las solicitudes en el proceso de publicaci√≥n.  Ha existido desde la versi√≥n 9.5 y se debe al nacimiento de numerosas solicitudes de administradores de clientes. <br><br>  El hecho es que EXPLAIN ANALYZE le permite ver las estad√≠sticas de ejecuci√≥n recopiladas de cada nodo del √°rbol del plan, pero estas estad√≠sticas se recopilan solo despu√©s de que se completa la consulta.  Pero en la vida, por desgracia, hay situaciones en las que necesita ver lo que la solicitud a√∫n no se ha completado y tal vez no va a terminar.  pg_query_state le permite ver las estad√≠sticas actuales de una consulta que se ejecuta en un proceso de servicio externo.  En este caso, el formato de la salida resultante es casi id√©ntico a la salida del comando EXPLAIN ANALYZE habitual. <br><br>  Utilidades: <br><br><h3>  pgBouncer </h3><br>  <a href="http://www.pgbouncer.org/">Este es</a> un <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">extractor de conexiones</a> tan <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">popular</a> que ser√≠a extra√±o hablar de eso aqu√≠.  Es solo que es parte de Standard, y tendr√° que instalarse por separado en el caso de Vanilla PostgreSQL. <br><br><h3>  pg_probackup </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgprobackup">pg_probackup</a> es uno de nuestros desarrollos m√°s populares.  Este es un administrador de respaldo y recuperaci√≥n que est√° siendo desarrollado y actualizado principalmente por Anastasia Lubennikova, Grigory Smolkin y la comunidad de usuarios. <br><br>  Ventajas competitivas de pg_probackup: copia de seguridad incremental con granularidad de bloque (8 KB), tres modos de copia de seguridad incremental (PAGE, DELTA, PTRACK), verificaci√≥n de integridad de copia de seguridad a pedido, verificaci√≥n de cl√∫ster PostgreSQL, compresi√≥n de copia de seguridad, recuperaci√≥n parcial, etc. <br><br>  El modo de copia incremental PTRACK, que se basa en <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">la extensi√≥n del mismo nombre</a> como parte del mecanismo redise√±ado, PTRACK 2.0, se ha vuelto a√∫n m√°s r√°pido y ahora es inequ√≠vocamente el modo m√°s r√°pido y m√°s barato de pg_probackup. <br><br><h3>  pg_repack </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgrepack">pg_repack es una</a> utilidad popular, su funcionamiento es similar a VACUUM FULL o <a href="https://postgrespro.ru/docs/postgrespro/12/sql-cluster">CLUSTER</a> .  No solo reempaqueta tablas, elimina vac√≠os, sino que tambi√©n sabe c√≥mo restaurar el orden f√≠sico de los √≠ndices agrupados.  A diferencia de CLUSTER y VACUUM FULL, realiza estas operaciones "sobre la marcha", sin bloqueos de tabla exclusivos y, en general, funciona de manera eficiente.  No est√° incluido en la versi√≥n vainilla. <br><br><h3>  pg_variables </h3><br>  Sobre esta extensi√≥n en un habr hay un interesante <a href="https://habr.com/ru/company/postgrespro/blog/302200/">art√≠culo de</a> nuestro empleado Ivan Frolkov.  La raz√≥n de la extensi√≥n es que trabajar con resultados intermedios a veces es inconveniente y costoso.  El art√≠culo explora alternativas.  Las m√°s comunes son las tablas temporales. <br><br>  Como almac√©n de datos temporal, la extensi√≥n pg_variables es mucho m√°s productiva que las tablas temporales (las pruebas de pgbench est√°n en el art√≠culo), y es m√°s conveniente: el conjunto de datos se define mediante un par "paquete - variable", que puede pasarse como par√°metros, devolverse de una funci√≥n, etc. Hay funciones set / get para trabajar con variables.  Entonces, por ejemplo, puede almacenar muchas variables (paquete es el nombre del paquete, y la expresi√≥n despu√©s del punto decimal son las variables en este paquete: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_set_int(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'#'</span></span>||n,n), n <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n);</code> </pre> <br><br>  Las variables tienen una propiedad interesante: no un error o ventaja, sino una caracter√≠stica: los datos almacenados por los medios de extensi√≥n existen fuera de las transacciones: se guardan tanto en el caso de arreglar una transacci√≥n como en caso de reversi√≥n;  Adem√°s, incluso cuando se ejecuta un comando separado, se pueden obtener datos parciales: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_insert(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, <span class="hljs-string"><span class="hljs-string">'errs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(n)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(n<span class="hljs-number"><span class="hljs-number">-3</span></span>)&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; ERROR: there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the variable "errs" <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> same key test_parti=# <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgv_select(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'errs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r(i <span class="hljs-type"><span class="hljs-type">int</span></span>); i <span class="hljs-comment"><span class="hljs-comment">--- 1 2 (2 rows)</span></span></code> </pre> <br><br>  Por un lado, esto no es muy conveniente: en algunos casos es necesario proporcionar la eliminaci√≥n de datos ingresados ‚Äã‚Äãincorrectamente, pero en otros puede resultar muy √∫til, por ejemplo, guardar algunos datos incluso en el caso de una reversi√≥n de la transacci√≥n.  La <a href="https://github.com/postgrespro/pg_variables">documentaci√≥n</a> tiene detalles. <br><br>  En conclusi√≥n, algunas extensiones m√°s: <br><br><h3>  sr_plan, plantuner </h3><br>  <b>sr_plan</b> <a href="https://postgrespro.ru/docs/postgrespro/12/sr-plan">guarda y restaura los</a> planes de consulta.  Incl√∫yalo as√≠: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> sr_plan.write_mode = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br><br>  Despu√©s de eso, los planes para todas las consultas posteriores se almacenar√°n en la tabla sr_plans hasta que esta variable se establezca en falso.  Se guardan los planes para todas las solicitudes, incluidas las repetidas. <br><br>  <b>plantuner</b> <a href="https://postgrespro.ru/docs/postgrespro/12/plantuner">admite</a> sugerencias para que el planificador conecte o desconecte √≠ndices espec√≠ficos al ejecutar una consulta.  Solo hay dos variables GUC: enable_index / desable_index: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> plantuner.disable_index=<span class="hljs-string"><span class="hljs-string">'id_idx2'</span></span>;</code> </pre> <br><br><h3>  Extensiones para b√∫squeda de texto completo: shared_ispell, pg_tsparser </h3><br>  La extensi√≥n shared_ispell, que le permite colocar <a href="https://postgrespro.ru/docs/postgrespro/12/hunspell-dict">diccionarios</a> en la memoria compartida, est√° en Standard y no en PostgreSQL.  Nuestro set hunspell-dict tiene diccionarios para idiomas: <br><br><ul><li>  hunspell_en_us, </li><li>  hunspell_fr, </li><li>  hunspell_nl_nl, </li><li>  hunspell_ru_ru </li></ul><br><br>  La <b>extensi√≥n pg_tsparser</b> es <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">un analizador de</a> b√∫squeda de texto <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">alternativo</a> .  Esta extensi√≥n cambia la estrategia de an√°lisis de texto est√°ndar para palabras que incluyen guiones bajos, as√≠ como n√∫meros y letras separados por guiones bajos.  Adem√°s de las partes individuales de la palabra devueltas por defecto, pg_tsparser tambi√©n devuelve la palabra completa.  Esto es muy importante para la documentaci√≥n t√©cnica o art√≠culos como este, en los que se encuentra el c√≥digo del programa, y ‚Äã‚Äãen √©l hay palabras como "pg_tsparser", "pg_probackup", "jsonb_build_object".  Este analizador percibe estas palabras no solo como un conjunto de componentes, sino tambi√©n como un token √∫nico, y por lo tanto mejora la calidad de la b√∫squeda. <br><br><h3>  Extensiones para 1C </h3><br><ul><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/mchar">mchar</a></b> es un tipo de datos opcional para compatibilidad con Microsoft SQL Server; </li><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/fulleq">fulleq</a></b> : proporciona un operador de igualdad adicional para la compatibilidad con Microsoft SQL Server; </li><li> <b><a href="https://postgrespro.ru/docs/postgrespro/12/fasttrun">fasttrun</a></b> ‚Äî  -     ,     pg_class. </li></ul><br><br>      ,    PostgresPro Standard  PostgreSQL.   ,     , , , <a href="https://postgrespro.ru/docs/postgrespro/12/index">  </a> . <br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479618/">https://habr.com/ru/post/479618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479590/index.html">Las 10 principales empresas de desarrollo de aplicaciones en 2020</a></li>
<li><a href="../479592/index.html">¬øC√≥mo lograr tus objetivos?</a></li>
<li><a href="../479598/index.html">Gato y perro alimentan al robot</a></li>
<li><a href="../479600/index.html">Otro DSL para validaciones</a></li>
<li><a href="../479602/index.html">¬øQu√© es el genoma completo y por qu√© es necesario?</a></li>
<li><a href="../479620/index.html">L√≥gica inversa</a></li>
<li><a href="../479622/index.html">C√≥mo funciona el prototipo de transacciones an√≥nimas en la cadena de bloques Waves</a></li>
<li><a href="../479624/index.html">El gendarme profesional de Postgres, Oleg Bartunov, le cuenta a Faride Roslovets sobre PostgreSQL y sus negocios en Rusia</a></li>
<li><a href="../479626/index.html">Resonador con un giro que los f√≠sicos no conocen</a></li>
<li><a href="../479630/index.html">Lucha por la atenci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>