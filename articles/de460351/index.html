<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ‚ôìÔ∏è üïö werf - unser Tool f√ºr CI / CD in Kubernetes (Review und Video Report) üí™ üëµüèº ‚õπüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 27. Mai wurde in der Haupthalle der DevOpsConf 2019-Konferenz, die im Rahmen des RIT ++ 2019- Festivals im Rahmen der Continuous Delivery-Sektion s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>werf - unser Tool f√ºr CI / CD in Kubernetes (Review und Video Report)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460351/">  Am 27. Mai wurde in der Haupthalle der DevOpsConf 2019-Konferenz, die im Rahmen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIT ++ 2019-</a> Festivals im Rahmen der Continuous Delivery-Sektion stattfand, der Bericht ‚Äûwerf ist unser Tool f√ºr CI / CD in Kubernetes‚Äú ver√∂ffentlicht.  Es geht um die <b>Probleme und Herausforderungen, mit denen jeder bei der Bereitstellung auf Kubernetes konfrontiert ist</b> , sowie um die Nuancen, die m√∂glicherweise nicht sofort erkennbar sind.  Wir analysieren m√∂gliche L√∂sungen und zeigen, wie dies im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf</a> Open Source Tool implementiert wird. <br><br>  Seit der Show hat unser Dienstprogramm (fr√ºher bekannt als dapp) die historische Grenze von <b>1000 Sternen auf GitHub</b> √ºberschritten - wir hoffen, dass die wachsende Community seiner Benutzer das Leben vieler DevOps-Ingenieure vereinfachen wird. <br><br><img src="https://habrastorage.org/webt/lh/k9/x1/lhk9x1wf3gzo6bk1lsjosnvjg1g.jpeg"><br><br>  Deshalb pr√§sentieren wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Video mit dem Bericht</b></a> (~ 47 Minuten, viel informativer als der Artikel) und dem Hauptauszug daraus in Textform.  Lass uns gehen! <a name="habracut"></a><br><br><h2>  Code-Lieferung in Kubernetes </h2><br>  Es geht nicht mehr um werf, sondern um CI / CD in Kubernetes, was bedeutet, dass unsere Software in Docker-Containern verpackt ist <i>(dar√ºber habe ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht 2016 gesprochen</a> )</i> , und K8s werden verwendet, um sie in der Produktion zu starten <i>(dar√ºber - im Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2017</a> )</i> . <br><br>  Wie sieht die Lieferung von Kubernetes aus? <br><br><ul><li>  Es gibt ein Git-Repository mit Code und Anweisungen zum Erstellen.  Die Anwendung wird in ein Docker-Image kompiliert und in der Docker-Registrierung ver√∂ffentlicht. </li><li>  Im selben Repository finden Sie Anweisungen zum Bereitstellen und Ausf√ºhren der Anwendung.  In der Bereitstellungsphase werden diese Anweisungen an Kubernetes gesendet, das das gew√ºnschte Image von der Registrierung empf√§ngt und startet. </li><li>  Au√üerdem gibt es normalerweise Tests.  Einige davon k√∂nnen beim Ver√∂ffentlichen eines Bildes ausgef√ºhrt werden.  Sie k√∂nnen auch (nach denselben Anweisungen) eine Kopie der Anwendung (in einem separaten K8s-Namespace oder in einem separaten Cluster) bereitstellen und dort Tests ausf√ºhren. </li><li>  Schlie√ülich ben√∂tigen wir ein CI-System, das Ereignisse von Git (oder Schaltfl√§chenklicks) empf√§ngt und alle angegebenen Phasen aufruft: Erstellen, Ver√∂ffentlichen, Bereitstellen, Testen. </li></ul><br><img src="https://habrastorage.org/webt/vd/jh/ks/vdjhksq3874swybast6v7oerqe4.gif"><br><br>  Hier gibt es einige wichtige Hinweise: <br><br><ol><li>  Da wir √ºber eine unver√§nderliche Infrastruktur verf√ºgen, muss das Image der Anwendung, die in allen Phasen (Staging, Produktion usw.) <b>verwendet wird, eins sein</b> .  <i>Ich habe hier mehr dar√ºber und mit Beispielen gesprochen.</i> </li><li>  Da wir den <i>IaC-Ansatz (</i> Infrastructure as Code) <i>verfolgen</i> , sollten der Anwendungscode und die Anweisungen zum <i>Erstellen</i> und Ausf√ºhren <b>in einem Repository liegen</b> .  <i>Weitere Informationen hierzu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im selben Bericht</a> .</i> </li><li>  Normalerweise sehen wir die Lieferkette <i>(Lieferung) folgenderma√üen</i> : Die Anwendung wurde zusammengestellt, getestet, freigegeben <i>(Freigabestufe)</i> und das ist alles - die Lieferung ist erfolgt.  In Wirklichkeit erh√§lt der Benutzer jedoch das, was Sie eingef√ºhrt haben, <b>nicht,</b> als Sie es an die Produktion geliefert haben, sondern als er dorthin gehen konnte und diese Produktion funktionierte.  Daher glaube ich, dass die Lieferkette <b>erst in der Betriebsphase</b> <i>(Lauf)</i> endet, genauer gesagt, selbst in dem Moment, in dem der Code aus der Produktion entfernt wurde (indem er durch einen neuen ersetzt wurde). </li></ol><br>  Kehren wir zu dem oben angegebenen Kubernetes-Lieferschema zur√ºck: Es wurde nicht nur von uns erfunden, sondern buchst√§blich von allen, die sich mit diesem Problem befasst haben.  Im Wesentlichen hei√üt dieses Muster jetzt GitOps <i>(mehr √ºber den Begriff und die Ideen dahinter finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> )</i> .  Schauen wir uns die Phasen des Schemas an. <br><br><h2>  B√ºhne bauen </h2><br>  Es scheint, dass Sie 2019 √ºber die Zusammenstellung von Docker-Images berichten k√∂nnen, wenn jeder wei√ü, wie man <code>docker build</code> Dateien schreibt und <code>docker build</code> Builds ausf√ºhrt? Hier sind die Nuancen, auf die ich achten m√∂chte: <br><br><ol><li>  <b>Das Gewicht des Bildes ist</b> wichtig. Verwenden Sie daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrstufig</a> , um nur die Anwendung zu belassen, die wirklich f√ºr das Bild ben√∂tigt wird. </li><li>  <b>Die Anzahl der Ebenen</b> sollte minimiert werden, indem die Ketten der <code>RUN</code> Befehle innerhalb der Bedeutung kombiniert werden. </li><li>  Dies tr√§gt jedoch zu den <b>Debugging-</b> Problemen bei, da Sie beim Absturz der Assembly den erforderlichen Befehl aus der Kette finden m√ºssen, die das Problem verursacht hat. </li><li>  <b>Die Build-Geschwindigkeit ist</b> wichtig, da wir √Ñnderungen schnell einf√ºhren und das Ergebnis betrachten m√∂chten.  Zum Beispiel m√∂chte ich die Abh√§ngigkeiten in den Sprachbibliotheken nicht bei jedem Build der Anwendung neu zusammenstellen. </li><li>  Oft werden <b>viele Bilder</b> aus einem Git-Repository ben√∂tigt, die durch eine Reihe von Docker-Dateien (oder benannten Stufen in einer Datei) und ein Bash-Skript mit ihrer sequentiellen Assemblierung gel√∂st werden k√∂nnen. </li></ol><br>  Es war nur die Spitze des Eisbergs, der sich alle gegen√ºbersehen.  Es gibt aber noch andere Probleme, insbesondere: <br><br><ol><li>  Oft m√ºssen wir in der Assembly-Phase etwas <b>bereitstellen</b> (z. B. das Ergebnis eines Befehls wie apt in einem Verzeichnis eines Drittanbieters zwischenspeichern). </li><li>  Wir wollen <b>Ansible,</b> anstatt auf die Shell zu schreiben. </li><li>  Wir m√∂chten <b>ohne Docker erstellen</b> (warum ben√∂tigen wir eine zus√§tzliche virtuelle Maschine, in der Sie alles daf√ºr konfigurieren m√ºssen, wenn bereits ein Kubernetes-Cluster vorhanden ist, in dem Sie Container ausf√ºhren k√∂nnen?). </li><li>  <b>Parallele Assembly</b> , die auf unterschiedliche Weise verstanden werden kann: verschiedene Befehle aus der Docker-Datei (wenn mehrstufig verwendet wird), mehrere Commits eines Repositorys, mehrere Docker-Dateien. </li><li>  <b>Verteilte Montage</b> : Wir wollen etwas in H√ºlsen sammeln, die ‚Äûkurzlebig‚Äú sind, weil  Ihr Cache verschwindet, was bedeutet, dass er irgendwo separat gespeichert werden muss. </li><li>  Schlie√ülich nannte ich <b>den</b> H√∂hepunkt der W√ºnsche Automagie: Es w√§re ideal, in das Repository zu gehen, ein Team einzugeben und ein fertiges Bild zu erhalten, das mit dem Verst√§ndnis zusammengestellt ist, wie und was richtig zu tun ist.  Ich pers√∂nlich bin mir jedoch nicht sicher, ob alle Nuancen auf diese Weise vorhergesehen werden k√∂nnen. </li></ol><br>  Und hier sind die Projekte: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">moby / buildkit</a> - ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builder</a> der Firma Docker Inc (bereits in die aktuellen Versionen von Docker integriert), der versucht, all diese Probleme zu l√∂sen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kaniko</a> - ein Sammler von Google, mit dem Sie ohne Docker bauen k√∂nnen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildpacks.io</a> - ein Versuch von CNCF, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auto-</a> Magie zu machen, und insbesondere eine interessante L√∂sung mit Rebase f√ºr Ebenen; </li><li>  und eine Reihe anderer Dienstprogramme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildah</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genuinetools / Img</a> ... </li></ul><br>  ... und sehen, wie viele Sterne sie auf GitHub haben.  Das hei√üt, einerseits ist und kann <code>docker build</code> etwas tun, aber in Wirklichkeit ist das <b>Problem nicht vollst√§ndig gel√∂st</b> - dies wird durch die parallele Entwicklung alternativer Builder belegt, von denen jeder einige der Probleme l√∂st. <br><br><h2>  Werf einbauen </h2><br>  Also kamen wir zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf</a> <i>(fr√ºher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekannt</a> als dapp)</i> - dem Open Source-Dienstprogramm von Flant, das wir seit vielen Jahren betreiben.  Alles begann vor ungef√§hr 5 Jahren mit Bash-Skripten, die die Zusammenstellung von Dockerfiles optimieren. In den letzten 3 Jahren wurde die vollst√§ndige Entwicklung im Rahmen eines Projekts mit einem eigenen Git-Repository fortgesetzt <i>(zuerst in Ruby, dann in Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgeschrieben</a> und gleichzeitig umbenannt)</i> .  Welche Build-Probleme werden in werf behoben? <br><br><img src="https://habrastorage.org/webt/--/1-/ca/--1-cakzswwfhrcrgnees6cvf-a.png"><br><br>  Die blau schattierten Probleme wurden bereits implementiert, die parallele Montage wurde auf demselben Host durchgef√ºhrt, und wir planen, die gelben Fragen bis Ende des Sommers zu beantworten. <br><br><h2>  Stadium der Ver√∂ffentlichung in der Registrierung (ver√∂ffentlichen) </h2><br>  Wir haben <code>docker push</code> eingegeben ... - Was kann beim Hochladen eines Bildes in die Registrierung schwierig sein?  Und dann stellt sich die Frage: "Welches Tag soll das Bild setzen?"  <b>Dies liegt daran,</b> dass wir <b>Gitflow</b> (oder eine andere Git-Strategie) und Kubernetes haben und die Branche sich daf√ºr einsetzt, dass das, was in Kubernetes passiert, dem folgt, was in Git gemacht wird.  Git ist unsere einzige Quelle der Wahrheit. <br><br>  Was ist so kompliziert?  <b>Stellen Sie die Reproduzierbarkeit sicher</b> : von einem Commit in Git, das von Natur aus <i>unver√§nderlich ist</i> , bis zu einem Docker-Image, das <i>unver√§ndert</i> bleiben muss. <br><br>  F√ºr uns ist es auch wichtig <b>, den Ursprung</b> zu <b>bestimmen</b> , da wir verstehen m√∂chten, aus welchem ‚Äã‚ÄãCommit die in Kubernetes gestartete Anwendung erstellt wurde (dann k√∂nnen wir Unterschiede und √§hnliche Dinge tun). <br><br><h3>  Markierungsstrategien </h3><br>  Das erste ist ein einfaches <b>Git-Tag</b> .  Wir haben eine Registrierung mit einem Bild als <code>1.0</code> .  Kubernetes hat B√ºhne und Produktion, wo dieses Bild gepumpt wird.  In Git machen wir Commits und setzen irgendwann das Tag <code>2.0</code> .  Wir sammeln es gem√§√ü den Anweisungen aus dem Repository und legen es mit dem <code>2.0</code> Tag in der Registrierung ab.  Wir rollen es auf der B√ºhne aus und wenn alles in Ordnung ist, dann in der Produktion. <br><br><img src="https://habrastorage.org/webt/4f/ub/u4/4fubu4r-0obh9gkzs4_kftnlqxs.gif"><br><br>  Das Problem bei diesem Ansatz ist, dass wir das Tag zuerst festgelegt und erst dann getestet und ausgerollt haben.  Warum?  Erstens ist dies einfach unlogisch: Wir geben eine Softwareversion heraus, die wir noch nicht einmal getestet haben (wir k√∂nnen nichts anderes tun, da Sie zur √úberpr√ºfung ein Tag einf√ºgen m√ºssen).  Zweitens ist dieser Weg nicht mit Gitflow kompatibel. <br><br>  Die zweite Option ist <b>git commit + tag</b> .  Im Hauptzweig befindet sich ein <code>1.0</code> Tag.  f√ºr ihn in der Registrierung - ein Image, das f√ºr die Produktion bereitgestellt wird.  Dar√ºber hinaus verf√ºgt der Kubernetes-Cluster √ºber Vorschau- und Staging-Schleifen.  Weiter folgen wir Gitflow: Im Hauptzweig f√ºr die Entwicklung <code>develop</code> wir neue Funktionen, aufgrund derer ein Commit mit der Kennung <code>#c1</code> .  Wir sammeln es und ver√∂ffentlichen es in der Registrierung unter Verwendung dieser Kennung ( <code>#c1</code> ).  Wir rollen die Vorschau mit derselben Kennung aus.  Wir machen dasselbe mit den Commits <code>#c2</code> und <code>#c3</code> . <br><br>  Als wir feststellten, dass es gen√ºgend Funktionen gibt, beginnen wir, alles zu stabilisieren.  Erstellen Sie in Git den Zweig <code>release_1.1</code> (basierend auf <code>#c3</code> von <code>develop</code> ).  Das Sammeln dieser Version ist nicht erforderlich, da  Dies wurde im vorherigen Schritt durchgef√ºhrt.  Daher k√∂nnen wir es einfach auf die Inszenierung ausrollen.  Wir beheben Fehler in <code>#c4</code> und rollen sie ebenfalls auf Staging aus.  Gleichzeitig wird derzeit eine <code>develop</code> , bei der regelm√§√üig √Ñnderungen gegen√ºber <code>release_1.1</code> werden.  Irgendwann bekommen wir ein Commit und werden zum Staging Commit herausgepumpt, mit dem wir zufrieden sind ( <code>#c25</code> ). <br><br>  Dann f√ºhren wir eine Zusammenf√ºhrung (mit schnellem Vorlauf) des Release-Zweigs ( <code>release_1.1</code> ) im Master durch.  Wir haben diesem Commit ein Tag mit der neuen Version ( <code>1.1</code> ) hinzugef√ºgt.  Dieses Bild ist jedoch bereits in der Registrierung zusammengestellt. Um es nicht erneut zu erfassen, f√ºgen wir dem vorhandenen Bild nur ein zweites Tag hinzu (jetzt enth√§lt es die Tags <code>#c25</code> und <code>1.1</code> in der Registrierung).  Danach rollen wir es in die Produktion aus. <br><br>  Es gibt einen Nachteil, dass ein Bild ( <code>#c25</code> ) beim Staging <code>#c25</code> wird und ein anderes ( <code>1.1</code> ) bei der Produktion <code>#c25</code> , aber wir wissen, dass es sich "physisch" um dasselbe Bild aus der Registrierung handelt. <br><br><img src="https://habrastorage.org/webt/mb/pq/iu/mbpqiumzomvrouhp8llx5aishza.gif"><br><br>  Das eigentliche Minus ist, dass es keine Unterst√ºtzung f√ºr Merge Commit'ov gibt. Sie m√ºssen einen schnellen Vorlauf durchf√ºhren. <br><br>  Sie k√∂nnen noch weiter gehen und den Trick machen ... Betrachten Sie ein Beispiel f√ºr eine einfache Docker-Datei: <br><br><pre> <code class="plaintext hljs">FROM ruby:2.3 as assets RUN mkdir -p /app WORKDIR /app COPY . ./ RUN gem install bundler &amp;&amp; bundle install RUN bundle exec rake assets:precompile CMD bundle exec puma -C config/puma.rb FROM nginx:alpine COPY --from=assets /app/public /usr/share/nginx/www/public</code> </pre> <br>  Wir erstellen daraus eine Datei nach diesem Prinzip, das wir nehmen: <br><br><ul><li>  SHA256 aus Kennungen der verwendeten Bilder ( <code>ruby:2.3</code> und <code>nginx:alpine</code> ), die Pr√ºfsummen ihres Inhalts sind; </li><li>  alle Teams ( <code>RUN</code> , <code>CMD</code> usw.); </li><li>  SHA256 aus Dateien, die hinzugef√ºgt wurden. </li></ul><br>  ... und nehmen Sie die Pr√ºfsumme (wieder SHA256) aus einer solchen Datei.  Dies ist die <b>Signatur von</b> allem, was den Inhalt eines Docker-Images definiert. <br><br><img src="https://habrastorage.org/webt/zp/w2/ju/zpw2jup54xa66mit1bt9u7amwlk.gif"><br><br>  <b>Kehren wir</b> zum Schema zur√ºck und verwenden <b>anstelle von Commits solche Signaturen</b> , d. H.  Kennzeichnen Sie Bilder mit Signaturen. <br><br><img src="https://habrastorage.org/webt/pr/d3/wf/prd3wfn6ctkod9ddqqmgtqnr1ew.gif"><br><br>  Wenn Sie beispielsweise √Ñnderungen von der Version zum Master zusammenf√ºhren m√ºssen, k√∂nnen Sie ein echtes Zusammenf√ºhrungs-Commit durchf√ºhren: Es hat eine andere Kennung, aber dieselbe Signatur.  Mit der gleichen Kennung werden wir das Bild auch in der Produktion ausrollen. <br><br>  Der Nachteil ist, dass jetzt nicht mehr festgestellt werden kann, welche Art von Commit in die Produktion gepumpt wurde - Pr√ºfsummen funktionieren nur in eine Richtung.  Dieses Problem wird durch eine zus√§tzliche Ebene mit Metadaten gel√∂st - mehr dazu sp√§ter. <br><br><h3>  Tagging in werf </h3><br>  In werf sind wir noch weiter gegangen und bereiten uns darauf vor, eine verteilte Assembly mit einem Cache zu erstellen, der nicht auf demselben Computer gespeichert ist ... Wir haben also zwei Arten von Docker-Images, die wir <i>Stage</i> und <i>Image nennen</i> . <br><br>  Das werf Git-Repository speichert spezifische Build-Anweisungen, die die verschiedenen Phasen des Builds beschreiben ( <i>beforeInstall</i> , <i>install</i> , <i>beforeSetup</i> , <i>setup</i> ).  Wir sammeln das Bild der ersten Stufe mit einer Signatur, die als Pr√ºfsumme der ersten Schritte definiert ist.  Dann f√ºgen wir den Quellcode hinzu, f√ºr das neue B√ºhnenbild betrachten wir seine Pr√ºfsumme ... Diese Operationen werden f√ºr alle Stufen wiederholt, wodurch wir eine Reihe von B√ºhnenbildern erhalten.  Dann machen wir das endg√ºltige Bild-Bild, das auch Metadaten √ºber seinen Ursprung enth√§lt.  Und wir markieren dieses Bild auf verschiedene Arten (Details sp√§ter). <br><br><img src="https://habrastorage.org/webt/4a/uw/am/4auwamdra7bm0xtvht35kpbstye.gif"><br><br>  Lassen Sie danach ein neues Commit erscheinen, in dem nur der Anwendungscode ge√§ndert wird.  Was wird passieren?  F√ºr Code√§nderungen wird ein Patch erstellt und ein neues B√ºhnenbild erstellt.  Seine Signatur wird als Pr√ºfsumme des alten B√ºhnenbildes und des neuen Patches definiert.  Aus diesem Bild wird ein neues endg√ºltiges Bildbild erzeugt.  Ein √§hnliches Verhalten tritt bei √Ñnderungen in anderen Phasen auf. <br><br>  B√ºhnenbilder sind somit ein Cache, der verteilt verteilt werden kann, und bereits daraus erstellte Bildbilder werden in die Docker-Registrierung geladen. <br><br><img src="https://habrastorage.org/webt/sc/8j/me/sc8jme4f1jfqbrbwt1anf2-rja8.gif"><br><br><h3>  Registry-Reinigung </h3><br>  Hier geht es nicht darum, Ebenen zu l√∂schen, die nach gel√∂schten Tags h√§ngen bleiben. Dies ist eine Standardfunktion der Docker-Registrierung.  Dies ist eine Situation, in der sich viele Docker-Tags ansammeln und wir verstehen, dass wir einige davon nicht mehr ben√∂tigen und sie Platz beanspruchen (und / oder wir daf√ºr bezahlen). <br><br>  Was sind die Reinigungsstrategien? <br><br><ol><li>  Sie k√∂nnen einfach <b>nichts reinigen</b> .  Manchmal ist es wirklich einfacher, ein wenig f√ºr den zus√§tzlichen Platz zu bezahlen, als einen riesigen Ball mit Tags zu entwirren.  Dies funktioniert aber nur bis zu einem bestimmten Punkt. </li><li>  <b>Vollst√§ndiger Reset</b> .  Wenn Sie alle Bilder l√∂schen und nur die relevanten im CI-System neu erstellen, kann ein Problem auftreten.  Wenn der Container bei der Produktion neu gestartet wird, wird ein neues Image f√ºr ihn geladen - eines, das noch von niemandem getestet wurde.  Dies t√∂tet die Idee einer unver√§nderlichen Infrastruktur. </li><li>  <b>Blaugr√ºn</b> .  Eine Registrierung begann zu √ºberlaufen - Bilder wurden in eine andere geladen.  Das gleiche Problem wie bei der vorherigen Methode: Ab wann k√∂nnen Sie die Registrierung bereinigen, die √ºbergelaufen ist? </li><li>  <b>Mit der Zeit</b> .  Alle Bilder l√∂schen, die √§lter als 1 Monat sind?  Aber es wird sicher einen Dienst geben, der seit einem Monat nicht mehr aktualisiert wurde ... </li><li>  <b>Manuell</b> bestimmen, was bereits gel√∂scht werden kann. </li></ol><br>  Es gibt zwei wirklich praktikable Optionen: Nicht reinigen oder eine Kombination aus Blaugr√ºn + manuell.  Im letzteren Fall handelt es sich um Folgendes: Wenn Sie verstehen, dass es Zeit ist, die Registrierung zu bereinigen, erstellen Sie eine neue und f√ºgen Sie beispielsweise f√ºr einen Monat alle neuen Bilder hinzu.  √úberpr√ºfen Sie einen Monat sp√§ter, welche Pods in Kubernetes noch die alte Registrierung verwenden, und √ºbertragen Sie sie auch in die neue Registrierung. <br><br>  <b>Wo sind</b> wir zu <b>werf gegangen</b> ?  Wir sammeln: <br><br><ol><li>  Git-Kopf: alle Tags, alle Zweige - vorausgesetzt, dass alles, was in Git getestet wird, in den Bildern ben√∂tigt wird (und wenn nicht, m√ºssen wir es im Git selbst l√∂schen); </li><li>  alle Pods, die jetzt in Kubernetes heruntergeladen werden; </li><li>  alte ReplicaSets (etwas, das k√ºrzlich herausgepumpt wurde) sowie wir planen, Helm-Releases zu scannen und dort die neuesten Bilder auszuw√§hlen. </li></ol><br>  ... und wir erstellen eine Whitelist aus diesem Set - eine Liste von Bildern, die wir nicht l√∂schen werden.  Wir s√§ubern alles andere, danach finden wir die verwaisten B√ºhnenbilder und l√∂schen sie auch. <br><br><h2>  Bereitstellungsphase (Bereitstellung) </h2><br><h3>  Robuste Deklarativit√§t </h3><br>  Der erste Punkt, auf den ich in der Bereitstellung aufmerksam machen m√∂chte, ist die Einf√ºhrung der deklarativ deklarierten aktualisierten Ressourcenkonfiguration.  Das urspr√ºngliche YAML-Dokument, das die Kubernetes-Ressourcen beschreibt, unterscheidet sich immer stark von dem Ergebnis, das tats√§chlich im Cluster funktioniert.  Weil Kubernetes die Konfiguration erweitert: <br><br><ol><li>  Bezeichner </li><li>  Serviceinformationen; </li><li>  viele Standardwerte; </li><li>  Abschnitt mit aktuellem Status; </li><li>  √Ñnderungen, die im Rahmen des Zulassungs-Webhooks vorgenommen wurden; </li><li>  das Ergebnis der Arbeit verschiedener Controller (und Scheduler). </li></ol><br>  Wenn eine neue Konfiguration einer Ressource ( <i>neu</i> ) angezeigt wird, k√∂nnen wir daher nicht einfach die aktuelle "Live" -Konfiguration ( <i>Live</i> ) √ºbernehmen und damit √ºberschreiben.  Dazu m√ºssen wir <i>new</i> mit der zuletzt angewendeten ( <i>zuletzt angewendeten</i> ) Konfiguration vergleichen und den resultierenden Patch <i>live √ºbertragen</i> . <br><br>  Dieser Ansatz wird als <b>2-Wege-Zusammenf√ºhrung bezeichnet</b> .  Es wird zum Beispiel in Helm verwendet. <br><br>  Es gibt auch eine <b>3-Wege-Zusammenf√ºhrung</b> , die sich darin unterscheidet: <br><br><ul><li>  Beim Vergleich von <i>zuletzt angewendet</i> und <i>neu sehen</i> wir uns an, was entfernt wurde. </li><li>  Beim Vergleich von <i>Neuem</i> und <i>Live sehen</i> wir, was hinzugef√ºgt oder ge√§ndert wurde. </li><li>  Wende den zusammengefassten Patch auf <i>live an</i> . </li></ul><br>  Wir stellen mehr als 1000 Anwendungen mit Helm bereit, sodass wir tats√§chlich mit einer 2-Wege-Zusammenf√ºhrung leben.  Er hat jedoch eine Reihe von Problemen, die wir mit unseren Patches gel√∂st haben, die Helm helfen, normal zu arbeiten. <br><br><h3>  Aktueller Rollout-Status </h3><br>  Nach dem n√§chsten Ereignis hat unser CI-System eine neue Konfiguration f√ºr Kubernetes generiert und diese mit Helm oder <code>kubectl apply</code> an den Cluster <code>kubectl apply</code> .  Als n√§chstes findet die bereits beschriebene N-Wege-Zusammenf√ºhrung statt, zu der die Kubernetes-API das CI-System genehmigt und dieses auf seinen Benutzer reagiert. <br><br><img src="https://habrastorage.org/webt/sk/vh/-u/skvh-uifcwg6_d5mgxhehh39q9i.png"><br><br>  Es gibt jedoch ein gro√ües Problem: Eine <b>erfolgreiche Anwendung bedeutet schlie√ülich keinen erfolgreichen Rollout</b> .  Wenn Kubernetes versteht, welche √Ñnderungen anzuwenden sind, wendet er sie an - wir wissen immer noch nicht, wie das Ergebnis aussehen wird.  Das Aktualisieren und Neustarten von Pods im Frontend kann beispielsweise erfolgreich sein, nicht jedoch im Backend, und wir erhalten verschiedene Versionen der ausgef√ºhrten Anwendungsabbilder. <br><br>  Um alles richtig zu machen, entsteht in diesem Schema ein zus√§tzlicher Link - ein spezieller Tracker, der Statusinformationen von der Kubernetes-API empf√§ngt und zur weiteren Analyse des tats√§chlichen Zustands der Dinge √ºbertr√§gt.  Wir haben eine Open Source-Bibliothek auf Go - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>kubedog erstellt</b></a> <i>(siehe Ank√ºndigung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> )</i> - die dieses Problem l√∂st und in werf integriert ist. <br><br>  Das Verhalten dieses Trackers auf werf-Ebene wird mithilfe von Anmerkungen konfiguriert, die in Deployments oder StatefulSets eingef√ºgt werden.  Die Hauptanmerkung <code>fail-mode</code> versteht die folgenden Bedeutungen: <br><br><ul><li>  <code>IgnoreAndContinueDeployProcess</code> - Ignorieren Sie <code>IgnoreAndContinueDeployProcess</code> Probleme dieser Komponente und setzen Sie die Bereitstellung fort. </li><li>  <code>FailWholeDeployProcessImmediately</code> - Ein Fehler in dieser Komponente stoppt den Bereitstellungsprozess. </li><li>  <code>HopeUntilEndOfDeployProcess</code> - Wir hoffen, dass diese Komponente bis zum Ende der Bereitstellung funktioniert. </li></ul><br>  Beispiel: Eine Kombination aus Ressourcen und Annotationswerten im Fehlermodus: <br><br><img src="https://habrastorage.org/webt/ja/qf/ot/jaqfotxaxoxwznieu2lvnnyhih0.png"><br><br>  Bei der ersten Bereitstellung ist die Datenbank (MongoDB) m√∂glicherweise noch nicht bereit. Die Bereitstellung st√ºrzt ab.  Sie k√∂nnen jedoch warten, bis der Start beginnt und die Bereitstellung weiterhin abgeschlossen ist. <br><br>  Es gibt zwei weitere Anmerkungen f√ºr kubedog in werf: <br><br><ul><li>  <code>failures-allowed-per-replica</code> - die Anzahl der erlaubten Drops pro Replikat; </li><li>  <code>show-logs-until</code> till - Passt den Moment an, bis werf (in stdout) Protokolle aller Pods anzeigt, die ausgerollt werden.  Standardm√§√üig ist dies <code>PodIsReady</code> (um Nachrichten zu ignorieren, die wir kaum ben√∂tigen, wenn Datenverkehr auf dem Pod eintrifft). Die Werte <code>ControllerIsReady</code> und <code>EndOfDeploy</code> ebenfalls <code>EndOfDeploy</code> . </li></ul><br><h3>  Was wollen wir noch von der Bereitstellung? </h3><br>  Zus√§tzlich zu den beiden bereits beschriebenen Punkten m√∂chten wir: <br><br><ul><li>  <b>Protokolle</b> zu sehen - und nur notwendig, aber nicht alles; </li><li>  Verfolgen Sie den <b>Fortschritt</b> , denn wenn ein Job mehrere Minuten lang "still" h√§ngt, ist es wichtig zu verstehen, was dort passiert. </li><li>  F√ºhren Sie ein <b>automatisches Rollback</b> durch, falls ein <b>Fehler aufgetreten ist</b> (und daher ist es wichtig, den tats√§chlichen Status der Bereitstellung zu kennen).  Der Rollout muss atomar sein: Entweder geht er bis zum Ende oder alles kehrt in seinen vorherigen Zustand zur√ºck. </li></ul><br><h2>  Zusammenfassung </h2><br>  Als Unternehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reichen</a> es f√ºr uns aus, alle beschriebenen Nuancen in verschiedenen Phasen der Bereitstellung (Erstellen, Ver√∂ffentlichen, Bereitstellen) zu implementieren, das CI-System und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf-</a> Dienstprogramm. <br><br>  Anstelle einer Schlussfolgerung: <br><br><img src="https://habrastorage.org/webt/ja/1y/tc/ja1ytcqobpkbw5rtf78ykb4clnm.png"><br><br>  Mit Hilfe von werf haben wir gute Fortschritte bei der L√∂sung einer Vielzahl von Problemen der DevOps-Ingenieure erzielt und werden uns freuen, wenn die breitere Community dieses Dienstprogramm zumindest in der Praxis ausprobiert.  Gemeinsam ein gutes Ergebnis zu erzielen, wird einfacher. <br><br><h2>  Videos und Folien </h2><br>  Video von der Auff√ºhrung (~ 47 Minuten): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cK3ackGUTLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Pr√§sentation des Berichts: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Andere Kubernetes-Berichte in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatische Skalierung und Ressourcenverwaltung in Kubernetes</a> " <i>(Dmitry Stolyarov; 27. April 2019 beim "Streik")</i> ; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes erweitern und erg√§nzen</a> ‚Äú <i>(Andrey Polov; 8. April 2019 bei Saint HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbanken und Kubernetes</a> " <i>(Dmitry Stolyarov; 8. November 2018 auf HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitoring and Kubernetes</a> " <i>(Dmitry Stolyarov; 28. Mai 2018 bei RootConf)</i> ; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beste CI / CD-Praktiken mit Kubernetes und GitLab</a> ‚Äú <i>(Dmitry Stolyarov; 7. November 2017 bei HighLoad ++)</i> ; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> ‚Äú <i>(Dmitry Stolyarov; 6. Juni 2017 bei RootConf)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460351/">https://habr.com/ru/post/de460351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460341/index.html">Fortsetzung ASO: Trends, Bewertungen und ein bisschen Feedback</a></li>
<li><a href="../de460343/index.html">Die Geschichte, wie die Spieleentwicklung zu einem Teil meines Lebens geworden ist</a></li>
<li><a href="../de460345/index.html">Installieren und konfigurieren Sie Sonata Admin auf Symfony 4</a></li>
<li><a href="../de460347/index.html">Verwaltung mobiler Ger√§te und mehr mit der UEM-L√∂sung von Sophos</a></li>
<li><a href="../de460349/index.html">Check Point Falcon-Beschleunigungskarten - Beschleunigung der Verkehrsverarbeitung</a></li>
<li><a href="../de460353/index.html">Neuronales Netz im Glas. Ben√∂tigt keinen Strom, erkennt Zahlen</a></li>
<li><a href="../de460355/index.html">Das Ertrinken zu retten ist unser Gesch√§ft: wie man mit Teamdemotivation umgeht</a></li>
<li><a href="../de460359/index.html">Young Game Designer 2 Kurs: Balance zwischen Fortschritt und Dynamik ohne Mathematik</a></li>
<li><a href="../de460361/index.html">Tolle FAQ zur Cybersicherheit von medizinischen Informationssystemen</a></li>
<li><a href="../de460363/index.html">7 fehlende Faktoren im Ansatz 12 Faktor App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>