<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏾 ♓️ 🕚 werf - unser Tool für CI / CD in Kubernetes (Review und Video Report) 💪 👵🏼 ⛹🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 27. Mai wurde in der Haupthalle der DevOpsConf 2019-Konferenz, die im Rahmen des RIT ++ 2019- Festivals im Rahmen der Continuous Delivery-Sektion s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>werf - unser Tool für CI / CD in Kubernetes (Review und Video Report)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460351/">  Am 27. Mai wurde in der Haupthalle der DevOpsConf 2019-Konferenz, die im Rahmen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIT ++ 2019-</a> Festivals im Rahmen der Continuous Delivery-Sektion stattfand, der Bericht „werf ist unser Tool für CI / CD in Kubernetes“ veröffentlicht.  Es geht um die <b>Probleme und Herausforderungen, mit denen jeder bei der Bereitstellung auf Kubernetes konfrontiert ist</b> , sowie um die Nuancen, die möglicherweise nicht sofort erkennbar sind.  Wir analysieren mögliche Lösungen und zeigen, wie dies im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf</a> Open Source Tool implementiert wird. <br><br>  Seit der Show hat unser Dienstprogramm (früher bekannt als dapp) die historische Grenze von <b>1000 Sternen auf GitHub</b> überschritten - wir hoffen, dass die wachsende Community seiner Benutzer das Leben vieler DevOps-Ingenieure vereinfachen wird. <br><br><img src="https://habrastorage.org/webt/lh/k9/x1/lhk9x1wf3gzo6bk1lsjosnvjg1g.jpeg"><br><br>  Deshalb präsentieren wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Video mit dem Bericht</b></a> (~ 47 Minuten, viel informativer als der Artikel) und dem Hauptauszug daraus in Textform.  Lass uns gehen! <a name="habracut"></a><br><br><h2>  Code-Lieferung in Kubernetes </h2><br>  Es geht nicht mehr um werf, sondern um CI / CD in Kubernetes, was bedeutet, dass unsere Software in Docker-Containern verpackt ist <i>(darüber habe ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht 2016 gesprochen</a> )</i> , und K8s werden verwendet, um sie in der Produktion zu starten <i>(darüber - im Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2017</a> )</i> . <br><br>  Wie sieht die Lieferung von Kubernetes aus? <br><br><ul><li>  Es gibt ein Git-Repository mit Code und Anweisungen zum Erstellen.  Die Anwendung wird in ein Docker-Image kompiliert und in der Docker-Registrierung veröffentlicht. </li><li>  Im selben Repository finden Sie Anweisungen zum Bereitstellen und Ausführen der Anwendung.  In der Bereitstellungsphase werden diese Anweisungen an Kubernetes gesendet, das das gewünschte Image von der Registrierung empfängt und startet. </li><li>  Außerdem gibt es normalerweise Tests.  Einige davon können beim Veröffentlichen eines Bildes ausgeführt werden.  Sie können auch (nach denselben Anweisungen) eine Kopie der Anwendung (in einem separaten K8s-Namespace oder in einem separaten Cluster) bereitstellen und dort Tests ausführen. </li><li>  Schließlich benötigen wir ein CI-System, das Ereignisse von Git (oder Schaltflächenklicks) empfängt und alle angegebenen Phasen aufruft: Erstellen, Veröffentlichen, Bereitstellen, Testen. </li></ul><br><img src="https://habrastorage.org/webt/vd/jh/ks/vdjhksq3874swybast6v7oerqe4.gif"><br><br>  Hier gibt es einige wichtige Hinweise: <br><br><ol><li>  Da wir über eine unveränderliche Infrastruktur verfügen, muss das Image der Anwendung, die in allen Phasen (Staging, Produktion usw.) <b>verwendet wird, eins sein</b> .  <i>Ich habe hier mehr darüber und mit Beispielen gesprochen.</i> </li><li>  Da wir den <i>IaC-Ansatz (</i> Infrastructure as Code) <i>verfolgen</i> , sollten der Anwendungscode und die Anweisungen zum <i>Erstellen</i> und Ausführen <b>in einem Repository liegen</b> .  <i>Weitere Informationen hierzu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im selben Bericht</a> .</i> </li><li>  Normalerweise sehen wir die Lieferkette <i>(Lieferung) folgendermaßen</i> : Die Anwendung wurde zusammengestellt, getestet, freigegeben <i>(Freigabestufe)</i> und das ist alles - die Lieferung ist erfolgt.  In Wirklichkeit erhält der Benutzer jedoch das, was Sie eingeführt haben, <b>nicht,</b> als Sie es an die Produktion geliefert haben, sondern als er dorthin gehen konnte und diese Produktion funktionierte.  Daher glaube ich, dass die Lieferkette <b>erst in der Betriebsphase</b> <i>(Lauf)</i> endet, genauer gesagt, selbst in dem Moment, in dem der Code aus der Produktion entfernt wurde (indem er durch einen neuen ersetzt wurde). </li></ol><br>  Kehren wir zu dem oben angegebenen Kubernetes-Lieferschema zurück: Es wurde nicht nur von uns erfunden, sondern buchstäblich von allen, die sich mit diesem Problem befasst haben.  Im Wesentlichen heißt dieses Muster jetzt GitOps <i>(mehr über den Begriff und die Ideen dahinter finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> )</i> .  Schauen wir uns die Phasen des Schemas an. <br><br><h2>  Bühne bauen </h2><br>  Es scheint, dass Sie 2019 über die Zusammenstellung von Docker-Images berichten können, wenn jeder weiß, wie man <code>docker build</code> Dateien schreibt und <code>docker build</code> Builds ausführt? Hier sind die Nuancen, auf die ich achten möchte: <br><br><ol><li>  <b>Das Gewicht des Bildes ist</b> wichtig. Verwenden Sie daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrstufig</a> , um nur die Anwendung zu belassen, die wirklich für das Bild benötigt wird. </li><li>  <b>Die Anzahl der Ebenen</b> sollte minimiert werden, indem die Ketten der <code>RUN</code> Befehle innerhalb der Bedeutung kombiniert werden. </li><li>  Dies trägt jedoch zu den <b>Debugging-</b> Problemen bei, da Sie beim Absturz der Assembly den erforderlichen Befehl aus der Kette finden müssen, die das Problem verursacht hat. </li><li>  <b>Die Build-Geschwindigkeit ist</b> wichtig, da wir Änderungen schnell einführen und das Ergebnis betrachten möchten.  Zum Beispiel möchte ich die Abhängigkeiten in den Sprachbibliotheken nicht bei jedem Build der Anwendung neu zusammenstellen. </li><li>  Oft werden <b>viele Bilder</b> aus einem Git-Repository benötigt, die durch eine Reihe von Docker-Dateien (oder benannten Stufen in einer Datei) und ein Bash-Skript mit ihrer sequentiellen Assemblierung gelöst werden können. </li></ol><br>  Es war nur die Spitze des Eisbergs, der sich alle gegenübersehen.  Es gibt aber noch andere Probleme, insbesondere: <br><br><ol><li>  Oft müssen wir in der Assembly-Phase etwas <b>bereitstellen</b> (z. B. das Ergebnis eines Befehls wie apt in einem Verzeichnis eines Drittanbieters zwischenspeichern). </li><li>  Wir wollen <b>Ansible,</b> anstatt auf die Shell zu schreiben. </li><li>  Wir möchten <b>ohne Docker erstellen</b> (warum benötigen wir eine zusätzliche virtuelle Maschine, in der Sie alles dafür konfigurieren müssen, wenn bereits ein Kubernetes-Cluster vorhanden ist, in dem Sie Container ausführen können?). </li><li>  <b>Parallele Assembly</b> , die auf unterschiedliche Weise verstanden werden kann: verschiedene Befehle aus der Docker-Datei (wenn mehrstufig verwendet wird), mehrere Commits eines Repositorys, mehrere Docker-Dateien. </li><li>  <b>Verteilte Montage</b> : Wir wollen etwas in Hülsen sammeln, die „kurzlebig“ sind, weil  Ihr Cache verschwindet, was bedeutet, dass er irgendwo separat gespeichert werden muss. </li><li>  Schließlich nannte ich <b>den</b> Höhepunkt der Wünsche Automagie: Es wäre ideal, in das Repository zu gehen, ein Team einzugeben und ein fertiges Bild zu erhalten, das mit dem Verständnis zusammengestellt ist, wie und was richtig zu tun ist.  Ich persönlich bin mir jedoch nicht sicher, ob alle Nuancen auf diese Weise vorhergesehen werden können. </li></ol><br>  Und hier sind die Projekte: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">moby / buildkit</a> - ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builder</a> der Firma Docker Inc (bereits in die aktuellen Versionen von Docker integriert), der versucht, all diese Probleme zu lösen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kaniko</a> - ein Sammler von Google, mit dem Sie ohne Docker bauen können; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildpacks.io</a> - ein Versuch von CNCF, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auto-</a> Magie zu machen, und insbesondere eine interessante Lösung mit Rebase für Ebenen; </li><li>  und eine Reihe anderer Dienstprogramme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildah</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genuinetools / Img</a> ... </li></ul><br>  ... und sehen, wie viele Sterne sie auf GitHub haben.  Das heißt, einerseits ist und kann <code>docker build</code> etwas tun, aber in Wirklichkeit ist das <b>Problem nicht vollständig gelöst</b> - dies wird durch die parallele Entwicklung alternativer Builder belegt, von denen jeder einige der Probleme löst. <br><br><h2>  Werf einbauen </h2><br>  Also kamen wir zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf</a> <i>(früher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekannt</a> als dapp)</i> - dem Open Source-Dienstprogramm von Flant, das wir seit vielen Jahren betreiben.  Alles begann vor ungefähr 5 Jahren mit Bash-Skripten, die die Zusammenstellung von Dockerfiles optimieren. In den letzten 3 Jahren wurde die vollständige Entwicklung im Rahmen eines Projekts mit einem eigenen Git-Repository fortgesetzt <i>(zuerst in Ruby, dann in Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgeschrieben</a> und gleichzeitig umbenannt)</i> .  Welche Build-Probleme werden in werf behoben? <br><br><img src="https://habrastorage.org/webt/--/1-/ca/--1-cakzswwfhrcrgnees6cvf-a.png"><br><br>  Die blau schattierten Probleme wurden bereits implementiert, die parallele Montage wurde auf demselben Host durchgeführt, und wir planen, die gelben Fragen bis Ende des Sommers zu beantworten. <br><br><h2>  Stadium der Veröffentlichung in der Registrierung (veröffentlichen) </h2><br>  Wir haben <code>docker push</code> eingegeben ... - Was kann beim Hochladen eines Bildes in die Registrierung schwierig sein?  Und dann stellt sich die Frage: "Welches Tag soll das Bild setzen?"  <b>Dies liegt daran,</b> dass wir <b>Gitflow</b> (oder eine andere Git-Strategie) und Kubernetes haben und die Branche sich dafür einsetzt, dass das, was in Kubernetes passiert, dem folgt, was in Git gemacht wird.  Git ist unsere einzige Quelle der Wahrheit. <br><br>  Was ist so kompliziert?  <b>Stellen Sie die Reproduzierbarkeit sicher</b> : von einem Commit in Git, das von Natur aus <i>unveränderlich ist</i> , bis zu einem Docker-Image, das <i>unverändert</i> bleiben muss. <br><br>  Für uns ist es auch wichtig <b>, den Ursprung</b> zu <b>bestimmen</b> , da wir verstehen möchten, aus welchem ​​Commit die in Kubernetes gestartete Anwendung erstellt wurde (dann können wir Unterschiede und ähnliche Dinge tun). <br><br><h3>  Markierungsstrategien </h3><br>  Das erste ist ein einfaches <b>Git-Tag</b> .  Wir haben eine Registrierung mit einem Bild als <code>1.0</code> .  Kubernetes hat Bühne und Produktion, wo dieses Bild gepumpt wird.  In Git machen wir Commits und setzen irgendwann das Tag <code>2.0</code> .  Wir sammeln es gemäß den Anweisungen aus dem Repository und legen es mit dem <code>2.0</code> Tag in der Registrierung ab.  Wir rollen es auf der Bühne aus und wenn alles in Ordnung ist, dann in der Produktion. <br><br><img src="https://habrastorage.org/webt/4f/ub/u4/4fubu4r-0obh9gkzs4_kftnlqxs.gif"><br><br>  Das Problem bei diesem Ansatz ist, dass wir das Tag zuerst festgelegt und erst dann getestet und ausgerollt haben.  Warum?  Erstens ist dies einfach unlogisch: Wir geben eine Softwareversion heraus, die wir noch nicht einmal getestet haben (wir können nichts anderes tun, da Sie zur Überprüfung ein Tag einfügen müssen).  Zweitens ist dieser Weg nicht mit Gitflow kompatibel. <br><br>  Die zweite Option ist <b>git commit + tag</b> .  Im Hauptzweig befindet sich ein <code>1.0</code> Tag.  für ihn in der Registrierung - ein Image, das für die Produktion bereitgestellt wird.  Darüber hinaus verfügt der Kubernetes-Cluster über Vorschau- und Staging-Schleifen.  Weiter folgen wir Gitflow: Im Hauptzweig für die Entwicklung <code>develop</code> wir neue Funktionen, aufgrund derer ein Commit mit der Kennung <code>#c1</code> .  Wir sammeln es und veröffentlichen es in der Registrierung unter Verwendung dieser Kennung ( <code>#c1</code> ).  Wir rollen die Vorschau mit derselben Kennung aus.  Wir machen dasselbe mit den Commits <code>#c2</code> und <code>#c3</code> . <br><br>  Als wir feststellten, dass es genügend Funktionen gibt, beginnen wir, alles zu stabilisieren.  Erstellen Sie in Git den Zweig <code>release_1.1</code> (basierend auf <code>#c3</code> von <code>develop</code> ).  Das Sammeln dieser Version ist nicht erforderlich, da  Dies wurde im vorherigen Schritt durchgeführt.  Daher können wir es einfach auf die Inszenierung ausrollen.  Wir beheben Fehler in <code>#c4</code> und rollen sie ebenfalls auf Staging aus.  Gleichzeitig wird derzeit eine <code>develop</code> , bei der regelmäßig Änderungen gegenüber <code>release_1.1</code> werden.  Irgendwann bekommen wir ein Commit und werden zum Staging Commit herausgepumpt, mit dem wir zufrieden sind ( <code>#c25</code> ). <br><br>  Dann führen wir eine Zusammenführung (mit schnellem Vorlauf) des Release-Zweigs ( <code>release_1.1</code> ) im Master durch.  Wir haben diesem Commit ein Tag mit der neuen Version ( <code>1.1</code> ) hinzugefügt.  Dieses Bild ist jedoch bereits in der Registrierung zusammengestellt. Um es nicht erneut zu erfassen, fügen wir dem vorhandenen Bild nur ein zweites Tag hinzu (jetzt enthält es die Tags <code>#c25</code> und <code>1.1</code> in der Registrierung).  Danach rollen wir es in die Produktion aus. <br><br>  Es gibt einen Nachteil, dass ein Bild ( <code>#c25</code> ) beim Staging <code>#c25</code> wird und ein anderes ( <code>1.1</code> ) bei der Produktion <code>#c25</code> , aber wir wissen, dass es sich "physisch" um dasselbe Bild aus der Registrierung handelt. <br><br><img src="https://habrastorage.org/webt/mb/pq/iu/mbpqiumzomvrouhp8llx5aishza.gif"><br><br>  Das eigentliche Minus ist, dass es keine Unterstützung für Merge Commit'ov gibt. Sie müssen einen schnellen Vorlauf durchführen. <br><br>  Sie können noch weiter gehen und den Trick machen ... Betrachten Sie ein Beispiel für eine einfache Docker-Datei: <br><br><pre> <code class="plaintext hljs">FROM ruby:2.3 as assets RUN mkdir -p /app WORKDIR /app COPY . ./ RUN gem install bundler &amp;&amp; bundle install RUN bundle exec rake assets:precompile CMD bundle exec puma -C config/puma.rb FROM nginx:alpine COPY --from=assets /app/public /usr/share/nginx/www/public</code> </pre> <br>  Wir erstellen daraus eine Datei nach diesem Prinzip, das wir nehmen: <br><br><ul><li>  SHA256 aus Kennungen der verwendeten Bilder ( <code>ruby:2.3</code> und <code>nginx:alpine</code> ), die Prüfsummen ihres Inhalts sind; </li><li>  alle Teams ( <code>RUN</code> , <code>CMD</code> usw.); </li><li>  SHA256 aus Dateien, die hinzugefügt wurden. </li></ul><br>  ... und nehmen Sie die Prüfsumme (wieder SHA256) aus einer solchen Datei.  Dies ist die <b>Signatur von</b> allem, was den Inhalt eines Docker-Images definiert. <br><br><img src="https://habrastorage.org/webt/zp/w2/ju/zpw2jup54xa66mit1bt9u7amwlk.gif"><br><br>  <b>Kehren wir</b> zum Schema zurück und verwenden <b>anstelle von Commits solche Signaturen</b> , d. H.  Kennzeichnen Sie Bilder mit Signaturen. <br><br><img src="https://habrastorage.org/webt/pr/d3/wf/prd3wfn6ctkod9ddqqmgtqnr1ew.gif"><br><br>  Wenn Sie beispielsweise Änderungen von der Version zum Master zusammenführen müssen, können Sie ein echtes Zusammenführungs-Commit durchführen: Es hat eine andere Kennung, aber dieselbe Signatur.  Mit der gleichen Kennung werden wir das Bild auch in der Produktion ausrollen. <br><br>  Der Nachteil ist, dass jetzt nicht mehr festgestellt werden kann, welche Art von Commit in die Produktion gepumpt wurde - Prüfsummen funktionieren nur in eine Richtung.  Dieses Problem wird durch eine zusätzliche Ebene mit Metadaten gelöst - mehr dazu später. <br><br><h3>  Tagging in werf </h3><br>  In werf sind wir noch weiter gegangen und bereiten uns darauf vor, eine verteilte Assembly mit einem Cache zu erstellen, der nicht auf demselben Computer gespeichert ist ... Wir haben also zwei Arten von Docker-Images, die wir <i>Stage</i> und <i>Image nennen</i> . <br><br>  Das werf Git-Repository speichert spezifische Build-Anweisungen, die die verschiedenen Phasen des Builds beschreiben ( <i>beforeInstall</i> , <i>install</i> , <i>beforeSetup</i> , <i>setup</i> ).  Wir sammeln das Bild der ersten Stufe mit einer Signatur, die als Prüfsumme der ersten Schritte definiert ist.  Dann fügen wir den Quellcode hinzu, für das neue Bühnenbild betrachten wir seine Prüfsumme ... Diese Operationen werden für alle Stufen wiederholt, wodurch wir eine Reihe von Bühnenbildern erhalten.  Dann machen wir das endgültige Bild-Bild, das auch Metadaten über seinen Ursprung enthält.  Und wir markieren dieses Bild auf verschiedene Arten (Details später). <br><br><img src="https://habrastorage.org/webt/4a/uw/am/4auwamdra7bm0xtvht35kpbstye.gif"><br><br>  Lassen Sie danach ein neues Commit erscheinen, in dem nur der Anwendungscode geändert wird.  Was wird passieren?  Für Codeänderungen wird ein Patch erstellt und ein neues Bühnenbild erstellt.  Seine Signatur wird als Prüfsumme des alten Bühnenbildes und des neuen Patches definiert.  Aus diesem Bild wird ein neues endgültiges Bildbild erzeugt.  Ein ähnliches Verhalten tritt bei Änderungen in anderen Phasen auf. <br><br>  Bühnenbilder sind somit ein Cache, der verteilt verteilt werden kann, und bereits daraus erstellte Bildbilder werden in die Docker-Registrierung geladen. <br><br><img src="https://habrastorage.org/webt/sc/8j/me/sc8jme4f1jfqbrbwt1anf2-rja8.gif"><br><br><h3>  Registry-Reinigung </h3><br>  Hier geht es nicht darum, Ebenen zu löschen, die nach gelöschten Tags hängen bleiben. Dies ist eine Standardfunktion der Docker-Registrierung.  Dies ist eine Situation, in der sich viele Docker-Tags ansammeln und wir verstehen, dass wir einige davon nicht mehr benötigen und sie Platz beanspruchen (und / oder wir dafür bezahlen). <br><br>  Was sind die Reinigungsstrategien? <br><br><ol><li>  Sie können einfach <b>nichts reinigen</b> .  Manchmal ist es wirklich einfacher, ein wenig für den zusätzlichen Platz zu bezahlen, als einen riesigen Ball mit Tags zu entwirren.  Dies funktioniert aber nur bis zu einem bestimmten Punkt. </li><li>  <b>Vollständiger Reset</b> .  Wenn Sie alle Bilder löschen und nur die relevanten im CI-System neu erstellen, kann ein Problem auftreten.  Wenn der Container bei der Produktion neu gestartet wird, wird ein neues Image für ihn geladen - eines, das noch von niemandem getestet wurde.  Dies tötet die Idee einer unveränderlichen Infrastruktur. </li><li>  <b>Blaugrün</b> .  Eine Registrierung begann zu überlaufen - Bilder wurden in eine andere geladen.  Das gleiche Problem wie bei der vorherigen Methode: Ab wann können Sie die Registrierung bereinigen, die übergelaufen ist? </li><li>  <b>Mit der Zeit</b> .  Alle Bilder löschen, die älter als 1 Monat sind?  Aber es wird sicher einen Dienst geben, der seit einem Monat nicht mehr aktualisiert wurde ... </li><li>  <b>Manuell</b> bestimmen, was bereits gelöscht werden kann. </li></ol><br>  Es gibt zwei wirklich praktikable Optionen: Nicht reinigen oder eine Kombination aus Blaugrün + manuell.  Im letzteren Fall handelt es sich um Folgendes: Wenn Sie verstehen, dass es Zeit ist, die Registrierung zu bereinigen, erstellen Sie eine neue und fügen Sie beispielsweise für einen Monat alle neuen Bilder hinzu.  Überprüfen Sie einen Monat später, welche Pods in Kubernetes noch die alte Registrierung verwenden, und übertragen Sie sie auch in die neue Registrierung. <br><br>  <b>Wo sind</b> wir zu <b>werf gegangen</b> ?  Wir sammeln: <br><br><ol><li>  Git-Kopf: alle Tags, alle Zweige - vorausgesetzt, dass alles, was in Git getestet wird, in den Bildern benötigt wird (und wenn nicht, müssen wir es im Git selbst löschen); </li><li>  alle Pods, die jetzt in Kubernetes heruntergeladen werden; </li><li>  alte ReplicaSets (etwas, das kürzlich herausgepumpt wurde) sowie wir planen, Helm-Releases zu scannen und dort die neuesten Bilder auszuwählen. </li></ol><br>  ... und wir erstellen eine Whitelist aus diesem Set - eine Liste von Bildern, die wir nicht löschen werden.  Wir säubern alles andere, danach finden wir die verwaisten Bühnenbilder und löschen sie auch. <br><br><h2>  Bereitstellungsphase (Bereitstellung) </h2><br><h3>  Robuste Deklarativität </h3><br>  Der erste Punkt, auf den ich in der Bereitstellung aufmerksam machen möchte, ist die Einführung der deklarativ deklarierten aktualisierten Ressourcenkonfiguration.  Das ursprüngliche YAML-Dokument, das die Kubernetes-Ressourcen beschreibt, unterscheidet sich immer stark von dem Ergebnis, das tatsächlich im Cluster funktioniert.  Weil Kubernetes die Konfiguration erweitert: <br><br><ol><li>  Bezeichner </li><li>  Serviceinformationen; </li><li>  viele Standardwerte; </li><li>  Abschnitt mit aktuellem Status; </li><li>  Änderungen, die im Rahmen des Zulassungs-Webhooks vorgenommen wurden; </li><li>  das Ergebnis der Arbeit verschiedener Controller (und Scheduler). </li></ol><br>  Wenn eine neue Konfiguration einer Ressource ( <i>neu</i> ) angezeigt wird, können wir daher nicht einfach die aktuelle "Live" -Konfiguration ( <i>Live</i> ) übernehmen und damit überschreiben.  Dazu müssen wir <i>new</i> mit der zuletzt angewendeten ( <i>zuletzt angewendeten</i> ) Konfiguration vergleichen und den resultierenden Patch <i>live übertragen</i> . <br><br>  Dieser Ansatz wird als <b>2-Wege-Zusammenführung bezeichnet</b> .  Es wird zum Beispiel in Helm verwendet. <br><br>  Es gibt auch eine <b>3-Wege-Zusammenführung</b> , die sich darin unterscheidet: <br><br><ul><li>  Beim Vergleich von <i>zuletzt angewendet</i> und <i>neu sehen</i> wir uns an, was entfernt wurde. </li><li>  Beim Vergleich von <i>Neuem</i> und <i>Live sehen</i> wir, was hinzugefügt oder geändert wurde. </li><li>  Wende den zusammengefassten Patch auf <i>live an</i> . </li></ul><br>  Wir stellen mehr als 1000 Anwendungen mit Helm bereit, sodass wir tatsächlich mit einer 2-Wege-Zusammenführung leben.  Er hat jedoch eine Reihe von Problemen, die wir mit unseren Patches gelöst haben, die Helm helfen, normal zu arbeiten. <br><br><h3>  Aktueller Rollout-Status </h3><br>  Nach dem nächsten Ereignis hat unser CI-System eine neue Konfiguration für Kubernetes generiert und diese mit Helm oder <code>kubectl apply</code> an den Cluster <code>kubectl apply</code> .  Als nächstes findet die bereits beschriebene N-Wege-Zusammenführung statt, zu der die Kubernetes-API das CI-System genehmigt und dieses auf seinen Benutzer reagiert. <br><br><img src="https://habrastorage.org/webt/sk/vh/-u/skvh-uifcwg6_d5mgxhehh39q9i.png"><br><br>  Es gibt jedoch ein großes Problem: Eine <b>erfolgreiche Anwendung bedeutet schließlich keinen erfolgreichen Rollout</b> .  Wenn Kubernetes versteht, welche Änderungen anzuwenden sind, wendet er sie an - wir wissen immer noch nicht, wie das Ergebnis aussehen wird.  Das Aktualisieren und Neustarten von Pods im Frontend kann beispielsweise erfolgreich sein, nicht jedoch im Backend, und wir erhalten verschiedene Versionen der ausgeführten Anwendungsabbilder. <br><br>  Um alles richtig zu machen, entsteht in diesem Schema ein zusätzlicher Link - ein spezieller Tracker, der Statusinformationen von der Kubernetes-API empfängt und zur weiteren Analyse des tatsächlichen Zustands der Dinge überträgt.  Wir haben eine Open Source-Bibliothek auf Go - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>kubedog erstellt</b></a> <i>(siehe Ankündigung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> )</i> - die dieses Problem löst und in werf integriert ist. <br><br>  Das Verhalten dieses Trackers auf werf-Ebene wird mithilfe von Anmerkungen konfiguriert, die in Deployments oder StatefulSets eingefügt werden.  Die Hauptanmerkung <code>fail-mode</code> versteht die folgenden Bedeutungen: <br><br><ul><li>  <code>IgnoreAndContinueDeployProcess</code> - Ignorieren Sie <code>IgnoreAndContinueDeployProcess</code> Probleme dieser Komponente und setzen Sie die Bereitstellung fort. </li><li>  <code>FailWholeDeployProcessImmediately</code> - Ein Fehler in dieser Komponente stoppt den Bereitstellungsprozess. </li><li>  <code>HopeUntilEndOfDeployProcess</code> - Wir hoffen, dass diese Komponente bis zum Ende der Bereitstellung funktioniert. </li></ul><br>  Beispiel: Eine Kombination aus Ressourcen und Annotationswerten im Fehlermodus: <br><br><img src="https://habrastorage.org/webt/ja/qf/ot/jaqfotxaxoxwznieu2lvnnyhih0.png"><br><br>  Bei der ersten Bereitstellung ist die Datenbank (MongoDB) möglicherweise noch nicht bereit. Die Bereitstellung stürzt ab.  Sie können jedoch warten, bis der Start beginnt und die Bereitstellung weiterhin abgeschlossen ist. <br><br>  Es gibt zwei weitere Anmerkungen für kubedog in werf: <br><br><ul><li>  <code>failures-allowed-per-replica</code> - die Anzahl der erlaubten Drops pro Replikat; </li><li>  <code>show-logs-until</code> till - Passt den Moment an, bis werf (in stdout) Protokolle aller Pods anzeigt, die ausgerollt werden.  Standardmäßig ist dies <code>PodIsReady</code> (um Nachrichten zu ignorieren, die wir kaum benötigen, wenn Datenverkehr auf dem Pod eintrifft). Die Werte <code>ControllerIsReady</code> und <code>EndOfDeploy</code> ebenfalls <code>EndOfDeploy</code> . </li></ul><br><h3>  Was wollen wir noch von der Bereitstellung? </h3><br>  Zusätzlich zu den beiden bereits beschriebenen Punkten möchten wir: <br><br><ul><li>  <b>Protokolle</b> zu sehen - und nur notwendig, aber nicht alles; </li><li>  Verfolgen Sie den <b>Fortschritt</b> , denn wenn ein Job mehrere Minuten lang "still" hängt, ist es wichtig zu verstehen, was dort passiert. </li><li>  Führen Sie ein <b>automatisches Rollback</b> durch, falls ein <b>Fehler aufgetreten ist</b> (und daher ist es wichtig, den tatsächlichen Status der Bereitstellung zu kennen).  Der Rollout muss atomar sein: Entweder geht er bis zum Ende oder alles kehrt in seinen vorherigen Zustand zurück. </li></ul><br><h2>  Zusammenfassung </h2><br>  Als Unternehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reichen</a> es für uns aus, alle beschriebenen Nuancen in verschiedenen Phasen der Bereitstellung (Erstellen, Veröffentlichen, Bereitstellen) zu implementieren, das CI-System und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf-</a> Dienstprogramm. <br><br>  Anstelle einer Schlussfolgerung: <br><br><img src="https://habrastorage.org/webt/ja/1y/tc/ja1ytcqobpkbw5rtf78ykb4clnm.png"><br><br>  Mit Hilfe von werf haben wir gute Fortschritte bei der Lösung einer Vielzahl von Problemen der DevOps-Ingenieure erzielt und werden uns freuen, wenn die breitere Community dieses Dienstprogramm zumindest in der Praxis ausprobiert.  Gemeinsam ein gutes Ergebnis zu erzielen, wird einfacher. <br><br><h2>  Videos und Folien </h2><br>  Video von der Aufführung (~ 47 Minuten): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cK3ackGUTLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Präsentation des Berichts: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Andere Kubernetes-Berichte in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatische Skalierung und Ressourcenverwaltung in Kubernetes</a> " <i>(Dmitry Stolyarov; 27. April 2019 beim "Streik")</i> ; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes erweitern und ergänzen</a> “ <i>(Andrey Polov; 8. April 2019 bei Saint HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbanken und Kubernetes</a> " <i>(Dmitry Stolyarov; 8. November 2018 auf HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitoring and Kubernetes</a> " <i>(Dmitry Stolyarov; 28. Mai 2018 bei RootConf)</i> ; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beste CI / CD-Praktiken mit Kubernetes und GitLab</a> “ <i>(Dmitry Stolyarov; 7. November 2017 bei HighLoad ++)</i> ; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> “ <i>(Dmitry Stolyarov; 6. Juni 2017 bei RootConf)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460351/">https://habr.com/ru/post/de460351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460341/index.html">Fortsetzung ASO: Trends, Bewertungen und ein bisschen Feedback</a></li>
<li><a href="../de460343/index.html">Die Geschichte, wie die Spieleentwicklung zu einem Teil meines Lebens geworden ist</a></li>
<li><a href="../de460345/index.html">Installieren und konfigurieren Sie Sonata Admin auf Symfony 4</a></li>
<li><a href="../de460347/index.html">Verwaltung mobiler Geräte und mehr mit der UEM-Lösung von Sophos</a></li>
<li><a href="../de460349/index.html">Check Point Falcon-Beschleunigungskarten - Beschleunigung der Verkehrsverarbeitung</a></li>
<li><a href="../de460353/index.html">Neuronales Netz im Glas. Benötigt keinen Strom, erkennt Zahlen</a></li>
<li><a href="../de460355/index.html">Das Ertrinken zu retten ist unser Geschäft: wie man mit Teamdemotivation umgeht</a></li>
<li><a href="../de460359/index.html">Young Game Designer 2 Kurs: Balance zwischen Fortschritt und Dynamik ohne Mathematik</a></li>
<li><a href="../de460361/index.html">Tolle FAQ zur Cybersicherheit von medizinischen Informationssystemen</a></li>
<li><a href="../de460363/index.html">7 fehlende Faktoren im Ansatz 12 Faktor App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>