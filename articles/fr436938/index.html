<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💬 👩🏼‍⚖️ 🏇🏽 Guix est le système d'exploitation le plus avancé. ⛺️ 🕘 🕋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les systèmes d'exploitation (OS) sont un sujet approfondi. Pendant des décennies, une approche a dominé ici: Unix. En effet, la plupart des systèmes m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guix est le système d'exploitation le plus avancé.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436938/"> Les systèmes d'exploitation (OS) sont un sujet approfondi.  Pendant des décennies, une approche a dominé ici: Unix.  En effet, la plupart des systèmes modernes, y compris la plupart des distributions GNU / Linux, * BSD et macOS, adhèrent à l'architecture Unix.  (Il n'y a pas de Windows, mais il n'y a presque rien d'intéressant sur ce sujet). <br><br>  En 2000, Rob Pike a fait un exposé sur les raisons pour lesquelles la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche sur les logiciels système n'est pas pertinente</a> .  En raison du pessimisme ou de la négligence de la communauté, il semble avoir complètement ignoré les plaintes recueillies par de nombreux utilisateurs d'Unix dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Unix-Haters Handbook</a> (1994).  Le livre est délibérément sarcastique, mais souligne certains problèmes critiques avec les systèmes Unix - et ils n'ont pas encore été résolus. <br><br>  En 2006, Elko Dositra a publié sa thèse, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Un modèle de déploiement de logiciel entièrement fonctionnel»,</a> qui décrit le gestionnaire de packages Nix fonctionnel.  En 2008, l'auteur a publié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NixOS: une distribution Linux entièrement fonctionnelle</a> .  Alors que NixOS réutilise beaucoup de logiciels gratuits pour les systèmes Unix, il est si loin de la conception et de la philosophie Unix qu'il peut difficilement être appelé un «système Unix». <br><a name="habracut"></a><br>  Nix est un grand pas en avant dans l'ingénierie des systèmes.  Cet OS a non seulement résolu de nombreux problèmes Unix (y compris les critiques de la collection susmentionnée), mais a également ouvert la voie à de nombreuses autres fonctions et études qui peuvent jouer un rôle très important à notre époque, lorsque la fiabilité et la sécurité sont devenues le sujet principal de nombreux travaux scientifiques, publics et politiques. débat. <br><br>  Pike avait tort.  Et cela prouve un autre point plus général: il est probablement plus sage de s’abstenir de déclarer toute recherche non pertinente si vous ne pouvez pas prouver l’impossibilité de poursuivre le développement.  Et le rapport mentionné peut difficilement être considéré comme une preuve mathématique.  Il n'a fait que renforcer l'idée qu'Unix est «assez bon» et que vous devez accepter ses fonctionnalités et ses problèmes. <br><br>  Heureusement, ce pessimisme inutile était myope et n'a pas duré longtemps: quelques années plus tard, le système Nix l'a prouvé. <br><br><h1>  Apparence de Guix </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guix</a> est le gestionnaire de paquets sur Nix, et GuixSD est le système d'exploitation, l'équivalent de NixOS, qui vise à être un «OS entièrement programmable».  En effet, presque tout ici est écrit et configuré dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma Guile</a> : de la gestion des paquets Guix au système d'initialisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU</a> Shepherd. <br><br>  Guix est très différent des systèmes d'exploitation Unix.  Vous pouvez consulter la documentation et évaluer le degré de changement: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide officiel</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste des fonctionnalités</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le Guix Package Guide</a> est une introduction technique (copie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). </li></ul><br><h1>  Avantages sociaux chez Guix </h1><br>  Les avantages de Guix sont révolutionnaires au point où le reste du système d'exploitation ressemble à des systèmes hérités par rapport à lui. <br><br>  Mes fonctionnalités préférées personnelles: <br><br><ul><li>  Invulnérabilité du système: Guix conserve un historique de tous les changements au niveau du système et de l'utilisateur.  Si la mise à jour casse quelque chose, vous pouvez toujours revenir en arrière.  Cela rend le système pratiquement <i>invulnérable</i> . <br></li><li>  Intégrité: puisque la configuration est déclarative, elle donne à l'utilisateur ou à l'administrateur système un contrôle complet.  Sur les autres variantes Unix, il est beaucoup plus difficile de dire quand un fichier de configuration aléatoire change. <br></li><li>  Système d'exploitation entièrement programmable: programmez les configurations du système et utilisez un système de contrôle de version.  De nombreux services système peuvent être configurés dans le Guile Scheme: des règles udev à Xorg, PAM, etc. Grâce à Guile, la configuration peut être conditionnée par le matériel ou même le nom d'hôte! <br></li><li>  Remplacement direct d'autres gestionnaires de packages (pas si bons): pourquoi gérer séparément les packages Emacs, Python ou TeXlive s'il y a une seule interface pour tout le monde (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ci</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessous</a> )!  Il est plus facile d'écrire et de gérer des déclarations pour les profils utilisateur. <br></li><li>  Définitions de packages Guile: il est beaucoup plus efficace de développer des définitions de packages en <i>vrac</i> .  Il remplace avantageusement des concepts tels que les indicateurs Portage USE (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ci</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessous</a> ). <br></li><li>  Plusieurs modes d'émission de packages: Un package Guix peut avoir plusieurs «modes d'émission» qui servent à séparer les différents composants (bibliothèques, outils supplémentaires, documentation, etc.).  Sur d'autres systèmes d'exploitation (généralement Debian), il est plus difficile de deviner quels paquets s'emboîtent. <br></li><li> Entrées non multiplicatives: dans la terminologie Guix, les «entrées» sont des dépendances de paquet.  Le profil utilisateur et l'environnement ne contiennent que des packages installés explicitement par l'utilisateur et pas nécessairement leurs dépendances.  Par exemple, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inxi</a> , un outil de génération de rapports sur les informations système: si je ne suis intéressé que par les rapports sur le système / équipement inxi, il n'est pas nécessaire d'ajouter deux à trois douzaines d'outils de ligne de commande supplémentaires à <code>PATH</code> .  Guix vous permet d'afficher dans le profil de l'utilisateur uniquement ce dont il a vraiment besoin. <br></li><li>  Environnements Guix: Lorsque vous exécutez un <code>guix environment SOME-PACKAGES</code> Guix <code>guix environment SOME-PACKAGES</code> Guix met en place un environnement temporaire où toutes les exigences pour <code>SOME-PACKAGES</code> .  Cela peut être utilisé pour configurer facilement l'environnement de construction pour le projet, ainsi qu'à d'autres fins (voir ci-dessous).  Une grande qualité - ils vous permettent d'exécuter des programmes sans les installer dans le profil utilisateur. <br></li><li>  Mises à jour partielles: 100% pris en charge.  C'est probablement la principale cause de pannes dans les versions flottantes comme Arch Linux et Gentoo: comme seules plusieurs versions y sont prises en charge en même temps (généralement une seule), l'ensemble du système doit être mis à jour dans son ensemble.  Cela signifie plus de trafic à chaque mise à jour.  Avec Guix, tout package est mis à jour individuellement. <br></li><li>  Intégration continue ou pourquoi Guix peut fonctionner sans mainteneurs de packages: grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des versions reproductibles</a> et à la prise en charge des mises à jour partielles, si le package fonctionne sur Guix, il fonctionnera "toujours" et certaines dépendances ne se briseront pas lors de la prochaine mise à jour (plus précisément, si la dépendance rompt le package, alors cela est trivialement corrigé pour utiliser la bonne version de la bibliothèque).  Ainsi, le travail avec les packages peut être transféré vers des «fermes d'assemblage» (l'une sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hydra</a> du projet Nix, l'autre sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cuirass</a> ).  Comparez cela à la plupart des autres communautés GNU / Linux, qui nécessitent des dizaines de mainteneurs pour mettre à niveau des milliers de packages.  Cette approche n'est pas évolutive: au final, ces distributions stagnent sur quelques milliers de packages.  À Guix, le nombre de colis peut augmenter tranquillement sans crainte de s'effondrer.  Dans le même temps, les contributeurs peuvent être utilisés plus efficacement. <br><br>  À Guix, la construction à partir des sources est tout aussi simple.  En fait, ce n'est pas si important pour l'utilisateur final: Guix peut facilement retourner à l'assemblage depuis les sources si le paquet fini n'est pas disponible. <br></li><li>  <code>guix import</code> et <code>guix refresh</code> : créez ou mettez à jour automatiquement et récursivement les définitions de package.  Des centaines de définitions sont traitées simultanément.  Ces fonctionnalités soulignent les avantages d'un véritable langage de programmation dans le système d'exploitation.  Ce qui est une tâche difficile sur la plupart des systèmes d'exploitation, elle est relativement facile à implémenter dans Guix. <br></li><li>  Chaînes Guix: une de mes fonctionnalités préférées!  Arch Linux ou Gentoo vous oblige à créer un référentiel local.  Comme ils ne prennent pas en charge les mises à jour partielles, l'utilisateur doit effectuer une maintenance de temps en temps (c'est-à-dire s'assurer que les mises à jour des dépendances ne cassent pas les packages).  Les canaux Guix remplacent avantageusement les superpositions AUR d'Arch Linux et Gentoo, permettant à quiconque de distribuer leurs définitions de packages, par exemple, à partir des référentiels Git.  Encore une fois, cela garantit une transparence totale (pots-de-vin, historique, etc.). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emacs-Guix</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pour</a> autant que je sache, Guix est la seule distribution à être livrée avec l'interface utilisateur Emacs la plus puissante! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Packs Guix</a> : une véritable alternative aux conteneurs comme Docker.  La plupart des systèmes de conteneurs souffrent de problèmes critiques: ils ne peuvent pas être lus et en réalité ce sont des binaires opaques, ce qui est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">catégoriquement inacceptable</a> pour les utilisateurs qui se soucient de la confiance, de la sécurité et de la confidentialité.  Au contraire, les packs Guix sont absolument clairs, reproductibles et transparents. <br></li><li>  <code>guix system vm</code> et <code>guix system disk-image</code> : Guix simplifie la lecture de l'intégralité du système actuel en tant qu'USB en direct, à l'intérieur de la machine virtuelle ou sur une machine distante. </li></ul><br><h1>  Guix en comparaison avec ses concurrents </h1><br><h3>  Debian, Arch Linux et la plupart des autres distributions GNU / Linux </h3><br>  Les distributions GNU / Linux n'ont généralement pas les avantages susmentionnés de Guix.  Les lacunes les plus critiques: <br><br><ul><li>  Manque de support pour plusieurs versions de packages ou «enfer des dépendances».  Supposons que le dernier mpv nécessite un nouveau ffmpeg, mais la mise à jour de ffmpeg interrompt la plupart des autres programmes.  Nous sommes coincés dans un dilemme: soit casser des paquets, soit sauvegarder les anciennes versions.  Pire encore, il peut ne pas y avoir de package approprié ou il n'y a pas de prise en charge du système d'exploitation.  Ce problème est inhérent à la plupart des distributions qui ne peuvent garantir l'accomplissement de leur tâche principale: un package pour <i>n'importe quel</i> programme. <br></li><li>  Dépendance critique envers les mainteneurs.  La gestion des packages non fonctionnels signifie que tous les packages doivent être constamment testés pour la compatibilité.  C'est beaucoup de travail acharné pour ceux sur les épaules desquels cette tâche a été confiée.  En pratique, cela signifie que la qualité de la gestion des packages dépend fortement des personnes.  Une distribution sans un nombre suffisant de mainteneurs souffrira inévitablement et pourrait même mourir.  Cette exigence de main-d'œuvre n'est pas normalement mise à l'échelle et, à mesure que le nombre de paquets augmente, elle entraîne une augmentation de la complexité (à la fois dans la base de code et dans la gestion). </li></ul><br><a name="2"></a><h3>  Gentoo, * BSD </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gentoo</a> et d'autres distributions avec le gestionnaire de paquets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Portage</a> ont une caractéristique célèbre: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UTILISER des drapeaux</a> pour activer des fonctions dans tout le système (par exemple, couper le son, activer le support de l'interface graphique, etc.). <br><br>  Les indicateurs USE rendent trivial l'activation ou la désactivation des fonctions de l'auteur du package (et l'avantage est qu'elles sont testées).  En revanche, Portage ne vous permet pas de configurer des fonctionnalités qui ne sont pas pensées à l'avance.  Par exemple, si un package a un son supplémentaire, mais que l'auteur n'a pas défini l'indicateur correspondant, l'utilisateur ne pourra rien y faire (sauf pour créer une nouvelle définition de package). <br><br>  Par comparaison, Guix vous permet de tout personnaliser, mais avec un peu plus de code Scheme.  En pseudo code, cela ressemble à ceci: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loop-over</span></span> (<span class="hljs-name"><span class="hljs-name">TARGET-PACKAGES</span></span>) (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> TARGET) (<span class="hljs-name"><span class="hljs-name">changes-here</span></span>... including patches, build options, etc.))</code> </pre> <br>  Ce lot de code définit les définitions des <code>TARGET-PACKAGES</code> avec vos modifications.  Aucune des modifications ne doit être apportée à la définition du package.  À tout moment, l'utilisateur conserve un contrôle total sur les modifications qui peuvent être apportées aux packages. <br><br>  J'ai adoré Gentoo, mais après être passé à Guix, les limites de Portage sont devenues apparentes. <br><br><ul><li>  Le système de drapeau USE ne permet pas la personnalisation de fonctions arbitraires non planifiées. <br></li><li>  L'utilisation de drapeaux ajoute une classe entière de complexité (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sémantique des atomes</a> plutôt compliquée) pour décrire et gérer la relation des fonctions entre les packages.  Guix supprime complètement ce niveau de complexité en utilisant Guile Scheme pour programmer les relations. </li></ul><br>  De plus, Portage souffre du même problème avec le manque de prise en charge appropriée pour plusieurs versions, et les indicateurs augmentent considérablement l'ampleur du problème (une plainte fréquente à propos de Portage): lorsque des indicateurs USE incompatibles s'appliquent à certaines dépendances, l'utilisateur doit rechercher manuellement une solution.  Parfois, cela signifie que la fonction requise n'est pas applicable (du moins sans travail important sur les définitions de package). <br><br>  En pratique, Guix fournit des packages pré-compilés - un énorme gain de temps par rapport à Gentoo (bien que Portage supporte la distribution de packages binaires). <br><br>  * Les systèmes BSD (par exemple FreeBSD) souffrent de problèmes similaires dans la <code>make config</code> . <br><br><h3>  Nix </h3><br>  Nix a été une percée historique dans la recherche de systèmes d'exploitation, et Guix a emprunté presque toutes ses idées à partir de là.  Aujourd'hui, Nix est toujours l'un des meilleurs systèmes d'exploitation actifs.  Guix n'aurait probablement pas existé sans un défaut. <br><br>  À mon avis, Guix résout le problème principal de Nix: au lieu de son propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage spécifique au domaine</a> (DSL), un langage de programmation complet basé sur Lisp Guile Scheme est utilisé ici. <br><br>  «Mettre en œuvre votre propre langage de programmation» est une idée fausse très courante dans le développement de logiciels.  Cela a touché de nombreux projets où le langage de configuration ou de programmation souffrait des inconvénients suivants: <br><br><ul><li>  expressivité et capacités limitées; <br></li><li>  Une autre langue d'apprentissage (mais pas quelque chose de très utile et universel), qui nécessite un certain effort de la part de l'utilisateur et crée ainsi une barrière à l'entrée; <br></li><li>  code moins lisible (au moins au début); <br></li><li>  performances souvent médiocres. </li></ul><br>  Il y a tellement de projets dans des langues locales ou trop limitées: <br><br><ul><li>  XML, HTML (encore mieux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S-XML</a> ) </li><li>  Make, Autoconf, Automake, Cmake, etc. </li><li>  Bash, Zsh, Fish (encore mieux: Eshell ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scsh</a> ) </li><li>  JSON, TOML, YAML </li><li>  Portage vers Nix <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ebuild</a> et de nombreuses autres règles de syntaxe pour les définitions de packages OS </li><li>  Firefox lorsqu'il est utilisé XUL (Mozilla l'a depuis abandonné) et la plupart des autres langues locales pour les extensions </li><li>  SQL </li><li>  Octave, R, PARI / GP, la plupart des programmes scientifiques (par exemple Common Lisp, Racket et autres schémas) </li><li>  Expressions régulières ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rx dans Emacs</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEG dans Racket</a> , etc.) </li><li>  sed, AWK, etc. </li><li>  La plupart des configurations init, y compris systemd (encore mieux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Shepherd</a> ) </li><li>  cron (encore mieux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mcron</a> ) </li><li>  conky (pas entièrement programmable, bien que cela devrait être la caractéristique la plus attendue d'un programme similaire) </li><li>  TeX, LaTeX (et tous les dérivés), Asymptote (encore mieux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scribble</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">skribilo</a> - toujours en développement; depuis janvier 2019, TeX / LaTeX est toujours utilisé comme étape intermédiaire dans la préparation du PDF) </li><li>  La plupart des programmes avec des configurations qui n'utilisent pas de langage de programmation à usage général. </li></ul><br>  Réinventer la roue n'est généralement pas une bonne idée.  Quand il s'agit d'outils aussi importants que les langages de programmation, cela a des conséquences très dramatiques.  Des efforts supplémentaires inutiles sont nécessaires, des erreurs se produisent.  La communauté se disperse.  Des communautés plus consolidées sont plus efficaces et utilisent mieux leur temps si elles améliorent les langages de programmation existants et bien développés. <br><br><h1>  Pas seulement pour le bureau </h1><br>  Guix prend en charge plusieurs architectures (i686, x86_64, ARMv7 et AArch64 à partir de janvier 2019) et prévoit de prendre en charge davantage de cœurs en dehors de l'écosystème Linux (disons * BSD, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Hurd</a> ou peut-être votre propre système!). <br><br>  Cela fait de Guix un excellent outil pour déployer des serveurs (reproductibles) et d'autres systèmes spécialisés.  Je pense que dans les systèmes embarqués, Guix peut très bien rivaliser avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenWRT</a> (bien qu'il faudra un certain travail pour porter sur des systèmes embarqués). <br><br><h1>  USB live auto-reproductible </h1><br>  Ci-dessus, j'ai mentionné <code>guix system disk-image</code> : par exemple, il vous permet de recréer le système actuel sur une clé USB. <br><br>  Ainsi, un clone du système actuel est facile à connecter n'importe où et à reproduire l'environnement actuel exact (moins le matériel).  Vous pouvez y inclure des données utilisateur: clés PGP, e-mail.  Tout est disponible immédiatement après le téléchargement. <br><br>  De toute évidence, le clonage fonctionne plus loin de la machine sur laquelle le clone est installé: au lieu du Guix «nu», un système d'exploitation à part entière est déployé, prêt à fonctionner. <br><br><a name="1"></a><h1>  Remplacement d'autres gestionnaires de packages </h1><br><h3>  Emacs, Python, Ruby ... et la puissance de l' <code>guix environment</code> </h3><br>  Guix peut remplacer n'importe quel gestionnaire de packages, y compris les gestionnaires de packages de langages de programmation.  Il présente plusieurs avantages: <br><br><ul><li>  Reproductibilité omniprésente. <br></li><li>  Rollbacks omniprésents. <br></li><li>  Pas besoin d'apprendre un autre gestionnaire de paquets. </li></ul><br>  À ce stade, vous devez mentionner l' <code>guix environment</code> .  Cette commande configure un environnement temporaire avec uniquement un ensemble spécifique de packages, comme <code>virtualenv</code> .  La particularité est qu'il est universel pour toutes les langues et leurs combinaisons. <br><br><h3>  Texlive </h3><br>  (Avertissement: à partir de janvier 2019, le système de build TeXlive pour Guix est en cours de refonte). <br><br>  TeXlive a reçu une mention spéciale car c'est particulièrement terrible :), ce qui confirme une fois de plus le rôle salvateur de Guix! <br><br>  La plupart des systèmes d'exploitation basés sur Unix distribuent généralement TeXlive dans le cadre d'une suite de packages.  Par exemple, Arch Linux en possède une douzaine.  Si vous avez besoin de packages TeX de différents ensembles, Arch Linux ne laisse d'autre choix que d'installer des milliers de packages (éventuellement inutiles), et TeXlive prend <i>beaucoup de</i> place: des centaines de mégaoctets. <br><br>  Alternativement, vous pouvez installer TeXlive manuellement, mais <code>tlmgr</code> : <code>tlmgr</code> est juste un mauvais gestionnaire de paquets, et il nécessite un travail supplémentaire fastidieux. <br><br>  À l'aide de Guix, les packages TeXlive sont installés séparément, comme tout le reste, ce qui vous aide à maintenir votre propre ensemble de packages TeXlive ou même à créer des spécifications d'environnement virtuel pour la compilation de documents spécifiques. <br><br><h1>  Le noyau </h1><br>  De nombreux systèmes d'exploitation n'offrent qu'une prise en charge limitée des noyaux personnalisés.  Si les utilisateurs souhaitent s'éloigner du noyau par défaut, le noyau non standard doit être géré manuellement. <br><br>  Gentoo est connu pour «exiger» le noyau de l'utilisateur comme étape d'installation recommandée (obligatoire?).  Cependant, ce n'est guère une condition préalable, et les utilisateurs eux-mêmes doivent prendre en charge la configuration du noyau. <br><br>  Dans Guix, le noyau est un package régulier entièrement personnalisable, comme tout autre.  Vous pouvez tout configurer et passer le fichier de configuration du noyau à la définition du package. <br><br>  Par exemple, voici les définitions d'un noyau Linux non libre avec le pilote <code>iwlwifi</code> (avertissement: je déconseille fortement d'utiliser des pilotes propriétaires, car ils constituent une menace sérieuse pour votre vie privée et votre liberté): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-module</span></span> (<span class="hljs-name"><span class="hljs-name">ambrevar</span></span> linux-custom) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> gexp) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> packages) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> git-download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> build-system trivial) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> ((<span class="hljs-name"><span class="hljs-name">guix</span></span> licenses) #<span class="hljs-symbol"><span class="hljs-symbol">:prefix</span></span> license:) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">gnu</span></span> packages linux) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">srfi</span></span> srfi-1)) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-nonfree (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> linux-libre) (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-nonfree"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">package-version</span></span> linux-libre)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> url-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://www.kernel.org/pub/linux/kernel/v4.x/"</span></span> <span class="hljs-string"><span class="hljs-string">"linux-"</span></span> version <span class="hljs-string"><span class="hljs-string">".tar.xz"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"1lm2s9yhzyqra1f16jrjwd66m3jl43n5k7av2r9hns8hdr1smmw4"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">native-inputs</span></span> `((<span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> ,(local-file <span class="hljs-string"><span class="hljs-string">"./linux-custom.conf"</span></span>)) ,@(alist-delete <span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> (package-native-inputs linux-libre)))))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>) <span class="hljs-string"><span class="hljs-string">"9d40a17beaf271e6ad47a5e714a296100eef4692"</span></span>) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version) (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> git-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">git-reference</span></span> (<span class="hljs-name"><span class="hljs-name">url</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/pub/scm/linux/kernel"</span></span> <span class="hljs-string"><span class="hljs-string">"/git/firmware/linux-firmware.git"</span></span>)) (<span class="hljs-name"><span class="hljs-name">commit</span></span> version))) (<span class="hljs-name"><span class="hljs-name">file-name</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-"</span></span> version <span class="hljs-string"><span class="hljs-string">"-checkout"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"099kll2n1zvps5qawnbm6c75khgn81j8ns0widiw0lnwm8s9q6ch"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-firmware-iwlwifi (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version)) (<span class="hljs-name"><span class="hljs-name">build-system</span></span> trivial-build-system) (<span class="hljs-name"><span class="hljs-name">arguments</span></span> `(#<span class="hljs-symbol"><span class="hljs-symbol">:modules</span></span> ((guix build utils)) #<span class="hljs-symbol"><span class="hljs-symbol">:builder</span></span> (begin (use-modules (guix build utils)) (let ((source (assoc-ref %build-inputs <span class="hljs-string"><span class="hljs-string">"source"</span></span>)) (fw-dir (string-append %output <span class="hljs-string"><span class="hljs-string">"/lib/firmware/"</span></span>))) (mkdir-p fw-dir) (for-each (lambda (file) (copy-file file (string-append fw-dir (basename file)))) (find-files source <span class="hljs-string"><span class="hljs-string">"iwlwifi-.*\\.ucode$|LICENSE\\.iwlwifi_firmware$"</span></span>)) #t)))) (<span class="hljs-name"><span class="hljs-name">home-page</span></span> <span class="hljs-string"><span class="hljs-string">"https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">synopsis</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free firmware for Intel wifi chips"</span></span>) (<span class="hljs-name"><span class="hljs-name">description</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free iwlwifi firmware"</span></span>) (<span class="hljs-name"><span class="hljs-name">license</span></span> (<span class="hljs-name"><span class="hljs-name">license</span></span><span class="hljs-symbol"><span class="hljs-symbol">:non-copyleft</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/LICENCE.iwlwifi_firmware?id=HEAD"</span></span>))))</code> </pre> <br>  Le noyau et le firmware personnalisés peuvent être conditionnellement inclus dans la configuration actuelle du système (certains fichiers <code>config.scm</code> ): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> *lspci* (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">port</span></span> (<span class="hljs-name"><span class="hljs-name">open-pipe*</span></span> OPEN_READ <span class="hljs-string"><span class="hljs-string">"lspci"</span></span>)) (<span class="hljs-name"><span class="hljs-name">str</span></span> (<span class="hljs-name"><span class="hljs-name">get-string-all</span></span> port))) (<span class="hljs-name"><span class="hljs-name">close-pipe</span></span> port) str)) (<span class="hljs-name"><span class="hljs-name">operating-system</span></span> (<span class="hljs-name"><span class="hljs-name">host-name</span></span> <span class="hljs-string"><span class="hljs-string">"..."</span></span>) <span class="hljs-comment"><span class="hljs-comment">;;... (kernel (cond ((string-match "Network controller: Intel Corporation Wireless 8888" *lspci*) linux-nonfree) (#t linux-libre))) (firmware (append (list linux-firmware-iwlwifi) %base-firmware))</span></span></code> </pre> <br>  Suivez ensuite ces étapes pour installer une nouvelle configuration système: <br><br><pre> <code class="bash hljs">sudo -E guix system reconfigure config.scm</code> </pre> <br>  Sans même installer un nouveau noyau, vous pouvez créer directement une image prête à démarrer à partir d'une clé USB. <br><br><h1>  Les jeux </h1><br>  Étant donné que les packages Guix utilisent des technologies avancées (par exemple, les dernières versions de Mesa) et permettent un réglage complet du noyau, c'est une plate-forme idéale pour les jeux et, en particulier, pour <i>empaqueter les</i> jeux! <br><br>  Malheureusement, l'industrie du jeu est loin d'être une philosophie du logiciel libre, et très peu de jeux sont emballés dans le cadre du projet officiel Guix. <br><br>  Bien que Guix soit synonyme de logiciel libre et n'accepte aucune propriété dans son référentiel, ironiquement, de nombreuses fonctionnalités avancées font de Guix un gestionnaire de packages idéal pour les programmes non libres. <br><br>  Quelques avantages: <br><br><ul><li>  <code>guix environment</code> vous permet d'exécuter n'importe quelle application dans un conteneur isolé qui restreint l'accès au réseau, masque le système de fichiers (il n'y a aucun risque que le programme propriétaire vole certains de vos fichiers, disons, portefeuille Bitcoin ou clés PGP) et même des informations au niveau du système telles comme nom d'utilisateur.  Cela est nécessaire pour exécuter tout programme source fermé non fiable. <br></li><li>  Gestion des packages fonctionnels: les programmes à source fermée ne résistent généralement pas à l'épreuve du temps et ne fonctionnent pas lorsqu'une dépendance de bibliothèque change son API.  Étant donné que Guix définit des packages au-dessus de n'importe quelle version de n'importe quelle dépendance (sans conflit avec le système actuel), Guix vous permet de créer des packages pour des jeux avec du code source fermé qui fonctionneront pour toujours. <br></li><li>  Environnement reproductible: les programmes à source fermée sont généralement mal portés et peuvent se comporter différemment sur des systèmes avec des dépendances légèrement différentes.  La propriété de reproductibilité de Guix implique que si nous faisons fonctionner le package Guix une fois, il fonctionnera toujours (sauf pour une panne matérielle ou un changement de configuration matérielle). </li></ul><br>  Pour ces raisons, Guix est un outil idéal pour emballer et distribuer des jeux en source fermée. <br><br>  Cependant, il s'agit d'un grand sujet distinct, qu'il vaut mieux laisser pour un autre article. <br><br><h1>  Trucs et astuces </h1><br><h3>  Emacs-guix </h3><br>  L'un des avantages incroyables de Guix est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface Emacs-Guix</a> , qui vous permet d'installer et de supprimer des packages, de mettre à jour de manière sélective, de rechercher, de passer à la définition de package, de gérer les générations, d'imprimer les «différences» entre eux, et bien plus encore. <br><br>  Il a des modes de développement pour l'assemblage et la programmation, ainsi qu'un environnement interactif spécial appelé Scheme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">REPL</a> .  Il s'agit d'une interface utilisateur unique pour le système d'exploitation. <br><br>  Il y a aussi l'interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helm System Packages</a> , qui chevauche partiellement Emacs-Guix, mais il me semble plus agréable pour des recherches de paquets rapides et des opérations rapides. <br><br><h3>  Stockage de données </h3><br>  Étant donné que Guix stocke plusieurs générations de configurations système (y compris l'historique complet des packages), il nécessite plus d'espace disque que les autres systèmes d'exploitation. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'après mon expérience, en 2018, la partition de 25 Go a dû être nettoyée environ une fois par mois (compte tenu du fait que j'ai de grandes demandes concernant le nombre de packages), et la partition de 50 Go peut être laissée sans surveillance pendant une année entière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est pratique d'utiliser la commande pour nettoyer le stockage </font></font><code>guix gc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais elle peut supprimer «trop de packages», c'est-à-dire les packages qui seront nécessaires immédiatement lors de la prochaine mise à jour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emacs-Guix a une commande </font></font><code>mx guix-store-dead-item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui trie les paquets morts par taille et vous permet de les supprimer individuellement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous devez analyser les dépendances, regardez </font></font><code>guix gc --references</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>guix gc --requisites</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci peut être combiné avec la sortie </font></font><code>guix build ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour voir les différents éléments du graphe de dépendances.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, pour afficher le code de l'un des scripts de génération, ouvrez le fichier renvoyé par la commande suivante: </font></font><br><br><pre> <code class="bash hljs">$ guix gc --references $(guix build -d coreutils) | grep builder /gnu/store/v02xky6f5rvjywd7ficzi5pyibbmk6cq-coreutils-8.29-guile-builder</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Génération de manifeste </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est souvent utile de générer un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manifeste de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tous les packages installés dans un profil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela peut être fait en utilisant le script Guile suivant:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use-modules</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> profiles) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> match) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> pretty-print)) (<span class="hljs-name"><span class="hljs-name">match</span></span> (<span class="hljs-name"><span class="hljs-name">command-line</span></span>) ((<span class="hljs-name"><span class="hljs-name">_</span></span> where) (<span class="hljs-name"><span class="hljs-name">pretty-print</span></span> `(specifications-&gt;manifest ',(map manifest-entry-name (manifest-entries (profile-manifest where)))))) (<span class="hljs-name"><span class="hljs-name">_</span></span> (<span class="hljs-name"><span class="hljs-name">error</span></span> <span class="hljs-string"><span class="hljs-string">"Please provide the path to a Guix profile."</span></span>)))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, exécutez-le sur votre profil </font></font><code>~/.guix-profile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs">$ guile -s manifest-to-manifest.scm ~/.guix-profile</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichiers dot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suivent l'historique des packages installés. </font><font style="vertical-align: inherit;">Comme je garde également la version de Guix, je peux revenir à l'état exact de mon système à tout moment dans le passé.</font></font><br><br><h1>  Les références </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques interfaces web: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste des paquets Guix</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suivi des messages d'erreur</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souhaits</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Documents: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de "mise en scène" GNU Guix (</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pourquoi Lisp a joué un rôle important dans le développement)</font></font><br></li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notes de Pierre</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paquets non officiels: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canal de paquet de chrome</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forfaits d'Oleg Pykhalov</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436938/">https://habr.com/ru/post/fr436938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436924/index.html">Quelques mots sur l'organisation des concours de robotique</a></li>
<li><a href="../fr436926/index.html">Héros de l'authentification à deux facteurs, ou comment "marcher dans la peau des autres"</a></li>
<li><a href="../fr436928/index.html">WebRTC - encore plus facile (EasyRTC)</a></li>
<li><a href="../fr436934/index.html">Naïve Math: le moteur de Mendocino et le théorème d'Earnshaw</a></li>
<li><a href="../fr436936/index.html">Dépôt nucléaire japonais à Primorye ou site de stockage des sous-marins nucléaires de la flotte du Pacifique</a></li>
<li><a href="../fr436940/index.html">Héros de l'authentification à deux facteurs, deuxième partie</a></li>
<li><a href="../fr436942/index.html">10 tendances de test de logiciels à surveiller en 2019</a></li>
<li><a href="../fr436944/index.html">La prochaine étape de la sécurité aéroportuaire</a></li>
<li><a href="../fr436946/index.html">Reconnaissance aux rayons X: précision = 0,84, rappel = 0,96. Avons-nous besoin de plus de médecins?</a></li>
<li><a href="../fr436948/index.html">L'avenir des infrastructures des centres de données</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>