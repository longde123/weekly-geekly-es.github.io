<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ’¼ ğŸ¤‘ ğŸ’ƒğŸ¿ Pembelajaran Mesin: Memprediksi Harga Saham di Pasar Saham â›¹ğŸ¾ ğŸ‘©â€ğŸ« ğŸ–¥ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penerjemah Polina Kabirova khusus untuk Netologia mengadaptasi sebuah artikel oleh Insinyur Universitas Cambridge Vivek Palaniappan tentang cara membu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembelajaran Mesin: Memprediksi Harga Saham di Pasar Saham</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netologyru/blog/428227/">  <i>Penerjemah Polina Kabirova khusus untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Netologia</a> mengadaptasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> oleh Insinyur Universitas Cambridge Vivek Palaniappan tentang cara membuat model menggunakan jaringan saraf yang dapat memprediksi harga saham di bursa saham.</i> <br><br>  Mesin dan pembelajaran mendalam telah menjadi strategi baru yang efektif yang digunakan banyak dana investasi untuk meningkatkan pendapatan.  Dalam artikel itu, saya akan menjelaskan bagaimana jaringan saraf membantu memprediksi situasi di pasar saham - misalnya, harga saham (atau indeks).  Teks ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> saya yang ditulis dengan Python.  Kode lengkap dan panduan program dapat ditemukan di GitHub.  Baca artikel terkait lainnya di Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedang</a> . <br><a name="habracut"></a><br><h2>  Jaringan saraf dalam bidang ekonomi </h2><br>  Perubahan dalam bidang keuangan tidak linier, dan kadang-kadang mungkin terlihat bahwa harga saham dibentuk sepenuhnya secara acak.  Metode deret waktu tradisional, seperti model ARIMA dan GARCH, efektif ketika rangkaian stasioner - sifat dasarnya tidak berubah seiring waktu.  Dan ini mengharuskan seri telah diproses sebelumnya menggunakan <code>log returns</code> atau dibawa ke stasioneritas berbeda.  Namun, masalah utama muncul ketika model ini diimplementasikan dalam sistem perdagangan nyata, karena stasioneritas tidak dijamin saat menambahkan data baru. <br><br>  Solusi untuk masalah ini dapat berupa jaringan saraf yang tidak memerlukan stasioneritas.  Jaringan saraf pada awalnya sangat efektif dalam menemukan hubungan antara data dan mampu memprediksi (atau mengklasifikasikan) data baru berdasarkan mereka. <br><br>  Biasanya, proyek ilmu data terdiri dari operasi berikut: <br><br><ol><li>  Pengumpulan data - menyediakan sekumpulan properti yang diperlukan. </li><li>  Preprocessing data seringkali merupakan langkah yang menakutkan tetapi perlu sebelum menggunakan data. </li><li>  Pengembangan dan implementasi model adalah pilihan jenis jaringan saraf dan parameternya. </li><li>  Model backtesting (pengujian pada data historis) adalah langkah kunci dalam strategi perdagangan apa pun. </li><li>  Optimasi - mencari parameter yang sesuai. </li></ol><br>  Input untuk jaringan saraf kami - data tentang harga saham selama 10 hari terakhir.  Dengan bantuan mereka, kami akan memperkirakan harga pada hari berikutnya. <br><br><h2>  Pengumpulan data </h2><br>  Untungnya, data yang dibutuhkan untuk proyek ini dapat ditemukan di Yahoo Finance.  Data dapat dikumpulkan menggunakan API Python <code>pdr.get_yahoo_data(ticker, start_date, end_date)</code> atau langsung dari situs. <br><br><h2>  Pra-pemrosesan data </h2><br>  Dalam kasus kami, data perlu dibagi ke dalam set pelatihan yang terdiri dari 10 harga sebelumnya dan harga hari berikutnya.  Untuk melakukan ini, saya mendefinisikan kelas <code>Preprocessing</code> , yang akan bekerja dengan data pelatihan dan tes.  Di dalam kelas, saya mendefinisikan metode <code>get_train(self, seq_len)</code> , yang mengubah data input dan output pelatihan menjadi array <code>NumPy</code> , menetapkan panjang jendela tertentu (dalam kasus kami 10).  Seluruh kode terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, seq_len)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  Generates training data  :param seq_len: length of window  :return: X_train and Y_train  """</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(self.stock_train)//seq_len)*seq_len - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(self.stock_train.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>])      y = np.array([self.stock_train.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]], np.float64)      self.input_train.append(x)      self.output_train.append(y)  self.X_train = np.array(self.input_train)  self.Y_train = np.array(self.output_train)</code> </pre> <br>  Demikian pula, saya telah mendefinisikan metode yang mengkonversi data uji <code>X_test</code> dan <code>Y_test</code> . <br><br><h2>  Model Jaringan Saraf Tiruan </h2><br>  Untuk proyek ini, saya menggunakan dua model jaringan saraf: Multilayer Perceptron (MLP) dan Long Short Term Model (LSTM).  Saya akan berbicara singkat tentang cara kerja model ini.  Baca lebih lanjut tentang MLP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel lain</a> , dan tentang karya LSTM di Jacob Aungiers. <br><br>  MLP adalah bentuk paling sederhana dari jaringan saraf.  Input data masuk ke dalam model dan menggunakan bobot tertentu, nilai-nilai ditransmisikan melalui lapisan tersembunyi untuk mendapatkan data output.  Mempelajari algoritma berasal dari propagasi balik melalui lapisan tersembunyi untuk mengubah nilai bobot masing-masing neuron.  Masalah dengan model ini adalah kurangnya "memori."  Tidak mungkin untuk menentukan apa data sebelumnya dan bagaimana hal itu dapat dan harus mempengaruhi yang baru.  Dalam konteks model kami, perbedaan 10 hari antara data dari dua set data mungkin penting, tetapi MLP tidak dapat menganalisis hubungan tersebut. <br><br>  Untuk melakukan ini, gunakan LSTM atau Jaringan Syaraf Berulang (RNN).  RNN menyimpan informasi data tertentu untuk digunakan nanti, ini membantu jaringan saraf menganalisis struktur kompleks hubungan antara data harga saham.  Tetapi dengan RNN, masalah gradien pudar muncul.  Gradien berkurang karena jumlah lapisan meningkat dan tingkat pelatihan (nilai kurang dari satu) dikalikan beberapa kali.  Selesaikan masalah LSTM ini dengan meningkatkan efisiensi. <br><br><h2>  Implementasi model </h2><br>  Untuk mengimplementasikan model, saya menggunakan <code>Keras</code> , karena ada lapisan yang ditambahkan secara bertahap, dan tidak mendefinisikan seluruh jaringan sekaligus.  Jadi kita dapat dengan cepat mengubah jumlah dan jenis lapisan, mengoptimalkan jaringan saraf. <br><br>  Langkah penting dalam bekerja dengan harga saham adalah normalisasi data.  Biasanya untuk ini Anda mengurangi kesalahan rata-rata dan membaginya dengan kesalahan standar.  Tetapi kita membutuhkan sistem ini untuk digunakan dalam perdagangan nyata untuk periode waktu tertentu.  Jadi, menggunakan statistik mungkin bukan cara paling akurat untuk menormalkan data.  Jadi saya hanya membagi semua data menjadi 200 (angka sewenang-wenang dibandingkan dengan semua angka lainnya kecil).  Dan walaupun tampaknya normalisasi seperti itu tidak dibenarkan dan tidak masuk akal, efektif untuk memastikan bahwa bobot dalam jaringan saraf tidak menjadi terlalu besar. <br><br>  Mari kita mulai dengan model yang lebih sederhana - MLP.  Keras membangun urutan dan menambahkan lapisan padat di atasnya.  Kode lengkapnya terlihat seperti ini: <br><br><pre> <code class="python hljs">model = tf.keras.models.Sequential() model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>)</code> </pre> <br>  Menggunakan Keras dalam lima baris kode, kami menciptakan MLP dengan lapisan tersembunyi, masing-masing seratus neuron.  Dan sekarang sedikit tentang pengoptimal.  Metode Adam (estimasi momen adaptif) mendapatkan popularitas - algoritma optimasi yang lebih efisien dibandingkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penurunan gradien stokastik</a> .  Ada dua ekstensi lain dari penurunan gradien stokastik - Keuntungan Adam segera terlihat dengan latar belakang mereka: <br><br>  <b>AdaGrad</b> - mempertahankan kecepatan belajar yang ditetapkan, yang meningkatkan hasil ketika gradien berbeda (misalnya, dengan masalah dengan bahasa alami dan visi komputer). <br><br>  <b>RMSProp</b> - mempertahankan kecepatan pelatihan yang ditetapkan, yang dapat bervariasi tergantung pada nilai rata-rata gradien terbaru untuk berat (misalnya, seberapa cepat itu berubah).  Ini berarti bahwa algoritme mengatasi dengan baik dengan masalah non-stasioner (misalnya, kebisingan). <br><br>  Adam menggabungkan manfaat ekstensi ini, jadi saya memilihnya. <br><br>  Sekarang kami menyesuaikan model dengan data pelatihan kami.  Keras menyederhanakan tugas lagi, hanya kode berikut yang diperlukan: <br><br><pre> <code class="python hljs">model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Saat model siap, Anda perlu memeriksanya pada data uji untuk menentukan seberapa baik kerjanya.  Ini dilakukan seperti ini: <br><br><pre> <code class="python hljs">model.evaluate(X_test, Y_test)</code> </pre> <br>  Informasi yang diperoleh dari verifikasi dapat digunakan untuk menilai kemampuan model untuk memprediksi harga saham. <br><br>  Prosedur serupa digunakan untuk model LSTM, jadi saya akan menunjukkan kode dan sedikit menjelaskannya: <br><br><pre> <code class="python hljs">model = tf.keras.Sequential() model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), return_sequences=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)) model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>) model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">50</span></span>) model.evaluate(X_test, Y_test)</code> </pre> <br>  Harap perhatikan bahwa Keras membutuhkan data dengan ukuran tertentu, tergantung pada model Anda.  Sangat penting untuk mengubah bentuk array menggunakan NumPy. <br><br><h2>  Model Backtesting </h2><br>  Ketika kami menyiapkan model kami menggunakan data pelatihan dan mengujinya pada data uji, kami dapat menguji model pada data historis.  Ini dilakukan sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strategy, seq_len, ticker, start_date, end_date, dim)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  A simple back test for a given date period  :param strategy: the chosen strategy. Note to have already formed the model, and fitted with training data.  :param seq_len: length of the days used for prediction  :param ticker: company ticker  :param start_date: starting date  :type start_date: "YYYY-mm-dd"  :param end_date: ending date  :type end_date: "YYYY-mm-dd"  :param dim: dimension required for strategy: 3dim for LSTM and 2dim for MLP  :type dim: tuple  :return: Percentage errors array that gives the errors for every test in the given date range  """</span></span>  data = pdr.get_data_yahoo(ticker, start_date, end_date)  stock_data = data[<span class="hljs-string"><span class="hljs-string">"Adj Close"</span></span>]  errors = []  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(stock_data)//<span class="hljs-number"><span class="hljs-number">10</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span> - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(stock_data.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>]).reshape(dim) / <span class="hljs-number"><span class="hljs-number">200</span></span>      y = np.array(stock_data.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">200</span></span>      predict = strategy.predict(x)      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> predict == <span class="hljs-number"><span class="hljs-number">0</span></span>:          predict = strategy.predict(x)      error = (predict - y) / <span class="hljs-number"><span class="hljs-number">100</span></span>      errors.append(error)      total_error = np.array(errors)  print(<span class="hljs-string"><span class="hljs-string">f"Average error = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{total_error.mean()}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br>  Namun, ini adalah versi pengujian yang disederhanakan.  Untuk sistem backtesting lengkap, faktor-faktor seperti "bias survivorship", bias (lihat bias depan), perubahan kondisi pasar dan biaya transaksi harus dipertimbangkan.  Karena ini hanya proyek pendidikan, uji coba sederhana sudah cukup. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/_9/hy/qw_9hyxncpkhgxv_rvsxxtxrhlk.png"></div><br>  <i>Perkiraan model LSTM saya untuk harga saham Apple pada bulan Februari</i> <br><br>  Untuk model LSTM sederhana tanpa optimasi, ini adalah hasil yang sangat bagus.  Ini menunjukkan bahwa jaringan saraf dan model pembelajaran mesin mampu membangun koneksi yang kompleks dan stabil antar parameter. <br><br><h2>  Optimalisasi Hyperparameter </h2><br>  Optimasi sering diperlukan untuk meningkatkan hasil model setelah pengujian.  Saya tidak memasukkannya dalam versi open source sehingga pembaca dapat mencoba untuk mengoptimalkan model itu sendiri.  Mereka yang tidak tahu cara mengoptimalkan harus menemukan hyperparameter yang akan meningkatkan kinerja model.  Ada beberapa metode untuk menemukan hiperparameter: dari memilih parameter pada grid hingga metode stokastik. <br><br>  Saya yakin bahwa dengan optimalisasi model, pengetahuan di bidang pembelajaran mesin naik ke tingkat yang baru.  Cobalah untuk mengoptimalkan model sehingga itu berfungsi lebih baik daripada milikku.  Bandingkan hasilnya dengan grafik di atas. <br><br><h2>  Kesimpulan </h2><br>  Pembelajaran mesin terus berkembang - metode baru muncul setiap hari, jadi sangat penting untuk terus belajar.  Cara terbaik untuk melakukan ini adalah membuat proyek yang menarik, misalnya, membangun model untuk memperkirakan harga saham.  Dan meskipun model LSTM saya tidak cukup baik untuk digunakan dalam perdagangan nyata, dasar yang diletakkan dalam pengembangan model seperti itu dapat membantu di masa depan. <br><br><h2>  Dari para editor </h2><br>  Mata kuliah Netologi dengan topik: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Analis</a> Profesi Online </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Ilmuwan</a> profesi online </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428227/">https://habr.com/ru/post/id428227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428217/index.html">Juta panggilan video per hari atau "Hubungi ibu!"</a></li>
<li><a href="../id428219/index.html">Dari mana praktik relokasi massal personel yang memenuhi syarat berasal?</a></li>
<li><a href="../id428221/index.html">Generasi AI dari wajah realistis</a></li>
<li><a href="../id428223/index.html">Kota dan Big Data mereka</a></li>
<li><a href="../id428225/index.html">Cara melakukan analisis web untuk SaaS melalui Google Analytics: memperkenalkan dan melacak corong</a></li>
<li><a href="../id428229/index.html">Bagaimana Lisp menjadi bahasa pemrograman untuk Tuhan</a></li>
<li><a href="../id428231/index.html">Cantik dan bersih: alat yang membantu Anda mencapai kode yang hampir sempurna</a></li>
<li><a href="../id428233/index.html">Lima alasan untuk mencintai pihak TI regional</a></li>
<li><a href="../id428235/index.html">Mengapa mereka memanggil saya dari NSA di tengah malam dan meminta sumbernya</a></li>
<li><a href="../id428237/index.html">Scrum-mitap dengan board game: undang ke Scrum Values â€‹â€‹Game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>