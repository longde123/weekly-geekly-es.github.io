<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 🧚🏾 👨🏿‍⚕️ Bytecode for JVM的Hello World 🧗🏾 🐂 📱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们编译一个显示“ Hello World”的简单程序，并逐步浏览其结构 


 对于那些不完全了解字节码的形式以及JVM如何使用字节码的人（例如，至少是最简单的指令（关于其存在的知识）），我认为这篇文章不会为您提供足够的信息。 


实际上，这并不困难。 使用JDK中的javap工具并考虑反汇编的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bytecode for JVM的Hello World</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480550/"><p> 我们编译一个显示“ Hello World”的简单程序，并逐步浏览其结构 </p><br><p> 对于那些不完全了解字节码的形式以及JVM如何使用字节码的人（例如，至少是最简单的指令（关于其存在的知识）），我认为这篇文章不会为您提供足够的信息。 </p><br><p>实际上，这并不困难。 使用JDK中的<code>javap</code>工具并考虑反汇编的代码就足够了。 </p><br><p> 我们将开始分析JVM字节码的结构 </p><a name="habracut"></a><br><p> 对此非常有用的书是官方的JVM规范-oracle上的Java虚拟机规范 </p><br><p> 首先，创建一个简单的程序： </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ... args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>); } }</code> </pre><br><p> 与<code>javac Main.java</code>团队进行编译，然后进行反汇编 </p><br><pre> <code class="plaintext hljs"> javap -c -v Main</code> </pre> <br><p>  <em>主类</em> </p><br><pre> <code class="plaintext hljs">Classfile /C:/Users/Arthur/playground/java/jvm/Main.class Last modified 26.10.2019; size 413 bytes MD5 checksum 6449121a3bb611fee394e4f322401ee1 Compiled from "Main.java" public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V { public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World 5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8 } SourceFile: "Main.java"</code> </pre><br><p> 这只是一个字节码表示形式，比原始字节码更容易让人看到，但看起来却有所不同： </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d 0a00 0600 0f09 0010 0011 0800 120a 0013 0014 0700 1507 0016 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0a53 6f75 7263 6546 696c 6501 0009 4d61 696e 2e6a 6176 610c 0007 0008 0700 170c 0018 0019 0100 0b48 656c 6c6f 2057 6f72 6c64 0700 1a0c 001b 001c 0100 044d 6169 6e01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 1d00 0100 0100 0000 052a b700 01b1 0000 0001 000a 0000 0006 0001 0000 0001 0089 000b 000c 0001 0009 0000 0025 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0100 0a00 0000 0a00 0200 0000 0400 0800 0500 0100 0d00 0000 0200 0e</code> </pre> <br><p>  （您可以通过Sublime Text打开<code>.class</code>文件，该Sublime Text指示File-&gt; Encoding with Encoding-&gt; Hexademical） </p><br><p> 我们将使用此代码。 </p><br><p> 但是首先，我们需要对其进行格式化，以免混淆其所在位置，而字节码实际上具有非常严格的结构： </p><br><pre> <code class="plaintext hljs"> ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p> 您可以在JVM规范<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.1章ClassFile结构中</a>找到它 </p><br><p> 这里的一切都很简单-尺寸单位在左侧，说明在右侧。 </p><br><p> 我们将以十六进制分析字节码，其中每个数字占用4位，因此，对于两个字节-4位和对于四个字节-8位。 </p><br><p>  <strong>魔术</strong> </p><br><p>  magic是一个标识我们类格式的值。 它等于<code>0xCAFEBABE</code> ，它具有自己<a href="https://en.wikipedia.org/wiki/Java_class_file">的创建历史</a> 。 </p><br><p>  <strong>minor_version，major_version</strong> </p><br><p> 这些是您的<code>class</code>文件的版本。 如果我们调用<code>major_version</code> M和<code>minor_version</code> m，我们得到的<code>class</code>文件的版本为<code>Mm</code> </p><br><p> 现在，我将立即从程序“ Hello World”中给出示例，以了解其用法： </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 -- minor_version 0034 -- major_version</code> </pre> <br><p> 我们可以在反汇编的代码中看到它，但是在十进制数系统中已经可以看到它： </p><br><pre> <code class="plaintext hljs"> ... public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ...</code> </pre> <br><p>  <strong>constant_pool_count</strong> </p><br><p> 此处显示了常量池中的变量数。 同时，如果您决定以纯字节码编写代码，那么您肯定需要监视其值，因为如果您指定了错误的值，则整个程序将陷入困境（选中！）。 </p><br><p> 另外，不要忘记您应该在<code>___ + 1</code>写入<code>___ + 1</code> of_variables_ <code>___ + 1</code> </p><br><p> 总计，我们得到： </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 0034 -- version 001d -- constant_pool_count</code> </pre> <br><p>  <strong>constant_pool []</strong> </p><br><p> 常量池中的每种类型的变量都有其自己的结构： </p><br><pre> <code class="plaintext hljs"> cp_info { u1 tag; u1 info[]; }</code> </pre> <br><p> 一切都需要按顺序进行。 首先，我们读取<code>tag</code>以找出变量的类型，然后根据该变量的类型，查看其后续值具有<code>info[]</code> </p><br><p> 可在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">表4.3常量池标签</a>规范中找到带有标签的<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">表</a> 。 </p><br><p> 实际上，这是平板电脑： </p><br><div class="scrollable-table"><table><thead><tr><th> 恒定型 </th><th> 价值 </th></tr></thead><tbody><tr><td> <code>CONSTANT_Class</code> </td> <td>  7 </td></tr><tr><td> <code>CONSTANT_Fieldref</code> </td> <td>  9 </td></tr><tr><td> <code>CONSTANT_Methodref</code> </td> <td>  10 </td></tr><tr><td> <code>CONSTANT_InterfaceMethodref</code> </td> <td>  11 </td></tr><tr><td> <code>CONSTANT_String</code> </td> <td>  8 </td></tr><tr><td> <code>CONSTANT_Integer</code> </td> <td>  3 </td></tr><tr><td> <code>CONSTANT_Float</code> </td> <td>  4 </td></tr><tr><td> <code>CONSTANT_Long</code> </td> <td>  5 </td></tr><tr><td> <code>CONSTANT_Double</code> </td> <td>  6 </td></tr><tr><td> <code>CONSTANT_NameAndType</code> </td> <td>  12 </td></tr><tr><td> <code>CONSTANT_Utf8</code> </td> <td>  1个 </td></tr><tr><td> <code>CONSTANT_MethodHandle</code> </td> <td>  15 </td></tr><tr><td> <code>CONSTANT_MethodType</code> </td> <td>  16 </td></tr><tr><td> <code>CONSTANT_InvokeDynamic</code> </td> <td>  18岁 </td></tr></tbody></table></div><br><p> 如前所述，每种类型的常数都有其自己的结构。 </p><br><p> 例如，这里是<code>CONSTANT_Class</code>结构： </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p> 字段和方法结构： </p><br><pre> <code class="plaintext hljs"> CONSTANT_Fieldref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p> 在此重要的是要注意，不同的结构可能具有不同的长度。 </p><br><p> 考虑我们的代码的一部分： </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a00 0600 0f09 0010 0011 0800 12 ...</code> </pre> <br><p> 因此，我们看一下常量的结构，发现第一个字节是为常量类型保留的。 在这里我们看到<code>0a</code> （10）-因此，它是<code>CONSTANT_Methodref</code> </p><br><p> 我们看一下它的结构： </p><br><pre> <code class="plaintext hljs"> CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p> 在标记使用一个字节之后，我们需要<code>name_and_type_index</code> 4个字节用于<code>class_index</code>和<code>name_and_type_index</code> </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 0900 1000 1108 0012 ...</code> </pre> <br><p> 好吧，我们找到了常量池的值之一。 来吧 我们看一下<code>09</code>表示<code>CONSTANT_Fieldref</code>类型 </p><br><p> 我们得到： </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 ...</code> </pre> <br><p> 您可能会认为大多数类型具有相同的形状，但事实并非如此。 <br> 例如，以下类型的结构看起来像<code>CONSTANT_String</code> ： </p><br><pre> <code class="plaintext hljs"> CONSTANT_String_info { u1 tag; u2 string_index; }</code> </pre> <br><p> 所有这些结构都可以在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.4章“常量池”中找到。</a> </p><br><p> 现在，让我们看看<code>info</code>本身内部的类型是什么意思。 </p><br><p> 属于<code>*_index</code>模式的方法通常包含常量池表中的地址。 例如， <code>class_index</code>表示<code>CONSTANT_Class_info</code>类型的值， <code>string_index</code>表示<code>CONSTANT_Class_info</code>类型的<code>string_index</code> </p><br><p> 我们可以在反汇编代码中看到这一点： </p><br><pre> <code class="plaintext hljs"> #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18</code> </pre> <br><pre> <code class="plaintext hljs"> 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 -- CONSTANT_String</code> </pre> <br><p> 您还可以突出显示数字和字符串的表示形式。 </p><br><p> 您可以从第<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.4.4</a>章开始阅读有关数字的表示形式，但是由于Hello World程序中尚未包含数字，因此现在我们仅分析行 </p><br><p> 实际上，这是该行的显示方式： </p><br><pre> <code class="plaintext hljs"> CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; }</code> </pre> <br><p> 例如，我们的Hello World： </p><br><pre> <code class="plaintext hljs"> 01 -- tag 000b -- length 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- bytes[length] // H ello W orld</code> </pre> <br><p> 解析整个字节码常量池，我们得到： </p><br><div class="spoiler">  <b class="spoiler_title">整个常量池</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> -- [Constant Pool] -- methodref 0a 0006 000f -- fieldref 09 0010 0011 -- string 08 0012 -- methodref 0a 0013 0014 -- Class 07 0015 -- Class 07 0016 -- Utf8 01 0006 3c 69 6e 69 74 3e -- Utf8 01 0003 28 29 56 -- Utf8 01 0004 43 6f 64 65 -- Utf8 01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 -- Utf8 01 0004 6d 61 69 6e -- Utf8 01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- Utf8 01 000a 53 6f 75 72 63 65 46 69 6c 65 -- Utf8 01 0009 4d 61 69 6e 2e 6a 61 76 61 -- NameAndType 0c 0007 0008 -- Class 07 0017 -- NameAndType 0c 0018 0019 -- Utf8 01 000b 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- Class 07 001a -- NameAndType 0c 001b 001c -- Utf8 01 0004 4d 61 69 6e -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d -- Utf8 01 0003 6f 75 74 -- Utf8 01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b -- Utf8 01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d -- Utf8 01 0007 70 72 69 6e 74 6c 6e -- Utf8 01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- [Constant Pool END]</code> </pre> </div></div><br><p> 另外，我们可以将其与反汇编代码进行比较： </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V</code> </pre> <br><p> 从而检查所有内容是否匹配，因为实际上<code>javap</code>只是处理该字节码，并以格式化的形式显示给我们。 </p><br><p> 需要常量池来进行指示。 例如： </p><br><pre> <code class="plaintext hljs"> public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 //    1    4: return</code> </pre> <br><p> 有关常量池中所有类型的更多信息，请参见<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.4章“常量池”。</a> </p><br><p> 在<em>ClassFile</em>结构中更进一步 </p><br><p>  <strong>access_flags</strong> </p><br><p> 这是修饰符属性的位掩码。 </p><br><div class="scrollable-table"><table><thead><tr><th> 标志名称 </th><th> 价值 </th><th> 口译 </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td> 宣布为<code>public</code> ; 可以从其程序包外部进行访问。 </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td> 宣布<code>final</code> ; 不允许子类。 </td></tr><tr><td> <code>ACC_SUPER</code> </td> <td>  0x0020 </td><td> 当由<em>invokespecial</em>指令调用时，特别对待超类方法。 </td></tr><tr><td> <code>ACC_INTERFACE</code> </td> <td>  0x0200 </td><td> 是一个接口，而不是一个类。 </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td> 申报<code>abstract</code> ; 不能实例化。 </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td> 宣布为合成； 在源代码中不存在。 </td></tr><tr><td> <code>ACC_ANNOTATION</code> </td> <td>  0x2000 </td><td> 声明为注释类型。 </td></tr><tr><td> <code>ACC_ENUM</code> </td> <td>  0x4000 </td><td> 声明为<code>enum</code>类型。 </td></tr></tbody></table></div><br><p>  <strong>this_class</strong> </p><br><p> 必须包含<code>this</code>的地址。 在我们的例子中，它位于地址5： </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object ...</code> </pre> <br><p> 应当注意，此变量的结构必须符合<code>CONSTANT_Class_info</code> </p><br><p>  <strong>超类</strong> </p><br><p> 类祖先地址。 在我们的情况下，该值位于地址<code>#6</code> 。 好吧，还需要<code>CONSTANT_Class_info</code>值结构 </p><br><p> 这些类的名称在<code>CONSTANT_Utf8_info</code>常量的结构中定义。 如果看一下单元格<code>#21</code>和<code>#22</code> ，我们将看到： </p><br><pre> <code class="plaintext hljs"> ... #21 = Utf8 Main #22 = Utf8 java/lang/Object ...</code> </pre> <br><p> 也就是说，在这些单元格中，该结构的<code>name_index</code>表示为： </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  <strong>interfaces_count，fields_count</strong> </p><br><p> 它们不在我们的程序中，因此它们的值将等于0000，并且就不会再有<code>fields[]</code> ， <code>interfaces[]</code>后续值。 </p><br><p> 阅读更多<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.1 ClassFile结构</a> </p><br><p>  <strong>Methods_count</strong> </p><br><p> 方法数量。 尽管在代码中我们在类中看到了一个方法，但实际上有两个方法。 除了<code>main</code>方法之外，还有一个默认构造函数。 因此，在我们的案例中，它们的数量是两个。 </p><br><p>  <strong>方法[]</strong> </p><br><p> 每个元素必须符合<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.6章方法中</a>描述的<code>method_info</code>结构。 </p><br><pre> <code class="plaintext hljs"> method_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p> 在我们的字节码（格式化的，带有注释）中，它看起来像这样： </p><br><pre> <code class="plaintext hljs"> -- [methods] -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 0001 -- max_stack 0001 -- max_locals 0000 0005 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 000a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01 -- public static void main(java.lang.String...); 0089 --access_flags 000b -- name_index 000c -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 0025 -- attribute_length 0002 -- max_stack 0001 -- max_locals 0000 0009 -- code_length b2 00 02 12 03 b6 00 04 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count 000a -- attribute_name_index 0000 000a -- attribute_length 00 02 00 00 00 04 00 08 00 05 -- [methods END]</code> </pre> <br><p> 让我们更详细地分析方法的结构： </p><br><p>  <strong>access_flags</strong> </p><br><p> 修饰符蒙版。  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">表4.5方法访问和属性标志</a> </p><br><div class="scrollable-table"><table><thead><tr><th> 标志名称 </th><th> 价值 </th><th> 口译 </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td> 宣布为<code>public</code> ; 可以从其程序包外部进行访问。 </td></tr><tr><td> <code>ACC_PRIVATE</code> </td> <td>  0x0002 </td><td> 宣布为<code>private</code> ; 仅在定义类中可访问。 </td></tr><tr><td> <code>ACC_PROTECTED</code> </td> <td>  0x0004 </td><td> 宣布<code>protected</code> ; 可以在子类中访问。 </td></tr><tr><td> <code>ACC_STATIC</code> </td> <td>  0x0008 </td><td> 声明为<code>static</code> 。 </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td> 宣布<code>final</code> ; 不能被覆盖（第<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">5.4.5节</a> ）。 </td></tr><tr><td> <code>ACC_SYNCHRONIZED</code> </td> <td>  0x0020 </td><td> 宣布<code>synchronized</code> ; 调用由监视器使用来包装。 </td></tr><tr><td> <code>ACC_BRIDGE</code> </td> <td>  0x0040 </td><td> 编译器生成的桥接方法。 </td></tr><tr><td> <code>ACC_VARARGS</code> </td> <td>  0x0080 </td><td> 用可变数量的参数声明。 </td></tr><tr><td> <code>ACC_NATIVE</code> </td> <td>  0x0100 </td><td> 宣布为<code>native</code> ; 用Java以外的语言实现。 </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td> 申报<code>abstract</code> ; 没有提供实现。 </td></tr><tr><td> <code>ACC_STRICT</code> </td> <td>  0x0800 </td><td> 声明<code>strictfp</code> ; 浮点模式受FP限制。 </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td> 宣布为合成； 在源代码中不存在。 </td></tr></tbody></table></div><br><p> 从字节码中可以看到，在<code>public Main();</code>方法中<code>public Main();</code>  （构造函数）为掩码<code>0001</code> ，表示<code>ACC_PUBLIC</code> 。 </p><br><p> 现在，让我们尝试自己组装<code>main</code>方法。 这是他所拥有的： </p><br><ul><li> 公开-ACC_PUBLIC-0x0001 </li><li> 静态-ACC_STATIC-0x0008 </li><li> 字符串... args-ACC_VARARGS-0x0080 </li></ul><br><p> 我们收集掩码：0x0001 + 0x0008 + 0x0080 = <code>0x0089</code> 。 这样我们获得了<code>access_flag</code> </p><br><blockquote> 顺便说一下，ACC_VARARGS在这里是可选的，因为如果我们 <br> 使用String [] args代替String ... args，则此标志将不会 </blockquote><p>  <strong>name_index</strong> </p><br><p> 常量池中的方法名称地址（ <code>CONSTANT_Utf8_info</code> ）。 此处需要注意的重要一点是，构造函数名称不是Main，而是位于单元＃7中的<code>&lt;init&gt;</code> 。 </p><br><p> 在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">第2.9章特殊方法中</a>了解有关<code>&lt;init&gt;</code>和<code>&lt;clinit&gt;</code>更多信息。 </p><br><p>  <strong>描述符索引</strong> </p><br><p> 粗略地说，这是指向方法句柄的地址。 该描述符包含返回值的类型及其签名的类型。 </p><br><p> 此外，JVM使用解释的缩写： </p><br><div class="scrollable-table"><table><thead><tr><th>  <em>BaseType</em>字符 </th><th> 型式 </th><th> 口译 </th></tr></thead><tbody><tr><td> <code>B</code> </td> <td> <code>byte</code> </td> <td> 有符号字节 </td></tr><tr><td> <code>C</code> </td> <td> <code>char</code> </td> <td> 基本多语言平面中的Unicode字符代码点，使用UTF-16编码 </td></tr><tr><td> <code>D</code> </td> <td> <code>double</code> </td> <td> 双精度浮点值 </td></tr><tr><td> <code>F</code> </td> <td> <code>float</code> </td> <td> 单精度浮点值 </td></tr><tr><td> <code>I</code> </td> <td> <code>int</code> </td> <td> 整数 </td></tr><tr><td> <code>J</code> </td> <td> <code>long</code> </td> <td> 长整数 </td></tr><tr><td>  <code>L</code> <em>ClassName</em> <code>;</code> </td><td> <code>reference</code> </td> <td> 类<em>ClassName的</em>一个实例 </td></tr><tr><td> <code>S</code> </td> <td> <code>short</code> </td> <td> 签名短 </td></tr><tr><td> <code>Z</code> </td> <td> <code>boolean</code> </td> <td>  <code>true</code>还是<code>false</code> </td></tr><tr><td> <code>[</code> </td> <td> <code>reference</code> </td> <td> 一维数组 </td></tr></tbody></table></div><br><p> 通常，它看起来像这样： </p><br><pre> <code class="plaintext hljs"> ( ParameterDescriptor* ) ReturnDescriptor</code> </pre> <br><p> 例如，以下方法： </p><br><pre> <code class="plaintext hljs"> Object method(int i, double d, Thread t) {..}</code> </pre> <br><p> 可以表示为 </p><br><pre> <code class="plaintext hljs"> (IDLjava/lang/Thread;)Ljava/lang/Object</code> </pre> <br><p> 实际上， <code>I</code>是<code>int</code> ， <code>D</code>是<code>double</code> ，并且是<code>Ljava/lang/Thread;</code>  class来自标准<code>java.lang</code>库的<code>Thread</code> 。 </p><br><p> 接下来，还有一些属性也具有自己的结构。 </p><br><p> 但首先，与往常一样，其<code>attributes_count</code>计数 </p><br><p> 然后，属性本身具有<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.7章“属性”中</a>描述的结构。 </p><br><pre> <code class="plaintext hljs"> attribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; }</code> </pre> <br><p>  <strong>attribute_name_index</strong> </p><br><p> 指定属性名称。 在我们的例子中，这两种方法都有一个<code>Code</code> 。 属性是一个单独的大主题，您甚至可以在其中按规范创建自己的属性。 但就目前而言，我们应该知道<code>attribute_name_index</code>仅指向具有<code>CONSTANT_Utf8_info</code>结构的常量池中的地址。 </p><br><p>  <strong>attribute_length</strong> </p><br><p> 包含属性的长度，不包括<code>attribute_name_index</code>和<code>attribute_length</code> </p><br><p>  <strong>资讯</strong> </p><br><p> 接下来，我们将使用<code>Code</code>结构，因为在<code>attribute_name_index</code>的值中，我们指向了<code>Code</code>常量池中的值。 </p><br><p> 阅读更多： <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.7.3章，代码属性</a> </p><br><p> 这是它的结构： </p><br><pre> <code class="plaintext hljs"> Code_attribute { u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  <strong>max_stack</strong> </p><br><p> 在我看来，由于前缀max，此属性的名称可能会引起误解。 实际上，这是完成操作所需的最小堆栈大小。 好吧，这个名称具有逻辑意义，也就是说在操作期间将达到的最大堆栈大小。 </p><br><p> 简而言之，JVM将为操作数堆栈分配空间。 您可以在此处指定一个大于必要值的值，但是在此属性中定义的值小于必要值将导致错误。 </p><br><p> 关于堆栈主题，您可以阅读“ <a href="https%253A%252F%252Fwww.tune-it.ru%252Fweb%252Fbleizard%252Fblog%253Fp_p_id%253Dcom_liferay_blogs_web_portlet_BlogsPortlet%2526p_p_lifecycle%253D0%2526p_p_state%253Dnormal%2526p_p_mode%253Dview%2526_com_liferay_blogs_web_portlet_BlogsPortlet_cur%253D2%2526_com_liferay_blogs_web_portlet_BlogsPortlet_delta%253D10%2526p_r_p_resetCur%253Dfalse">在Java世界的上下文中的堆栈和堆上</a> ”或“ <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM内部</a> ” </p><br><p>  <strong>max_locals</strong> </p><br><p> 局部变量的最大大小 </p><br><p> 您可以<a href="https://jrebel.com/rebellabs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">在JVM核心的Mastering Java Bytecode中</a>或在同一<a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals中</a>熟悉局部变量。 </p><br><p>  <strong>code_length</strong> </p><br><p> 该方法内部将执行的代码的大小 </p><br><p>  <strong>代码[]</strong> </p><br><p> 每个代码都指向一些指令。  <code>optcode</code>和命令与助记符的相关性表可以在Wikipedia- <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java字节码指令列表中</a>找到，也可以在本书结尾处的规范中找到。 </p><br><p> 例如，使用我们的构造函数： </p><br><pre> <code class="plaintext hljs"> -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 00 01 -- max_stack 00 01 -- max_locals 00 00 00 05 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 00 0a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01</code> </pre> <br><p> 在这里我们可以找到我们的代码： </p><br><pre> <code class="plaintext hljs"> 2a b7 00 01 b1</code> </pre> <br><p> 我们在表中查找命令并进行比较： </p><br><pre> <code class="plaintext hljs"> 2a - aload_0 b7 0001 - invokespecial #1 b1 - return</code> </pre> <br><p> 这些命令的描述也可以在这里找到： <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.10.1.9章。</a>  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">类型检查说明</a> </p><br><p>  <strong>exception_table_length</strong> </p><br><p> 指定exception_table中的元素数。 我们没有异常钩子，因此我们不会解析它。 但是您还可以阅读<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">第4.7.3章“代码属性”</a> </p><br><p>  <strong>exception_table []</strong> </p><br><p> 它具有以下结构： </p><br><pre> <code class="plaintext hljs"> { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; }</code> </pre> <br><p> 为了简化，您需要指定<code>handler_pc</code>将要处理的代码的开始，结束（ <code>start_pc</code> ， <code>end_pc</code> ）和<code>catch_type</code>异常<code>catch_type</code> </p><br><p>  <strong>attribute_count</strong> </p><br><p>  <code>Code</code>的属性数 </p><br><p>  <strong>属性[]</strong> </p><br><p> 分析器或调试器经常使用属性。 </p><br><hr><br><h3 id="sredstva-dlya-raboty-s-bayt-kodom"> 字节码工具 </h3><br><p> 这不是与本文相关的主题，但仍与之间接相关。 </p><br><p> 有很多使用字节码的工具。 在这里，我想回顾一下Apache Commons的<a href="https://commons.apache.org/proper/commons-bcel/">字节码工程库</a> （BCEL）。 </p><br><p> 首先，使用它我们可以获得一些字节码属性： </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes());</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">完整代码清单</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import org.apache.bcel.classfile.*; import org.apache.commons.codec.binary.Hex; import java.io.*; public class ClassParserExample { public static void main(String... args) throws IOException, ClassNotFoundException { // read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes()); System.out.println( "minor: " + MINOR_VER ); // 0 System.out.println( "major: " + MAJOR_VER ); // 34 System.out.println( "constant pool: " + CONSTANT_POOL); // not correctly System.out.println( "access flags: " + ACCESS_FLAGS ); // 21 System.out.println( "this class: " + THIS_CLASS ); System.out.println( "super class: " + SUPER_CLASS ); // Object System.out.println( "interfaces: " + INTERFACES ); // &lt;empty&gt; System.out.println( "fields: " + FIELDS ); // &lt;empty&gt; System.out.println( "methods: " + METHODS ); // one method: psvm hello world System.out.println( "attributes: " + ATTRIBUTES ); // 536f7572636546696c65 - I think it's instructions for Java tools } private static String getHex(byte[] bytes){ return Hex.encodeHexString(bytes); } private static String getHex(int intNum){ return Integer.toHexString(intNum); } private static String getHex(Constant[] constants){ if (constants == null) return null; StringBuilder sb = new StringBuilder(); for (Constant c : constants){ if (c == null) continue; sb.append(getHex(c.getTag())).append(" "); } return sb.toString(); } private static String getHex(JavaClass[] clazzes){ if (clazzes == null) return null; StringBuilder sb = new StringBuilder(); for (JavaClass c : clazzes){ sb.append(getHex(c.getClassName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Field[] fields){ if (fields == null) return null; StringBuilder sb = new StringBuilder(); for (Field c : fields){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Method[] methods){ if (methods == null) return null; StringBuilder sb = new StringBuilder(); for (Method c : methods){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Attribute[] attributes){ if (attributes == null) return null; StringBuilder sb = new StringBuilder(); for (Attribute c : attributes){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } } /* Class A: public class ClassA { public static void main(String[] args) { System.out.println("Hello world"); } } */ /* Class A bytecode: cafe babe 0000 0034 0022 0a00 0600 1409 0015 0016 0800 170a 0018 0019 0700 1a07 001b 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 124c 6f63 616c 5661 7269 6162 6c65 5461 626c 6501 0004 7468 6973 0100 1d4c 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 413b 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0461 7267 7301 0013 5b4c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b01 000a 536f 7572 6365 4669 6c65 0100 0b43 6c61 7373 412e 6a61 7661 0c00 0700 0807 001c 0c00 1d00 1e01 000b 4865 6c6c 6f20 776f 726c 6407 001f 0c00 2000 2101 001b 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 4101 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 2f00 0100 0100 0000 052a b700 01b1 0000 0002 000a 0000 0006 0001 0000 0006 000b 0000 000c 0001 0000 0005 000c 000d 0000 0009 000e 000f 0001 0009 0000 0037 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0200 0a00 0000 0a00 0200 0000 0800 0800 0900 0b00 0000 0c00 0100 0000 0900 1000 1100 0000 0100 1200 0000 0200 13 */ /* Assembled code: Classfile /C:/java/BCEL/src/main/resources/compiled/ClassA.class Last modified 08.12.2019; size 563 bytes MD5 checksum bcd0198f6764a1dc2f3967fef701452e Compiled from "ClassA.java" public class com.apploidxxx.parse.ClassA minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#20 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // Hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // com/apploidxxx/parse/ClassA #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/apploidxxx/parse/ClassA; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 ClassA.java #20 = NameAndType #7:#8 // "&lt;init&gt;":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 Hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 com/apploidxxx/parse/ClassA #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V { public com.apploidxxx.parse.ClassA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/apploidxxx/parse/ClassA; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 8: 0 line 9: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; } SourceFile: "ClassA.java */</code> </pre> </div></div><br><p>     ,    (,  Jasmin) -. </p><br><p>      <a href="https://github.com/AppLoidx/JVM-research"> </a>   <a href="https://github.com/apache/commons-bcel/tree/master/src/examples"> </a> </p><br><p> ,     <strong>Jasmin</strong> .   ,   ,     ,         JVM  -. </p><br><p>         : </p><br><div class="spoiler"> <b class="spoiler_title">Hello World</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.bytecode 52.0 .source Main.j .class public Main .super java/lang/Object .method public static main([Ljava/lang/String;)V .limit stack 2 .limit locals 2 getstatic java/lang/System/out Ljava/io/PrintStream; ldc "Hello world!" invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V return .end method</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">; ClassCreating.j .bytecode 52.0 .source ClassCreating.java .class public ClassCreating .super java/lang/Object .method public &lt;init&gt;()V .limit stack 1 .limit locals 1 .line 1 0: aload_0 1: invokespecial java/lang/Object/&lt;init&gt;()V 4: return .end method .method public static main([Ljava/lang/String;)V ; Flag ACC_VARARGS set, see JVM spec .limit stack 2 .limit locals 3 .line 3 0: new java/lang/String 3: dup 4: invokespecial java/lang/String/&lt;init&gt;()V 7: astore_1 .line 4 8: new ClassCreating 11: dup 12: invokespecial ClassCreating/&lt;init&gt;()V 15: astore_2 .line 5 16: aload_2 17: invokevirtual ClassCreating/sayHello()V .line 6 20: return .end method .method public sayHello()V .limit stack 2 .limit locals 1 .line 9 0: getstatic java/lang/System/out Ljava/io/PrintStream; 3: ldc "Hello, User!" 5: invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V .line 10 8: return .end method</code> </pre> </div></div><br><hr><br><p>       Hello World </p><br><p>  -       : <a href="https://gist.github.com/AppLoidx/7173d7277dd73025ae06377a7cc75ed0">gist.github</a> </p><br><p>          . </p><br><p>  <strong>二手文献</strong> </p><br><ul><li> The Java Virtual Machine Specification — <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">docs.oracle</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480550/">https://habr.com/ru/post/zh-CN480550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480530/index.html">物联网不是儿童玩具。 黑客对物联网的攻击不仅使大公司而且使普通家庭感到恐惧</a></li>
<li><a href="../zh-CN480532/index.html">从不同角度看EDA</a></li>
<li><a href="../zh-CN480538/index.html">什么对游戏更好：Intel Optane或SSD？</a></li>
<li><a href="../zh-CN480542/index.html">成人安全意识：如何关闭网络钓鱼漏洞</a></li>
<li><a href="../zh-CN480544/index.html">Java中的5个隐藏秘密</a></li>
<li><a href="../zh-CN480552/index.html">Firefox为网络的未来而战</a></li>
<li><a href="../zh-CN480556/index.html">NGINX：俄罗斯IT社区的验证</a></li>
<li><a href="../zh-CN480558/index.html">挖矿的收支平衡水平如何让您确定比特币的关键点</a></li>
<li><a href="../zh-CN480564/index.html">没有框架的Java中的REST API</a></li>
<li><a href="../zh-CN480566/index.html">我在2019年找到的IT工作知识</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>