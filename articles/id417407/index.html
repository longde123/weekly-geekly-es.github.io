<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚷 🤰 🍟 Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 1 👩🏾‍🏭 ✈️ 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Walt Disney Animation Studios (WDAS) baru-baru ini membuat hadiah yang tak ternilai bagi komunitas riset rendering dengan merilis adegan pulau penuh d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417407/">  Walt Disney Animation Studios (WDAS) baru-baru ini membuat hadiah yang tak ternilai bagi komunitas riset rendering dengan merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adegan pulau penuh dari kartun <em>Moana</em></a> .  Geometri dan tekstur untuk satu bingkai menempati lebih dari 70 GB ruang disk.  Ini adalah contoh hebat tingkat kerumitan yang harus dihadapi sistem rendering hari ini;  tidak pernah sebelumnya para peneliti dan pengembang yang terlibat dalam rendering di luar studio film dapat bekerja dengan adegan yang realistis. <br><br>  Beginilah hasil dari menampilkan adegan dengan pbrt modern seperti: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/729/ae6/97a/729ae697af18f30723b71a7168807a3f.jpg"></div><br>  <i>Sebuah pulau dari Moana dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pbrt-v3</a> pada resolusi 2048x858 dengan 256 sampel per piksel.</i>  <i>Total waktu render pada instance 12-core / 24-thread dari Google Compute Engine dengan frekuensi 2 GHz dengan versi terbaru dari pbrt-v3 adalah 1 jam 44 menit 45 detik.</i> <br><br>  Di pihak Disney, itu adalah pekerjaan yang sangat besar, ia harus mengekstraksi adegan itu dari format internalnya sendiri dan mengubahnya ke format yang biasa;  Terima kasih khusus kepadanya untuk waktu yang dihabiskan untuk pengemasan dan mempersiapkan data ini untuk penggunaan luas.  Saya yakin bahwa pekerjaan mereka akan dihargai dengan baik di masa depan karena peneliti menggunakan adegan ini untuk mempelajari masalah rendering adegan efisien tingkat kompleksitas ini. <br><a name="habracut"></a><br>  Adegan ini telah banyak mengajari saya dan memungkinkan saya untuk meningkatkan penyaji pbrt, tetapi sebelum kita membahas ini, saya akan menceritakan sebuah kisah pendek untuk memahami konteksnya. <br><br><h2>  Hash itu bukan </h2><br>  Bertahun-tahun yang lalu, saat melakukan magang di tim rendering Pixar, saya mendapat pelajaran yang aneh: hal-hal “menarik” hampir selalu muncul ketika input data dilewatkan ke sistem program yang sangat berbeda dari semua yang sebelumnya.  Bahkan dalam sistem perangkat lunak yang ditulis dengan baik dan matang, tipe input baru hampir selalu mengarah pada penemuan cacat yang tidak diketahui dalam implementasi yang ada. <br><br>  Saya pertama kali belajar pelajaran ini selama produksi <em>Toy Story 2</em> .  Suatu hari, seseorang memperhatikan bahwa banyak waktu yang dihabiskan untuk mengurai file deskripsi adegan RIB.  Orang lain dari tim rendering (saya kira itu adalah Craig Kolb) meluncurkan profiler dan mulai mencari tahu. <br><br>  Ternyata sebagian besar waktu parsing ditempati oleh pencarian di tabel hash yang digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">string interning</a> .  Tabel hash agak kecil, mungkin 256 elemen, dan ketika beberapa nilai di hash menjadi satu sel, ia mengatur sebuah rantai.  Setelah implementasi pertama dari tabel hash, banyak waktu berlalu dan sekarang ada puluhan ribu objek di layar, sehingga meja kecil seperti itu dengan cepat diisi dan menjadi tidak efektif. <br><br>  Itu paling disarankan untuk hanya menambah ukuran meja - semua ini terjadi pada puncak alur kerja, jadi tidak ada waktu untuk beberapa jenis solusi elegan, misalnya, memperluas ukuran meja ketika mengisinya.  Kami membuat perubahan dalam satu baris, membangun kembali aplikasi, melakukan tes cepat sebelum melakukan dan ... tidak ada peningkatan kecepatan terjadi.  Mencari tabel hash membutuhkan waktu yang sama.  Luar biasa! <br><br>  Setelah penelitian lebih lanjut, kami menemukan bahwa fungsi tabel hash yang digunakan mirip dengan yang berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  (Maafkan saya, Pixar, jika saya mengungkapkan kode sumber RenderMan rahasia Anda.) <br><br>  Fungsi "hash" diimplementasikan kembali pada 1980-an.  Pada saat itu, programmer mungkin menganggap bahwa biaya komputasi untuk memeriksa efek dari semua karakter dalam string pada nilai hash akan terlalu tinggi dan tidak sepadan.  (Saya pikir jika hanya ada beberapa objek dan 256 elemen dalam tabel hash dalam adegan, maka itu sudah cukup.) <br><br>  Implementasi usang lainnya berkontribusi: dari saat Pixar mulai membuat filmnya, nama-nama objek dalam adegan telah tumbuh cukup banyak, misalnya, "BuzzLightyear / LeftArm / Hand / IndexFinger / Knuckle2".  Namun, beberapa tahap awal pipa menggunakan penyangga dengan panjang tetap untuk menyimpan nama-nama objek dan memperpendek semua nama panjang, hanya mempertahankan ujungnya, dan, jika beruntung, menambahkan elipsis di awal, menjadikannya jelas bahwa sebagian dari nama itu hilang: "... tahun / KiriArm / Hand / IndexFinger / Knuckle2 ". <br><br>  Selanjutnya, semua nama objek yang dilihat oleh renderer memiliki bentuk ini, fungsi hash menjadikannya semua menjadi satu bagian dari memori sebagai ".", Dan tabel hash sebenarnya adalah daftar terkait yang besar.  Hari tua yang indah  Setidaknya, setelah menemukan jawabannya, kami segera memperbaiki kesalahan ini. <br><br><h2>  Inovasi yang menarik </h2><br>  Pelajaran ini diingat saya tahun lalu ketika Heather Pritchet dan Rasmus Tamstorf dari WDAS menghubungi saya dan bertanya apakah saya akan tertarik untuk memeriksa kemungkinan kualitas rendering adegan dari <em>Moana</em> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman</a> <sup>1</sup> .  Secara alami, saya setuju.  Saya senang membantu dan saya bertanya-tanya bagaimana semuanya akan berubah. <br><br>  Optimis yang naif dalam diri saya berharap bahwa tidak akan ada kejutan besar - pada akhirnya, versi pertama pbrt dirilis sekitar 15 tahun yang lalu, dan banyak orang menggunakan dan mempelajari kodenya selama bertahun-tahun.  Anda dapat yakin bahwa tidak akan ada gangguan seperti fungsi hash lama dari RenderMan, bukan? <br><br>  Tentu saja jawabannya tidak.  (Dan itulah sebabnya saya menulis ini dan beberapa posting lainnya.) Meskipun saya sedikit kecewa bahwa pbrt tidak sempurna "di luar kotak", tapi saya pikir pengalaman saya dengan adegan <em>Moana</em> adalah konfirmasi pertama dari nilai penerbitan adegan ini. ;  pbrt telah menjadi sistem yang lebih baik karena saya tahu cara menangani adegan ini. <br><br><h3>  Rendering pertama </h3><br>  Setelah mengakses adegan, saya langsung mengunduhnya (butuh beberapa jam dengan koneksi internet rumah saya) dan membukanya dari tar, menerima 29 GB file pbrt dan 38 GB peta tekstur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ptex</a> <sup>2</sup> .  Saya mencoba membuat adegan di sistem rumah saya (dengan 16 GB RAM dan 4-core CPU).  Setelah kembali ke komputer setelah beberapa waktu, saya melihat bahwa itu dibekukan, semua RAM penuh, dan pbrt masih berusaha untuk menyelesaikan uraian adegan deskripsi.  OS berusaha untuk mengatasi tugas menggunakan memori virtual, tetapi tampaknya sia-sia.  Setelah mengalahkan prosesnya, saya harus menunggu sekitar satu menit sebelum sistem mulai merespons tindakan saya. <br><br>  Upaya berikutnya adalah turunan dari Google Compute Engine, yang memungkinkan Anda untuk menggunakan lebih banyak RAM (120 GB) dan lebih banyak CPU (32 utas pada 16 CPU).  Berita baiknya adalah pbrt berhasil membuat adegan (berkat kerja Heather dan Rasmus untuk mengubahnya menjadi format pbrt).  Sangat menarik untuk melihat bahwa pbrt dapat menghasilkan piksel yang relatif baik untuk konten film berkualitas tinggi, tetapi kecepatannya ternyata tidak begitu luar biasa: 34 menit 58 detik hanya untuk menguraikan deskripsi adegan, dan selama rendering sistem menghabiskan hingga 70 GB RAM. <br><br>  Ya, ada 29 gigabyte file deskripsi format format pbrt pada disk yang perlu di-sparsing, jadi saya tidak berharap tahap pertama akan memakan waktu beberapa detik.  Tapi habiskan setengah jam bahkan sebelum sinar mulai melacak?  Ini sangat menyulitkan pekerjaan dengan adegan itu. <br><br>  Di sisi lain, kecepatan ini memberi tahu kami bahwa sesuatu yang sangat berbau busuk mungkin terjadi dalam kode;  bukan hanya "inversi matriks dapat dilakukan 10% lebih cepat";  lebih tepatnya, sesuatu pada level "oh, kita akan melalui daftar 100 ribu elemen yang terhubung".  Saya optimis dan berharap setelah menemukan jawabannya, saya dapat mempercepat proses secara signifikan. <br><br><h3>  Statistik tidak membantu </h3><br>  Tempat pertama saya mulai mencari petunjuk adalah statistik pbrt dump setelah rendering.  Tahap utama dari eksekusi pbrt telah dikonfigurasi sehingga Anda dapat mengumpulkan perkiraan data profil dengan memperbaiki operasi dengan gangguan berkala selama proses rendering.  Sayangnya, statistik tidak banyak membantu kami: menurut laporan, dari hampir 35 menit sebelum dimulainya rendering, 4 menit 22 detik dihabiskan untuk membangun BVH, tetapi tidak ada rincian yang diberikan mengenai sisa waktu tersebut. <br><br>  Membangun BVH adalah satu-satunya tugas komputasi signifikan yang dilakukan selama adegan parsing;  yang lainnya pada dasarnya adalah deserialisasi dari deskripsi geometri dan material.  Mengetahui berapa banyak waktu yang dihabiskan untuk membuat BVH memberikan pemahaman tentang bagaimana (tidak) efektif sistem adalah: waktu yang tersisa, yaitu sekitar 30 menit, parsing data 29 GB, yaitu, kecepatannya 16,5 MB / s.  Parser JSON yang dioptimalkan dengan baik, yang pada dasarnya melakukan tugas yang sama, beroperasi pada kecepatan 50-200 MB / s.  Jelas, masih ada ruang untuk perbaikan. <br><br>  Untuk lebih memahami waktu yang terbuang, saya meluncurkan pbrt dengan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perf</a> Linux yang belum pernah saya gunakan sebelumnya.  Tapi, sepertinya, dia mengatasi tugas itu.  Saya menginstruksikan dia untuk mencari karakter DWARF untuk mendapatkan nama fungsi ( <code>--call-graph dwarf</code> ), dan agar tidak mendapatkan 100 GB file jejak, saya harus menurunkan laju pengambilan sampel dari 4000 menjadi 100 sampel per detik ( <code>-F 100</code> ).  Tetapi dengan parameter ini semuanya berjalan dengan baik, dan saya terkejut bahwa alat <code>perf report</code> memiliki antarmuka dengan kutukan yang bagus. <br><br>  Inilah yang bisa dia katakan kepada saya setelah memulai dengan pbrt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/d31/643/a9ed31643e22b9c5d0566c7b210f4067.png"></div><br>  <i>Saya tidak bercanda ketika saya berbicara tentang "antarmuka dengan kutukan yang bagus".</i> <br><br>  Kita melihat bahwa lebih dari separuh waktu dihabiskan untuk mekanika parsing: <code>yyparse()</code> adalah <code>yyparse()</code> dihasilkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bison</a> , dan <code>yylex()</code> adalah penganalisa leksikal (lexer) yang dihasilkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flex</a> .  Lebih dari separuh waktu dalam <code>yylex()</code> dihabiskan untuk <code>strtod()</code> , yang mengubah string menjadi nilai ganda.  Kami akan <code>yyparse()</code> serangan pada <code>yyparse()</code> dan <code>yylex()</code> hingga artikel ketiga dalam seri ini, tetapi sekarang kita sudah dapat memahami bahwa mungkin ada baiknya untuk mengurangi jumlah data yang dilemparkan ke renderer. <br><br><h3>  Dari teks ke PLY </h3><br>  Salah satu cara untuk mengurangi waktu penguraian data teks adalah dengan mengonversi data ke format yang diurai lebih efisien.  Sebagian besar 29 GB file deskripsi adegan ini adalah jerat segitiga, dan pbrt sudah memiliki dukungan asli untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format PLY</a> , yang merupakan representasi biner efektif dari jerat poligon.  Juga di pbrt ada flag baris perintah <code>--toply</code> , yang mem-parsing file deskripsi adegan pbrt, mengubah semua jerat segitiga yang ditemukan menjadi file PLY dan membuat file pbrt baru yang merujuk ke file-file PLY ini. <br><br>  Tangkapannya adalah bahwa tekstur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ptex</a> secara aktif digunakan dalam adegan Disney, yang, pada gilirannya, membutuhkan nilai <code>faceIndex</code> untuk dikaitkan dengan setiap segitiga, yang menentukan wajah sub mesh asli yang diambil.  Untuk mentransfer nilai-nilai ini, cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambahkan dukungan untuk bidang baru di file PLY</a> .  Penelitian lebih lanjut mengungkapkan bahwa dalam kasus mengkonversi setiap mesh - bahkan jika hanya memiliki selusin segitiga - menjadi file PLY, puluhan ribu file PLY kecil dibuat dalam folder, dan ini menciptakan masalah kinerjanya sendiri;  Kami berhasil menyingkirkan masalah ini dengan menambahkan pada implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan untuk membiarkan jerat kecil tidak berubah</a> . <br><br>  Saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip baris perintah kecil</a> untuk mengonversi semua file <code>*_geometry.pbrt</code> dalam folder untuk menggunakan PLY untuk jerat besar.  Perhatikan bahwa ia memiliki asumsi hard-coded tentang jalur yang perlu diubah agar skrip bekerja di tempat lain. <br><br><h3>  Peningkatan kecepatan pertama </h3><br>  Setelah mengonversi semua jerat besar ke PLY, ukuran deskripsi adegan pada disk menurun dari 29 menjadi 22 GB: 16,9 GB file adegan pbrt dan 5,1 GB file biner PLY.  Setelah konversi, total waktu tahap pertama sistem menurun menjadi 27 menit 35 detik, dan penghematan sebesar 7 menit 23 detik, yaitu, kami dipercepat dengan 1,3 kali <sup>3</sup> .  Memproses file PLY jauh lebih efisien daripada memproses file teks pbrt: hanya 40 detik waktu startup dihabiskan untuk mengurai file PLY, dan kami melihat bahwa file PLY diproses dengan kecepatan sekitar 130 MB / s, atau sekitar 8 kali lebih cepat daripada format teks pbrt . <br><br>  Itu adalah kemenangan mudah yang bagus, tetapi kami masih harus melakukan banyak hal. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lain kali,</a> kami akan mencari tahu di mana semua memori sebenarnya digunakan, memperbaiki beberapa kesalahan di sini dan mencapai kecepatan lebih dalam proses. <br><br><h2>  Catatan </h2><br><ol><li>  Anda sekarang harus memiliki pemahaman yang lebih baik tentang motivasi untuk menambahkan dukungan ptex di pihak saya dan mengubah Disney BSDF ke pbrt tahun lalu. </li><li>  Semua waktu di sini dan di posting selanjutnya diindikasikan untuk versi WIP (Work In Progress), yang saya pakai sebelum rilis resmi.  Tampaknya versi finalnya sedikit lebih besar.  Kami akan tetap berpegang pada hasil yang saya rekam ketika bekerja dengan adegan asli, meskipun faktanya mereka tidak cukup sesuai dengan hasil dari versi final.  Saya menduga pelajaran dari mereka bisa sama. </li><li>  Perhatikan bahwa peningkatan kecepatan pada dasarnya adalah apa yang Anda harapkan dengan pengurangan sekitar 50 persen dalam volume data parsing.  Jumlah waktu yang kami habiskan menurut profiler mengkonfirmasi ide kami. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417407/">https://habr.com/ru/post/id417407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417395/index.html">Pengujian end-to-end: apa, mengapa, mengapa</a></li>
<li><a href="../id417397/index.html">Bahasa pemrograman apa yang harus dipelajari pada tahun 2018 dan mengapa?</a></li>
<li><a href="../id417399/index.html">Selamat datang: memperkenalkan pengembang baru ke tim</a></li>
<li><a href="../id417401/index.html">Akhirnya, kami memilih multimeter anggaran dengan fungsionalitas yang baik</a></li>
<li><a href="../id417405/index.html">Pengkode Otomatis dan Kecerdasan Buatan yang Kuat</a></li>
<li><a href="../id417409/index.html">Bagaimana cara bertahan rekan satu tim di scram scalable dan mempertahankan kontrol kualitas kode</a></li>
<li><a href="../id417411/index.html">Mengevaluasi pengembang berdasarkan data objektif</a></li>
<li><a href="../id417413/index.html">Apakah masalah pemimpin tim berbeda di St. Petersburg, cari tahu di Saint TeamLead Conf</a></li>
<li><a href="../id417415/index.html">Pelajaran pencetakan 3D. Mencetak komponen dengan ketebalan lapisan berbeda dari 3Dtool</a></li>
<li><a href="../id417419/index.html">[Yekaterinburg, pengumuman] Alice mengunjungi Kontur - hackathon untuk menciptakan keterampilan bagi asisten suara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>