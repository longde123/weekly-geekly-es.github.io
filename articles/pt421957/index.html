<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑ üòö üéûÔ∏è Como o Yandex criou a realidade aumentada no Maps para iOS. Experi√™ncia usando o ARKit üòß üì¥ ü§∞üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Restam menos pessoas que podem se surpreender com a Realidade Aumentada (AR). Para alguns, essa tecnologia est√° associada a um brinquedo por algumas h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o Yandex criou a realidade aumentada no Maps para iOS. Experi√™ncia usando o ARKit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421957/"><p>  Restam menos pessoas que podem se surpreender com a Realidade Aumentada (AR).  Para alguns, essa tecnologia est√° associada a um brinquedo por algumas horas.  Outros acham mais pr√°tico. </p><br><p>  Meu nome √© Dmitry e estou desenvolvendo Yandex.Maps para iOS.  Hoje vou contar aos leitores da Habr como criamos o roteamento usando realidade aumentada.  Voc√™ tamb√©m aprender√° sobre os recursos do uso da estrutura ARKit, gra√ßas aos quais a introdu√ß√£o da realidade aumentada n√£o √© mais a preocupa√ß√£o de apenas especialistas no campo da vis√£o computacional. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  Em 2009, a revista Esquire foi a primeira entre a m√≠dia a adicionar suporte de realidade aumentada ao seu produto.  Na capa da revista postou um c√≥digo com o qual voc√™ podia ver Robert Downey Jr. "ao vivo". </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  O uso de RA na ind√∫stria do entretenimento n√£o se limitou a isso.  Um exemplo v√≠vido foi o jogo Pokemon Go, lan√ßado em 2016.  Em julho daquele ano, ele foi baixado mais de 16 milh√µes de vezes.  O sucesso do jogo levou ao surgimento de numerosos clones com AR. </p><br><p>  Eventos significativos na ind√∫stria de AR nos √∫ltimos anos podem ser considerados os an√∫ncios do Google Glass e Microsoft Hololens.  A apar√™ncia desses dispositivos mostra o vetor no qual as grandes empresas se deslocam. </p><br><p>  A Apple n√£o foi exce√ß√£o.  Em 2017, a empresa introduziu a estrutura ARKit, cuja import√¢ncia para a ind√∫stria dificilmente pode ser superestimada.  E falaremos sobre isso em mais detalhes. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Recursos do ARKit, facilitando o uso do AR: </p><br><ul><li>  falta de tags especiais (marcadores), </li><li>  integra√ß√£o com as estruturas gr√°ficas 2D / 3D da Apple existentes - SceneKit, SpriteKit, Metal, </li><li>  alta precis√£o na determina√ß√£o da posi√ß√£o e orienta√ß√£o do dispositivo no espa√ßo, </li><li>  n√£o √© necess√°rio calibrar a c√¢mera ou os sensores. </li></ul><br><p>  Sob o cap√¥ do ARKit, existe um sistema de odometria inercial visual que combina dados com os subsistemas visual (c√¢mera) e inercial (aceler√¥metro, girosc√≥pio) do dispositivo para determinar a posi√ß√£o e o deslocamento no palco.  O elemento de conex√£o desse sistema √© o filtro Kalman - um algoritmo que, a cada momento, seleciona as melhores leituras dos dois subsistemas e as fornece na forma de nossa posi√ß√£o e orienta√ß√£o no palco.  O ARKit tamb√©m tem um "entendimento" da cena - podemos definir superf√≠cies horizontais e verticais, bem como as condi√ß√µes de ilumina√ß√£o da cena.  Assim, ao adicionar um objeto √† cena, podemos adicionar ilumina√ß√£o padr√£o, gra√ßas √† qual o objeto parecer√° mais realista. </p><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text"><p>  Em breve, a vers√£o 2.0 do framework ser√° lan√ßada, na qual novos recursos ser√£o adicionados e a precis√£o do posicionamento ser√° significativamente aprimorada. </p></div></div><br><p>  O ARKit permitiu que os desenvolvedores incorporassem realidade aumentada de alta qualidade em seus aplicativos, gastando muito menos esfor√ßo.  Vamos demonstrar isso usando o exemplo de Yandex.Maps. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Roteamento com AR no Yandex.Maps </h2><br><p>  Normalmente, ap√≥s o an√∫ncio da nova vers√£o do iOS, muitas equipes da Yandex se re√∫nem para discutir a possibilidade de introduzir novos recursos em seus aplicativos.  A equipe do Yandex.Mart fez o mesmo.  Dentro de um m√™s a partir do momento do an√∫ncio do ARKit, discutimos frequentemente como implement√°-lo no Maps.  Que tipo de id√©ias n√£o ouvimos um do outro!  Rapidamente, chegamos √† conclus√£o de que uma das solu√ß√µes mais √∫teis e de superf√≠cie √© o uso de realidade aumentada no roteamento. </p><br><p>  A escolha dessa id√©ia se deve ao fato de muitos usu√°rios de cart√µes frequentemente encontrarem uma situa√ß√£o em que voc√™ se encontra em uma √°rea desconhecida e precisa decidir rapidamente para onde ir.  A abordagem padr√£o para o usu√°rio m√©dio do mapa √© abrir o aplicativo, criar uma rota para pedestres e, no lugar, determinar para onde se mover.  A id√©ia de introduzir a realidade aumentada no roteamento de pedestres √© salvar o usu√°rio de a√ß√µes desnecess√°rias, mostrando imediatamente onde voc√™ precisa se mover diretamente sobre a imagem da c√¢mera. </p><br><p>  Primeiro, quero dizer algumas palavras sobre roteamento.  O que eu coloco nesse conceito?  Do ponto de vista da implementa√ß√£o em um aplicativo m√≥vel, este √© um conjunto bastante padr√£o de etapas que permitem ao usu√°rio ir do ponto A ao ponto B: </p><br><ul><li>  sele√ß√£o de pontos de partida e chegada, </li><li>  receber uma rota sob a forma de um conjunto de pontos em coordenadas geogr√°ficas (latitude, longitude), </li><li>  exibido no mapa da linha de rota, </li><li>  acompanhar o usu√°rio com informa√ß√µes adicionais enquanto se move ao longo da rota. </li></ul><br><p>  N√£o vamos nos concentrar nos dois primeiros pontos.  S√≥ posso dizer que obtemos a rota por meio da biblioteca de plataforma cruzada Yandex.Mapkit, que tamb√©m est√° dispon√≠vel para voc√™ na forma de um pod.  Como o roteamento de realidade aumentada difere do roteamento padr√£o nos mapas?  Primeiro de tudo, a principal diferen√ßa √© um mapa quase completamente oculto.  A √™nfase principal √© colocada na √°rea da tela com a imagem do fluxo de v√≠deo da c√¢mera, na qual elementos visuais adicionais s√£o sobrepostos (marca de chegada, marca auxiliar e imagem da linha de rota).  Cada um desses elementos visuais possui sua pr√≥pria carga sem√¢ntica e sua pr√≥pria l√≥gica (quando e como deve ser exibida).  Consideraremos o papel de cada um desses elementos em mais detalhes posteriormente, mas por enquanto proponho considerar as tarefas que t√≠nhamos diante de n√≥s: </p><br><ul><li>  aprender a posicionar objetos na cena do ARKit, conhecendo suas coordenadas geogr√°ficas, </li><li>  Aprenda a desenhar a interface do usu√°rio necess√°ria em uma cena 3D com desempenho suficiente. </li></ul><br><p>  Precis√°vamos converter as coordenadas dos pontos de geogr√°ficas para as coordenadas no palco, selecionar os pontos a serem exibidos e exibir toda a interface do usu√°rio necess√°ria na parte superior da imagem da c√¢mera na posi√ß√£o correta.  Mas tudo acabou sendo um pouco mais complicado do que parecia √† primeira vista. </p><br><p>  Antes de come√ßar a implementar os recursos diretamente, um de meus colegas recebeu a tarefa de criar um prot√≥tipo mostrando a possibilidade (ou impossibilidade) de implementar funcionalidades semelhantes com um conjunto acess√≠vel de ferramentas.  Durante duas semanas, assistimos a San Sanych lavrando os espa√ßos abertos e os arredores pr√≥ximos de nosso escrit√≥rio com um telefone na m√£o e olhando o mundo ao nosso redor atrav√©s do prisma da c√¢mera.  Como resultado, obtivemos um prot√≥tipo funcional que mostrava cada ponto do percurso como uma marca no palco, com uma dist√¢ncia a ele.  Com a ajuda desse prot√≥tipo, foi poss√≠vel, sob uma combina√ß√£o bem-sucedida de circunst√¢ncias, ir do trabalho ao metr√¥ e quase nunca se perder.  Mas, falando s√©rio, ele confirmou a possibilidade de implementar a funcionalidade pretendida.  Mas ainda havia v√°rias tarefas que nossa equipe ainda precisava resolver. </p><br><p>  Tudo come√ßou com o estudo de ferramentas.  Naquela √©poca, apenas uma pessoa da equipe tinha experi√™ncia em trabalhar com gr√°ficos 3D.  Vamos dar uma olhada r√°pida nas ferramentas com as quais qualquer um que pensa em implementar essas id√©ias com o ARKit. </p><br><h2 id="instrumenty-i-api">  Ferramentas e APIs </h2><br><p>  A principal tarefa de renderizar objetos √© criar e gerenciar objetos de cena da estrutura do SceneKit.  Com o advento do ARKit, a classe ARSCNView (o descendente da classe SCNView - a classe base para trabalhar com a cena no SceneKit) ficou dispon√≠vel para o desenvolvedor, que resolve a maioria das tarefas demoradas de integra√ß√£o do ARKit e SceneKit, a saber: </p><br><ul><li>  sincroniza√ß√£o da posi√ß√£o do telefone no espa√ßo com a posi√ß√£o da c√¢mera no palco, </li><li>  o sistema de coordenadas da cena coincide com o sistema de coordenadas ARKit, </li><li>  como pano de fundo da cena, o fluxo de v√≠deo da c√¢mera do dispositivo √© usado. </li></ul><br><p>  O objeto ARSCNView tamb√©m fornece ao desenvolvedor um objeto de sess√£o de realidade aumentada que pode ser iniciado com a configura√ß√£o necess√°ria, interrompida ou inscrita em v√°rios eventos usando o objeto delegado. </p><br><p>  Para adicionar objetos √† cena, herdeiros ou objetos diretamente do SCNNode s√£o usados.  Esta classe representa uma posi√ß√£o (vetor tridimensional) no sistema de coordenadas de seu pai.  Assim, obtemos uma √°rvore de objetos em cena com uma raiz em um objeto especial - o rootNode da nossa cena.  Tudo aqui √© muito semelhante √† hierarquia dos objetos UIView no UIKit.  Os objetos SCNNode podem ser exibidos no palco quando adicionam material e ilumina√ß√£o. </p><br><p>  Para adicionar realidade aumentada a um aplicativo m√≥vel, voc√™ tamb√©m precisa conhecer os principais objetos da API do ARKit.  O principal √© o objeto da sess√£o de realidade aumentada - ARSession.  Este objeto realiza o processamento de dados e √© respons√°vel pelo ciclo de vida da sess√£o de realidade aumentada.  O objetivo deste artigo n√£o √© recontar a documenta√ß√£o do ARKit e SceneKit, portanto, n√£o escreverei sobre todos os par√¢metros de configura√ß√£o dispon√≠veis da sess√£o de realidade aumentada, mas focarei em um dos par√¢metros mais importantes da configura√ß√£o da sess√£o de realidade aumentada para aplicativos de navega√ß√£o - worldAlignment.  Este par√¢metro determina a dire√ß√£o dos eixos da cena no momento da inicializa√ß√£o da sess√£o.  Em geral, ao inicializar uma sess√£o de realidade aumentada, o ARKit cria um sistema de coordenadas com um in√≠cio que coincide com a posi√ß√£o atual do telefone no espa√ßo e direciona o eixo desse sistema, dependendo do valor da propriedade woldAlignment.  Em nossa implementa√ß√£o, √© usado o valor gravityAndHeading, o que implica que os eixos ser√£o direcionados da seguinte forma: o eixo Y - na dire√ß√£o oposta √† gravidade, o eixo Z - ao sul e o eixo X - ao leste. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="mundo-alinhamento-gravidade-e-rumo"></p><br><p>  Com uma boa combina√ß√£o de circunst√¢ncias, os eixos X / Z estar√£o de fato alinhados com as dire√ß√µes para o sul / leste, mas, devido a erros nas leituras da b√∫ssola, os eixos podem ser direcionados em um determinado √¢ngulo em rela√ß√£o √† dire√ß√£o descrita na documenta√ß√£o.  Esse √© um dos problemas com os quais tivemos que lidar, mas mais sobre isso mais tarde. </p><br><p>  Agora que examinamos as ferramentas b√°sicas, vamos resumir: mapear uma rota usando o SceneKit est√° adicionando objetos SCNNode √† cena nas posi√ß√µes obtidas pela convers√£o de coordenadas geogr√°ficas em coordenadas de cena.  Antes de falarmos sobre a convers√£o de coordenadas e, geralmente, sobre a coloca√ß√£o de objetos em cena, vamos falar sobre os problemas de renderiza√ß√£o de elementos da interface do usu√°rio, assumindo que sabemos a posi√ß√£o dos objetos no palco. </p><br><h1 id="metka-finisha">  Marca de chegada </h1><br><p>  O principal elemento visual do roteamento de pedestres com realidade aumentada √© a marca de chegada, que exibe o ponto final da rota.  Tamb√©m acima da marca, mostramos ao usu√°rio a dist√¢ncia at√© o ponto final da rota. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="vis√£o geral do marcador de acabamento"></p><br><h2 id="razmer">  Tamanho </h2><br><p>  Quando nos foi mostrado o design dessa tag, prestamos aten√ß√£o aos requisitos para o tamanho dessa tag.  Eles n√£o obedeceram √†s regras da proje√ß√£o em perspectiva.  Explicarei que nos mecanismos tridimensionais usados ‚Äã‚Äãpara criar, por exemplo, jogos de computador, o ‚Äúvisual‚Äù √© modelado usando proje√ß√£o em perspectiva.  De acordo com as regras de proje√ß√£o em perspectiva, objetos distantes s√£o representados em uma escala menor e linhas paralelas geralmente n√£o s√£o paralelas.  Assim, o tamanho da proje√ß√£o do objeto no plano da tela muda linearmente (diminui) √† medida que a c√¢mera se afasta do objeto na cena.  Resulta da descri√ß√£o dos layouts que o tamanho da marca na tela tem um tamanho fixo (m√°ximo) quando removido a menos de 50 m, depois diminui linearmente de 50 ma 2 km, ap√≥s o que o tamanho m√≠nimo permanece inalterado.  Tais requisitos s√£o obviamente devidos √† conveni√™ncia do usu√°rio.  Eles permitem que o usu√°rio nunca perca o ponto final da rota da visualiza√ß√£o, para que ele sempre tenha uma id√©ia de para onde se mover. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="acabamento-marcador-tamanho-demandas"></p><br><p>  T√≠nhamos que entender como poder√≠amos nos inserir no mecanismo de proje√ß√£o SceneKit que funcionava de acordo com certas regras.  Quero notar imediatamente que t√≠nhamos cerca de duas semanas para fazer tudo sobre tudo, portanto simplesmente n√£o havia tempo para realizar uma an√°lise aprofundada de v√°rias abordagens para resolver os problemas colocados.  Agora, analisar nossas decis√µes, avali√°-las √© muito mais simples, e podemos concluir que a maioria das decis√µes tomadas estava correta.  A exig√™ncia de tamanho, de fato, foi o primeiro obst√°culo.  Todos os problemas descritos abaixo podem ser resolvidos usando o SceneKit e o UIKit.  Tentei explicar em detalhes como resolver cada um dos problemas usando as duas abordagens.  Qual abordagem usar depende de voc√™. </p><br><p>  Vamos imaginar que decidimos implementar uma etiqueta de acabamento usando o SceneKit.  Se levarmos em conta que o r√≥tulo de acordo com os layouts deveria parecer um c√≠rculo na tela, torna-se √≥bvio que no SceneKit o objeto do r√≥tulo deve ser uma esfera (j√° que a proje√ß√£o da esfera em qualquer plano √© um c√≠rculo).  Para que a proje√ß√£o tenha um determinado raio na tela especificado nos requisitos dos projetistas, √© necess√°rio conhecer o raio da esfera a qualquer momento.  Assim, ao colocar uma esfera de um determinado raio na cena em um determinado ponto e atualizar constantemente seu raio ao se aproximar ou se afastar, obteremos uma proje√ß√£o na tela do tamanho necess√°rio a qualquer momento.  O algoritmo para determinar o raio da esfera em um ponto arbitr√°rio no tempo √© o seguinte: </p><br><ol><li>  definir a posi√ß√£o do objeto no palco - o centro da esfera, </li><li>  encontre a proje√ß√£o desse ponto no plano da tela (usando a API SceneKit), </li><li>  para determinar o tamanho exigido da marca na tela, encontramos a dist√¢ncia da c√¢mera ao centro da esfera no palco, </li><li>  determinamos o tamanho necess√°rio na tela pela dist√¢ncia do objeto usando as regras descritas no design, </li><li>  sabendo o tamanho da marca na tela (di√¢metro do c√≠rculo), escolhemos qualquer ponto desse c√≠rculo, </li><li>  fa√ßa a proje√ß√£o reversa (UnprojectPoint) do ponto selecionado, </li><li>  encontramos o comprimento do vetor desde o ponto recebido no palco at√© o centro da esfera. </li></ol><br><p>  O valor obtido do comprimento do vetor ser√° o raio desejado da esfera. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="terminar-marcador-tamanho-solu√ß√£o-cena-kit"></p><br><p>  No momento da implementa√ß√£o, n√£o conseguimos encontrar uma maneira de determinar o tamanho do objeto em cena e decidimos desenhar a marca de chegada usando o UIKit.  Nesse caso, o algoritmo repete as etapas de 1 a 5, ap√≥s o qual um c√≠rculo do tamanho desejado √© desenhado na tela com o centro no ponto obtido na etapa 2 usando as ferramentas UIKit.  Um exemplo de implementa√ß√£o de um r√≥tulo usando o UIKit pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Algumas palavras sobre o c√≥digo</b> <div class="spoiler_text"><p>  No final do artigo, forneci v√°rios links para materiais √∫teis e simplesmente interessantes, incluindo exemplos, nos quais √© poss√≠vel ver em detalhes o c√≥digo real que resolve os problemas apresentados no artigo e implementa os algoritmos apresentados.  O principal interesse na minha opini√£o √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prot√≥tipo de roteamento de pedestres</a> , que re√∫ne toda a funcionalidade, com exce√ß√£o do mecanismo de ajuste de eixo, descrito em detalhes abaixo. </p><br><p>  O c√≥digo acima n√£o afirma ser √≥timo, completo e de qualidade de produ√ß√£o =) </p></div></div><br><p>  A diferen√ßa entre o uso do SceneKit e do UIKit nesse caso tamb√©m est√° no fato de que, ao implementar no SceneKit, o objeto SCNNode para o ponto de extremidade da rota (marca de chegada) ser√° criado com material e geometria, pois deve estar vis√≠vel ao usar o UIKit precisamos do objeto n√≥ exclusivamente para procurar a proje√ß√£o no plano da tela (para determinar o centro da marca na tela).  Nesse caso, a geometria e o material n√£o precisam ser adicionados.  Observe que a dist√¢ncia da c√¢mera ao objeto SCNNode do ponto final da rota pode ser encontrada de duas maneiras - usando as coordenadas geogr√°ficas dos pontos ou como o comprimento do vetor entre os pontos na cena.  Isso √© poss√≠vel porque o objeto da c√¢mera √© uma propriedade SCNNode.  Para obter o n√≥ da c√¢mera, voc√™ precisa consultar a propriedade pointOfView da nossa cena. </p><br><p>  Aprendemos como determinar o raio do n√≥ da marca de chegada em um momento arbitr√°rio ao implementar no SceneKit e a posi√ß√£o da exibi√ß√£o da marca de chegada, se implementada no UIKit.  Resta entender quando √© necess√°rio atualizar esses valores?  Este local √© o m√©todo do objeto SCNSceneRendererDelegate: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  Este m√©todo √© chamado ap√≥s cada quadro de cena renderizado.  Ao atualizar os valores da propriedade no corpo desse m√©todo, obtemos um r√≥tulo de acabamento exibido corretamente. </p><br><h2 id="animaciya">  Anima√ß√£o </h2><br><p>  Depois que a marca de chegada apareceu no dev, passamos a adicionar anima√ß√£o ondulada a essa marca.  Eu acho que, para a maioria dos desenvolvedores do iOS, criar anima√ß√µes n√£o √© grande coisa.  Mas, ao pensar sobre o m√©todo de implementa√ß√£o, encontramos o problema de atualizar constantemente o quadro de nossa vis√£o.  Observe que, na maioria dos casos, as anima√ß√µes s√£o adicionadas aos objetos est√°ticos do UIView.  Um problema semelhante - uma atualiza√ß√£o constante do raio da geometria do n√≥ surge quando implementada usando o SceneKit.  O fato √© que a anima√ß√£o pulsante se resume √† anima√ß√£o do tamanho do c√≠rculo (para UIKit) e do raio da esfera (para SceneKit).  Sim, sim, sabemos que no UIKit esse tipo de anima√ß√£o pode ser feito usando o CALayer, mas, para simplificar a narrativa, decidi considerar esse problema simetricamente para as duas estruturas.  Considere uma implementa√ß√£o no UIKit.  Se voc√™ adicionar c√≥digo que anima o mesmo quadro ao c√≥digo existente que atualiza o quadro de exibi√ß√£o, a anima√ß√£o ser√° interrompida definindo explicitamente o quadro.  Portanto, como solu√ß√£o para esse problema, decidimos usar a anima√ß√£o da propriedade transform.scale.xy do objeto UIView.  Ao implementar usando o SceneKit, voc√™ precisar√° adicionar anima√ß√£o da propriedade scale ao objeto SCNNode.  O bom de usar o SceneKit nesse caso √© o fato de que ele suporta totalmente o CoreAnimation, portanto, n√£o √© necess√°rio aprender uma nova API.  O c√≥digo que implementa a anima√ß√£o semelhante √† anima√ß√£o do r√≥tulo no Yandex.Maps √© mais ou menos assim: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Quadro de avisos </h2><br><p>  No in√≠cio do artigo, mencionei um outdoor com uma dist√¢ncia do ponto final da rota, que, em ess√™ncia, √© uma etiqueta com texto sempre localizado acima da marca de chegada.  Por tradi√ß√£o, descreverei os problemas inerentes √†s implementa√ß√µes no UIKit e SceneKit, falando sobre poss√≠veis solu√ß√µes para cada uma das estruturas. </p><br><p>  Vamos come√ßar com o UIKit.  Nesse caso, o outdoor √© um UILabel comum, no qual o texto √© constantemente atualizado, mostrando a dist√¢ncia at√© o ponto final da rota.  Vamos olhar para o problema que estamos enfrentando. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="terminar-marcador-de-problema-local-uikit"></p><br><p>  Se voc√™ definir um r√≥tulo para um quadro e girar o telefone, veremos que o quadro n√£o muda (seria estranho se n√£o estivesse).  Ao mesmo tempo, gostar√≠amos que o r√≥tulo permanecesse paralelo ao plano da Terra. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="terminar-marcador-outdoor-desejado-uikit"></p><br><p>  Acho que todo mundo entende que, ao mudar a orienta√ß√£o do dispositivo, precisamos mudar o r√≥tulo, mas em que √¢ngulo?  Se voc√™ ativar a imagina√ß√£o e imaginar mentalmente todos os eixos dos sistemas de coordenadas e vetores envolvidos nesse processo, podemos concluir que o √¢ngulo de rota√ß√£o √© igual ao √¢ngulo entre o eixo x do sistema de coordenadas UIKit e a proje√ß√£o do eixo X do sistema de coordenadas SceneKit no plano da tela. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="finish-placemark-billboard-solution-uikit"></p><br><p>  Uma tarefa simples que mais uma vez comprovou a utilidade do curso de geometria da escola. </p><br><p>  Ao implementar a marca de chegada usando o SceneKit, voc√™ provavelmente ter√° que renderizar o cartaz √† dist√¢ncia usando as ferramentas do SceneKit, o que significa que voc√™ definitivamente ter√° a tarefa de fazer com que o objeto SCNNode esteja sempre orientado para a c√¢mera.  Acho que o problema ficar√° mais claro se voc√™ olhar para a figura: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="finish-placemark-billboard-problem-scenekit"></p><br><p>  Esse problema foi resolvido usando a API SCNBillboardConstraint.  Adicionando uma constante com um eixo livre Y √† cole√ß√£o de constru√ß√µes de nosso n√≥, obtemos um n√≥ que gira em torno do eixo Y do seu sistema de coordenadas, de modo a estar sempre orientado para a c√¢mera.  A √∫nica tarefa do desenvolvedor √© colocar esse n√≥ na altura correta para que o quadro de avisos com a dist√¢ncia fique sempre vis√≠vel para o usu√°rio. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Etiqueta do assistente </h1><br><p>  Uma das principais caracter√≠sticas do roteamento de pedestres com realidade aumentada, dentro da equipe, consideramos uma marca auxiliar - um elemento visual especial que aparece na tela no momento em que o ponto final da rota sai da zona de visibilidade e mostra ao usu√°rio onde virar o telefone para que a marca apare√ßa na tela linha de chegada. </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="acabamento-marcador-dica-vis√£o geral"></p><br><p>  Tenho certeza que muitos dos leitores encontraram funcionalidades semelhantes em alguns jogos, na maioria das vezes em atiradores.  Que surpresa nossa equipe foi quando vimos esse elemento da interface do usu√°rio nos layouts.  Devo dizer imediatamente que a implementa√ß√£o correta desse recurso pode exigir mais de uma hora de experimenta√ß√£o de voc√™, mas o resultado final vale o tempo gasto.  Come√ßamos definindo requisitos, a saber: </p><br><ul><li>  para qualquer orienta√ß√£o do dispositivo, o r√≥tulo se move ao longo das bordas da tela, </li><li>  se o usu√°rio girou 180 graus para o ponto final da rota, o r√≥tulo √© exibido na parte inferior da tela, </li><li>  a cada momento, girar em dire√ß√£o √† marca deve ser a curva mais curta at√© o ponto final da rota. </li></ul><br><p>  Ap√≥s descrever os requisitos, iniciamos a implementa√ß√£o.  Quase imediatamente, chegamos √† conclus√£o de que a renderiza√ß√£o seria feita usando o UIKit.  O principal problema com a implementa√ß√£o foi a determina√ß√£o do centro desse r√≥tulo em cada momento.  Depois de considerar a marca de chegada, essa tarefa n√£o deve causar dificuldades, por isso n√£o vou me deter em sua solu√ß√£o em detalhes.  No artigo, apenas darei uma descri√ß√£o do algoritmo para a escolha do centro do r√≥tulo auxiliar, e o c√≥digo fonte pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Algoritmo de Centro de Pesquisa Algoritmo de Pesquisa: </p><br><ol><li>  crie um objeto SCNNode para o ponto final da rota com uma posi√ß√£o na cena obtida da coordenada geogr√°fica do ponto, </li><li>  encontre a proje√ß√£o de um ponto no plano da tela, </li><li>  encontre a interse√ß√£o do segmento do centro da tela at√© o ponto da proje√ß√£o encontrada com os segmentos dos limites da tela no sistema de coordenadas da tela. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="terminar-marcador-sugest√£o-solu√ß√£o"></p><br><p>  O ponto de interse√ß√£o encontrado √© o centro desejado da marca auxiliar.  Por analogia com o c√≥digo que atualiza os par√¢metros do r√≥tulo final, colocamos o c√≥digo que renderiza o r√≥tulo auxiliar no m√©todo delegado j√° mencionado acima. </p><br><h1 id="poliliniya-marshruta">  Polilinha de rota </h1><br><p>  Tendo constru√≠do uma rota e visto a marca de chegada na tela, o usu√°rio pode alcan√ß√°-la orientando apenas na dire√ß√£o da marca, mas o roteamento √© chamado assim porque mostra a rota para o usu√°rio.  Pensamos que seria muito estranho reduzir a funcionalidade do roteamento de pedestres, excluindo a exibi√ß√£o da rota da vers√£o AR.  Para visualizar a linha de rota, decidiu-se exibir um conjunto de setas se movendo ao longo dela.  Nesse caso, os projetistas estavam convencidos de que as flechas praticamente desapareceriam ao se afastar (o tamanho seria determinado pelas regras da proje√ß√£o em perspectiva) e decidiu-se usar o SceneKit para implementa√ß√£o. </p><br><p>  Antes de continuar a descrever a implementa√ß√£o, √© importante observar que, por design, as setas deveriam estar a uma dist√¢ncia de 3 m uma da outra.  Se voc√™ estimar o n√∫mero de objetos (setas) que precisam ser renderizados com uma rota de cerca de 1 km, ser√£o aproximadamente 330 pe√ßas.  Ao mesmo tempo, cada objeto √© adicionado a uma anima√ß√£o de movimento ao longo de sua parte da rota.  Observe que as setas remotas da posi√ß√£o da c√¢mera no palco a uma dist√¢ncia de cerca de 100-150 metros s√£o praticamente invis√≠veis devido ao seu tamanho pequeno.  Tendo considerado esses fatores, decidiu-se n√£o exibir todos os objetos, mas exibir apenas aqueles que s√£o removidos do usu√°rio a n√£o mais de 100 metros ao longo da linha de rota, atualizando periodicamente o conjunto de objetos exibido.  Exibimos uma quantidade suficiente de informa√ß√µes visuais, eliminando c√°lculos desnecess√°rios do SceneKit e economizando a bateria do usu√°rio. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="vis√£o geral da rota-polilinha"></p><br><p>  Vejamos as principais etapas que tivemos que realizar para obter o resultado final: </p><br><ul><li>  sele√ß√£o da se√ß√£o de rota para a qual exibiremos as primitivas, </li><li>  cria√ß√£o de modelos 3D, </li><li>  cria√ß√£o de anima√ß√£o </li><li>  atualizar ao dirigir ao longo de uma rota. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Selecionando uma plotagem para exibir </h2><br><p>  Como observei acima, n√£o exibimos setas para toda a rota, mas selecionamos a se√ß√£o ideal para exibi√ß√£o.  A escolha de um segmento em um momento arbitr√°rio consiste em procurar o segmento de rota mais pr√≥ximo (a rota √© uma sequ√™ncia de segmentos / segmentos) at√© a posi√ß√£o atual do usu√°rio e selecionar segmentos da rota mais pr√≥xima ao ponto final da rota at√© que seu comprimento total exceda 100 metros. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="rota-polilinha-rota-parte-sele√ß√£o"></p><br><h2 id="sozdanie-3d-modeli">  Cria√ß√£o de modelo 3D </h2><br><p>  Considere com mais detalhes o processo de cria√ß√£o de um modelo 3D.  Na maioria dos casos, tudo o que voc√™ precisa fazer para criar um modelo 3D simples (como nossa seta) √© abrir qualquer editor 3D, passar algum tempo dominando-o e criar esse modelo nele.  Caso os funcion√°rios de sua equipe tenham experi√™ncia em modelagem 3D ou tenham tempo para aprender, por exemplo, 3DMax (e deve ser comprado), voc√™ ter√° uma sorte incr√≠vel.  Infelizmente, no momento da implementa√ß√£o desse recurso, nenhum de n√≥s tinha nenhuma experi√™ncia especial, n√£o havia tempo livre para treinamento, portanto tivemos que fazer um modelo, por assim dizer, com meios improvisados.  Quero dizer a descri√ß√£o do modelo no c√≥digo.  Tudo come√ßou com a apresenta√ß√£o de um modelo 3D na forma de tri√¢ngulos.  Em seguida, tivemos que encontrar manualmente as coordenadas dos v√©rtices desses tri√¢ngulos no sistema de coordenadas do modelo e criar uma matriz de √≠ndices dos v√©rtices dos tri√¢ngulos.  Com esses dados √† nossa disposi√ß√£o, podemos criar a geometria necess√°ria diretamente no SceneKit.  Voc√™ pode criar um modelo semelhante ao nosso, por exemplo, assim: </p><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SCNGeometry</span></span></span></span> { convenience init(material: SCNMaterial) { let vertices: [<span class="hljs-type"><span class="hljs-type">SCNVector3</span></span>] = [ <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">11</span></span> ] let sources: [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>] = [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>(<span class="hljs-type"><span class="hljs-type">vertices</span></span>: <span class="hljs-type"><span class="hljs-type">vertices</span></span>)] let indices: [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span><span class="hljs-number"><span class="hljs-number">32</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] let geometryElements = [<span class="hljs-type"><span class="hljs-type">SCNGeometryElement</span></span>(<span class="hljs-type"><span class="hljs-type">indices</span></span>: <span class="hljs-type"><span class="hljs-type">indices</span></span>, <span class="hljs-type"><span class="hljs-type">primitiveType</span></span>: <span class="hljs-type"><span class="hljs-type">.triangles</span></span>)] self.init(sources: sources, elements: geometryElements) self.materials = [<span class="hljs-type"><span class="hljs-type">material</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func arrowBlue() -&gt; SCNGeometry { let material = SCNMaterial() material.diffuse.contents = UIColor.blue material.lightingModel = .constant <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ARSCNArrowGeometry(material: material) }</code> </pre> <br><p>  O resultado final √© assim: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="rota-polilinha-seta-modelo"></p><br><h2 id="animaciya-linii-marshruta">  Anima√ß√£o da linha de rota </h2><br><p>  O pr√≥ximo passo no caminho para exibir uma linha animada da rota foi o est√°gio de cria√ß√£o da pr√≥pria anima√ß√£o.  Mas qual √© a maneira de realizar a anima√ß√£o, que, na forma final, parece que a seta inicia seu movimento no ponto inicial da se√ß√£o selecionada da rota e "flutua" ao longo da rota at√© o final desta se√ß√£o? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  N√£o descreverei todas as formas poss√≠veis para criar uma anima√ß√£o desse tipo; em vez disso, abordarei mais detalhadamente o m√©todo que escolhemos.  Depois que uma se√ß√£o da rota √© selecionada, a dividimos em se√ß√µes do mesmo comprimento - se√ß√µes da anima√ß√£o de uma seta.  Cada uma dessas se√ß√µes √© destacada em cores e tem um comprimento igual √† dist√¢ncia entre as setas. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="rota-polilinha-rota-parte-particionamento"></p><br><p>  No in√≠cio de cada se√ß√£o, criamos o objeto SCNNode da seta, cuja anima√ß√£o consiste em mover-se ao longo de sua se√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="rota-polilinha-setas-posi√ß√£o-inicial"></p><br><p>  Como voc√™ pode ver, a se√ß√£o de anima√ß√£o √†s vezes consiste em um segmento, √†s vezes em dois ou mais.  Tudo depende do passo (no nosso caso - 3 metros) entre as setas e as coordenadas dos pontos que comp√µem o percurso. </p><br><p>  Uma anima√ß√£o de seta √© uma sequ√™ncia de duas etapas: </p><br><ul><li>  apar√™ncia na posi√ß√£o inicial com o √¢ngulo de rota√ß√£o inicial, </li><li>  uma sequ√™ncia de deslocamentos ao longo de segmentos com rota√ß√µes nos pontos de conex√£o dos segmentos. </li></ul><br><p>  Esquematicamente, fica assim: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="route-polyline-arrow-anitaion-steps"></p><br><p>  Pareceu-nos a maneira mais f√°cil de implementar essa anima√ß√£o usando a API SCNAction - uma API declarativa que permite criar convenientemente anima√ß√µes sequenciais, de grupo e repetidas.  Voc√™ pode ver a implementa√ß√£o em mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Devido ao fato de que cada seta termina sua anima√ß√£o no ponto inicial da se√ß√£o de anima√ß√£o da pr√≥xima seta, √© criada a impress√£o de movimento cont√≠nuo da seta ao longo de toda a se√ß√£o selecionada da rota. </p><br><p>  Sobre isso, proponho concluir a considera√ß√£o de v√°rios aspectos da renderiza√ß√£o e ir para a parte principal - determinar as posi√ß√µes dos objetos no palco pelas coordenadas geogr√°ficas dos objetos. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Determinando a posi√ß√£o de um objeto na cena </h1><br><p>  Iniciamos a conversa sobre como determinar a posi√ß√£o de um objeto na cena considerando sistemas de coordenadas, cuja convers√£o deve ser realizada.  Existem apenas 2 deles: </p><br><ul><li>  coordenadas geod√©sicas (ou geogr√°ficas por simplicidade) - a posi√ß√£o dos objetos (pontos de rota) no mundo real, </li><li>  Coordenadas cartesianas - a posi√ß√£o dos objetos em cena (no ARKit).  Lembre-se de que o sistema de coordenadas da cena coincide com o sistema de coordenadas ARKit (no caso de usar o ARSCNView). </li></ul><br><p>  A tradu√ß√£o de um sistema de coordenadas para outro e vice-versa √© poss√≠vel devido ao fato de que as coordenadas no ARKit s√£o medidas em metros, e o deslocamento entre duas coordenadas geod√©sicas pode ser traduzido com grande precis√£o no deslocamento em metros ao longo dos eixos X e Z do sistema de coordenadas ARKit em pequenas compensa√ß√µes.  Deixe-me lembr√°-lo de que as coordenadas geod√©sicas s√£o pontos com uma certa longitude e latitude. </p><br><p>  Vamos relembrar conceitos importantes do curso de geografia, como paralelos e meridianos, e suas propriedades b√°sicas: </p><br><ul><li>  <strong>Paralelo</strong> √© uma linha com um valor de grau de latitude.  Os comprimentos dos v√°rios paralelos s√£o diferentes. </li><li>  <strong>Meridiano</strong> - uma linha com um valor de grau de longitude.  Os comprimentos de todos os meridianos s√£o os mesmos. </li></ul><br><p>  Agora vamos ver como voc√™ pode calcular o deslocamento em metros, entre duas coordenadas geod√©sicas com coordenadas <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  e <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">  : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta long \ times metersInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ times metersInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="metersInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {lands} \ cos \ left (\ alpha \ right)} {360 ^ {¬∞}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="metersInLatDegree = \ frac {2 \ pi R_ \ text {lands}} {360 ^ {¬∞}}"></p><br><div class="spoiler">  <b class="spoiler_title">Explica√ß√£o</b> <div class="spoiler_text"><p>  O deslocamento em coordenadas geod√©sicas √© mapeado linearmente para metros apenas em pequenos deslocamentos.  Em grandes deslocamentos, √© necess√°rio aceitar honestamente a integral. </p></div></div><br><p>  Agora que podemos traduzir o deslocamento de um sistema de coordenadas para outro, precisamos decidir sobre um ponto de refer√™ncia - um ponto para o qual a coordenada geogr√°fica e a coordenada no ARKit (coordenada no palco) s√£o conhecidas ao mesmo tempo.  Tendo encontrado esse ponto, podemos determinar a coordenada de qualquer objeto no palco, conhecendo sua coordenada geogr√°fica e usando as f√≥rmulas acima. </p><br><p>  Para maior clareza, considere um exemplo: <br>  No in√≠cio da sess√£o de realidade aumentada, solicitamos ao CoreLocation nossa coordenada geogr√°fica e a recebemos instantaneamente - <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ inline (lat_0, lon_0)">  .  Lembrando que a origem do sistema de coordenadas do ARKit est√° no in√≠cio da sess√£o no ponto em que o dispositivo est√° localizado, obtivemos o ponto de refer√™ncia, pois sabemos a coordenada geogr√°fica e a coordenada em cena <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ inline (x_0, y_0, z_0) = (0,0,0)">  .  Precisamos encontrar a coordenada na cena do objeto com uma coordenada geogr√°fica <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  .  Para fazer isso, encontre o deslocamento em metros entre a coordenada geogr√°fica do objeto e a coordenada geogr√°fica do nosso ponto de refer√™ncia e adicione o deslocamento encontrado √† coordenada na cena do ponto de refer√™ncia.  A coordenada resultante na cena ser√° a desejada. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="coordenadas-convers√£o-objeto-posi√ß√£o-em-cena"></p><br><p>  Observo que a posi√ß√£o na cena encontrada dessa maneira corresponder√° √† posi√ß√£o do objeto no mundo real somente se o eixo X / Z do sistema de coordenadas da cena estiver alinhado com as dire√ß√µes para o sul / leste.  O alinhamento do eixo, em teoria, deve ser alcan√ßado definindo o sinalizador worldAlignment como gravitiAndHeading.  Mas como eu disse no come√ßo do post, isso est√° longe de ser sempre o caso. </p><br><p>  Vamos considerar com mais detalhes o m√©todo de determina√ß√£o do ponto de refer√™ncia.  Para fazer isso, introduzimos o conceito de <strong>estimativa</strong> - um conjunto de coordenadas geogr√°ficas e coordenadas no palco. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="coordenadas-convers√£o-estimativa-defini√ß√£o"></p><br><p>  O m√©todo proposto acima para determinar o ponto de refer√™ncia nem sempre pode ser usado.  No momento do in√≠cio de uma sess√£o de realidade aumentada, uma solicita√ß√£o de CLLocation de um usu√°rio n√£o pode ser executada imediatamente; al√©m disso, a precis√£o da coordenada obtida pode ter um grande erro.  Seria mais correto solicitar ao SceneKit uma posi√ß√£o no palco no momento em que obtivermos o valor do CoreLocation.  Nesse caso, os componentes da estimativa resultante s√£o realmente obtidos ao mesmo tempo e temos a oportunidade de usar qualquer uma das estimativas como ponto de refer√™ncia.  Ao trabalhar com o ARKit, o erro de deslocamento se acumula com o tempo, portanto a Apple n√£o recomenda o uso do ARKit como ferramenta de navega√ß√£o. </p><br><p>  Quando decidimos implementar o roteamento de pedestres com realidade aumentada, fizemos uma pequena pesquisa sobre as solu√ß√µes existentes naquele momento, usando o ARKit para tarefas semelhantes, e nos deparamos com a estrutura ARKit + CoreLocation.  A id√©ia dessa estrutura era que, gra√ßas ao ARKit, podemos determinar com mais precis√£o a localiza√ß√£o do usu√°rio do que quando usamos exclusivamente CoreLocation. </p><br><p>  Conceito de ARKit + CoreLocation: </p><br><ul><li>  ao receber CLLocation de CLLocationManager <br><ul><li>  solicite uma posi√ß√£o na cena usando scene.pointOfView.worldPosition </li><li>  salve este par de coordenadas (estimativa) no buffer </li></ul></li><li>  obtenha a localiza√ß√£o exata, se necess√°rio <br><ul><li>  escolha a melhor estimativa </li><li>  calcular o deslocamento entre a posi√ß√£o atual no palco e a posi√ß√£o no palco da melhor estimativa </li><li>         </li></ul></li></ul><br><p>          ,   ,   CoreLocation,       . </p><br><p>   ,   ¬´ ¬ª.   ,      . </p><br><p>     (,    ): </p><br><ul><li>    (  horizontalAccuracy), </li><li>       , </li><li>        100    . </li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Porque</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit ‚Äì        ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\inline t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\inline (lat_1,lon_1)">      ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\inline (x_1,z_1)">  .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">      CLLocationManager ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\inline (x_2,z_2)">  em conformidade. </p><br><p>      ARKit ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\inline (\Delta x,\Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">  .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\inline (lat_{2calc},lon_{2calc})">  .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="coordinates-conversion-correction-angle-problem"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\inline initialBearing(1,2)">  e <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\inline initialBearing(1,2_{calc})"> ,  <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\inline 2_{calc}"> ‚Äì    2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\inline initialBearing(a,b)">   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="coordinates-conversion-correction-angle-calculation-for-pair"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="coordinates-conversion-correction-angle-calculation-error"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  Por exemplo: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Teste </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="correction-angle-calculation-alg-testing-street-before-correction"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="correction-angle-calculation-alg-testing-street-after-correction"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="correction-angle-calculation-alg-testing-street-after-last-correction"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="correction-angle-calculation-alg-testing-tracks"></p><br><p>              ‚Äî     gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o </h1><br><p>      Slack, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  Links √∫teis </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li> ARKit+CoreLocation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   ARKit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> AR   </a> </li></ul><br><p>      ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> .</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421957/">https://habr.com/ru/post/pt421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421945/index.html">Google e Mastercard concluem um acordo secreto para rastrear compras nas lojas</a></li>
<li><a href="../pt421947/index.html">Bem-vindo ao Android Devs Meetup 8 de setembro</a></li>
<li><a href="../pt421949/index.html">Esquadr√£o Suicida Como recrutamos os desenvolvedores juniores mais ferozes</a></li>
<li><a href="../pt421953/index.html">Summ3r 0f h4ck: est√°gio de ver√£o na Digital Security</a></li>
<li><a href="../pt421955/index.html">O Senado n√£o quer rob√¥s distra√≠dos com cerveja. E sobre o que mais escrever na sexta-feira?</a></li>
<li><a href="../pt421959/index.html">O que fazer quando "isto" perde o link de contexto</a></li>
<li><a href="../pt421961/index.html">Criando uma demonstra√ß√£o para um telefone antigo - AONDEMO</a></li>
<li><a href="../pt421963/index.html">Contabilidade e contador: seu papel na organiza√ß√£o</a></li>
<li><a href="../pt421965/index.html">‚ÄúAl√©m do trabalho, ainda trabalho‚Äù - 10 perguntas para o programador, terceira edi√ß√£o</a></li>
<li><a href="../pt421967/index.html">Brinquedo infantil em elementos l√≥gicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>