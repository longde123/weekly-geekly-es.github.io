<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🚒 👨🏼‍🎨 🚶 ConfigureAunggu, siapa yang harus disalahkan dan apa yang harus dilakukan? 😀 🌊 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam praktik saya, saya sering melihat, di lingkungan yang berbeda , kode seperti di bawah ini: 


[1] var x = FooWithResultAsync(/*...*/).Result; //...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAunggu, siapa yang harus disalahkan dan apa yang harus dilakukan?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463587/"><p>  Dalam praktik saya, saya sering melihat, di lingkungan yang <em>berbeda</em> , kode seperti di bawah ini: </p><br><pre><code class="plaintext hljs">[1] var x = FooWithResultAsync(/*...*/).Result; // [2] FooAsync(/*...*/).Wait(); // [3] FooAsync(/*...*/).GetAwaiter().GetResult(); // [4] FooAsync(/*...*/) .ConfigureAwait(false) .GetAwaiter() .GetResult(); // [5] await FooAsync(/*...*/).ConfigureAwait(false) //  [6] await FooAsync(/*...*/)</code> </pre> <br><p>  Dari komunikasi dengan penulis garis-garis tersebut, menjadi jelas bahwa mereka semua dibagi menjadi tiga kelompok: </p><br><ul><li>  Grup pertama adalah mereka yang tidak tahu apa-apa tentang kemungkinan masalah dengan memanggil <code>Result/Wait/GetResult</code> .  Contoh (1-3) dan kadang-kadang (6) adalah tipikal untuk programmer dari grup ini; </li><li>  Kelompok kedua termasuk programmer yang menyadari kemungkinan masalah, tetapi mereka tidak tahu penyebab terjadinya mereka.  Pengembang dari grup ini, di satu sisi, mencoba menghindari garis seperti (1-3 dan 6), tetapi, di sisi lain, kode penyalahgunaan seperti (4-5); </li><li>  Kelompok ketiga, dalam pengalaman saya yang terkecil, adalah para programmer yang tahu bagaimana kode (1-6) bekerja, dan karenanya, dapat membuat pilihan berdasarkan informasi. </li></ul><br><p>  Apakah risikonya memungkinkan, dan seberapa besar itu, ketika menggunakan kode, seperti dalam contoh di atas, tergantung, seperti yang saya sebutkan sebelumnya, pada <em>lingkungan</em> . </p><br><p><img src="https://habrastorage.org/webt/j6/dr/vl/j6drvl4thcu_8wzj5t7qe8o0oew.jpeg"></p><a name="habracut"></a><br><h2 id="riski-i-ih-prichiny">  Risiko dan penyebabnya </h2><br><p>  Contoh (1-6) dibagi menjadi dua kelompok.  Grup pertama adalah kode yang memblokir utas panggilan.  Grup ini termasuk (1-4). <br>  Memblokir utas seringkali merupakan ide yang buruk.  Mengapa  Untuk kesederhanaan, kami mengasumsikan bahwa semua utas dialokasikan dari beberapa kumpulan utas.  Jika program memiliki kunci, maka ini dapat menyebabkan pemilihan semua utas dari kolam.  Dalam kasus terbaik, ini akan memperlambat program dan menyebabkan penggunaan sumber daya yang tidak efisien.  Dalam kasus terburuk, ini dapat menyebabkan kebuntuan, ketika utas tambahan diperlukan untuk menyelesaikan beberapa tugas, tetapi kumpulan tidak dapat mengalokasikannya. <br>  Jadi, ketika pengembang menulis kode seperti (1-4), ia harus berpikir tentang seberapa besar kemungkinan situasi yang dijelaskan di atas. </p><br><p>  Tetapi banyak hal menjadi lebih buruk ketika kita bekerja di lingkungan di mana ada konteks sinkronisasi yang berbeda dari standar.  Jika ada konteks sinkronisasi <em>khusus</em> , memblokir utas panggilan meningkatkan kemungkinan kebuntuan yang terjadi berkali-kali.  Jadi, kode dari contoh (1-3), jika dijalankan di utas WinForms UI, hampir dijamin akan membuat jalan buntu.  Saya menulis "praktis" karena  ada pilihan saat ini tidak demikian, tetapi lebih pada nanti.  Menambahkan <code>ConfigureAwait(false)</code> , seperti pada (4), tidak akan memberikan 100% jaminan perlindungan terhadap kebuntuan.  Berikut ini adalah contoh untuk mengonfirmasi ini: </p><br><pre> <code class="plaintext hljs">[7] //   /  . async Task FooAsync() { // Delay   .     . await Task.Delay(5000); //       RestPartOfMethodCode(); } //  ""  ,   ,  WinForms . private void button1_Click(object sender, EventArgs e) { FooAsync() .ConfigureAwait(false) .GetAwaiter() .GetResult(); button1.Text = "new text"; }</code> </pre> <br><p>  Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Komputasi Paralel - Semuanya Tentang SynchronizationContext"</a> memberikan informasi tentang berbagai konteks sinkronisasi. </p><br><p>  Untuk memahami penyebab kebuntuan, Anda perlu menganalisis kode mesin negara ke mana panggilan ke metode async dikonversi, dan kemudian kode kelas MS.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Async Menunggu dan</a> artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StateMachine Generated</a> memberikan contoh mesin negara tersebut. <br>  Saya tidak akan memberikan kode sumber lengkap yang dihasilkan misalnya (7), automaton, saya hanya akan menunjukkan baris-baris penting untuk analisis lebih lanjut: </p><br><pre> <code class="plaintext hljs">//  MoveNext. //... //  taskAwaiter    . taskAwaiter = Task.Delay(5000).GetAwaiter(); if(tasAwaiter.IsCompleted != true) { _awaiter = taskAwaiter; _nextState = ...; _builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter, ThisStateMachine&gt;(ref taskAwaiter, ref this); return; }</code> </pre> <br><p>  Cabang <code>if</code> dijalankan jika panggilan asinkron ( <code>Delay</code> ) belum selesai dan, oleh karena itu, utas saat ini dapat dibebaskan. <br>  Harap dicatat bahwa di <code>AwaitUnsafeOnCompleted</code> , taskAwaiter diterima dari panggilan asinkron (relatif ke <code>FooAsync</code> ) <strong>internal</strong> ( <code>Delay</code> ). </p><br><p>  Jika Anda terjun ke hutan sumber MS yang tersembunyi di balik panggilan <code>AwaitUnsafeOnCompleted</code> , maka, pada akhirnya, kami akan datang ke kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SynchronizationContextAwaitTaskContinuation</a> , dan kelas dasarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AwaitTaskContinuation</a> , di mana jawaban untuk pertanyaan itu berada. </p><br><p>  Kode kelas-kelas ini dan yang terkait agak membingungkan, oleh karena itu, untuk memfasilitasi persepsi, saya membiarkan diri saya menulis "analog" yang sangat disederhanakan dari contoh apa (7) berubah menjadi, tetapi tanpa mesin negara, dan dalam hal TPL: </p><br><pre> <code class="plaintext hljs">[8] Task FooAsync() { //  methodCompleted    ,  , //    ,     " ". //    ,   methodCompleted.WaitOne()  , //   SetResult  AsyncTaskMethodBuilder, //       . var methodCompleted = new AutoResetEvent(false); SynchronizationContext current = SynchronizationContext.Current; return Task.Delay(5000).ContinueWith( t=&gt; { if(current == null) { RestPartOfMethodCode(methodCompleted); } else { current.Post(state=&gt;RestPartOfMethodCode(methodCompleted), null); methodCompleted.WaitOne(); } }, TaskScheduler.Current); } // // void RestPartOfMethodCode(AutoResetEvent methodCompleted) // { //      FooAsync. // methodCompleted.Set(); // }</code> </pre> <br><p>  Dalam contoh (8), penting untuk memperhatikan fakta bahwa jika ada konteks sinkronisasi, semua kode metode asinkron yang muncul setelah penyelesaian panggilan asinkron internal <strong>dijalankan melalui konteks ini</strong> (panggil saat ini. <code>current.Post(...)</code> ).  Fakta ini <strong>adalah penyebab</strong> kebuntuan.  Misalnya, jika kita berbicara tentang aplikasi WinForms, maka konteks sinkronisasi di dalamnya dikaitkan dengan aliran UI.  Jika utas UI diblokir, misalnya (7) ini terjadi melalui panggilan ke <code>.GetResult()</code> , maka sisa kode metode asinkron tidak dapat dieksekusi, yang berarti bahwa metode asinkron tidak dapat menyelesaikan, dan tidak dapat melepaskan utas UI, yang merupakan jalan buntu. </p><br><p>  Dalam contoh (7), panggilan ke <code>FooAsync</code> dikonfigurasi melalui <code>ConfigureAwait(false)</code> , tetapi ini tidak membantu.  Faktanya adalah bahwa Anda perlu mengkonfigurasi objek tunggu yang akan diteruskan ke <code>AwaitUnsafeOnCompleted</code> , dalam contoh kami, ini adalah objek tunggu dari panggilan <code>Delay</code> .  Dengan kata lain, dalam hal ini, memanggil <code>ConfigureAwait(false)</code> dalam kode klien tidak masuk akal.  Anda dapat memecahkan masalah jika pengembang metode <code>FooAsync</code> mengubahnya sebagai berikut: </p><br><pre> <code class="plaintext hljs">[9] async Task FooAsync() { await Task.Delay(5000).ConfigureAwait(false); //       RestPartOfMethodCode(); } private void button1_Click(object sender, EventArgs e) { FooAsync().GetAwaiter().GetResult(); button1.Text = "new text"; }</code> </pre> <br><p>  Di atas, kami memeriksa risiko yang muncul dengan kode kelompok pertama - kode dengan pemblokiran (contoh 1-4).  Sekarang tentang grup kedua (contoh 5 dan 6) - kode tanpa kunci.  Dalam hal ini, pertanyaannya adalah, kapan panggilan ke <code>ConfigureAwait(false)</code> dibenarkan?  Ketika mem-parsing contoh (7), kami telah menemukan bahwa kami perlu mengonfigurasi objek yang menunggu atas dasar mana kelanjutan dari eksekusi akan dibangun.  Yaitu  konfigurasi diperlukan (jika Anda mengambil keputusan ini) hanya untuk panggilan asinkron <strong>internal</strong> . </p><br><h2 id="kto-vinovat">  Siapa yang harus disalahkan? </h2><br><p>  Seperti biasa, jawaban yang benar adalah "segalanya."  Mari kita mulai dengan programmer dari MS.  Di satu sisi, pengembang Microsoft memutuskan bahwa, di hadapan konteks sinkronisasi, pekerjaan harus dilakukan melaluinya.  Dan ini logis, kalau tidak mengapa masih diperlukan.  Dan, seperti yang saya percaya, mereka berharap bahwa pengembang kode "klien" <strong>tidak akan</strong> memblokir utas, terutama jika konteks sinkronisasi terkait dengannya.  Di sisi lain, mereka memberikan alat yang sangat sederhana untuk "menembak diri sendiri di kaki" - itu terlalu sederhana dan nyaman untuk mendapatkan hasilnya melalui pemblokiran. <code>.Result/.GetResult</code> , atau blok sungai, menunggu panggilan untuk mengakhiri, melalui. <code>.Wait</code> .  Yaitu  Pengembang MS telah memungkinkan bahwa penggunaan perpustakaan mereka yang "salah" (atau berbahaya) tidak menyebabkan kesulitan apa pun. </p><br><p>  Tetapi ada juga kesalahan pada pengembang kode "klien".  Terdiri dari fakta bahwa, seringkali, pengembang tidak mencoba untuk memahami alat mereka dan mengabaikan peringatan.  Dan ini adalah jalan langsung menuju kesalahan. </p><br><h2 id="chto-delat">  Apa yang harus dilakukan </h2><br><p>  Di bawah ini saya berikan rekomendasi saya. </p><br><h3 id="dlya-razrabotchikov-klientskogo-koda">  Untuk pengembang kode klien </h3><br><ol><li>  Lakukan yang terbaik untuk menghindari pemblokiran.  Dengan kata lain, jangan campur kode sinkron dan asinkron tanpa kebutuhan khusus. </li><li>  Jika Anda harus melakukan kunci, maka tentukan di lingkungan mana kode dieksekusi: <br><ul><li>  Apakah ada konteks sinkronisasi?  Jika demikian, yang mana?  Fitur apa yang ia buat dalam karyanya? </li><li>  Jika tidak ada konteks sinkronisasi, maka: Apa yang akan menjadi beban?  Apa kemungkinan blok Anda akan menyebabkan "kebocoran" benang dari kolam?  Apakah jumlah utas yang dibuat pada awal sudah cukup secara default, atau haruskah saya mengalokasikan lebih banyak? </li></ul></li><li>  Jika kodenya asinkron, apakah Anda perlu mengonfigurasi panggilan asinkron melalui <code>ConfigureAwait</code> ? </li></ol><br><p>  Buat keputusan berdasarkan semua informasi yang diterima.  Anda mungkin perlu memikirkan kembali pendekatan implementasi Anda.  Mungkin <code>ConfigureAwait</code> akan membantu Anda, atau mungkin Anda tidak membutuhkannya. </p><br><h3 id="dlya-razrabotchikov-bibliotek">  Untuk pengembang perpustakaan </h3><br><ol><li>  Jika Anda yakin bahwa kode Anda dapat dipanggil dari "sinkron", maka pastikan untuk menerapkan API sinkron.  Itu harus benar-benar sinkron, mis.  Anda harus menggunakan API sinkron dari perpustakaan pihak ketiga. </li><li>  <code>ConfigureAwait(true / false)</code> . </li></ol><br><p>  Di sini, dari sudut pandang saya, diperlukan pendekatan yang lebih halus daripada yang biasanya direkomendasikan.  Banyak artikel mengatakan bahwa dalam kode pustaka, semua panggilan asinkron harus dikonfigurasikan melalui <code>ConfigureAwait(false)</code> .  Saya tidak bisa setuju dengan itu.  Mungkin, dari sudut pandang penulis, kolega dari Microsoft membuat keputusan yang salah ketika memilih perilaku "default" dalam kaitannya dengan bekerja dengan konteks sinkronisasi.  Tetapi mereka (MS), bagaimanapun, meninggalkan kesempatan bagi pengembang kode "klien" untuk mengubah perilaku ini.  Strategi, ketika kode pustaka sepenuhnya tercakup oleh <code>ConfigureAwait(false)</code> , mengubah perilaku default, dan, yang lebih penting, pendekatan ini menghilangkan pengembang kode pilihan "klien". </p><br><p>  Opsi saya adalah, ketika menerapkan API asinkron, tambahkan dua parameter input tambahan untuk setiap metode API: <code>CancellationToken token</code> <code>bool continueOnCapturedContext</code> dan <code>bool continueOnCapturedContext</code> .  Dan implementasikan kodenya sebagai berikut: </p><br><pre> <code class="plaintext hljs">public async Task&lt;string&gt; FooAsync( /*  */, CancellationToken token, bool continueOnCapturedContext) { // ... await Task.Delay(30, token).ConfigureAwait(continueOnCapturedContext); // ... return result; }</code> </pre> <br><p>  Parameter pertama, <code>token</code> , berfungsi, seperti yang Anda ketahui, untuk kemungkinan pembatalan terkoordinasi (pengembang perpustakaan terkadang mengabaikan fitur ini).  Yang kedua, <code>continueOnCapturedContext</code> - memungkinkan Anda mengkonfigurasi interaksi dengan konteks sinkronisasi panggilan asinkron internal. </p><br><p>  Pada saat yang sama, jika metode API asinkron sendiri merupakan bagian dari metode asinkron lain, kode "klien" akan dapat menentukan bagaimana ia harus berinteraksi dengan konteks sinkronisasi: </p><br><pre> <code class="plaintext hljs">//     : async Task ClientFoo() { // ""  ClientFoo   ,     //   FooAsync   . await FooAsync( /*  */, ancellationToken.None, false); //     . await FooAsync( /*  */, ancellationToken.None, false).ConfigureAwait(false); //... } // ,  . private void button1_Click(object sender, EventArgs e) { FooAsync( /*  */, _source.Token, false).GetAwaiter().GetResult(); button1.Text = "new text"; }</code> </pre> <br><h2 id="v-kachestve-zaklyucheniya">  Kesimpulannya </h2><br><p>  Kesimpulan utama dari hal tersebut di atas adalah tiga pemikiran berikut: </p><br><ol><li>  Kunci seringkali merupakan akar dari semua kejahatan.  Kehadiran kunci yang dapat menyebabkan, dalam kasus terbaik, degradasi kinerja dan penggunaan sumber daya yang tidak efisien, dalam kondisi terburuk - hingga menemui jalan buntu.  Sebelum Anda menggunakan kunci, pertimbangkan apakah ini perlu?  Mungkin ada cara sinkronisasi lain yang dapat diterima dalam kasus Anda; </li><li>  Pelajari alat yang Anda gunakan; </li><li>  Jika Anda mendesain perpustakaan, cobalah untuk memastikan bahwa penggunaannya yang benar mudah, hampir intuitif, dan yang salah penuh dengan kompleksitas. </li></ol><br><p>  Saya mencoba sesederhana mungkin untuk menjelaskan risiko yang terkait dengan async / menunggu, dan alasan terjadinya.  Dan juga, mempresentasikan visi saya untuk menyelesaikan masalah ini.  Saya berharap bahwa saya berhasil, dan materi akan bermanfaat bagi pembaca.  Untuk lebih memahami bagaimana segala sesuatu bekerja, Anda harus, tentu saja, merujuk pada sumbernya.  Ini dapat dilakukan melalui repositori MS di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> atau, bahkan lebih nyaman, melalui situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MS</a> itu sendiri. </p><br><p>  <em>PS</em> Saya akan berterima kasih atas kritik yang membangun. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/branding/e54/4c4/1ba/e544c41ba712b412e5347191ba90d0c8.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463587/">https://habr.com/ru/post/id463587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463577/index.html">Plastisitas dan kekuatan: pengerasan intermetalik tanpa penekanan pada dislokasi</a></li>
<li><a href="../id463579/index.html">Windows: cari tahu siapa yang login di mana</a></li>
<li><a href="../id463581/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 23. Teknologi Routing Lanjut</a></li>
<li><a href="../id463583/index.html">Plugin yang fantastis, vol. 1. Teori</a></li>
<li><a href="../id463585/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 24. IPv6</a></li>
<li><a href="../id463591/index.html">BlueKeep-2 - semua versi Windows baru sekarang rentan</a></li>
<li><a href="../id463595/index.html">Kami mengontrol fokus atau sejumput C # dan STM32 untuk webcam</a></li>
<li><a href="../id463597/index.html">Menggunakan Context API in React untuk membuat desain aplikasi yang responsif</a></li>
<li><a href="../id463599/index.html">"Ini adalah mimpi buruk": para astronot berbagi pendapat tentang kesalahan yang dilakukan Hollywood ketika membuat film tentang ruang</a></li>
<li><a href="../id463601/index.html">Pisahkan metode logging di Java / logback</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>