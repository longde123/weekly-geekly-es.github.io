<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíû üêò üë®üèΩ‚Äçü§ù‚Äçüë®üèª Um novo jogo com uma atmosfera antiga no Three.js. Parte 2 ‚ú°Ô∏è üìâ üï°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte, falei sobre os problemas que encontrei no processo de cria√ß√£o de um jogo em 3D para o navegador usando o Three.js. Agora, gostaria ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um novo jogo com uma atmosfera antiga no Three.js. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira</a> parte, falei sobre os problemas que encontrei no processo de cria√ß√£o de um jogo em 3D para o navegador usando o Three.js.  Agora, gostaria de me aprofundar na solu√ß√£o de alguns problemas importantes ao escrever um jogo, como construir n√≠veis, detectar colis√µes e adaptar a imagem a qualquer propor√ß√£o da janela do navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Diagramas de n√≠vel </h3><br>  Na verdade, os pr√≥prios n√≠veis s√£o criados no editor 3D, a saber, sua geometria, mapeamento de textura, cozimento de sombras, etc.  Eu descrevi tudo isso na primeira parte.  Por que existem outros esquemas?  O fato √© que o Three.js n√£o oferece nenhum tipo de mecanismo f√≠sico, e eu uso esquemas de n√≠veis para identificar obst√°culos. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  O Three.js para resolver o problema de colis√£o oferece apenas raytracing - a maneira mais simples de determinar a interse√ß√£o da geometria dos objetos.  Em princ√≠pio, ele pode ser usado, e eu at√© fiz isso em um dos meus outros projetos.  Era uma cidade virtual diretamente no site, no navegador.  Voc√™ pode se deslocar pela cidade e n√£o passar pelas paredes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  No caso em que a interse√ß√£o da geometria do jogador com o edif√≠cio ocorre durante o movimento, implementei a repulsa do jogador por uma certa dist√¢ncia na dire√ß√£o oposta √† parede.  Mas para isso, os objetos devem ser paralelep√≠pedos.  Em torno de alguns objetos complexos, criei colisores (chamaremos os objetos invis√≠veis que desempenham o papel de obst√°culos e impedem o jogador de passar por eles mesmos), atrav√©s do qual as interse√ß√µes foram realizadas.  E as partes inferiores de alguns edif√≠cios, que s√£o simplesmente ‚Äúcaixas‚Äù, eram algumas vezes usadas como colididores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  Em objetos geometricamente complexos, o tra√ßado de raios pode n√£o funcionar ou se comportar de maneira inadequada.  E, como solu√ß√£o, voc√™ pode incorporar no objeto n√£o um, mas v√°rios pequenos coletores invis√≠veis na forma de paralelep√≠pedos com 100% de transpar√™ncia, desenhados um ao lado do outro e uns sobre os outros, repetindo aproximadamente a forma do objeto. <br><br>  No jogo sobre masmorras, o n√≠vel √© um √∫nico objeto longo com movimentos cortados para mover o jogador.  Na verdade, para resolver o problema da colis√£o, √© poss√≠vel colar coletores invis√≠veis sempre que necess√°rio e usar raytracing.  No entanto, eu decidi seguir o outro caminho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  Em primeiro lugar, eu queria automatizar o processo de cria√ß√£o de uma variedade de coletores. </li><li>  Em segundo lugar, voc√™ pode usar apenas informa√ß√µes sobre os coletores, ou seja, suas coordenadas no espa√ßo, e n√£o carregar a cena 3D em si com alguns objetos vazios extras. </li><li>  Em terceiro lugar, como o jogo usa apenas uma vista lateral e uma das coordenadas nunca muda ao se mover, voc√™ pode usar o c√°lculo de interse√ß√µes em apenas duas coordenadas. </li><li>  E quarto, afinal, de fato, haver√° um esquema de n√≠veis.  Al√©m disso, criar novos n√≠veis √© apenas conveniente, come√ßando com esse esquema.  Voc√™ pode simplesmente arrastar blocos pela tela em qualquer editor de gr√°ficos, construindo novos corredores e obst√°culos e, em seguida, execute o script e obtenha informa√ß√µes sobre os coletores.  Ou seja, o problema do editor de n√≠veis est√° parcialmente resolvido. </li></ul><br>  Eu escrevi um script que usa par√¢metros de entrada como o nome do arquivo do esquema de n√≠veis (png) e a cor, cujo preenchimento √© interpretado como um obst√°culo.  A cor padr√£o do espa√ßo livre √© preta.  Para processamento pelo script, o esquema de cada n√≠vel deve ser salvo em um arquivo png separado.  Por exemplo, para o n√≠vel mais baixo, fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  Concordei que um bloco deveria ter 80 pixels de largura e 48 pixels de altura.  Isso corresponde a 4 x 2,4 metros no mundo 3D.  Seria poss√≠vel criar 40 x 24 pixels, ou seja, dez vezes, mas na imagem parece pequena. <br><br>  O resultado do script no primeiro n√≠vel (a imagem √© cortada √† direita): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  O script √© executado no navegador.  Eu acho que n√£o h√° nenhum ponto na marca√ß√£o html, √© fundamental: campos de entrada de dados e um bot√£o Iniciar.  Em seguida, a imagem lida √© exibida na tela.  E, como resultado do script, uma matriz √© exibida sob a imagem na escala mundial 3D, que cont√©m as coordenadas inferior esquerda e superior direita de cada bloco e com o deslocamento especificado no script para cada n√≠vel.  Essa matriz pode ser copiada e colada na lista de coletores para usar no jogo (mais sobre isso abaixo), ela ser√° armazenada em algum tipo de constante.  As coordenadas tamb√©m aparecem na pr√≥pria imagem, mas no quadro de refer√™ncia da imagem 2D.  Esses n√∫meros s√£o exibidos no centro de cada bloco e permitem verificar se todos os blocos est√£o inclu√≠dos no c√°lculo.  Sozinhos, esses n√∫meros n√£o s√£o necess√°rios para nada, exceto para inspe√ß√£o visual.  Alguns blocos, como colunas entre as quais o jogador passa, n√£o devem ser contados.  Sobre quais objetos s√£o exclu√≠dos do c√°lculo - abaixo. <br><br>  Al√©m disso, por exemplo, no segundo n√≠vel, existem finas placas horizontais nas quais o jogador caminha.  Eles devem ser considerados.  Portanto, voc√™ precisa garantir que os n√∫meros tamb√©m apare√ßam neles.  No diagrama, fa√ßa 2 pixels de altura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Agora, sobre como o script leva em conta os blocos: <br><br><ul><li>  O esquema √© processado por blocos de 80x48, em cada um dos quais uma √°rea √© obtida do 2¬∫ ao 79¬∫ pixels horizontalmente e do 2¬∫ ao 47¬∫ pixels verticalmente.  O primeiro e o √∫ltimo pixels n√£o s√£o usados ‚Äã‚Äãpara que, ao redor dos blocos, voc√™ possa criar uma moldura preta com uma largura de 1 pixel, isso melhore a percep√ß√£o visual do circuito e facilite sua cria√ß√£o. </li><li>  Todos os pixels da linha superior do bloco s√£o visualizados.  Se houver cores entre elas, as coordenadas do bloco v√£o do primeiro ao √∫ltimo pixel colorido horizontalmente e at√© a altura total do bloco verticalmente na matriz final.  Este ser√° um bloco em branco na largura total ou parcial. </li><li>  Todos os pixels da linha inferior do bloco s√£o visualizados.  Se houver cores entre elas, mas n√£o houver uma colorida na linha superior, as coordenadas do bloco v√£o do primeiro ao √∫ltimo pixel colorido horizontalmente e 3 pixels verticalmente da parte inferior √† matriz final.  Esta ser√° uma plataforma sobre a qual andar.  Dentro de um bloco, pode haver v√°rias plataformas horizontais.  As plataformas s√£o reconhecidas apenas na parte inferior do bloco.  As coordenadas da plataforma s√£o "afundadas" em um bloco, localizado abaixo, para que a superf√≠cie da plataforma fique no mesmo n√≠vel dos blocos vizinhos - n√£o das plataformas. </li><li>  As colunas e outras decora√ß√µes dentro de um bloco vazio n√£o s√£o processadas, pois apenas a linha superior e inferior de pixels √© considerada.  Portanto, dentro do bloco, voc√™ pode colocar uma decora√ß√£o, explica√ß√µes para o diagrama, ponteiros, colunas, etc., sem medo de que isso afete de alguma forma o resultado do script. </li></ul><br>  Todas as coordenadas recebidas da matriz s√£o traduzidas para a escala do mundo 3D, multiplicada pelo coeficiente de sua escala (que foi selecionada no editor 3D quando foi criada).  A matriz est√° pronta para uso no jogo.  O c√≥digo do script foi escrito √†s pressas, por isso n√£o finge ser elegante, mas executa sua tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Agora - sobre como o jogo funciona com uma variedade de blocos.  O jogo usa corredores que se cruzam (n√≠veis).  Quando um jogador se transforma em um corredor, um novo conjunto de blocos √© conectado: e para cada corredor, consequentemente, seu pr√≥prio conjunto √© obtido, obtido a partir de seu esquema de n√≠veis.  Durante o movimento do jogador, suas coordenadas s√£o verificadas quanto a estar dentro de cada bloco.  E se ele estiver dentro de qualquer quarteir√£o, teremos uma colis√£o.  Mas a cada movimento do jogador, n√£o precisamos procurar cruzamentos com todos os blocos do n√≠vel, porque pode haver muitos deles.  Crie uma matriz apenas dos blocos mais pr√≥ximos do jogador. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Aqui, na entrada x, y, est√£o as coordenadas atuais do jogador, dw, dh, a dist√¢ncia na qual voc√™ deseja procurar blocos na horizontal e na vertical, por exemplo, 12 e 8 metros.  Em outras palavras, pegue todos os blocos ao redor do jogador em um quadrado de 24x16 metros.  Eles participar√£o da busca por confrontos.  ap.v.lv.d [i] √© um elemento de uma matriz de blocos do n√≠vel atual; na verdade, ele pr√≥prio tamb√©m √© uma matriz de 4 n√∫meros que definem os limites de um bloco - [x1, y1, x2, y2], portanto, para verificar o quadrado horizontalmente, pegamos elementos com os √≠ndices 0 e 2 e verticalmente - 1 e 3. Se houver uma correspond√™ncia, adicione esse bloco √† lista de colis√µes ap.v.coll. <br><br>  Quando o jogador se move, atualizaremos esta lista de colis√µes, mas para economizar desempenho, n√£o faremos isso a cada passo (ou melhor, renderizar o quadro), mas quando o jogador deixar um determinado quadrado, um pouco menor, especificado em ap.v.collwStep e ap.v.collhStep, por exemplo, 8 e 4 metros.  Ou seja, remontaremos a matriz de colis√£o novamente quando o jogador passar por um determinado caminho horizontal ou verticalmente de sua posi√ß√£o original.  Ao mesmo tempo, lembremos da posi√ß√£o em que remontamos o array para us√°-lo na pr√≥xima itera√ß√£o.  pers [ax] - aqui por ax, queremos dizer o eixo de coordenadas (ax), pode ser x ou z, dependendo da dire√ß√£o do corredor ao longo do qual o jogador est√° andando. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  Por que essas dificuldades?  Por que n√£o usar todo o conjunto de colis√µes no n√≠vel e n√£o tomar banho de vapor.  O fato √© que a detec√ß√£o de colis√£o √© realizada de acordo com um algoritmo muito mais complexo, e n√£o √© rent√°vel verificar a colis√£o com absolutamente todos os blocos de n√≠vel, e n√£o os mais pr√≥ximos, a cada renderiza√ß√£o de quadro.  (Embora isso n√£o seja preciso.) <br><br>  A defini√ß√£o de colis√µes em cada renderiza√ß√£o de um quadro usando a matriz de colis√µes preparada acima: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Aqui x, y, xOld, yOld s√£o as coordenadas novas e atuais do player.  Os novos s√£o calculados com o toque de um bot√£o, com base em uma determinada velocidade, ou seja, s√£o poss√≠veis coordenadas.  Eles s√£o verificados para ver se est√£o dentro de algum bloco da lista de colis√µes.  Se eles ca√≠rem, eles reverter√£o para os antigos e o jogador n√£o passar√° pelo obst√°culo.  E se n√£o caem, tornam-se atuais.  pw2 e ph2 s√£o metade da largura e altura do colisor imagin√°rio do jogador (largura do jogador / 2, altura do jogador / 2).  A sa√≠da √© emitida se houver uma colis√£o horizontal e vertical (collw, collh), se houver um bloco de suporte (supportf) sob o player - isso deixa claro se √© necess√°rio iniciar a anima√ß√£o de queda ainda mais ou se o player simplesmente mudou para um bloco vizinho e assim por diante.  Apenas n√£o pergunte por que adicionei 0,001 l√° e subtra√≠ 0,11.  √â uma muleta terr√≠vel que evita cair atrav√©s dos blocos e o efeito de tremula√ß√£o ao colidir com um obst√°culo horizontal ... Essa fun√ß√£o funciona, mas precisa ser reescrita da maneira normal.  A otimiza√ß√£o dessa fun√ß√£o tamb√©m est√° ausente ainda. <br><br>  Eu acho que com colis√µes vale a pena terminar aqui. <br><br>  √â dif√≠cil dizer qu√£o r√°pido meu m√©todo √© ou talvez mais lento que o tra√ßado de raios, mas no √∫ltimo, o Three.js tamb√©m armazena uma variedade de objetos que participam do sistema de colis√£o.  Apenas as colis√µes s√£o determinadas pelo m√©todo de emiss√£o da viga e sua interse√ß√£o com os planos dos lados dos objetos, e comigo, determinando se as coordenadas de um objeto est√£o dentro do outro ao longo de cada um dos dois eixos. <br><br>  O jogo tamb√©m possui objetos em movimento (tubar√£o) e objetos marcadores que acionam algum tipo de anima√ß√£o (por exemplo, o contato com a √°gua aciona o movimento de um tubar√£o).  Todos esses objetos tamb√©m participam de colis√µes, e alguns com coordenadas que variam no tempo.  Ali, curiosamente, tudo √© mais simples: durante o movimento do objeto, suas coordenadas s√£o comparadas com as coordenadas do jogador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  Em geral, manter um gamepad javascript em um navegador n√£o √© uma tarefa trivial.  N√£o h√° eventos de pressionar e liberar bot√µes.  Existem apenas eventos conectando e desconectando o dispositivo e o estado que pode ser obtido por pesquisas peri√≥dicas e, em seguida, compare-o com o anterior. <br><br>  Um v√≠deo demonstrando a opera√ß√£o do gamepad em um navegador em um tablet no Windows 8.1 e um PC no Windows 10. O tablet, no entanto, √© antigo, lan√ßado em 2014, de modo que a ilumina√ß√£o din√¢mica √© desativada no jogo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Para pesquisar o gamepad, uma fun√ß√£o chamada uma vez a cada 100 milissegundos √© usada.  √â definido usando a fun√ß√£o da minha biblioteca m3d.lib.globalTimer.addEvent. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  Aqui globalTimer √© o sistema de gerenciamento de eventos de timer javascript setInterval que eu escrevi.  L√°, simplesmente uma s√©rie de eventos √© adicionada a uma determinada matriz que precisa ser chamada em intervalos diferentes.  Ent√£o, um temporizador setInterval √© definido com a frequ√™ncia correspondente ao evento com a frequ√™ncia mais alta de todas.  O timer pesquisa a fun√ß√£o m3d.lib.globalTimer.update (), que percorre a lista de todos os eventos e executa as fun√ß√µes daqueles que foram executados.  Ao adicionar ou remover eventos, a frequ√™ncia do intervalo tamb√©m pode ser alterada (por exemplo, se voc√™ excluir o evento mais r√°pido). <br><br>  O jogo tamb√©m define manipuladores para cada tecla do gamepad: 'a' √© para o eixo (machado), 'b' √© para o bot√£o (bot√£o) e 11 √© o desvio esquerdo ao longo do eixo horizontal da cruz (como se fosse o bot√£o 1), 12 - o desvio correto ao longo do eixo horizontal da cruz (como se fosse o bot√£o 2), 21 e 22 - para o eixo vertical.  Por exemplo: <br><br>  ['a', 11], <br>  ['b', 3] <br><br>  significa que a pr√≥xima fun√ß√£o ser√° definida ao mesmo tempo para o desvio no eixo horizontal √† esquerda e para o bot√£o 3 (esquerda).  Bem, ent√£o √© definida uma fun√ß√£o que ser√° executada quando o bot√£o for pressionado e depois liberada. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Aqui apcontrolsRenderStart () √© uma fun√ß√£o que inicia uma renderiza√ß√£o se ainda n√£o estiver em execu√ß√£o.  Em geral, o suporte ao gamepad est√° intimamente ligado √† minha biblioteca m3d, por isso, se eu continuar descrevendo todos os seus recursos, ele se estender√° por muito tempo ... <br><br>  Vou dar apenas uma parte: gamepad, no qual implementei a inicializa√ß√£o do gamepad, instala√ß√£o de manipuladores e pesquisas de estado da maneira mais simples. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  Em geral, o suporte ao gamepad ainda est√° incompleto: apenas o suporte ao gamepad mais simples √© implementado, mas n√£o o que, por exemplo, √© usado no XBox, porque eu n√£o o tenho.  Se eu conseguir, vou program√°-lo e trabalhar com ele.  L√° ser√° poss√≠vel ajustar a velocidade do personagem, ou seja, ser√° poss√≠vel mover-se a qualquer velocidade no intervalo de etapa a corrida.  Isso √© obtido usando par√¢metros fracion√°rios dos eixos.  Meu gamepad retorna apenas n√∫meros inteiros -1 e 1. Al√©m disso, meu gamepad tem uma cruz repugnante e, quando pressionado para a esquerda ou para a direita, pressiona simultaneamente para cima ou para baixo.  Portanto, eu n√£o usei a parte superior e inferior na cruz e a dupliquei com os bot√µes √† direita do gamepad ... Com o lan√ßamento do jogo, pretendo criar v√°rios perfis de gamepads.  Al√©m disso, no caso de conectar v√°rios gamepads, apenas o √∫ltimo ser√° usado at√© o momento. <br><br><h3>  Tela responsiva </h3><br>  O jogo foi projetado para uma propor√ß√£o de 16: 9.  Mas adicionei o ajuste horizontal autom√°tico de ¬± 10% para que na janela expandida do navegador n√£o houvesse barras pretas nas laterais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  E seria assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  No modo de tela cheia, haver√° 16: 9 reais.  Seria poss√≠vel adaptar a imagem em geral a qualquer propor√ß√£o da janela do navegador, mas n√£o o fiz, pois uma janela baixa e larga levaria a um √¢ngulo de vis√£o muito grande, o que n√£o √© bom do ponto de vista da jogabilidade: becos sem sa√≠da distantes, objetos, inimigos ser√£o imediatamente vis√≠veis e tudo o mais que o jogador ainda n√£o precisa ver.  Portanto, limitei-me a ajustar dentro de ¬± 10% de 16: 9.  No entanto, para monitores estreitos (4: 3), percebi a capacidade de alternar de 16: 9 para o modo de adapta√ß√£o de 4: 3 para 16: 9 pressionando a tecla Y.  Mas n√£o mais amplo - ent√£o, novamente, para n√£o quebrar a jogabilidade.  Ou seja, voc√™ pode reproduzir na propor√ß√£o cl√°ssica de 16: 9 ou aumentar a imagem at√© a altura da janela cortando-a horizontalmente.  Embora isso tamb√©m n√£o seja muito bom, por exemplo, em situa√ß√µes de fliperama, quando algo voa na dire√ß√£o do jogador pelo lado.  Pouco tempo resta para a rea√ß√£o.  Mas voc√™ sempre pode retornar rapidamente ao modo cl√°ssico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  A adapta√ß√£o da tela, bem como todas as teclas de atalho usadas no jogo, s√£o mostradas no v√≠deo a seguir: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Na verdade, a propor√ß√£o √© definida nas configura√ß√µes do jogo. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  E no jogo, quando voc√™ pressiona Y, ele alterna: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Minha biblioteca tem um evento que trava na janela de redimensionamento.  Aqui est√° um fragmento: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  O m3d.lib.inBlock tamb√©m √© uma fun√ß√£o da minha biblioteca, que inscreve um ret√¢ngulo em outro ret√¢ngulo com par√¢metros como centraliza√ß√£o, redimensionamento ou corte e exibe as novas dimens√µes do ret√¢ngulo inscrito, bem como os tamanhos dos campos formados nesse processo.  Com base nessas informa√ß√µes, o cont√™iner div da janela √© posicionado.  'renderer' √© um elemento de contexto de bloco de uma cena 3D.  Em seguida, a tela √© dimensionada para l√° de acordo com os par√¢metros obtidos. <br><br>  A interface do usu√°rio √© exibida no cont√™iner em um elemento de tela separado.  Em geral, a √°rvore de documentos consiste em tr√™s blocos DIV transparentes com posicionamento absoluto (mais ou menos poss√≠vel, dependendo das necessidades do jogo): na parte inferior est√° a tela da cena 3D, acima est√° a tela para IU e a parte superior √© usada para animar elementos da interface e outros efeitos visuais .  Ou seja, a interface do usu√°rio n√£o √© renderizada em 3D, mas em seu knavass ou camada.  A tarefa de combinar camadas em uma √∫nica imagem √© deixada para o navegador.  Para trabalhar com a interface do usu√°rio, tenho um objeto especial na biblioteca.  Resumidamente - a ess√™ncia √© a seguinte.  As listas de sprites com elementos da interface do usu√°rio no formato png com transpar√™ncia s√£o carregadas.  A partir da√≠, os elementos necess√°rios s√£o retirados - planos de fundo, bot√µes.  E eles s√£o desenhados na tela do meio usando a fun√ß√£o js drawImage (img, ix, iy, iw, ih, x, y, w, h).  Ou seja, os fragmentos necess√°rios da imagem s√£o exibidos nas posi√ß√µes necess√°rias na tela.  Os bot√µes s√£o exibidos na parte superior dos fundos anexados a eles - todas as suas posi√ß√µes e tamanhos s√£o definidos na configura√ß√£o da interface do usu√°rio.  Ao redimensionar uma janela, as posi√ß√µes dos elementos na tela de destino (na qual s√£o exibidas) s√£o recalculadas, dependendo se esse ou aquele elemento est√° centralizado horizontal e verticalmente ou se est√° encaixado em algum canto ou face da tela.  Isso cria uma interface do usu√°rio adapt√°vel que n√£o depende da propor√ß√£o da tela.  Apenas √© necess√°rio definir a resolu√ß√£o m√≠nima poss√≠vel horizontal e verticalmente e n√£o ficar abaixo dela para que os elementos n√£o se sobreponham.  Falarei sobre a interface do usu√°rio outra vez, porque o artigo acabou sendo volumoso e ainda estou trabalhando na interface, porque ainda h√° muitas fun√ß√µes ausentes necess√°rias.  Por exemplo, em monitores de alta resolu√ß√£o, a interface parecer√° pequena.  Voc√™ pode multiplicar o tamanho dos elementos por um determinado coeficiente, dependendo da resolu√ß√£o da tela.  Por outro lado, talvez os enormes bot√µes na tela n√£o sejam necess√°rios?  Se a resolu√ß√£o da tela for grande, a tela em si √© bastante grande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  E voc√™ pode dar ao programador uma escolha - escalar a IU dinamicamente com o tamanho da janela ou distribuir os elementos nos cantos.  No caso do tamanho din√¢mico, tamb√©m existem quest√µes pr√≥prias - por exemplo, o "sab√£o" de uma interface quando ela √© exibida em uma escala muito grande.  Se voc√™ criar sprites de elementos de interface em uma resolu√ß√£o deliberadamente grande, eles ocupar√£o muito espa√ßo e tamb√©m, provavelmente, n√£o ser√° √∫til para dispositivos pequenos - eles ainda n√£o precisam de sprites grandes, mas consumir√£o mem√≥ria. <br><br>  Eu acho que √© o suficiente por hoje.  Ainda h√° algo em que pensar, como implementar isso ou aquilo.  Enquanto isso, discordo por algum tempo da programa√ß√£o e fa√ßo promo√ß√£o.  Eu pretendo participar de um par de vitrines independentes e estou ativamente envolvido na promo√ß√£o do jogo nas redes sociais, j√° que em novembro planejo ir para a plataforma de crowdfunding: precisarei de especialistas na √°rea de gr√°ficos 3D e anima√ß√£o esquel√©tica para concluir o jogo. <br><br>  Nos artigos a seguir, falarei sobre o controle de toque nos navegadores para dispositivos m√≥veis - nem todos conectam um gamepad ou teclado ao tablet, sobre a otimiza√ß√£o de gr√°ficos 3D para dispositivos de baixa pot√™ncia e muito mais. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472272/">https://habr.com/ru/post/pt472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472258/index.html">Como "aprender a aprender" - melhore a aten√ß√£o plena</a></li>
<li><a href="../pt472262/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 318 (de 14 a 20 de outubro)</a></li>
<li><a href="../pt472264/index.html">Arqueologia digital e realidade virtual ou como tentei fazer amizade com BIM e VR</a></li>
<li><a href="../pt472268/index.html">Melhorando os controles do Microsoft Edge no Chromium</a></li>
<li><a href="../pt472270/index.html">‚ÄúVoc√™ n√£o tem acesso √† ora√ß√£o atual‚Äù: contas de alta tecnologia do Vaticano foram cortadas em 15 minutos</a></li>
<li><a href="../pt472274/index.html">SSH remoto: dicas e hacks</a></li>
<li><a href="../pt472278/index.html">Meu commit git favorito</a></li>
<li><a href="../pt472280/index.html">A tarefa de determinar a presen√ßa de uma palma em um scanner de veias</a></li>
<li><a href="../pt472288/index.html">9 extens√µes √∫teis de navegador para desenvolvedores (lista para 2020)</a></li>
<li><a href="../pt472290/index.html">Estruturas vs. Classes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>