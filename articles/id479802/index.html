<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç† üñºÔ∏è üëÆ C ++ vtables. Bagian 1 (dasar-dasar + beberapa Inheritance) üôè üôçüèΩ üë©üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Terjemahan artikel disiapkan khusus untuk siswa kursus "Pengembang C ++" Apakah menarik untuk dikembangkan ke arah ini? Datang online 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vtables. Bagian 1 (dasar-dasar + beberapa Inheritance)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/479802/"><p>  <em>Halo semuanya!</em>  <em>Terjemahan artikel disiapkan khusus untuk siswa kursus <a href="https://otus.pw/d2qJ/">"Pengembang C ++"</a></em>  <em>Apakah menarik untuk dikembangkan ke arah ini?</em>  <em>Datang online 13 Desember pukul 20.00 waktu Moskow.</em>  <em>ke kelas master <a href="https://otus.pw/x79M/">"Berlatih menggunakan Kerangka Tes Google"</a> !</em> </p><br><p><img src="https://habrastorage.org/webt/eh/lh/ox/ehlhoxzs1sz7v7xtni9lizjefxq.png"></p><br><p>  Pada artikel ini, kita akan melihat bagaimana clang mengimplementasikan vtables (tabel metode virtual) dan RTTI (identifikasi tipe runtime).  Pada bagian pertama, kita mulai dengan kelas dasar, dan kemudian melihat pewarisan berganda dan virtual. <a name="habracut"></a></p><br><p>  Harap dicatat bahwa dalam artikel ini kita harus menggali representasi biner yang dihasilkan untuk berbagai bagian kode kita menggunakan gdb.  Ini adalah level yang cukup rendah, tetapi saya akan melakukan semua kerja keras untuk Anda.  Saya tidak berpikir bahwa sebagian besar posting di masa depan akan menjelaskan detail dari level rendah seperti itu. </p><br><blockquote>  <em>Penafian</em> : semua yang ditulis di sini tergantung pada implementasinya, dapat berubah dalam versi apa pun di masa mendatang, jadi Anda tidak harus bergantung padanya.  Kami menganggap ini hanya untuk tujuan pendidikan. </blockquote><p><img src="https://habrastorage.org/webt/40/po/du/40podustjhxkcl7_keexd9uea2e.png"></p><br><p>  luar biasa, maka mari kita mulai. </p><br><h2 id="chast-1---vtables---osnovy">  Bagian 1 - vtables - Dasar-dasar </h2><br><p>  Mari kita lihat kode berikut: </p><br><pre><code class="plaintext hljs">#include &lt;iostream&gt; using namespace std; class NonVirtualClass { public: void foo() {} }; class VirtualClass { public: virtual void foo() {} }; int main() { cout &lt;&lt; "Size of NonVirtualClass: " &lt;&lt; sizeof(NonVirtualClass) &lt;&lt; endl; cout &lt;&lt; "Size of VirtualClass: " &lt;&lt; sizeof(VirtualClass) &lt;&lt; endl; }</code> </pre> <br><pre> <code class="plaintext hljs">$ #    main.cpp $ clang++ main.cpp &amp;&amp; ./a.out Size of NonVirtualClass: 1 Size of VirtualClass: 8</code> </pre> <br><p>  <code>NonVirtualClass</code> memiliki ukuran 1 byte, karena di kelas C ++ tidak dapat memiliki ukuran nol.  Namun, ini tidak penting sekarang. </p><br><p>  <code>VirtualClass</code> adalah 8 byte pada mesin 64-bit.  Mengapa  Karena di dalamnya ada pointer tersembunyi yang menunjuk ke sebuah vtable.  vtables adalah tabel terjemahan statis yang dibuat untuk setiap kelas virtual.  Artikel ini berbicara tentang konten mereka dan bagaimana mereka digunakan. </p><br><p>  Untuk mendapatkan pemahaman lebih dalam tentang seperti apa vtables, mari kita lihat kode berikut dengan gdb untuk mengetahui bagaimana memori dialokasikan: </p><br><pre> <code class="plaintext hljs">#include &lt;iostream&gt; class Parent { public: virtual void Foo() {} virtual void FooNotOverridden() {} }; class Derived : public Parent { public: void Foo() override {} }; int main() { Parent p1, p2; Derived d1, d2; std::cout &lt;&lt; "done" &lt;&lt; std::endl; }</code> </pre> <br><pre> <code class="plaintext hljs">$ #         ,  gdb $ clang++ -std=c++14 -stdlib=libc++ -g main.cpp &amp;&amp; gdb ./a.out ... (gdb) #  gdb  -  C++ (gdb) set print asm-demangle on (gdb) set print demangle on (gdb) #     main (gdb) b main Breakpoint 1 at 0x4009ac: file main.cpp, line 15. (gdb) run Starting program: /home/shmike/cpp/a.out Breakpoint 1, main () at main.cpp:15 15 Parent p1, p2; (gdb) #     (gdb) n 16 Derived d1, d2; (gdb) #     (gdb) n 18 std::cout &lt;&lt; "done" &lt;&lt; std::endl; (gdb) #  p1, p2, d1, d2 -     ,    (gdb) p p1 $1 = {_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;} (gdb) p p2 $2 = {_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;} (gdb) p d1 $3 = {&lt;Parent&gt; = {_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;}, &lt;No data fields&gt;} (gdb) p d2 $4 = {&lt;Parent&gt; = {_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;}, &lt;No data fields&gt;}</code> </pre> <br><p>  Inilah yang kami pelajari dari hal di atas: <br>  - Terlepas dari kenyataan bahwa kelas tidak memiliki anggota data, ada pointer tersembunyi ke vtable; <br>  - vtable untuk p1 dan p2 adalah sama.  vtables adalah data statis untuk setiap jenis; <br>  - d1 dan d2 mewarisi vtable-pointer dari Parent, yang menunjuk ke vtable Berasal; <br>  - Semua vtables menunjukkan offset 16 (0x10) byte di vtable.  Kami juga akan membahas ini nanti. </p><br><p>  Mari kita lanjutkan sesi gdb kami untuk melihat isi dari vtables.  Saya akan menggunakan perintah x, yang menampilkan memori di layar.  Kita akan menghasilkan 300 byte dalam heksadesimal, dimulai dengan 0x400b40.  Kenapa tepatnya alamat ini?  Karena kami melihat di atas bahwa penunjuk vtable menunjuk ke 0x400b50, dan simbol untuk alamat ini adalah <code>vtable for Derived+16 (16 == 0x10)</code> . </p><br><pre> <code class="plaintext hljs">(gdb) x/300xb 0x400b40 0x400b40 &lt;vtable for Derived&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b48 &lt;vtable for Derived+8&gt;: 0x90 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400b50 &lt;vtable for Derived+16&gt;: 0x80 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b58 &lt;vtable for Derived+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b60 &lt;typeinfo name for Derived&gt;: 0x37 0x44 0x65 0x72 0x69 0x76 0x65 0x64 0x400b68 &lt;typeinfo name for Derived+8&gt;: 0x00 0x36 0x50 0x61 0x72 0x65 0x6e 0x74 0x400b70 &lt;typeinfo name for Parent+7&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b78 &lt;typeinfo for Parent&gt;: 0x90 0x20 0x60 0x00 0x00 0x00 0x00 0x00 0x400b80 &lt;typeinfo for Parent+8&gt;: 0x69 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400b88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b90 &lt;typeinfo for Derived&gt;: 0x10 0x22 0x60 0x00 0x00 0x00 0x00 0x00 0x400b98 &lt;typeinfo for Derived+8&gt;: 0x60 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400ba0 &lt;typeinfo for Derived+16&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400ba8 &lt;vtable for Parent&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400bb0 &lt;vtable for Parent+8&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400bb8 &lt;vtable for Parent+16&gt;: 0xa0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400bc0 &lt;vtable for Parent+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 ...</code> </pre> <br><blockquote>  Catatan: kita melihat karakter yang tidak dihiasi (demangled).  Jika Anda benar-benar tertarik, _ZTV adalah awalan untuk vtable, _ZTS adalah awalan untuk tipe string (nama), dan _ZTI untuk typeinfo. </blockquote><br><hr><br><p>  Berikut adalah struktur <code>vtable Parent</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x400ba8 </td><td>  0x0 </td><td>  top_offset (lebih lanjut tentang ini nanti) </td></tr><tr><td>  0x400bb0 </td><td>  0x400b78 </td><td>  Pointer untuk mengetik info untuk Induk (juga bagian dari dump memori di atas) </td></tr><tr><td>  0x400bb8 </td><td>  0x400aa0 </td><td>  Pointer to Parent :: Foo () <em>(1)</em> .  _vptr Poin induk di sini. </td></tr><tr><td>  0x400bc0 </td><td>  0x400a90 </td><td>  Pointer to Parent :: FooNotOverridden () <em>(2)</em> </td></tr></tbody></table></div><br><p>  Berikut adalah struktur yang <code>vtable Derived</code> dari <code>vtable Derived</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x400b40 </td><td>  0x0 </td><td>  top_offset (lebih lanjut tentang ini nanti) </td></tr><tr><td>  0x400b48 </td><td>  0x400b90 </td><td>  Pointer untuk mengetikkan info untuk Berasal (juga bagian dari dump memori di atas) </td></tr><tr><td>  0x400b50 </td><td>  0x400a80 </td><td>  Pointer ke Turunkan :: Foo () <em>(3)</em> ., _ Vptr Turunkan poin di sini. </td></tr><tr><td>  0x400b58 </td><td>  0x400a90 </td><td>  Pointer to Parent :: FooNotOverridden () (sama seperti Parent) </td></tr></tbody></table></div><br><p>  1: </p><br><pre> <code class="plaintext hljs">(gdb) # ,        0x400aa0 (gdb) info symbol 0x400aa0 Parent::Foo() in section .text of a.out</code> </pre> <br><p>  2: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x400a90 Parent::FooNotOverridden() in section .text of a.out</code> </pre> <br><p>  3: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x400a80 Derived::Foo() in section .text of a.out</code> </pre> <br><p>  Ingat bahwa pointer vtable di Derived menunjuk ke offset +16 byte di vtable?  Pointer ketiga adalah alamat dari pointer metode pertama.  Ingin metode ketiga?  Tidak masalah - tambahkan 2 <em>sizeof (void</em> ) ke pointer vtable.  Ingin rekam typeinfo?  pergi ke pointer di depannya. </p><br><p>  Pindah - bagaimana dengan struktur catatan typeinfo? </p><br><p>  <code>Parent</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x400b78 </td><td>  0x602090 </td><td>  Kelas pembantu untuk metode type_info <em>(1)</em> </td></tr><tr><td>  0x400b80 </td><td>  0x400b69 </td><td>  String yang mewakili nama tipe <em>(2)</em> </td></tr><tr><td>  0x400b88 </td><td>  0x0 </td><td>  0 berarti tidak ada entri typeo orangtua </td></tr></tbody></table></div><br><p>  Dan di sini adalah entri <code>typeinfo Derived</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x400b90 </td><td>  0x602210 </td><td>  Kelas pembantu untuk metode type_info <em>(3)</em> </td></tr><tr><td>  0x400b98 </td><td>  0x400b60 </td><td>  String yang mewakili nama tipe <em>(4)</em> </td></tr><tr><td>  0x400ba0 </td><td>  0x400b78 </td><td>  Pointer ke entri Induk typeinfo </td></tr></tbody></table></div><br><p>  1: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x602090 vtable for __cxxabiv1::__class_type_info@@CXXABI_1.3 + 16 in section .bss of a.out</code> </pre> <br><p>  2: </p><br><pre> <code class="plaintext hljs">(gdb) x/s 0x400b69 0x400b69 &lt;typeinfo name for Parent&gt;: "6Parent"</code> </pre> <br><p>  3: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x602210 vtable for __cxxabiv1::__si_class_type_info@@CXXABI_1.3 + 16 in section .bss of a.out</code> </pre> <br><p>  4: </p><br><pre> <code class="plaintext hljs">(gdb) x/s 0x400b60 0x400b60 &lt;typeinfo name for Derived&gt;: "7Derived"</code> </pre> <br><p>  Jika Anda ingin tahu lebih banyak tentang __si_class_type_info, Anda dapat menemukan beberapa informasi di <a href="https://refspecs.linuxfoundation.org/LSB_4.0.0/LSB-CXX-generic/LSB-CXX-generic/baselib.html">sini</a> dan juga di <a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc%2B%2B/api/a01094_source.html">sini</a> . </p><br><p>  Ini melelahkan keahlian saya dengan gdb dan juga melengkapi bagian ini.  Saya menyarankan bahwa beberapa orang menemukan ini terlalu rendah, atau mungkin hanya tidak memiliki nilai praktis.  Jika demikian, saya akan merekomendasikan melewatkan bagian 2 dan 3, langsung ke <a href="https://shaharmike.com/cpp/vtable-part4/">bagian 4</a> . </p><br><h2 id="chast-2---mnozhestvennoe-nasledovanie">  Bagian 2 - Multiple Inheritance </h2><br><p>  Dunia hierarki warisan tunggal lebih mudah bagi kompilator.  Seperti yang kita lihat di bagian pertama, setiap kelas anak memperluas vtable induk dengan menambahkan entri untuk setiap metode virtual baru. </p><br><p>  Mari kita lihat multiple inheritance, yang memperumit situasi, bahkan ketika inheritance diimplementasikan hanya murni dari interface. </p><br><p>  Mari kita lihat cuplikan kode berikut: </p><br><pre> <code class="plaintext hljs">class Mother { public: virtual void MotherMethod() {} int mother_data; }; class Father { public: virtual void FatherMethod() {} int father_data; }; class Child : public Mother, public Father { public: virtual void ChildMethod() {} int child_data; };</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Struktur anak </th></tr></thead><tbody><tr><td>  _vptr $ Ibu </td></tr><tr><td>  mother_data (+ padding) </td></tr><tr><td>  _vptr $ Ayah </td></tr><tr><td>  data ayah </td></tr><tr><td>  child_data <em>(1)</em> </td></tr></tbody></table></div><br><p>  Perhatikan bahwa ada 2 pointer vtable.  Secara intuitif, saya akan mengharapkan 1 atau 3 petunjuk (Ibu, Ayah dan Anak).  Bahkan, tidak mungkin untuk memiliki satu pointer (lebih lanjut tentang ini nanti), dan kompiler cukup pintar untuk menggabungkan entri anak vtable Anak sebagai kelanjutan dari vtable Ibu, sehingga menghemat 1 pointer. </p><br><p>  Mengapa seorang anak tidak dapat memiliki satu pointer vtable untuk ketiga jenis?  Ingat bahwa pointer Anak dapat diteruskan ke fungsi yang menerima pointer Ibu atau Ayah, dan keduanya akan mengharapkan pointer ini mengandung data yang benar di offset yang benar.  Fungsi-fungsi ini tidak perlu diketahui tentang Child, dan Anda pasti tidak boleh berasumsi bahwa Child benar-benar berada di bawah pointer Ibu / Ayah yang dengannya mereka beroperasi. </p><br><p>  <em>(1) Itu tidak relevan dengan topik ini, tetapi, bagaimanapun, menarik bahwa child_data sebenarnya ditempatkan dalam pengisian Ayah.</em>  <em>Ini disebut tail padding dan mungkin menjadi subjek posting di masa depan.</em> </p><br><p>  Berikut adalah struktur <code>vtable</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x4008b8 </td><td>  0 </td><td>  top_offset (lebih lanjut tentang ini nanti) </td></tr><tr><td>  0x4008c0 </td><td>  0x400930 </td><td>  arahkan ke ketik info untuk Anak </td></tr><tr><td>  0x4008c8 </td><td>  0x400800 </td><td>  Mother :: MotherMethod ().  _vptr $ Poin ibu di sini. </td></tr><tr><td>  0x4008d0 </td><td>  0x400810 </td><td>  Anak :: AnakMetode () </td></tr><tr><td>  0x4008d8 </td><td>  -16 </td><td>  top_offset (lebih lanjut tentang ini nanti) </td></tr><tr><td>  0x4008e0 </td><td>  0x400930 </td><td>  arahkan ke ketik info untuk Anak </td></tr><tr><td>  0x4008e8 </td><td>  0x400820 </td><td>  Father :: FatherMethod ().  _vptr $ Ayah menunjuk di sini. </td></tr></tbody></table></div><br><p>  Dalam contoh ini, turunan Child akan memiliki pointer yang sama ketika casting ke pointer Mother.  Tetapi ketika melakukan casting ke pointer Father, kompiler menghitung offset dari pointer ini untuk menunjuk ke _vptr $ Father part of the Child (bidang ke-3 di struktur Child, lihat tabel di atas). </p><br><p>  Dengan kata lain, untuk Anak tertentu c;: (void <em>) &amp; c! = (Void</em> ) static_cast &lt;Father *&gt; (&amp; c).  Beberapa orang tidak mengharapkan ini, dan mungkin suatu hari informasi ini akan menghemat waktu Anda untuk debugging. </p><br><p>  Saya menemukan ini berguna lebih dari sekali.  Tapi tunggu, itu belum semuanya. </p><br><p>  Bagaimana jika Child memutuskan untuk mengganti salah satu metode Ayah?  Pertimbangkan kode ini: </p><br><pre> <code class="plaintext hljs">class Mother { public: virtual void MotherFoo() {} }; class Father { public: virtual void FatherFoo() {} }; class Child : public Mother, public Father { public: void FatherFoo() override {} };</code> </pre> <br><p>  Situasi semakin sulit.  Fungsi dapat mengambil argumen Father * dan memanggil FatherFoo () untuk itu.  Tetapi jika Anda melewati instance Child, diharapkan memanggil metode Child yang diganti dengan pointer yang benar ini.  Namun, si penelepon tidak tahu bahwa dia benar-benar mengandung Child.  Ini memiliki pointer ke offset Anak, di mana lokasi Bapa.  Seseorang harus mengimbangi pointer ini, tetapi bagaimana cara melakukannya?  Keajaiban apa yang dilakukan kompiler untuk membuat ini bekerja? </p><br><p>  <em>Sebelum kita menjawab ini, perhatikan bahwa mengganti salah satu metode Mother tidak terlalu rumit, karena pointer ini sama.</em>  <em>Anak tahu apa yang harus dibaca setelah Ibu, dan berharap metode Anak tepat setelah itu.</em> </p><br><p>  Inilah solusinya: kompiler membuat metode thunk yang mengoreksi pointer ini dan kemudian memanggil metode "nyata".  Alamat metode adaptor akan berada di bawah vtable Father, sedangkan metode "real" akan berada di bawah vtable Child. </p><br><p>  Ini adalah <code>vtable Child</code> : </p><br><pre> <code class="plaintext hljs">0x4008e8 &lt;vtable for Child&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4008f0 &lt;vtable for Child+8&gt;: 0x60 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4008f8 &lt;vtable for Child+16&gt;: 0x00 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400900 &lt;vtable for Child+24&gt;: 0x10 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400908 &lt;vtable for Child+32&gt;: 0xf8 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400910 &lt;vtable for Child+40&gt;: 0x60 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x400918 &lt;vtable for Child+48&gt;: 0x20 0x08 0x40 0x00 0x00 0x00 0x00 0x00</code> </pre> <br><p>  Apa artinya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamatnya </th><th>  Nilai </th><th>  Isi </th></tr></thead><tbody><tr><td>  0x4008e8 </td><td>  0 </td><td>  top_offset (segera hadir!) </td></tr><tr><td>  0x4008f0 </td><td>  0x400960 </td><td>  typeinfo untuk anak </td></tr><tr><td>  0x4008f8 </td><td>  0x400800 </td><td>  Mother :: MotherFoo () </td></tr><tr><td>  0x400900 </td><td>  0x400810 </td><td>  Anak :: FatherFoo () </td></tr><tr><td>  0x400908 </td><td>  -8 </td><td>  top_offset </td></tr><tr><td>  0x400910 </td><td>  0x400960 </td><td>  typeinfo untuk anak </td></tr><tr><td>  0x400918 </td><td>  0x400820 </td><td>  bukan adaptor virtual Child :: FatherFoo () </td></tr></tbody></table></div><br><p>  Penjelasan: seperti yang kita lihat sebelumnya, Anak memiliki 2 tabel - satu digunakan untuk Ibu dan Anak, dan yang lainnya untuk Ayah.  Dalam vtable Father, FatherFoo () menunjuk ke "adaptor", dan dalam vtable Child menunjuk langsung ke Child :: FatherFoo (). </p><br><p>  Dan apa yang ada dalam "adaptor" ini, Anda bertanya? </p><br><pre> <code class="plaintext hljs">(gdb) disas /m 0x400820, 0x400850 Dump of assembler code from 0x400820 to 0x400850: 15 void FatherFoo() override {} 0x0000000000400820 &lt;non-virtual thunk to Child::FatherFoo()+0&gt;: push %rbp 0x0000000000400821 &lt;non-virtual thunk to Child::FatherFoo()+1&gt;: mov %rsp,%rbp 0x0000000000400824 &lt;non-virtual thunk to Child::FatherFoo()+4&gt;: sub $0x10,%rsp 0x0000000000400828 &lt;non-virtual thunk to Child::FatherFoo()+8&gt;: mov %rdi,-0x8(%rbp) 0x000000000040082c &lt;non-virtual thunk to Child::FatherFoo()+12&gt;: mov -0x8(%rbp),%rdi 0x0000000000400830 &lt;non-virtual thunk to Child::FatherFoo()+16&gt;: add $0xfffffffffffffff8,%rdi 0x0000000000400837 &lt;non-virtual thunk to Child::FatherFoo()+23&gt;: callq 0x400810 &lt;Child::FatherFoo()&gt; 0x000000000040083c &lt;non-virtual thunk to Child::FatherFoo()+28&gt;: add $0x10,%rsp 0x0000000000400840 &lt;non-virtual thunk to Child::FatherFoo()+32&gt;: pop %rbp 0x0000000000400841 &lt;non-virtual thunk to Child::FatherFoo()+33&gt;: retq 0x0000000000400842: nopw %cs:0x0(%rax,%rax,1) 0x000000000040084c: nopl 0x0(%rax)</code> </pre> <br><p>  Seperti yang telah kita bahas, ini offset dan FatherFoo () dipanggil.  Dan berapa banyak yang harus kita ubah untuk mendapatkan Anak?  top_offset! </p><br><p>  <em>Harap dicatat bahwa saya pribadi menemukan nama thunk non-virtual sangat membingungkan karena ini adalah entri tabel virtual untuk fungsi virtual.</em>  <em>Saya tidak yakin bahwa ini bukan virtual, tetapi ini hanya pendapat saya.</em> </p><br><hr><br><p>  <em>Itu saja untuk saat ini, dalam waktu dekat kami akan menerjemahkan 3 dan 4 bagian.</em>  <em>Ikuti beritanya!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479802/">https://habr.com/ru/post/id479802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479780/index.html">DevOps Moscow Meetup 17/12: bergabung dengan siaran</a></li>
<li><a href="../id479790/index.html">Tiga Inkubator mengadakan kursus prototipe untuk kelompok siswa pertama</a></li>
<li><a href="../id479794/index.html">Kami menggabungkan mikrokontroler "anak-anak" dan permainan papan</a></li>
<li><a href="../id479796/index.html">Ancaman Tingkat Thanos Kingston</a></li>
<li><a href="../id479800/index.html">Saya menulis dalam C # sehingga front-end lebih mudah</a></li>
<li><a href="../id479810/index.html">Bagaimana saya menerbitkan artikel sains di Nature</a></li>
<li><a href="../id479814/index.html">Masalah Privasi Data Direktori Aktif</a></li>
<li><a href="../id479816/index.html">Combinatorics dengan Python</a></li>
<li><a href="../id479818/index.html">Cara menilai kecakapan berbahasa Inggris</a></li>
<li><a href="../id479820/index.html">Apa yang harus diletakkan di bawah pohon IT? Jam biner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>