<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔔 🏕️ 🚽 Ist Haskell wirklich die Sprache der Genies und der Wissenschaft? ™️ 😪 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich hatte einmal eine Diskussion mit einem Gründer eines israelischen Startups, der eine GPU-basierte Datenbank mit Schwerpunkt auf Geschwindigkeit en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist Haskell wirklich die Sprache der Genies und der Wissenschaft?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441350/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Ich hatte einmal eine Diskussion mit einem Gründer eines israelischen Startups, der eine GPU-basierte Datenbank mit Schwerpunkt auf Geschwindigkeit entwickelte.  Der Arbeitsstapel umfasste unter anderem Haskell und C ++, und der Gründer beschwerte sich darüber, wie schwierig es ist, kompetente Programmierer zu finden.  Das war einer der Gründe, warum er nach Moskau kam. <br><br>  Ich fragte sorgfältig, ob sie erwägen, etwas Populäreres und Neues zu verwenden.  Und obwohl die Antwort eher höflich und mit Argumenten untermauert war, klang sie immer noch wie „Komm schon, bring nicht einmal diese Spielsachen zur Sprache“. <br><br>  Bis dahin konnte alles, was ich über Haskell hörte, als „SEHR vorsichtig im Umgang damit“ zusammengefasst werden.  Um die Haskell-Programmierer besser kennenzulernen, kam ich zu einem aktuellen Telegramm-Chat mit einigen Fragen.  Anfangs hatte ich große Angst, und wie sich herausstellte, hatte ich recht. <br><br>  Haskell eignet sich nicht für populäre Erklärungen, und die Leute versuchen es anscheinend nicht einmal.  Wenn das Thema jemals angesprochen wird, wird es nur ausführlich und so objektiv wie möglich besprochen.  Jemand schrieb mir: „Eines der bestimmenden Merkmale von Haskell selbst und seiner Community ist, dass sie nicht versucht haben, irgendeine Art von Mainstream-Anerkennung zu erreichen.  Stattdessen konzentrierten sie sich darauf, einen logischen, prinzipiellen Weg zur Lösung realer Probleme zu finden, indem versucht wurde, ein möglichst breites Publikum zu beschwichtigen. “ <br><br>  Trotzdem haben mir einige Leute von ihren Erfahrungen erzählt, die unten gezeigt werden. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Nolane</a> )</b> : Als ich auf dem College war, haben sie mir angeboten, einen Coursera-Kurs auf Haskell zu machen, um zusätzliche Credits zu erhalten.  Dann hatten wir auch einen funktionalen Programmierkurs, der Haskell beinhaltete.  Ich habe eine meiner Hausarbeiten sowie die Abschlussarbeit über GHC geschrieben.  Dann fand ich einen Job als Haskell-Programmierer. <br><br>  Es war und ist schwer.  Wenn Sie anfangen, Haskell zu lernen, müssen Sie viele neue Konzepte in Ihren Kopf stecken.  Es ist, als würde man wieder von Grund auf lernen, Code zu schreiben. <br><br>  Menschen neigen dazu, ihre früheren Erinnerungen zu vergessen (oder zu glätten): wie wenn sie Schwierigkeiten hatten zu verstehen, was ein „Zeiger“, eine „Funktion“ oder eine „Klasse“ ist.  Vielleicht fällt es ihnen deshalb so schwer, Haskell zu lernen: Mit zunehmendem Alter wird es schwieriger, neue Dinge zu lernen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Nachdem ich meine Probezeit bei einem Job wegen eines Redux-Fuckups nicht bestanden hatte, habe ich versucht, mich ein bisschen besser damit vertraut zu machen, indem ich mir Videos von seinem Schöpfer angesehen habe.  Zuerst habe ich in JavaScript geübt, dann habe ich etwas über Haskell gelernt, das als die „wahre“ funktionale Sprache gilt.  Ich war fasziniert von seinen einzigartigen Konzepten und wie ordentlich es war. <br><br>  Tutorials sind jedoch nicht allzu benutzerfreundlich, und ihr zwingender Hintergrund verhindert, dass neue Konzepte entstehen. <br><br>  <b>Yuri Syrovetskiy ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">cblp</a> )</b> : Das <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Schwierigste</a></b> ist, Haskell als Ihre zweite Sprache zu lernen, wenn die Erinnerungen an das Erlernen der ersten noch frisch sind. <br><br><h2>  Was ist gut und schlecht an Haskell? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Es ist prägnant, elegant und flexibel.  Kein Wunder, dass die Hälfte der Bibliotheken auf EDSL ist (oder zumindest so fühlt es sich an). <br><br>  <b>Yuri Syrovetskiy</b> : Es ist (subjektiv) einfach, Ihre Gedanken an Code anzupassen. Es besteht ein ausgewogenes <b>Verhältnis</b> zwischen imperativen und funktionalen Paradigmen.  Das Erstellen von Abstraktionen von Daten und Algorithmen ist recht einfach, sodass Sie über die jeweilige Aufgabe nachdenken können, ohne sich von kleinen Ärgernissen ablenken zu lassen. <br><br>  <b>John Doe</b> : Strenge, starke (sogar faschistische, würde ich sagen) Typisierung. <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">interphx</a> )</b> : Ein großartiges <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Typensystem</a></b> .  Es ist nicht so mächtig wie in Idris oder Agda, erreicht aber dennoch den bequemen Mittelpunkt, an dem Sie fast alles beschreiben können, und dennoch funktioniert die Typinferenz gut.  Sie müssen sie nicht jedes Mal manuell markieren. <br><br>  Ein leistungsstarkes Typsystem zwingt Sie jedoch dazu, den übertragenen Werten mehr Aufmerksamkeit zu schenken.  Eine Reihe von Typdefinitionen könnte wie ein Boilerplate aussehen.  Jeder Befehl hat einen eigenen oder gar keinen Erweiterungssatz.  Der Code ist „dichter“ - jede Zeichenfolge enthält häufig mehr Informationen als in anderen Sprachen, sodass es für einen unerfahrenen Entwickler schwieriger ist, sie zu lesen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wenn Sie Haskell lernen, werden Sie wahrscheinlich auf dieses Sprichwort <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">stoßen</a></b> : "Wenn es kompiliert wird, ist es wahrscheinlich richtig."  Null existiert nicht, das Funktionsparadigma selbst ist sehr streng und hält Sie innerhalb bestimmter Richtlinien, die in den meisten Fällen zu einem besseren Design führen. <br><br>  Zum Beispiel hat Haskell keine Variablen - nur Konstanten.  Sie müssen nicht verfolgen, was wo zugewiesen ist.  Haskell bietet Anreize für die Verwendung von „reinen“ Funktionen, die keine Nebenwirkungen haben.  Das funktionale Design zwingt das Programm dazu, als Ganzes zu arbeiten, im Gegensatz zu objektorientierten Sprachen, in denen viele Objekte versuchen, mithilfe dieser Nebenwirkungen miteinander zu kommunizieren, was die App in ein unvorhersehbares Chaos verwandelt.  Wir haben dies in C # und Unity bei der Arbeit sehr gelitten. <br><br>  <b>Denis Mirzoev</b> : Wenn die Sprache von Natur aus „faul“ ist, ist sie im Allgemeinen ausdrucksvoller.  Algorithmen werden einfacher.  Wenn keine Zwischenergebnisse verwendet werden, wird die Leistung erheblich gesteigert. <br><br>  <b>Igor Shevnin</b> : Die „Faulheit“ hilft oft, aber wenn die Reihenfolge der Funktionsaufrufe wichtig ist, ist es manchmal sehr schwer zu verstehen, was los ist. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wenn es stimmt, ist es wahrscheinlich ziemlich schnell. <br><br>  <b>Denis Mirzoev</b> : In <b>Bezug auf die</b> Leistung ist es vergleichbar mit Java, aber nicht so schnell wie C. <br><br>  <b>Igor Shevnin</b> : Es bietet <b>sofort</b> Erweiterungsunterstützung, mit der Sie die Sprache und das <b>Typensystem</b> nach Ihren Wünschen anpassen können.  Es gibt viele Erweiterungen, die von der Community häufig verwendet werden und anständige Beispiele und Dokumentationen enthalten. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Standard-Prelude-Bibliothek hat viele schlechte Funktionen wie read, head, readFile, die eine Ausnahme auslösen und die App zum Absturz bringen können, anstatt Vielleicht zurückzugeben.  Also muss ich Alternativen verwenden oder meine eigenen schreiben. <br><br>  <b>Igor Shevnin</b> : Das größte Problem ist der Mangel an Standards, bis zu dem Punkt, an dem viele Leute die Standardbibliothek durch eine der Alternativen ersetzen, die in keiner Weise miteinander kompatibel sind.  Die Aufteilung der Community in das, was die Standardbibliothek sein sollte, was in der Kerndistribution enthalten sein muss und was auf Erweiterungen verlagert werden kann ... Meiner Meinung nach behindert dies die Entwicklung der Sprache. <br><br>  <b>Denis Mirzoev</b> : Es fehlen Tools: Es gibt keine richtige IDE, nur sehr wenige Leistungsbenchmarks, kein "schrittweises" Debugging - es ist ein grundlegendes Problem. <br><br><h2>  Für welche Projekte ist Haskell am besten geeignet? </h2><br>  <b>YS</b> : Für komplexe, sicherheits- und finanzbezogene Aufgaben, bei denen Fehler teuer sind. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Für alles, wo Sie rechnen, konvertieren und analysieren müssen.  Ich bin überrascht, dass Haskell in Data Science-Anwendungen weniger beliebt ist als Python. <br><br>  <b>IS</b> : Ich würde nicht riskieren, es für eingebettete Systeme (es ist schnell, aber es gibt immer noch erheblichen Speicheraufwand aufgrund von "faulem" Computing) oder kleine Skripte (wo seine strenge Natur nicht benötigt wird) zu verwenden.  Es ist auch wichtig zu verstehen, wie schwierig es ist, Entwickler im Vergleich zu Mainstream-Sprachen zu finden. <br><br>  <b>John Doe</b> : Zum Schreiben von Industriecode, der von anderen gelesen wird, benötigen Sie jedoch ein ganzes Team von Haskell-Entwicklern.  Es gibt nicht viele von ihnen. <br><br>  <b>IS</b> : Aber dank seiner prägnanten und strengen Natur können Sie Haskell für fast alles verwenden. <br><br><h2>  Ist es eine gute Idee, Ihre Entwicklungskarriere bei Haskell zu beginnen? </h2><br>  <b>IS</b> : Wahrscheinlich nicht, da die überwiegende Mehrheit der Codebasen, mit denen ein Entwickler arbeiten muss, nicht darauf geschrieben ist. <br><br>  <b>John Doe</b> : Schlechte Idee!  Nicht-ML-Sprachen - das ist fast alles in industriellen Anwendungen - wären ein Schock für Sie. <br><br>  <b>DS</b> : Oft lernen die Leute zuerst Mathematik und wechseln später zur Programmierung.  Theoretisch sollte das Erlernen einer Sprache, die viele mathematische Konzepte erfordert (algebraische Datentypen, reine Funktionen), einfacher sein als zwingende Sprachen.  Ich denke es ist eine gute Idee. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Alle Rookie-Entwickler, mit denen ich zusammenarbeite, <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">stelle</a></b> ich zuerst Haskell vor.  Menschen, die nicht über das Gepäck des imperativen Stils verfügen, lernen Funktionscode viel schneller, und selbst wenn sie später mit objektorientierten Sprachen arbeiten, verwenden sie häufig gute Architekturlösungen, weil sie an sie gewöhnt sind. <br><br>  <b>YS</b> : Es ist am besten, mit ein paar grundlegend unterschiedlichen Sprachen zu beginnen, zum Beispiel C, Haskell und Smalltalk, in beliebiger Reihenfolge.  Keine Sprache kann Ihnen ein umfassendes Verständnis der Landschaft vermitteln. <br><br><h2>  Haskell ist eine ziemlich alte Sprache.  Ist es gut oder schlecht? </h2><br>  <b>YS</b> : Die Sprache wird sehr aktiv entwickelt, sie belastet die Abwärtskompatibilität nicht. <br><br>  <b>John Doe</b> : Es wurde 1998 standardisiert, aber Sie werden es nicht bemerken: Bis heute gibt es ungefähr alle 6 Monate eine neue Compiler-Version, die möglicherweise die Abwärtskompatibilität beeinträchtigen kann. <br><br>  <b>DS</b> : Haskell ist nicht alt, es hat sich einfach bewährt.  Es führt (und wird) niemals sinnlose Veränderungen ein.  Es ist also wahrscheinlich gut für die Gesundheit der Gemeinde. <br><br><h2>  Es wird oft gesagt, dass Haskell eine der am schwierigsten zu erlernenden Sprachen ist.  Ist es wirklich? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Als Sprache selbst - nein.  Der schwierigste Teil sind die verwendeten Abstraktionen.  Eine Person, die noch nie einen Haskell-Code gesehen hat, könnte durch die Menge neuer Informationen und seltsamer Anweisungen verrückt werden.  Was nicht hilft, ist, dass die Sprache viele Dinge „einschränkt“, die nicht zu ihrem Funktionskonzept passen. <br><br>  <b>John Doe</b> : Ich habe zwei Monate Schlafenszeitlehrbücher, Handbücher und Tutorials gebraucht, um mein erstes Projekt zu kompilieren.  Nach der endgültigen Kompilierung funktionierte es ein halbes Jahr lang unter Volllast (6.000 RPS-Durchschnitt, mit 15.000 Spitzen) ohne Änderungen. <br><br>  <b>DS</b> : Ich wette, wenn Sie einem College-Studenten Haskell als Muttersprache geben und er damit weit kommt, würde die zwingende Programmierung für ihn kompliziert und weniger intuitiv aussehen. <br><br>  <b>IS</b> : Es ist alles relativ.  Von den gängigen Sprachen halte ich C ++ für die schwierigste.  Theorembeweisende Sprachen (wie Agda oder Coq) sind konzeptionell schwieriger als Haskell.  Haskell ist keine harte Sprache, aber es braucht Zeit, um seine Muster und Bibliotheken (sowohl Standard- als auch Drittanbieter-Sprachen) zu lernen. <br><br><h2>  Ist seine Komplexität gerechtfertigt? </h2><br>  <b>IS</b> : Muster und ein hohes Abstraktionsniveau sind gerechtfertigt, da dadurch Code kürzer und langlebiger wird.  Aber ich denke, Operatoren, Funktionsnamen und viele andere Dinge hätten etwas benutzerfreundlicher sein können. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Oft ermöglicht Ihnen die Komplexität von Haskell, sehr kurze, flexible und modulare Lösungen zu <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">erstellen</a></b> . <br><br>  <b>YS</b> : Ich würde sagen, nur die Effektkontrolle ist ein bisschen wackelig, obwohl sie fast immer keiner Kontrolle vorzuziehen ist.  Und es gibt ein laufendes Projekt, um es einfacher zu machen. <br><br>  <b>John Doe</b> : Für Leute, die an Python / PHP / was auch immer gewöhnt sind, fühlt sich Haskell von der Realität verdrängt.  Für diejenigen, die sich noch nicht für die Theorie der Kategorien interessiert haben, ist es sehr schwer, von Grund auf neu zu lernen.  Aber wenn Sie es verstehen, finden Sie einen neuen Ansatz zur Lösung eines Problems. <br><br><h2>  Es wird oft gesagt, Haskell sei keine Sprache für Entwickler, sondern für Mathematiker.  Ist das der Grund, warum es nicht Mainstream ist? </h2><br>  <b>DS</b> : Es zeigt die Hauptidee der Hauptentwickler von Haskell: „Vermeiden Sie Erfolg um jeden Preis“.  Das bedeutet nicht "Erfolg vermeiden", sondern "Erfolg zu teuer vermeiden". <br><br>  Sie hätten Haskell populär machen können.  Beispielsweise unterstützt Microsoft die Sprache.  Sie hätten es zwingender machen und die Starrheit für die Popularität opfern können.  Es gibt viele schmutzige Tricks, die sie hätten anwenden können, aber nie gemacht haben. <br><br>  Sicher, die Sprache ist nicht beliebt, aber das bedeutet, dass die Qualität nicht darunter leidet.  Die Vorteile von Haskell im Vergleich zu imperativen Sprachen liegen für mich auf der Hand und seine Probleme können alle gelöst werden. Ich glaube, dass es später populär wird. <br><br>  <b>YS</b> : Nur Leute, die nichts darüber wissen, sagen es.  Haskell wird häufig in der "realen" Entwicklung verwendet. Sie könnten wahrscheinlich Beispiele in Ihrer bevorzugten Suchmaschine finden.  Insbesondere sind wir bei Kaspersky Labs sehr zufrieden mit Haskell und würden es nicht gegen etwas anderes eintauschen. <br><br>  <b>IS</b> : Was ist die Sprache eines Mathematikers?  Es ist entweder R / MatLab / Mathematica, das speziell für Statistiken und Berechnungen entwickelt wurde, oder Python, weil es einfacher ist und nicht so viel technischen Hintergrund erfordert.  Aber nicht Haskell.  Es hat Sachen aus der Algebra, wie Monoide, aber es hat praktische Anwendung. <br><br>  Der Grund, warum C / C ++ / Java so beliebt ist, liegt darin, dass sie im Unternehmensbereich historisch sehr verbreitet waren.  Sie füllten eine Nische.  Aber heutzutage beginnen viele Unternehmen, Haskell und andere funktionale Sprachen zu verwenden. <br><br><h2>  Mit welchem ​​PL würden Sie Haskell vergleichen? </h2><br>  <b>John Doe</b> : Von den populären, wahrscheinlich mit Erlang.  Aber Erlang ist einfacher zu lernen und zu schreiben. <br><br>  <b>DS</b> : Ich kenne C, C ++, Java und Haskell.  C ++ ist schrecklich und kann mit nichts verglichen werden.  C eignet sich hervorragend für die Entwicklung auf niedriger Ebene.  In allen anderen Anwendungen würde ich Haskell bevorzugen. <br><br>  Die Wahl zwischen Java und Haskell ist schwieriger, hängt jedoch von der Anwendung ab.  Zum Beispiel ist Java für Android besser, aber in Serveranwendungen sind sie fast gleich.  Wenn die Umgebung - Tools, Bibliotheken - dies zulässt, wähle ich häufig Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Ich vergleiche mit C #.  Nur Google "How to Do Vielleicht in C # und Haskell".  Es ist seltsam, dass sich eine so streng funktionale Sprache wie Haskell viel flexibler und freier anfühlt.  Aber in Wirklichkeit sind sie die polaren Gegensätze. <br><br>  C # ist eine der objektorientiertesten Sprachen, und ihre Vorteile stehen im Gegensatz zu Haskell.  C # zwingt Sie immer dazu, viele zusätzliche Dinge zu schreiben, was den Code verlangsamt und ihn oft weniger elegant macht.  Nach Haskells kurzen und ordentlichen Lösungen ist es schwierig, zurück zu gehen. <br><br>  <b>IS</b> : Mit Rust und bisher gewinnt Rust wahrscheinlich.  Es nimmt viel von Haskell und anderen funktionalen Sprachen, kombiniert aber funktionale und zwingende Ansätze, und die Entwickler haben die Entwicklung viel intelligenter gehandhabt. <br><br><h2>  Wie ist Ihre Meinung zur Haskell-Community? </h2><br>  <b>John Doe</b> : Die überwiegende Mehrheit der Menschen ist sehr freundlich und hilfsbereit, was einen schönen Kontrast zu vielen anderen Sprachen darstellt. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Haskell-Gemeinschaften sind oft voller schrecklich kluger Leute.  Lokale Memes über Doktoranden und Hochschulen existieren aus einem bestimmten Grund.  In anderen Communities diskutieren die Leute meistens über regelmäßige Produktionsprobleme und Datenstrukturen, während in einem Haskell-Chat über Monaden, anwendbare Funktoren, verrückte Typen und ähnliches gesprochen wird. <br><br>  Sie lernen immer etwas, woran Sie noch nie gedacht haben. <br><br><h2>  Es wird gesagt, dass Haskell-Entwickler zu voll von sich sind.  Ist es wahr </h2><br>  <b>DS</b> : Ja.  Ich habe das Gefühl, es liegt daran, dass sie ihre Sprache wirklich mögen und enttäuscht sind, wie unbeliebt sie ist. <br><br>  <b>John Doe</b> : Nichts dergleichen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Leute sagen wahrscheinlich, dass viele Mainstream-Entwickler, die sich über einen Haskellisten ärgern, über funktionale Programmierung und ihre Vorteile sprechen.  Der Haskellist ärgert sich unterdessen darüber, dass niemand auf ihn hört und Terminologie herumwirft, und wird daher als „voll von sich selbst“ bezeichnet. <br><br>  <b>IS</b> : Es ist ein bisschen hart, sie so zu nennen.  Dies liegt wahrscheinlich daran, dass funktionale Programmierung, OOP, Unterschiede zwischen OOP-Klassen und Unionstypen, das Erweiterungsproblem und viele andere Definitionen langsam zu einem zusammenhängenden Bild werden und es dann schwierig ist, Menschen zu verstehen, die die heiligen Kriege von OOP gegen FP fortsetzen. <br><br><h2>  Warum sind FP-Sprachen so nisch? </h2><br>  <b>DS</b> : Ihre Vorteile reichen nicht aus, um Programmierer zu interessieren.  Schwer zu lernen hilft auch nichts.  Werkzeugprobleme schrecken auch die Leute ab, obwohl dieses Problem wahrscheinlich gelöst würde, wenn mehr Leute interessiert wären.  Es ist ein Teufelskreis. <br><br>  <b>IS</b> : Nun, FP-Konzepte dringen langsam in andere Sprachen ein ... <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Grundprinzipien von FP und seinen Sprachen sind bereits ziemlich weit verbreitet.  Sogar Sharp hat Linq und einige andere ähnliche Bibliotheken.  Aber rein funktionale Sprachen haben wahrscheinlich einfach zu viele neuartige Konzepte, um populär zu sein. <br><br>  Vergessen Sie nicht, dass die Hardware vor 20 Jahren noch nicht schnell genug war, um mit funktionalen Sprachen umzugehen, sodass sie erst vor kurzem in den Mainstream eingetreten ist und Haskell selbst nur wächst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441350/">https://habr.com/ru/post/de441350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441338/index.html">Wie wir ein Kryptowährungs-Zahlungssystem erstellt haben: fünf Hauptprobleme</a></li>
<li><a href="../de441340/index.html">Das kulturelle Erbe Kasachstans in 3D-Modellen</a></li>
<li><a href="../de441344/index.html">Treten Sie in den Himmel. Eine ehrliche Geschichte über eine ernsthafte Leidenschaft für das Fallschirmspringen</a></li>
<li><a href="../de441346/index.html">Treffen Sie einen Content-Strategen: Ein Interview mit Dmitry Kabanov, Kurator von Techstars Startup Digest und SXSW-Berater</a></li>
<li><a href="../de441348/index.html">Direktes Routing und Balancing mit NFT vs Nginx</a></li>
<li><a href="../de441352/index.html">CI / CD-Muster und Anti-Muster. Teil 2</a></li>
<li><a href="../de441356/index.html">Wie verstehe ich den "fremden" Code und trete einem neuen Team bei?</a></li>
<li><a href="../de441358/index.html">Startete den ersten kommerziellen Beresheet-Mondlander</a></li>
<li><a href="../de441360/index.html">Openshift - Red-Hat-Handwerk</a></li>
<li><a href="../de441362/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>