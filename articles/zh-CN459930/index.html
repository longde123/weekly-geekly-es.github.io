<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘 🤱🏾 🧑🏽 Python导入自动化 🤦🏼 🙅🏼 🍅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="到  之后 

import math import os.path import requests # 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get)  

 imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python导入自动化</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459930/"><div class="scrollable-table"><table><tbody><tr><th> 到 </th><th> 之后 </th></tr><tr><td><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment"># 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get)</span></span></code> </pre> </td><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> smart_imports smart_imports.all() print(math.pi) print(os_path.join(<span class="hljs-string"><span class="hljs-string">'my'</span></span>, <span class="hljs-string"><span class="hljs-string">'path'</span></span>)) print(requests.get)</code> </pre></td></tr></tbody></table></div> 碰巧的是，自2012年以来，我一直在开发开放源代码浏览器，是唯一的程序员。 本身就是Python。 浏览器并不是最简单的事情，现在在项目的主要部分中，有1000多个模块和12万多行Python代码。 总体而言，卫星项目将增加一倍半。 <br><br> 在某个时候，我已经厌倦了在每个文件的开头弄乱导入层，我决定一劳永逸地解决这个问题。 因此<b>smart_imports</b>库诞生了（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pypi</a> ）。 <br><br> 这个想法很简单。 任何复杂的项目最终都会在命名所有内容时形成自己的协议。  <b>如果将此协议转换为更正式的规则，则可以通过与其关联的变量的名称自动导入任何实体。</b> <br><br> 例如，您无需编写<code>import math</code>即可访问<code>math.pi</code>我们<code>math.pi</code>了解，在这种情况下， <code>math</code>是标准库的模块。 <br><br> 智能导入支持Python&gt; = 3.5。该库完全受测试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖率&gt; 95％</a> 。 我已经使用一年了。 <br><br> 有关详细信息，我邀请您加入Cat。 <br><a name="habracut"></a><br><h2> 一般如何运作？ </h2><br> 因此，标题图片中的代码如下所示： <br><br><ol><li> 在调用<code>smart_imports.all()</code>库将构建从其进行调用<abbr title="抽象语法树">的</abbr>模块的<abbr title="抽象语法树">AST</abbr> ； </li><li> 查找未初始化的变量； </li><li> 我们通过一系列规则来运行每个变量的名称，这些规则试图找到按名称导入所需的模块（或模块属性）。 如果规则已找到所需的实体，则不会检查以下规则。 </li><li> 找到的模块将被加载，初始化并放置在全局名称空间中（或这些模块的必要属性放置在此处）。 </li></ol><br> 未初始化的变量在整个代码中进行搜索，包括新语法。 <br><br> 仅对显式调用<code>smart_imoprts.all()</code>那些项目组件启用自动导入。 此外，智能进口的使用并不禁止使用常规进口。 这使您可以逐步实现库，并解决复杂的循环依赖性。 <br><br> 细心的读者会注意到AST模块被构造了两次： <br><br><ul><li>  CPython在模块导入期间首次构建它。 </li><li>  smart_imports第二次在调用<code>smart_imports.all()</code>期间构建它。 </li></ul><br>  AST实际上只能构建一次（为此，您需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP-0302中</a>实现的导入挂钩集成到模块的导入过程中，但是此解决方案会减慢导入速度。 <br><br><div class="spoiler">  <b class="spoiler_title">你为什么这么认为？</b> <div class="spoiler_text"> 比较两个实现（带有和不带有钩子）的性能，我得出的结论是，导入模块时，CPython在其内部（C-shh）数据结构中构建AST。 将它们转换为Python数据结构比使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ast</a>模块从源构建树要贵。 <br></div></div><br> 当然，每个模块的AST每次构建和分析一次。 <br><br><h2> 默认导入规则 </h2><br> 无需额外配置即可使用该库。 默认情况下，它根据以下规则导入模块： <br><br><ol><li> 通过名称的完全一致，它将搜索当前模块（在同一目录中）旁边的模块。 </li><li> 检查标准库的模块： <br><ul><li> 完全匹配顶级软件包的名称； </li><li> 对于嵌套的软件包和模块，请检查化合物名称，并用下划线替换点。 例如，如果存在<code>os_path</code>变量，则将导入<code>os.path</code> 。 </li></ul></li><li> 通过名称的完全匹配，它将搜索已安装的第三方程序包。 例如，众所周知的包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">request</a> 。 </li></ol><br><h2> 性能表现 </h2><br> 智能导入不会影响程序的性能，但是会增加启动时间。 <br><br> 由于AST的重建，首次运行的时间增加了约1.5–2倍。 对于小型项目，这并不重要。 在大型项目中，启动时间受模块之间依赖关系的影响，而不是特定模块的导入时间。 <br><br>  <s>当</s>智能导入变得流行时，我将工作从AST重写为C-这将大大降低启动成本。 <br><br> 为了加快加载速度，可以将AST模块的处理结果缓存在文件系统上。 在配置中启用了缓存。 当然，更改源时将禁用缓存。 <br><br> 启动时间受模块搜索规则列表及其顺序的影响。 由于某些规则使用标准的Python功能来搜索模块。 您可以通过使用“自定义名称”规则明确指出名称和模块的对应关系来排除这些费用（请参见下文）。 <br><br><h2> 构型 </h2><br> 默认配置已在前面进行了描述。 在小型项目中使用标准库就足够了。 <br><br><div class="spoiler">  <b class="spoiler_title">默认配置</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_local_modules"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_stdlib"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_predefined_names"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_global_modules"</span></span>}] }</code> </pre> <br></div></div><br> 如有必要，可以在文件系统上放置更复杂的配置。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复杂配置的示例</a> （来自浏览器）。 <br><br> 在调用<code>smart_import.all()</code>库将确定调用模块在文件系统上的位置，并开始在从当前目录到根的方向上查找<code>smart_imports.json</code>文件。 如果找到了这样的文件，则将其视为当前模块的配置。 <br><br> 您可以使用几个不同的配置（将它们放在不同的目录中）。 <br><br> 现在没有很多配置选项： <br><br><pre> <code class="json hljs">{ //     AST. //     null —   . <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>|<span class="hljs-string"><span class="hljs-string">"string"</span></span>, //       . <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [] }</code> </pre> <br><h2> 导入规则 </h2><br> 在配置中指定规则的顺序决定了它们的应用顺序。 第一条可行的规则停止了对进口的进一步搜索。 <br><br> 在配置示例中，rule_predefined_names规则通常会出现<code>rule_predefined_names</code> ，有必要正确识别内置函数（例如<code>print</code> ）。 <br><br><h3> 规则1：预定义名称 </h3><br> 该规则允许您忽略诸如<code>__file__</code>类的预定义名称和诸如<code>print</code>类的内置函数。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}] # } import smart_imports smart_imports.all() #        __file__ #        print(__file__)</span></span></code> </pre> </div></div><br><h3> 规则2：本地模块 </h3><br> 检查当前模块旁边（在同一目录中）是否存在具有指定名称的模块。 如果有，请导入。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules"}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- b.py # b.py import smart_imports smart_imports.all() #    "a.py" print(a)</span></span></code> </pre> </div></div><br><h3> 规则3：全局模块 </h3><br> 尝试直接按名称导入模块。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求</a>模块。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_global_modules"}] # } # #    # # pip install requests import smart_imports smart_imports.all() #    requests print(requests.get('http://example.com'))</span></span></code> </pre> </div></div><br><h3> 规则4：自定义名称 </h3><br> 对应于特定模块的名称或其属性。 符合性在规则配置中指示。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_custom", # "variables": {"my_import_module": {"module": "os.path"}, # "my_import_attribute": {"module": "random", "attribute": "seed"}}}] # } import smart_imports smart_imports.all() #       #        print(my_import_module) print(my_import_attribute)</span></span></code> </pre> </div></div><br><h3> 规则5：标准模块 </h3><br> 检查名称是否为标准库模块。 例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">math</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">os.path</a> ，它们会转换为<code>os_path</code> 。 <br><br> 它比导入全局模块的规则更快，因为它检查缓存列表中模块是否存在。 每个版本的Python的列表都来自这里： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/jackmaney/python-stdlib-list</a> <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_stdlib"}] # } import smart_imports smart_imports.all() print(math.pi)</span></span></code> </pre> </div></div><br><h3> 规则6：按前缀导入 </h3><br> 通过名称从与其前缀关联的包中导入模块。 当在整个代码中使用多个软件包时，使用起来很方便。 例如，可以使用<code>utils_</code>前缀访问<code>utils</code>软件包模块。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_prefix", # "prefixes": [{"prefix": "utils_", "module": "my_package.utils"}]}] # } # #    : # # my_package # |-- __init__.py # |-- utils # |-- |-- __init__ # |-- |-- a.py # |-- |-- b.py # |-- subpackage # |-- |-- __init__ # |-- |-- c.py # c.py import smart_imports smart_imports.all() print(utils_a) print(utils_b)</span></span></code> </pre> </div></div><br><h3> 规则7：父包中的模块 </h3><br> 如果在项目的不同部分中有相同名称的子包（例如， <code>tests</code>或<code>migrations</code> ），则可以允许它们搜索要在父包中按名称导入的模块。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_parent", # "suffixes": [".tests"]}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- tests # |-- |-- __init__ # |-- |-- b.py # b.py import smart_imports smart_imports.all() print(a)</span></span></code> </pre> </div></div><br><h3> 规则8：绑定到另一个软件包 </h3><br> 对于来自特定程序包的模块，它允许按名称搜索其他程序包中的导入（在配置中指定）。 就我而言，当我不想将前一个规则（父包中的模块）的工作扩展到整个项目时，该规则很有用。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_namespace", # "map": {"my_package.subpackage_1": ["my_package.subpackage_2"]}}] # } # #    : # # my_package # |-- __init__.py # |-- subpackage_1 # |-- |-- __init__ # |-- |-- a.py # |-- subpackage_2 # |-- |-- __init__ # |-- |-- b.py # a.py import smart_imports smart_imports.all() print(b)</span></span></code> </pre> </div></div><br><h3> 添加自己的规则 </h3><br> 添加自己的规则非常简单： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们</a>从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">smart_imports.rules.BaseRule</a>类<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继承</a> 。 </li><li> 我们意识到必要的逻辑。 </li><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">smart_imports.rules.register</a>方法注册规则 </li><li> 将规则添加到配置中。 </li><li>  ??? </li><li> 获利 </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在当前规则</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施中</a>可以找到一个例子<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br><h2> 获利 </h2><br> 每个来源开头的多行导入清单已消失。 <br><br> 行数减少了。 在浏览器切换到智能导入之前，它有6688行负责导入。 过渡之后，剩下的2084个（每个文件两行smart_imports + 130行导入，分别从函数和类似位置显式调用）。 <br><br> 一个不错的好处是项目中名称的标准化。 代码变得更易于阅读和编写。 无需考虑导入实体的名称-有一些易于遵循的明确规则。 <br><br><h2> 发展计划 </h2><br> 我喜欢通过变量名定义代码属性的想法，因此我将尝试在智能导入和其他项目中进行开发。 <br><br> 关于智能进口，我计划： <br><br><ol><li> 添加对新版本Python的支持。 </li><li> 探索在代码类型注释上依赖当前社区实践的可能性。 </li><li> 探索进行懒惰进口的可能性。 </li><li> 实现实用程序，以从源代码自动生成配置并使用smart_imports重构源。 </li><li> 重写部分C代码以加快AST的工作。 </li><li> 如果在没有显式导入的情况下存在代码分析问题，则可以与linter和IDE进行集成。 </li></ol><br> 此外，我对您对库和导入规则的默认行为感兴趣。 <br><br> 感谢您压制此文本表：-D </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459930/">https://habr.com/ru/post/zh-CN459930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459914/index.html">SQL Index Manager-用于整理和维护索引的免费工具</a></li>
<li><a href="../zh-CN459918/index.html">使用pwnable.kr 03-BOF解决问题 堆栈上的缓冲区溢出</a></li>
<li><a href="../zh-CN459922/index.html">在轴承振动诊断过程中消除振动传感器信号中的高频噪声</a></li>
<li><a href="../zh-CN459924/index.html">完整的React测试周期。 Auto.ru报告</a></li>
<li><a href="../zh-CN459928/index.html">学生的移动应用开发之路</a></li>
<li><a href="../zh-CN459934/index.html">＃306移动开发人员的有趣材料摘要（7月8日至14日）</a></li>
<li><a href="../zh-CN459936/index.html">使用Visual Studio的9种技巧</a></li>
<li><a href="../zh-CN459948/index.html">像Horizo​​n Zero Dawn一样实现物理上正确的体积云</a></li>
<li><a href="../zh-CN459952/index.html">关于备份和存储的一点经验</a></li>
<li><a href="../zh-CN459954/index.html">为什么最大的IT公司之一加入CNCF-开发云基础架构的基金</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>