<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèª üë©üèª‚Äçüè´ ‚úàÔ∏è O que voc√™ precisa esperar para criar estrat√©gias de negocia√ß√£o na bolsa: qu√£o eficiente √© o aprendizado de m√°quina üå± üëõ üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em nosso blog sobre Habr√©, publicamos tradu√ß√µes adaptadas de materiais do blog The Financial Hacker, dedicadas a quest√µes de cria√ß√£o de estrat√©gias de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que voc√™ precisa esperar para criar estrat√©gias de negocia√ß√£o na bolsa: qu√£o eficiente √© o aprendizado de m√°quina</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/412639/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/pq/lc/zm/pqlczmojlxuisfxberyvpnismeu.png"></a> <br><br>  Em nosso blog sobre Habr√©, publicamos tradu√ß√µes adaptadas de materiais do blog The Financial Hacker, dedicadas a quest√µes de cria√ß√£o de estrat√©gias de negocia√ß√£o na bolsa.  Discutimos anteriormente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">busca por inefici√™ncias do mercado</a> , a cria√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos de estrat√©gias de negocia√ß√£o</a> e os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princ√≠pios de sua programa√ß√£o</a> .  Hoje vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nos concentrar</a> no uso de abordagens de aprendizado de m√°quina para melhorar a efici√™ncia dos sistemas de negocia√ß√£o. <br><br>  O primeiro computador a vencer o Campeonato Mundial de Xadrez foi o Deep Blue.  Isso foi em 1996, e outros vinte anos se passaram antes que outro programa, Alpha Go, conseguisse derrotar o melhor jogador de Go.  Deep Blue era um sistema orientado a modelos com regras de xadrez embutidas.  AplhaGo √© um sistema de minera√ß√£o de dados, uma rede neural profunda, treinada usando milhares de jogos no Go.  Ou seja, para dar um passo nas vit√≥rias sobre as pessoas que s√£o campe√£s no xadrez, para dominar os melhores jogadores de Go, era necess√°rio n√£o um peda√ßo de ferro aprimorado, mas uma inova√ß√£o no campo do software. <br><br>  No artigo atual, consideraremos a aplica√ß√£o da abordagem de minera√ß√£o de dados para criar estrat√©gias de negocia√ß√£o.  Esse m√©todo n√£o leva em considera√ß√£o os mecanismos de mercado, simplesmente verifica as curvas de pre√ßos e outras fontes de dados para procurar padr√µes preditivos.  O aprendizado de m√°quina ou "intelig√™ncia artificial" nem sempre √© necess√°rio para isso.  Pelo contr√°rio, muitas vezes, os m√©todos mais populares e lucrativos de minera√ß√£o de dados funcionam sem frescuras na forma de redes neurais ou suporte a m√©todos vetoriais. <a name="habracut"></a><br><br><h2>  Princ√≠pios de aprendizado de m√°quina </h2><br>  O algoritmo treinado √© alimentado com amostras de dados, geralmente extra√≠das de alguma forma a partir dos pre√ßos de c√¢mbio hist√≥ricos.  Cada amostra consiste em n vari√°veis ‚Äã‚Äãx1 ... xn, que geralmente s√£o chamadas de preditores, fun√ß√µes, sinais ou, mais simplesmente, dados de entrada.  Esses preditores podem ser os pre√ßos das √∫ltimas n barras no gr√°fico de pre√ßos ou um conjunto de valores de indicadores cl√°ssicos ou qualquer outra fun√ß√£o da curva de pre√ßos (h√° casos em que pixels individuais do gr√°fico de pre√ßos s√£o usados ‚Äã‚Äãcomo preditores para uma rede neural!).  Cada amostra tamb√©m geralmente cont√©m uma determinada vari√°vel de destino y, por exemplo, o resultado da pr√≥xima transa√ß√£o ap√≥s analisar a amostra ou o pr√≥ximo movimento de pre√ßo. <br><br>  Na literatura, y √© freq√ºentemente chamado de r√≥tulo ou objetivo.  No processo de aprendizagem, o algoritmo aprende a prever o alvo y com base nos preditores x1 ... xn.  O que o sistema ‚Äúlembra‚Äù no processo √© armazenado em uma estrutura de dados chamada modelo que √© espec√≠fico para um algoritmo espec√≠fico (√© importante n√£o confundir esse conceito com um modelo financeiro ou estrat√©gia orientada a modelo).  Um modelo de aprendizado de m√°quina pode ser fun√ß√µes com regras de previs√£o escritas usando o c√≥digo C gerado pelo processo de aprendizado.  Ou poderia ser um conjunto de pesos relacionados √† rede neural: <br><br><blockquote>  Treinamento: x1 ... xn, y =&gt; modelo <br><br>  Previs√£o: x1 ... xn, model =&gt; y <br></blockquote><br>  Preditores, fun√ß√µes ou o que voc√™ quiser cham√°-los, devem conter informa√ß√µes suficientes para gerar previs√µes sobre o valor do destino y com uma certa precis√£o.  Eles tamb√©m devem atender a dois crit√©rios formais.  Primeiro, todos os valores do preditor devem estar no mesmo intervalo, por exemplo, -1 ... +1 (para a maioria dos algoritmos em R) ou -100 ... +100 (para algoritmos nas linguagens de script Zorro ou TSSB).  Portanto, antes de enviar dados para o sistema, voc√™ precisa normaliz√°-los.  Em segundo lugar, as amostras devem ser equilibradas, ou seja, distribu√≠das uniformemente sobre os valores da vari√°vel de destino.  Ou seja, voc√™ deve ter o mesmo n√∫mero de amostras que levam a um resultado positivo e perder conjuntos.  Se esses dois requisitos n√£o forem seguidos, bons resultados n√£o ser√£o bem-sucedidos. <br><br>  Os algoritmos de regress√£o geram previs√µes sobre valores num√©ricos, como magnitude ou o sinal do pr√≥ximo movimento de pre√ßo.  Os algoritmos de classifica√ß√£o prev√™em classes quantitativas de amostras, por exemplo, se precedem o lucro ou a perda de fundos.  Alguns algoritmos, como redes neurais, √°rvores de decis√£o ou m√©todos de vetores de suporte, podem ser executados nos dois modos. <br><br>  Tamb√©m existem algoritmos que podem aprender a extrair amostras de classe sem a necessidade de um destino y.  Isso √© chamado de aprendizado n√£o supervisionado, em oposi√ß√£o ao aprendizado supervisionado.  Em algum lugar entre esses dois m√©todos est√° localizado o "aprendizado por refor√ßo", no qual o sistema treina executando simula√ß√µes com fun√ß√µes especificadas e usa o resultado como um objetivo.  Um seguidor do AlphaGo, um sistema chamado AlphaZero, utilizava o aprendizado refor√ßado, jogando um milh√£o de jogos de Go sozinho.  Em finan√ßas, esses sistemas ou produtos que usam aprendizado n√£o supervisionado s√£o extremamente raros.  99% dos sistemas usam aprendizado supervisionado. <br><br>  Quaisquer que sejam os sinais que usamos para preditores em finan√ßas, na maioria dos casos, eles conter√£o muito ru√≠do e poucas informa√ß√µes e, al√©m disso, ser√£o inst√°veis.  Portanto, a previs√£o financeira √© uma das tarefas mais dif√≠ceis do aprendizado de m√°quina.  Algoritmos mais complexos aqui alcan√ßam melhores resultados.  A sele√ß√£o de preditores √© fundamental para o sucesso.  N√£o necessariamente deve haver muitos deles, pois isso leva a reciclagem e mau funcionamento.  Portanto, as estrat√©gias de minera√ß√£o de dados geralmente usam um algoritmo pr√©-selecionado que extrai um pequeno n√∫mero de preditores de um pool maior.  Essa sele√ß√£o preliminar pode ser baseada na correla√ß√£o entre preditores, seu significado, riqueza de informa√ß√µes ou simplesmente o sucesso / fracasso do uso da su√≠te de testes.  Experimentos pr√°ticos com a sele√ß√£o de alvos podem ser encontrados, por exemplo, no blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Robot Wealth</a> . <br><br>  Abaixo est√° uma lista dos m√©todos mais populares de minera√ß√£o de dados usados ‚Äã‚Äãno campo das finan√ßas. <br><br><h2>  1. Sopa de indicadores </h2><br>  A maioria dos sistemas de negocia√ß√£o n√£o se baseia em modelos financeiros.  Frequentemente, os comerciantes precisam apenas de sinais de negocia√ß√£o gerados por determinados indicadores t√©cnicos, que s√£o filtrados por outros indicadores em combina√ß√£o com indicadores t√©cnicos adicionais.  Ao perguntar a um profissional sobre como essa confus√£o de indicadores pode levar a algum tipo de lucro, ele geralmente responde algo como: "Acredite em mim, troco minhas m√£os e tudo funciona". <br><br>  E √© verdade.  Pelo menos algumas vezes.  Embora a maioria desses sistemas n√£o seja aprovada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teste WFA</a> (e alguns simplesmente testam dados hist√≥ricos), um n√∫mero surpreendentemente grande desses sistemas funciona e gera lucro.  O autor do blog Financial Hacker est√° envolvido no desenvolvimento de sistemas de negocia√ß√£o personalizados e conta a hist√≥ria de um dos clientes que experimentou sistematicamente os indicadores t√©cnicos at√© encontrar uma combina√ß√£o que funcione para certos tipos de ativos.  Esse m√©todo de tentativa e erro √© uma abordagem cl√°ssica da minera√ß√£o de dados. Para obter sucesso, voc√™ s√≥ precisa dele, sorte e muito dinheiro para testes.  Como resultado, √†s vezes voc√™ pode contar com um sistema lucrativo. <br><br><h2>  2. Padr√µes de Candlestick </h2><br>  N√£o deve ser confundido com os padr√µes de velas existentes h√° centenas de anos.  O equivalente moderno dessa abordagem √© o com√©rcio baseado em movimentos de pre√ßos.  Voc√™ tamb√©m analisa os indicadores aberto, alto, baixo e fechado para cada vela no gr√°fico.  Mas agora voc√™ est√° usando a minera√ß√£o de dados para analisar as velas da curva de pre√ßos e destacar padr√µes que podem ser usados ‚Äã‚Äãpara gerar previs√µes sobre a dire√ß√£o do movimento dos pre√ßos no futuro. <br><br>  Existem pacotes de software completos para esse fim.  Eles procuram padr√µes rent√°veis ‚Äã‚Äãem termos de crit√©rios definidos pelo usu√°rio e os utilizam para criar uma fun√ß√£o de detec√ß√£o de padr√µes.  Tudo isso pode ser algo como isto: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Essa fun√ß√£o C retorna 1 quando o sinal corresponde a um dos padr√µes, caso contr√°rio, retorna 0. O c√≥digo longo parece sugerir que essa n√£o √© a maneira mais r√°pida de procurar padr√µes.  √â melhor usar uma abordagem na qual a fun√ß√£o de detec√ß√£o n√£o precise ser exportada, mas pode classificar os sinais por sua import√¢ncia e classific√°-los.  Um exemplo desse sistema pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no link</a> . <br><br>  O com√©rcio a um pre√ßo pode funcionar?  Como no caso anterior, esse m√©todo n√£o se baseia em nenhum modelo financeiro racional.  Ao mesmo tempo, todos entendem que realmente certos eventos no mercado podem afetar seus participantes, como resultado dos quais surgem padr√µes preditivos de curto prazo.  Mas o n√∫mero de tais padr√µes n√£o pode ser grande se voc√™ estudar apenas a sequ√™ncia de v√°rias velas consecutivas no gr√°fico.  Voc√™ precisar√° comparar o resultado com os dados das velas, que n√£o est√£o pr√≥ximas, mas, pelo contr√°rio, s√£o selecionadas aleatoriamente por um per√≠odo mais longo.  Nesse caso, voc√™ obter√° um n√∫mero quase ilimitado de padr√µes - e romper√° com sucesso os conceitos de realidade e racionalidade.  √â dif√≠cil imaginar como o pre√ßo futuro pode ser previsto com base em alguns de seus valores na semana passada.  Apesar disso, muitos comerciantes trabalham nessa dire√ß√£o. <br><br><h2>  3. Regress√£o linear </h2><br>  Uma base simples para muitos algoritmos complexos de aprendizado de m√°quina: prever a vari√°vel de destino y usando uma combina√ß√£o linear de preditores x1 ... xn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="imagem"><br><br>  Probabilidades - este √© o modelo.  Eles s√£o calculados para minimizar a soma dos desvios quadr√°ticos entre os valores reais de y, os valores de treinamento e os y previstos de acordo com a f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc7/06c/d46/bc706cd46620a7d8682eb18e16daeeda.png" alt="imagem"><br><br>  Para amostras distribu√≠das normalmente, a minimiza√ß√£o √© poss√≠vel usando opera√ß√µes de matriz, portanto, n√£o s√£o necess√°rias itera√ß√µes.  No caso em que n = 1 - com apenas um preditor x, a f√≥rmula de regress√£o √© reduzida para: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/a79/e98/adca79e98f1193be9b631dbfe51dbc96.png" alt="imagem"><br><br>  - isto √©, antes de uma regress√£o linear simples, e quando n&gt; 1, a regress√£o linear ser√° multivariada.  A regress√£o linear simples est√° dispon√≠vel na maioria das plataformas de negocia√ß√£o, por exemplo, o indicador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LinReg</a> no TA-Lib.  Quando y = pre√ßo ex = tempo, ele pode ser usado como uma alternativa √†s m√©dias m√≥veis.  Na plataforma R, essa regress√£o √© implementada pela fun√ß√£o de entrega padr√£o lm (..).  Tamb√©m pode ser representado por regress√£o polinomial.  Como no caso mais simples, aqui usamos uma vari√°vel preditiva x, mas tamb√©m seus graus quadrado e subsequente, ent√£o xn == xn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/248/b3c/bd4/248b3cbd40c637b1a15376d227432e81.png" alt="imagem"><br><br>  Se n = 2 ou n = 3, a regress√£o polinomial √© frequentemente usada para prever o pr√≥ximo pre√ßo m√©dio dos pre√ßos suavizados das √∫ltimas barras.  Para a regress√£o polinomial, a fun√ß√£o polyfit do MatLab, R, Zorro e muitas outras plataformas pode ser usada. <br><br><h2>  4. Perceptron </h2><br>  Muitas vezes, √© chamada de rede neural com apenas um neur√¥nio.  De fato, o perceptron √© uma fun√ß√£o de regress√£o, como descrito acima, mas com um resultado bin√°rio, como resultado do qual √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regress√£o log√≠stica</a> .  Embora, em geral, isso n√£o seja uma regress√£o, mas um algoritmo de classifica√ß√£o.  Por exemplo, a fun√ß√£o de aviso (PERCEPTRON, ...) da estrutura Zorro gera c√≥digo C que retorna 100 ou -100 dependendo se o resultado previsto √© limiar ou n√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre> <br>  Como voc√™ pode ver, a matriz sig √© equivalente √†s fun√ß√µes xn na f√≥rmula de regress√£o, e os coeficientes a s√£o os fatores digitais. <br><br><h2>  5. Redes neurais </h2><br>  A regress√£o linear ou log√≠stica pode resolver apenas problemas lineares.  Ao mesmo tempo, as tarefas de negocia√ß√£o geralmente n√£o se enquadram nessa categoria.  Um exemplo famoso √© a previs√£o da sa√≠da de uma fun√ß√£o XOR simples.  Isso tamb√©m inclui a previs√£o de lucro das transa√ß√µes.  Uma rede neural artificial (RNA) pode resolver problemas n√£o lineares.  Este √© um conjunto de perceptrons que est√£o conectados a uma matriz de diferentes n√≠veis.  Cada perceptron √© um neur√¥nio da rede.  Sua sa√≠da se torna entrada para outros neur√¥nios do seguinte n√≠vel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/d12/c5d/050d12c5da82f4f97fdd942d7777b8e4.png" alt="imagem"><br><br>  Como o perceptron, a rede neural √© treinada determinando coeficientes que minimizam o erro entre a previs√£o e o alvo na amostra.  Isso requer um processo de aproxima√ß√£o, geralmente com a propaga√ß√£o reversa do erro da sa√≠da para a entrada com a otimiza√ß√£o dos pesos ao longo do caminho.  Este processo tem duas limita√ß√µes.  Primeiro, a sa√≠da dos neur√¥nios deve ser uma fun√ß√£o continuamente diferenci√°vel, em vez de um limiar simples para o perceptron.  Em segundo lugar, a rede n√£o deve ser muito profunda - a presen√ßa de um grande n√∫mero de n√≠veis ocultos de neur√¥nios entre os dados de entrada e sa√≠da apenas prejudica.  Essa segunda limita√ß√£o limita a complexidade dos problemas que uma rede neural padr√£o pode resolver. <br><br>  Ao usar redes neurais para prever transa√ß√µes, voc√™ ter√° muitos par√¢metros que podem ser manipulados, os quais, se feitos incorretamente, podem resultar na apar√™ncia do vi√©s de sele√ß√£o: <br><br><ul><li>  n√∫mero de n√≠veis ocultos; </li><li>  o n√∫mero de neur√¥nios em cada n√≠vel oculto; </li><li>  o n√∫mero de ciclos de retropropaga√ß√£o - √©pocas; </li><li>  grau de treinamento, largura da etapa da √©poca; </li><li>  momento, fator de in√©rcia para adapta√ß√£o dos pesos; </li><li>  fun√ß√£o de ativa√ß√£o. </li></ul><br>  A fun√ß√£o de ativa√ß√£o emula o limiar de perceptron.  Para propaga√ß√£o de retorno, voc√™ precisa de uma fun√ß√£o constantemente diferenci√°vel que gere uma etapa suave para um determinado valor de x.  Normalmente, fun√ß√µes sigm√≥ides, tanh ou softmax s√£o usadas para isso.  √Äs vezes, √© usada uma fun√ß√£o linear que retorna a soma ponderada de todos os dados de entrada.  Nesse caso, a rede pode ser usada para regress√£o, previs√£o de valores num√©ricos em vez de sa√≠da bin√°ria. <br><br>  As redes neurais est√£o inclu√≠das na entrega de pacotes padr√£o do R (por exemplo, nnet √© uma rede com um n√≠vel oculto), assim como em muitos outros pacotes (como RSNNS e FCNN4R). <br><br><h2>  6. Aprendizagem profunda </h2><br>  Os m√©todos de aprendizado profundo usam redes neurais com muitos n√≠veis ocultos e milhares de neur√¥nios que n√£o podem ser efetivamente treinados usando propaga√ß√£o simples das costas.  Nos √∫ltimos anos, v√°rios m√©todos se tornaram populares para o treinamento de redes t√£o grandes.  Eles geralmente envolvem pr√©-treinamento de n√≠veis ocultos de neur√¥nios para aumentar a efic√°cia do aprendizado b√°sico. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> M√°quina de Boltzmann Restrita (RBM) √© um algoritmo de classifica√ß√£o n√£o controlado com uma estrutura de rede especial na qual n√£o h√° conex√µes entre neur√¥nios ocultos.  O Sparse Auto Encoder (SAE) usa a estrutura de rede usual, mas pr√©-treina os n√≠veis ocultos de uma maneira espec√≠fica, reproduzindo sinais de entrada nos n√≠veis de sa√≠da com o m√≠nimo de conex√µes ativas poss√≠vel.  Esses m√©todos permitem implementar redes muito complexas para resolver problemas de aprendizado muito complexos.  Por exemplo, a tarefa de derrotar a melhor pessoa jogando Go. <br><br>  As redes de aprendizado profundo est√£o inclu√≠das nos pacotes deepnet e darch para R. Deepnet inclui o codificador autom√°tico e darch inclui a m√°quina Boltzmann.  Abaixo est√° um exemplo de c√≥digo que usa deepnet com tr√™s n√≠veis ocultos para processar sinais de negocia√ß√£o por meio da fun√ß√£o neor () da estrutura Zorro: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(50,100,50), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre> <br><h2>  7. Vetores de suporte </h2><br>  Como nas redes neurais, o m√©todo do vetor de suporte √© outra extens√£o da regress√£o linear.  Se voc√™ olhar para a f√≥rmula de regress√£o novamente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="imagem"><br><br>  Ent√£o, podemos interpretar as fun√ß√µes xn como as coordenadas de um espa√ßo n-dimensional.  Definir a vari√°vel de destino y com um valor fixo determinar√° o plano nesse espa√ßo - ser√° chamado de hiperplano, porque na verdade ter√° dois (at√© n-1) tamanhos.  O hiperplano separa as amostras com y&gt; 0 daquelas onde y &lt;0. Os coeficientes an podem ser calculados como o caminho que separa o plano das amostras mais pr√≥ximas - seus vetores de suporte, da√≠ o nome do algoritmo.  Assim, obtemos um classificador bin√°rio com a separa√ß√£o ideal de amostras vencedoras e perdedoras. <br><br>  Problema: geralmente essas amostras n√£o podem ser divididas linearmente - elas s√£o agrupadas aleatoriamente em um espa√ßo de fun√ß√£o.  √â imposs√≠vel tra√ßar um plano suave entre as op√ß√µes vencedoras e perdedoras; se isso puder ser feito, m√©todos simples como a an√°lise discriminante linear podem ser usados ‚Äã‚Äãpara calcul√°-lo.  Mas, no caso geral, voc√™ pode usar o truque: adicione mais tamanhos ao espa√ßo.  Nesse caso, o algoritmo do vetor de suporte poder√° gerar mais par√¢metros com uma fun√ß√£o nuclear que combina dois preditores - semelhante √† transi√ß√£o da regress√£o simples para o polin√¥mio.  Quanto mais tamanhos voc√™ adicionar, mais f√°cil ser√° dividir as amostras com um hiperplano.  Em seguida, pode ser convertido novamente no espa√ßo n-dimensional original. <br><br>  Como redes neurais, vetores de refer√™ncia podem ser usados ‚Äã‚Äãn√£o apenas para classifica√ß√£o, mas tamb√©m para regress√£o.  Eles tamb√©m oferecem v√°rias op√ß√µes para otimiza√ß√£o e poss√≠vel reciclagem: <br><br><ul><li>  Fun√ß√£o do kernel - o kernel RBF (fun√ß√£o de base radial, kernel sim√©trico) √© normalmente usado, mas outros kernels podem ser selecionados, por exemplo, sigm√≥ide, polinomial e linear. </li><li>  Gama - largura do n√∫cleo RBF. </li><li>  Par√¢metro de custo C, ‚Äúpenalidade‚Äù por classifica√ß√µes incorretas de amostras de treinamento. </li></ul><br>  A biblioteca libsvm √© frequentemente usada, dispon√≠vel no pacote e1071 para R. <br><br><h2>  8. Algoritmo de k-vizinhos mais pr√≥ximos </h2><br>  Comparado com o pesado RNA e SVM, este √© um algoritmo simples e agrad√°vel, com uma propriedade exclusiva: ele n√£o precisa ser treinado.  As amostras ser√£o o modelo.  Esse algoritmo pode ser usado para um sistema de negocia√ß√£o que est√° sendo constantemente treinado, adicionando novas amostras.  Este algoritmo calcula as dist√¢ncias no espa√ßo de fun√ß√µes do valor atual at√© as amostras k-mais pr√≥ximas.  A dist√¢ncia no espa√ßo n-dimensional entre os dois conjuntos (x1 ... xn) e (y1 ... yn) √© calculada pela f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/322/2bc/66e3222bce4b5e79d460e20b612eadcb.png" alt="imagem"><br><br>  O algoritmo simplesmente prediz o alvo a partir da m√©dia de k vari√°veis-alvo das amostras mais pr√≥ximas, ponderadas pelas dist√¢ncias de retorno.  Pode ser usado para classifica√ß√£o e regress√£o.  Para prever os vizinhos mais pr√≥ximos, voc√™ pode chamar a fun√ß√£o knn em R ou escrever o c√≥digo C para esse fim. <br><br><h2>  9. meios K </h2><br>  Este √© um algoritmo de aproxima√ß√£o para classifica√ß√£o n√£o controlada.  √â um pouco semelhante ao algoritmo anterior.  Para classificar amostras, o algoritmo primeiro coloca k pontos aleat√≥rios no espa√ßo de fun√ß√µes.  Em seguida, ele atribui a um desses pontos todas as amostras com a menor dist√¢ncia.  Ent√£o o ponto muda para o meio desses valores mais pr√≥ximos.  Isso gera novas liga√ß√µes de amostra, pois algumas delas agora estar√£o mais pr√≥ximas de outros pontos.  O processo √© repetido at√© que a refer√™ncia novamente, como resultado do deslocamento dos pontos, pare, ou seja, at√© que cada ponto seja m√©dio para as amostras mais pr√≥ximas.  Agora, temos k classes de amostra, cada uma localizada pr√≥xima a um ponto-k. <br><br>  Esse algoritmo simples pode produzir resultados surpreendentemente bons.  Em R, a fun√ß√£o kmeans √© usada para implement√°-la; um exemplo do algoritmo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no link</a> . <br><br><h2>  10. Naive Bayes </h2><br>  Esse algoritmo usa o teorema bayesiano para classificar amostras de fun√ß√µes n√£o num√©ricas (eventos), como os padr√µes de vela mencionados acima.  Suponha que o evento X (por exemplo, o par√¢metro Open da barra anterior abaixo do par√¢metro Open da barra atual) apare√ßa em 80% das amostras vencedoras.  Ent√£o, qual ser√° a probabilidade de ganhar a amostra na presen√ßa do evento X nela?  Isso n√£o √© 0,8 como voc√™ imagina.  Essa probabilidade √© calculada pela f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/e4e/7ab/727e4e7abb69e9b8ef5334558a753a70.png" alt="imagem"><br><br>  P (Y | X) √© a probabilidade de que o evento Y (lucro) ocorra em todas as amostras que cont√™m o evento X (em nosso exemplo, Open (1) &lt;Open (0)).  De acordo com a f√≥rmula, √© igual √† probabilidade de ocorr√™ncia do evento X em todas as amostras vencedoras (no nosso caso, 0,8), multiplicada pela probabilidade Y em todas as amostras (aproximadamente 0,5 se voc√™ seguir as dicas para balancear amostras) e dividida pela probabilidade de ocorr√™ncia de X em todas as amostras. <br><br>  Se somos ing√™nuos e assumimos que todos os eventos de X s√£o independentes um do outro, podemos calcular a probabilidade total de que a amostra estar√° ganhando simplesmente multiplicando as probabilidades P (X | vencedoras) de cada evento X. Chegamos √† seguinte f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c54/d51/7b0c54d515098b06b54e7446d9097954.png" alt="imagem"><br><br>  Com fator de escala s.  Para que uma f√≥rmula funcione, as fun√ß√µes devem ser escolhidas de forma a serem t√£o independentes quanto poss√≠vel.  Isso ser√° um obst√°culo ao uso de Bayes ing√™nuo para negocia√ß√£o.  Por exemplo, dois eventos Close (1) &lt;Close (0) e Open (1) &lt;Open (0) provavelmente n√£o s√£o independentes um do outro.  Preditores num√©ricos podem ser convertidos em eventos dividindo o n√∫mero em intervalos separados.  Naive Bayes est√° dispon√≠vel no pacote e1071 para R. <br><br><h2>  11. √Årvores de decis√£o e regress√£o </h2><br>  Tais √°rvores preveem o resultado de valores num√©ricos com base em uma cadeia de decis√£o no formato sim / n√£o na estrutura dos galhos das √°rvores.  Cada decis√£o representa a presen√ßa ou aus√™ncia de eventos (no caso de valores n√£o num√©ricos) ou a compara√ß√£o de valores com um limite fixo.  Uma fun√ß√£o t√≠pica da √°rvore, gerada, por exemplo, pela estrutura Zorro, tem a seguinte apar√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre> <br>  Como essa √°rvore √© obtida de um conjunto de amostras?  Pode haver v√°rios m√©todos para isso, incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a entropia informacional de Shannon</a> . <br><br>  As √°rvores de decis√£o podem ser amplamente utilizadas.  Por exemplo, eles s√£o adequados para gerar previs√µes mais precisas do que as obtidas com redes neurais ou vetores de refer√™ncia.  No entanto, esta n√£o √© uma solu√ß√£o universal.  O algoritmo mais conhecido desse tipo √© C5.0, dispon√≠vel no pacote C50 para R. <br><br>  Para melhorar ainda mais a qualidade das previs√µes, voc√™ pode usar conjuntos de √°rvores - elas s√£o chamadas de floresta aleat√≥ria.  Esse algoritmo est√° dispon√≠vel nos pacotes R chamados randomForest, ranger e Rborist. <br><br><h2>  Conclus√£o </h2><br>  Existem muitos m√©todos de minera√ß√£o de dados e aprendizado de m√°quina.  A quest√£o cr√≠tica aqui √© a seguinte: quais s√£o as melhores estrat√©gias baseadas em modelo ou de aprendizado de m√°quina?  N√£o h√° d√∫vida de que o aprendizado de m√°quina tem v√°rias vantagens.  Por exemplo, voc√™ n√£o precisa se preocupar com a microestrutura do mercado, a economia, levar em considera√ß√£o a filosofia dos participantes do mercado ou outras coisas semelhantes.  Voc√™ pode se concentrar em matem√°tica pura.  O aprendizado de m√°quina √© uma maneira muito mais elegante e atraente de criar sistemas de negocia√ß√£o.  Por seu lado, todas as vantagens, exceto uma - al√©m das hist√≥rias nos f√≥runs dos traders, o sucesso desse m√©todo nas negocia√ß√µes reais √© dif√≠cil de rastrear. <br><br>  Quase toda semana, novos artigos s√£o publicados sobre negocia√ß√£o usando o aprendizado de m√°quina.  Esses materiais devem ser tomados com uma quantidade razo√°vel de ceticismo.  Alguns autores afirmam taxas fant√°sticas de ganho de 70%, 80% ou at√© 85%.  No entanto, poucas pessoas dizem que voc√™ pode perder dinheiro, mesmo que as previs√µes estejam ganhando.  Uma precis√£o de 85% geralmente se traduz em um indicador de rentabilidade acima de 5 - se tudo fosse t√£o simples, os criadores desse sistema j√° se tornariam bilion√°rios.  No entanto, por algum motivo, a reprodu√ß√£o dos mesmos resultados simplesmente repetindo os m√©todos descritos nos artigos falha. <br><br>  Comparado aos sistemas baseados em modelo, existem muito poucos sistemas de aprendizado de m√°quina bem-sucedidos.  Por exemplo, eles raramente s√£o usados ‚Äã‚Äãpor fundos de hedge bem-sucedidos.  Talvez no futuro, quando o poder da computa√ß√£o se tornar ainda mais acess√≠vel, algo mudar√°, mas, por enquanto, os algoritmos de aprendizado profundo continuam sendo mais um hobby interessante para os geeks do que uma ferramenta de fazer dinheiro na bolsa. <br><br><h2>  Outros materiais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relacionados ao</a> mercado financeiro e de a√ß√µes da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">An√°lise e an√°lises de mercado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">De volta ao futuro: verificando o desempenho de um rob√¥ de negocia√ß√£o usando dados hist√≥ricos</a> </li><li>  Backtest de Python orientado a eventos passo a passo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412639/">https://habr.com/ru/post/pt412639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412625/index.html">Como encontrar rapidamente e n√£o perder especialistas em IA e Ci√™ncia de Dados</a></li>
<li><a href="../pt412627/index.html">Exposi√ß√£o Internacional CMEF & ICMD 2018 Primavera em Xangai (Parte 2)</a></li>
<li><a href="../pt412629/index.html">Forma de onda adapt√°vel para o seu servi√ßo de √°udio</a></li>
<li><a href="../pt412633/index.html">Experi√™ncia em configurar e usar o WSL (subsistema Linux no Windows 10)</a></li>
<li><a href="../pt412637/index.html">Fazer ou n√£o redesenhar logotipos? Essa √© a quest√£o</a></li>
<li><a href="../pt412641/index.html">O que a minera√ß√£o, a Ge√≥rgia e o Irkutsk t√™m em comum?</a></li>
<li><a href="../pt412643/index.html">Como integramos o sistema de pagamentos ao projeto russo</a></li>
<li><a href="../pt412645/index.html">Objeto, propriedade, atividade: modelos e m√©todos de sua constru√ß√£o</a></li>
<li><a href="../pt412647/index.html">Novas evid√™ncias para a exist√™ncia do nono planeta</a></li>
<li><a href="../pt412649/index.html">Como construir uma equipe e processos focados no crescimento r√°pido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>