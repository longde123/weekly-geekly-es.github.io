<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé™ ü•ö „äóÔ∏è Aceleramos o agendador Tokio dez vezes üëÜüèø üê• ü§öüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estamos preparando a pr√≥xima vers√£o principal do Tokio, um ambiente de tempo de execu√ß√£o ass√≠ncrono para o Rust. Em 13 de outubro, uma solicita√ß√£o de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aceleramos o agendador Tokio dez vezes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472242/"> Estamos preparando a pr√≥xima vers√£o principal do Tokio, um ambiente de tempo de execu√ß√£o ass√≠ncrono para o Rust.  Em 13 de outubro, uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicita√ß√£o de pool</a> com um agendador de tarefas completamente reescrito foi emitida para mesclagem em uma filial.  O resultado ser√£o enormes melhorias de desempenho e lat√™ncia reduzida.  Alguns testes registraram uma acelera√ß√£o de dez vezes!  Como sempre, testes sint√©ticos n√£o refletem benef√≠cios reais na realidade.  Portanto, tamb√©m verificamos como as altera√ß√µes no agendador afetavam tarefas reais, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hyper</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tonic</a> (spoiler: o resultado √© maravilhoso). <br><br>  Preparando-me para trabalhar em um novo planejador, passei um tempo pesquisando recursos tem√°ticos.  Al√©m das implementa√ß√µes reais, nada de especial foi encontrado.  Tamb√©m descobri que o c√≥digo-fonte para implementa√ß√µes existentes √© dif√≠cil de navegar.  Para consertar isso, tentamos escrever o sheduler do Tokio da maneira mais limpa poss√≠vel.  Espero que este artigo detalhado sobre a implementa√ß√£o do agendador ajude aqueles que est√£o na mesma posi√ß√£o e, sem sucesso, √† procura de informa√ß√µes sobre este t√≥pico. <br><br>  O artigo come√ßa com uma revis√£o de alto n√≠vel do design, incluindo pol√≠ticas de captura de trabalho.  Depois, mergulhe nos detalhes de otimiza√ß√µes espec√≠ficas no novo planejador Tokio. <br><a name="habracut"></a><br>  Otimiza√ß√µes consideradas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Novo std :: future task system</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escolhendo o melhor algoritmo de fila</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Simplifique modelos de mensagens</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Captura do acelerador</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reduza a sincroniza√ß√£o entre threads</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reduza a aloca√ß√£o de mem√≥ria</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Contagem at√¥mica reduzida de links</a> </li></ul><br>  Como voc√™ pode ver, o tema principal √© "redu√ß√£o".  Afinal, o c√≥digo mais r√°pido √© a sua falta! <br><br>  Tamb√©m falaremos sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teste do novo agendador</a> .  √â muito dif√≠cil escrever o c√≥digo paralelo correto, sem bloqueios.  √â melhor trabalhar devagar, mas corretamente, do que rapidamente, mas com falhas, principalmente se os erros estiverem relacionados √† seguran√ßa da mem√≥ria.  A melhor op√ß√£o, no entanto, deve funcionar rapidamente e sem erros, por isso escrevemos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tear</a> , uma ferramenta de teste de simultaneidade. <br><br>  Antes de mergulhar no t√≥pico, quero agradecer: <br><br><ul><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@withoutboats</a></b> e outros que trabalharam na fun√ß√£o <code>async / await</code> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aguardada</a></b> no Rust.  Voc√™ fez um √≥timo trabalho.  Este √© um recurso matador. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@cramertj</a></b> e outros que desenvolveram <code>std::task</code> .  Esta √© uma grande melhoria em rela√ß√£o ao que era antes.  E um √≥timo c√≥digo. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flutuante</a></b> , o criador do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linkerd</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> mais importante, o meu empregador.  Obrigado por me deixar gastar tanto tempo neste trabalho.  Se algu√©m estiver interessado na malha de servi√ßo, d√™ uma olhada no Linkerd.  Em breve, incluir√° todos os benef√≠cios discutidos neste artigo. <br></li><li>  <b><a href="">Escolha</a></b> uma implementa√ß√£o t√£o boa do planejador. </li></ul><br>  Tome uma x√≠cara de caf√© e sente-se.  Este ser√° um artigo longo. <br><br><h1>  Como os planejadores funcionam? </h1><br>  A tarefa do sheduler √© planejar o trabalho.  O aplicativo √© dividido em unidades de trabalho, que chamaremos de <i>tarefas</i> .  Uma tarefa √© considerada execut√°vel quando pode avan√ßar em sua execu√ß√£o, mas n√£o est√° mais conclu√≠da ou no modo inativo, quando est√° bloqueada em um recurso externo.  As tarefas s√£o independentes no sentido de que qualquer n√∫mero de tarefas pode ser executado simultaneamente.  O planejador √© respons√°vel pela execu√ß√£o de tarefas em um estado de execu√ß√£o at√© que retornem ao modo de espera.  A execu√ß√£o da tarefa implica atribuir o tempo do processador √† tarefa - um recurso global. <br><br>  O artigo discute agendadores de espa√ßo do usu√°rio, ou seja, trabalhando sobre os encadeamentos do sistema operacional (que, por sua vez, s√£o controlados por um sheduler no n√≠vel do kernel).  O agendador Tokio executa futuros de Rust, que podem ser considerados como "threads verdes ass√≠ncronos".  Esse √© um padr√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fluxo misto M: N</a> no qual muitas tarefas da interface do usu√°rio s√£o multiplexadas em v√°rios encadeamentos do sistema operacional. <br><br>  Existem muitas maneiras diferentes de simular um sheduler, cada um com seus pr√≥prios pr√≥s e contras.  No n√≠vel mais b√°sico, o planejador pode ser modelado como uma <i>fila de execu√ß√£o</i> e um <i>processador</i> que o separa.  Um processador √© um peda√ßo de c√≥digo que √© executado em um encadeamento.  No pseudo-c√≥digo, ele faz o seguinte: <br><br><pre> <code class="plaintext hljs">while let Some(task) = self.queue.pop() { task.run(); }</code> </pre> <br>  Quando uma tarefa se torna vi√°vel, ela √© inserida na fila de execu√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff6/1f4/18f/ff61f418f73f08c62b5e9eaeacaeb8ed.png"><br><br>  Embora voc√™ possa criar um sistema no qual recursos, tarefas e um processador existam no mesmo encadeamento, o Tokio prefere usar v√°rios encadeamentos.  Vivemos em um mundo onde um computador possui muitos processadores.  O desenvolvimento de um agendador de rosca √∫nica levar√° ao carregamento insuficiente de ferro.  Queremos usar todas as CPUs.  Existem v√°rias maneiras de fazer isso: <br><br><ul><li>  Uma fila de execu√ß√£o global, muitos processadores. <br></li><li>  Muitos processadores, cada um com sua pr√≥pria fila de execu√ß√£o. </li></ul><br><h3>  Uma vez, muitos processadores </h3><br>  Este modelo possui uma fila de execu√ß√£o global.  Quando as tarefas s√£o conclu√≠das, elas s√£o colocadas no final da fila.  Existem v√°rios processadores, cada um em um thread separado.  Cada processador retira uma tarefa do in√≠cio da fila ou bloqueia o encadeamento se n√£o houver tarefas dispon√≠veis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85c/8d0/23d/85c8d023dfeba249bba01234e0e8783a.png"><br><br>  A linha de execu√ß√£o deve ser suportada por muitos fabricantes e consumidores.  Geralmente, √© usada uma lista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intrusiva</a> , na qual a estrutura de cada tarefa inclui um ponteiro para a pr√≥xima tarefa na fila (em vez de agrupar as tarefas em uma lista vinculada).  Assim, a aloca√ß√£o de mem√≥ria para opera√ß√µes push e pop pode ser evitada.  Voc√™ pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a opera√ß√£o push sem travar</a> , mas para coordenar os consumidores, o mutex √© necess√°rio para a opera√ß√£o pop (√© tecnicamente poss√≠vel implementar uma fila de multiusu√°rios sem travar). <br><br>  No entanto, na pr√°tica, a sobrecarga para prote√ß√£o adequada contra bloqueios √© mais do que apenas usar um mutex. <br><br>  Essa abordagem geralmente √© usada para um pool de threads de uso geral, porque possui v√°rias vantagens: <br><br><ul><li>  As tarefas s√£o bastante planejadas. <br></li><li>  Implementa√ß√£o relativamente simples.  Uma fila mais ou menos padr√£o faz interface com o ciclo do processador descrito acima. </li></ul><br>  Uma breve nota sobre o planejamento justo (eq√ºitativo).  Isso significa que as tarefas s√£o realizadas honestamente: quem veio antes foi quem saiu antes.  Planejadores de uso geral tentam ser justos, mas h√° exce√ß√µes, como a paraleliza√ß√£o por jun√ß√£o de forquilha, em que a velocidade de c√°lculo do resultado, em vez da justi√ßa para cada subtarefa individual, √© um fator importante. <br><br>  Este modelo tem uma desvantagem.  Todos os processadores se candidatam a tarefas do in√≠cio da fila.  Para threads de uso geral, isso geralmente n√£o √© um problema.  O tempo para concluir uma tarefa excede em muito o tempo para recuper√°-la da fila.  Quando as tarefas s√£o executadas por um longo per√≠odo, a competi√ß√£o na fila √© reduzida.  No entanto, espera-se que as tarefas ass√≠ncronas de Rust sejam conclu√≠das muito rapidamente.  Nesse caso, os custos indiretos da luta na fila aumentam significativamente. <br><br><h3>  Simultaneidade e simpatia mec√¢nica </h3><br>  Para alcan√ßar o desempenho m√°ximo, precisamos aproveitar ao m√°ximo os recursos de hardware.  O termo ‚Äúsimpatia mec√¢nica‚Äù por software foi usado pela primeira vez por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Martin Thompson</a> (cujo blog n√£o √© mais atualizado, mas ainda √© muito informativo). <br><br>  Uma discuss√£o detalhada da implementa√ß√£o do paralelismo em equipamentos modernos est√° al√©m do escopo deste artigo.  De um modo geral, o ferro aumenta a produtividade n√£o devido √† acelera√ß√£o, mas devido √† introdu√ß√£o de um n√∫mero maior de n√∫cleos de CPU (at√© meu laptop tem seis!). Cada n√∫cleo pode executar grandes quantidades de computa√ß√£o em pequenos intervalos de tempo.  A√ß√µes como acessar o cache e a mem√≥ria levam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito mais tempo em</a> rela√ß√£o ao tempo de execu√ß√£o na CPU.  Portanto, para acelerar os aplicativos, voc√™ precisa maximizar o n√∫mero de instru√ß√µes da CPU para cada acesso √† mem√≥ria.  Embora o compilador ajude muito, ainda precisamos pensar em coisas como alinhamento e padr√µes de acesso √† mem√≥ria. <br><br>  Threads separados funcionam separadamente como um √∫nico thread isolado, <b>at√© que</b> v√°rios threads modifiquem simultaneamente a mesma linha de cache (muta√ß√µes simult√¢neas) ou seja necess√°ria <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consist√™ncia consistente</a> .  Nesse caso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">protocolo de coer√™ncia do cache</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CPU √©</a> ativado.  Garante a relev√¢ncia do cache de cada CPU. <br><br>  A conclus√£o √© √≥bvia: na medida do poss√≠vel, evite a sincroniza√ß√£o entre os threads, pois √© lento. <br><br><h3>  Muitos processadores, cada um com sua pr√≥pria fila de execu√ß√£o </h3><br>  Outro modelo s√£o v√°rios agendadores de thread √∫nico.  Cada processador recebe sua pr√≥pria fila de execu√ß√£o e as tarefas s√£o fixadas em um processador espec√≠fico.  Isso evita completamente o problema de sincroniza√ß√£o.  Como o modelo de tarefa Rust requer a capacidade de enfileirar uma tarefa a partir de qualquer encadeamento, ainda deve haver uma maneira segura de encadeamento de inserir tarefas no planejador.  A fila de execu√ß√£o de cada processador suporta MPSC (thread-safe push operation) ou cada processador possui <b>duas</b> filas de execu√ß√£o: n√£o sincronizadas e thread-safe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/a3c/35e/c6da3c35e7f6fb28b63fdb3ff6417882.png"><br><br>  Essa estrat√©gia usa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seastar</a> .  Como quase completamente evitamos a sincroniza√ß√£o, essa estrat√©gia fornece uma velocidade muito boa.  Mas ela n√£o resolve todos os problemas.  Se a carga de trabalho n√£o for completamente homog√™nea, alguns processadores estar√£o com carga, enquanto outros ficar√£o ociosos, o que levar√° ao uso n√£o ideal de recursos.  Isso acontece porque as tarefas s√£o corrigidas em um processador espec√≠fico.  Quando um grupo de tarefas √© planejado em um pacote em um processador, ele cumpre sozinho o pico de carga, mesmo que outros estejam ociosos. <br><br>  A maioria das cargas de trabalho "reais" n√£o √© homog√™nea.  Portanto, planejadores de uso geral geralmente evitam esse modelo. <br><br><h3>  Agendador de captura de tarefas </h3><br>  O planejador com planejadores de roubo de trabalho √© baseado no modelo do planejador fragmentado e resolve o problema do carregamento incompleto de recursos de hardware.  Cada processador suporta sua pr√≥pria fila de execu√ß√£o.  As tarefas que s√£o executadas s√£o colocadas na fila de execu√ß√£o do processador atual e funcionam nele.  Mas quando o processador est√° ocioso, ele verifica as filas do processador irm√£o e tenta pegar algo a partir da√≠.  O processador entra no modo de suspens√£o somente depois que n√£o consegue encontrar trabalho nas filas de execu√ß√£o ponto a ponto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/561/9a9/02c/5619a902c1d95252d20ac7db1273e57f.png"><br><br>  No n√≠vel do modelo, essa √© a melhor abordagem dos dois mundos.  Sob carga, os processadores trabalham de forma independente, evitando a sincroniza√ß√£o de sobrecarga.  Nos casos em que a carga entre os processadores √© distribu√≠da de maneira desigual, o planejador pode redistribu√≠-la.  √â por isso que esses agendadores s√£o usados ‚Äã‚Äãem <a href="">Go</a> , <a href="">Erlang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java</a> e outras linguagens. <br><br>  A desvantagem √© que essa abordagem √© muito mais complicada.  O algoritmo de fila deve suportar a captura de tarefas e, para uma execu√ß√£o suave, √© necess√°ria <b>alguma</b> sincroniza√ß√£o entre processadores.  Se n√£o for implementado corretamente, a sobrecarga para captura poder√° ser maior que o ganho. <br><br>  Considere esta situa√ß√£o: o processador A est√° atualmente executando uma tarefa e possui uma fila de execu√ß√£o vazia.  O processador B est√° ocioso;  ele tenta capturar alguma tarefa, mas falha, ent√£o entra no modo de suspens√£o.  Em seguida, 20 tarefas s√£o geradas a partir da tarefa do processador A.  Idealmente, o processador B deve acordar e pegar alguns deles.  Para isso, √© necess√°rio implementar certas heur√≠sticas no planejador, onde os processadores sinalizam para os processadores pares adormecidos sobre a apar√™ncia de novas tarefas em sua fila.  Obviamente, isso requer sincroniza√ß√£o adicional, para que essas opera√ß√µes sejam melhor minimizadas. <br><br>  Em resumo: <br><br><ul><li>  Quanto menos sincroniza√ß√£o, melhor. <br></li><li>  A captura de trabalho √© o algoritmo ideal para planejadores de uso geral. <br></li><li>  Cada processador funciona independentemente dos outros, mas √© necess√°ria alguma sincroniza√ß√£o para capturar o trabalho. </li></ul><br><h1>  Agendador Tokio 0.1 </h1><br>  O primeiro agendador de trabalho do Tokio foi lan√ßado em mar√ßo de 2018.  Esta foi a primeira tentativa, com base em algumas suposi√ß√µes que se mostraram erradas. <br><br>  Primeiro, o agendador do Tokio 0.1 sugeriu que os threads do processador fossem fechados se estivessem ociosos por um certo per√≠odo de tempo.  O planejador foi criado originalmente como um sistema "de uso geral" para o pool de threads Rust.  Naquela √©poca, o tempo de execu√ß√£o dos Tokio ainda estava em um est√°gio inicial de desenvolvimento.  Em seguida, o modelo assumiu que as tarefas de E / S seriam executadas no mesmo encadeamento que o seletor de E / S (epoll, kqueue, iocp ...).  Mais tarefas computacionais podem ser direcionadas para o conjunto de encadeamentos.  Nesse contexto, a configura√ß√£o flex√≠vel do n√∫mero de encadeamentos ativos √© assumida; portanto, faz mais sentido desabilitar os encadeamentos inativos.  No entanto, no planejador com captura de tarefas, o modelo passou a executar <i>todas</i> as tarefas ass√≠ncronas e, nesse caso, faz sentido manter sempre um pequeno n√∫mero de encadeamentos no estado ativo. <br><br>  Em segundo lugar, uma linha de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">viga cruzada de</a> duas vias foi implementada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">l√°</a> .  Essa implementa√ß√£o √© baseada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linha Chase-Lev bidirecional</a> e n√£o √© adequada para o planejamento de tarefas ass√≠ncronas independentes pelos motivos descritos abaixo. <br><br>  Em terceiro lugar, a implementa√ß√£o acabou sendo muito complicada.  Isso se deve em parte ao fato de esse ter sido meu primeiro agendador de tarefas.  Al√©m disso, fiquei impaciente ao usar at√¥micos em galhos, onde o mutex teria se sa√≠do bem.  Uma li√ß√£o importante √© que muitas vezes s√£o os mutexes que funcionam melhor. <br><br>  Finalmente, houve muitas pequenas falhas na implementa√ß√£o inicial.  Nos primeiros anos, os detalhes de implementa√ß√£o do modelo ass√≠ncrono de Rust evolu√≠ram significativamente, mas as bibliotecas mantiveram a API est√°vel o tempo todo.  Isso levou ao ac√∫mulo de alguma d√≠vida t√©cnica. <br><br>  Agora, a Tokio est√° se aproximando do primeiro grande lan√ßamento - e podemos pagar toda essa d√≠vida, al√©m de aprender com a experi√™ncia adquirida ao longo dos anos de desenvolvimento.  Este √© um momento emocionante! <br><br><h1>  Agendador Tokio da pr√≥xima gera√ß√£o </h1><br>  Agora √© hora de examinar mais de perto o que mudou no novo planejador. <br><br><a name="1"></a><h3>  Novo sistema de tarefas </h3><br>  Primeiro, √© importante destacar o que <b>n√£o faz</b> parte do Tokio, mas √© crucial em termos de melhoria da efici√™ncia: este √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">novo sistema de tarefas</a> no <code>std</code> , originalmente desenvolvido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Taylor Kramer</a> .  Este sistema fornece os ganchos que o planejador deve implementar para executar tarefas ass√≠ncronas do Rust, e o sistema √© verdadeiramente projetado e implementado de maneira excelente.  √â muito mais leve e mais flex√≠vel que a itera√ß√£o anterior. <br><br>  A estrutura <code>Waker</code> dos recursos sinaliza que h√° uma tarefa <i>vi√°vel</i> que deve ser colocada na fila do planejador.  No novo sistema de tarefas, essa √© uma estrutura de dois ponteiros, enquanto antes era muito maior.  Reduzir o tamanho √© importante para minimizar a sobrecarga de copiar o valor do <code>Waker</code> em locais diferentes e ocupa menos espa√ßo nas estruturas, o que permite espremer dados mais importantes na linha de cache.  O design do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vtable</a> fez v√°rias otimiza√ß√µes, as quais discutiremos mais adiante. <br><br><a name="2"></a><h3>  Escolhendo o melhor algoritmo de fila </h3><br>  A fila de execu√ß√£o est√° no centro do planejador.  Portanto, este √© o componente mais importante a ser corrigido.  O planejador Tokio original usava uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fila de m√£o cruzada de</a> duas vias: uma implementa√ß√£o de fonte √∫nica (produtor) e muitos consumidores.  Uma tarefa √© colocada em uma extremidade e os valores s√£o recuperados na outra.  Na maioria das vezes, o encadeamento "empurra" os valores do final da fila, mas √†s vezes outros encadeamentos interceptam o trabalho, executando a mesma opera√ß√£o.  A fila de m√£o dupla √© suportada por uma matriz e um conjunto de √≠ndices que rastreiam a cabe√ßa e a cauda.  Quando a fila est√° cheia, a introdu√ß√£o dela levar√° a um aumento no espa√ßo de armazenamento.  Uma nova matriz maior √© alocada e os valores s√£o movidos para o novo armazenamento. <br><br>  A capacidade de crescer √© alcan√ßada atrav√©s da complexidade e das despesas gerais.  As opera√ß√µes push / pop devem levar em considera√ß√£o esse crescimento.  Al√©m disso, a libera√ß√£o da matriz original est√° repleta de dificuldades adicionais.  Em uma linguagem de coleta de lixo (GC), a matriz antiga ficar√° fora do escopo e, eventualmente, o GC a limpar√°.  No entanto, o Rust √© enviado sem um GC.  Isso significa que n√≥s mesmos somos respons√°veis ‚Äã‚Äãpor liberar a matriz, mas os threads podem tentar acessar a mem√≥ria ao mesmo tempo.  Para resolver esse problema, a viga cruzada usa uma estrat√©gia de recupera√ß√£o baseada em √©poca.  Embora n√£o exija muitos recursos, ele adiciona uma sobrecarga n√£o trivial ao caminho principal (caminho ativo).  Agora, cada opera√ß√£o deve executar opera√ß√µes de leitura-modifica√ß√£o-grava√ß√£o at√¥mica (RMW) na entrada e sa√≠da de se√ß√µes cr√≠ticas para sinalizar para outros segmentos que a mem√≥ria est√° em uso e n√£o pode ser limpa. <br><br>  Devido √† sobrecarga do crescimento da fila de execu√ß√£o, faz sentido pensar: o suporte a esse crescimento √© realmente necess√°rio?  Essa pergunta finalmente me levou a reescrever o planejador.  A nova estrat√©gia √© ter um tamanho de fila fixo para cada processo.  Quando a fila est√° cheia, em vez de aumentar a fila local, a tarefa se move para a fila global com v√°rios consumidores e v√°rios produtores.  Os processadores verificar√£o periodicamente essa fila global, mas com uma frequ√™ncia muito menor que a local. <br><br>  Como parte de uma das primeiras experi√™ncias, substitu√≠mos a viga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cruzada</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mpmc</a> .  Isso n√£o levou a uma melhoria significativa devido √† quantidade de sincroniza√ß√£o para push e pop.  A chave para capturar o trabalho √© que quase n√£o h√° concorr√™ncia nas filas sob carga, pois cada processador acessa apenas sua pr√≥pria fila. <br><br>  Nesse est√°gio, decidi estudar cuidadosamente as fontes Go - e descobri que elas usam um tamanho de fila fixo com um fabricante e v√°rios consumidores, com sincroniza√ß√£o m√≠nima, o que √© muito impressionante.  Para adaptar o algoritmo ao agendador Tokio, fiz algumas altera√ß√µes.  Vale ressaltar que a implementa√ß√£o Go usa opera√ß√µes at√¥micas sequenciais (como eu a entendo).  A vers√£o Tokio tamb√©m reduz o n√∫mero de algumas opera√ß√µes de c√≥pia em ramifica√ß√µes de c√≥digo mais raras. <br><br>  Uma implementa√ß√£o de fila √© um buffer circular que armazena valores em uma matriz.  A cabe√ßa e a cauda da fila s√£o rastreadas por opera√ß√µes at√¥micas com valores inteiros. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// Concurrently updated by many threads. head: AtomicU32, /// Only updated by producer thread but read by many threads. tail: AtomicU32, /// Masks the head / tail position value to obtain the index in the buffer. mask: usize, /// Stores the tasks. buffer: Box&lt;[MaybeUninit&lt;Task&gt;]&gt;, }</span></span></code> </pre> <br>  O enfileiramento √© realizado por um √∫nico encadeamento: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if tail.wrapping_sub(head) &lt; self.buffer.len() as u32 { // Map the position to a slot index. let idx = tail as usize &amp; self.mask; // Don't drop the previous value in `buffer[idx]` because // it is uninitialized memory. self.buffer[idx].as_mut_ptr().write(task); // Make the task available self.tail.store(tail.wrapping_add(1), Release); return; } // The local buffer is full. Push a batch of work to the global // queue. match self.push_overflow(task, head, tail, global) { Ok(_) =&gt; return, // Lost the race, try again Err(v) =&gt; task = v, } }</span></span></code> </pre> <br>  Observe que nesta fun√ß√£o de <code>push</code> , as √∫nicas opera√ß√µes at√¥micas s√£o carregadas com <code>Acquire</code> pedidos e salvar com <code>Release</code> pedidos.  N√£o h√° opera√ß√µes RMW ( <code>compare_and_swap</code> , <code>fetch_and</code> ...) ou ordem sequencial, como antes.  Isso √© importante porque nos chips x86 todos os downloads / salvamentos j√° s√£o "at√¥micos".  Assim, no n√≠vel da CPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta fun√ß√£o n√£o ser√° sincronizada</a> .  As opera√ß√µes at√¥micas impedir√£o certas otimiza√ß√µes no compilador, mas isso √© tudo.  Provavelmente, a primeira opera√ß√£o de <code>load</code> pode ser realizada com seguran√ßa com pedidos <code>Relaxed</code> , mas a substitui√ß√£o n√£o carrega nenhuma sobrecarga percept√≠vel. <br><br>  Quando a fila est√° cheia, <code>push_overflow</code> √© <code>push_overflow</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa fun√ß√£o move metade das tarefas da fila local para a global. A fila global √© uma lista intrusiva protegida por um mutex. Ao mover para a fila global, as tarefas s√£o primeiro vinculadas, ent√£o um mutex √© criado e todas as tarefas s√£o inseridas atualizando o ponteiro na cauda da fila global. Isso economiza um tamanho pequeno de se√ß√£o cr√≠tica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ estiver familiarizado com os detalhes do pedido de mem√≥ria at√¥mica, poder√° notar um "problema" em potencial com a fun√ß√£o mostrada acima </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A opera√ß√£o de </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordena√ß√£o </font><font style="vertical-align: inherit;">at√¥mica √© </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bastante fraca. Ele pode retornar valores obsoletos, ou seja, uma opera√ß√£o de captura paralela j√° pode aumentar o valor </font></font><code>self.head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas no cache do fluxo</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o valor antigo permanecer√°, portanto, n√£o notar√° a opera√ß√£o de captura. Isso n√£o √© um problema com a corre√ß√£o do algoritmo. Da maneira principal (r√°pida), </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos preocupamos apenas com a fila local estar cheia ou n√£o. Como apenas o encadeamento atual pode empurrar a fila, uma opera√ß√£o desatualizada </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente far√° com que a fila pare√ßa mais cheia do que realmente √©. Pode determinar incorretamente que a fila est√° cheia e causar </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas essa fun√ß√£o inclui uma opera√ß√£o at√¥mica mais forte. Se </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinar que a fila n√£o est√° realmente cheia, retornar√° w / </font></font><code>Err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a opera√ß√£o </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° iniciada novamente. Esta √© outra raz√£o pela qual</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move metade da fila de execu√ß√£o para a fila global. </font><font style="vertical-align: inherit;">Ap√≥s esse movimento, esses falsos positivos ocorrem com muito menos frequ√™ncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(do processador ao qual a fila pertence) tamb√©m √© implementado simplesmente:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if head == tail { // queue is empty return None; } // Map the head position to a slot index. let idx = head as usize &amp; self.mask; let task = self.buffer[idx].as_ptr().read(); // Attempt to claim the task read above. let actual = self .head .compare_and_swap(head, head.wrapping_add(1), Release); if actual == head { return Some(task.assume_init()); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fun√ß√£o, um at√¥mico </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A sobrecarga principal vem </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© semelhante a </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas a </font></font><code>self.tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carga at√¥mica deve ser transferida </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al√©m disso, da mesma forma </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a opera√ß√£o </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenta fingir ser metade da fila em vez de uma √∫nica tarefa. </font><font style="vertical-align: inherit;">Isso tem um bom efeito no desempenho, que discutiremos mais adiante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima parte que falta √© a an√°lise da fila global, que recebe tarefas que transbordam filas locais, bem como a transfer√™ncia de tarefas para o planejador a partir de threads que n√£o s√£o do processador. </font><font style="vertical-align: inherit;">Se o processador estiver sob carga, ou seja, houver tarefas na fila local, o processador tentar√° extrair as tarefas da fila global ap√≥s cerca de 60 tarefas na fila local. </font><font style="vertical-align: inherit;">Ele tamb√©m verifica a fila global quando est√° no estado de "pesquisa" descrito abaixo.</font></font><br><br><a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifique modelos de mensagens </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os aplicativos Tokio normalmente consistem em muitas pequenas tarefas independentes. Eles interagem entre si atrav√©s de mensagens. Esse modelo √© semelhante a outros idiomas, como Go e Erlang. Dado o qu√£o comum √© o modelo, faz sentido para o planejador otimiz√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que as tarefas A e B. A tarefa A esteja sendo executada e envie uma mensagem para a tarefa B pelo canal de transmiss√£o. Um canal √© um recurso no qual a tarefa B est√° bloqueada no momento; portanto, a a√ß√£o de enviar uma mensagem far√° com que a tarefa B fa√ßa a transi√ß√£o para um estado execut√°vel - e ser√° colocada na fila de execu√ß√£o do processador atual. Em seguida, o processador deduzir√° a pr√≥xima tarefa da fila de execu√ß√£o, executar√° e repetir√° esse ciclo at√© atingir a tarefa B.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema √© que pode haver um atraso significativo entre o envio de uma mensagem e a conclus√£o da tarefa B. </font><font style="vertical-align: inherit;">Al√©m disso, dados quentes, como uma mensagem, s√£o armazenados no cache da CPU, mas quando a tarefa √© conclu√≠da, √© prov√°vel que os caches correspondentes sejam limpos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver esse problema, o novo agendador Tokio implementa otimiza√ß√£o (como nos agendadores Go e Kotlin). </font><font style="vertical-align: inherit;">Quando uma tarefa entra em um estado execut√°vel, ela n√£o √© colocada no final da fila, mas √© armazenada em um slot especial de "pr√≥xima tarefa". </font><font style="vertical-align: inherit;">O processador sempre verifica esse slot antes de verificar a fila. </font><font style="vertical-align: inherit;">Se j√° houver uma tarefa antiga ao inserir no slot, ela ser√° exclu√≠da do slot e ser√° movida para o final da fila. </font><font style="vertical-align: inherit;">Assim, a tarefa de transmitir uma mensagem ser√° realizada praticamente sem demora.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/12f/e12/a32/12fe12a324d1855a6c62cacd56cb4f70.png"><br><br><a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Captura do acelerador </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um planejador de captura de tarefas, se a fila de execu√ß√£o do processador estiver vazia, o processador tentar√° capturar tarefas das CPUs do mesmo n√≠vel. Primeiro, uma CPU de mesmo n√≠vel aleat√≥ria √© selecionada; se nenhuma tarefa for encontrada, a pr√≥xima ser√° pesquisada e assim por diante, at√© que as tarefas sejam encontradas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√°tica, v√°rios processadores geralmente terminam de processar a fila de execu√ß√£o aproximadamente ao mesmo tempo. Isso acontece quando um pacote de trabalho chega (por exemplo, quando</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consultado a disponibilidade do soquete). Os processadores acordam, recebem tarefas, iniciam-nas e concluem. Isso leva ao fato de que todos os processadores est√£o tentando capturar simultaneamente as tarefas de outras pessoas, ou seja, muitos threads est√£o tentando acessar as mesmas filas. Existe um conflito. Uma escolha aleat√≥ria do ponto de partida ajuda a reduzir a concorr√™ncia, mas a situa√ß√£o ainda n√£o √© muito boa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para contornar esse problema, o novo planejador limita o n√∫mero de processadores paralelos que executam opera√ß√µes de captura. Chamamos o estado do processador em que ele est√° tentando capturar as tarefas de outras pessoas como "procura de emprego" ou "busca" para abreviar (mais sobre isso mais tarde). Essa otimiza√ß√£o √© realizada usando valor at√¥mico</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que o processador aumenta antes de iniciar a pesquisa e diminui ao sair do estado de pesquisa. </font><font style="vertical-align: inherit;">O m√°ximo poss√≠vel em um estado de pesquisa pode ser metade do n√∫mero total de processadores. </font><font style="vertical-align: inherit;">Ou seja, o limite aproximado est√° definido e isso √© normal. </font><font style="vertical-align: inherit;">N√£o precisamos de um limite r√≠gido para o n√∫mero de CPUs na pesquisa, apenas para limitar. </font><font style="vertical-align: inherit;">Sacrificamos a precis√£o em prol da efici√™ncia do algoritmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de entrar no estado de pesquisa, o processador tenta capturar o trabalho das CPUs pares e verifica a fila global.</font></font><br><br><a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diminuir a sincroniza√ß√£o entre threads </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra parte importante do planejador √© notificar as CPUs dos pares sobre novas tarefas. Se o "irm√£o" estiver dormindo, ele acorda e captura tarefas. As notifica√ß√µes desempenham outro papel importante. Lembre-se de que o algoritmo de fila usa ordena√ß√£o at√¥mica fraca ( </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Devido √† aloca√ß√£o at√¥mica da mem√≥ria, n√£o h√° garantia de que um processador par ver√° tarefas na fila sem sincroniza√ß√£o adicional. Portanto, as notifica√ß√µes tamb√©m s√£o respons√°veis ‚Äã‚Äãpor isso. Por esse motivo, as notifica√ß√µes ficam caras. O objetivo √© minimizar seu n√∫mero para n√£o usar os recursos da CPU, ou seja, o processador tem tarefas e o irm√£o n√£o pode roub√°-las. O n√∫mero excessivo de notifica√ß√µes leva a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um problema de manada de trov√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O planejador original dos Tokio adotou uma abordagem ing√™nua das notifica√ß√µes. Sempre que uma nova tarefa era colocada na fila de execu√ß√£o, o processador recebia uma notifica√ß√£o. Sempre que a CPU foi notificada e viu a tarefa ap√≥s acordar, ela notificou outra CPU. Essa l√≥gica levou muito rapidamente todos os processadores a acordar e procurar trabalho (causando um conflito). Muitas vezes, a maioria dos processadores n√£o encontrou trabalho e adormeceu novamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O novo planejador melhorou bastante esse padr√£o, semelhante ao planejador Go. As notifica√ß√µes s√£o enviadas como antes, mas apenas se n√£o houver CPU no estado de pesquisa (consulte a se√ß√£o anterior). Quando o processador recebe uma notifica√ß√£o, ele entra imediatamente no estado de pesquisa. Quando o processador no estado de pesquisa encontra novas tarefas, ele primeiro sai do estado de pesquisa e depois notifica o outro processador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa l√≥gica limita a velocidade na qual os processadores s√£o ativados. Se um pacote de tarefas inteiro for planejado imediatamente (por exemplo, quando</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pesquisada quanto √† prontid√£o do soquete), a primeira tarefa resultar√° em uma notifica√ß√£o ao processador. </font><font style="vertical-align: inherit;">Ele est√° agora em um estado de pesquisa. </font><font style="vertical-align: inherit;">As demais tarefas agendadas no pacote n√£o notificar√£o o processador, pois h√° pelo menos uma CPU no estado de pesquisa. </font><font style="vertical-align: inherit;">Esse processador notificado capturar√° metade das tarefas do lote e, por sua vez, notificar√° o outro processador. </font><font style="vertical-align: inherit;">Um terceiro processador acorda, encontra as tarefas de um dos dois primeiros e captura metade deles. </font><font style="vertical-align: inherit;">Isso leva a um aumento suave no n√∫mero de CPUs em funcionamento, bem como no balanceamento de carga r√°pido.</font></font><br><br><a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduza a aloca√ß√£o de mem√≥ria </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O novo agendador Tokio requer apenas uma aloca√ß√£o de mem√≥ria para cada tarefa gerada, enquanto o antigo requer dois. </font><font style="vertical-align: inherit;">Anteriormente, a estrutura da tarefa era algo assim:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// All state needed to manage the task state: TaskState, /// The logic to run is represented as a future trait object. future: Box&lt;dyn Future&lt;Output = ()&gt;&gt;, }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m ser√° destacada em </font></font><code>Box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Durante muito tempo, eu quis consertar essa junta (tentei pela primeira vez em 2014). Duas coisas mudaram desde o antigo planejador dos Tokio. Primeiro, estabilizado </font></font><code>std::alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em segundo lugar, o futuro sistema de tarefas mudou para uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrat√©gia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expl√≠cita de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">vtable</font></a><font style="vertical-align: inherit;"> . Finalmente, foram essas duas coisas que estavam faltando para se livrar da ineficiente aloca√ß√£o de mem√≥ria dupla para cada tarefa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora a estrutura </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© apresentada da seguinte forma:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span>&lt;T&gt; { header: Header, future: T, trailer: Trailer, }</code> </pre> <br>     <code>Header</code> ,  <code>Trailer</code> ,     ¬´¬ª  ()  ¬´¬ª (), . .   ,    ,  ,   . ¬´¬ª          .     ,      ( 64  128 ).  ,        . <br><br><a name="7"></a><h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima otimiza√ß√£o discutida neste artigo √© reduzir o n√∫mero de links at√¥micos. Existem muitas refer√™ncias √† estrutura da tarefa, inclusive do agendador e de cada waker. A estrat√©gia geral para gerenciar essa mem√≥ria √© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a contagem de links at√¥micos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Essa estrat√©gia requer uma opera√ß√£o at√¥mica toda vez que um link √© clonado e toda vez que um link √© exclu√≠do. Quando o √∫ltimo link fica fora do escopo, a mem√≥ria √© liberada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No antigo agendador Tokio, o agendador e todos os wakers continham um link para um descritor de tarefas, aproximadamente:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waker</span></span></span></span> { task: Arc&lt;Task&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a tarefa √© ativada, o link √© clonado (ocorre um incremento at√¥mico). </font><font style="vertical-align: inherit;">Em seguida, o link √© colocado na fila de execu√ß√£o. </font><font style="vertical-align: inherit;">Quando o processador recebe a tarefa e conclui sua execu√ß√£o, ele descarta o link, o que leva √† redu√ß√£o at√¥mica. </font><font style="vertical-align: inherit;">Essas opera√ß√µes at√¥micas (incremento e diminui√ß√£o) se somam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse problema foi identificado anteriormente pelos desenvolvedores do sistema de tarefas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles perceberam que, ao ligar, o </font></font><code>Waker::wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link original </font></font><code>waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralmente n√£o √© mais necess√°rio. </font><font style="vertical-align: inherit;">Isso permite reutilizar o contador de link at√¥mico ao mover uma tarefa para a fila de execu√ß√£o. </font><font style="vertical-align: inherit;">O sistema de tarefas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora inclui duas chamadas de API para "ativar":</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>wake</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que aceita </font></font><code>self</code> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>wake_by_ref</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que aceita </font></font><code>&amp;self</code> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa constru√ß√£o de API nos faz us√°-la ao chamar </font></font><code>wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, evitando incremento at√¥mico. </font><font style="vertical-align: inherit;">A implementa√ß√£o fica assim:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { task.scheduler.schedule(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_by_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso evita a sobrecarga de contagens de links adicionais </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se voc√™ puder assumir a responsabilidade de acordar. Na minha experi√™ncia, √© quase sempre aconselh√°vel acordar </font></font><code>&amp;self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O despertar </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impede a reutiliza√ß√£o do waker (√∫til nos casos em que o recurso envia muitos valores, como canais, soquetes, ...). Tamb√©m no caso, √© </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais dif√≠cil implementar a ativa√ß√£o segura de threads (deixaremos os detalhes para outro artigo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O novo planejador resolve o problema de "despertar </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" evitando o incremento at√¥mico </font></font><code>wake_by_ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que o torna t√£o eficaz quanto</font></font><code>wake(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para fazer isso, o planejador mant√©m uma lista de todas as tarefas atualmente ativas (ainda n√£o conclu√≠das). </font><font style="vertical-align: inherit;">A lista representa o contador de refer√™ncia necess√°rio para enviar a tarefa para a fila de execu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A complexidade dessa otimiza√ß√£o est√° no fato de que o planejador n√£o remover√° tarefas de sua lista at√© receber uma garantia de que a tarefa ser√° colocada na fila de execu√ß√£o novamente. </font><font style="vertical-align: inherit;">Os detalhes da implementa√ß√£o desse esquema est√£o al√©m do escopo deste artigo, mas eu recomendo fortemente que voc√™ olhe a fonte.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concorr√™ncia em negrito (insegura) com Loom </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â muito dif√≠cil escrever o c√≥digo paralelo correto, sem bloqueios. √â melhor trabalhar devagar, mas corretamente, do que rapidamente, mas com falhas, principalmente se os erros estiverem relacionados √† seguran√ßa da mem√≥ria. A melhor op√ß√£o, no entanto, deve funcionar rapidamente e sem erros. O novo agendador fez algumas otimiza√ß√µes bastante agressivas e evita a maioria dos tipos </font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por causa da especializa√ß√£o. Em geral, h√° bastante c√≥digo inseguro nele </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem v√°rias maneiras de testar c√≥digo paralelo. Uma delas √© que os usu√°rios testem e depurem em vez de voc√™ (uma op√ß√£o atraente, com certeza). Outra √© escrever testes de unidade que s√£o executados em loop e podem detectar um erro. Talvez at√© use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSAN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Obviamente, se ele encontrar um erro, ele n√£o poder√° ser facilmente reproduzido sem reiniciar o ciclo de teste. Al√©m disso, quanto tempo leva esse ciclo? Dez segundos? Dez minutos? Dez dias? Anteriormente, era necess√°rio testar o c√≥digo paralelo no Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achamos essa situa√ß√£o inaceit√°vel. Quando liberamos o c√≥digo, queremos nos sentir confiantes (o m√°ximo poss√≠vel), especialmente no caso de c√≥digo paralelo sem bloqueios. Os usu√°rios dos Tokio precisam de confiabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, desenvolvemos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma ferramenta para teste de permuta√ß√£o de c√≥digo paralelo. Os testes s√£o escritos como de costume, mas</font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele ser√° executado muitas vezes, reorganizando todas as op√ß√µes poss√≠veis de execu√ß√£o e comportamento que o teste pode encontrar em um ambiente de streaming. Ele tamb√©m verifica o acesso correto √† mem√≥ria, libera mem√≥ria, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como exemplo, aqui est√° o teste de tear para o novo planejador:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multi_spawn</span></span></span></span>() { loom::model(|| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pool = ThreadPool::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c1 = Arc::new(AtomicUsize::new(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (tx, rx) = oneshot::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx1 = Arc::new(Mutex::new(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(tx))); <span class="hljs-comment"><span class="hljs-comment">// Spawn a task let c2 = c1.clone(); let tx2 = tx1.clone(); pool.spawn(async move { spawn(async move { if 1 == c1.fetch_add(1, Relaxed) { tx1.lock().unwrap().take().unwrap().send(()); } }); }); // Spawn a second task pool.spawn(async move { spawn(async move { if 1 == c2.fetch_add(1, Relaxed) { tx2.lock().unwrap().take().unwrap().send(()); } }); }); rx.recv(); }); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece bastante normal, mas um peda√ßo de c√≥digo em um bloco </font></font><code>loom::model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© executado milhares de vezes (possivelmente milh√µes), sempre com uma ligeira mudan√ßa de comportamento. Cada execu√ß√£o altera a ordem exata dos encadeamentos. Al√©m disso, para cada opera√ß√£o at√¥mica, o tear tenta todos os diferentes comportamentos permitidos no modelo de mem√≥ria C ++ 11. Lembre-se de que a carga at√¥mica com </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">era bastante fraca e poderia retornar valores obsoletos. O teste </font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentar√° todos os valores poss√≠veis que podem ser carregados. </font></font><br><br> <code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tornou-se uma ferramenta inestim√°vel no desenvolvimento de um novo planejador. Ele capturou mais de dez bugs que passaram em todos os testes de unidade, testes manuais e testes de carga.</font></font><br><br>    ,  loom  ¬´  ¬ª,   .      .      .       ,        .   Loom   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> (dynamic partial-order reduction).    ,    .          ,        ( ). Loom           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, gra√ßas aos extensos testes com o Loom, agora estou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais confiante na corre√ß√£o do agendador.</font></font><br><br><h1>  Resultados </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, examinamos o que s√£o os agendadores e como o novo agendador Tokio obteve um enorme aumento de desempenho ... mas que tipo de crescimento? </font><font style="vertical-align: inherit;">Dado que o novo agendador foi desenvolvido apenas, no mundo real ele ainda n√£o foi totalmente testado. </font><font style="vertical-align: inherit;">Aqui est√° o que sabemos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, o novo agendador √© muito mais r√°pido em micro benchmarks:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejador antigo </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> teste chained_spawn ... banco: 2.019.796 ns / iter (+/- 302.168)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
teste ping_pong ... banco: 1.279.948 ns / iter (+/- 154.365)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
teste spawn_many ... banco: 10.283.608 ns / iter (+/- 1.284.275)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test yield_many ... bench: 21.450.748 ns / iter (+/- 1.201.337) </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejador novo </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> teste chained_spawn ... banco: 168.854 ns / iter (+/- 8.339)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
teste ping_pong ... banco: 562.659 ns / iter (+/- 34.410)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
teste spawn_many ... banco: 7.320.737 ns / iter (+/- 264.620)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test yield_many ... bench: 14.638.563 ns / iter (+/- 1.573.678) </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta refer√™ncia inclui o seguinte: </font></font><br><br><ul><li> <code>chained_spawn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerar novas tarefas recursivamente, ou seja, gerar uma tarefa que gera outra tarefa, que tamb√©m gera uma tarefa etc. </font></font><br></li><li> <code>ping_pong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seleciona um canal </font></font><code>oneshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e gera uma tarefa que envia uma mensagem nesse canal. </font><font style="vertical-align: inherit;">A tarefa original est√° aguardando uma mensagem. </font><font style="vertical-align: inherit;">Este √© o teste mais pr√≥ximo do "mundo real".</font></font><br></li><li> <code>spawn_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica a implementa√ß√£o de tarefas no planejador, ou seja, gera tarefas fora do seu contexto. </font></font><br></li><li> <code>yield_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verifica o despertar da tarefa independente. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferen√ßa nos benchmarks √© muito impressionante. </font><font style="vertical-align: inherit;">Mas como isso ser√° refletido no "mundo real"? </font><font style="vertical-align: inherit;">√â dif√≠cil dizer com certeza, mas tentei executar os benchmarks </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° o servidor Hyper mais simples, cujo desempenho √© medido usando </font></font><code>wrk -t1 -c50 -d10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejador antigo </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Executando o teste 10s @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 threads e 50 conex√µes</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Estat√≠sticas do segmento Avg Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Lat√™ncia 371.53us 99.05us 1.97ms 60.53%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 114,61k 8,45k 133,85k 67,00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1139307 solicita√ß√µes em 10.00s, 95.61MB de leitura</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pedidos / s: 113923.19</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer√™ncia / s: 9,56MB </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planejador novo </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Executando o teste 10s @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 threads e 50 conex√µes</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Estat√≠sticas do segmento Avg Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Lat√™ncia 275.05us 69.81us 1.09ms 73.57%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 153.17k 10.68k 171.51k 71.00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1522671 solicita√ß√µes em 10.00s, 127.79MB de leitura</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pedidos / s: 152258.70</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer√™ncia / s: 12,78MB </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos um aumento de 34% nas solicita√ß√µes por segundo logo ap√≥s a altera√ß√£o do agendador! A primeira vez que vi isso, fiquei muito feliz, porque esperava um aumento de no m√°ximo 5-10%. Mas ent√£o fiquei triste, porque esse resultado tamb√©m mostrou que o antigo agendador do Tokio n√£o √© t√£o bom. Lembrei-me de que a Hyper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© l√≠der em classifica√ß√µes do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">TechEmpower</font></a><font style="vertical-align: inherit;"> . √â interessante ver como o novo planejador afetar√° as classifica√ß√µes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o cliente e servidor gRPC, com o novo agendador acelerou em cerca de 10%, o que √© bastante impressionante, considerando que o Tonic ainda n√£o est√° totalmente otimizado.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estou realmente muito feliz por finalmente concluir este projeto ap√≥s v√°rios meses de trabalho. </font><font style="vertical-align: inherit;">Esse √© um grande aprimoramento da E / S ass√≠ncrona do Rust. </font><font style="vertical-align: inherit;">Estou muito satisfeito com as melhorias feitas. </font><font style="vertical-align: inherit;">Ainda h√° muito espa√ßo para otimiza√ß√£o no c√≥digo Tokio, ent√£o ainda n√£o terminamos a melhoria de desempenho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que o material do artigo seja √∫til para colegas que tentam escrever seu agendador de tarefas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472242/">https://habr.com/ru/post/pt472242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472228/index.html">9 truques para trabalhar com o c√≥digo do Visual Studio</a></li>
<li><a href="../pt472230/index.html">Chips para ML - fale sobre novos produtos</a></li>
<li><a href="../pt472232/index.html">Do ‚ÄúColor Extender para ZX-Spectrum‚Äù ao ZX-Poly</a></li>
<li><a href="../pt472234/index.html">Criptomoeda: ainda √© um freeloader ou um parceiro?</a></li>
<li><a href="../pt472240/index.html">Sobre gamification. O que √©, por que e como faz√™-lo? Apar√™ncia do desenvolvedor</a></li>
<li><a href="../pt472246/index.html">React + IndexDb + atualiza√ß√£o autom√°tica = quase AsyncRedux</a></li>
<li><a href="../pt472248/index.html">Como fundimos a programa√ß√£o final do IT-Planet</a></li>
<li><a href="../pt472252/index.html">Eventos digitais em Moscou, de 21 a 28 de outubro</a></li>
<li><a href="../pt472254/index.html">Eventos digitais em S√£o Petersburgo, de 21 a 28 de outubro</a></li>
<li><a href="../pt472258/index.html">Como "aprender a aprender" - melhore a aten√ß√£o plena</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>