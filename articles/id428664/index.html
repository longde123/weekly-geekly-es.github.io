<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥠 🕎 🐖 Boot kernel Linux. Bagian 1 🏙️ 🤲🏼 ⛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari bootloader ke kernel 

 Jika Anda membaca artikel sebelumnya, Anda tahu tentang hobi baru saya untuk pemrograman tingkat rendah. Saya menulis beb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Boot kernel Linux. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>Dari bootloader ke kernel</b> <br><br>  Jika Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya, Anda tahu tentang hobi baru saya untuk pemrograman tingkat rendah.  Saya menulis beberapa artikel tentang pemrograman assembler untuk <code>x86_64</code> Linux dan pada saat yang sama mulai menyelami kode sumber dari kernel Linux. <br><br>  Saya sangat tertarik untuk memahami bagaimana hal-hal tingkat rendah bekerja: bagaimana program berjalan di komputer saya, bagaimana mereka berada di memori, bagaimana kernel mengelola proses dan memori, bagaimana tumpukan jaringan bekerja pada tingkat rendah, dan banyak lagi.  Jadi, saya memutuskan untuk menulis seri artikel lain tentang kernel Linux untuk <b>arsitektur x86_64</b> . <br><br>  Harap dicatat bahwa saya bukan pengembang kernel profesional dan tidak menulis kode kernel di tempat kerja.  Ini hanya hobi.  Saya hanya suka hal-hal tingkat rendah dan menarik untuk menyelidiki mereka.  Karena itu, jika Anda melihat ada kebingungan atau pertanyaan / komentar muncul, hubungi saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Twitter</a> , melalui <a href="">surat</a> atau hanya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket</a> .  Saya akan berterima kasih. <br><a name="habracut"></a><br>  Semua artikel diterbitkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub</a> , dan jika ada yang salah dengan bahasa Inggris saya atau konten artikel, jangan ragu untuk mengirim permintaan tarik. <br><br>  <i>Harap dicatat bahwa ini bukan dokumentasi resmi, tetapi hanya pelatihan dan berbagi pengetahuan.</i> <br><br>  <b>Pengetahuan yang dibutuhkan</b> <br><br><ul><li>  Memahami Kode C </li><li>  Memahami Kode Assembler (AT&amp;T Syntax) </li></ul><br>  Bagaimanapun, jika Anda baru mulai mempelajari alat-alat tersebut, saya akan mencoba menjelaskan sesuatu dalam artikel ini dan selanjutnya.  Oke, dengan perkenalan selesai, sekarang saatnya untuk menyelami kernel Linux dan hal-hal tingkat rendah. <br><br>  Saya mulai menulis buku ini pada zaman kernel Linux 3.18, dan banyak yang telah berubah sejak saat itu.  Jika ada perubahan, saya akan memperbarui artikel yang sesuai. <br><br><h1>  Tombol daya ajaib, apa selanjutnya? </h1><br>  Meskipun ini adalah artikel tentang kernel Linux, kami belum mencapainya - setidaknya di bagian ini.  Segera setelah Anda menekan tombol daya ajaib di laptop atau komputer desktop, itu mulai berfungsi.  Motherboard mengirimkan sinyal ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catu daya</a> .  Setelah menerima sinyal, ini memberi komputer jumlah listrik yang diperlukan.  Segera setelah motherboard menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinyal "Power OK"</a> , ia mencoba memulai CPU.  Dia membuang semua data yang tersisa di register dan menetapkan nilai yang telah ditentukan untuk masing-masing data. <br><br>  Prosesor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">80386</a> dan versi yang lebih baru harus memiliki nilai berikut di register CPU setelah reboot: <br><br><pre>  IP 0xfff0
 Pemilih CS 0xf000
 Basis CS 0xffff0000 </pre><br>  Prosesor mulai bekerja dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode nyata</a> .  Mari kita kembali sedikit dan mencoba memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">segmentasi memori</a> dalam mode ini.  Mode nyata didukung pada semua prosesor yang kompatibel dengan x86: dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8086</a> ke prosesor Intel 64-bit modern.  Prosesor 8086 menggunakan bus alamat 20-bit, yaitu, ia dapat bekerja dengan ruang alamat <code>0-0xFFFFF</code> atau <code>1 </code> .  Tetapi hanya memiliki register 16-bit dengan alamat maksimum <code>2^16-1</code> atau <code>0xffff</code> (64 kilobyte). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Segmentasi memori</a> diperlukan untuk menggunakan seluruh ruang alamat yang tersedia.  Semua memori dibagi menjadi beberapa segmen kecil dengan ukuran tetap <code>65536</code> byte (64 KB).  Karena dengan register 16-bit kita tidak dapat mengakses memori di atas 64 KB, metode alternatif dikembangkan. <br><br>  Alamat terdiri dari dua bagian: 1) pemilih segmen dengan alamat basis;  2) offset dari alamat dasar.  Dalam mode nyata, alamat dasar <code>  * 16</code> segmen <code>  * 16</code> .  Dengan demikian, untuk mendapatkan alamat fisik dalam memori, Anda perlu mengalikan bagian pemilih segmen dengan 16 dan menambahkan offset ke dalamnya: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Misalnya, jika register <code>CS:IP</code> memiliki nilai <code>0x2000:0x0010</code> , maka alamat fisik yang sesuai akan seperti ini: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  Tetapi jika Anda mengambil pemilih dari segmen terbesar dan <code>0xffff:0xffff</code> offset <code>0xffff:0xffff</code> , Anda mendapatkan alamat: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  yaitu, <code>65520</code> byte setelah megabyte pertama.  Karena hanya satu megabyte yang tersedia dalam mode nyata, <code>0x10ffef</code> menjadi <code>0x00ffef</code> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">garis A20</a> dinonaktifkan. <br><br>  Nah, sekarang kita tahu sedikit tentang mode nyata dan pengalamatan memori dalam mode ini.  Mari kita kembali ke pembahasan nilai register setelah reset. <br><br>  Register <code>CS</code> terdiri dari dua bagian: pemilih segmen yang terlihat dan alamat basis tersembunyi.  Meskipun alamat dasar biasanya dibentuk dengan mengalikan nilai pemilih segmen dengan 16, selama reset perangkat keras, pemilih segmen dalam register CS adalah <code>0xf000</code> , dan alamat dasar adalah <code>0xffff0000</code> .  Prosesor menggunakan alamat basis khusus ini sampai CS berubah. <br><br>  Alamat awal dibentuk dengan menambahkan alamat basis ke nilai dalam register EIP: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  Kami mendapatkan <code>0xfffffff0</code> , yaitu 16 byte di bawah 4 GB.  Titik ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vektor reset</a> .  Ini adalah lokasi di memori di mana CPU menunggu instruksi pertama untuk dieksekusi setelah reset: operasi melompat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jmp</a> ), yang biasanya menunjukkan titik masuk BIOS.  Misalnya, jika Anda melihat kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coreboot</a> ( <code>src/cpu/x86/16bit/reset16.inc</code> ), kita akan melihat: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Di sini kita melihat kode operasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opcode</a> ) <code>jmp</code> , yaitu <code>0xe9</code> , dan alamat tujuan <code>_start16bit - ( . + 2)</code> . <br><br>  Kita juga melihat bahwa bagian <code>reset</code> adalah 16 byte, dan mengkompilasi untuk dijalankan dari alamat <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ): <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  BIOS sekarang mulai;  Setelah menginisialisasi dan memeriksa perangkat keras BIOS, Anda perlu menemukan perangkat boot.  Urutan boot disimpan dalam konfigurasi BIOS.  Ketika mencoba untuk boot dari hard drive, BIOS mencoba untuk menemukan sektor boot.  Pada disk yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipartisi MBR</a> , sektor boot disimpan di 446 byte pertama dari sektor pertama, di mana setiap sektor adalah 512 byte.  Dua byte terakhir dari sektor pertama adalah <code>0x55</code> dan <code>0xaa</code> .  Mereka menunjukkan kepada BIOS bahwa itu adalah perangkat boot. <br><br>  Sebagai contoh: <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br>  Kami mengumpulkan dan menjalankan: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QEMU</a> menerima perintah untuk menggunakan <code>boot</code> binary yang baru saja kita buat sebagai disk image.  Karena file biner yang dihasilkan di atas memenuhi persyaratan sektor boot (mulai dari <code>0x7c00</code> dan diakhiri dengan urutan ajaib), QEMU akan mempertimbangkan biner sebagai master boot record (MBR) dari image disk. <br><br>  Anda akan melihat: <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  Dalam contoh ini, kita melihat bahwa kode berjalan dalam mode nyata 16-bit dan dimulai pada alamat <code>0x7c00</code> dalam memori.  Setelah memulai, ini menyebabkan interupsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">0x10</a> , yang hanya mencetak karakter <code>!</code>  ;  mengisi sisa 510 byte dengan nol dan diakhiri dengan dua byte ajaib <code>0xaa</code> dan <code>0x55</code> . <br><br>  Anda dapat melihat dump biner dengan utilitas <code>objdump</code> : <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Tentu saja, di sektor boot nyata, ada kode untuk melanjutkan proses boot dan tabel partisi bukannya sekelompok nol dan tanda seru :).  Mulai saat ini, BIOS mentransfer kontrol ke bootloader. <br><br>  <i>Catatan</i> : seperti dijelaskan di atas, CPU dalam mode nyata;  di mana perhitungan alamat fisik dalam memori adalah sebagai berikut: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Kami hanya memiliki register tujuan umum 16-bit, dan nilai maksimum register 16-bit adalah <code>0xffff</code> , sehingga pada nilai terbesar hasilnya adalah: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  di mana <code>0x10ffef</code> adalah <code>1  + 64  - 16 </code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosesor 8086</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prosesor</a> pertama dengan mode real) memiliki garis alamat 20-bit.  Sejak <code>2^20 = 1048576</code> , memori yang tersedia sebenarnya adalah 1 MB. <br><br>  Secara umum, pengalamatan memori mode-nyata adalah sebagai berikut: <br><br><pre>  0x00000000 - 0x000003FF - tabel vektor interupsi dari mode real
 0x00000400 - 0x000004FF - Area data BIOS
 0x00000500 - 0x00007BFF - tidak digunakan
 0x00007C00 - 0x00007DFF - bootloader kami
 0x00007E00 - 0x0009FFFF - tidak digunakan
 0x000A0000 - 0x000BFFFF - RAM Video (VRAM) 
 0x000B0000 - 0x000B7777 - memori video monokrom
 0x000B8000 - 0x000BFFFF - memori video mode warna
 0x000C0000 - 0x000C7FFF - Video ROM BIOS
 0x000C8000 - 0x000EFFFF - area bayangan (BIOS Shadow)
 0x000F0000 - 0x000FFFFF - BIOS sistem </pre><br>  Di awal artikel tertulis bahwa instruksi pertama untuk prosesor terletak di <code>0xFFFFFFF0</code> , yang jauh lebih dari <code>0xFFFFF</code> (1 MB).  Bagaimana cara CPU mengakses alamat ini dalam mode nyata?  Jawab dalam dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coreboot</a> : <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  Pada awal eksekusi, BIOS tidak dalam RAM, tetapi dalam ROM. <br><br><h1>  Bootloader </h1><br>  Kernel Linux dapat dimuat dengan bootloader yang berbeda, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GRUB 2</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">syslinux</a> .  Kernel memiliki protokol boot yang mendefinisikan persyaratan bootloader untuk mengimplementasikan dukungan Linux.  Dalam contoh ini, kami bekerja dengan GRUB 2. <br><br>  Melanjutkan proses booting, BIOS memilih perangkat booting dan memindahkan kontrol ke sektor boot, eksekusi dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">boot.img</a> .  Karena ukurannya yang terbatas, ini adalah kode yang sangat sederhana.  Ini berisi pointer untuk menuju ke gambar GRUB 2. Dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskboot.img</a> dan biasanya disimpan segera setelah sektor pertama di ruang yang tidak digunakan sebelum partisi pertama.  Kode di atas memuat ke memori sisa gambar yang berisi kernel GRUB 2 dan driver untuk memproses sistem file.  Setelah itu, fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grub_main dijalankan</a> . <br><br>  Fungsi <code>grub_main</code> menginisialisasi konsol, mengembalikan alamat dasar untuk modul, mengatur perangkat root, memuat / mem-parsing file konfigurasi grub, memuat modul, dll.  Pada akhir eksekusi, itu menempatkan grub ke mode normal.  Fungsi <code>grub_normal_execute</code> (dari file sumber <code>grub-core/normal/main.c</code> ) menyelesaikan persiapan terakhir dan menampilkan menu untuk memilih sistem operasi.  Ketika kita memilih salah satu item menu grub, fungsi <code>grub_menu_execute_entry</code> , yang mengeksekusi perintah <code>boot</code> grub dan memuat OS yang dipilih. <br><br>  Sebagaimana ditunjukkan dalam protokol boot kernel, bootloader harus membaca dan mengisi beberapa bidang header instalasi kernel, yang dimulai dengan offset <code>0x01f1</code> dari kode instalasi kernel.  Offset ini ditunjukkan dalam <a href="">skrip</a> tautan.  <a href="">Lengkungan</a> header kernel <a href="">/ x86 / boot / header.</a> Dimulai dengan: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  Bootloader harus mengisi ini dan header lainnya (yang ditandai hanya sebagai tipe <code>write</code> di protokol boot Linux, seperti dalam contoh ini) dengan nilai-nilai yang diterima dari baris perintah atau dihitung pada saat boot.  Sekarang kita tidak akan membahas deskripsi dan penjelasan untuk semua bidang header.  Kami akan membahas nanti bagaimana kernel menggunakannya.  Untuk deskripsi semua bidang, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol unduhan</a> . <br><br>  Seperti yang Anda lihat dalam protokol boot kernel, memori akan ditampilkan sebagai berikut: <br><br><pre>  |  Mode Kernel yang Dilindungi |
 100000 + ------------------------ +
          |  Pemetaan I / O |
 0A0000 + ------------------------ +
          |  Cadangan  untuk BIOS |  Biarkan sebanyak mungkin gratis
          ~ ~
          |  Baris perintah |  (mungkin juga di bawah X + 10.000)
 X + 10000 + ------------------------ +
          |  Tumpukan / tumpukan |  Untuk menggunakan kode mode kernel nyata
 X + 08000 + ------------------------ +
          |  Instalasi Kernel |  Kode mode nyata kernel
          |  Sektor boot kernel |  Sektor boot kernel lawas
        X + ------------------------ +
          |  Loader |  &lt;- Titik masuk sektor boot 0x7C00
 001000 + ------------------------ +
          |  Cadangan  untuk MBR / BIOS |
 000800 + ------------------------ +
          |  Biasanya digunakan  MBR |
 000600 + ------------------------ +
          |  Digunakan  Hanya BIOS |
 000000 + ------------------------ +
</pre><br>  Jadi, ketika loader mentransfer kontrol ke kernel, itu dimulai dengan alamat: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  di mana <code>X</code> adalah alamat sektor boot kernel.  Dalam kasus kami, <code>X</code> adalah <code>0x10000</code> , seperti yang terlihat di memori dump: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  Bootloader memindahkan kernel Linux ke memori, mengisi bidang header, dan kemudian pindah ke alamat memori yang sesuai.  Sekarang kita dapat langsung menuju ke kode instalasi kernel. <br><br><h1>  Awal dari fase instalasi kernel </h1><br>  Akhirnya kita berada di intinya!  Meskipun secara teknis belum berjalan.  Pertama, bagian instalasi kernel perlu mengkonfigurasi sesuatu, termasuk dekompresor dan beberapa hal dengan manajemen memori.  Setelah semua ini, dia akan membongkar inti yang sebenarnya dan pergi ke sana.  Instalasi dimulai pada <a href="">arch / x86 / boot / header.</a> Dengan karakter <a href="">_start</a> . <br><br>  Pada pandangan pertama, ini mungkin tampak sedikit aneh, karena ada beberapa instruksi di depannya.  Tapi dulu sekali, kernel Linux memiliki bootloader sendiri.  Sekarang jika Anda menjalankan, misalnya, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  Anda akan melihat: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  Sebenarnya, file <code>header.S</code> dimulai dengan angka ajaib <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MZ</a> (lihat screenshot dump di atas), teks pesan kesalahan dan header <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PE</a> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  Diperlukan untuk memuat sistem operasi dengan dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UEFI</a> .  Kami akan mempertimbangkan perangkatnya dalam bab-bab berikut. <br><br>  Titik masuk aktual untuk menginstal kernel: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  Bootloader (grub2 dan lainnya) tahu tentang hal ini (mengimbangi <code>0x200</code> dari <code>MZ</code> ) dan langsung menuju ke sana, meskipun <code>header.S</code> dimulai dari bagian <code>.bstext</code> , di mana teks pesan kesalahan berada: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Titik masuk instalasi kernel: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Di sini kita melihat kode operasi <code>jmp</code> ( <code>0xeb</code> ), yang menuju ke titik <code>start_of_setup-1f</code> .  Dalam notasi <code>Nf</code> , misalnya, <code>2f</code> mengacu pada label lokal <code>2:</code>  Dalam kasus kami, ini adalah label <code>1</code> , yang hadir segera setelah transisi, dan berisi sisa header pengaturan.  Segera setelah header instalasi, kita melihat bagian <code>.entrytext</code> , yang dimulai dengan label <code>start_of_setup</code> . <br><br>  Ini adalah kode pertama yang sebenarnya dieksekusi (selain instruksi lompatan sebelumnya, tentu saja).  Setelah bagian dari instalasi kernel menerima kontrol dari loader, instruksi <code>jmp</code> pertama terletak pada offset <code>0x200</code> dari awal mode kernel sebenarnya, yaitu, setelah 512 byte pertama.  Ini dapat dilihat di protokol boot kernel Linux dan dalam kode sumber grub2: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  Dalam kasus kami, kernel melakukan boot pada alamat <code>0x10000</code> .  Ini berarti bahwa setelah memulai instalasi kernel, register segmen akan memiliki nilai-nilai berikut: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  Setelah memulai <code>start_of_setup</code> kernel harus melakukan hal berikut: <br><br><ul><li>  Pastikan semua nilai register segmen sama </li><li>  Jika perlu, konfigurasikan tumpukan yang benar </li><li>  Konfigurasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bss</a> </li><li>  Masuk ke kode C di <a href="">arch / x86 / boot / main.c</a> </li></ul><br>  Mari kita lihat bagaimana ini diterapkan. <br><br><h1>  Penjajaran Kasus Segmen </h1><br>  Pertama-tama, kernel memeriksa apakah register segmen <code>ds</code> dan <code>es</code> menunjuk ke alamat yang sama.  Itu kemudian membersihkan bendera arah menggunakan <code>cld</code> : <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  Seperti yang saya tulis sebelumnya, grub2 secara default memuat kode instalasi kernel pada <code>0x10000</code> , dan <code>cs</code> pada <code>0x10200</code> , karena eksekusi tidak dimulai dari awal file, tetapi dari transisi di sini: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  Ini adalah offset <code>512</code> byte dari <a href="">4d 5a</a> .  Juga perlu untuk menyelaraskan <code>cs</code> dari <code>0x10200</code> ke <code>0x10000</code> , seperti semua register segmen lainnya.  Setelah itu instal tumpukan: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  Instruksi ini mendorong nilai <code>ds</code> ke stack, diikuti oleh alamat label <a href="">6</a> dan instruksi <code>lretw</code> , yang memuat alamat label <code>6</code> ke dalam register <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penghitung perintah</a> dan memuat <code>cs</code> dengan nilai <code>ds</code> .  Setelah itu, <code>ds</code> dan <code>cs</code> akan memiliki nilai yang sama. <br><br><h1>  Pengaturan tumpukan </h1><br>  Hampir semua kode ini adalah bagian dari proses mempersiapkan lingkungan C dalam mode nyata.  Langkah selanjutnya adalah memeriksa nilai register <code>ss</code> dan membuat tumpukan yang benar jika nilai <code>ss</code> salah: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  Ini dapat memicu tiga skenario berbeda: <br><br><ul><li>  <code>ss</code> nilai valid <code>0x1000</code> (seperti dengan semua register lain kecuali <code>cs</code> ) </li><li>  <code>ss</code> nilai yang tidak valid dan bendera <code>CAN_USE_HEAP</code> diatur (lihat di bawah) </li><li>  <code>ss</code> nilai yang tidak valid dan bendera <code>CAN_USE_HEAP</code> tidak disetel (lihat di bawah) </li></ul><br>  Pertimbangkan semua skenario secara berurutan: <br><br><ul><li>  <code>ss</code> nilai yang valid ( <code>0x1000</code> ).  Dalam hal ini, kita pergi ke label 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Di sini kita mengatur perataan register <code>dx</code> (yang berisi nilai <code>sp</code> ditunjukkan oleh bootloader) menjadi <code>4</code> byte dan memeriksa nol.  Jika nol, maka kita masukkan nilai <code>0xfffc</code> <code>dx</code> (alamat selaras <code>4</code> byte sebelum ukuran segmen maksimum 64 KB).  Jika tidak sama dengan nol, maka kami terus menggunakan nilai <code>sp</code> ditentukan oleh bootloader ( <code>0xf7f4</code> dalam kasus kami).  Kemudian kami menempatkan nilai <code>ax</code> dalam <code>ss</code> , yang menyimpan alamat segmen yang benar <code>0x1000</code> dan menetapkan <code>sp</code> benar.  Sekarang kita memiliki tumpukan yang benar: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  Dalam skenario kedua, <code>ss != ds</code> .  Pertama-tama kita meletakkan nilai <a href="">_end</a> (alamat akhir kode instalasi) dalam <code>dx</code> dan memeriksa <code>loadflags</code> field header, menggunakan instruksi <code>testb</code> untuk memeriksa apakah heap dapat digunakan.  <a href="">loadflags</a> adalah tajuk bitmask yang didefinisikan sebagai berikut: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  dan sebagaimana ditunjukkan dalam protokol boot: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  Jika bit <code>CAN_USE_HEAP</code> , maka dalam <code>dx</code> kami menetapkan nilai <code>heap_end_ptr</code> (yang menunjuk ke <code>_end</code> ) dan menambahkan <code>STACK_SIZE</code> ke sana (ukuran tumpukan minimum adalah <code>1024</code> byte).  Setelah itu, buka label <code>2</code> (seperti pada kasus sebelumnya) dan buat tumpukan yang benar. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  Jika <code>CAN_USE_HEAP</code> tidak disetel, cukup gunakan tumpukan minimum dari <code>_end</code> ke <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  Penyiapan BSS </h1><br>  Dua langkah lagi diperlukan sebelum beralih ke kode C utama: ini mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">area BSS</a> dan memverifikasi tanda tangan "ajaib".  Verifikasi tanda tangan terlebih dahulu: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  Instruksi hanya membandingkan <a href="">setup_sig</a> dengan angka ajaib 0x5a5aaa55.  Jika mereka tidak sama, kesalahan fatal dilaporkan. <br><br>  Jika angka ajaib cocok dan kami memiliki satu set register segmen dan tumpukan yang benar, maka yang tersisa hanyalah mengonfigurasi bagian BSS sebelum melanjutkan ke kode C. <br><br>  Bagian BSS digunakan untuk menyimpan data yang tidak diinisialisasi yang dialokasikan secara statis.  Linux dengan hati-hati memeriksa apakah area memori ini diatur ulang: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  Pertama, alamat awal <a href="">__bss_start</a> dipindahkan ke <code>di</code> .  Kemudian alamat <code>_end + 3</code> (+3 untuk perataan dengan 4 byte) dipindahkan ke <code>cx</code> .  Register <code>eax</code> dihapus (menggunakan instruksi <code>xor</code> ), ukuran partisi bss ( <code>cx-di</code> ) dihitung, dan ditempatkan di <code>cx</code> .  Kemudian <code>cx</code> dibagi menjadi empat (ukuran "kata") dan instruksi <code>stosl</code> digunakan <code>stosl</code> , menyimpan nilai <code></code> (nol) di alamat yang menunjuk ke <code>di</code> , secara otomatis meningkatkan <code>di</code> oleh empat dan mengulanginya sampai <code></code> mencapai nol).  Efek bersih dari kode ini adalah nol dituliskan ke semua kata dalam memori dari <code>__bss_start</code> ke <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  Pergi ke utama </h1><br>  Itu saja: kami memiliki tumpukan dan BSS, sehingga Anda dapat pergi ke fungsi C <code>main()</code> : <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  Fungsi <code>main()</code> terletak di <a href="">arch / x86 / boot / main.c.</a>  Kami akan membicarakannya di bagian selanjutnya. <br><br><h1>  Kesimpulan </h1><br>  Ini adalah akhir dari bagian pertama tentang perangkat kernel Linux.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan atau saran, hubungi saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , melalui </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau cukup buat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada bagian berikutnya kita akan melihat kode pertama di C, yang dilakukan selama instalasi Linux kernel, pelaksanaan memori sub-program, seperti </font></font><code>memset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>earlyprintk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, awal implementasi dan inisialisasi dari konsol, dan banyak lagi.</font></font><br><br><h1>  Referensi </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Programmer Intel 80386 1986</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bootloader minimal untuk arsitektur Intel</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8086</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80386</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atur Ulang Vektor</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode nyata</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol boot kernel Linux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panduan Pengembang Coreboot</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Interrupt Ralph Brown</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber daya</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinyal “Daya OK”</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428664/">https://habr.com/ru/post/id428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428654/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 15: Perangkat Lunak Medis, Bagian 2</a></li>
<li><a href="../id428656/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 15: Perangkat Lunak Medis, Bagian 3</a></li>
<li><a href="../id428658/index.html">Lokakarya pendidikan gratis di kantor Mail.Ru Group</a></li>
<li><a href="../id428660/index.html">Mengaktifkan Kebijakan Permintaan Tarik yang Dapat Diperpanjang dalam VSTS untuk Mendukung Proses Pengembangan</a></li>
<li><a href="../id428662/index.html">Tugas pemrograman ritel</a></li>
<li><a href="../id428666/index.html">Bagaimana saya membuat animasi yang mengubah suasana hati menggunakan topeng CSS</a></li>
<li><a href="../id428668/index.html">Blizzard mengumumkan rilis rilis ulang WarCraft III pada tahun 2019. Buka pre-order</a></li>
<li><a href="../id428672/index.html">Gambaran Umum QuietOn Active Squelch</a></li>
<li><a href="../id428674/index.html">Membangun pencarian perutean / semantik klien di Profi.ru</a></li>
<li><a href="../id428676/index.html">Mematahkan fondasi dasar C #: mengalokasikan memori untuk tipe referensi pada stack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>