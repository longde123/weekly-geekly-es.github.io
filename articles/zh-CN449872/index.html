<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛽️ 🌺 🍈 RxVMS基础：RxCommand和GetIt 🥕 🛎️ 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是我的Flutter体系结构系列的第四部分： 


- 引言 
- Dart Streams基础知识 
- RxDart：流程的神奇转变 
- RxVMS基础：RxCommand和GetIt（本文） 
- RxVMS：服务和管理器 
- RxVMS：独立的小部件 
- 使用RxVMS进行用户身份验...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxVMS基础：RxCommand和GetIt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449872/"><p> 这是我的Flutter体系结构系列的第四部分： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dart Streams基础知识</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxDart：流程的神奇转变</a> </li><li>  <strong>RxVMS基础：RxCommand和GetIt（本文）</strong> </li><li>  RxVMS：服务和管理器 </li><li>  RxVMS：独立的小部件 </li><li> 使用RxVMS进行用户身份验证 </li></ul><br><p> 尽管前两部分显然与RxVMS模式无关，但是对于清楚地了解此方法而言，它们是必需的。 现在，我们转到在应用程序中使用RxVMS所需的最重要的程序包。 </p><a name="habracut"></a><br><h2 id="getit-bystryy-servicelocator">  GetIt：快速ServiceLocator </h2><br><p> 当您回顾显示应用程序中各种RxVMS元素的图表时... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9cf/f8a/7c1/9cff8a7c191e44a7f4f269c3b0ee97cd.png" alt="图片"></p><br><p> ...也许您想知道各种映射，管理器和服务如何相互了解。 更重要的是，您可能想知道一个元素如何访问另一个元素的功能。 </p><br><p> 通过许多不同的方法（例如继承的小部件，IoC容器，DI ...），我个人更喜欢服务定位器。 在这方面，我有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GetIt</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特别文章</a> -这种方法的实现，但是在这里我将略微谈谈该主题。 通常，您只需在该服务中注册对象一次，然后就可以在整个应用程序中访问它们。 有点单身……但具有更大的灵活性。 </p><br><h2 id="ispolzovanie"> 使用方法 </h2><br><p> 使用GetIt很明显。 在应用程序的最开始，您注册了您计划随后使用的服务和/或管理器。 将来，只需调用GetIt方法即可访问已注册类的实例。 </p><br><p> 一个不错的功能是，您可以像具体实现一样注册接口或抽象类。 访问实例时，只需使用接口/抽象，即可在注册期间轻松替换必要的实现。 这使您可以轻松地将实际服务切换到MockService。 </p><br><h2 id="nemnogo-praktiki"> 一点练习 </h2><br><p> 我通常通过全局变量在名为service_locator.dart的文件中初始化SeviceLocator。 这样就为整个项目获得了一个全局变量。 </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    GetIt sl = new GetIt(); void setUpServiceLocator(ErrorReporter reporter) { //  // [registerSingleton]  -  . //   . // sl.get&lt;ErrorReporter&gt;.get()    . sl.registerSingleton&lt;ErrorReporter&gt;(reporter); // [registerLazySingleton]   ,       // sl.get&lt;ImageService&gt;.get()            . sl.registerLazySingleton&lt;ImageService&gt;(() =&gt; new ImageServiceImplementation()); sl.registerLazySingleton&lt;MapService&gt;(() =&gt; new MapServiceImplementation()); //  sl.registerSingleton&lt;UserManager&gt;(new UserManagerImplementation()); sl.registerLazySingleton&lt;EventManager&gt;(() =&gt; new EvenManagerImplementation()); sl.registerLazySingleton&lt;ImageManager&gt;(() =&gt; new ImageManagerImplementation()); sl.registerLazySingleton&lt;AppManager&gt;(() =&gt; new AppManagerImplementation());</span></span></code> </pre> <br><p> 每当您要访问时，只需致电 </p><br><pre> <code class="cpp hljs">RegistrationType object = sl.get&lt;RegistrationType&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  GetIt  `callable`,   : RegistrationType object2 = sl&lt;RegistrationType&gt;();</span></span></code> </pre> <br><p>  <strong>极其重要的注意事项：</strong>使用GetIt时，导入文件时始终使用相同的样式-包（推荐）或相对路径，但不能同时使用两种方法。 这是因为Dart不管这些文件的身份如何，都将它们视为不同的文件。 </p><br><p> 如果您对此感到困难，请访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的博客</a>以获取详细信息。 </p><br><h2 id="rxcommand"> 接收命令 </h2><br><p> 现在，我们使用GetIt来访问任何地方的对象（包括用户界面），我想描述如何实现UI事件的处理函数。 最简单的方法是将功能添加到管理器并在小部件中调用它们： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookUpZip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String zip)</span></span></span></span>; }</code> </pre> <br><p> 然后在用户界面中 </p><br><pre> <code class="cpp hljs">TextField(onChanged: sl.get&lt;SearchManager&gt;().lookUpZip,)</code> </pre> <br><p> 这将在<code>TextField</code>每次更改时<code>lookUpZip</code> 。 但是我们如何将结果传递给我们？ 由于我们希望是反应式的，因此可以在<code>SearchManager</code>添加一个<code>StreamController</code> ： </p><br><pre> <code class="cpp hljs">abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> Stream&lt;String&gt; get nameOfCity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookUpZip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String zip)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManagerImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class">{</span></span> @override Stream&lt;String&gt; get nameOfCity =&gt; cityController.stream; StreamController&lt;String&gt; cityController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController(); @override Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; lookUpZip(String zip) async { var cityName = await sl.get&lt;ZipApiService&gt;().lookUpZip(zip); cityController.add(cityName); } }</code> </pre> <br><p> 并在用户界面中： </p><br><pre> <code class="cpp hljs">StreamBuilder&lt;String&gt;( initialData:<span class="hljs-string"><span class="hljs-string">'', stream: sl.get&lt;SearchManager&gt;().nameOfCity, builder: (context, snapshot) =&gt; Text(snapShot.data);</span></span></code> </pre> <br><p> 尽管此方法有效，但这不是最佳方法。 这里是问题： </p><br><ul><li> 冗余代码-如果我们不想在公共领域中明确显示它，我们总是必须为其创建一个方法StreamController和一个getter </li><li> 忙状态-如果我们想在函数执行其工作时显示Spinner怎么办？ </li><li> 错误处理-如果一个函数抛出异常怎么办？ </li></ul><br><p> 当然，我们可以添加更多StreamController来处理状态和错误...但是很快它变得很乏味，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rx_command</a>包在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>派上用场。 </p><br><p>  <code>RxCommand</code>解决了上述所有问题，甚至更多。  <code>RxCommand</code>封装了一个函数（同步或异步），并将其结果自动发布到流中。 </p><br><p> 使用RxCommand，我们可以这样重写我们的管理器： </p><br><pre> <code class="cpp hljs">abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> RxCommand&lt;String,String&gt; lookUpZipCommand; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManagerImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class">{</span></span> @override RxCommand&lt;String,String&gt; lookUpZipCommand; SearchManagerImplementation() { lookUpZipCommand = RxCommand.createAsync((zip) =&gt; sl.get&lt;ZipApiService&gt;().lookUpZip(zip)); } }</code> </pre> <br><p> 并在用户界面中： </p><br><pre> <code class="cpp hljs">TextField(onChanged: sl.get&lt;SearchManager&gt;().lookUpZipCommand,) ... StreamBuilder&lt;String&gt;( initialData:<span class="hljs-string"><span class="hljs-string">'', stream: sl.get&lt;SearchManager&gt;().lookUpZipCommand, builder: (context, snapshot) =&gt; Text(snapShot.data);</span></span></code> </pre> <br><p> 这更加简洁易读。 </p><br><h2 id="rxcommand-v-detalyah">  RxCommand详细 </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0aa/485/a85/0aa485a85b55c760e32b482a6c00b758.png"></p><br><p>  RxCommand具有一个输入和五个输出Observables： </p><br><ul><li><p>  <strong>canExecuteInput</strong>是一个可选的<code>Observable&lt;bool&gt;</code> ，您可以在创建RxCommand时将其传递给工厂函数。 根据接收到的最后一个值，它向RxCommand发出信号是否可以执行。 </p><br></li><li><p>  <strong>isExecuting</strong>是一个<code>Observable&lt;bool&gt;</code> ，它指示命令当前是否正在执行其功能。 团队繁忙时，无法重新运行。 如果要在运行时显示Spinner，请收听<code>isExecuting</code> </p><br></li><li><p>  <strong>canExecute</strong>是一个<code>Observable&lt;bool&gt;</code> ，它表示执行命令的能力。 例如，这与StreamBuilder配合得很好，可以在开/关状态之间更改按钮的外观。 <br>  <em>其含义如下：</em> </p><br><pre> <code class="cpp hljs">Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; canExecute = Observable.combineLatest2&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(canExecuteInput,isExecuting) =&gt; canExecuteInput &amp;&amp; !isExecuting).distinct.</code> </pre> <br><p>  <em>这意味着</em> </p><br><ul><li> 如果isExecuting返回<code>true</code>则为<code>true</code> </li><li> 仅当isExecuting返回<code>false</code>并且canExecuteInput不返回<code>false</code> ，它将返回<code>false</code> 。 </li></ul><br></li><li><p>  <strong>thrownExceptions</strong>是一个<code>Observable&lt;Exception&gt;</code> 。 打包函数可以抛出的所有异常都将被捕获并发送到此Observable。 如果发生错误，可以方便地收听并显示对话框。 </p><br></li><li><p>  <strong>（团队本身）</strong>实际上也是可观察的。 工作函数返回的值将在此通道上传输，因此您可以将RxCommand作为流参数直接传递给StreamBuilder </p><br></li><li><p>  <strong>结果</strong>在一个<code>Observable&lt;CommandResult&gt;</code>包含所有命令状态，其中<code>CommandResult</code>定义为 </p><br></li></ul><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Combined execution state of an `RxCommand` /// Will be issued for any state change of any of the fields /// During normal command execution, you will get this item's listening at the command's [.results] observable. /// 1. If the command was just newly created, you will get `null, false, false` (data, error, isExecuting) /// 2. When calling execute: `null, false, true` /// 3. When exceution finishes: `result, false, false` class CommandResult&lt;T&gt; { final T data; final Exception error; final bool isExecuting; const CommandResult(this.data, this.error, this.isExecuting); bool get hasData =&gt; data != null; bool get hasError =&gt; error != null; @override bool operator ==(Object other) =&gt; other is CommandResult&lt;T&gt; &amp;&amp; other.data == data &amp;&amp; other.error == error &amp;&amp; other.isExecuting == isExecuting; @override int get hashCode =&gt; hash3(data.hashCode, error.hashCode, isExecuting.hashCode); @override String toString() { return 'Data: $data - HasError: $hasError - IsExecuting: $isExecuting'; } }</span></span></code> </pre> <br><p> 如果要将命令的结果直接传递到StreamBuilder，则<code>.results</code> Observable尤其有用。 这将根据命令的状态显示不同的内容，并且与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rx_widgets</a>包中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxLoader</a>一起使用时效果很好。 这是一个使用<code>.results</code> Observable的RxLoader小部件示例： </p><br><pre> <code class="cpp hljs">Expanded( <span class="hljs-comment"><span class="hljs-comment">/// RxLoader      ///    Stream&lt;CommandResult&gt; child: RxLoader&lt;List&lt;WeatherEntry&gt;&gt;( spinnerKey: AppKeys.loadingSpinner, radius: 25.0, commandResults: sl.get&lt;AppManager&gt;().updateWeatherCommand.results, /// ,  .hasData == true dataBuilder: (context, data) =&gt; WeatherListView(data, key: AppKeys.weatherList), /// ,  .isExceuting == true placeHolderBuilder: (context) =&gt; Center( key: AppKeys.loaderPlaceHolder, child: Text("No Data")), /// ,  .hasError == true errorBuilder: (context, ex) =&gt; Center( key: AppKeys.loaderError, child: Text("Error: ${ex.toString()}")), ), ),</span></span></code> </pre><br><h2 id="sozdanie-rxcommands"> 创建RxCommand </h2><br><p>  RxCommands可以使用同步和异步功能： </p><br><ul><li> 它们没有参数，也不返回结果。 </li><li> 它们有一个参数，不返回结果。 </li><li> 它们没有参数并返回结果。 </li><li> 它们有一个参数并返回结果； </li></ul><br><p> 对于所有选项，RxCommand提供了几种工厂方法，其中考虑了同步和异步处理程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, TResult&gt; createSync&lt;TParam, TResult&gt;(Func1&lt;TParam, TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, TResult&gt; createSyncNoParam&lt;TResult&gt;(Func&lt;TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createSyncNoResult&lt;TParam&gt;(Action1&lt;TParam&gt; action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createSyncNoParamNoResult(Action action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, TResult&gt; createAsync&lt;TParam, TResult&gt;(AsyncFunc1&lt;TParam, TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, TResult&gt; createAsyncNoParam&lt;TResult&gt;(AsyncFunc&lt;TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createAsyncNoResult&lt;TParam&gt;(AsyncAction1&lt;TParam&gt; action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createAsyncNoParamNoResult(AsyncAction action,...</code> </pre> <br><p>  <strong>即使打包的函数不返回值，RxCommand在执行函数后也将返回空值。</strong>  <strong>因此，您可以将侦听器设置为此类命令，以使其对功能的完成做出响应。</strong> </p><br><h2 id="dostup-k-poslednemu-rezultatu"> 获取最新结果 </h2><br><p>  <code>RxCommand.lastResult</code>使您可以访问命令执行结果的最后成功值，该值可以在StreamBuilder中用作<code>initialData</code> 。 </p><br><p> 如果要在运行时或发生错误时获取CommandResult事件中包含的最后结果，则可以在创建命令时传递<code>emitInitialCommandResult = true</code> 。 </p><br><p> 例如，如果要将初始值分配给<code>.lastResult</code> ，则在StreamBuilder中将其用作<code>initialData</code>时，可以在创建命令时将它与<code>initialLastResult</code>参数一起传递。 </p><br><h2 id="primer---delaem-flutter-reaktivnym"> 示例-使Flutter具有反应性 </h2><br><p> 该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a>的最新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本</a>已为<strong>RxVMS</strong>进行了重组，因此现在您应该在如何使用它方面有了一个不错的选择。 </p><br><p> 由于这是一个非常简单的应用程序，因此我们只需要一个管理员： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppManager</span></span></span><span class="hljs-class"> {</span></span> RxCommand&lt;String, List&lt;WeatherEntry&gt;&gt; updateWeatherCommand; RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; switchChangedCommand; RxCommand&lt;String, String&gt; textChangedCommand; AppManager() { <span class="hljs-comment"><span class="hljs-comment">//    bool         //   Observable switchChangedCommand = RxCommand.createSync&lt;bool, bool&gt;((b) =&gt; b); //    switchChangedCommand  canExecute Observable  // updateWeatherCommand updateWeatherCommand = RxCommand.createAsync&lt;String, List&lt;WeatherEntry&gt;&gt;( sl.get&lt;WeatherService&gt;().getWeatherEntriesForCity, canExecute: switchChangedCommand, ); //         textChangedCommand = RxCommand.createSync&lt;String, String&gt;((s) =&gt; s); //    ... textChangedCommand //     500ms... .debounce(new Duration(milliseconds: 500)) // ...   updateWeatherCommand .listen(updateWeatherCommand); //     updateWeatherCommand(''); } }</span></span></code> </pre> <br><p> 您可以将不同的RxCommands组合在一起。 请注意， <code>switchedChangedCommand</code>实际上是<code>updateWeatherCommand</code>的<strong>Observable canExecute</strong> 。 </p><br><p> 现在，让我们看看如何在用户界面中使用Manager： </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( appBar: AppBar(title: Text(<span class="hljs-string"><span class="hljs-string">"WeatherDemo"</span></span>)), resizeToAvoidBottomPadding: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, body: Column( children: &lt;Widget&gt;[ Padding( padding: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">16.0</span></span>), child: TextField( key: AppKeys.textField, autocorrect: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, controller: _controller, decoration: InputDecoration( hintText: <span class="hljs-string"><span class="hljs-string">"Filter cities"</span></span>, ), style: TextStyle( fontSize: <span class="hljs-number"><span class="hljs-number">20.0</span></span>, ), <span class="hljs-comment"><span class="hljs-comment">//    textChangedCommand! onChanged: sl.get&lt;AppManager&gt;().textChangedCommand, ), ), Expanded( /// RxLoader   builders   ///   Stream&lt;CommandResult&gt; child: RxLoader&lt;List&lt;WeatherEntry&gt;&gt;( spinnerKey: AppKeys.loadingSpinner, radius: 25.0, commandResults: sl.get&lt;AppManager&gt;().updateWeatherCommand.results, dataBuilder: (context, data) =&gt; WeatherListView(data, key: AppKeys.weatherList), placeHolderBuilder: (context) =&gt; Center(key: AppKeys.loaderPlaceHolder, child: Text("No Data")), errorBuilder: (context, ex) =&gt; Center(key: AppKeys.loaderError, child: Text("Error: ${ex.toString()}")), ), ), Padding( padding: const EdgeInsets.all(8.0), child: Row( children: &lt;Widget&gt;[ ///  Updatebutton    updateWeatherCommand.canExecute Expanded( //        Streambuilder, //      WidgetSelector child: WidgetSelector( buildEvents: sl .get&lt;AppManager&gt;() .updateWeatherCommand .canExecute, onTrue: RaisedButton( key: AppKeys.updateButtonEnabled, child: Text("Update"), onPressed: () { _controller.clear(); sl.get&lt;AppManager&gt;().updateWeatherCommand(); }, ), onFalse: RaisedButton( key: AppKeys.updateButtonDisabled, child: Text("Please Wait"), onPressed: null, ), ), ), //    canExecuteInput StateFullSwitch( state: true, onChanged: sl.get&lt;AppManager&gt;().switchChangedCommand, ), ], ), ), ], ), );</span></span></code> </pre> <br><h2 id="tipovye-shablony-ispolzovaniya"> 典型使用模式 </h2><br><p> 我们已经看到了一种使用<strong>CommandResults</strong>响应命令的不同状态的方法。 在我们要显示命令是否成功（但不显示结果）的情况下，一种常见的模式是在<code>initState</code> StatefulWidget函数中侦听Observables命令。 这是一个真实项目的示例。 </p><br><p>  <code>createEventCommand</code>定义： </p><br><pre> <code class="cpp hljs"> RxCommand&lt;Event, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createEventCommand;</code> </pre> <br><p> 这将在数​​据库中创建一个<strong>Event</strong>对象，并且不会返回任何实际值。 但是，正如我们之前所了解的，即使返回类型为<code>void</code>的RxCommand在完成时也将返回单个数据项。 因此，命令完成后，我们可以使用此行为来触发应用程序中的操作： </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,        _eventCommandSubscription = _createCommand.listen((_) async { Navigator.pop(context); await showToast('Event saved'); }); //        _errorSubscription = _createEventCommand.thrownExceptions.listen((ex) async { await sl.get&lt;ErrorReporter&gt;().logException(ex); await showMessageDialog(context, 'There was a problem saving event', ex.toString()); }); }</span></span></code> </pre> <br><p>  <strong>重要提示</strong> ：当我们不再需要订阅时，请不要忘记完成订阅： </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _eventCommandSubscription?.cancel(); _errorSubscription?.cancel(); super.dispose(); }</code> </pre> <br><p> 此外，如果要使用忙碌计数器显示，可以： </p><br><ul><li> 监听<code>initState</code>函数中的<code>initState</code> Observable命令； </li><li> 显示/隐藏订阅中的计数器； 以及 </li><li> 使用命令本身作为<strong>StreamBuilder</strong>的数据源 </li></ul><br><h2 id="oblegchenie-zhizni-s-rxcommandlisteners"> 使用RxCommandListeners使生活更轻松 </h2><br><p> 如果要使用多个Observable，则可能必须管理多个订阅。 直接控制侦听和释放一组订阅可能很困难，这会使代码的可读性降低，并使您有出错的风险（例如，在完成过程中忘记<code>cancel</code> ）。 </p><br><p> 最新版本的<strong>rx_command</strong>添加了帮助程序类<code>RxCommandListener</code> ，该类旨在简化此处理。 它的构造函数接受各种状态更改的命令和处理程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RxCommandListener</span></span></span><span class="hljs-class">&lt;TParam, TResult&gt; {</span></span> final RxCommand&lt;TParam, TResult&gt; command; <span class="hljs-comment"><span class="hljs-comment">//       final void Function(TResult value) onValue; //    isExecuting final void Function(bool isBusy) onIsBusyChange; //       final void Function(Exception ex) onError; //    canExecute final void Function(bool state) onCanExecuteChange; //    .results Observable  final void Function(CommandResult&lt;TResult&gt; result) onResult; //     /  final void Function() onIsBusy; final void Function() onNotBusy; //     final Duration debounceDuration; RxCommandListener(this.command,{ this.onValue, this.onIsBusyChange, this.onIsBusy, this.onNotBusy, this.onError, this.onCanExecuteChange, this.onResult, this.debounceDuration,} ) void dispose();</span></span></code> </pre> <br><p> 您不需要传递所有处理程序函数。 所有这些都是可选的，因此您可以简单地转移所需的那些。 您只需要在<code>dispose</code>函数中为<code>RxCommandListener</code>调用<code>dispose</code> ，它将取消订阅中使用的所有内容。 </p><br><p> 在另一个真实示例中，让我们比较带有和不<code>RxCommandListener</code>的相同代码。 在聊天屏幕上，这里可以使用<code>selectAndUploadImageCommand</code>命令，用户可以在其中上传图像。 调用命令时： </p><br><ul><li>  <strong>显示“图像选择器”</strong>对话框<strong>。</strong> </li><li> 选择图像后加载 </li><li> 下载完成后，该命令将返回图像存储地址，以便您可以创建新的聊天条目。 </li></ul><br><p> 没有<strong>RxCommandListener</strong> ： </p><br><pre> <code class="cpp hljs">_selectImageCommandSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .listen((imageLocation) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imageLocation == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    sl.get&lt;EventManager&gt;().createChatEntryCommand(new ChatEntry( event: widget.event, isImage: true, content: imageLocation.downloadUrl, )); }); _selectImageIsExecutingSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .isExecuting .listen((busy) { if (busy) { MySpinner.show(context); } else { MySpinner.hide(); } }); _selectImageErrorSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .thrownExceptions .listen((ex) =&gt; showMessageDialog(context, 'Upload problem', "We cannot upload your selected image at the moment. Please check your internet connection"));</span></span></code> </pre> <br><p> 使用<strong>RxCommandListener</strong> ： </p><br><pre> <code class="cpp hljs">selectImageListener = RxCommandListener( command: sl.get&lt;ImageManager&gt;().selectAndUploadImageCommand, onValue: (imageLocation) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imageLocation == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; sl.get&lt;EventManager&gt;().createChatEntryCommand(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChatEntry( event: widget.event, isImage: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, content: imageLocation.downloadUrl, )); }, onIsBusy: () =&gt; MySpinner.show(context), onNotBusy: MySpinner.hide, onError: (ex) =&gt; showMessageDialog(context, <span class="hljs-string"><span class="hljs-string">'Upload problem'</span></span>, <span class="hljs-string"><span class="hljs-string">"We cannot upload your selected image at the moment. Please check your internet connection"</span></span>));</code> </pre> <br><p> 通常，如果有多个Observable，我将始终使用RxCommandListener。 </p><br><p> 尝试使用<strong>RxCommands</strong> ，看看它如何使您的生活更轻松。 <br>  <em>顺便说一下，您不需要使用<strong>RxVMS</strong>来利用<strong>RxCommands</strong> 。</em> </p><br><p> 有关<code>RxCommand</code>更多信息<code>RxCommand</code>阅读<code>RxCommand</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自述</a>包。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449872/">https://habr.com/ru/post/zh-CN449872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449862/index.html">＃296移动开发人员的有趣材料摘要（4月22日至26日）</a></li>
<li><a href="../zh-CN449864/index.html">ResNet50。 自己实施</a></li>
<li><a href="../zh-CN449866/index.html">对HTTPS的潜在攻击以及如何防御</a></li>
<li><a href="../zh-CN449868/index.html">GIT数据库版本控制机制（MySQL转储管理）</a></li>
<li><a href="../zh-CN449870/index.html">通用JSONDecoder</a></li>
<li><a href="../zh-CN449876/index.html">Innovation SSI-2001：IBM PC（及其副本）中最稀有的声卡之一的故事</a></li>
<li><a href="../zh-CN449878/index.html">IT领域的专利研究。 年轻战士的历程。 第一部分：如何理解客户需求并准备报告模板</a></li>
<li><a href="../zh-CN449880/index.html">敏捷精简版：专门针对倦怠</a></li>
<li><a href="../zh-CN449884/index.html">ESP8266上的8008微处理器仿真</a></li>
<li><a href="../zh-CN449886/index.html">就像骑自行车一样</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>