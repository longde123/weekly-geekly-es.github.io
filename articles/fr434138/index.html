<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé† üïú ü§∂üèø Nous √©crivons notre propre machine virtuelle üë®üèΩ‚Äç‚úàÔ∏è üè® üëàüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans ce didacticiel, je vais vous montrer comment √©crire votre propre machine virtuelle (VM) qui peut ex√©cuter des programmes d'assembleur tels que 20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons notre propre machine virtuelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/">  Dans ce didacticiel, je vais vous montrer comment √©crire votre propre machine virtuelle (VM) qui peut ex√©cuter des programmes d'assembleur tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2048</a> (mon ami) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Roguelike</a> (le mien).  Si vous savez programmer, mais que vous voulez mieux comprendre ce qui se passe √† l'int√©rieur de l'ordinateur et comment fonctionnent les langages de programmation, alors ce projet est fait pour vous.  √âcrire votre propre machine virtuelle peut sembler un peu effrayant, mais je vous promets que le sujet est √©tonnamment simple et instructif. <br><br>  <a href="">Le code final</a> est d'environ 250 lignes en C. Il suffit de conna√Ætre uniquement les bases du C ou du C ++, comme l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arithm√©tique binaire</a> .  Tout syst√®me Unix (y compris macOS) convient √† la construction et √† l'ex√©cution.  Plusieurs API Unix sont utilis√©es pour configurer l'entr√©e et l'affichage de la console, mais elles ne sont pas essentielles au code principal.  (La mise en ≈ìuvre du support Windows est appr√©ci√©e). <br><br><blockquote>  <b>Remarque:</b> cette VM est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme comp√©tent</a> .  Autrement dit, vous lisez d√©j√† son code source en ce moment!  Chaque morceau de code sera affich√© et expliqu√© en d√©tail, de sorte que vous pouvez √™tre s√ªr que rien ne manque.  Le code final est cr√©√© par un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plexus</a> de blocs de code.  D√©p√¥t de projets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Contenu </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Table des mati√®res</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Architecture LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples d'assembleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ex√©cution du programme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mise en ≈ìuvre des instructions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instructions Triche</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Proc√©dures de traitement des interruptions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aide-m√©moire pour les routines d'interruption</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√©l√©chargez le logiciel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Registres mapp√©s en m√©moire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnalit√©s de la plateforme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©marrage de la machine virtuelle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©thode alternative en C ++</a> </li></ol><br><a name="2"></a><h1>  2. Introduction </h1><br><h3>  Qu'est-ce qu'une machine virtuelle? </h3><br>  Une machine virtuelle est un programme qui agit comme un ordinateur.  Il simule un processeur avec plusieurs autres composants mat√©riels, vous permettant d'effectuer des op√©rations arithm√©tiques, de lire et d'√©crire dans la m√©moire et d'interagir avec des p√©riph√©riques d'entr√©e / sortie comme un v√©ritable ordinateur physique.  Plus important encore, VM comprend un langage machine que vous pouvez utiliser pour la programmation. <br><br>  La quantit√© de mat√©riel simul√©e par une machine virtuelle particuli√®re d√©pend de son objectif.  Certaines machines virtuelles reproduisent le comportement d'un ordinateur particulier.  Les gens n'ont plus NES, mais nous pouvons toujours jouer √† des jeux pour NES en simulant du mat√©riel au niveau logiciel.  Ces √©mulateurs doivent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recr√©er avec pr√©cision</a> chaque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tail</a> et chaque composant mat√©riel majeur de l'appareil d'origine. <br><br>  Les autres VM ne correspondent √† aucun ordinateur particulier, mais correspondent partiellement √† plusieurs √† la fois!  Cela est principalement fait pour faciliter le d√©veloppement de logiciels.  Imaginez que vous souhaitez cr√©er un programme qui s'ex√©cute sur plusieurs architectures informatiques.  La machine virtuelle fournit une plate-forme standard qui assure la portabilit√©.  Pas besoin de r√©√©crire le programme dans diff√©rents dialectes d'assembleur pour chaque architecture.  Il suffit de ne faire qu'une petite VM dans chaque langue.  Apr√®s cela, tout programme ne peut √™tre √©crit qu'une seule fois dans le langage d'assemblage d'une machine virtuelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Remarque: le</b> compilateur r√©sout ces probl√®mes en compilant un <i>langage</i> standard de <i>haut niveau</i> pour diff√©rentes architectures de processeur.  VM cr√©e une <i>architecture CPU</i> standard qui est simul√©e sur divers p√©riph√©riques mat√©riels.  L'un des avantages du compilateur est qu'il n'y a pas de surcharge d'ex√©cution comme le fait VM.  Bien que les compilateurs fonctionnent bien, l'√©criture d'un nouveau compilateur pour plusieurs plates-formes est tr√®s difficile, donc les machines virtuelles sont toujours utiles.  En r√©alit√©, √† diff√©rents niveaux, VM et compilateurs sont utilis√©s ensemble. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La machine virtuelle Java (JVM)</a> est un exemple tr√®s r√©ussi.  La JVM elle-m√™me est de taille relativement moyenne; elle est suffisamment petite pour qu'un programmeur puisse la comprendre.  Cela vous permet d'√©crire du code pour des milliers d'appareils diff√©rents, y compris les t√©l√©phones.  Apr√®s avoir impl√©ment√© la JVM sur le nouveau p√©riph√©rique, n'importe quel programme Java, Kotlin ou Clojure √©crit peut fonctionner sans modifications.  Les seuls co√ªts ne seront que les frais g√©n√©raux de la machine virtuelle elle-m√™me et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'abstraction</a> du niveau machine.  C'est g√©n√©ralement un tr√®s bon compromis. <br><br>  Une machine virtuelle n'a pas besoin d'√™tre volumineuse ou omnipr√©sente pour offrir des avantages similaires.  Les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeux vid√©o</a> plus anciens utilisaient souvent de petites machines virtuelles pour cr√©er des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syst√®mes de script</a> simples. <br><br>  Les machines virtuelles sont √©galement utiles pour isoler des programmes en toute s√©curit√©.  Une application est la collecte des ordures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il n'y a aucun moyen trivial d'</a> impl√©menter le ramasse-miettes automatique au-dessus de C ou C ++, car le programme ne peut pas voir sa propre pile ou ses variables.  Cependant, la machine virtuelle est ¬´en dehors¬ª du programme en cours d'ex√©cution et peut observer toutes les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rences aux cellules de m√©moire</a> sur la pile. <br><br>  Un autre exemple de ce comportement est illustr√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les contrats intelligents Ethereum</a> .  Les contrats intelligents sont de petits programmes ex√©cut√©s par chaque n≈ìud de validation de la cha√Æne de blocs.  Autrement dit, les op√©rateurs autorisent l'ex√©cution sur leurs machines de tout programme √©crit par des inconnus, sans aucune possibilit√© de les √©tudier √† l'avance.  Pour √©viter les actions malveillantes, elles sont effectu√©es sur une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">machine virtuelle</a> qui n'a pas acc√®s au syst√®me de fichiers, au r√©seau, au disque, etc.  Ethereum est √©galement un bon exemple de portabilit√©.  Gr√¢ce √† VM, vous pouvez √©crire des contrats intelligents sans prendre en compte les fonctionnalit√©s de nombreuses plateformes. <br><br><a name="3"></a><h1>  3. Architecture LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  Notre machine virtuelle simulera un ordinateur fictif appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LC-3</a> .  Il est populaire pour enseigner aux √©tudiants monteurs.  Ici, un ensemble de commandes simplifi√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par rapport √† x86</a> , mais conserve tous les concepts de base utilis√©s dans les processeurs modernes. <br><br>  Tout d'abord, vous devez simuler les composants mat√©riels n√©cessaires.  Essayez de comprendre ce qu'est chaque composant, mais ne vous inqui√©tez pas si vous ne savez pas comment il s'int√®gre dans la vue d'ensemble.  Commen√ßons par cr√©er un fichier en C. Chaque morceau de code de cette section doit √™tre plac√© dans la port√©e globale de ce fichier. <br><br><h3>  La m√©moire </h3><br>  Le LC-3 poss√®de 65 536 cellules de m√©moire (2 <sup>16</sup> ), chacune contenant une valeur de 16 bits.  Cela signifie qu'il ne peut stocker que 128 Ko - beaucoup moins que ce √† quoi vous √™tes habitu√©!  Dans notre programme, cette m√©moire est stock√©e dans un tableau simple: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Registres </h3><br>  Un registre est un emplacement pour stocker une valeur dans le CPU.  Les registres sont comme un ¬´√©tabli¬ª de CPU.  Pour qu'il puisse fonctionner avec certaines donn√©es, il doit se trouver dans l'un des registres.  Mais comme il n'y a que quelques registres, seule une quantit√© minimale de donn√©es peut √™tre t√©l√©charg√©e √† tout moment.  Les programmes contournent ce probl√®me en chargeant des valeurs de la m√©moire dans des registres, en calculant des valeurs dans d'autres registres, puis en stockant les r√©sultats finaux dans la m√©moire. <br><br>  Il n'y a que 10 registres dans le LC-3, chacun avec 16 bits.  La plupart d'entre eux sont √† usage g√©n√©ral, mais certains ont des r√¥les assign√©s. <br><br><ul><li>  8 registres √† usage g√©n√©ral ( <code>R0-R7</code> ) </li><li>  1 registre du comptoir des √©quipes ( <code>PC</code> ) </li><li>  1 registre des indicateurs de condition ( <code>COND</code> ) </li></ul><br>  Les registres √† usage g√©n√©ral peuvent √™tre utilis√©s pour effectuer des calculs logiciels.  Le compteur d'instructions est un entier non sign√© qui est l'adresse m√©moire de la prochaine instruction √† ex√©cuter.  Les drapeaux de condition nous renseignent sur le calcul pr√©c√©dent. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Comme la m√©moire, nous allons stocker les registres dans un tableau: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Jeu d'instructions </h3><br>  Une instruction est une commande qui indique au processeur d'effectuer une sorte de t√¢che fondamentale, par exemple, ajouter deux nombres.  L'instruction a un <b>opcode</b> (code d'op√©ration) indiquant le type de t√¢che en cours d'ex√©cution, ainsi qu'un ensemble de <b>param√®tres</b> qui fournissent une entr√©e pour la t√¢che en cours d'ex√©cution. <br><br>  Chaque <b>opcode</b> repr√©sente une t√¢che que le processeur ¬´sait¬ª comment effectuer.  Il y a 16 opcodes dans LC-3.  Un ordinateur ne peut calculer que la s√©quence de ces instructions simples.  La longueur de chaque instruction est de 16 bits et les 4 bits de gauche stockent le code d'op√©ration.  Les autres sont utilis√©s pour stocker les param√®tres. <br><br>  Plus tard, nous discuterons en d√©tail de ce que fait chaque instruction.  D√©finissez les opcodes suivants pour le moment.  Assurez-vous de conserver cette commande pour obtenir la valeur d'√©num√©ration correcte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Remarque: l'</b> architecture Intel x86 contient des centaines d'instructions, tandis que d'autres architectures telles que ARM et LC-3 sont tr√®s peu nombreuses.  Les petits jeux d'instructions sont appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RISC</a> , tandis que les plus grands sont appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CISC</a> .  Les grands jeux d'instructions, en r√®gle g√©n√©rale, ne fournissent pas de fonctionnalit√©s fondamentalement nouvelles, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simplifient souvent l'√©criture du code assembleur</a> .  Une instruction CISC peut remplacer plusieurs instructions RISC.  Cependant, les processeurs CISC sont plus complexes et co√ªteux √† concevoir et √† fabriquer.  Ceci et d'autres compromis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne permettent pas d'appeler la conception ¬´optimale¬ª</a> . </blockquote><br><h3>  Indicateurs de condition </h3><br>  Le registre <code>R_COND</code> stocke des indicateurs de condition qui fournissent des informations sur le dernier calcul effectu√©.  Cela permet aux programmes de v√©rifier les conditions logiques, telles que <code>if (x &gt; 0) { ... }</code> . <br><br>  Chaque processeur poss√®de de nombreux drapeaux d'√©tat pour signaler diverses situations.  Le LC-3 utilise seulement trois drapeaux de condition qui montrent le signe du calcul pr√©c√©dent. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Remarque:</b> (Le caract√®re <code>&lt;&lt;</code> est appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'op√©rateur de d√©calage vers la gauche</a> . <code>(n &lt;&lt; k)</code> d√©cale les bits <code>n</code> gauche de <code>k</code> emplacements. Ainsi, <code>1 &lt;&lt; 2</code> est √©gal √† <code>4</code> Lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> si vous n'√™tes pas familier avec le concept. Ce sera tr√®s important). </blockquote><br>  Nous avons termin√© la configuration des composants mat√©riels de notre machine virtuelle!  Apr√®s avoir ajout√© des inclusions standard (voir le lien ci-dessus), votre fichier devrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Voici des liens vers des sections num√©rot√©es de l'article, d'o√π proviennent les fragments de code correspondants.</font>  <font color="gray">Pour une liste compl√®te, voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme de travail</a> - env.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Exemples d'assembleurs </h1><br>  Maintenant, regardons le programme d'assembleur LC-3 pour avoir une id√©e de ce que fait r√©ellement la machine virtuelle.  Vous n'avez pas besoin de savoir programmer en assembleur, ni de tout comprendre ici.  Essayez juste d'avoir une id√©e g√©n√©rale de ce qui se passe.  Voici un simple ¬´Hello World¬ª: <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Comme en C, le programme ex√©cute une instruction de haut en bas.  Mais contrairement √† C, il n'y a pas de zones imbriqu√©es <code>{}</code> ou de structures de contr√¥le telles que <code>if</code> ou <code>while</code> ;  juste une simple liste d'op√©rateurs.  Par cons√©quent, il est beaucoup plus facile √† r√©aliser. <br><br>  Veuillez noter que les noms de certains op√©rateurs correspondent aux opcodes que nous avons d√©finis pr√©c√©demment.  Nous savons que les instructions sont de 16 bits, mais chaque ligne ressemble √† un nombre diff√©rent de caract√®res.  Comment un tel d√©calage est-il possible? <br><br>  En effet, le code que nous lisons est √©crit en <b>langage assembleur</b> - sous forme de texte brut, lisible et inscriptible.  Un outil, appel√© <b>assembleur</b> , convertit chaque ligne de texte en une instruction binaire 16 bits qu'une machine virtuelle comprend.  Cette forme binaire, qui est essentiellement un tableau d'instructions 16 bits, est appel√©e <b>code machine</b> et est en fait ex√©cut√©e par une machine virtuelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Remarque:</b> bien que le compilateur et l'assembleur jouent un r√¥le similaire dans le d√©veloppement, ils ne sont pas identiques.  L'assembleur code simplement ce que le programmeur a √©crit dans le texte, en rempla√ßant les caract√®res par leur repr√©sentation binaire et en les emballant dans des instructions. </blockquote><br>  Les <code>.STRINGZ</code> <code>.ORIG</code> et <code>.STRINGZ</code> ressemblent √† des instructions, mais non.  Ce sont des directives d'assembleur qui g√©n√®rent une partie du code ou des donn√©es.  Par exemple, <code>.STRINGZ</code> ins√®re une cha√Æne de caract√®res √† un emplacement sp√©cifi√© dans un programme binaire. <br><br>  Les boucles et les conditions sont ex√©cut√©es √† l'aide d'une instruction de type goto.  Voici un autre exemple qui compte jusqu'√† 10. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Remarque:</b> ce didacticiel n'a pas √† apprendre l'assemblage.  Mais si vous √™tes int√©ress√©, vous pouvez √©crire et cr√©er vos propres programmes LC-3 √† l'aide des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outils LC-3</a> . </blockquote><br><a name="5"></a><h1>  5. Ex√©cution du programme </h1><br>  Encore une fois, les exemples pr√©c√©dents donnent juste une id√©e de ce que fait la VM.  Pour √©crire une machine virtuelle, vous n'avez pas besoin d'une compr√©hension compl√®te de l'assembleur.  Tant que vous suivez la proc√©dure appropri√©e pour lire et ex√©cuter les instructions, <i>tout programme</i> LC-3 fonctionnera correctement, quelle que soit sa complexit√©.  En th√©orie, une VM peut m√™me ex√©cuter un navigateur ou un syst√®me d'exploitation comme Linux! <br><br>  Si vous pensez profond√©ment, alors c'est une id√©e philosophiquement merveilleuse.  Les programmes eux-m√™mes peuvent produire des actions arbitrairement complexes auxquelles nous ne nous attendions pas et que nous ne pouvons pas comprendre.  Mais en m√™me temps, toutes leurs fonctionnalit√©s sont limit√©es √† du code simple, que nous √©crirons!  En m√™me temps, nous savons tout et rien sur le fonctionnement de chaque programme.  Turing a mentionn√© cette merveilleuse id√©e: <br><br><blockquote>  ¬´L'opinion selon laquelle les machines ne peuvent surprendre personne avec quoi que ce soit est bas√©e, je crois, sur une erreur, √† laquelle les math√©maticiens et les philosophes sont particuli√®rement enclins.  Je veux dire l'hypoth√®se que depuis qu'un fait est devenu la propri√©t√© de l'esprit, imm√©diatement toutes les cons√©quences de ce fait deviendront la propri√©t√© de l'esprit. ¬ª  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Proc√©dure </h3><br>  Voici la description exacte de la proc√©dure √† √©crire: <br><br><ol><li>  T√©l√©chargez une instruction de la m√©moire √† l'adresse du registre <code>PC</code> . </li><li>  Augmentez <code>PC</code> registre <code>PC</code> . </li><li>  Affichez l'opcode pour d√©terminer le type d'instruction √† suivre. </li><li>  Suivez les instructions en utilisant ses param√®tres. </li><li>  Revenez √† l'√©tape 1. </li></ol><br>  Vous pouvez poser la question: "Mais si la boucle continue √† incr√©menter le compteur en l'absence de <code>if</code> ou <code>while</code> , les instructions ne se termineront-elles pas?"  La r√©ponse est non.  Comme nous l'avons d√©j√† mentionn√©, certaines instructions de type goto modifient le flux d'ex√©cution en sautant autour du <code>PC</code> . <br><br>  Nous commen√ßons l'√©tude de ce processus comme exemple du cycle principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Mise en ≈ìuvre des instructions </h1><br>  Maintenant, votre t√¢che est de faire l'impl√©mentation correcte pour chaque opcode.  Une sp√©cification d√©taill√©e de chaque instruction est contenue dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> .  √Ä partir de la sp√©cification, vous devez savoir comment fonctionne chaque instruction et √©crire une impl√©mentation.  C'est plus facile qu'il n'y para√Æt.  Ici, je vais montrer comment mettre en ≈ìuvre deux d'entre eux.  Le code pour le reste peut √™tre trouv√© dans la section suivante. <br><br><h3>  AJOUTER </h3><br>  L'instruction <code>ADD</code> prend deux nombres, les ajoute et stocke le r√©sultat dans un registre.  La sp√©cification se trouve dans la documentation √† la page 526. Chaque instruction <code>ADD</code> est la suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Il y a deux lignes dans le diagramme, car il y a deux ¬´modes¬ª diff√©rents pour cette instruction.  Avant d'expliquer les modes, essayons de trouver les similitudes entre eux.  Les deux commencent par quatre bits identiques <code>0001</code> .  Il s'agit de la valeur de l'opcode pour <code>OP_ADD</code> .  Les trois bits suivants sont marqu√©s <code>DR</code> pour le registre de sortie.  Le registre de sortie est l'emplacement de stockage du montant.  Les trois bits suivants sont: <code>SR1</code> .  Il s'agit d'un registre contenant le premier num√©ro √† ajouter. <br><br>  Ainsi, nous savons o√π enregistrer le r√©sultat et nous connaissons le premier nombre √† ajouter.  Il ne reste plus qu'√† trouver le deuxi√®me num√©ro √† ajouter.  Ici, les deux lignes commencent √† diff√©rer.  Notez que le 5√®me bit est 0 en haut et 1. est en bas. Ce bit correspond soit <i>au mode direct</i> soit <i>au mode</i> <i>registre</i> .  En mode registre, le deuxi√®me num√©ro est enregistr√© dans le registre, comme le premier.  Il est marqu√© comme <code>SR2</code> et est contenu dans les bits deux √† z√©ro.  Les bits 3 et 4 ne sont pas utilis√©s.  En assembleur, il s'√©crira comme ceci: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  En mode imm√©diat, au lieu d'ajouter le contenu du registre, la valeur imm√©diate est int√©gr√©e dans l'instruction elle-m√™me.  Ceci est pratique car le programme n'a pas besoin d'instructions suppl√©mentaires pour charger ce num√©ro dans le registre √† partir de la m√©moire.  Au lieu de cela, il est d√©j√† dans l'instruction lorsque nous en avons besoin.  Le compromis est que seuls de petits nombres peuvent y √™tre stock√©s.  Pour √™tre pr√©cis, un maximum de 2 <sup>5</sup> = 32.  Ceci est tr√®s utile pour augmenter les compteurs ou les valeurs.  Dans l'assembleur, vous pouvez √©crire comme ceci: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Voici un extrait de la sp√©cification: <br><br><blockquote>  Si le bit [5] est √©gal √† 0, le deuxi√®me op√©rande source est obtenu √† partir de SR2.  Si le bit [5] est √©gal √† 1, le deuxi√®me op√©rande source est obtenu en √©tendant imm5 √† 16 bits.  Dans les deux cas, le deuxi√®me op√©rande source est ajout√© au contenu de SR1 et le r√©sultat est stock√© dans DR.  (p. 526) </blockquote><br>  Ceci est similaire √† ce que nous avons discut√©.  Mais qu'est-ce qu'une ¬´extension de sens¬ª?  Bien qu'en mode direct, la valeur ne dispose que de 5 bits, elle doit √™tre ajout√©e avec un nombre de 16 bits.  Ces 5 bits doivent √™tre √©tendus √† 16 pour correspondre √† un autre nombre.  Pour les nombres positifs, nous pouvons remplir les bits manquants avec des z√©ros et obtenir la m√™me valeur.  Cependant, pour les nombres n√©gatifs, cela ne fonctionne pas.  Par exemple, ‚àí1 sur cinq bits est <code>1 1111</code> .  Si vous le remplissez simplement de z√©ros, nous obtenons <code>0000 0000 0001 1111</code> , soit 32!  Le d√©veloppement de la valeur emp√™che ce probl√®me en remplissant les bits avec des z√©ros pour les nombres positifs et des uns pour les nombres n√©gatifs. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Remarque:</b> si vous √™tes int√©ress√© par les nombres n√©gatifs binaires, vous pouvez lire des informations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suppl√©mentaires</a> sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> .  Mais ce n'est pas essentiel.  Copiez simplement le code ci-dessus et utilisez-le lorsque la sp√©cification indique d'augmenter la valeur. </blockquote><br>  La sp√©cification a la derni√®re phrase: <br><br><blockquote>  Les codes de condition sont d√©finis selon que le r√©sultat est n√©gatif, nul ou positif.  (p. 526) </blockquote><br>  Plus t√¥t, nous avons d√©fini la condition d'√©num√©ration des drapeaux, et maintenant il est temps d'utiliser ces drapeaux.  Chaque fois qu'une valeur est √©crite dans le registre, nous devons mettre √† jour les drapeaux pour indiquer son signe.  Nous √©crivons une fonction √† r√©utiliser: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Nous sommes maintenant pr√™ts √† √©crire le code pour <code>ADD</code> : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Cette section contient beaucoup d'informations, alors r√©sumons. <br><br><ul><li>  <code>ADD</code> prend deux valeurs et les stocke dans un registre. </li><li>  En mode registre, la deuxi√®me valeur √† ajouter est en registre. </li><li>  En mode direct, la deuxi√®me valeur est int√©gr√©e dans les 5 bits de droite de l'instruction. </li><li>  Les valeurs inf√©rieures √† 16 bits doivent √™tre d√©velopp√©es. </li><li>  Chaque fois que l'instruction change de casse, les indicateurs de condition doivent √™tre mis √† jour. </li></ul><br>  Vous pourriez √™tre d√©pass√© en √©crivant 15 autres instructions.  Cependant, les informations obtenues ici peuvent √™tre r√©utilis√©es.  La plupart des instructions utilisent une combinaison d'extension de valeur, de divers modes et de mises √† jour d'indicateurs. <br><br><h3>  LDI </h3><br>  LDI signifie chargement "indirect" ou "indirect" (chargement indirect).  Cette instruction est utilis√©e pour charger une valeur d'un emplacement m√©moire dans un registre.  Sp√©cifications √† la page 532. <br><br>  Voici √† quoi ressemble la disposition binaire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  Contrairement √† <code>ADD</code> , il n'y a pas de modes et moins de param√®tres.  Cette fois, le code d'op√©ration est <code>1010</code> , ce qui correspond √† la valeur d'√©num√©ration <code>OP_LDI</code> .  Encore une fois, nous voyons un <code>DR</code> (registre de sortie) √† trois bits pour stocker la valeur charg√©e.  Les bits restants sont marqu√©s comme <code>PCoffset9</code> .  Il s'agit de la valeur imm√©diate int√©gr√©e √† l'instruction (similaire √† <code>imm5</code> ).  √âtant donn√© que l'instruction est charg√©e √† partir de la m√©moire, nous pouvons deviner que ce nombre est une sorte d'adresse qui indique o√π charger la valeur.  La sp√©cification explique plus en d√©tail: <br><br><blockquote>  L'adresse est calcul√©e en √©tendant les bits de la valeur <code>[8:0]</code> √† 16 bits et en ajoutant cette valeur au <code>PC</code> agrandi.  Ce qui est stock√© en m√©moire √† cette adresse est l'adresse des donn√©es qui seront charg√©es dans le <code>DR</code> .  (p. 532) </blockquote><br>  Comme pr√©c√©demment, vous devez √©tendre cette valeur 9 bits, mais cette fois-ci, ajoutez-la au <code>PC</code> actuel.  (Si vous regardez le cycle d'ex√©cution, le <code>PC</code> augment√© imm√©diatement apr√®s le chargement de cette instruction).  La somme r√©sultante est l'adresse d'emplacement en m√©moire, et cette adresse <i>contient une autre</i> valeur, qui est l'adresse de la valeur de chargement. <br><br>  Cela peut sembler un moyen d√©tourn√© de lire de m√©moire, mais c'est n√©cessaire.  L'instruction <code>LD</code> est limit√©e √† un d√©calage d'adresse de 9 bits, tandis que la m√©moire n√©cessite une adresse de 16 bits.  <code>LDI</code> est utile pour charger des valeurs qui sont stock√©es quelque part en dehors de l'ordinateur actuel, mais pour les utiliser, l'adresse de l'emplacement final doit √™tre stock√©e √† proximit√©.  Vous pouvez le consid√©rer comme une variable locale en C, qui est un pointeur vers certaines donn√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Comme pr√©c√©demment, apr√®s avoir √©crit la valeur dans <code>DR</code> , les drapeaux doivent √™tre mis √† jour: <br><br><blockquote>  Les codes de condition sont d√©finis selon que le r√©sultat est n√©gatif, nul ou positif.  (p. 532) </blockquote><br>  Voici le code de ce cas: ( <code>mem_read</code> discut√© dans la section suivante): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Comme je l'ai dit, pour cette instruction, nous avons utilis√© une partie importante du code et des connaissances acquises plus t√¥t lors de l'√©criture d' <code>ADD</code> .  La m√™me chose avec le reste des instructions. <br><br>  Vous devez maintenant impl√©menter le reste des instructions.  Suivez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cifications</a> et utilisez le code d√©j√† √©crit.  Le code de toutes les instructions est donn√© √† la fin de l'article.  Deux des opcodes mentionn√©s pr√©c√©demment ne seront pas n√©cessaires: <code>OP_RTI</code> et <code>OP_RES</code> .  Vous pouvez les ignorer ou donner une erreur s'ils sont appel√©s.  Une fois termin√©, la majeure partie de votre machine virtuelle peut √™tre consid√©r√©e comme compl√®te! <br><br><a name="7"></a><h1>  7. Lit d'enfant selon les instructions </h1><br>  Cette section contient des impl√©mentations compl√®tes des instructions restantes si vous √™tes bloqu√©. <br><br><h3>  RTI &amp; RES </h3><br>  (non utilis√©) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bit "Et"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PAS au niveau du bit</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Succursale </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Sauter </h3><br>  <code>RET</code> est indiqu√© comme une instruction distincte dans la sp√©cification, car il s'agit d'une autre commande dans l'assembleur.  Il s'agit en fait d'un cas particulier de <code>JMP</code> .  <code>RET</code> se produit chaque fois que <code>R1</code> est 7. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Registre de saut </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Charge </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Registre de charge </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Adresse de chargement effective </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Boutique </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Magasin indirect </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Registre du magasin </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Proc√©dures de traitement des interruptions </h1><br>  LC-3 fournit plusieurs routines pr√©d√©finies pour effectuer des t√¢ches courantes et interagir avec les p√©riph√©riques d'E / S.  Par exemple, il existe des proc√©dures pour obtenir les lignes d'entr√©e et de sortie du clavier vers la console.  Ils sont appel√©s routines d'interruption, que vous pouvez consid√©rer comme le syst√®me d'exploitation ou l'API pour LC-3.  Chaque sous-programme se voit attribuer un code d'interruption (code d'interruption) qui l'identifie (semblable √† un opcode).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'ex√©cuter, une instruction est appel√©e </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le code du sous-programme souhait√©.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finissez une √©num√©ration pour chaque code d'interruption: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous vous demandez peut-√™tre pourquoi les codes d'interruption ne sont pas inclus dans les instructions. </font><font style="vertical-align: inherit;">En effet, ils n'ajoutent en fait aucune nouvelle fonctionnalit√© au LC-3, mais fournissent uniquement un moyen pratique de terminer la t√¢che (comme les fonctions syst√®me en C). </font><font style="vertical-align: inherit;">Dans le simulateur officiel LC-3, les codes d'interruption </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont √©crits en assembleur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lorsqu'un code d'interruption est appel√©, l'ordinateur se d√©place vers l'adresse de ce code. </font><font style="vertical-align: inherit;">La CPU ex√©cute les instructions de la proc√©dure et, une fois termin√©e, est </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©initialis√©e √† l'emplacement √† partir duquel l'interruption a √©t√© appel√©e.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a aucune sp√©cification sur la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fa√ßon d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> impl√©menter des routines d'interruption: juste ce qu'elles doivent faire. Dans notre VM, nous agirons un peu diff√©remment en les √©crivant en C. Lorsque le code d'interruption est appel√©, la fonction C sera appel√©e. Apr√®s son fonctionnement, l'instruction continuera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les proc√©dures puissent √™tre √©crites en assembleur et que l'ordinateur physique LC-3 le soit, ce n'est pas la meilleure option pour la machine virtuelle. Au lieu d'√©crire vos propres proc√©dures d'entr√©e-sortie primitives, vous pouvez utiliser celles qui sont disponibles sur notre syst√®me d'exploitation. Cela am√©liorera la machine virtuelle sur nos ordinateurs, simplifiera le code et fournira un niveau d'abstraction plus √©lev√© pour la portabilit√©.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un exemple sp√©cifique est la saisie au clavier. </font><font style="vertical-align: inherit;">La version assembleur utilise une boucle pour v√©rifier en continu la saisie au clavier. </font><font style="vertical-align: inherit;">Mais tant de temps processeur est perdu! </font><font style="vertical-align: inherit;">En utilisant la fonction OS appropri√©e, le programme peut dormir paisiblement avant le signal d'entr√©e.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'op√©rateur √† choix multiple pour l'opcode, </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez un autre commutateur:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme pour les instructions, je vais vous montrer comment mettre en ≈ìuvre une proc√©dure et faire le reste vous-m√™me. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code d'interruption est </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√© pour renvoyer une cha√Æne avec un z√©ro de fin (de m√™me </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C). </font><font style="vertical-align: inherit;">Sp√©cifications √† la page 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher une cha√Æne, nous devons donner √† la routine d'interruption une cha√Æne √† afficher. </font><font style="vertical-align: inherit;">Cela se fait en stockant l'adresse du premier caract√®re </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant le d√©but du traitement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la sp√©cification:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichez la cha√Æne de caract√®res ASCII sur l'√©cran de la console. </font><font style="vertical-align: inherit;">Les caract√®res sont contenus dans des cellules de m√©moire cons√©cutives, un caract√®re par cellule, en commen√ßant √† l'adresse sp√©cifi√©e dans </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La sortie se termine lorsqu'une valeur est rencontr√©e dans la m√©moire </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(p. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que contrairement aux cha√Ænes C, ici, les caract√®res ne sont </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stock√©s </font><i><font style="vertical-align: inherit;">dans un octet, mais dans un emplacement en m√©moire</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'emplacement de m√©moire du LC-3 est de 16 bits, donc chaque caract√®re de la cha√Æne est de 16 bits. </font><font style="vertical-align: inherit;">Pour afficher cela dans la fonction C, vous devez convertir chaque valeur en caract√®re et les imprimer s√©par√©ment.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rien de plus n'est requis pour cette proc√©dure. </font><font style="vertical-align: inherit;">Les routines d'interruption sont assez simples si vous connaissez C. Revenez maintenant aux sp√©cifications et impl√©mentez le reste. </font><font style="vertical-align: inherit;">Comme pour les instructions, le code complet se trouve √† la fin de ce guide.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Aide-m√©moire pour les routines d'interruption </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette section contient des impl√©mentations compl√®tes des routines d'interruption restantes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saisie de caract√®res </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sortie de caract√®res </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demande de saisie de caract√®res </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sortie ligne </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fin du programme </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. T√©l√©chargement de programmes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons beaucoup parl√© du chargement et de l'ex√©cution des instructions √† partir de la m√©moire, mais comment les instructions entrent-elles dans la m√©moire en g√©n√©ral? </font><font style="vertical-align: inherit;">Lors de la conversion d'un programme assembleur en code machine, le r√©sultat est un fichier contenant un tableau d'instructions et de donn√©es. </font><font style="vertical-align: inherit;">Il peut √™tre t√©l√©charg√© en copiant simplement le contenu directement dans une adresse en m√©moire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les 16 premiers bits du fichier programme indiquent l'adresse en m√©moire o√π le programme doit d√©marrer. </font><font style="vertical-align: inherit;">Cette adresse est appel√©e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il doit √™tre lu en premier, apr√®s quoi le reste des donn√©es est lu en m√©moire √† partir du fichier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le code pour charger le programme dans la m√©moire LC-3:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que pour chaque valeur charg√©e est appel√©e </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les programmes LC-3 sont √©crits dans l'ordre des octets directs, mais la plupart des ordinateurs modernes utilisent l'ordre inverse. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons retourner chacun charg√© </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Si vous utilisez accidentellement un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordinateur √©trange</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , rien ne doit √™tre chang√©).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: l' </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordre des octets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fait r√©f√©rence √† la fa√ßon dont les octets d'un entier sont interpr√©t√©s. </font><font style="vertical-align: inherit;">Dans l'ordre inverse, le premier octet est le chiffre le moins significatif, et dans l'ordre inverse, vice versa. </font><font style="vertical-align: inherit;">Pour autant que je sache, la d√©cision </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est essentiellement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitraire. </font><font style="vertical-align: inherit;">Diff√©rentes entreprises ont pris des d√©cisions diff√©rentes, nous avons donc maintenant diff√©rentes impl√©mentations. </font><font style="vertical-align: inherit;">Pour ce projet, vous n'avez plus besoin de conna√Ætre quoi que ce soit sur l'ordre des octets.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √©galement une fonction pratique pour </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui prend le chemin de la cha√Æne:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Registres mapp√©s </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains registres sp√©ciaux ne sont pas disponibles dans la table des registres r√©guliers. Au lieu de cela, une adresse sp√©ciale leur est r√©serv√©e en m√©moire. Pour lire et √©crire dans ces registres, il vous suffit de lire et d'√©crire dans leur m√©moire. Ils sont appel√©s </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registres mapp√©s en m√©moire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Habituellement, ils sont utilis√©s pour interagir avec des p√©riph√©riques mat√©riels sp√©ciaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour notre LC-3, nous devons impl√©menter deux registres mappables. Il s'agit du registre d'√©tat du clavier ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et du registre de donn√©es du clavier ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Le premier indique si la touche a √©t√© enfonc√©e et le second d√©termine quelle touche est enfonc√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que la saisie au clavier puisse √™tre demand√©e √† l'aide </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elle bloque l'ex√©cution jusqu'√† la r√©ception de la saisie. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permettre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interroger l'√©tat de l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appareil tout en continuant √† ex√©cuter le programme, afin qu'il reste r√©actif en attendant l'entr√©e.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les registres mapp√©s compliquent un peu l'acc√®s √† la m√©moire. </font><font style="vertical-align: inherit;">Nous ne pouvons pas lire et √©crire directement dans la matrice de m√©moire, mais nous devons plut√¥t appeler des fonctions sp√©ciales - le setter et le getter. </font><font style="vertical-align: inherit;">Apr√®s avoir lu la m√©moire du registre KBSR, le getter v√©rifie le clavier et met √† jour les deux emplacements en m√©moire.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est le dernier composant d'une machine virtuelle! </font><font style="vertical-align: inherit;">Si vous avez impl√©ment√© le reste des routines d'interruption et des instructions, vous √™tes presque pr√™t √† l'essayer! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout ce qui est √©crit doit √™tre ajout√© au fichier C dans l'ordre suivant:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Caract√©ristiques de la plateforme </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette section contient quelques d√©tails fastidieux n√©cessaires pour acc√©der au clavier et fonctionner correctement. </font><font style="vertical-align: inherit;">Il n'y a rien d'int√©ressant ou d'information sur le fonctionnement des machines virtuelles. </font><font style="vertical-align: inherit;">N'h√©sitez pas √† copier-coller! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous essayez de d√©marrer la machine virtuelle dans un syst√®me d'exploitation autre qu'Unix, tel que Windows, ces fonctions doivent √™tre remplac√©es par les fonctions Windows correspondantes.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code pour extraire le chemin des arguments du programme et afficher un exemple d'utilisation s'ils sont manquants. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code de configuration d'entr√©e de terminal sp√©cifique √† Unix. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque le programme est interrompu, nous voulons r√©tablir la console √† ses param√®tres normaux. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©marrage de la machine virtuelle </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant cr√©er et ex√©cuter la machine virtuelle LC-3! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilez le </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programme avec votre</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilateur pr√©f√©r√©.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√©l√©chargez la version compil√©e de </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ex√©cutez le programme avec le fichier obj comme argument: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jouez en 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©bogage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le programme ne fonctionne pas correctement, il est fort probable que vous ayez mal cod√© une sorte d‚Äôinstruction. </font><font style="vertical-align: inherit;">Il peut √™tre difficile de d√©boguer. </font><font style="vertical-align: inherit;">Je vous recommande de lire le code d'assemblage du programme en m√™me temps - et √† l'aide du d√©bogueur, suivez pas √† pas les instructions de la machine virtuelle. </font><font style="vertical-align: inherit;">Lors de la lecture du code, assurez-vous que la machine virtuelle va √† l'instruction pr√©vue. </font><font style="vertical-align: inherit;">Si une incompatibilit√© se produit, vous d√©couvrirez quelle instruction a caus√© le probl√®me. </font><font style="vertical-align: inherit;">Relisez la sp√©cification et rev√©rifiez le code.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. M√©thode alternative en C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un moyen avanc√© d'ex√©cuter des instructions qui r√©duit consid√©rablement la taille du code. Il s'agit d'une section compl√®tement facultative. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que C ++ prend en charge des g√©n√©riques puissants pendant le processus de compilation, nous pouvons cr√©er des parties d'instructions √† l'aide du compilateur. Cette m√©thode r√©duit la duplication de code et est en fait plus proche du niveau mat√©riel de l'ordinateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'id√©e est de r√©utiliser les √©tapes communes √† chaque instruction. Par exemple, certaines instructions utilisent l'adressage indirect ou l'extension d'une valeur et l'ajoutent √† la valeur actuelle </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. D'accord, ce serait bien d'√©crire ce code une fois pour toutes les instructions?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En consid√©rant l'instruction comme une s√©quence d'√©tapes, nous voyons que chaque instruction n'est qu'un r√©arrangement de plusieurs √©tapes plus petites. </font><font style="vertical-align: inherit;">Nous utiliserons des indicateurs de bits pour indiquer les √©tapes √† suivre pour chaque instruction. </font><font style="vertical-align: inherit;">La valeur </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le bit du num√©ro d'instruction indique que pour cette instruction, le compilateur doit inclure cette section de code.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai appris cette technique gr√¢ce √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'√©mulateur NES d√©velopp√© par Bisqwit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous √™tes int√©ress√© par l'√©mulation ou NES, je recommande fortement ses vid√©os. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'autres versions de C ++ utilisent le code d√©j√† √©crit. </font><font style="vertical-align: inherit;">Version compl√®te </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434138/">https://habr.com/ru/post/fr434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434128/index.html">PHP Digest n ¬∞ 146 (10-24 d√©cembre 2018) + R√©sultats 2018</a></li>
<li><a href="../fr434130/index.html">Interface r√©active. Conf√©rence d'Artyom Belov √† FrontTalks 2018</a></li>
<li><a href="../fr434132/index.html">Achetez un t√©l√©viseur et roulez-le: LG pr√©voit de commencer √† vendre des t√©l√©viseurs flexibles dans l'ann√©e √† venir</a></li>
<li><a href="../fr434134/index.html">Analyse des r√©sultats de l'enqu√™te Kaggle ML & DS 2018</a></li>
<li><a href="../fr434136/index.html">Anatomie d'entreprise</a></li>
<li><a href="../fr434140/index.html">Une br√®ve histoire des fonctionnalit√©s asynchrones Javascript</a></li>
<li><a href="../fr434142/index.html">L'√©quipe QRL a fix√© un d√©lai serr√© pour la migration des jetons</a></li>
<li><a href="../fr434146/index.html">Top 10 des films informatiques</a></li>
<li><a href="../fr434150/index.html">Caract√©ristiques de la recherche d'emploi en Europe</a></li>
<li><a href="../fr434154/index.html">Jeu de donn√©es du Nouvel An 2018: s√©mantique ouverte de la langue russe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>