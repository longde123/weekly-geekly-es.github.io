<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬛️ 🤥 🈴 Kerangka API Golang ♐️ 🧜🏻 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proses untuk mengenal Golang, saya memutuskan untuk membuat kerangka aplikasi, yang akan nyaman bagi saya untuk bekerja dengan di masa depan. Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerangka API Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455302/"><p>  Dalam proses untuk mengenal Golang, saya memutuskan untuk membuat kerangka aplikasi, yang akan nyaman bagi saya untuk bekerja dengan di masa depan.  Hasilnya adalah, menurut pendapat saya, benda kerja yang baik, yang saya putuskan untuk dibagikan, dan pada saat yang sama membahas momen-momen yang muncul selama pembuatan bingkai. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/599/73a/8a9/59973a8a925f690405c0f171fdd53048.jpg" alt="gambar"></p><br><p>  Pada prinsipnya, desain bahasa Go mengisyaratkan bahwa ia tidak perlu membuat aplikasi skala besar (saya berbicara tentang kurangnya obat generik dan mekanisme penanganan kesalahan yang tidak terlalu kuat).  Tetapi kita masih tahu bahwa ukuran aplikasi biasanya tidak berkurang, tetapi lebih sering justru sebaliknya.  Oleh karena itu, lebih baik untuk segera membuat kerangka kerja yang memungkinkan untuk merangkai fungsi baru tanpa mengorbankan dukungan kode. </p><a name="habracut"></a><br><p>  Saya mencoba memasukkan lebih sedikit kode ke dalam artikel, alih-alih saya menambahkan tautan ke baris kode tertentu di Github dengan harapan akan lebih nyaman untuk melihat keseluruhan gambar. </p><br><p>  Pertama, saya membuat sketsa rencana apa yang harus ada dalam aplikasi.  Karena saya akan berbicara tentang masing-masing item secara terpisah dalam artikel, saya pertama-tama akan memberikan yang utama dari daftar ini sebagai konten. </p><br><ul><li>  Pilih pengelola paket </li><li> Pilih kerangka kerja untuk membuat API </li><li>  Pilih Alat untuk Injeksi Ketergantungan (DI) </li><li>  Rute Permintaan Web </li><li>  Respons JSON / XML sesuai dengan header permintaan </li><li>  ORM </li><li>  Migrasi </li><li>  Buat kelas dasar untuk lapisan model Layanan-&gt; Repositori-&gt; Entitas </li><li>  Repositori CRUD dasar </li><li>  Layanan CRUD dasar </li><li>  Pengontrol CRUD Dasar </li><li>  Meminta Validasi </li><li>  Konfigurasi dan variabel lingkungan </li><li>  Perintah konsol </li><li>  Penebangan </li><li>  Integrasi logger dengan Sentry atau sistem peringatan lain </li><li>  Menyetel peringatan untuk kesalahan </li><li>  Tes unit dengan redefinisi layanan melalui DI </li><li>  Persentase dan tes peta kode jangkauan </li><li>  Kesombongan </li><li>  Menulis Docker </li></ul><br><h2 id="menedzher-paketov">  Manajer paket </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Setelah membaca</a> deskripsi untuk berbagai implementasi, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">govendor</a> dan saat ini saya puas dengan pilihannya.  Alasannya sederhana - ini memungkinkan Anda untuk menginstal dependensi di dalam direktori dengan aplikasi, menyimpan informasi tentang paket dan versinya. </p><br><p>  Informasi tentang paket dan versinya disimpan dalam satu <a href="">file</a> vendor.json.  Ada minus dalam pendekatan ini juga.  Jika Anda menambahkan paket dengan dependensinya, maka bersama dengan informasi tentang paket tersebut, informasi tentang dependensinya juga akan masuk ke file.  File tumbuh dengan cepat dan tidak lagi mungkin untuk menentukan dengan jelas dependensi mana yang utama dan turunannya. </p><br><p>  Dalam komposer PHP atau dalam npm, dependensi utama dijelaskan dalam satu file, dan semua dependensi utama dan turunan serta versinya direkam secara otomatis dalam file kunci.  Pendekatan ini lebih nyaman menurut saya.  Tetapi untuk saat ini, implementasi govendor sudah cukup bagi saya. </p><br><h2 id="freymvork">  Kerangka kerja </h2><br><p>  Dari kerangka saya tidak perlu banyak, router yang nyaman, validasi permintaan.  Semua ini ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gin yang</a> populer.  Dia berhenti di situ. </p><br><h2 id="dependency-injection">  Ketergantungan injeksi </h2><br><p>  Dengan DI aku harus sedikit menderita.  Pertama-tama pilih Dig.  Dan pada awalnya semuanya bagus.  Layanan yang dijelaskan, Menggali lebih jauh membangun dependensi, dengan nyaman.  Tetapi kemudian ternyata layanan tidak dapat didefinisikan ulang, misalnya, selama pengujian.  Oleh karena itu, pada akhirnya, saya sampai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesimpulan</a> bahwa saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sarulab / di</a> wadah layanan sederhana. </p><br><p>  Saya baru saja harus memotongnya, karena di luar kotak itu memungkinkan Anda untuk menambahkan layanan dan melarang mendefinisikan ulang mereka.  Dan ketika menulis autotests, menurut pendapat saya, lebih mudah untuk menginisialisasi wadah seperti dalam aplikasi, dan kemudian mendefinisikan kembali beberapa layanan, menentukan bertopik sebagai gantinya.  Dalam fork, ia menambahkan metode untuk mengganti deskripsi layanan. </p><br><p> Tetapi pada akhirnya, baik dalam kasus Dig dan dalam wadah layanan, saya harus memasukkan tes ke dalam paket terpisah.  Kalau tidak, ternyata tes dijalankan secara terpisah dalam paket ( <code>go test model/service</code> ), tetapi tes tersebut tidak segera dimulai untuk seluruh aplikasi ( <code>go test ./...</code> ), karena ketergantungan siklus yang muncul. </p><br><h2 id="otvety-v-formate-jsonxml-v-sootvetstvii-s-zagolovkami-zaprosa">  Respons JSON / XML sesuai dengan header permintaan </h2><br><p>  Di Gin, saya tidak menemukan ini, jadi saya hanya menambahkan <a href="">metode</a> ke pengontrol dasar yang menghasilkan respons tergantung pada header permintaan. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c BaseController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context *gin.Context, obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, code </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> context.GetHeader(<span class="hljs-string"><span class="hljs-string">"Accept"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"application/xml"</span></span>: context.XML(code, obj) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: context.JSON(code, obj) } }</code> </pre><br><h2 id="orm">  ORM </h2><br><p>  Dengan ORM tidak merasakan siksaan panjang pilihan.  Ada banyak pilihan.  Tetapi menurut deskripsi fitur, saya suka GORM, yang merupakan salah satu yang paling populer pada saat pemilihan.  Ada dukungan untuk DBMS yang paling umum digunakan.  Setidaknya PostgreSQL dan MySQL ada di sana.  Ini juga memiliki metode untuk mengelola skema dasar yang dapat Anda gunakan saat membuat migrasi. </p><br><h2 id="migracii">  Migrasi </h2><br><p>  Untuk migrasi, saya memilih paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">angsa-angsa</a> .  Saya meletakkan paket terpisah secara global dan mulai migrasi ke sana.  Pada awalnya, implementasi seperti itu malu, karena koneksi ke database harus dijelaskan dalam file <a href="">db / dbconf.yml yang</a> terpisah.  Namun kemudian ternyata string koneksi di dalamnya dapat dideskripsikan sedemikian rupa sehingga nilainya diambil dari variabel lingkungan. </p><br><pre> <code class="plaintext hljs">development: driver: postgres open: $DB_URL</code> </pre> <br><p>  Dan ini cukup nyaman.  Paling tidak dengan docker-compose, saya tidak perlu menduplikasi <a href="">string koneksi</a> . </p><br><p>  Gorm-angsa juga mendukung rollback migrasi, yang menurut saya sangat berguna. </p><br><h2 id="bazovyy-crud-repozitoriy">  Repositori CRUD dasar </h2><br><p>  Saya lebih suka segala sesuatu yang merujuk pada sumber daya untuk ditempatkan di lapisan repositori yang terpisah.  Menurut pendapat saya, dengan pendekatan ini, kode logika bisnis lebih bersih.  Dalam hal ini, kode logika bisnis hanya tahu bahwa kode itu perlu bekerja dengan data yang diambil dari repositori.  Dan apa yang terjadi di repositori, logika bisnis tidak penting.  Repositori dapat bekerja dengan database relasional, dengan penyimpanan KV, dengan disk, atau mungkin dengan API layanan lain.  Kode logika bisnis akan sama dalam semua kasus ini. </p><br><p>  Repositori CRUD mengimplementasikan <a href="">antarmuka</a> berikut </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CrudRepositoryInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BaseRepositoryInterface GetModel() (entity.InterfaceEntity) Find(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) (entity.InterfaceEntity, error) List(parameters ListParametersInterface) (entity.InterfaceEntity, error) Create(item entity.InterfaceEntity) entity.InterfaceEntity Update(item entity.InterfaceEntity) entity.InterfaceEntity Delete(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) error }</code> </pre> <br><p>  Yaitu, CRUD mengimplementasikan operasi <code>Create()</code> , <code>Find()</code> , <code>List()</code> , <code>Update()</code> , <code>Delete()</code> dan metode <code>GetModel()</code> . </p><br><p>  Tentang <a href="">GetModel ()</a> .  Ada repositori <code>CrudRepository</code> dasar yang mengimplementasikan operasi CRUD dasar.  Dalam repositori yang menanamkannya ke dalam diri mereka sendiri, cukup untuk menunjukkan model mana yang harus mereka gunakan.  Untuk melakukan ini, metode <code>GetModel()</code> harus mengembalikan model GORM.  Kemudian kami harus menggunakan hasil <code>GetModel()</code> menggunakan refleksi dalam metode CRUD. </p><br><p>  <a href="">Sebagai contoh</a> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c CrudRepository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity.InterfaceEntity, error)</span></span></span></span> { item := reflect.New(reflect.TypeOf(c.GetModel()).Elem()).Interface() err := c.db.First(item, id).Error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item, err }</code> </pre> <br><p>  Pada kenyataannya, dalam hal ini perlu untuk meninggalkan pengetikan statis demi pengetikan dinamis.  Pada saat-saat seperti itu, kurangnya obat generik dalam bahasa tersebut sangat terasa. </p><br><p>  Agar repositori yang bekerja dengan model tertentu untuk menerapkan aturan mereka sendiri untuk memfilter daftar dalam metode <code>List()</code> , saya pertama kali menerapkan pengikatan terlambat sehingga metode yang bertanggung jawab untuk membangun kueri dipanggil dari metode <code>List()</code> .  Dan metode ini dapat diimplementasikan dalam repositori tertentu.  Sulit untuk meninggalkan pola pikir yang terbentuk ketika bekerja dengan bahasa lain.  Tetapi, melihatnya dengan tampilan yang segar, dan menghargai "keanggunan" dari jalan yang dipilih, kemudian ia mengubahnya menjadi pendekatan yang lebih dekat dengan Go.  Untuk melakukan ini, cukup di <code>CrudRepository</code> melalui antarmuka <a href="">pembuat kueri</a> dideklarasikan, yang sudah <a href=""><code>  List()</code></a> . </p><br><pre> <code class="go hljs">listQueryBuilder ListQueryBuilderInterface</code> </pre><br><p>  Ternyata cukup lucu.  Membatasi bahasa untuk mengikat terlambat, yang pada awalnya tampak seperti cacat, mendorong pemisahan kode yang lebih jelas. </p><br><h2 id="bazovyy-crud-servis">  Layanan CRUD dasar </h2><br><p>  Tidak ada yang menarik di sini, karena tidak ada logika bisnis dalam kerangka ini.  Panggilan metode CRUD ke repositori hanya <a href="">diproksi</a> . </p><br><p>  Di lapisan layanan, logika bisnis harus diimplementasikan. </p><br><h2 id="bazovyy-crud-kontroller">  Pengontrol CRUD Dasar </h2><br><p>  Pengontrol mengimplementasikan <a href="">metode CRUD</a> .  Mereka memproses parameter dari permintaan, kontrol ditransfer ke metode layanan yang sesuai, dan berdasarkan respons layanan, respons dibentuk untuk klien. </p><br><p>  Dengan controller saya punya cerita yang sama dengan repositori mengenai daftar penyaringan.  Akibatnya, saya redid implementasi dengan pengikatan akhir buatan sendiri dan menambahkan <a href="">hydrator</a> , yang, berdasarkan parameter permintaan, membentuk struktur dengan parameter untuk memfilter daftar. </p><br><p>  Dalam hydrator yang datang dengan kontroler CRUD, hanya parameter pagination yang diproses.  Pada pengontrol spesifik di mana pengontrol CRUD terintegrasi, <a href="">hydrator</a> dapat <a href="">didefinisikan ulang</a> . </p><br><h2 id="validaciya-zaprosov">  Meminta Validasi </h2><br><p>  Validasi dilakukan oleh Gin.  Misalnya, ketika menambahkan catatan ( <code>Create()</code> metode), itu sudah cukup untuk <a href="">menghiasi</a> elemen struktur entitas </p><br><pre> <code class="go hljs">Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`binding:"required"`</span></span></code> </pre> <br><p>  Metode framework <a href=""><code>ShouldBindJSON()</code></a> menangani memeriksa parameter permintaan untuk kepatuhan dengan persyaratan yang dijelaskan dalam dekorator. </p><br><h2 id="konfigi-i-peremennye-okruzheniya">  Konfigurasi dan variabel lingkungan </h2><br><p>  Saya sangat menyukai implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Viper</a> , terutama dalam hubungannya dengan Cobra. </p><br><p>  Membaca konfigurasi yang saya <a href="">jelaskan di main.go.</a>  Parameter dasar yang tidak mengandung rahasia dijelaskan <a href="">dalam file base.env</a> .  Anda dapat menimpanya di file .env yang ditambahkan ke .gitignore.  Di .env, Anda bisa mendeskripsikan nilai-nilai rahasia untuk lingkungan. </p><br><p>  Variabel lingkungan memiliki prioritas yang lebih tinggi. </p><br><h2 id="konsolnye-komandy">  Perintah konsol </h2><br><p>  Untuk deskripsi perintah konsol, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cobra</a> .  Daripada itu baik untuk menggunakan Cobra bersama dengan Viper.  Kita bisa <a href="">menggambarkan perintahnya</a> </p><br><pre> <code class="go hljs">serverCmd.PersistentFlags().StringVar(&amp;serverPort, <span class="hljs-string"><span class="hljs-string">"port"</span></span>, defaultServerPort, <span class="hljs-string"><span class="hljs-string">"Server port"</span></span>)</code> </pre> <br><p>  Dan <a href="">ikat variabel lingkungan</a> ke nilai parameter perintah </p><br><pre> <code class="go hljs">viper.BindPFlag(<span class="hljs-string"><span class="hljs-string">"SERVER_PORT"</span></span>, serverCmd.PersistentFlags().Lookup(<span class="hljs-string"><span class="hljs-string">"port"</span></span>))</code> </pre> <br><p>  Bahkan, seluruh aplikasi kerangka kerja ini adalah konsol.  Server web diluncurkan oleh salah satu perintah konsol server. </p><br><pre> <code class="bash hljs">gin -i run server</code> </pre> <br><h2 id="logirovanie">  Penebangan </h2><br><p>  Saya memilih paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logrus</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logging</a> , karena ada semua yang biasanya saya butuhkan: mengatur level logging, tempat untuk login, menambahkan kait, misalnya, untuk mengirim log ke sistem peringatan. </p><br><h2 id="integraciya-loggera-s-sistemoy-alertinga">  Integrasi Logger dengan Sistem Peringatan </h2><br><p>  Saya memilih Sentry, karena semuanya ternyata cukup sederhana berkat integrasi siap pakai dengan logrus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logrus_sentry</a> .  Saya membuat <a href="">parameter</a> dengan url ke Sentry <code>SENTRY_DSN</code> dan batas waktu untuk mengirim ke Sentry <code>SENTRY_TIMEOUT</code> .  Ternyata secara default, batas waktu kecil, jika tidak salah, 300 ms, dan banyak pesan tidak terkirim. </p><br><h2 id="nastroyka-alertinga-dlya-oshibok">  Menyetel peringatan untuk kesalahan </h2><br><p>  Saya melakukan pemrosesan panik secara terpisah untuk <a href="">server web</a> dan untuk <a href="">perintah konsol</a> . </p><br><h2 id="yunit-testy-s-pereopredeleniem-servisov-cherez-di">  Tes unit dengan redefinisi layanan melalui DI </h2><br><p>  Seperti disebutkan di atas, paket terpisah harus dialokasikan untuk pengujian unit.  Karena pustaka yang dipilih untuk membuat wadah layanan tidak memungkinkan mendefinisikan ulang layanan, dalam garpu menambahkan metode untuk mendefinisikan kembali deskripsi layanan.  Karena ini, dalam pengujian unit, Anda dapat <a href="">menggunakan</a> deskripsi layanan yang sama seperti dalam aplikasi </p><br><pre> <code class="go hljs">dic.InitBuilder()</code> </pre> <br><p>  Dan <a href="">mendefinisikan ulang</a> hanya beberapa deskripsi layanan di bertopik dengan cara ini </p><br><pre> <code class="go hljs">dic.Builder.Set(di.Def{ Name: dic.UserRepository, Build: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctn di.Container)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewUserRepositoryMock(), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, })</code> </pre> <br><p>  Selanjutnya, Anda dapat <a href="">membangun wadah</a> dan menggunakan layanan yang diperlukan dalam tes: </p><br><pre> <code class="go hljs">dic.Container = dic.Builder.Build() userService := dic.Container.Get(dic.UserService).(service.UserServiceInterface)</code> </pre> <br><p>  Dengan demikian, kami akan menguji userService, yang alih-alih repositori nyata akan menggunakan rintisan yang disediakan. </p><br><p>  Persentase dan tes peta kode jangkauan <br>  Saya benar-benar puas dengan utilitas uji go standar. </p><br><p>  Anda dapat menjalankan tes secara individual </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/unit/user_service_test.go -v</code> </pre> <br><p>  Anda dapat menjalankan semua tes sekaligus </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v</code> </pre> <br><p>  Anda dapat membangun peta cakupan dan menghitung persentase cakupan </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v -coverpkg=./... -coverprofile=coverage.out</code> </pre> <br><p>  Dan lihat peta cakupan kode dengan tes di browser </p><br><pre> <code class="bash hljs">go tool cover -html=coverage.out</code> </pre> <br><h2 id="swagger">  Kesombongan </h2><br><p>  Ada proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gin-swagger</a> untuk Gin, yang dapat digunakan baik untuk menghasilkan spesifikasi untuk Swagger dan untuk menghasilkan dokumentasi berdasarkan itu.  Tetapi, ternyata, untuk menghasilkan spesifikasi untuk operasi tertentu, perlu untuk menunjukkan komentar tentang fungsi spesifik dari pengontrol.  Ini ternyata sangat tidak nyaman bagi saya, karena saya tidak ingin menduplikasi kode operasi CRUD di setiap controller.  Sebagai gantinya, pada pengontrol tertentu, saya cukup menyematkan pengontrol CRUD seperti dijelaskan di atas.  Saya juga tidak benar-benar ingin membuat fungsi rintisan. </p><br><p>  Oleh karena itu, saya sampai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesimpulan</a> bahwa spesifikasi dihasilkan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">goswagger</a> , karena dalam hal ini operasi <a href="">dapat dijelaskan tanpa terikat dengan fungsi tertentu</a> . </p><br><pre> <code class="bash hljs">swagger generate spec -o doc/swagger.yml</code> </pre> <br><p>  Ngomong-ngomong, dengan goswagger Anda bahkan bisa pergi dari kebalikannya, dan menghasilkan kode server web berdasarkan spesifikasi Swagger.  Tetapi dengan pendekatan ini, ada kesulitan dalam menggunakan ORM, dan saya akhirnya meninggalkannya. </p><br><p>  Dokumentasi dibuat menggunakan gin-swagger, untuk ini file spesifikasi yang dihasilkan sebelumnya <a href="">ditunjukkan</a> . </p><br><h2 id="docker-compose">  Menulis Docker </h2><br><p>  Dalam kerangka itu, saya menambahkan deskripsi dua kontainer - <a href="">untuk kode dan untuk pangkalan</a> .  Di awal wadah dengan kode, kami menunggu sampai wadah dengan pangkalan diluncurkan sepenuhnya.  Dan pada setiap awal, kami menggulir migrasi jika perlu.  Parameter untuk menghubungkan ke database untuk migrasi dijelaskan, seperti yang disebutkan di atas, di <a href="">dbconf.yml</a> , di mana dimungkinkan untuk menggunakan <a href="">variabel lingkungan</a> untuk mentransfer pengaturan untuk menghubungkan ke database. </p><br><p>  Terima kasih atas perhatian anda  Dalam prosesnya, saya harus beradaptasi dengan fitur bahasa.  Saya akan tertarik untuk mengetahui pendapat rekan-rekan yang menghabiskan lebih banyak waktu dengan Go.  Tentunya beberapa momen bisa dibuat lebih elegan, jadi saya akan senang menerima kritik yang berguna.  Tautan ke bingkai: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/zubroide/go-api-boilerplate</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455302/">https://habr.com/ru/post/id455302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455286/index.html">Gigi kebijaksanaan: tidak bisa dihilangkan</a></li>
<li><a href="../id455288/index.html">Berita terbaik minggu ini: pemblokir iklan perusahaan di kunci enkripsi Chrome, FSB dan Yandex, komunikasi semakin mahal</a></li>
<li><a href="../id455290/index.html">Panduan Lengkap untuk Prometheus pada tahun 2019</a></li>
<li><a href="../id455292/index.html">Cara 4 kali meningkatkan runtime perangkat dengan self-powered</a></li>
<li><a href="../id455294/index.html">Panduan: bagaimana memilih sepeda listrik menggunakan Twitter sebagai contoh - berbicara tentang bingkai</a></li>
<li><a href="../id455306/index.html">Jawaban atas pertanyaan Anda tentang mengapa Anda memerlukan penerbit untuk menerbitkan buku</a></li>
<li><a href="../id455308/index.html">Tempat yang menjanjikan</a></li>
<li><a href="../id455310/index.html">Serangan pada saluran bypass: sekarang tidak hanya PC tetapi juga smartphone sedang diserang (tinjauan analitik)</a></li>
<li><a href="../id455312/index.html">Satu-bit penambah penuh pada chip yang tidak biasa</a></li>
<li><a href="../id455314/index.html">Apa itu jaringan layanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>