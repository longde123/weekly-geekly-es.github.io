<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏻 👨🏻‍🔧 🏍️ 关于RTOS的全部真相。 第29条。 Nucleus SE的中断 ☮️ 🤴🏼 🔍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="所有现代微处理器和微控制器都包含某种中断机制。 这些机制是提供许多应用程序所需的响应能力所必需的。 当然，使用RTOS时，响应性和可预测性是主要目标，但同时又彼此相对。 使用中断会破坏实时操作系统的完整性。 在上一篇文章（第4和第6条）中提到了此问题及其解决方案。 在本文中，我们将研究Nucleus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第29条。 Nucleus SE的中断</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/">所有现代微处理器和微控制器都包含某种中断机制。 这些机制是提供许多应用程序所需的响应能力所必需的。 当然，使用RTOS时，响应性和可预测性是主要目标，但同时又彼此相对。 使用中断会破坏实时操作系统的完整性。 在上一篇文章（第4和第6条）中提到了此问题及其解决方案。 在本文中，我们将研究Nucleus SE中使用的中断处理策略。 在所有情况下，中断都不是由Nucleus SE控制的：当中断按照优先级和向量发生时，会以通常的方式进行处理。 它们的执行时间只是从主应用程序和调度程序的代码中的可用时间中“窃取”。 显然，所有的中断处理程序都应该简单，简短和快速。 <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">该系列中的先前文章：</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第28条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件计时器</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第27条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统时间</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第26条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渠道：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第25条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据通道：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第23条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号量：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十九条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号灯：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十八条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：助手服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十七条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <br></div></div><br><h2> 定期和受控中断 </h2><br>  Nucleus SE提供了两种处理中断的方法：“本机”或“常规”（本机），其中中断没有什么特别的，并且在某种程度上与操作系统的交互作用有限（至少在使用优先级调度程序时）；托管，您可以在其中从中断处理程序访问大量的API调用。 <br><br> 使用I / O宏，Nucleus SE中断处理程序可以在标准或托管模式下使用。 <br><br><h3> 员工中断 </h3><br>  Nucleus SE Staff中断是标准的中断处理程序，可以视为“不受管理”。 通常在中断可能发生的频率很高且需要处理而对计算资源的使用较少的情况下使用它们。 这种处理程序很可能是用C编写的，因为许多现代的嵌入式编译器都支持使用interrupt关键字来开发中断处理程序。 仅存储编译器认为必要的上下文信息。 这将导致对标准中断处理程序可以执行的操作的重大限制，我们很快就会看到。 <br><br> 要在Nucleus SE中创建常规中断处理程序，只需编写常规中断处理程序就足够了，包括在开头调用<b>宏NUSE_NISR_Enter（）</b> ，在末尾调用<b>NUSE_NISR_Exit（）</b> 。 这些宏在<b>nuse_types</b>文件中定义<b>。</b>  h并将全局变量<b>NUSE_Task_State</b>设置为<b>NUSE_NISR_CONTEXT</b> 。 <br><br><h3> 引导式中断 </h3><br> 如果您需要更大的灵活性来处理中断处理程序，则可以使用Nucleus SE管理的中断。 与标准中断的主要区别在于保持上下文。 受控中断不会使编译器在堆栈上保存多个寄存器，而是在输入处保存任务的整个上下文（在其自己的上下文块中）。 然后，从输出的上下文块中还原当前任务的上下文。 这提供了通过中断处理程序代码来更改当前任务的能力，这在使用优先级调度程序时是可能的。 上一篇文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃10</a> ）中提供了Nucleus SE中上下文保存和恢复的完整说明。 <br><br> 显然，与标准中断发生的情况相比，上下文的完全保留与使用多个寄存器的堆栈中的存储相比，增加了计算资源的使用。 必须为此付出额外的灵活性，这就是提供中断处理方法选择的原因。 <br><br> 使用<b>nuse_types.h中</b>描述的<b>NUSE_MANAGED_ISR（）</b>宏来构建托管中断。 该宏创建一个包含以下操作的函数： <br><br><ul><li> 维持任务的内容； </li><li> 将<b>NUSE_Task_State</b>分配<b>给</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li> 用户提供的中断处理程序功能代码； </li><li> 将<b>NUSE_Task_State</b>恢复到以前的状态； </li><li> 恢复任务的上下文。 </li></ul><br> 宏具有两个参数：用作生成的处理程序的函数名称的中断名称，以及包含中断处理程序的用户逻辑的函数的名称。 <br><br><h3> 来自中断处理程序的API调用 </h3><br> 可以从标准或托管中断处理程序中调用的API函数集取决于所使用的调度程序。 一般而言，使用优先级调度程序提供了许多选项，用于通过API函数调用来访问调度程序，这在使用标准中断处理程序时很困难。 <br><br>  <b><i>使用优先级调度程序时，对标准中断处理程序的API调用</i></b> <br><br> 使用优先级调度程序时，允许从标准中断处理程序中进行有限数量的API函数调用。 此限制是Nucleus SE API灵活性的结果：许多调用可能导致任务准备就绪，并且标准中断处理程序可能不会调用调度程序（因为未保存任务上下文）。 关闭任务锁可提供更大的灵活性。 <br><br> 始终允许以下API调用： <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br> 但是，只有<b>NUSE_Signals_Send（）</b>对它们有用，因为它提供了一种方便的方法来向任务指示需要采取某些措施。 <br><br> 如果禁用了锁定，也就是说，许多API调用无法将任务置于就绪状态，那么其他API调用将变为可用： <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br> 某些API调用始终是标准中断处理程序无法访问的，因为它们不可避免地需要调度程序的工作： <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>使用优先级调度程序以外的任何调度程序时，对托管中断处理程序或标准中断处理程序的API调用</i></b> <br><br> 使用“运行至完成”，“循环调度”或“时间片”调度程序时，可以从中断处理程序中调用更多API函数。 如果使用优先级调度程序，则托管中断处理程序具有一组相似的功能。 这是因为允许调用，这可能导致安排另一个任务。  <b>NUSE_Reschedule（）</b>代码提供了此功能，该代码在中断处理程序中检测调用上下文并抑制上下文更改（允许它在中断处理程序的末尾发生）。 在上一篇文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9</a>篇）中对调度程序的工作进行了全面分析。 <br><br> 关键要求是中断处理程序内部的API调用不应导致当前任务的挂起，例如，等待释放资源。 <br><br> 换句话说，必须使用<b>NUSE_NO_SUSPEND</b>暂停<b>选项</b>进行此类调用。 <br><br> 考虑到这一点，可以使用以下API调用： <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br> 某些呼叫始终被禁止，因为它们与当前任务直接相关： <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2> 实时时钟中断处理程序 </h2><br> 实时时钟（RTC）中断处理程序是Nucleus SE中唯一完整的中断处理程序。 除了提供Nucleus SE中时间管理的所有必要功能外，它还用作编写托管中断处理程序的示例。 <br><br><h3>  RTC中断处理程序操作 </h3><br> 先前的文章之一列出了RTC中断处理程序提供的功能，其中涉及Nucleus SE（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃27</a> ）中的系统时间这一广泛主题。 所描述的功能是可选的，具体取决于应用程序的配置。 <br><br><div class="spoiler">  <b class="spoiler_title">以下是完整的RTC中断处理程序代码。</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br> 接下来，我们看一下RTC中断处理程序的四个主要功能区域。 <br><br>  <b><i>计时器</i></b> <br> 如果配置了应用程序计时器，则中断处理程序将进入循环以通过将其计数器减1来处理每个计时器。如果计时器结束计数（即计数器达到0），则可以执行两个操作： <br><br><ul><li> 如果配置了计时器完成处理程序并且计时器具有正确的（非<b>NULL</b> ）函数指针（在<b>NUSE_Timer_Expiration_Routine_Address []中</b> ），则通过从<b>NUSE_Timer_Expiration_Routine_Parameter []中</b>获取一个参数来执行该处理程序； </li><li> 如果将计时器配置为在完成后初始化（即<b>NUSE_Timer_Reschedule_Time []</b>具有非零值），则计时器将使用该值重新加载。 </li></ul><br> 上一篇文章（＃28）中详细描述了应用程序计时器。 <br><br>  <b><i>系统时钟</i></b> <br> 如果配置了系统计时器，则<b>NUSE_Tick_Cloc</b> k的值仅增加1。有关更多信息，请参见第28条。 <br><br>  <b><i>暂停任务（任务睡眠）</i></b> <br> 如果启用了对暂停任务的支持（即，配置了<b>NUSE_Task_Sleep（）</b> API调用），则会检查每个任务的超时计数器（ <b>NUSE_Task_Timeout_Counter []中</b>的值），如果不等于零，则减少1。如果达到零，则恢复对应的任务。 <br><br>  <b><i>时间片调度</i></b> <br> 如果使用了时间片调度程序，则调度程序计数器（ <b>NUSE_Time_Slice_Ticks</b> ）会减少。 如果达到零，则调用调度程序。 对<b>NUSE_Reschedule（）</b>的调用负责重置计数器。 <br><br><h3> 控制中断 </h3><br> 必须解释为什么RTC中断处理程序是可控的，因为在某些情况下，用户可能决定将其重写为标准中断，以减少对计算资源的使用。 例如，如果仅使用一个系统时间功能（即，没有应用程序计时器，没有任务挂起，也没有时间片调度程序），则定期中断将起作用。 在以下情况下需要引导中断： <br><br><ul><li> 如果使用了计时器，并且配置了完成计时器，因为这些处理器可以（从中断上下文中）进行API调用，这将导致新的调度。 它们具有与从中断处理程序进行的API调用相同的限制（请参见本文前面的内容）。 </li><li> 如果使用优先级调度程序，则完成任务挂起可能需要唤醒具有更高优先级的任务； </li><li> 如果使用了时间片调度程序，则会从RTC中断处理程序中调用它，因此，需要一个受控中断。 </li></ul><br><h2> 兼容Nucleus RTOS </h2><br> 由于Nucleus SE中断的实现与Nucleus RTOS完全不同，因此您不应期望在这方面具有兼容性。  Nucleus RTOS具有标准/低级/高级中断方案，这有点类似于Nucleus SE中的标准/受控中断方案。 <br><br><h3> 底层和高层中断处理程序 </h3><br>  <b><i>低级中断处理程序</i></b> <br> 低级中断服务例程（LISR）的执行方式与常规处理程序相同，包括使用当前堆栈。  Nucleus RTOS会一直保持上下文，直到调用低级中断处理程序为止，并在处理程序完成后恢复上下文。 因此，低级中断处理程序可以用C编写，并且可以用C调用其他处理程序。但是，低级处理程序仅可使用少数Nucleus RTOS服务。 如果中断处理需要其他Nucleus RTOS服务，则需要激活一个高级中断处理程序。  Nucleus RTOS支持使用多个低级中断处理程序。 <br><br>  <b><i>高级中断处理程序</i></b> <br> 高级别中断服务例程（HISR）是动态创建和删除的。 每个高级处理器都有自己的堆栈空间和自己的控制单元。 内存由应用程序分配。 并且，当然，必须先创建一个高级中断处理程序，然后才能激活它。 <br><br> 由于高级中断处理程序具有自己的堆栈和控制单元，因此如果尝试访问当前正在使用的Nucleus RTOS数据结构，则可以将其暂时阻止。 <br><br> 高级中断处理程序可以使用三个优先级。 如果在具有较低优先级的处理程序的工作期间激活了具有较高优先级的较高级别的处理程序，则将在任务完成时执行具有较低优先级的处理程序。 具有相同优先级的高级中断处理程序将按照其激活顺序执行。 必须先完成所有激活的高级中断处理程序，然后才能继续以正常模式安排任务。 <br><br><h3>  Nucleus RTOS API实用程序要求中断 </h3><br>  Nucleus RTOS有几个API调用来支持中断。 它们都没有在Nucleus SE中实现。 <br><br> 对于标准中断，API调用提供以下功能： <br><br><ul><li> 控制（激活/停用）中断（本地和全局）； </li><li> 设置中断向量。 </li></ul><br> 对于低级中断： <br><br><ul><li> 在内核中注册一个低级中断处理程序。 </li></ul><br> 对于高级中断： <br><br><ul><li> 创建/消除高级中断； </li><li> 高级别中断激活； </li><li> 获取应用程序中（目前）的高级中断数； </li><li> 获取指向所有高级中断控制单元的指针； </li><li> 获取指向当前高级中断控制单元的指针； </li><li> 获取高级中断信息。 </li></ul><br>  <b><i>全局中断控制</i></b> <br><br> 无论任务如何，此调用都会激活或取消激活中断。 因此，此调用取消激活的中断将保持不变，直到通过重用此调用将其激活为止。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br> 参数： <br><br>  <b>new_level-</b>系统的新中断级别。 它始终可以取值<b>NU_DISABLE_INTERRUPTS</b> （取消激活所有中断）和<b>NU_ENABLE_INTERRUPTS</b> （激活所有中断）。 根据体系结构，其他值可能可用。 <br><br> 返回值： <br><br> 该服务调用返回先前级别的已激活中断。 <br><br>  <b><i>本地中断控制</i></b> <br><br> 通过此服务调用，您可以根据任务激活或取消激活中断。 该调用将状态寄存器更改为指定的值。 下次更改上下文时，状态寄存器将返回上一次对<b>NU_Control_Interrupts（）的</b>调用所指定的值。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br> 参数： <br><br>  <b>new_level-</b>当前任务的新中断级别。 它始终可以取值<b>NU_DISABLE_INTERRUPTS</b> （取消激活所有中断）和<b>NU_ENABLE_INTERRUPTS</b> （激活所有中断）。 根据体系结构，其他值可能可用。 <br><br> 返回值： <br> 该服务调用返回先前级别的已激活中断。 <br><br>  <b><i>设置中断向量</i></b> <br><br> 该开销将替换由中断处理程序控制的向量所指定的中断向量。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br> 参数： <br><br>  <b>vector-</b>要为其注册中断的中断向量； <br>  <b>new</b>是为向量编写的中断处理程序。 <br><br> 返回值： <br><br> 该实用程序调用返回指向先前为中断向量注册的中断处理程序的指针。 <br><br>  <b><i>低级中断记录</i></b> <br><br> 此开销使用中断向量调用低级中断处理程序的功能。 系统上下文将在调用指定的低级中断处理程序之前自动保存，并在中断处理程序完成后恢复。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br> 参数： <br><br>  <b>vector-</b>要为其注册中断的中断向量； <br>  <b>lisr_entry-</b>将为向量注册的函数，值<b>NU_NULL</b>将清除向量； <br>  <b>old_lisr</b>是先前为指定向量注册的函数。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_VECTOR-</b>无效向量； <br>  <b>NU_NOT_Rector-</b>由于尚未在l <b>isr_entry</b>中指定取消注册，因此此向量尚未注册。 <br>  <b>NO_MORE_LISRS-</b>已达到注册的低级中断处理程序的最大数量。 <br><br>  <b><i>创建一个高级中断处理程序</i></b> <br> 该实用程序调用将创建一个高级中断处理程序。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br> 参数： <br><br>  <b>hisr-</b>指向用户为高级中断处理程序提供的控制块的指针； <br>  <b>name-</b>指向以零结尾的高级中断处理程序的7个字符的名称的指针； <br>  <b>hisr_entry-</b>高级中断处理程序函数的入口； <br>  <b>优先级</b> -高级中断处理程序（0-2）具有三个优先级； 优先级0为最高； <br>  <b>stack_pointer-</b>指向高级中断处理程序的堆栈区域的指针； <br>  <b>stack_size-</b>高级中断处理程序的堆栈中的字节数。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_HISR-</b>指向高级中断处理程序（ <b>NULL</b> ）或控制单元的控制单元的空指针； <br>  <b>NU_INVALID_ENTRY-</b>指向高级中断处理程序（ <b>NULL</b> ）入口点的空指针； <br>  <b>NU_INVALID_PRIORITY-</b>高级中断处理程序的优先级不正确； <br>  <b>NU_INVALID_MEMORY-</b>无效的堆栈指针； <br>  <b>NU_INVALID_SIZE-</b>堆栈大小太小。 <br><br>  <b><i>删除高级中断处理程序</i></b> <br> 该实用程序调用将删除先前创建的高级中断处理程序。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br> 参数： <br><br>  <b>hisr</b>是指向用户提供的高级中断处理程序的控制块的指针。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_HISR-</b>指向高级中断处理程序的<b>无效</b>指针。 <br><br>  <b><i>激活高级中断处理程序</i></b> <br><br> 该实用程序调用将激活高级中断处理程序。 如果当前正在执行指定的高级中断处理程序，则在处理程序停止工作之前，不会执行激活请求。 一个高级中断处理程序针对每个激活请求运行一次。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br> 参数： <br><br>  <b>hisr</b>是指向高级中断处理程序的控制块的指针。 <br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_HISR-</b>指向高级中断处理程序的控制单元的无效指针。 <br><br>  <b><i>获取系统中高级中断处理程序的数量</i></b> <br> 该实用程序调用返回已安装的高级中断处理程序的数量。 所有创建的高级中断处理程序都被视为已安装。 远程高级中断处理程序不被视为已安装。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br> 参数： <br> 缺席。 <br><br> 返回值： <br> 该实用程序调用返回系统中已安装的高级中断处理程序的数量。 <br><br>  <b><i>获取指向高级中断处理程序的控制块的指针</i></b> <br><br> 该服务调用形成了指向系统中安装的所有高级中断处理程序的指针的顺序列表。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br> 参数： <br><br>  <b>pointer_list-</b>指针数组<b>NU_HISR</b>的指针； 该数组将填充指向系统中安装的高级中断处理程序的指针； <br>  <b>maximum_pointers-</b>可以放置在数组中的<b>NU_HISR</b>指针的最大数量； 它通常等于<b>pointer_list</b>数组的大小。 <br><br> 返回值： <br> 该实用程序调用返回系统中活动的高级中断处理程序的数量。 <br><br>  <b><i>获取指向当前高级中断处理程序的指针</i></b> <br> 该实用程序调用返回一个指向当前正在执行的高级中断处理程序的指针。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br> 参数： <br> 缺席。 <br><br> 返回值： <br> 该服务调用返回一个指向当前正在执行的高级中断处理程序的控制单元的指针。 如果非高级中断处理程序调用此函数， <b>则</b>返回<b>NU_NULL</b> 。 <br><br>  <b><i>获取有关高级中断处理程序的信息</i></b> <br> 该实用程序调用返回有关指定的高级中断处理程序的各种信息。 <br><br> 服务电话原型： <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br> 参数： <br><br>  <b>hisr-</b>指向高级中断处理程序的指针； <br>  <b>name-</b>指向高级中断处理程序名称的8个字符区域的指针，包括终止的零； <br>  <b>schedule_count-</b>指向该高级中断处理程序被调度的总次数的变量的指针； <br>  <b>优先级</b> -指向用于存储高级中断处理程序的优先级的变量的指针； <br>  <b>stack_base-</b>指向存储原始堆栈指针的指针； 这与创建高级中断处理程序时传递的指针相同； <br>  <b>stack_size-</b>指向用于存储高级中断处理程序的总堆栈大小的变量的指针； <br> <b>minimum_stack</b> –          ,      . <br><br>  : <br><br> <b>NU_SUCCESS</b> –    ; <br> <b>NU_INVALID_HISR</b> –      . <br><br><h3>  API    </h3><br> <b><i>  API    </i></b> <br>         Nucleus RTOS: <br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i>  API    </i></b> <br>         Nucleus RTOS,     -,          Nucleus RTOS,      <b>NU_NO_SUSPEND</b> . <br><br>            Nucleus SE. <br><br> <b> :</b>           ,      .   —       Mentor Embedded ( Mentor Graphics).        ,          .   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458770/">https://habr.com/ru/post/zh-CN458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458758/index.html">翻译文学的辉煌与贫穷</a></li>
<li><a href="../zh-CN458760/index.html">拉斯维加斯展览的对象是电子开发商，而不是消费者。 设计自动化会议的报告</a></li>
<li><a href="../zh-CN458764/index.html">2019年技术团队和非技术团队的基本敏捷实践</a></li>
<li><a href="../zh-CN458766/index.html">IronPython是邪恶的</a></li>
<li><a href="../zh-CN458768/index.html">参加GolangConf的5-6个理由</a></li>
<li><a href="../zh-CN458774/index.html">功能数据库管理系统</a></li>
<li><a href="../zh-CN458778/index.html">Satellite 6.5报告引擎：什么以及为什么</a></li>
<li><a href="../zh-CN458782/index.html">通过现代手段将ZX Spectrum的程序改编为TR-DOS。 第三部分</a></li>
<li><a href="../zh-CN458784/index.html">从Altium Designer到PADS Professional广播项目和库</a></li>
<li><a href="../zh-CN458786/index.html">视频游戏管理员逐步保持游戏文化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>