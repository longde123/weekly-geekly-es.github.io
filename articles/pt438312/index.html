<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏼 🙏🏾 👨🏾‍🤝‍👨🏼 Automação de rede com Ansible: módulo de comando 😐 🎭 🏝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Falando em cenários típicos de automação de rede, não se pode prescindir de um conjunto de módulos de comando. Graças a esses módulos, o Ansible permi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automação de rede com Ansible: módulo de comando</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/438312/">  Falando em cenários típicos de automação de rede, não se pode prescindir de um conjunto de módulos de comando.  Graças a esses módulos, o Ansible permite executar comandos em equipamentos de rede como se você os estivesse inserindo diretamente no console.  Ao mesmo tempo, a saída dos comandos não apenas desliza na janela do terminal para afundar no esquecimento, mas pode ser salva e usada no futuro.  Ele pode ser gravado em variáveis, analisado para uso em tarefas subseqüentes ou salvo para o futuro em variáveis ​​de host. <br><br><img src="https://habrastorage.org/webt/ga/bs/bh/gabsbhxuxhvjzjvvizswbdkkq2o.png" width="100%"><br><br>  O objetivo desta publicação é mostrar que qualquer tarefa repetitiva de gerenciamento de rede pode ser automatizada e que o Ansible não apenas permite gerenciar configurações, mas também ajuda a se livrar da rotina e economizar tempo. <br><a name="habracut"></a><br>  Vamos analisar as maneiras básicas de usar os módulos de comando de rede, incluindo salvar a saída de comandos usando o parâmetro register.  Também consideraremos como dimensionar para vários dispositivos de rede usando hostvars e como organizar a execução condicional usando o parâmetro wait_for e três outros parâmetros relacionados: intervalo, novas tentativas e correspondência. <br><br>  Diferentes plataformas de rede têm seus próprios módulos de comando, todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suportados</a> no nível de extensão do Red Hat Ansible Engine Networking Add-on: <br><br><table><tbody><tr><td>  <b>Plataformas de rede</b> </td><td>  <b>Módulos * os_command</b> </td></tr><tr><td>  Arista eos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eos_command</a> </td></tr><tr><td>  Cisco IOS / IOS-XE </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ios_command</a> </td></tr><tr><td>  Cisco IOS-XR </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">iosxr_command</a> </td></tr><tr><td>  Cisco NX-OS </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nxos_command</a> </td></tr><tr><td>  Juniper Junos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">junos_command</a> </td></tr><tr><td>  Vyos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vyos_command</a> </td></tr></tbody></table><br><h3>  Noções básicas do módulo de comando </h3><br>  Considere um manual que simplesmente execute o comando show version usando o módulo eos_command: <br><br><pre><code class="plaintext hljs">--- - name: COMMAND MODULE PLAYBOOK hosts: eos connection: network_cli tasks: - name: EXECUTE ARISTA EOS COMMAND eos_command: commands: show version register: output - name: PRINT OUT THE OUTPUT VARIABLE debug: var: output</code> </pre> <br>  Aqui temos duas tarefas e a primeira usa o módulo eos_command com um único parâmetro de comandos.  Como executamos apenas um comando - show version - ele pode ser especificado na mesma linha que o próprio parâmetro de comandos.  Se houver duas ou mais equipes, cada uma delas deverá ser colocada em uma linha separada após os comandos:.  Neste exemplo, usamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palavra</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chave register</a> para salvar a saída do comando show version.  O parâmetro register (pode ser usado em qualquer tarefa Ansible) define a variável em que a saída da nossa tarefa será salva, para que possa ser usada posteriormente.  No nosso exemplo, essa variável é chamada de saída. <br><br>  A segunda tarefa em nosso exemplo usa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo de depuração</a> para exibir o conteúdo da variável de saída recém-criada.  Ou seja, são os mesmos dados que você veria na interface da linha de comandos no dispositivo EOS se você inserisse "show version" lá.  A diferença é que nosso manual irá mostrá-los na janela do terminal em que você o inicia.  Como você pode ver, o módulo de depuração facilita a verificação de variáveis ​​Ansible. <br><br>  Aqui está o resultado do nosso manual: <br><br><pre> <code class="plaintext hljs">PLAY [eos] ************************************************************************* TASK [execute Arista eos command] ************************************************** ok: [eos] TASK [print out the output variable] *********************************************** ok: [eos] =&gt; { "output": { "changed": false, "failed": false, "stdout": [ "Arista vEOS\nHardware version: \nSerial number: \nSystem MAC address: 0800.27ec.005e\n\nSoftware image version: 4.20.1F\nArchitecture: i386\nInternal build version: 4.20.1F-6820520.4201F\nInternal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91\n\nUptime: 1 day, 3 hours and 23 minutes\nTotal memory: 2017324 kB\nFree memory: 1111848 kB" ], "stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 3 hours and 23 minutes", "Total memory: 2017324 kB", "Free memory: 1111848 kB" ] ] } } PLAY RECAP ************************************************************************* eos : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  Como pode ser visto na captura de tela, nossas tarefas foram bem-sucedidas.  Como a primeira tarefa usa o nível de detalhe padrão das mensagens, simplesmente diz que o host eos concluiu a tarefa com o resultado ok, destacando o sucesso da execução em verde.  A segunda tarefa, com o módulo debug, retorna a saída do comando executado, exibindo as mesmas informações em dois formatos: <br><br><ul><li>  stdout </li><li>  stdout_lines </li></ul><br>  A seção stdout mostra a mesma coisa que você veria na interface da linha de comandos do dispositivo, mas na forma de uma linha longa.  E a seção stdout_lines divide essa saída em linhas para facilitar a leitura.  Cada item desta lista é uma linha separada na saída do comando. <br><br>  Compare a saída do comando no dispositivo e no Ansible: <br><br><table><tbody><tr><td>  <b>Saída da equipe no Arista EOS</b> </td><td>  <b>stdout_lines no Ansible</b> </td></tr><tr><td>  eos&gt; show vers <br>  Arista vEOS <br>  Versão do hardware: <br>  Número de série: <br>  Endereço MAC do sistema: 0800.27ec.005e <br><br>  Versão da imagem do software: 4.20.1F <br>  Arquitetura: i386 <br>  Versão de compilação interna: 4.20.1F-6820520.4201F <br>  ID da compilação interna: 790a11e8-5aaf-4be7-a11a-e61795d05b91 <br><br>  Tempo de atividade: 1 dia, 3 horas e 56 minutos <br>  Memória total: 2017324 kB <br>  Memória livre: 1116624 kB </td><td>  "Stdout_lines": [ <br>  [ <br>  "Arista vEOS", <br>  "Versão do hardware:", <br>  "Número de série:", <br>  "Endereço MAC do sistema: 0800.27ec.005e", <br>  "", <br>  "Versão da imagem do software: 4.20.1F", <br>  "Arquitetura: i386", <br>  "Versão de compilação interna: <br>  4.20.1F-6820520.4201F ", <br>  "ID da versão interna: <br>  790a11e8-5aaf-4be7-a11a-e61795d05b91 ", <br>  "", <br>  "Tempo de atividade: 1 dia, 3 horas e 23 minutos", <br>  "Memória total: 2017324 kB", <br>  "Memória livre: 1111848 kB" <br>  ] </td></tr></tbody></table><br>  Se você conhece JSON e YAML, provavelmente já prestou atenção em uma singularidade: stdout_lines começa com dois colchetes de abertura: <br><br><pre> <code class="plaintext hljs">"stdout_lines": [ [</code> </pre><br>  Dois colchetes de abertura indicam que stdout_lines realmente retorna uma lista de listas de linhas.  Se você modificar ligeiramente nossa tarefa de depuração, esse chip poderá ser usado para exibir seletivamente os resultados do comando.  Como existe apenas uma lista de linhas em nossa lista, essa lista é chamada zero (na verdade, é a primeira, mas a contagem vai do zero).  Agora vamos ver como extrair uma linha separada dela, por exemplo, Endereço MAC do Sistema.  Na saída do comando, essa linha é a quarta de uma linha, mas, como contamos do zero, precisamos da linha 3 da lista 0, ou seja: output.stdout_lines [0] [3]. <br><br><pre> <code class="plaintext hljs"> - name: print out a single line of the output variable debug: var: output.stdout_lines[0][3]   debug-   : TASK [print out a single line of the output variable] ****************************** ok: [eos] =&gt; { "output.stdout_lines[0][3]": "System MAC address: 0800.27ec.005e" }</code> </pre><br>  Qual é o objetivo da numeração da lista e por que é necessário?  O fato é que, dentro da mesma tarefa, você pode executar várias equipes, por exemplo, assim (aqui temos três equipes): <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show version - show ip int br - show int status register: output - name: print out command debug: var: output.stdout_lines</code> </pre><br>  Aqui está a aparência da saída: <br><br><pre> <code class="plaintext hljs"> "output.stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 4 hours and 20 minutes", "Total memory: 2017324 kB", "Free memory: 1111104 kB" ], [ "Interface IP Address Status Protocol MTU", "Ethernet1 172.16.1.1/24 up up 1500", "Management1 192.168.2.10/24 up up 1500" ], [ "Port Name Status Vlan Duplex Speed Type Flags", "Et1 connected routed full unconf EbraTestPhyPort ", "Et2 connected 1 full unconf EbraTestPhyPort ", "Et3 connected 1 full unconf EbraTestPhyPort ", "Ma1 connected routed a-full a-1G 10/100/1000" ] ]</code> </pre><br>  Aqui, o número da lista zero é a saída do comando show version, a lista número um é a saída show ip int br, a lista número dois é a saída show int status.  Ou seja, o número da lista é determinado pela ordem em que os comandos são executados. <br><br><table><tbody><tr><td>  <b>Equipes Arista EOS</b> </td><td>  <b>Listas de saída correspondentes</b> </td></tr><tr><td>  mostrar versão </td><td>  output.stdout_lines [0] </td></tr><tr><td>  mostre o IP int br </td><td>  output.stdout_lines [1] </td></tr><tr><td>  mostre o status int </td><td>  output.stdout_lines [2] </td></tr></tbody></table><br><h3>  Escala do módulo de comando: variáveis ​​do host </h3><br>  E o que acontece se você executar o manual em vários dispositivos ao mesmo tempo? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9g/e0/ap/9ge0apzkt1vioj3gtttw2eivili.png"></div><br><br>  Para ser exclusiva, a variável de saída é armazenada como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma variável de host</a> para cada host no inventário.  Se tivermos três switches e executarmos nosso manual sobre eles, obteremos a variável de saída para cada host único.  Suponha que precisamos do endereço IP do comando show ip int br para a porta Ethernet1 no switch03.  Como show ip int br é o segundo comando executado como parte da tarefa e os dados Ethernet1 estão contidos na segunda linha de sua saída, precisaremos escrever stdout_lines [1] [1].  Para acessar as variáveis ​​de um host específico, usamos a palavra-chave hostvars e pesquisamos o host que precisamos pelo nome. <br><br>  Veja como fazê-lo: <br><br><pre> <code class="plaintext hljs"> - name: debug hostvar debug: var: hostvars["switch03"].output.stdout_lines[1][1]</code> </pre><br>  Como resultado, a saída contém exatamente o que precisamos: <br><br><pre> <code class="plaintext hljs">TASK [debug hostvar] *************************************************************** ok: [switch03] =&gt; { "hostvars[\"switch03\"].output.stdout_lines[1][1]": "Ethernet1 172.16.1.3/24 up up 1500" }</code> </pre><br>  Por padrão, a tarefa usa as variáveis ​​do host atual, mas o hostvars permite acessar diretamente as variáveis ​​de outro host. <br><br><h3>  Condições em tarefas com módulos de comando: parâmetro wait_for </h3><br>  O parâmetro wait_for permite implementar uma verificação de condição imediatamente após a execução do comando.  Por exemplo, para que a tarefa seja considerada concluída com êxito apenas se a saída do comando de verificação de status contiver determinado texto.  Por padrão, o parâmetro wait_for não é usado, portanto, a tarefa é executada apenas uma vez, como nos exemplos acima.  Porém, se você a definir explicitamente, a tarefa será reiniciada até que a condição seja atendida ou o limite de tentativas seja excedido (há 10 por padrão).  Se você habilitar o log de comandos, poderá ver que, no manual abaixo (especialmente escrito para que a condição nunca ocorra), tudo acontece exatamente assim. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show int status wait_for: - result[0] contains DURHAM</code> </pre><br>  Este manual executará o comando show int status 10 vezes, porque sua saída nunca conterá uma linha DURHAM. <br><br>  Você pode verificar isso usando o comando show logging: <br><br><pre> <code class="plaintext hljs">Mar 24 20:33:52 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=17 start_time=1521923632.5 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:53 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=18 start_time=1521923633.71 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:54 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=19 start_time=1521923634.81 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:55 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=20 start_time=1521923635.92 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:56 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=21 start_time=1521923636.99 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:58 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=22 start_time=1521923638.07 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:59 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=23 start_time=1521923639.22 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:00 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=24 start_time=1521923640.32 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:01 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=25 start_time=1521923641.4 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:02 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=26 start_time=1521923642.47 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status</code> </pre><br>  Agora, vejamos um exemplo de um manual real, no qual tudo está configurado para estabelecer uma vizinhança OSPF (adjacência) com um dispositivo que não seja o comando ip ospf area.  Aplicamos esse comando e, em seguida, usamos o parâmetro wait_for para verificar a presença da palavra FULL na saída: se estiver lá, a vizinhança foi estabelecida com sucesso.  Se CHEIO não aparecer em 10 tentativas, a tarefa falhará. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: turn on OSPF for interface Ethernet1 eos_config: lines: - ip ospf area 0.0.0.0 parents: interface Ethernet1 - name: execute Arista eos command eos_command: commands: - show ip ospf neigh wait_for: - result[0] contains FULL</code> </pre><br>  Execute este manual usando o comando ansible-playbook: <br><br><pre> <code class="plaintext hljs">➜ ansible-playbook ospf.yml PLAY [eos] ********************************************************************************************* TASK [turn on OSPF for interface Ethernet1] ******************************************************* changed: [eos] TASK [execute Arista eos command] **************************************************************** ok: [eos] PLAY RECAP ****************************************************************************************** eos : ok=2 changed=1 unreachable=0 failed=0</code> </pre><br>  Observamos a linha de comando e vemos que o manual foi bem-sucedido: <br><br><pre> <code class="plaintext hljs">eos#show ip ospf neigh Neighbor ID VRF Pri State Dead Time Address Interface 2.2.2.2 default 1 FULL/DR 00:00:33 172.16.1.2 Ethernet1</code> </pre><br>  Além de contém, você pode usar os seguintes operadores de comparação: <br><br><ul><li>  eq: - é igual </li><li>  neq: - não é igual </li><li>  gt: - mais </li><li>  ge: - maior ou igual a </li><li>  lt: - menos </li><li>  le: - menor ou igual a </li></ul><br>  Além disso, junto com wait_for, você pode usar três parâmetros adicionais (descritos em detalhes na documentação dos módulos): <br><br><table><tbody><tr><td>  <b>Parâmetro</b> </td><td>  <b>Descrição do produto</b> </td></tr><tr><td>  intervalo </td><td>  Tempo entre repetições de uma equipe. </td></tr><tr><td>  tentativas </td><td>  Máx.  o número de repetições antes que a tarefa seja concluída com um erro ou a condição seja atendida. </td></tr><tr><td>  combinar </td><td>  A coincidência de todas as condições ou pelo menos uma. </td></tr></tbody></table><br>  Vamos nos aprofundar mais detalhadamente no parâmetro match: <br><br><pre> <code class="plaintext hljs"> - name: execute Arista eos command eos_command: commands: - show ip ospf neigh match: any wait_for: - result[0] contains FULL - result[0] contains 172.16.1.2</code> </pre><br>  Quando match: any for especificado, a tarefa será considerada bem-sucedida se o resultado contiver FULL ou 172.16.1.2.  Se match: all for especificado, o resultado deverá conter FULL e 172.16.1.2.  Por padrão, match: all é usado, porque se você prescreve várias condições, provavelmente deseja que elas sejam executadas todas, e não pelo menos uma. <br><br>  Quando pode corresponder: algum é útil?  Suponha que você precise verificar se o centro de dados possui uma conexão bidirecional com a Internet.  E o data center está conectado a cinco provedores de Internet diferentes, cada um com sua própria conexão BGP.  Um manual pode verificar todas essas cinco conexões e, se pelo menos uma delas funcionar, e não as cinco, informar que tudo está em ordem.  Lembre-se de que any é um OR lógico e tudo é um AND lógico. <br><br><table><tbody><tr><td>  <b>Parâmetro</b> </td><td>  <b>Descrição do produto</b> </td></tr><tr><td>  match: any </td><td>  "OR" lógico <br>  É necessária pelo menos uma condição </td></tr><tr><td>  match: all </td><td>  "E" lógico <br>  Todas as condições necessárias </td></tr></tbody></table><br><h3>  Condições negativas: construindo a lógica inversa </h3><br>  Às vezes, é importante não o que está na conclusão, mas o que não está lá.  Aqui, é claro, é sempre tentador usar o operador de comparação neq, mas para alguns cenários com condições negativas, existem opções melhores.  Por exemplo, se você precisar inverter a instrução contains (do tipo "a saída do comando não deve conter tal e tal"), você pode usar a palavra-chave register para salvar a saída e processá-la na próxima tarefa usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expressão when</a> .  Ou, por exemplo, quando precisar interromper o manual, se as condições não forem atendidas, basta usar os módulos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falha</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">declaração</a> para sair especificamente com o erro.  Quanto ao operador de comparação neq, é útil apenas quando você pode extrair o valor exato da saída (por exemplo, de um par de valores-chave ou de JSON), e não apenas uma sequência ou uma lista de sequências.  Caso contrário, será realizada a comparação caractere por seqüência de caracteres. <br><br><h3>  O que vem a seguir </h3><br>  Leia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> sobre como trabalhar com a saída de comandos nos módulos de rede.  Ele fornece exemplos úteis do uso de ge, le e outras condições ao trabalhar com saída no formato JSON em plataformas de rede específicas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438312/">https://habr.com/ru/post/pt438312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438298/index.html">Por que ensinar se o desenvolvimento é mais rentável? Conversa com GeekBrains</a></li>
<li><a href="../pt438302/index.html">A incrível criatividade da evolução digital</a></li>
<li><a href="../pt438304/index.html">Subcontratação? Legal, você bate</a></li>
<li><a href="../pt438306/index.html">Radiação: Laboratório radioquímico durante a semana</a></li>
<li><a href="../pt438310/index.html">Instagram usa aprendizado de máquina para remover seguidores falsos</a></li>
<li><a href="../pt438314/index.html">1. Check Point Maestro Hyperscale Network Security - uma nova plataforma de segurança escalável</a></li>
<li><a href="../pt438316/index.html">Noções básicas de campo de distância assinado em 2D</a></li>
<li><a href="../pt438318/index.html">Como dominar a sintaxe assíncrona / aguardar: um exemplo real</a></li>
<li><a href="../pt438320/index.html">Ensinar as crianças a programar</a></li>
<li><a href="../pt438322/index.html">VSaaS 2025: tecnologia de CFTV do futuro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>