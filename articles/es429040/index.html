<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛪️ 🙇🏼 🔘 Parchear código Java en producción sin anestesia 👌🏾 📇 🤺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aquí hablaré sobre el dispositivo de una de las muchas herramientas que ayudan en el desarrollo de varios servicios para el proyecto Odnoklassniki. De...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parchear código Java en producción sin anestesia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/429040/"><img src="https://habrastorage.org/webt/di/gh/wc/dighwcvw92d2zysgdcdref8_ptg.png" alt="imagen"><br><br>  Aquí hablaré sobre el dispositivo de una de las muchas herramientas que ayudan en el desarrollo de varios servicios para el proyecto Odnoklassniki.  Dentro de la empresa, lo llamamos "Reemplazo de código activo" (HCR), y esta herramienta está diseñada para corregir errores críticos y sin complicaciones al ejecutar servicios de producción sin detenerlos.  Esta es una característica extremadamente importante, ya que le permite evitar el proceso bastante aburrido y lento de diseñar una nueva versión corregida del servicio basura, para evitar la pausa suficiente de la operadora en la disponibilidad de cada host y evitar el vaciado de cachés. <br><br>  En general, ahorra mucho tiempo y reduce el intervalo desde el momento en que se detecta el error hasta la corrección de horas a minutos.  En la mayoría de los casos, como se planeó, se corrigen errores menores en el código, por ejemplo, el programador olvidó verificar si es nulo y para algunos usuarios ciertas acciones en el sitio conducen a un error.  Es decir, cuando la corrección se lleva a cabo cambiando varias líneas dentro del método.  Y en aras de tales cambios menores, ya no necesita distraer a sus colegas y esperar horas disponibles para la producción. <br><a name="habracut"></a><br>  Por ejemplo: <br><br><img src="https://habrastorage.org/webt/ra/dh/vz/radhvzc9u4d1q6dc8r4v6uhlekq.png" alt="imagen"><br>  Puedes arreglarlo fácilmente en: <br><br><img src="https://habrastorage.org/webt/rp/9i/ta/rp9itax-od_0ahz3yg8dxdxvf7u.png" alt="imagen"><br>  Por supuesto, puede hacer muchos más cambios, al mismo tiempo agregar nuevas clases, hacer rápidamente los cambios que el administrador solicita al mismo tiempo, sin esperar la próxima actualización.  Pero esto ya es así, si Monsieur sabe mucho sobre perversiones. <br><br>  Además, es posible poner "parches" entre sí y hasta el infinito. <br><br>  Pero esta herramienta no es omnipotente y se basa en la funcionalidad estándar que ofrece la clase Java: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">java.lang.instrument.Instrumentation y su método void redefineClasses (ClassDefinition ... definiciones)</a> . <br><br>  Instrumentation.redefineClasses reemplaza las clases cargadas previamente con un nuevo código de bytes.  Puede sobrecargar varias clases con diferentes dependencias al mismo tiempo.  La sobrecarga no cambia las instancias de clase existentes, no cambia la herencia y no toca los campos de instancia o clase.  Solo puede cambiar el cuerpo del método, el conjunto de constantes y atributos.  Puede agregar nuevas clases o subclases.  Las firmas de métodos, los campos de instancia y los campos de clase no se pueden cambiar.  Si intenta realizar cambios incompatibles, redefineClasses en principio no funcionará y arrojará un error.  Debe recordarse que cuando las clases se sobrecargan, la ejecución de la sección de código sobrecargada no se interrumpe, el nuevo bytecode se usará la próxima vez que se llame al mismo método.  Y, por lo tanto, si intenta corregir el código de un método que tiene un ciclo infinitamente largo en su interior, el reemplazo real ocurrirá solo después de que termine este ciclo. <br><br>  Si simplemente: puede cambiar el código solo dentro de los métodos y el punto. <br><br>  Y aquí hay un ejemplo de un ciclo while, que hasta que se complete el método, no se solucionará. <br><br><img src="https://habrastorage.org/webt/p7/rv/1a/p7rv1agfvd0f7phg4otdxedkohk.png" alt="imagen"><br><br>  La principal dificultad fue hacer una herramienta que funcione en el ecosistema Odnoklassniki, una herramienta que se ajuste a todos los procesos de trabajo establecidos.  Que interactuará de manera consistente y transparente con todos los servicios en cientos de hosts, además de ser flexible y fácil de usar.  Esta herramienta debería hacer frente a docenas de experimentos, trabajos y actualizaciones que ocurren continuamente en la producción. <br><br>  ¿Cómo se ve el proceso de instalación de un parche desde el punto de vista del desarrollador / administrador que trata de corregir un error en la producción, pero para que pueda hacerse usando algún procedimiento estándar y confiable en docenas de servidores?  Omitimos el proceso de encontrar y corregir errores en el código. <br><br>  1. Se crea un brunch por separado en GIT para las correcciones de código.  El uso de versiones es muy importante no solo por conveniencia, sino también para posibles investigaciones posteriores. <br><br>  2. TeamCity lanza el proceso de compilación del parche.  Primero, se crea un ensamblaje de proyecto a partir del brunch especificado, y luego se compara el nuevo ensamblaje con el instalado en la producción.  Para hacer esto, escribí un complemento para la herramienta de compilación, que extrae todos los archivos de los archivos, compara las discrepancias y selecciona solo aquellos archivos que han cambiado o agregado.  En este caso, la versión del compilador de Java en ambos ensamblados debería ser la misma, porque  otra versión del compilador creará diferentes archivos y casi todos los archivos del proyecto se incluirán en el parche.  Es muy importante crear solo un pequeño archivo, en el que solo se obtendrán los archivos necesarios, porque  Esto acelerará significativamente el proceso de entrega del parche a docenas de servidores.  El proceso de compilación es adecuado no solo para el parche del código del proyecto, sino que también puede reemplazar la biblioteca parcheada en el proyecto.  Al comparar el contenido de dos ensamblajes, se encontrarán diferencias en las bibliotecas (archivos jar). <br><br>  3. En caso de un ensamblaje exitoso, el parche se envía a un repositorio especial, y en la ventana de resultados se emite una clave (o hash), que es necesaria para identificar de forma única el parche y garantizar que este código llegue a la producción. <br><br><img src="https://habrastorage.org/webt/7v/c5/es/7vc5esvpyls4kbc-djqnyxp5owq.png" alt="imagen"><br><br>  Bueno, y de nuevo: puede parchear un número ilimitado de veces y las compilaciones con el mismo número de versión diferirán en un hash. <br><br>  4. Luego, toda la actividad se transfiere al servicio de configuración, donde en la IU habitual puede especificar para qué servicio, en qué hosts y qué versiones de aplicaciones necesita parchear. <br><br><img src="https://habrastorage.org/webt/pd/qf/um/pdqfummd7yqcqr0igjjbdshtnqk.png" alt="imagen"><br><br>  Tal abundancia de parámetros proporciona el nivel necesario de flexibilidad de configuración, que es muy importante en un gran zoológico desde muchos servidores.  Digamos que en alguna parte de los servidores el número de versión de la aplicación es diferente y no necesita parchear este código en absoluto.  O, para la verificación, Hot Code Rreplace se inicia primero en un servidor o en un grupo de servidores, y luego se distribuye en todas las instancias de la aplicación. <br><br>  5. A través de un cambio de configuración, los servicios seleccionados reciben información sobre lo que necesita instalar el parche, su versión y el hash de verificación.  La idea es que todos los servicios reciban el comando "instalar el parche" y luego actuar de forma independiente.  Comparan independientemente su propia versión y solo si la versión coincide y falta el hash del parche o es diferente, descargan independientemente el ensamblaje del parche desde el repositorio.  El proceso de descarga en sí se realiza a través de HTTP, y puede cambiar rápidamente la dirección del repositorio, el número de intentos de descarga y el período de espera entre reintentos. <br><br>  6. Cada aplicación comprueba localmente el hash del ensamblado y lo desempaqueta.  En este caso, se comprueba la presencia de cada archivo en la matriz entre los devueltos por Instrumentation.getAllLoadedClasses (), todas las clases y archivos nuevos se escriben en uno nuevo: una ruta de clase temporal, y esta ruta de clase se agrega a través de Instrumentation.appendToSystemClassLoaderSearch (), y las clases existentes se leen en la memoria y pasar por el método redefineClasses. <br><br>  7. Todo el proceso: la llegada de una señal sobre la necesidad de parchear la aplicación, su descarga, verificación, desempaquetado y aplicación se registra en detalle, tanto en el registro general con la aplicación como en el propio, para que pueda monitorear el proceso rápidamente y sin gestos innecesarios. <br><br>  8. Después de que el parche se aplica con éxito, el proceso finaliza cambiando la versión de la aplicación a la parcheada agregando una línea especialmente compuesta que incluye el hash del parche.  En el caso de que para algún host la versión no haya cambiado a la esperada, vamos al registro de Reemplazo de código activo para ese host y veremos qué sucedió allí.  Si se tratara de problemas de comunicación, puede repetir con seguridad el comando de revisión y el host deseado lo intentará nuevamente. <br><br>  ¿Qué posibles problemas pueden evitar que la aplicación parchee?  Hay bastantes de ellos, y entre ellos la funcionalidad de la clase Instrumentation que pondría en último lugar.  Hasta ahora, el código torcido que no cumple con las estrictas condiciones de redefineClasses siempre ha sido actualizado por la JVM sin ninguna consecuencia para la aplicación.  Al aplicar el método redefineClasses, la JVM detiene completamente la aplicación, pero este proceso lleva una fracción de segundo.  Porque no da nada de miedo. <br><br>  El momento más arriesgado es la entrega del parche al servidor, que se decidió mediante reentrenamientos adicionales.  Pero si las retransmisiones no ayudan, puede repetir el comando para llamar al parche y cada uno de los hosts intentará repetir el proceso, pero instale el parche solo si es necesario, es decir.  el parche no se ha instalado previamente o si la clave hash ha cambiado. <br><br>  Otro problema potencial es cuando la solución corrige un error y agrega uno nuevo.  Para minimizar este riesgo, primero cargamos el parche en un número limitado de servidores, miramos los registros, gráficos y monitoreamos el resultado.  Y solo entonces implementamos correcciones a otros hosts. <br><br>  ¿Qué hacer al reiniciar una aplicación o servidor?  Esto ya está incrustado en la lógica de todas las aplicaciones classmate: una de las primeras en cualquier aplicación es el módulo HCR.  Y si durante la inicialización se nota información sobre la necesidad de parchear la aplicación, primero se aplicará el parche. <br><br>  Y ahora un poco sobre en qué consiste Hot Code Replace. <br><br><ol><li>  Nuestro JavaAgent.  JavaAgent, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">si alguien lo ha olvidado</a> , este es un archivo * .jar separado, especialmente formado, que JVM recoge cuando la aplicación comienza a usar un parámetro adicional, por ejemplo: -javaagent: /path/to/lib/my-agent.jar Gracias a las características adicionales de Javaagent- y es posible usar magia de reemplazo de código.  Es en el agente donde está disponible la clase java.lang.instrument.Instrumentation.  Pero, no lo obstruí (el agente) con código extra, porque  La actualización del agente es una tarea no trivial, pero simplemente movió la instancia de la clase Instrumentation al campo estático de la clase de utilidad.  Por lo tanto, todas las manipulaciones pueden iniciarse desde cualquier lugar de la aplicación. </li><li>  Servicio de configuración: es responsable de la configuración de cualquiera de nuestras aplicaciones y, por lo tanto, se inicializa primero en cada aplicación.  Es allí donde se oculta la funcionalidad principal de Hot Code Replace.  Al iniciar la aplicación o al cambiar la configuración de HCR para una aplicación en particular, se verifica la compatibilidad de la versión y se realizan todas las manipulaciones anteriores. </li><li>  TeamCity y scripts de creación: para crear convenientemente "parches" y guardar solo clases y recursos modificados o agregados en ellos. </li></ol><br>  ¿Cuáles son las ventajas que tenemos de esta herramienta?  El primero es la velocidad de corregir errores críticos en el producto.  Desde los registros, veo que los colegas gradualmente comenzaron a usar HCR cada vez más a menudo, en lugar de esperar a que se publicaran.  Lo siguiente es la velocidad de aplicación.  No es necesario detener la aplicación, la JVM solo se congela por una fracción de segundo y todos sus objetos permanecen en sus lugares y continúan funcionando. <br><br>  Y nuestros desarrolladores se curaron libre y felizmente y corrigieron sus errores de forma inmediata e independiente directamente en producción sin tener en cuenta la cantidad de servidores y la carga. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429040/">https://habr.com/ru/post/es429040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429030/index.html">Logomachine hace logotipos gratis por comentario</a></li>
<li><a href="../es429032/index.html">Splunk Essentials para la aplicación de la industria de servicios financieros, o cómo Splunk ingresa al mercado de análisis financiero</a></li>
<li><a href="../es429034/index.html">Algunas historias sobre programadores underground</a></li>
<li><a href="../es429036/index.html">Confía en mí, sé lo que estoy haciendo: autoadaptación de un robot modular al entorno de ejecución de tareas</a></li>
<li><a href="../es429038/index.html">Rust News # 2 (octubre de 2018)</a></li>
<li><a href="../es429042/index.html">Estamos probando SharxBase, una plataforma de virtualización de software y hardware del proveedor ruso SharxDC</a></li>
<li><a href="../es429046/index.html">Cuatro años de desarrollo de SObjectizer-5.5. ¿Cómo ha cambiado SObjectizer durante este tiempo?</a></li>
<li><a href="../es429048/index.html">Consejos para un hoster novato</a></li>
<li><a href="../es429050/index.html">Ataque de intercambio de criptomonedas Gate.io registrado</a></li>
<li><a href="../es429052/index.html">¿Por qué en las laptops táctiles algunos SPA dejaron de admitir eventos táctiles?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>