<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 〽️ 👨🏽‍🚒 Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 2 👩🏾‍🤝‍👨🏻 🦐 👩🏿‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspiriert vom ersten Parsing- Sieg mit einer Beschreibung einer Inselszene aus Disneys Moana- Cartoon, ging ich weiter auf das Studium der Speichernu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417445/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg" alt="Bild"></div><br>  Inspiriert vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Parsing- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sieg</a> mit einer Beschreibung einer Inselszene aus Disneys <em>Moana-</em> Cartoon, ging ich weiter auf das Studium der Speichernutzung ein.  Mit der Vorlaufzeit konnte noch viel getan werden, aber ich entschied, dass es nützlich wäre, zuerst die Situation zu untersuchen. <br><br>  Ich habe die Laufzeituntersuchung mit den integrierten pbrt-Statistiken gestartet.  pbrt verfügt über eine manuelle Einstellung für wichtige Speicherzuweisungen, um die Speichernutzung zu verfolgen. Nach Abschluss des Renderns wird ein Speicherzuweisungsbericht angezeigt.  Der Speicherzuordnungsbericht für diese Szene lautete ursprünglich wie folgt: <br><br> <code> <br> BVH- 9,01  <br>  1,44  <br> MIP- 2,00  <br>   11,02 </code> <br> <br>  In Bezug auf die Laufzeit stellte sich heraus, dass die integrierten Statistiken kurz waren und nur die Speicherzuordnung für bekannte Objekte mit einer Größe von 24 GB meldeten.  <code>top</code> sagte, dass tatsächlich etwa 70 GB Speicher verwendet wurden, dh 45 GB wurden in der Statistik nicht berücksichtigt.  Kleine Abweichungen sind durchaus verständlich: Dynamische Speicherzuordnungen benötigen zusätzlichen Speicherplatz zum Registrieren der Ressourcennutzung, einige gehen aufgrund von Fragmentierung verloren und so weiter.  Aber 45 GB?  Hier versteckt sich definitiv etwas Schlimmes. <br><a name="habracut"></a><br>  Um zu verstehen, was uns fehlt (und um sicherzustellen, dass wir richtig verfolgt haben), habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">massif verwendet</a> , um die tatsächliche Zuordnung des dynamischen Speichers zu verfolgen.  Es ist ziemlich langsam, aber zumindest funktioniert es gut. <br><br><h2>  Primitive </h2><br>  Das erste, was ich beim Verfolgen des Massivs fand, waren zwei Codezeilen, die Instanzen der Basisklasse <code>Primitive</code> , die in der Statistik nicht berücksichtigt werden, im Speicher zuordneten.  Ein kleines Versehen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ziemlich einfach zu beheben ist</a> .  Danach sehen wir Folgendes: <br><br> <code>Primitives 24,67 </code> <br> <br>  Ups  Was ist also ein Primitiv und warum all diese Erinnerung? <br><br>  pbrt unterscheidet zwischen <code>Shape</code> , bei der es sich um reine Geometrie (Kugel, Dreieck usw.) handelt, und <code>Primitive</code> , bei der es sich um eine Kombination aus Geometrie, Material, manchmal der Funktion der Strahlung und dem Medium handelt, das innerhalb und außerhalb der Oberfläche der Geometrie beteiligt ist. <br><br>  <a href="">Für die</a> Basisklasse <code>Primitive</code> gibt es <a href="">mehrere Optionen</a> : <code>GeometricPrimitive</code> , ein Standardfall: eine Vanillekombination aus Geometrie, Material usw., sowie <code>TransformedPrimitive</code> , ein Primitiv, auf das Transformationen angewendet werden, entweder als Instanz eines Objekts oder zum Verschieben von Primitiven mit Transformationen, die sich im Laufe der Zeit ändern.  Es stellt sich heraus, dass in dieser Szene beide Typen Platzverschwendung sind. <br><br><h3>  GeometricPrimitive: 50% zusätzlicher Speicherplatz </h3><br>  <em>Hinweis: Bei dieser Analyse werden einige falsche Annahmen getroffen.</em>  <em>Sie werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierten Beitrag der Serie</a> überarbeitet.</em> <br><br>  4,3 GB für <code>GeometricPrimitive</code> .  Es ist lustig, in einer Welt zu leben, in der 4,3 GB verwendeter RAM nicht Ihr größtes Problem sind, aber lassen Sie uns trotzdem sehen, woher wir 4,3 GB <code>GeometricPrimitive</code> .  Hier sind die relevanten Teile der Klassendefinition: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeometricPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface; };</code> </pre> <br>  Wir haben einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeiger auf vtable</a> , drei weitere Zeiger und dann ein <code>MediumInterface</code> das zwei weitere Zeiger mit einer Gesamtgröße von 48 Bytes enthält.  Es gibt nur wenige lichtemittierende Netze in dieser Szene, daher ist <code>areaLight</code> fast immer ein Nullzeiger, und es gibt keine Umgebung, die die Szene beeinflusst, sodass beide <code>mediumInterface</code> ebenfalls null sind.  Wenn wir also eine spezielle Implementierung der <code>Primitive</code> Klasse hätten, die ohne die Strahlungs- und Medienfunktionen verwendet werden könnte, würden wir fast die Hälfte des von <code>GeometricPrimitive</code> belegten Speicherplatzes einsparen - in unserem Fall etwa 2 GB. <br><br>  Ich habe es jedoch nicht behoben und pbrt eine neue <code>Primitive</code> Implementierung hinzugefügt.  Wir bemühen uns aus einem sehr einfachen Grund, die Unterschiede zwischen dem pbrt-v3-Quellcode auf github und dem in meinem Buch beschriebenen System zu minimieren. Wenn Sie sie synchron halten, können Sie das Buch leicht lesen und mit dem Code arbeiten.  In diesem Fall entschied ich, dass die völlig neue Implementierung von <code>Primitive</code> , die im Buch nie erwähnt wurde, einen zu großen Unterschied darstellen würde.  Aber dieses Update wird definitiv in der neuen Version von pbrt erscheinen. <br><br>  Bevor wir fortfahren, machen wir ein Test-Rendering: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg"></div><br>  <i>Strand von der Insel aus dem Film "Moana" von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> mit einer Auflösung von 2048x858 und 256 Samples pro Pixel.</i>  <i>Die gesamte Renderzeit auf der 12-Core / 24-Thread-Instanz von Google Compute Engine mit einer Frequenz von 2 GHz mit der neuesten Version von pbrt-v3 betrug 2 Stunden 25 Minuten 43 Sekunden.</i> <br><br><h3>  TransformedPrimitives: 95% verschwendeter Speicherplatz </h3><br>  Der unter 4,3 GB <code>GeometricPrimitive</code> zugewiesene Speicher war ein ziemlich schmerzhafter Treffer, aber was ist mit 17,4 GB unter <code>TransformedPrimitive</code> ? <br><br>  Wie oben erwähnt, wird <code>TransformedPrimitive</code> sowohl für Transformationen mit zeitlicher Änderung als auch für Instanzen von Objekten verwendet.  In beiden Fällen müssen wir eine zusätzliche Transformation auf das vorhandene <code>Primitive</code> anwenden.  Die <code>TransformedPrimitive</code> Klasse enthält nur zwei Mitglieder: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Primitive&gt; primitive; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedTransform PrimitiveToWorld;</code> </pre> <br>  So weit so gut: ein Zeiger auf ein Primitiv und eine Transformation, die sich im Laufe der Zeit ändert.  Aber was ist eigentlich in <code>AnimatedTransform</code> gespeichert? <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Transform *startTransform, *endTransform; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float startTime, endTime; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> actuallyAnimated; Vector3f T[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Quaternion R[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Matrix4x4 S[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRotation; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DerivativeTerm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... Float kc, kx, ky, kz; }; DerivativeTerm c1[3], c2[3], c3[3], c4[3], c5[3];</span></span></code> </pre> <br>  Neben Zeigern auf zwei Übergangsmatrizen und der damit verbundenen Zeit gibt es auch eine Zerlegung der Matrizen in Transport-, Rotations- und Skalierungskomponenten sowie vorberechnete Werte zur Begrenzung des Volumens, das durch das Verschieben von Begrenzungsrahmen belegt wird (siehe Abschnitt 2.4.9 unseres Buches) <em>Physikalisch basiertes Rendern</em> ).  All dies summiert sich auf 456 Bytes. <br><br>  Aber in dieser Szene <em>bewegt sich nichts</em> .  Unter dem Gesichtspunkt von Transformationen für Instanzen von Objekten benötigen wir einen Zeiger auf die Transformation, und die Werte für Zerlegung und bewegliche Begrenzungsrahmen werden nicht benötigt.  (Das heißt, es werden nur 8 Bytes benötigt).  Wenn Sie eine separate <code>Primitive</code> Implementierung für feste Instanzen von Objekten erstellen, werden insgesamt 17,4 GB auf 900 MB (!) Komprimiert. <br><br>  Was <code>GeometricPrimitive</code> betrifft, ist die Korrektur eine nicht triviale Änderung im Vergleich zu dem, was im Buch beschrieben wird. Daher werden wir es auch auf die nächste Version von pbrt verschieben.  Zumindest verstehen wir jetzt, was mit dem Chaos von 24,7 GB <code>Primitive</code> Speicher passiert. <br><br><h2>  Probleme mit dem Konvertierungscache </h2><br>  Der nächstgrößte Block nicht erfassten Speichers, der vom Massiv definiert wurde, war <code>TransformCache</code> , der ungefähr 16 GB belegte.  (Hier ist ein Link zur <a href="">ursprünglichen Implementierung</a> .) Die Idee ist, dass dieselbe Transformationsmatrix häufig mehrmals in der Szene verwendet wird. Daher ist es am besten, eine einzige Kopie davon im Speicher zu haben, damit alle Elemente, die sie verwenden, einfach einen Zeiger auf dasselbe Objekt speichern Umwandlung. <br><br>  <code>TransformCache</code> verwendete <code>std::map</code> , um den Cache zu speichern, und massif berichtete, dass 6 von 16 GB für schwarz-rote Baumknoten in <code>std::map</code> .  Das ist eine Menge: 60% dieses Volumens werden für die Transformationen selbst verwendet.  Schauen wir uns die Deklaration für diese Distribution an: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Transform, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Transform *, Transform *&gt;&gt; cache;</code> </pre> <br>  Hier ist die Arbeit perfekt erledigt: <code>Transform</code> vollständig als Schlüssel für die Verteilung verwendet.  Noch besser ist, dass pbrt <code>Transform</code> zwei 4x4-Matrizen (die Transformationsmatrix und ihre inverse Matrix) speichert, was dazu führt, dass 128 Bytes in jedem Knoten des Baums gespeichert werden.  All dies ist für den für ihn gespeicherten Wert absolut unnötig. <br><br>  Vielleicht ist eine solche Struktur in einer Welt ganz normal, in der es für uns wichtig ist, dass dieselbe Transformationsmatrix in Hunderten oder Tausenden von Grundelementen verwendet wird, und im Allgemeinen gibt es nicht viele Transformationsmatrizen.  Aber für eine Szene mit einer Reihe von meist einzigartigen Transformationsmatrizen, wie in unserem Fall, ist dies nur ein schrecklicher Ansatz. <br><br>  Abgesehen von der Tatsache, dass der Speicherplatz für Schlüssel verschwendet wird, beinhaltet eine Suche in <code>std::map</code> zum Durchlaufen des rot-schwarzen Baums viele Zeigeroperationen. Daher erscheint es logisch, etwas völlig Neues auszuprobieren.  Glücklicherweise wird in dem Buch wenig über <code>TransformCache</code> geschrieben, sodass es durchaus akzeptabel ist, es vollständig neu zu schreiben. <br><br>  Und bevor wir anfangen: Nachdem wir die Signatur der <code>Lookup()</code> -Methode untersucht haben, wird ein weiteres Problem offensichtlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transform &amp;t, Transform **tCached, Transform **tCachedInverse)</span></span></span></span></code> </pre> <br>  Wenn die aufrufende Funktion <code>Transform</code> bereitstellt, speichert der Cache Konvertierungszeiger, die dem übergebenen entsprechen, und gibt sie zurück, übergibt aber auch die inverse Matrix.  Um dies zu ermöglichen, wird in der ursprünglichen Implementierung beim Hinzufügen einer Transformation zum Cache die inverse Matrix immer berechnet und gespeichert, damit sie zurückgegeben werden kann. <br><br>  Das Dumme dabei ist, dass die meisten Dial Peers, die den Transformationscache verwenden, die inverse Matrix nicht abfragen oder verwenden.  Das heißt, verschiedene Arten von Speicher werden für nicht anwendbare inverse Transformationen verschwendet. <br><br>  In der <a href="">neuen Implementierung</a> werden die folgenden Verbesserungen hinzugefügt: <br><br><ul><li>  Es verwendet eine Hash-Tabelle, um die Suche zu beschleunigen, und erfordert keine Speicherung von etwas anderem als dem <code>Transform *</code> -Array, wodurch der Speicherbedarf im Wesentlichen auf den Wert reduziert wird, der tatsächlich zum Speichern aller <code>Transform</code> . </li><li>  Die Signatur der Suchmethode sieht jetzt wie <code>Transform *Lookup(const Transform <br> &amp;t)</code> <code>Transform *Lookup(const Transform <br> &amp;t)</code>  <code>Transform *Lookup(const Transform <br> &amp;t)</code> ;  An einer Stelle, an der die aufrufende Funktion die inverse Matrix aus dem Cache <code>Lookup()</code> möchte, wird <code>Lookup()</code> zweimal <code>Lookup()</code> . </li></ul><br>  Zum Hashing habe ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Funktion FNV1a verwendet</a> .  Nach seiner Implementierung fand ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aras 'Beitrag zu Hash-Funktionen</a> ;  Vielleicht hätte ich einfach xxHash oder CityHash verwenden sollen, weil ihre Leistung besser ist.  Vielleicht wird meine Schande eines Tages gewinnen und ich werde es reparieren. <br><br>  Dank der neuen <code>TransformCache</code> Implementierung konnte die Systemstartzeit erheblich verkürzt werden - bis zu 21 Minuten und 42 Sekunden.  Das heißt, wir haben weitere 5 Minuten und 7 Sekunden gespart oder 1,27-mal beschleunigt.  Darüber hinaus hat eine effizientere Speichernutzung den von den Transformationsmatrizen belegten Speicherplatz von 16 auf 5,7 GB reduziert, was fast der gespeicherten Datenmenge entspricht.  Dies erlaubte uns, nicht zu versuchen, die Tatsache auszunutzen, dass sie nicht wirklich projektiv sind, und 3x4-Matrizen anstelle von 4x4 zu speichern.  (Im Normalfall wäre ich skeptisch, wie wichtig diese Art der Optimierung ist, aber hier würden wir mehr als ein Gigabyte sparen - viel Speicher! Dies lohnt sich auf jeden Fall im Produktionsrenderer.) <br><br><h2>  Kleine Leistungsoptimierung zu vervollständigen </h2><br>  Eine zu verallgemeinerte <code>TransformedPrimitive</code> Struktur kostet uns sowohl Speicher als auch Zeit: Der Profiler gab an, dass ein erheblicher Teil der Zeit beim Start in der Funktion <code>AnimatedTransform::Decompose()</code> , die die Transformation der Matrix in Quaternionsrotation, -übertragung und -skalierung zerlegt.  Da sich in dieser Szene nichts bewegt, ist diese Arbeit nicht erforderlich, und eine gründliche Überprüfung der Implementierung von <code>AnimatedTransform</code> hat gezeigt, dass auf keinen dieser Werte zugegriffen wird, wenn die beiden Transformationsmatrizen tatsächlich identisch sind. <br><br>  Durch Hinzufügen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Zeilen</a> zum Konstruktor, damit die Zerlegungen der Transformationen nicht ausgeführt werden, wenn sie nicht erforderlich sind, haben wir ab der Startzeit weitere 1 min 31 gespeichert: Als Ergebnis kamen wir zu 20 min 9 s, dh sie beschleunigten im Allgemeinen 1,73-mal. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nächsten Artikel werden</a> wir den Parser ernsthaft aufgreifen und analysieren, was wichtig wurde, als wir die Arbeit anderer Teile beschleunigten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417445/">https://habr.com/ru/post/de417445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417435/index.html">In der Konfiguration von Aliens: Colonial Marines wurde ein Tippfehler gefunden, aufgrund dessen die Spiel-KI vier Jahre lang fehlerhaft war</a></li>
<li><a href="../de417437/index.html">Projektor gegen Flachbildschirm. Wir probieren ein Augenarztgewand an und finden heraus, warum Größe wichtig ist</a></li>
<li><a href="../de417439/index.html">Der Intel Core i7-8086K (Teil 1)</a></li>
<li><a href="../de417441/index.html">Wie wir gewöhnliche Spieler und für DDoS oder unsere Server kaputt gemacht haben: eine praktische Anleitung</a></li>
<li><a href="../de417443/index.html">Organische Stoffe auf dem Mars könnten vor 40 Jahren entdeckt werden, wenn eine andere Analysemethode verwendet würde</a></li>
<li><a href="../de417447/index.html">Expedition zu den mysteriösen Feenkreisen in der Namibwüste</a></li>
<li><a href="../de417449/index.html">Jurassic World: Können wir Dinosaurier wirklich wiederbeleben?</a></li>
<li><a href="../de417451/index.html">Fünf häufige Fehler für Anfänger</a></li>
<li><a href="../de417453/index.html">Organisation von Praktika für Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>