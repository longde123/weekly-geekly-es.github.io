<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåù „ÄΩÔ∏è üë®üèΩ‚Äçüöí Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 2 üë©üèæ‚Äçü§ù‚Äçüë®üèª ü¶ê üë©üèø‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspiriert vom ersten Parsing- Sieg mit einer Beschreibung einer Inselszene aus Disneys Moana- Cartoon, ging ich weiter auf das Studium der Speichernu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417445/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg" alt="Bild"></div><br>  Inspiriert vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Parsing- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sieg</a> mit einer Beschreibung einer Inselszene aus Disneys <em>Moana-</em> Cartoon, ging ich weiter auf das Studium der Speichernutzung ein.  Mit der Vorlaufzeit konnte noch viel getan werden, aber ich entschied, dass es n√ºtzlich w√§re, zuerst die Situation zu untersuchen. <br><br>  Ich habe die Laufzeituntersuchung mit den integrierten pbrt-Statistiken gestartet.  pbrt verf√ºgt √ºber eine manuelle Einstellung f√ºr wichtige Speicherzuweisungen, um die Speichernutzung zu verfolgen. Nach Abschluss des Renderns wird ein Speicherzuweisungsbericht angezeigt.  Der Speicherzuordnungsbericht f√ºr diese Szene lautete urspr√ºnglich wie folgt: <br><br> <code> <br> BVH- 9,01  <br>  1,44  <br> MIP- 2,00  <br>   11,02 </code> <br> <br>  In Bezug auf die Laufzeit stellte sich heraus, dass die integrierten Statistiken kurz waren und nur die Speicherzuordnung f√ºr bekannte Objekte mit einer Gr√∂√üe von 24 GB meldeten.  <code>top</code> sagte, dass tats√§chlich etwa 70 GB Speicher verwendet wurden, dh 45 GB wurden in der Statistik nicht ber√ºcksichtigt.  Kleine Abweichungen sind durchaus verst√§ndlich: Dynamische Speicherzuordnungen ben√∂tigen zus√§tzlichen Speicherplatz zum Registrieren der Ressourcennutzung, einige gehen aufgrund von Fragmentierung verloren und so weiter.  Aber 45 GB?  Hier versteckt sich definitiv etwas Schlimmes. <br><a name="habracut"></a><br>  Um zu verstehen, was uns fehlt (und um sicherzustellen, dass wir richtig verfolgt haben), habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">massif verwendet</a> , um die tats√§chliche Zuordnung des dynamischen Speichers zu verfolgen.  Es ist ziemlich langsam, aber zumindest funktioniert es gut. <br><br><h2>  Primitive </h2><br>  Das erste, was ich beim Verfolgen des Massivs fand, waren zwei Codezeilen, die Instanzen der Basisklasse <code>Primitive</code> , die in der Statistik nicht ber√ºcksichtigt werden, im Speicher zuordneten.  Ein kleines Versehen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ziemlich einfach zu beheben ist</a> .  Danach sehen wir Folgendes: <br><br> <code>Primitives 24,67 </code> <br> <br>  Ups  Was ist also ein Primitiv und warum all diese Erinnerung? <br><br>  pbrt unterscheidet zwischen <code>Shape</code> , bei der es sich um reine Geometrie (Kugel, Dreieck usw.) handelt, und <code>Primitive</code> , bei der es sich um eine Kombination aus Geometrie, Material, manchmal der Funktion der Strahlung und dem Medium handelt, das innerhalb und au√üerhalb der Oberfl√§che der Geometrie beteiligt ist. <br><br>  <a href="">F√ºr die</a> Basisklasse <code>Primitive</code> gibt es <a href="">mehrere Optionen</a> : <code>GeometricPrimitive</code> , ein Standardfall: eine Vanillekombination aus Geometrie, Material usw., sowie <code>TransformedPrimitive</code> , ein Primitiv, auf das Transformationen angewendet werden, entweder als Instanz eines Objekts oder zum Verschieben von Primitiven mit Transformationen, die sich im Laufe der Zeit √§ndern.  Es stellt sich heraus, dass in dieser Szene beide Typen Platzverschwendung sind. <br><br><h3>  GeometricPrimitive: 50% zus√§tzlicher Speicherplatz </h3><br>  <em>Hinweis: Bei dieser Analyse werden einige falsche Annahmen getroffen.</em>  <em>Sie werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierten Beitrag der Serie</a> √ºberarbeitet.</em> <br><br>  4,3 GB f√ºr <code>GeometricPrimitive</code> .  Es ist lustig, in einer Welt zu leben, in der 4,3 GB verwendeter RAM nicht Ihr gr√∂√ütes Problem sind, aber lassen Sie uns trotzdem sehen, woher wir 4,3 GB <code>GeometricPrimitive</code> .  Hier sind die relevanten Teile der Klassendefinition: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeometricPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface; };</code> </pre> <br>  Wir haben einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeiger auf vtable</a> , drei weitere Zeiger und dann ein <code>MediumInterface</code> das zwei weitere Zeiger mit einer Gesamtgr√∂√üe von 48 Bytes enth√§lt.  Es gibt nur wenige lichtemittierende Netze in dieser Szene, daher ist <code>areaLight</code> fast immer ein Nullzeiger, und es gibt keine Umgebung, die die Szene beeinflusst, sodass beide <code>mediumInterface</code> ebenfalls null sind.  Wenn wir also eine spezielle Implementierung der <code>Primitive</code> Klasse h√§tten, die ohne die Strahlungs- und Medienfunktionen verwendet werden k√∂nnte, w√ºrden wir fast die H√§lfte des von <code>GeometricPrimitive</code> belegten Speicherplatzes einsparen - in unserem Fall etwa 2 GB. <br><br>  Ich habe es jedoch nicht behoben und pbrt eine neue <code>Primitive</code> Implementierung hinzugef√ºgt.  Wir bem√ºhen uns aus einem sehr einfachen Grund, die Unterschiede zwischen dem pbrt-v3-Quellcode auf github und dem in meinem Buch beschriebenen System zu minimieren. Wenn Sie sie synchron halten, k√∂nnen Sie das Buch leicht lesen und mit dem Code arbeiten.  In diesem Fall entschied ich, dass die v√∂llig neue Implementierung von <code>Primitive</code> , die im Buch nie erw√§hnt wurde, einen zu gro√üen Unterschied darstellen w√ºrde.  Aber dieses Update wird definitiv in der neuen Version von pbrt erscheinen. <br><br>  Bevor wir fortfahren, machen wir ein Test-Rendering: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg"></div><br>  <i>Strand von der Insel aus dem Film "Moana" von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> mit einer Aufl√∂sung von 2048x858 und 256 Samples pro Pixel.</i>  <i>Die gesamte Renderzeit auf der 12-Core / 24-Thread-Instanz von Google Compute Engine mit einer Frequenz von 2 GHz mit der neuesten Version von pbrt-v3 betrug 2 Stunden 25 Minuten 43 Sekunden.</i> <br><br><h3>  TransformedPrimitives: 95% verschwendeter Speicherplatz </h3><br>  Der unter 4,3 GB <code>GeometricPrimitive</code> zugewiesene Speicher war ein ziemlich schmerzhafter Treffer, aber was ist mit 17,4 GB unter <code>TransformedPrimitive</code> ? <br><br>  Wie oben erw√§hnt, wird <code>TransformedPrimitive</code> sowohl f√ºr Transformationen mit zeitlicher √Ñnderung als auch f√ºr Instanzen von Objekten verwendet.  In beiden F√§llen m√ºssen wir eine zus√§tzliche Transformation auf das vorhandene <code>Primitive</code> anwenden.  Die <code>TransformedPrimitive</code> Klasse enth√§lt nur zwei Mitglieder: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Primitive&gt; primitive; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedTransform PrimitiveToWorld;</code> </pre> <br>  So weit so gut: ein Zeiger auf ein Primitiv und eine Transformation, die sich im Laufe der Zeit √§ndert.  Aber was ist eigentlich in <code>AnimatedTransform</code> gespeichert? <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Transform *startTransform, *endTransform; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float startTime, endTime; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> actuallyAnimated; Vector3f T[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Quaternion R[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Matrix4x4 S[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRotation; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DerivativeTerm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... Float kc, kx, ky, kz; }; DerivativeTerm c1[3], c2[3], c3[3], c4[3], c5[3];</span></span></code> </pre> <br>  Neben Zeigern auf zwei √úbergangsmatrizen und der damit verbundenen Zeit gibt es auch eine Zerlegung der Matrizen in Transport-, Rotations- und Skalierungskomponenten sowie vorberechnete Werte zur Begrenzung des Volumens, das durch das Verschieben von Begrenzungsrahmen belegt wird (siehe Abschnitt 2.4.9 unseres Buches) <em>Physikalisch basiertes Rendern</em> ).  All dies summiert sich auf 456 Bytes. <br><br>  Aber in dieser Szene <em>bewegt sich nichts</em> .  Unter dem Gesichtspunkt von Transformationen f√ºr Instanzen von Objekten ben√∂tigen wir einen Zeiger auf die Transformation, und die Werte f√ºr Zerlegung und bewegliche Begrenzungsrahmen werden nicht ben√∂tigt.  (Das hei√üt, es werden nur 8 Bytes ben√∂tigt).  Wenn Sie eine separate <code>Primitive</code> Implementierung f√ºr feste Instanzen von Objekten erstellen, werden insgesamt 17,4 GB auf 900 MB (!) Komprimiert. <br><br>  Was <code>GeometricPrimitive</code> betrifft, ist die Korrektur eine nicht triviale √Ñnderung im Vergleich zu dem, was im Buch beschrieben wird. Daher werden wir es auch auf die n√§chste Version von pbrt verschieben.  Zumindest verstehen wir jetzt, was mit dem Chaos von 24,7 GB <code>Primitive</code> Speicher passiert. <br><br><h2>  Probleme mit dem Konvertierungscache </h2><br>  Der n√§chstgr√∂√üte Block nicht erfassten Speichers, der vom Massiv definiert wurde, war <code>TransformCache</code> , der ungef√§hr 16 GB belegte.  (Hier ist ein Link zur <a href="">urspr√ºnglichen Implementierung</a> .) Die Idee ist, dass dieselbe Transformationsmatrix h√§ufig mehrmals in der Szene verwendet wird. Daher ist es am besten, eine einzige Kopie davon im Speicher zu haben, damit alle Elemente, die sie verwenden, einfach einen Zeiger auf dasselbe Objekt speichern Umwandlung. <br><br>  <code>TransformCache</code> verwendete <code>std::map</code> , um den Cache zu speichern, und massif berichtete, dass 6 von 16 GB f√ºr schwarz-rote Baumknoten in <code>std::map</code> .  Das ist eine Menge: 60% dieses Volumens werden f√ºr die Transformationen selbst verwendet.  Schauen wir uns die Deklaration f√ºr diese Distribution an: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Transform, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Transform *, Transform *&gt;&gt; cache;</code> </pre> <br>  Hier ist die Arbeit perfekt erledigt: <code>Transform</code> vollst√§ndig als Schl√ºssel f√ºr die Verteilung verwendet.  Noch besser ist, dass pbrt <code>Transform</code> zwei 4x4-Matrizen (die Transformationsmatrix und ihre inverse Matrix) speichert, was dazu f√ºhrt, dass 128 Bytes in jedem Knoten des Baums gespeichert werden.  All dies ist f√ºr den f√ºr ihn gespeicherten Wert absolut unn√∂tig. <br><br>  Vielleicht ist eine solche Struktur in einer Welt ganz normal, in der es f√ºr uns wichtig ist, dass dieselbe Transformationsmatrix in Hunderten oder Tausenden von Grundelementen verwendet wird, und im Allgemeinen gibt es nicht viele Transformationsmatrizen.  Aber f√ºr eine Szene mit einer Reihe von meist einzigartigen Transformationsmatrizen, wie in unserem Fall, ist dies nur ein schrecklicher Ansatz. <br><br>  Abgesehen von der Tatsache, dass der Speicherplatz f√ºr Schl√ºssel verschwendet wird, beinhaltet eine Suche in <code>std::map</code> zum Durchlaufen des rot-schwarzen Baums viele Zeigeroperationen. Daher erscheint es logisch, etwas v√∂llig Neues auszuprobieren.  Gl√ºcklicherweise wird in dem Buch wenig √ºber <code>TransformCache</code> geschrieben, sodass es durchaus akzeptabel ist, es vollst√§ndig neu zu schreiben. <br><br>  Und bevor wir anfangen: Nachdem wir die Signatur der <code>Lookup()</code> -Methode untersucht haben, wird ein weiteres Problem offensichtlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transform &amp;t, Transform **tCached, Transform **tCachedInverse)</span></span></span></span></code> </pre> <br>  Wenn die aufrufende Funktion <code>Transform</code> bereitstellt, speichert der Cache Konvertierungszeiger, die dem √ºbergebenen entsprechen, und gibt sie zur√ºck, √ºbergibt aber auch die inverse Matrix.  Um dies zu erm√∂glichen, wird in der urspr√ºnglichen Implementierung beim Hinzuf√ºgen einer Transformation zum Cache die inverse Matrix immer berechnet und gespeichert, damit sie zur√ºckgegeben werden kann. <br><br>  Das Dumme dabei ist, dass die meisten Dial Peers, die den Transformationscache verwenden, die inverse Matrix nicht abfragen oder verwenden.  Das hei√üt, verschiedene Arten von Speicher werden f√ºr nicht anwendbare inverse Transformationen verschwendet. <br><br>  In der <a href="">neuen Implementierung</a> werden die folgenden Verbesserungen hinzugef√ºgt: <br><br><ul><li>  Es verwendet eine Hash-Tabelle, um die Suche zu beschleunigen, und erfordert keine Speicherung von etwas anderem als dem <code>Transform *</code> -Array, wodurch der Speicherbedarf im Wesentlichen auf den Wert reduziert wird, der tats√§chlich zum Speichern aller <code>Transform</code> . </li><li>  Die Signatur der Suchmethode sieht jetzt wie <code>Transform *Lookup(const Transform <br> &amp;t)</code> <code>Transform *Lookup(const Transform <br> &amp;t)</code>  <code>Transform *Lookup(const Transform <br> &amp;t)</code> ;  An einer Stelle, an der die aufrufende Funktion die inverse Matrix aus dem Cache <code>Lookup()</code> m√∂chte, wird <code>Lookup()</code> zweimal <code>Lookup()</code> . </li></ul><br>  Zum Hashing habe ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Funktion FNV1a verwendet</a> .  Nach seiner Implementierung fand ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aras 'Beitrag zu Hash-Funktionen</a> ;  Vielleicht h√§tte ich einfach xxHash oder CityHash verwenden sollen, weil ihre Leistung besser ist.  Vielleicht wird meine Schande eines Tages gewinnen und ich werde es reparieren. <br><br>  Dank der neuen <code>TransformCache</code> Implementierung konnte die Systemstartzeit erheblich verk√ºrzt werden - bis zu 21 Minuten und 42 Sekunden.  Das hei√üt, wir haben weitere 5 Minuten und 7 Sekunden gespart oder 1,27-mal beschleunigt.  Dar√ºber hinaus hat eine effizientere Speichernutzung den von den Transformationsmatrizen belegten Speicherplatz von 16 auf 5,7 GB reduziert, was fast der gespeicherten Datenmenge entspricht.  Dies erlaubte uns, nicht zu versuchen, die Tatsache auszunutzen, dass sie nicht wirklich projektiv sind, und 3x4-Matrizen anstelle von 4x4 zu speichern.  (Im Normalfall w√§re ich skeptisch, wie wichtig diese Art der Optimierung ist, aber hier w√ºrden wir mehr als ein Gigabyte sparen - viel Speicher! Dies lohnt sich auf jeden Fall im Produktionsrenderer.) <br><br><h2>  Kleine Leistungsoptimierung zu vervollst√§ndigen </h2><br>  Eine zu verallgemeinerte <code>TransformedPrimitive</code> Struktur kostet uns sowohl Speicher als auch Zeit: Der Profiler gab an, dass ein erheblicher Teil der Zeit beim Start in der Funktion <code>AnimatedTransform::Decompose()</code> , die die Transformation der Matrix in Quaternionsrotation, -√ºbertragung und -skalierung zerlegt.  Da sich in dieser Szene nichts bewegt, ist diese Arbeit nicht erforderlich, und eine gr√ºndliche √úberpr√ºfung der Implementierung von <code>AnimatedTransform</code> hat gezeigt, dass auf keinen dieser Werte zugegriffen wird, wenn die beiden Transformationsmatrizen tats√§chlich identisch sind. <br><br>  Durch Hinzuf√ºgen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Zeilen</a> zum Konstruktor, damit die Zerlegungen der Transformationen nicht ausgef√ºhrt werden, wenn sie nicht erforderlich sind, haben wir ab der Startzeit weitere 1 min 31 gespeichert: Als Ergebnis kamen wir zu 20 min 9 s, dh sie beschleunigten im Allgemeinen 1,73-mal. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Artikel werden</a> wir den Parser ernsthaft aufgreifen und analysieren, was wichtig wurde, als wir die Arbeit anderer Teile beschleunigten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417445/">https://habr.com/ru/post/de417445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417435/index.html">In der Konfiguration von Aliens: Colonial Marines wurde ein Tippfehler gefunden, aufgrund dessen die Spiel-KI vier Jahre lang fehlerhaft war</a></li>
<li><a href="../de417437/index.html">Projektor gegen Flachbildschirm. Wir probieren ein Augenarztgewand an und finden heraus, warum Gr√∂√üe wichtig ist</a></li>
<li><a href="../de417439/index.html">Der Intel Core i7-8086K (Teil 1)</a></li>
<li><a href="../de417441/index.html">Wie wir gew√∂hnliche Spieler und f√ºr DDoS oder unsere Server kaputt gemacht haben: eine praktische Anleitung</a></li>
<li><a href="../de417443/index.html">Organische Stoffe auf dem Mars k√∂nnten vor 40 Jahren entdeckt werden, wenn eine andere Analysemethode verwendet w√ºrde</a></li>
<li><a href="../de417447/index.html">Expedition zu den mysteri√∂sen Feenkreisen in der Namibw√ºste</a></li>
<li><a href="../de417449/index.html">Jurassic World: K√∂nnen wir Dinosaurier wirklich wiederbeleben?</a></li>
<li><a href="../de417451/index.html">F√ºnf h√§ufige Fehler f√ºr Anf√§nger</a></li>
<li><a href="../de417453/index.html">Organisation von Praktika f√ºr Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>