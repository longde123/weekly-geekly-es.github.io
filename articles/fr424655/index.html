<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤮 🧘 ♨️ Personnaliser Jira selon vos besoins. Flux parfait et ticket parfait 👩🏼‍🎨 🙌🏻 🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous travaillez dans une entreprise informatique, vos processus sont très probablement basés sur le produit Atlassian bien connu - Jira. Il existe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Personnaliser Jira selon vos besoins. Flux parfait et ticket parfait</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/424655/"><img src="https://habrastorage.org/webt/wm/nq/on/wmnqonj46aq2yavvhzsepa06qjo.jpeg"><br><br>  Si vous travaillez dans une entreprise informatique, vos processus sont très probablement basés sur le produit Atlassian bien connu - Jira.  Il existe de nombreux trackers de tâches sur le marché pour résoudre les mêmes problèmes, y compris des solutions open source (Trac, Redmine, Bugzilla), mais Jira est peut-être le plus utilisé aujourd'hui. <br><br>  Je m'appelle Dmitry Semenikhin, je suis chef d'équipe chez Badoo.  Dans une courte série d'articles, je vais vous dire exactement comment nous utilisons Jira, comment nous l'avons personnalisé pour nos processus, quelles bonnes choses ont été «vissées» au-dessus et comment nous avons transformé le traqueur de problèmes en un centre de communication unique pour la tâche et simplifié notre vie.  Dans cet article, vous verrez notre flux à l'intérieur, apprenez comment vous pouvez «tordre» votre Jira et découvrez des fonctionnalités supplémentaires de l'outil que vous ne connaissez peut-être pas. <br><br>  L'article est principalement destiné à ceux qui utilisent déjà Jira, mais peut avoir des difficultés à intégrer ses fonctionnalités standard dans les processus existants de l'entreprise.  En outre, l'article peut être utile aux entreprises qui utilisent d'autres suiveurs de tâches, mais ont rencontré certaines restrictions et envisagent un changement de décision.  L'article n'est pas construit sur le principe de «problème - solution», dans lequel je décris les outils et fonctionnalités existants que nous avons construits autour de Jira, ainsi que les technologies que nous avons utilisées pour les implémenter. <br><a name="habracut"></a><br><h1>  Fonctionnalités supplémentaires de Jira </h1><br>  Pour rendre le texte suivant plus compréhensible, voyons quels outils Jira nous fournit pour la mise en œuvre de liste de souhaits non standard - ceux qui vont au-delà de la fonctionnalité Jira standard. <br><br><h3>  API REST </h3><br>  En général, un appel de commande API est une demande HTTP vers une URL API indiquant la méthode (GET, PUT, POST et DELETE), la commande et le corps de la demande.  Le corps de la demande, ainsi que la réponse de l'API, sont au format JSON.  Un exemple de demande qui renvoie une représentation JSON d'un ticket: <br><br><pre><code class="json hljs">GET /rest/api/latest/issue/{ticket_number}</code> </pre> <br>  En utilisant l'API, vous pouvez, en utilisant des scripts dans n'importe quel langage de programmation: <br><br><ul><li>  créer des billets; <br></li><li>  modifier toutes les propriétés des tickets (intégrées et personnalisées); <br></li><li>  rédiger des commentaires; <br></li><li>  utiliser JQL (langage de requête intégré) pour recevoir les listes de tickets; <br></li><li>  et bien plus. <br></li></ul><br>  La documentation détaillée de l'API est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Nous avons écrit notre propre client API Jira de haut niveau en PHP, qui implémente toutes les commandes dont nous avons besoin.  Voici un exemple de commandes pour travailler avec des commentaires: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_post(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment"</span></span>, [<span class="hljs-string"><span class="hljs-string">'body'</span></span> =&gt; $comment]); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment_id, $new_text)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_put(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment/{$comment_id}"</span></span>, [<span class="hljs-string"><span class="hljs-string">'body'</span></span> =&gt; $new_text]); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment_id)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_delete(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment/{$comment_id}"</span></span>); }</code> </pre><br><h3>  Webhooks </h3><br>  À l'aide de webhook, vous pouvez configurer l'appel d'une fonction de rappel externe sur votre hôte à divers événements dans Jira.  En même temps, vous pouvez configurer autant de règles que vous le souhaitez afin que différentes URL se «tordent» pour différents événements et pour les tickets qui correspondent au filtre spécifié dans le webhook.  L'interface de configuration des webhooks est disponible pour l'administrateur Jira. <br><br>  Par conséquent, vous pouvez créer des règles comme celle-ci: <br><br>  <b>Nom</b> : «SRV - Nouvelle fonctionnalité créée / mise à jour» <br>  <b>URL</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.myremoteapp.com/webhookreceiver</a> <br>  <b>Portée</b> : Project = SRV AND type in ('New Feature') <br>  <b>Événements</b> : problème mis à jour, problème créé <br><br>  Dans cet exemple, l'URL spécifiée sera appelée pour la création de tickets et les événements de modification correspondant au filtre d' <i>étendue</i> .  Dans le même temps, le corps de la demande contiendra toutes les informations nécessaires sur ce qui a exactement changé et quel événement s'est produit. <br><br>  Il est important de comprendre que Jira ne garantit pas que votre événement sera livré.  Si l'URL externe n'a pas répondu ou a répondu avec une erreur, cela ne sera visible nulle part (sauf pour les journaux, peut-être).  Par conséquent, le gestionnaire d'événements Webhook doit être aussi fiable que possible.  Par exemple, vous pouvez mettre les événements en file d'attente et essayer de les traiter jusqu'à ce qu'il réussisse.  Cela aidera à résoudre les problèmes liés aux services temporairement indisponibles, par exemple, toute base de données externe nécessaire au traitement correct de l'événement. <br><br>  Une documentation détaillée sur les webhooks est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Scriptrunner </h3><br>  Il s'agit d'un plugin pour Jira, un outil très puissant qui vous permet de personnaliser beaucoup de Jira (y compris la possibilité de remplacer les webhooks).  L'utilisation de ce plugin nécessite une connaissance de Groovy.  Le principal avantage de l'outil pour nous est que vous pouvez intégrer une logique personnalisée dans le flux en ligne.  Votre code de script sera exécuté immédiatement dans l'environnement Jira en réponse à une action spécifique.  Par exemple, vous pouvez créer votre propre bouton dans l'interface de ticket, en cliquant dessus, vous créerez des tickets associés à la tâche en cours ou exécuterez des tests unitaires pour cette tâche.  Et si soudainement quelque chose se passe mal, vous en tant qu'utilisateur le saurez immédiatement. <br><br>  Les personnes intéressées peuvent lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br><br><h1>  Flow: ce qui est caché sous le capot </h1><br>  Et maintenant sur la façon dont nous appliquons des fonctionnalités supplémentaires de Jira dans nos projets.  Considérez cela dans le contexte du passage de notre ticket de flux typique de la création à la fermeture.  En même temps, je vais vous parler du flux lui-même. <br><br><h3>  Ouvert / backlog </h3><br>  Ainsi, tout d'abord, le ticket entre dans l'arriéré de nouveaux tickets avec le statut <b>Ouvert</b> .  De plus, le chef de composant, après avoir vu un nouveau ticket sur son tableau de bord, prend une décision: attribuer un ticket dès maintenant au développeur ou l'envoyer au backlog des tickets connus (statut <b>Backlog</b> ) afin que vous puissiez l'attribuer plus tard lorsqu'un développeur gratuit apparaît et que les tickets de priorité supérieure seront fermés.  Cela peut sembler étrange, car il semble logique de faire le contraire: créer des tickets avec le statut <i>Backlog</i> , puis les traduire en statut Open.  Mais nous avons précisément pris racine dans ce schéma.  Il vous permet de configurer facilement des filtres pour réduire le temps de décision pour les nouveaux tickets.  Un exemple de filtre JQL qui affiche de nouvelles tâches pour une piste: <br><br> <code>Project = SRV AND assignee is EMPTY AND status in (Open)</code> <br> <br><h3>  En cours </h3><br><div class="spoiler">  <b class="spoiler_title">Nuances techniques du travail avec Git</b> <div class="spoiler_text">  Il convient de noter que nous travaillons sur chaque tâche dans une branche Git distincte.  Quant à cela, nous avons convenu que le nom de la succursale au début devrait contenir le numéro de ticket.  Par exemple, <i>SRV-123_new_super_feature</i> .  De plus, les commentaires pour chaque commit dans la branche doivent contenir le numéro de ticket au format [SRV-123]: {comment}.  Nous avons besoin d'un tel format, par exemple, pour la suppression correcte d'une «mauvaise» tâche d'une build.  La procédure à suivre est décrite en détail dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> . <br><br>  Ces exigences sont contrôlées par des crochets Git.  Par exemple, voici le contenu de prepare-commit-msg, qui prépare un commentaire pour la validation, obtenant le numéro de ticket à partir du nom de la branche actuelle: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash b=`git symbolic-ref HEAD| sed -e 's|^refs/heads/||' | sed -e 's|_.*||'` c=`cat $1` if [ -n "$b" ] &amp;&amp; [[ "$c" != "[$b]:"* ]] then echo "[$b]: $c" &gt; $1 fi</span></span></code> </pre><br>  Si vous essayez de pousser un commit avec un commentaire «incorrect», un tel push sera rejeté.  Une tentative de création d'une agence sans numéro de ticket au début sera également rejetée. <br></div></div><br>  Lorsqu'un ticket frappe le développeur, la première chose qu'il décompose.  Le résultat de la décomposition est l’idée du développeur de savoir comment résoudre le problème et combien de temps la solution prendra.  Une fois que tous les détails principaux ont été clarifiés, le ticket est transféré au statut <b>En cours</b> et le développeur commence à écrire du code. <br><br>  Il est habituel pour nous de définir la date d'échéance de la tâche au moment où elle est transférée au statut En cours.  Si le développeur ne l'a pas fait, il recevra un rappel dans le messager d'entreprise HipChat.  Un script spécial toutes les deux heures: <br><br><ul><li>  l'utilisation de l'API Jira REST sélectionne les tickets en état de progression avec un champ de date d'échéance vide ( <i>projet = SRV AND status = 'In Progress' AND duedate is EMPTY</i> ); <br></li><li>  sélectionne les tickets incomplets dont la date d'échéance est antérieure à la date actuelle ( <i>projet = SRV AND status = 'In Progress'</i> <i>AND duedate is not EMPTY AND duedate &lt;now ()</i> ); <br></li><li>  reconnaît le développeur pour chaque ticket en lisant le champ correspondant dans le ticket, ainsi que le lead du développeur; <br></li><li>  regroupe les tickets des développeurs et des prospects et envoie des rappels à HipChat à l'aide de son API. <br></li></ul><br>  Après avoir fait tous les commits nécessaires, le développeur pousse la branche dans un navet commun.  Dans ce cas, le crochet Git post-réception se déclenche, ce qui fait beaucoup de choses intéressantes: <br><br><ul><li>  Le nom de la branche Git, ainsi que les commentaires sur les commits, sont vérifiés pour la conformité à nos règles; <br></li><li>  il est vérifié que le ticket auquel la branche est associée n'est pas fermé (vous ne pouvez pas insérer de nouveau code dans des tickets fermés); <br></li><li>  La syntaxe des fichiers PHP modifiés est vérifiée (PHP -l <i>nom_fichier.php</i> ); <br></li><li>  le formatage est vérifié; <br></li><li>  si le ticket dans lequel la branche est poussée est dans l'état <i>Ouvert</i> , il sera automatiquement transféré dans l'état <i>En cours</i> ; <br></li><li>  le ticket est attaché à la succursale, l'entrée correspondante est effectuée dans le champ personnalisé du ticket <i>Commits</i> à l'aide de l'API Jira.  Cela ressemble à ceci: <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/yt/-u/snyt-ud30nzzbgr4seaehcccnme.png"></div><br>  ( <i>branchdiff</i> est un lien vers le diff de la branche dont la tête est à l'origine de la branche actuelle dans notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outil de</a> révision de code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codeisok</a> ); <br><br><ul><li>  un commentaire est créé dans le ticket avec tous les commits de cette push. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/np/28/5pnp284b9eobeeyafn3hfjgcimu.png"></div><br>  <i>(Aida est le nom conditionnel de notre complexe d'automatisation pour travailler avec Jira, Git et pas seulement. C'est à partir de ce nom que les commentaires automatiques apparaissent dans le ticket. Nous en avons écrit plus sur Aida dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> ).</i> <br>  Un clic sur le hachage du commit ouvre le diff avec la révision précédente de la branche (je vais le montrer ci-dessous); <br></li><li>  il vérifie s'il existe des fichiers dans la branche qui peuvent nécessiter une traduction dans les langues prises en charge (par exemple, les modèles de page Web), et s'il y en a, la nouvelle valeur \ Changed est définie dans le champ personnalisé du ticket Lexems.  Cela garantit que le ticket ne sera pas mis en production sans une traduction complète; <br></li><li>  le nom de l'employé qui pousse la branche est ajouté à la liste des développeurs (un champ personnalisé du ticket <i>Développeurs</i> ) <br></li></ul><br><h3>  En révision </h3><br>  Après avoir écrit le code et vérifié que toutes les conditions requises pour la tâche sont remplies et que les tests ne sont pas rompus, le développeur attribue un ticket au réviseur (statut <b>En révision</b> ).  En règle générale, le développeur décide qui examinera son ticket.  Ce sera probablement un autre développeur qui connaît bien la bonne partie du code.  La révision s'effectue à l'aide de l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codeisok</a> , qui s'ouvre immédiatement avec le diff souhaité en cliquant sur le lien <i>branchdiff</i> dans le <i>champ</i> Ticket de validation ou dans le commentaire en tant que hachage de validation dans les commentaires. <br><br>  L'évaluateur voit quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/eg/ti/tyegti15pqhzbdgiebcw1evm8pi.png"></div><br>  Une fois la révision terminée, le réviseur appuie sur le bouton <i>Terminer</i> et, entre autres, à ce moment, les événements suivants se produisent: <br><br><ul><li>  à l'aide de l'API JIra, un commentaire est créé dans le ticket avec les commentaires du réviseur dans le contexte du code.  Cela ressemble à ceci: <br></li></ul><br><img src="https://habrastorage.org/webt/0k/n6/ka/0kn6kaydki4umhdxzmjebixy6eu.png"><br><ul><li>  s'il y avait des commentaires sur le code et que le réviseur a décidé de rouvrir le ticket, le développeur recevra une notification à ce sujet dans HipChat (cela se fait en utilisant la règle du webhook, qui fonctionne à la réouverture); <br></li><li>  Le champ de ticket <i>Reviewers</i> est rempli. <br></li></ul><br><h3>  Résolu </h3><br>  En outre, si l'examen a réussi, le ticket est envoyé à l'arriéré des ingénieurs QA dans le statut <b>Résolu</b> .  Mais en même temps, en utilisant webhook pour l'événement résolu, des tests automatiques sur le code de branche sont lancés en arrière-plan.  Après quelques minutes, un nouveau commentaire apparaîtra dans le ticket, qui vous informera des résultats du test. <br><br><img src="https://habrastorage.org/webt/um/ff/cc/umffccnuyujwg3ypdz3scdcrrou.png"><br><br>  De plus, à tout moment, vous pouvez lancer manuellement un cycle de test répété en cliquant sur le bouton spécial Exécuter les tests unitaires dans le menu du ticket.  Après une exécution réussie, un nouveau commentaire apparaîtra dans le ticket, similaire au précédent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/sk/65/ttsk65fr3egs9fbjpa7v6pbdzta.png"></div><br>  En fait, ce bouton est l'un des états de tâche supplémentaires dans le flux de travail Jira, une traduction dans laquelle déclenche un script Groovy pour le plugin ScriptRunner.  Le script appelle une URL externe, qui lance l'exécution du test, et si l'URL a répondu avec succès, le ticket revient à son état précédent (dans notre cas, <i>Résolu</i> ). <br><br><h3>  In Shot / In Shot - OK </h3><br>  La tâche est d'abord testée dans un environnement de développement.  Si tout va bien, un plan est créé (par exemple, en cliquant sur le lien <i>Créer un plan</i> dans le champ <i>Valeurs</i> ) - le répertoire sur le serveur dédié vers lequel les modifications du ticket sont copiées qui sont adjacentes au maître actuel.  Le serveur fonctionne avec les données de production: les bases de données et les services sont les mêmes qui servent les vrais utilisateurs.  Ainsi, le testeur peut ouvrir un site Web ou se connecter à la prise de vue à l'aide d'un client mobile et "isoler" la fonctionnalité dans l'environnement de production.  "Isolé" signifie qu'aucun autre code / fonctionnalité, à l'exception du nouveau de la branche et du maître actuel, n'est exécuté.  Par conséquent, cette étape de test est peut-être la principale, car elle permet à l'ingénieur QA de trouver le problème de la manière la plus fiable directement dans le problème de test. <br><br>  Les ressources de prise de vue sont accessibles à l'aide d'URL spéciales générées dans le script de création de prise de vue et placées dans l'en-tête du ticket à l'aide de l'API Jira.  En conséquence, nous voyons des liens vers le site, le panneau d'administration, les journaux et d'autres outils qui sont exécutés dans un environnement de prise de vue: <br><br><img src="https://habrastorage.org/webt/kf/yk/e_/kfyke_qa3yjtezpyqx0-edwghfw.png"><br><br>  De plus, au moment de la génération de plans, un script est lancé qui analyse le contenu des fichiers modifiés et crée des demandes de traduction des nouveaux jetons trouvés.  Une fois la traduction terminée, la valeur du champ <i>Lexems est</i> remplacée par Terminé et le ticket peut être ajouté à la génération. <br><br>  Si le test en plan a réussi, le ticket est transféré au statut <b>En plan - OK.</b> <br><br><h3>  En construction / En construction - OK </h3><br>  Nous téléchargeons le code deux fois par jour - le matin et le soir.  Pour ce faire, une branche de construction spéciale est créée, qui sera finalement fusionnée avec le maître et disposée «au combat». <br><br>  Au moment de la création de la branche de génération, un script spécial utilisant une requête JQL reçoit une liste de tickets dans l'état <i>In Shot - OK</i> et essaie de les figer dans la branche de construction lorsque toutes les conditions suivantes sont remplies: <br><br><ul><li>  la traduction du ticket est terminée ou rien n'a besoin d'être traduit ( <i>Lexems dans ('Non', 'Terminé')</i> ); <br></li><li>  le développeur est présent sur le lieu de travail (le système de fusion automatique vérifie sur la base interne si le développeur est en vacances ou en congé de maladie, et si c'est le cas, le ticket ne peut être gelé que manuellement par les ingénieurs de publication ou un autre développeur responsable, ce qui est indiqué dans le champ spécial <i>Vice Developer</i> ; le chef du développeur absent dans ce cas reçoit une notification indiquant que le ticket ne peut pas être automatiquement ajouté à la version); <br></li><li>  le ticket n'a pas le drapeau <i>Up in Build</i> défini <i>par le développeur</i> (il s'agit d'un champ personnalisé spécial du ticket qui permet au développeur de déterminer quand le ticket ira à la build); <br></li><li>  la branche de ticket ne dépend pas d'une autre branche qui n'a pas encore atteint le maître ou la build actuelle.  Nous faisons de notre mieux pour éviter une telle situation, mais cela se produit parfois lorsque le développeur crée sa propre branche non pas à partir du maître, mais à partir d'une branche d'un autre ticket, ou lorsqu'il se fige une autre branche pour lui-même.  Cela peut également être fait par hasard, nous avons donc décidé qu'une protection supplémentaire ne nuirait pas. <br></li></ul><br>  Il convient de noter que la fusion automatique peut ne pas se produire en raison d'un conflit de fusion.  Dans ce cas, le ticket est automatiquement transféré au statut de <b>réouverture</b> et attribué au développeur, à propos duquel il reçoit immédiatement une notification dans HipChat, et un message correspondant est ajouté au commentaire du ticket.  Après avoir résolu le conflit, le ticket revient à la génération. <br><br>  Si tout va bien et que la branche de ticket est figée dans la build, le ticket est automatiquement transféré vers le statut <b>In Build</b> et le nom de la build est écrit dans le champ personnalisé du ticket <i>Build_Name</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/bl/cq/teblcqsgvc0tgn82svazpssgmii.png"></div><br>  De plus, en utilisant cette valeur, il est facile d'obtenir une liste des tickets qui ont été publiés avec chaque build.  Par exemple, pour rechercher quelqu'un à blâmer en cas de problème. <br><br>  À l'étape suivante, les ingénieurs QA vérifient en outre si le code de tâche fonctionne correctement en conjonction avec d'autres tâches de la build.  Si tout va bien, le ticket est défini manuellement sur <b>In Build - OK.</b> <br><br><h3>  En production / En production - OK / Fermé </h3><br>  De plus, lors de la construction, l'ensemble de nos tests est exécuté (Unit, intégration, Selenium-, etc.).  Si tout va bien, la construction est figée dans master et le code est mis en production.  Le ticket est transféré au statut <b>En production.</b> <br><br>  De plus, le développeur (ou le client) s'assure que la fonctionnalité fonctionne correctement en production et définit le statut du ticket <b>En production - OK.</b> <br><br>  Après deux semaines, les tickets en statut <i>En production - OK</i> sont automatiquement transférés en statut <b>Fermé</b> , si quelqu'un ne l'a pas fait manuellement auparavant. <br><br>  Il convient également de mentionner des statuts supplémentaires dans lesquels le ticket peut être situé: <br><br><ul><li>  <b>Exigences</b> - lorsqu'il n'est pas possible d'obtenir rapidement du client les clarifications nécessaires sur la tâche, et sans eux, un travail supplémentaire sur le ticket est impossible, le ticket est transféré à ce statut et attribué à celui qui a besoin de donner des explications; <br></li><li>  <b>Suspendu</b> - si le travail de ticket est suspendu, par exemple, si le développeur est bloqué par les tâches d'une équipe adjacente ou a été contraint de passer à une tâche plus urgente; <br></li><li>  <b>Rouvert</b> - une tâche peut être redécouverte au développeur après un examen, après des tests, après une tentative infructueuse de fusionner une branche avec le maître. <br></li></ul><br>  En conséquence, un diagramme simplifié de notre flux de travail ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-m/cd/ue/-mcduen0-daw39ykqjhvp4rvdka.png"></div><br><h1>  Ticket - centre de communication pour la tâche </h1><br>  À la suite du passage du ticket dans le flux, son en-tête acquiert approximativement la forme suivante: <br><br><img src="https://habrastorage.org/webt/c7/4t/qp/c74tqp2l7smg9unpuxpgzw3fhxo.png"><br><br>  Quoi d'autre est intéressant ici que nous avons personnalisé pour nous et que je n'ai pas encore mentionné? <br><br><ul><li>  <i>Composant</i> - utilisé pour regrouper un ticket dans un grand département.  Différents sous-groupes sont responsables de différents composants et, par conséquent, sur leurs tableaux de bord, ils ne voient que les tâches de leurs composants.  Par exemple, je peux lister tous les bogues ouverts pour les composants de mon équipe avec cette requête: <br><br><pre> <code class="php hljs">Project = SRV <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> type = Bug <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> status = Open <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> component in componentsLeadByUser(d.semenihin)</code> </pre> <br></li><li>  <i>Révision</i> - si une révision du code est nécessaire.  La valeur par défaut est nécessaire.  Si la valeur du champ est définie sur <i>Non, le</i> ticket obtiendra immédiatement le statut <i>Résolu.</i> <i><br></i> <br>  QA - Le testeur doit-il être vérifié?  La valeur par défaut est nécessaire.  Si la valeur du champ est définie sur <i>Non, le</i> ticket passe immédiatement à l'état <i>In Shot - OK.</i> <i><br></i> <br>  Sprint - dans notre cas, il n'est pertinent que pour les tâches avec le type Nouvelle fonctionnalité, un plan pour lequel nous établissons à l'avance pour une semaine. <br></li><li>  <i>Date d'échéance</i> - le développeur détermine la date à laquelle le ticket sera en production.  Exposé avant de commencer le travail sur la tâche. <br></li><li>  <i>Situation</i> - en fait, un court journal avec une brève description de l'état actuel de la tâche.  Par exemple, <i>«20/08 j'attends des traductions»</i> , <i>«21/08 Une clarification est demandée au client sur le problème X»</i> .  Cela permet de voir un bref résumé de la tâche dans la liste des autres tâches. <br></li><li>  <i>Msg4QA</i> - informations pour les ingénieurs QA, que le développeur partage pour simplifier le processus de test <br></li></ul><br>  Nous essayons de mener une discussion sur les questions controversées avec le directeur de tâche dans les commentaires du ticket, et non de «salir» les clarifications importantes par courrier et messagerie instantanée.  Si la discussion a néanmoins eu lieu «en marge», il est hautement souhaitable de copier ce que vous avez convenu dans le ticket. <br><br>  En plus des textes «humains», comme je l'ai mentionné plus haut, beaucoup de choses sont écrites automatiquement dans un commentaire à l'aide de l'API: <br><br><ul><li>  commet <br></li><li>  examiner les résultats; <br></li><li>  résultats des tests. <br></li></ul><br>  Parfois, les commentaires automatiques peuvent interférer, par exemple, avec les chefs de produit.  Par conséquent, nous avons créé un script JS simple qui ajoute un bouton à l'interface Jira et vous permet de minimiser tous les commentaires automatiques, en ne laissant que des commentaires humains.  Par conséquent, les commentaires automatiques minimisés semblent compacts. <br><br><img src="https://habrastorage.org/webt/nx/_-/jh/nx_-jh1r3hxzby1j1ue7itohe0e.png"><br><br><div class="spoiler">  <b class="spoiler_title">Code JS du script que nous avons intégré dans le modèle de ticket</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $ = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.jQuery;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> botsAttrMatch = [       <span class="hljs-string"><span class="hljs-string">'aida'</span></span>,       <span class="hljs-string"><span class="hljs-string">'itops.api'</span></span>   ].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bot</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`[rel="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${bot}</span></span></span><span class="hljs-string">"]`</span></span>).join(<span class="hljs-string"><span class="hljs-string">','</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AIDA_COLLAPSE_KEY = <span class="hljs-string"><span class="hljs-string">'aida-collapsed'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> COMMENT_SELECTOR = <span class="hljs-string"><span class="hljs-string">'.issue-data-block.activity-comment.twixi-block'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JiraImprovements = {       init() {           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addButtons();           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleAidaCollapsing();           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleCommentExpansion();           <span class="hljs-comment"><span class="hljs-comment">// Handle toggle button and aida collapsing and put it on a loop           // to handle unexpected JIRA behaviour           const self = this;           setInterval(function () {               self.addButtons();               self.handleAidaCollapsing();           }, 2000);           addCss(`               #badoo-toggle-bots {                   background: #fff2c9;                   color: #594300;                   border-radius: 0 3px 0 0;                   margin-top: 3px;                   display: inline-block;               }           `);       },       addButtons() {           // Do we already have the button?           if ($('#badoo-toggle-bots').length &gt; 0) {               return;           }           // const headerOps = $('ul#opsbar-opsbar-operations');           const jiraHeader = $('#issue-tabs');           // Only add it in ticket state           if (jiraHeader.length &gt; 0) {               const li = $('&lt;a id="badoo-toggle-bots" class="aui-button aui-button-primary aui-style" href="/"&gt;Collapse Bots&lt;/a&gt;');               li.on('click', this.toggleAidaCollapsing.bind(this));               jiraHeader.append(li);           }       },       toggleAidaCollapsing(e) {           e.preventDefault();           const isCollapsed = localStorage.getItem(AIDA_COLLAPSE_KEY) === 'true';           localStorage.setItem(AIDA_COLLAPSE_KEY, !isCollapsed);           this.handleAidaCollapsing();       },       handleAidaCollapsing() {           const isCollapsed = localStorage.getItem(AIDA_COLLAPSE_KEY) === 'true';           const aidaComments = $(COMMENT_SELECTOR).has(botsAttrMatch).not('.manual-toggle');           if (isCollapsed) {               aidaComments.removeClass('expanded').addClass('collapsed');               $('#badoo-toggle-bots').text('Show Bots');           }           else {               aidaComments.removeClass('collapsed').addClass('expanded');               $('#badoo-toggle-bots').text('Collapse Bots');           }       },       handleCommentExpansion() {           $(document.body).delegate('a.collapsed-comments', 'click', function () {               const self = this; // eslint-disable-line no-invalid-this               let triesLeft = 100;               const interval = setInterval(() =&gt; {                   if (--triesLeft &lt; 0 || self.offsetHeight === 0) {                       clearInterval(interval);                   }                   // Element has been removed from DOM. ie new jira comments have been added                   if (self.offsetHeight === 0) {                       JiraImprovements.handleAidaCollapsing();                   }               }, 100);           });           $(document.body).delegate(COMMENT_SELECTOR, 'click', function () {               $(this).addClass('manual-toggle');// eslint-disable-line no-invalid-this           });       }   };   JiraImprovements.init();   function addCss(cssText) {       const style = document.createElement('style');       style.type = 'text/css';       if (style.styleSheet) {           style.styleSheet.cssText = cssText;       }       else {           style.appendChild(document.createTextNode(cssText));       }       document.head.appendChild(style);   } });</span></span></code> </pre><br></div></div><br><h1>  Quoi d'autre? </h1><br>    API  webhooks Jira    : <br><br><ul><li>    HipChat,      -   (    ); <br></li><li>    HipChat            (    ,    ); <br></li><li>              (  )    (          ;        ); <br></li><li>       ;        ,       ; <br></li><li>         In progress  ; <br></li><li>   ,   «»    (, On Review),      ; <br></li><li>                 ,      Jira     (, «d.semenihin (Day off)»).   . <br></li></ul><br><h1>  Résumé </h1><br> Jira —  ,        ,     . ,  ,      .    Jira         ,          . <br><br>            —   .       Jira     ,          Jira. , -      . <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424655/">https://habr.com/ru/post/fr424655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424641/index.html">Rebranding: la vie hack comment ne pas devenir un sujet de ridicule</a></li>
<li><a href="../fr424645/index.html">Comme nous l'avons fait l'enquête interne la plus massive à la banque</a></li>
<li><a href="../fr424649/index.html">Java vs GO. Test par un grand nombre d'utilisateurs</a></li>
<li><a href="../fr424651/index.html">Qu'est-ce que ZFS? Et pourquoi les gens sont-ils fous d'elle?</a></li>
<li><a href="../fr424653/index.html">Bienvenue au Meetup Voronezh Game Dev</a></li>
<li><a href="../fr424657/index.html">[Français] Corriger ou tuer le JavaScript installé automatiquement?</a></li>
<li><a href="../fr424659/index.html">Avantage du bureau à domicile - lumière du jour</a></li>
<li><a href="../fr424661/index.html">Les petits satellites terrestres contiennent un potentiel pour des opportunités scientifiques et commerciales incroyables</a></li>
<li><a href="../fr424663/index.html">De quelles compétences les développeurs auront-ils besoin à l'avenir?</a></li>
<li><a href="../fr424669/index.html">Profils d'utilisateurs fantômes: les annonceurs Facebook vous trouveront même en utilisant un numéro de téléphone non public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>