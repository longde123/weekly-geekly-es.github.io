<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∞ üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üë©üèª‚Äçüè≠ Nous √©crivons notre langage de programmation, partie 1: nous √©crivons un langage VM üë©üèº‚Äçüé® üíü üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Bonne journ√©e √† tous les habrachitateli! 

 Donc, il vaut peut-√™tre la peine de dire que le but de mon travail, sur la base duquel un c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons notre langage de programmation, partie 1: nous √©crivons un langage VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  Pr√©sentation </h3><br>  Bonne journ√©e √† tous les habrachitateli! <br><br>  Donc, il vaut peut-√™tre la peine de dire que le but de mon travail, sur la base duquel un certain nombre de statues seront √©crites, √©tait de cr√©er moi-m√™me un PJ pleinement fonctionnel √† partir de 0, puis de partager mes connaissances, mes meilleures pratiques et mon exp√©rience avec ceux qui sont int√©ress√©s. <br><br>  Je d√©crirai la cr√©ation du langage que j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crit plus haut ici</a> . <br><br>  Il a int√©ress√© de nombreuses personnes et provoqu√© une discussion anim√©e dans les commentaires.  Par cons√©quent - le sujet est int√©ressant pour beaucoup. <br><br>  Je pense que cela vaut la peine de publier imm√©diatement des informations sur le projet: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Site</a> (sera rempli de documentation un peu plus tard). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©p√¥t</a> <br><br>  Pour toucher le projet vous-m√™me et voir tout en action, il est pr√©f√©rable de t√©l√©charger le r√©f√©rentiel et d'ex√©cuter tout depuis le dossier bin.  Dans la version, je ne suis pas press√© de t√©l√©charger les derni√®res versions de la langue et du runtime, car  parfois c'est trop paresseux pour moi de le faire. <br><br>  Je peux coder en C / C ++ et Object Pascal.  J'ai √©crit le projet sur FPC depuis  √† mon avis, cette langue est beaucoup plus simple et mieux adapt√©e pour √©crire comme √ßa.  Le deuxi√®me facteur d√©terminant √©tait que FPC prend en charge un grand nombre de plateformes cibles et qu'il est possible de reconstruire un projet pour la plateforme souhait√©e avec un minimum de modifications.  Si pour une raison quelconque je n'aime pas Object Pascal, alors ne vous pr√©cipitez pas pour fermer le message et courez pour jeter des pierres au commentaire.  Ce langage est tr√®s beau et intuitif, mais je ne fournirai pas autant de code.  Exactement ce dont vous avez besoin. <br><br>  Alors, je vais peut-√™tre commencer mon histoire. <br><a name="habracut"></a><br><h3>  Nous nous fixons des objectifs </h3><br>  Tout d'abord, tout projet a besoin de ses objectifs et de ses savoirs traditionnels, qui devront √™tre mis en ≈ìuvre √† l'avenir.  Il est n√©cessaire de d√©cider √† l'avance quel type de langage sera cr√©√© afin d'√©crire la VM principale pour celui-ci. <br><br>  Les points cl√©s qui ont d√©termin√© le d√©veloppement futur de ma machine virtuelle sont les suivants: <br><br><ul><li>  Saisie et transtypage dynamiques.  J'ai d√©cid√© d'organiser son accompagnement au stade de d√©veloppement de la VM. </li><li>  Prise en charge du multithreading.  J'ai inclus cet √©l√©ment dans cette liste √† l'avance afin de bien concevoir l'architecture de la machine virtuelle et d'organiser la prise en charge du multithreading au niveau principal de la machine virtuelle, et pas plus tard avec des b√©quilles. </li><li>  Exportation de m√©thodes externes.  Sans cela, la langue sera inutile.  √Ä moins de l'int√©grer dans n'importe quel projet. </li><li>  Compilation du langage (dans un seul fichier ex√©cutable abstrait).  Partiellement compil√© ou interpr√©t√©?  Cela d√©pend beaucoup de cela. </li><li>  Architecture g√©n√©rale des VM.  Est-ce que la pile ou l'enregistrement sera notre VM?  J'ai essay√© d'impl√©menter ceci et cela.  J'ai choisi une machine virtuelle empil√©e pour le support. </li><li>  Comment voyez-vous travailler avec des variables, des tableaux, des structures?  Personnellement, √† ce moment-l√†, je voulais impl√©menter un langage dans lequel presque tout est li√© √† des pointeurs implicites, car une telle approche √©conomiserait consid√©rablement de la m√©moire et simplifierait la vie du d√©veloppeur.  Si nous permettons √† quelque chose de grand d'√™tre pass√© dans les m√©thodes, seul un pointeur vers ce gros sera automatiquement transf√©r√©. </li></ul><br>  J'ai donc choisi les priorit√©s ci-dessus et j'ai commenc√© √† impl√©menter la machine virtuelle du langage.  C'est √©trange bien s√ªr, g√©n√©ralement tous les analyseurs / traducteurs sont √©crits en premier, puis les VM.  Eh bien, j'ai commenc√© √† d√©velopper le projet dans cet ordre et je vais le d√©crire plus en d√©tail dans l'ordre dans lequel je l'ai d√©velopp√©. <br><br>  Je dois dire tout de suite que j'ai nomm√© VM aussi √©loquemment que possible - SVM (Stack-based Virtual Machine). <br><br><h3>  Commen√ßons par l'impl√©mentation de la classe variable </h3><br>  Au d√©part, j'ai simplement utilis√© un type de variante, car il est plus simple et plus rapide.  C'√©tait une b√©quille, mais cela a soutenu le projet et m'a permis d'impl√©menter rapidement la premi√®re version de VM et du langage.  Plus tard, je me suis assis sur le code et j'ai √©crit une impl√©mentation de ma ¬´variante¬ª.  En substance, vous devez √©crire une classe qui stocke un pointeur vers une valeur en m√©moire, dans mon impl√©mentation, elle est <code>null/cardinal/int64/double/string/array</code> .  On pourrait utiliser le typage de casse, mais je me suis dit qu'il serait pr√©f√©rable d'impl√©menter la fa√ßon dont j'ai impl√©ment√©. <br><br>  Avant de commencer √† √©crire du code de classe, j'ai d√©cid√© de mettre imm√©diatement la directive {$ H +} dans l'en-t√™te du module pour une prise en charge plus flexible des cha√Ænes dans le futur langage. <br><blockquote>  P.S.  pour ceux qui ne connaissent pas la diff√©rence entre les modes H- et H + FPC. <br><br>  Lors de l'assemblage de code en mode H, les cha√Ænes seront pr√©sent√©es comme un tableau de caract√®res.  Lorsque H + - comme un pointeur vers un morceau de m√©moire.  Dans le premier cas, les lignes seront initialement de longueur fixe et limit√©es par d√©faut √† 256 caract√®res.  Dans le second cas, les lignes seront extensibles dynamiquement et beaucoup plus de caract√®res pourront y √™tre entass√©s.  Ils fonctionneront un peu plus lentement, mais de fa√ßon plus fonctionnelle.  Avec H +, vous pouvez √©galement d√©clarer des cha√Ænes comme un tableau de caract√®res, par exemple de cette mani√®re: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  Donc, pour commencer, nous d√©clarerons Enum un type, que nous utiliserons comme un certain indicateur pour d√©terminer le type de donn√©es par pointeur: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  Ensuite, nous d√©crivons la structure de base de notre type de variable et quelques m√©thodes: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  La classe n'h√©rite de rien, les appels h√©rit√©s dans le constructeur et le destructeur peuvent donc √™tre omis.  Je ferai attention √† la directive inline.  Il est pr√©f√©rable d'ajouter {$ inline on} √† l'en-t√™te du fichier, c'est s√ªr.  Son utilisation active dans les machines virtuelles a consid√©rablement augment√© la productivit√© (Mb quelque part de 15 √† 20%!).  Elle indique au compilateur que le corps de la m√©thode est mieux int√©gr√© √† la place de son invocation.  Le code de sortie sera l√©g√®rement plus grand √† la fin, mais fonctionnera plus rapidement.  Dans ce cas, l'utilisation de l'inline est recommand√©e. <br><br>  Ok, √† ce stade, nous avons lav√© les fondations de notre classe.  Maintenant, nous devons d√©crire un certain nombre de setters et getters (setter &amp; getter) dans notre classe. <br><br>  La t√¢che consiste √† √©crire quelques m√©thodes qui vous permettront d'encha√Æner et de r√©cup√©rer plus tard les valeurs de notre classe. <br><br>  Tout d'abord, d√©couvrons l'affectation d'une valeur pour notre classe.  Vous pouvez d'abord √©crire un setter g√©n√©ralis√©, puis, pour les types de donn√©es individuels: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Vous pouvez maintenant √©crire du code pour quelques getters: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ok, super, maintenant que vous avez pass√© un certain temps √† regarder l'IDE et √† taper avec enthousiasme le code pour les setters et les getters, nous sommes confront√©s √† la t√¢che de mettre en ≈ìuvre le support de notre type d'op√©rations math√©matiques et logiques.  A titre d'exemple, je vais vous donner l'impl√©mentation de l'op√©ration d'ajout: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Tout est simple.  D'autres op√©rations peuvent √™tre d√©crites de la m√™me mani√®re, et maintenant notre classe est pr√™te. <br>  Pour les tableaux, bien s√ªr, vous avez encore besoin de quelques m√©thodes, un exemple d'obtention d'un √©l√©ment par index: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Super.  Nous pouvons maintenant passer √† autre chose. <br><br><h3>  Nous r√©alisons une pile </h3><br>  Apr√®s un certain temps, je suis venu √† de telles pens√©es.  La pile doit √™tre √† la fois statique (pour la vitesse) et dynamique (pour la flexibilit√©) en m√™me temps. <br><br>  Par cons√©quent, la pile est impl√©ment√©e en blocs.  C'est-√†-dire  comment cela devrait fonctionner - au d√©part, le tableau de la pile a une certaine taille (j'ai d√©cid√© de d√©finir la taille du bloc √† 256 √©l√©ments afin qu'il soit beau et pas petit).  Par cons√©quent, un compteur est inclus avec la matrice, indiquant le sommet actuel de la pile.  La r√©allocation de m√©moire est une op√©ration extra longue, qui peut √™tre effectu√©e moins fr√©quemment.  Si plus de valeurs sont pouss√©es sur la pile, sa taille peut toujours √™tre √©tendue √† la taille d'un autre bloc. <br><br>  J'apporte toute l'impl√©mentation de la pile: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans les m√©thodes externes, la machine virtuelle passera un pointeur sur la pile afin de pouvoir y prendre les arguments n√©cessaires.  Un pointeur vers le flux VM a √©t√© ajout√© plus tard, afin que les appels de rappel √† partir de m√©thodes externes puissent √™tre impl√©ment√©s et, en g√©n√©ral, pour transf√©rer plus de puissance sur les m√©thodes VM. <br><br>  Alors, comment vous √™tes-vous familiaris√© avec la disposition de la pile?  La pile de rappel est organis√©e de la m√™me mani√®re, pour la simplicit√© et la commodit√© des op√©rations d'appel et de retour et de la pile de ramasse-miettes.  La seule chose est les autres tailles des blocs. <br><br><h3>  Parlez de poubelle </h3><br>  C'est g√©n√©ralement beaucoup, beaucoup.  Et vous devez en faire quelque chose. <br><br>  Tout d'abord, je veux parler de la fa√ßon dont les r√©cup√©rateurs sont organis√©s dans d'autres langages, par exemple, en Lua, Ruby, Java, Perl, PHP, etc.  Ils fonctionnent sur le principe du comptage des pointeurs vers les objets en m√©moire. <br><br>  C'est-√†-dire  donc nous avons allou√© de la m√©moire pour quelque chose, c'est logique - le pointeur a √©t√© imm√©diatement plac√© dans une variable / tableau / ailleurs.  Le garbage collector d'ex√©cution ajoute imm√©diatement ce pointeur √† lui-m√™me avec une liste des objets garbage possibles.  En arri√®re-plan, le garbage collector surveille en permanence toutes les variables, tableaux, etc.  S'il n'y a pas de pointeur vers quelque chose de la liste des ordures possibles, cela signifie que les ordures et la m√©moire d'en dessous doivent √™tre supprim√©es. <br><br>  J'ai d√©cid√© de vendre mon v√©lo.  Je suis plus habitu√© √† travailler avec la m√©moire sur le principe de Taras Bulba.  Je vous ai donn√© naissance - je vais vous tuer, je veux dire, quand j'appellerai le prochain Free dans le prochain cours.  Par cons√©quent, le garbage collector de ma machine virtuelle est semi-automatique.  C'est-√†-dire  il doit √™tre appel√© en mode manuel et fonctionner en cons√©quence.  √Ä son tour, des pointeurs vers des objets temporaires d√©clar√©s sont ajout√©s (ce r√¥le incombe principalement au traducteur et un peu au d√©veloppeur).  Pour lib√©rer de la m√©moire sous d'autres objets, vous pouvez utiliser un opcode s√©par√©. <br><br>  C'est-√†-dire  le garbage collector au moment de l'appel a une liste de pointeurs que vous devez parcourir et lib√©rer de la m√©moire. <br><br><h3>  Donc, maintenant, nous allons traiter de la compilation dans un fichier ex√©cutable abstrait </h3><br>  L'id√©e √©tait √† l'origine que les applications √©crites dans ma langue pouvaient fonctionner sans source, comme c'est le cas avec de nombreuses langues similaires.  C'est-√†-dire  il peut √™tre utilis√© √† des fins commerciales. <br><br>  Pour ce faire, vous devez d√©terminer le format des fichiers ex√©cutables.  J'ai obtenu ce qui suit: <br><br><ol><li>  En-t√™te, par exemple "SVMEXE_CNS". </li><li>  Une section contenant une liste de biblioth√®ques √† partir desquelles les m√©thodes seront import√©es. </li><li>  La section d'importation des m√©thodes requises, les biblioth√®ques √† partir desquelles les m√©thodes sont import√©es sont indiqu√©es par leur num√©ro dans la section ci-dessus. </li><li>  Section de constantes. </li><li>  Section de code </li></ol><br>  Je ne pense pas qu'il soit utile de pr√©senter les √©tapes d√©taill√©es de la mise en ≈ìuvre des analyseurs pour ces sections, car vous pouvez tout voir par vous-m√™me dans mon r√©f√©rentiel. <br><br><h3>  Ex√©cution de code </h3><br>  Apr√®s avoir analys√© les sections ci-dessus et initialis√© la machine virtuelle, nous avons une section avec le code.  Dans ma machine virtuelle, un bytecode non align√© est ex√©cut√©, c'est-√†-dire  les instructions peuvent √™tre de longueur arbitraire. <br><br>  Un ensemble d'opcodes - instructions pour une machine virtuelle avec de petits commentaires que je montre √† l'avance ci-dessous: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Ainsi, vous vous √™tes familiaris√© avec les op√©rations que la machine virtuelle √©crite par moi peut effectuer.  Maintenant, je veux parler de la fa√ßon dont tout cela fonctionne. <br><br>  Une machine virtuelle est impl√©ment√©e en tant qu'objet, vous pouvez donc facilement impl√©menter la prise en charge du multithreading. <br><br>  Il a un pointeur vers un tableau avec des opcodes, IP (Instruction Pointer) - d√©calage de l'instruction ex√©cut√©e et des pointeurs vers d'autres structures de VM. <br><br>  L'ex√©cution de code est un gros casse-t√™te. <br><br>  Donnez simplement une description de la VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Un peu sur la gestion des exceptions </h3><br>  Pour ce faire, la machine virtuelle poss√®de une pile de gestionnaires d'exceptions et un grand bloc try / catch dans lequel l'ex√©cution de code est encapsul√©e.  √Ä partir de la pile, vous pouvez placer une structure qui a un d√©calage de point d'entr√©e sur le bloc de gestion des exceptions catch et finalement / end.  J'ai √©galement fourni l'opcode trs, qui est plac√© avant catch et jette le code pour finalement / end s'il r√©ussit, en supprimant simultan√©ment le bloc avec des informations sur les gestionnaires d'exceptions du haut de la pile correspondante.  C'est simple?  C'est simple.  Est-ce pratique?  Id√©alement. <br><br><h3>  Parlons des m√©thodes externes et des biblioth√®ques </h3><br>  Je les ai d√©j√† mentionn√©s auparavant.  Importations, biblioth√®ques ... Sans eux, le langage n'aura pas la flexibilit√© et les fonctionnalit√©s souhait√©es. <br><br>  Tout d'abord, dans l'impl√©mentation de la VM, nous d√©clarerons le type de la m√©thode externe et le protocole pour l'appeler. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Lors de l'importation d'une machine virtuelle, l'analyseur de la section d'importation remplit un tableau de pointeurs vers des m√©thodes externes.  Par cons√©quent, chaque m√©thode a une adresse statique, qui est calcul√©e au stade de l'assemblage de l'application sous la machine virtuelle et par laquelle la m√©thode souhait√©e peut √™tre appel√©e. <br><br>  L'appel se produit plus tard de cette mani√®re lors de l'ex√©cution du code: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  √âcrivons une biblioth√®que simple pour notre VM </h3><br>  Et laissez-la d'abord mettre en ≈ìuvre la m√©thode Sleep: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  R√©sum√© </h3><br>  Sur ce, je terminerai probablement mon premier article √† partir d'un cycle con√ßu. <br><br>  Aujourd'hui, j'ai d√©crit en d√©tail la cr√©ation du langage d'ex√©cution.  Je crois que cet article sera tr√®s utile pour les personnes qui d√©cident d'essayer d'√©crire leur propre langage ou de comprendre comment fonctionnent des langages de programmation similaires. <br><br>  Le code VM complet est disponible dans le r√©f√©rentiel, dans la branche / runtime / svm. <br><br>  Si vous avez aim√© cet article, alors ne soyez pas paresseux pour jeter un plus dans le karma et l'augmenter en haut, j'ai essay√© et j'essaierai pour vous. <br><br>  Si quelque chose n'est pas clair pour vous, alors bienvenue dans les commentaires ou sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le forum</a> . <br><br>  Peut-√™tre que vos questions et vos r√©ponses seront int√©ressantes non seulement pour vous. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435202/">https://habr.com/ru/post/fr435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435186/index.html">Rolls-Royce d√©veloppe l'avion √©lectrique le plus rapide du monde</a></li>
<li><a href="../fr435190/index.html">Google a r√©ussi √† se retirer de la taxe de 22,7 milliards de dollars via l'Irlande et les Bermudes</a></li>
<li><a href="../fr435194/index.html">Simplifiez la r√©daction du CV d'un d√©veloppeur</a></li>
<li><a href="../fr435196/index.html">Les chercheurs r√©ussissent ReCAPTCHA en utilisant les services Google</a></li>
<li><a href="../fr435198/index.html">Arduin et LED, ou comment mettre √† niveau le designer pour enfants</a></li>
<li><a href="../fr435204/index.html">R√©ception pour les d√©veloppeurs pour surmonter la procrastination</a></li>
<li><a href="../fr435206/index.html">L'Europe approuve la directive sur le droit d'auteur - pourquoi les plateformes de streaming s'opposent</a></li>
<li><a href="../fr435208/index.html">Internet des objets ... qui pleurent pour une bonne UI / UX</a></li>
<li><a href="../fr435210/index.html">Le travail de Xamarin avec le SDK C</a></li>
<li><a href="../fr435212/index.html">Comment oublier les cartes de visite en papier dans la nouvelle ann√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>