<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏰 👨‍👩‍👦‍👦 👩🏻‍🏭 Nous écrivons notre langage de programmation, partie 1: nous écrivons un langage VM 👩🏼‍🎨 💟 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 Bonne journée à tous les habrachitateli! 

 Donc, il vaut peut-être la peine de dire que le but de mon travail, sur la base duquel un c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous écrivons notre langage de programmation, partie 1: nous écrivons un langage VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  Présentation </h3><br>  Bonne journée à tous les habrachitateli! <br><br>  Donc, il vaut peut-être la peine de dire que le but de mon travail, sur la base duquel un certain nombre de statues seront écrites, était de créer moi-même un PJ pleinement fonctionnel à partir de 0, puis de partager mes connaissances, mes meilleures pratiques et mon expérience avec ceux qui sont intéressés. <br><br>  Je décrirai la création du langage que j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit plus haut ici</a> . <br><br>  Il a intéressé de nombreuses personnes et provoqué une discussion animée dans les commentaires.  Par conséquent - le sujet est intéressant pour beaucoup. <br><br>  Je pense que cela vaut la peine de publier immédiatement des informations sur le projet: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Site</a> (sera rempli de documentation un peu plus tard). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dépôt</a> <br><br>  Pour toucher le projet vous-même et voir tout en action, il est préférable de télécharger le référentiel et d'exécuter tout depuis le dossier bin.  Dans la version, je ne suis pas pressé de télécharger les dernières versions de la langue et du runtime, car  parfois c'est trop paresseux pour moi de le faire. <br><br>  Je peux coder en C / C ++ et Object Pascal.  J'ai écrit le projet sur FPC depuis  à mon avis, cette langue est beaucoup plus simple et mieux adaptée pour écrire comme ça.  Le deuxième facteur déterminant était que FPC prend en charge un grand nombre de plateformes cibles et qu'il est possible de reconstruire un projet pour la plateforme souhaitée avec un minimum de modifications.  Si pour une raison quelconque je n'aime pas Object Pascal, alors ne vous précipitez pas pour fermer le message et courez pour jeter des pierres au commentaire.  Ce langage est très beau et intuitif, mais je ne fournirai pas autant de code.  Exactement ce dont vous avez besoin. <br><br>  Alors, je vais peut-être commencer mon histoire. <br><a name="habracut"></a><br><h3>  Nous nous fixons des objectifs </h3><br>  Tout d'abord, tout projet a besoin de ses objectifs et de ses savoirs traditionnels, qui devront être mis en œuvre à l'avenir.  Il est nécessaire de décider à l'avance quel type de langage sera créé afin d'écrire la VM principale pour celui-ci. <br><br>  Les points clés qui ont déterminé le développement futur de ma machine virtuelle sont les suivants: <br><br><ul><li>  Saisie et transtypage dynamiques.  J'ai décidé d'organiser son accompagnement au stade de développement de la VM. </li><li>  Prise en charge du multithreading.  J'ai inclus cet élément dans cette liste à l'avance afin de bien concevoir l'architecture de la machine virtuelle et d'organiser la prise en charge du multithreading au niveau principal de la machine virtuelle, et pas plus tard avec des béquilles. </li><li>  Exportation de méthodes externes.  Sans cela, la langue sera inutile.  À moins de l'intégrer dans n'importe quel projet. </li><li>  Compilation du langage (dans un seul fichier exécutable abstrait).  Partiellement compilé ou interprété?  Cela dépend beaucoup de cela. </li><li>  Architecture générale des VM.  Est-ce que la pile ou l'enregistrement sera notre VM?  J'ai essayé d'implémenter ceci et cela.  J'ai choisi une machine virtuelle empilée pour le support. </li><li>  Comment voyez-vous travailler avec des variables, des tableaux, des structures?  Personnellement, à ce moment-là, je voulais implémenter un langage dans lequel presque tout est lié à des pointeurs implicites, car une telle approche économiserait considérablement de la mémoire et simplifierait la vie du développeur.  Si nous permettons à quelque chose de grand d'être passé dans les méthodes, seul un pointeur vers ce gros sera automatiquement transféré. </li></ul><br>  J'ai donc choisi les priorités ci-dessus et j'ai commencé à implémenter la machine virtuelle du langage.  C'est étrange bien sûr, généralement tous les analyseurs / traducteurs sont écrits en premier, puis les VM.  Eh bien, j'ai commencé à développer le projet dans cet ordre et je vais le décrire plus en détail dans l'ordre dans lequel je l'ai développé. <br><br>  Je dois dire tout de suite que j'ai nommé VM aussi éloquemment que possible - SVM (Stack-based Virtual Machine). <br><br><h3>  Commençons par l'implémentation de la classe variable </h3><br>  Au départ, j'ai simplement utilisé un type de variante, car il est plus simple et plus rapide.  C'était une béquille, mais cela a soutenu le projet et m'a permis d'implémenter rapidement la première version de VM et du langage.  Plus tard, je me suis assis sur le code et j'ai écrit une implémentation de ma «variante».  En substance, vous devez écrire une classe qui stocke un pointeur vers une valeur en mémoire, dans mon implémentation, elle est <code>null/cardinal/int64/double/string/array</code> .  On pourrait utiliser le typage de casse, mais je me suis dit qu'il serait préférable d'implémenter la façon dont j'ai implémenté. <br><br>  Avant de commencer à écrire du code de classe, j'ai décidé de mettre immédiatement la directive {$ H +} dans l'en-tête du module pour une prise en charge plus flexible des chaînes dans le futur langage. <br><blockquote>  P.S.  pour ceux qui ne connaissent pas la différence entre les modes H- et H + FPC. <br><br>  Lors de l'assemblage de code en mode H, les chaînes seront présentées comme un tableau de caractères.  Lorsque H + - comme un pointeur vers un morceau de mémoire.  Dans le premier cas, les lignes seront initialement de longueur fixe et limitées par défaut à 256 caractères.  Dans le second cas, les lignes seront extensibles dynamiquement et beaucoup plus de caractères pourront y être entassés.  Ils fonctionneront un peu plus lentement, mais de façon plus fonctionnelle.  Avec H +, vous pouvez également déclarer des chaînes comme un tableau de caractères, par exemple de cette manière: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  Donc, pour commencer, nous déclarerons Enum un type, que nous utiliserons comme un certain indicateur pour déterminer le type de données par pointeur: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  Ensuite, nous décrivons la structure de base de notre type de variable et quelques méthodes: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  La classe n'hérite de rien, les appels hérités dans le constructeur et le destructeur peuvent donc être omis.  Je ferai attention à la directive inline.  Il est préférable d'ajouter {$ inline on} à l'en-tête du fichier, c'est sûr.  Son utilisation active dans les machines virtuelles a considérablement augmenté la productivité (Mb quelque part de 15 à 20%!).  Elle indique au compilateur que le corps de la méthode est mieux intégré à la place de son invocation.  Le code de sortie sera légèrement plus grand à la fin, mais fonctionnera plus rapidement.  Dans ce cas, l'utilisation de l'inline est recommandée. <br><br>  Ok, à ce stade, nous avons lavé les fondations de notre classe.  Maintenant, nous devons décrire un certain nombre de setters et getters (setter &amp; getter) dans notre classe. <br><br>  La tâche consiste à écrire quelques méthodes qui vous permettront d'enchaîner et de récupérer plus tard les valeurs de notre classe. <br><br>  Tout d'abord, découvrons l'affectation d'une valeur pour notre classe.  Vous pouvez d'abord écrire un setter généralisé, puis, pour les types de données individuels: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Vous pouvez maintenant écrire du code pour quelques getters: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ok, super, maintenant que vous avez passé un certain temps à regarder l'IDE et à taper avec enthousiasme le code pour les setters et les getters, nous sommes confrontés à la tâche de mettre en œuvre le support de notre type d'opérations mathématiques et logiques.  A titre d'exemple, je vais vous donner l'implémentation de l'opération d'ajout: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Tout est simple.  D'autres opérations peuvent être décrites de la même manière, et maintenant notre classe est prête. <br>  Pour les tableaux, bien sûr, vous avez encore besoin de quelques méthodes, un exemple d'obtention d'un élément par index: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Super.  Nous pouvons maintenant passer à autre chose. <br><br><h3>  Nous réalisons une pile </h3><br>  Après un certain temps, je suis venu à de telles pensées.  La pile doit être à la fois statique (pour la vitesse) et dynamique (pour la flexibilité) en même temps. <br><br>  Par conséquent, la pile est implémentée en blocs.  C'est-à-dire  comment cela devrait fonctionner - au départ, le tableau de la pile a une certaine taille (j'ai décidé de définir la taille du bloc à 256 éléments afin qu'il soit beau et pas petit).  Par conséquent, un compteur est inclus avec la matrice, indiquant le sommet actuel de la pile.  La réallocation de mémoire est une opération extra longue, qui peut être effectuée moins fréquemment.  Si plus de valeurs sont poussées sur la pile, sa taille peut toujours être étendue à la taille d'un autre bloc. <br><br>  J'apporte toute l'implémentation de la pile: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans les méthodes externes, la machine virtuelle passera un pointeur sur la pile afin de pouvoir y prendre les arguments nécessaires.  Un pointeur vers le flux VM a été ajouté plus tard, afin que les appels de rappel à partir de méthodes externes puissent être implémentés et, en général, pour transférer plus de puissance sur les méthodes VM. <br><br>  Alors, comment vous êtes-vous familiarisé avec la disposition de la pile?  La pile de rappel est organisée de la même manière, pour la simplicité et la commodité des opérations d'appel et de retour et de la pile de ramasse-miettes.  La seule chose est les autres tailles des blocs. <br><br><h3>  Parlez de poubelle </h3><br>  C'est généralement beaucoup, beaucoup.  Et vous devez en faire quelque chose. <br><br>  Tout d'abord, je veux parler de la façon dont les récupérateurs sont organisés dans d'autres langages, par exemple, en Lua, Ruby, Java, Perl, PHP, etc.  Ils fonctionnent sur le principe du comptage des pointeurs vers les objets en mémoire. <br><br>  C'est-à-dire  donc nous avons alloué de la mémoire pour quelque chose, c'est logique - le pointeur a été immédiatement placé dans une variable / tableau / ailleurs.  Le garbage collector d'exécution ajoute immédiatement ce pointeur à lui-même avec une liste des objets garbage possibles.  En arrière-plan, le garbage collector surveille en permanence toutes les variables, tableaux, etc.  S'il n'y a pas de pointeur vers quelque chose de la liste des ordures possibles, cela signifie que les ordures et la mémoire d'en dessous doivent être supprimées. <br><br>  J'ai décidé de vendre mon vélo.  Je suis plus habitué à travailler avec la mémoire sur le principe de Taras Bulba.  Je vous ai donné naissance - je vais vous tuer, je veux dire, quand j'appellerai le prochain Free dans le prochain cours.  Par conséquent, le garbage collector de ma machine virtuelle est semi-automatique.  C'est-à-dire  il doit être appelé en mode manuel et fonctionner en conséquence.  À son tour, des pointeurs vers des objets temporaires déclarés sont ajoutés (ce rôle incombe principalement au traducteur et un peu au développeur).  Pour libérer de la mémoire sous d'autres objets, vous pouvez utiliser un opcode séparé. <br><br>  C'est-à-dire  le garbage collector au moment de l'appel a une liste de pointeurs que vous devez parcourir et libérer de la mémoire. <br><br><h3>  Donc, maintenant, nous allons traiter de la compilation dans un fichier exécutable abstrait </h3><br>  L'idée était à l'origine que les applications écrites dans ma langue pouvaient fonctionner sans source, comme c'est le cas avec de nombreuses langues similaires.  C'est-à-dire  il peut être utilisé à des fins commerciales. <br><br>  Pour ce faire, vous devez déterminer le format des fichiers exécutables.  J'ai obtenu ce qui suit: <br><br><ol><li>  En-tête, par exemple "SVMEXE_CNS". </li><li>  Une section contenant une liste de bibliothèques à partir desquelles les méthodes seront importées. </li><li>  La section d'importation des méthodes requises, les bibliothèques à partir desquelles les méthodes sont importées sont indiquées par leur numéro dans la section ci-dessus. </li><li>  Section de constantes. </li><li>  Section de code </li></ol><br>  Je ne pense pas qu'il soit utile de présenter les étapes détaillées de la mise en œuvre des analyseurs pour ces sections, car vous pouvez tout voir par vous-même dans mon référentiel. <br><br><h3>  Exécution de code </h3><br>  Après avoir analysé les sections ci-dessus et initialisé la machine virtuelle, nous avons une section avec le code.  Dans ma machine virtuelle, un bytecode non aligné est exécuté, c'est-à-dire  les instructions peuvent être de longueur arbitraire. <br><br>  Un ensemble d'opcodes - instructions pour une machine virtuelle avec de petits commentaires que je montre à l'avance ci-dessous: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Ainsi, vous vous êtes familiarisé avec les opérations que la machine virtuelle écrite par moi peut effectuer.  Maintenant, je veux parler de la façon dont tout cela fonctionne. <br><br>  Une machine virtuelle est implémentée en tant qu'objet, vous pouvez donc facilement implémenter la prise en charge du multithreading. <br><br>  Il a un pointeur vers un tableau avec des opcodes, IP (Instruction Pointer) - décalage de l'instruction exécutée et des pointeurs vers d'autres structures de VM. <br><br>  L'exécution de code est un gros casse-tête. <br><br>  Donnez simplement une description de la VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Un peu sur la gestion des exceptions </h3><br>  Pour ce faire, la machine virtuelle possède une pile de gestionnaires d'exceptions et un grand bloc try / catch dans lequel l'exécution de code est encapsulée.  À partir de la pile, vous pouvez placer une structure qui a un décalage de point d'entrée sur le bloc de gestion des exceptions catch et finalement / end.  J'ai également fourni l'opcode trs, qui est placé avant catch et jette le code pour finalement / end s'il réussit, en supprimant simultanément le bloc avec des informations sur les gestionnaires d'exceptions du haut de la pile correspondante.  C'est simple?  C'est simple.  Est-ce pratique?  Idéalement. <br><br><h3>  Parlons des méthodes externes et des bibliothèques </h3><br>  Je les ai déjà mentionnés auparavant.  Importations, bibliothèques ... Sans eux, le langage n'aura pas la flexibilité et les fonctionnalités souhaitées. <br><br>  Tout d'abord, dans l'implémentation de la VM, nous déclarerons le type de la méthode externe et le protocole pour l'appeler. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Lors de l'importation d'une machine virtuelle, l'analyseur de la section d'importation remplit un tableau de pointeurs vers des méthodes externes.  Par conséquent, chaque méthode a une adresse statique, qui est calculée au stade de l'assemblage de l'application sous la machine virtuelle et par laquelle la méthode souhaitée peut être appelée. <br><br>  L'appel se produit plus tard de cette manière lors de l'exécution du code: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  Écrivons une bibliothèque simple pour notre VM </h3><br>  Et laissez-la d'abord mettre en œuvre la méthode Sleep: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  Résumé </h3><br>  Sur ce, je terminerai probablement mon premier article à partir d'un cycle conçu. <br><br>  Aujourd'hui, j'ai décrit en détail la création du langage d'exécution.  Je crois que cet article sera très utile pour les personnes qui décident d'essayer d'écrire leur propre langage ou de comprendre comment fonctionnent des langages de programmation similaires. <br><br>  Le code VM complet est disponible dans le référentiel, dans la branche / runtime / svm. <br><br>  Si vous avez aimé cet article, alors ne soyez pas paresseux pour jeter un plus dans le karma et l'augmenter en haut, j'ai essayé et j'essaierai pour vous. <br><br>  Si quelque chose n'est pas clair pour vous, alors bienvenue dans les commentaires ou sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le forum</a> . <br><br>  Peut-être que vos questions et vos réponses seront intéressantes non seulement pour vous. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435202/">https://habr.com/ru/post/fr435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435186/index.html">Rolls-Royce développe l'avion électrique le plus rapide du monde</a></li>
<li><a href="../fr435190/index.html">Google a réussi à se retirer de la taxe de 22,7 milliards de dollars via l'Irlande et les Bermudes</a></li>
<li><a href="../fr435194/index.html">Simplifiez la rédaction du CV d'un développeur</a></li>
<li><a href="../fr435196/index.html">Les chercheurs réussissent ReCAPTCHA en utilisant les services Google</a></li>
<li><a href="../fr435198/index.html">Arduin et LED, ou comment mettre à niveau le designer pour enfants</a></li>
<li><a href="../fr435204/index.html">Réception pour les développeurs pour surmonter la procrastination</a></li>
<li><a href="../fr435206/index.html">L'Europe approuve la directive sur le droit d'auteur - pourquoi les plateformes de streaming s'opposent</a></li>
<li><a href="../fr435208/index.html">Internet des objets ... qui pleurent pour une bonne UI / UX</a></li>
<li><a href="../fr435210/index.html">Le travail de Xamarin avec le SDK C</a></li>
<li><a href="../fr435212/index.html">Comment oublier les cartes de visite en papier dans la nouvelle année</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>