<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçì üßùüèΩ üñêÔ∏è Acerca de LL Parsing: un enfoque para analizar a trav√©s del concepto de corte de cuerdas üé∫ üåò üßìüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Saludos a la distinguida comunidad! 

 La repetici√≥n es la madre del aprendizaje, y comprender el an√°lisis es una habilidad muy √∫til para cualquier p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acerca de LL Parsing: un enfoque para analizar a trav√©s del concepto de corte de cuerdas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> ¬°Saludos a la distinguida comunidad! <br><br>  La repetici√≥n es la madre del aprendizaje, y comprender el an√°lisis es una habilidad muy √∫til para cualquier programador, por lo que quiero volver a plantear este tema y hablar esta vez sobre el an√°lisis de descenso recursivo (LL) sin hacer demasiado formalismo (siempre puede usarlos m√°s adelante). volver) <br><br>  Como escribe el gran D. Strogov, "comprender es simplificar".  Por lo tanto, para comprender el concepto de an√°lisis mediante el m√©todo de descenso recursivo (tambi√©n conocido como an√°lisis LL), simplificamos la tarea tanto como sea posible y escribimos manualmente un analizador de un formato similar a JSON, pero m√°s simple (si lo desea, puede expandirlo a un analizador JSON completo si querer hacer ejercicio).  Escrib√°moslo, tomando como base la idea de <b>cortar la cuerda</b> . <br><a name="habracut"></a><br>  En los libros cl√°sicos y los cursos de dise√±o de compiladores, generalmente comienzan a explicar el tema del an√°lisis y la interpretaci√≥n, destacando varias fases: <br><br><ul><li>  An√°lisis l√©xico: divisi√≥n del texto de origen en una serie de subcadenas (tokens o tokens) </li><li>  An√°lisis: construir un √°rbol de an√°lisis a partir de una variedad de tokens </li><li>  Interpretaci√≥n (o compilaci√≥n): atravesar el √°rbol resultante en el orden deseado (directo o inverso) y realizar algunas acciones de interpretaci√≥n o generaci√≥n de c√≥digo en algunos pasos de este recorrido </li></ul><br><div class="spoiler">  <b class="spoiler_title">en realidad no</b> <div class="spoiler_text">  porque en el proceso de an√°lisis ya obtenemos una secuencia de pasos, que es una secuencia de visitas a los nodos del √°rbol, el √°rbol en forma expl√≠cita puede no existir en absoluto, pero a√∫n no profundizaremos.  Para aquellos que quieren profundizar, hay enlaces al final. <br></div></div><br>  Ahora quiero usar un enfoque ligeramente diferente para este mismo concepto (an√°lisis LL) y mostrar c√≥mo se puede construir un analizador LL basado en la idea de cortar una cadena: los fragmentos se cortan de la cadena original durante el an√°lisis, se hace m√°s peque√±o y luego se analiza expuesto el resto de la l√≠nea.  Como resultado, llegamos al mismo concepto de descenso recursivo, pero de una manera ligeramente diferente de lo que generalmente se hace.  Quiz√°s este camino sea m√°s conveniente para comprender la esencia de la idea.  Y si no, entonces todav√≠a es una oportunidad para mirar un descenso recursivo desde un √°ngulo diferente. <br><br>  Comencemos con una tarea m√°s simple: hay una l√≠nea con delimitadores, y quiero escribir una iteraci√≥n sobre sus valores.  Algo como: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  ¬øC√≥mo se puede hacer esto?  La forma est√°ndar es convertir la cadena delimitada en una matriz o lista usando String.split (en Java) o names.split (",") (en javascript), e iterar a trav√©s de la matriz ya.  Pero imaginemos que no queremos o no podemos usar la conversi√≥n a una matriz (por ejemplo, bueno, de repente si programamos en el lenguaje de programaci√≥n AVAJ ++, en el que no hay una estructura de datos de "matriz").  Todav√≠a puede escanear la cadena y rastrear los delimitadores, pero tampoco usar√© este m√©todo, porque hace que el c√≥digo del ciclo de iteraci√≥n sea engorroso y, lo m√°s importante, va en contra del concepto que quiero mostrar.  Por lo tanto, nos relacionaremos con una cadena delimitada de la misma manera que con las listas en la programaci√≥n funcional.  Y all√≠ siempre definen las funciones head (obtener el primer elemento de la lista) y tail (obtener el resto de la lista).  A partir de los primeros dialectos de Lisp, donde estas funciones se llamaban de manera absolutamente horrible e intuitiva: car y cdr (car = contenido del registro de direcciones, cdr = contenido del registro de decrementos. Las leyendas antiguas son profundas, s√≠, eheheh). <br><br>  Nuestra l√≠nea es una l√≠nea delimitada.  Resalta los divisores en p√∫rpura: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Y resalte los elementos de la lista en amarillo: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Asumimos que nuestra l√≠nea es mutable (se puede cambiar) y escribimos una funci√≥n: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Su firma, por ejemplo, podr√≠a ser: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  En la entrada de la funci√≥n, damos una lista (en forma de una cadena con separadores) y, de hecho, el valor del separador.  En la salida, la funci√≥n devuelve el primer elemento de la lista (segmento de l√≠nea al primer separador), el resto de la lista y el signo de si se devolvi√≥ el primer elemento.  En este caso, el resto de la lista se coloca en la misma variable donde estaba la lista original. <br><br>  Como resultado, tuvimos la oportunidad de escribir as√≠: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Salidas como se esperaba: <br><br>  ivanov <br>  petrov <br>  sidorov <br><br>  Lo hicimos sin conversi√≥n a ArrayList, pero estropeamos la variable de nombres, y ahora tiene una cadena vac√≠a.  Todav√≠a no parece muy √∫til, como si cambiaran el punz√≥n por jab√≥n.  Pero vamos m√°s all√°.  All√≠ veremos por qu√© fue necesario y ad√≥nde nos llevar√°. <br><br>  Ahora analicemos algo m√°s interesante: una lista de pares clave-valor.  Esta tambi√©n es una tarea muy com√∫n. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Tambi√©n esperado.  Y lo mismo se puede lograr con String.split, sin cortar las l√≠neas. <br>  Pero digamos que ahora quer√≠amos complicar nuestro formato y pasar de un valor clave plano a un formato anidable que recuerda a JSON.  Ahora queremos leer algo como esto: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  ¬øQu√© separador dividen?  Si es una coma, entonces en una de las fichas tendremos la l√≠nea <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Obviamente no es lo que necesitamos.  Por lo tanto, debemos prestar atenci√≥n a la estructura de la l√≠nea que queremos analizar. <br><br>  Comienza con una llave y termina con una llave (emparejada, lo cual es importante).  Dentro de estos corchetes hay una lista de pares 'clave': 'valor', cada par est√° separado del siguiente par por una coma.  La clave y el valor est√°n separados por dos puntos.  Una clave es una cadena de letras encerradas en ap√≥strofes.  El valor puede ser una cadena de caracteres encerrados en ap√≥strofes, o puede ser la misma estructura, comenzando y terminando con llaves entre pares.  Llamamos a dicha estructura la palabra "objeto", como es costumbre llamarla en JSON. <br><br>  Acabamos de describir informalmente la gram√°tica de nuestro formato similar a JSON.  T√≠picamente, las gram√°ticas se describen al rev√©s, en forma formal, y la notaci√≥n BNF o sus variaciones se usan para escribirlas.  Pero ahora puedo prescindir de √©l, y veremos c√≥mo puede "cortar" esta l√≠nea para que pueda analizarse de acuerdo con las reglas de esta gram√°tica. <br><br>  De hecho, nuestro "objeto" comienza con una llave de apertura y termina con un par que lo cierra.  ¬øQu√© puede hacer una funci√≥n que analiza dicho formato?  Lo m√°s probable, lo siguiente: <br><br><ul><li>  verifique que la cadena pasada comience con una llave de apertura </li><li>  verifique que la cadena pasada termine con un par de llaves de cierre </li><li>  si ambas condiciones son verdaderas, corte los corchetes de apertura y cierre, y lo que queda, pase a la funci√≥n que analiza la lista de pares 'clave': 'valor' </li></ul><br>  Nota: aparecieron las palabras "funci√≥n que analiza este formato" y "funci√≥n que analiza la lista de pares 'clave': 'valor'‚Äù.  Tenemos dos caracter√≠sticas!  Estas son las mismas funciones que en la descripci√≥n cl√°sica del algoritmo de descenso recursivo se denominan "funciones de an√°lisis de s√≠mbolos no terminales", y que dicen que "para cada s√≠mbolo no terminal hay una funci√≥n de an√°lisis".  Lo que, de hecho, lo analiza.  Podr√≠amos nombrarlos, por ejemplo, parseJsonObject y parseJsonPairList. <br><br>  Tambi√©n ahora debemos prestar atenci√≥n a que tenemos el concepto de "par de par" adem√°s del concepto de "separador".  Si para cortar una l√≠nea al siguiente separador (dos puntos entre una clave y un valor, una coma entre los pares "clave: valor"), la funci√≥n cutNextToken fue suficiente para nosotros, ahora que podemos usar no solo una cadena, sino tambi√©n un objeto, necesitamos funci√≥n "cortar al siguiente par de par√©ntesis".  Algo como esto: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Esta funci√≥n corta un fragmento de la l√≠nea del par√©ntesis de apertura al par que lo cierra, dados los par√©ntesis, si los hay.  Por supuesto, no puede limitarse a los corchetes, sino que utiliza una funci√≥n similar para cortar varias estructuras de bloques que se pueden anidar: los bloques de operador comienzan ... fin, si ... fin, para ... fin y otros similares. <br><br>  Dibujemos gr√°ficamente lo que suceder√° con la cadena.  Color turquesa: esto significa que escaneamos la l√≠nea hacia adelante hasta el s√≠mbolo resaltado en turquesa para determinar qu√© debemos hacer a continuaci√≥n.  Violeta es "qu√© cortar, esto es cuando cortamos los fragmentos resaltados en violeta de la l√≠nea y continuamos analizando lo que queda de √©l m√°s all√°". <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  A modo de comparaci√≥n, la salida del programa (el texto del programa se proporciona en el ap√©ndice) que analiza esta l√≠nea: <br><br>  Demostraci√≥n de an√°lisis de estructura similar a JSON <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  En cualquier momento, sabemos lo que esperamos encontrar en nuestra l√≠nea de entrada.  Si ingresamos a la funci√≥n parseJsonObject, entonces esperamos que el objeto nos sea pasado all√≠, y podemos verificar esto por la presencia de los corchetes de apertura y cierre al principio y al final.  Si ingresamos la funci√≥n parseJsonPairList, entonces esperamos una lista de pares "clave: valor" all√≠, y despu√©s de que "mordimos" la clave (antes del separador ":"), esperamos que lo siguiente que "muerdamos" sea valor  Podemos ver el primer car√°cter del valor y sacar una conclusi√≥n sobre su tipo (si el ap√≥strofe, entonces el valor es del tipo "cadena", si el corchete de apertura es el valor es del tipo "objeto"). <br><br>  Por lo tanto, cortando fragmentos de la cadena, podemos analizarlos por el m√©todo de an√°lisis de arriba hacia abajo (descenso recursivo).  Y cuando podemos analizar, podemos analizar el formato que necesitamos.  O cree su propio formato conveniente para nosotros y desm√≥ntelo.  O cree un lenguaje espec√≠fico de dominio (DSL) para nuestra √°rea espec√≠fica y dise√±e un int√©rprete para ello.  Y para construirlo correctamente, sin soluciones tortuosas en regexp o m√°quinas de estado hechas a s√≠ mismas que surgen para los programadores que intentan resolver alg√∫n problema que requiere an√°lisis, pero que no poseen el material. <br><br>  Aqu√≠  Felicitaciones a todos por el pr√≥ximo verano y les deseo lo mejor, amor y analizadores funcionales :) <br><br>  Para m√°s lectura: <br><br>  Ideol√≥gico: un par de largos pero valiosos art√≠culos de Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comida rica de programador</a> <br><br>  Un par de citas a partir de ah√≠: <br><blockquote>  Aprendes compiladores y comienzas a escribir tus propios DSL, o obtienes un mejor idioma </blockquote><blockquote>  La primera gran fase de la canalizaci√≥n de compilaci√≥n es el an√°lisis </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema del pinocho</a> <br><br>  Cita a partir de ah√≠: <br><blockquote>  Las conversiones de tipos, las conversiones de reducci√≥n y ampliaci√≥n, las funciones de amigo para omitir las protecciones de clase est√°ndar, el <b>relleno de minilenguajes en cadenas y el an√°lisis manual</b> , hay docenas de formas de evitar los sistemas de tipos en Java y C ++, y los programadores los usan todo el tiempo , porque (poco saben) est√°n intentando construir software, no hardware. </blockquote>  T√©cnico: dos art√≠culos sobre an√°lisis sobre la diferencia entre los enfoques LL y LR: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">An√°lisis LL y LR desmitificados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LL y LR en contexto: por qu√© las herramientas de an√°lisis son dif√≠ciles</a> <br><br>  Y a√∫n m√°s profundo en el tema: c√≥mo escribir un int√©rprete Lisp en C ++ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Int√©rprete Lisp en 90 l√≠neas de C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Solicitud</b>  <b class="spoiler_title">Ejemplo de c√≥digo (java) que implementa el analizador descrito en el art√≠culo:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412905/">https://habr.com/ru/post/es412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412895/index.html">Vesta Matveeva: la lucha contra el cibercrimen es una elecci√≥n moral</a></li>
<li><a href="../es412897/index.html">Monitoreo de productos Atlassian con Prometheus</a></li>
<li><a href="../es412899/index.html">Lectura de fin de semana: 30 materiales sobre sonido, la historia de las marcas de audio y la industria del cine.</a></li>
<li><a href="../es412901/index.html">Monitoreo y Kubernetes (revisi√≥n y video informe)</a></li>
<li><a href="../es412903/index.html">Como pintamos a Habr</a></li>
<li><a href="../es412911/index.html">Los desarrolladores hablan sobre caracter√≠sticas cortadas de los juegos</a></li>
<li><a href="../es412913/index.html">"Baikal-T1" sali√≥ a la venta por 3990 rublos</a></li>
<li><a href="../es412915/index.html">Determinaci√≥n de la densidad del gas a partir de los resultados de medici√≥n de presi√≥n y temperatura con sensores Arduino</a></li>
<li><a href="../es412917/index.html">Russian Post comenzar√° a usar clasificadores rob√≥ticos. Como va a funcionar</a></li>
<li><a href="../es412921/index.html">Firmas de red de Monero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>