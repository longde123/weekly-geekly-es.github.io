<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 ⚡️ 🤞🏻 Kontainer profesional aplikasi Node.js menggunakan Docker 🔦 🤑 🕦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis bahan, terjemahan yang kami terbitkan hari ini, adalah seorang insinyur DevOps. Dia bilang dia harus menggunakan Docker . Secara khusus, platf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontainer profesional aplikasi Node.js menggunakan Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  Penulis bahan, terjemahan yang kami terbitkan hari ini, adalah seorang insinyur DevOps.  Dia bilang dia harus menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> .  Secara khusus, platform manajemen kontainer ini digunakan pada berbagai tahap siklus hidup aplikasi Node.js.  Menggunakan Docker, sebuah teknologi yang, baru-baru ini, sangat populer, memungkinkan Anda untuk mengoptimalkan proses pengembangan dan keluaran proyek Node.js dalam produksi. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="gambar"></a> <br><br>  Sekarang kami menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel</a> tentang Docker, yang dirancang untuk mereka yang ingin mempelajari platform ini untuk penggunaannya dalam berbagai situasi.  Materi yang sama berfokus terutama pada penggunaan profesional Docker dalam pengembangan Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu buruh pelabuhan?</font> </h2><br>  Docker adalah program yang dirancang untuk mengatur virtualisasi di tingkat sistem operasi (containerisasi).  Di jantung wadah adalah gambar berlapis.  Sederhananya, Docker adalah alat yang memungkinkan Anda untuk membuat, menyebarkan, dan menjalankan aplikasi menggunakan wadah yang tidak tergantung pada sistem operasi yang digunakannya.  Wadah tersebut mencakup gambar OS dasar yang diperlukan agar aplikasi berfungsi, perpustakaan tempat aplikasi ini bergantung, dan aplikasi ini sendiri.  Jika beberapa kontainer berjalan di komputer yang sama, maka mereka menggunakan sumber daya komputer ini bersama-sama.  Wadah Docker dapat mengemas proyek yang dibuat menggunakan berbagai teknologi.  Kami tertarik pada proyek berdasarkan Node.js. <br><br><h2>  <font color="#3AC1EF">Membuat proyek Node.js</font> </h2><br>  Sebelum kita mengemas proyek Node.js ke dalam wadah Docker, kita perlu membuat proyek ini.  Ayo lakukan.  Ini adalah file <code>package.json</code> dari proyek ini: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Untuk menginstal dependensi proyek, jalankan perintah <code>npm install</code> .  Dalam menjalankan perintah ini, antara lain, file <code>package-lock.json</code> akan dibuat.  Sekarang buat file <code>index.js</code> , yang akan berisi kode proyek: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Seperti yang Anda lihat, di sini kami menggambarkan server sederhana yang mengembalikan beberapa teks sebagai tanggapan terhadap permintaan untuk itu. <br><br><h2>  <font color="#3AC1EF">Buat Dockerfile</font> </h2><br>  Sekarang setelah aplikasi siap, mari kita bicara tentang cara mengemasnya ke dalam wadah Docker.  Yaitu, itu akan tentang apa yang paling penting dari setiap proyek berbasis Docker, tentang Dockerfile. <br><br>  Dockerfile adalah file teks yang berisi instruksi untuk membuat gambar Docker untuk suatu aplikasi.  Instruksi dalam file ini, jika tidak masuk ke dalam perincian, menjelaskan pembuatan lapisan dari sistem file multi-level, yang memiliki segala yang diperlukan suatu aplikasi untuk bekerja.  Platform Docker dapat menyimpan cache lapisan gambar, yang, ketika menggunakan kembali lapisan yang sudah ada dalam cache, mempercepat proses pembuatan gambar. <br><br>  Dalam pemrograman berorientasi objek, ada yang namanya kelas.  Kelas digunakan untuk membuat objek.  Di Docker, gambar dapat dibandingkan dengan kelas, dan wadah dapat dibandingkan dengan contoh gambar, yaitu, dengan objek.  Pertimbangkan proses pembuatan Dockerfile, yang akan membantu kami mengetahui hal ini. <br><br>  Buat Dockerfile kosong: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Karena kita akan membangun sebuah wadah untuk aplikasi Node.js, hal pertama yang perlu kita masukkan ke dalam wadah adalah gambar Node dasar, yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Hub</a> .  Kami akan menggunakan versi LTS dari Node.js.  Akibatnya, pernyataan pertama Dockerfile kami adalah pernyataan berikut: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Setelah itu, buat direktori untuk kode kita.  Pada saat yang sama, berkat instruksi <code>ARG</code> digunakan di sini, kita dapat, jika perlu, menentukan nama direktori aplikasi selain <code>/app</code> selama perakitan wadah.  Detail tentang manual ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Karena kita menggunakan gambar Node, platform Node.js dan npm akan sudah diinstal di dalamnya.  Menggunakan apa yang sudah ada dalam gambar, Anda dapat mengatur instalasi dependensi proyek.  Menggunakan flag <code>NODE_ENV</code> (atau jika <code>NODE_ENV</code> lingkungan <code>NODE_ENV</code> diatur ke <code>production</code> ) npm tidak akan menginstal modul yang terdaftar di bagian <code>devDependencies</code> pada file <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Di sini kita menyalin file <code>package*.json</code> ke gambar, alih-alih, misalnya menyalin semua file proyek.  Kami melakukan hal itu karena petunjuk Dockerfile <code>RUN</code> , <code>COPY</code> dan <code>ADD</code> membuat lapisan gambar tambahan, sehingga Anda dapat menggunakan fitur caching dari lapisan platform Docker.  Dengan pendekatan ini, saat berikutnya kami mengumpulkan gambar yang serupa, Docker akan mencari tahu apakah mungkin untuk menggunakan kembali lapisan gambar yang sudah ada dalam cache, dan jika demikian, itu akan mengambil keuntungan dari apa yang sudah ada, daripada membuat yang baru. lapisan.  Ini memungkinkan Anda untuk secara serius menghemat waktu ketika merakit lapisan-lapisan selama mengerjakan proyek-proyek besar, yang mencakup banyak modul npm. <br><br>  Sekarang salin file proyek ke direktori kerja saat ini.  Di sini kita tidak akan menggunakan instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ADD</a> , tetapi instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">COPY</a> .  Bahkan, dalam banyak kasus dianjurkan untuk memberikan preferensi pada instruksi <code>COPY</code> . <br><br>  Instruksi <code>ADD</code> , dibandingkan dengan <code>COPY</code> , memiliki beberapa fitur, yang, bagaimanapun, tidak selalu diperlukan.  Misalnya, kita berbicara tentang opsi untuk membongkar arsip .tar dan mengunduh file dengan URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Wadah buruh pelabuhan adalah lingkungan yang terisolasi.  Ini berarti bahwa ketika kita meluncurkan aplikasi dalam wadah, kita tidak akan dapat berinteraksi dengannya secara langsung tanpa membuka port yang didengarkan aplikasi ini.  Untuk memberi tahu Docker bahwa ada aplikasi dalam wadah tertentu yang mendengarkan pada port tertentu, Anda dapat menggunakan instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  Sampai saat ini, kami, menggunakan Dockerfile, telah menggambarkan gambar yang akan berisi aplikasi dan segala yang diperlukan untuk berhasil diluncurkan.  Sekarang tambahkan instruksi ke file yang memungkinkan Anda untuk memulai aplikasi.  Ini adalah instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMD</a> .  Ini memungkinkan Anda untuk menentukan perintah tertentu dengan parameter yang akan dieksekusi ketika wadah mulai, dan, jika perlu, dapat ditimpa oleh alat baris perintah. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  Inilah yang akan terlihat seperti Dockerfile: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Perakitan gambar</font> </h2><br>  Kami telah menyiapkan file Dockerfile yang berisi instruksi untuk membangun gambar, atas dasar mana wadah dengan aplikasi yang sedang berjalan akan dibuat.  Rakit gambar dengan mengeksekusi perintah dari formulir berikut: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  Dalam kasus kami, akan terlihat seperti ini: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  Dockerfile memiliki pernyataan <code>ARG</code> yang menjelaskan argumen <code>APP_DIR</code> .  Di sini kita mengatur maknanya.  Jika ini tidak dilakukan, maka akan mengambil nilai yang ditugaskan padanya dalam file, yaitu - <code>app</code> . <br><br>  Setelah menyusun gambar, periksa apakah Docker melihatnya.  Untuk melakukan ini, jalankan perintah berikut: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  Menanggapi perintah ini, kira-kira berikut ini harus menjadi output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Gambar Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Peluncuran Gambar</font> </h2><br>  Setelah kita merakit gambar Docker, kita dapat menjalankannya, yaitu membuat instance darinya, diwakili oleh wadah yang berfungsi.  Untuk melakukan ini, gunakan perintah seperti ini: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  Dalam kasus kami, akan terlihat seperti ini: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Kami akan meminta sistem untuk informasi tentang wadah yang bekerja menggunakan perintah ini: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  Menanggapi hal ini, sistem harus menampilkan sesuatu seperti berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Wadah Docker</font></i> <br><br>  Sejauh ini, semuanya berjalan seperti yang diharapkan, meskipun kami belum mencoba mengakses aplikasi yang berjalan di wadah.  Yaitu, wadah kami, bernama <code>node-app</code> , mendengarkan pada port <code>8000</code> .  Untuk mencoba mengaksesnya, Anda dapat membuka browser dan masuk ke <code>localhost:8000</code> .  Selain itu, untuk memeriksa kesehatan wadah, Anda dapat menggunakan perintah berikut: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Jika wadah benar-benar berfungsi, maka sesuatu seperti yang ditunjukkan pada gambar berikut akan dikembalikan sebagai respons terhadap perintah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Hasil Pemeriksaan Kesehatan Kontainer</font></i> <br><br>  Atas dasar gambar yang sama, misalnya, atas dasar yang baru saja dibuat, dimungkinkan untuk membuat banyak wadah.  Selain itu, Anda dapat mengirim gambar kami ke registri Docker Hub, yang akan memungkinkan pengembang lain mengunggah gambar kami dan meluncurkan wadah yang sesuai di rumah.  Pendekatan ini menyederhanakan bekerja dengan proyek. <br><br><h2>  <font color="#3AC1EF">Rekomendasi</font> </h2><br>  Berikut adalah beberapa saran yang layak dipertimbangkan untuk memanfaatkan kekuatan Docker dan membuat gambar seringkas mungkin. <br><br><h3>  <font color="#3AC1EF">▍1.</font>  <font color="#3AC1EF">Selalu buat file .dockerignore</font> </h3><br>  Dalam folder proyek yang Anda rencanakan untuk ditempatkan di wadah, Anda selalu perlu membuat file <code>.dockerignore</code> .  Ini memungkinkan Anda untuk mengabaikan file dan folder yang tidak diperlukan saat membangun gambar.  Dengan pendekatan ini, kita dapat mengurangi apa yang disebut konteks pembangunan, yang akan memungkinkan kita untuk dengan cepat mengumpulkan gambar dan mengurangi ukurannya.  File ini mendukung templat nama file, dalam hal ini mirip dengan file <code>.gitignore</code> .  Disarankan untuk menambahkan perintah ke <code>.dockerignore</code> karena Docker akan mengabaikan folder <code>/.git</code> , karena folder ini biasanya berisi materi besar (terutama selama pengembangan proyek) dan menambahkannya ke gambar menyebabkan peningkatan ukurannya.  Selain itu, menyalin folder ini ke dalam gambar tidak masuk akal. <br><br><h3>  <font color="#3AC1EF">▍2.</font>  <font color="#3AC1EF">Gunakan proses perakitan gambar multi-tahap</font> </h3><br>  Pertimbangkan contoh ketika kita mengumpulkan proyek untuk organisasi tertentu.  Proyek ini menggunakan banyak paket npm, dan masing-masing paket tersebut dapat menginstal paket tambahan yang bergantung padanya.  Melakukan semua operasi ini mengarah ke waktu tambahan yang dihabiskan dalam proses perakitan gambar (meskipun ini, berkat kemampuan caching Docker, bukan masalah besar).  Lebih buruk lagi, gambar yang dihasilkan mengandung dependensi dari proyek tertentu cukup besar.  Di sini, jika kita berbicara tentang proyek front-end, kita dapat mengingat bahwa proyek seperti itu biasanya diproses menggunakan bundler seperti webpack, yang memungkinkan untuk dengan mudah mengemas semua yang dibutuhkan aplikasi dalam paket penjualan.  Akibatnya, file paket npm untuk proyek semacam itu tidak diperlukan.  Dan ini berarti bahwa kita dapat menyingkirkan file-file tersebut setelah membangun proyek menggunakan paket web yang sama. <br><br>  Berbekal ide ini, coba lakukan ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Namun pendekatan semacam itu tidak cocok untuk kita.  Seperti yang telah kami katakan, instruksi <code>RUN</code> , <code>ADD</code> dan <code>COPY</code> membuat lapisan yang di-cache oleh Docker, jadi kita perlu menemukan cara untuk menangani instalasi dependensi, membangun proyek, dan kemudian menghapus file yang tidak perlu dengan satu perintah.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  Dalam contoh ini, hanya ada satu pernyataan <code>RUN</code> yang menginstal dependensi, <code>node_modules</code> proyek, dan menghapus folder <code>node_modules</code> .  Ini mengarah pada fakta bahwa ukuran gambar tidak akan sebesar ukuran gambar yang mencakup folder <code>node_modules</code> .  Kami menggunakan file dari folder ini hanya selama proses pembangunan proyek, dan kemudian menghapusnya.  Benar, pendekatan ini buruk karena butuh banyak waktu untuk menginstal dependensi npm.  Anda dapat menghilangkan kelemahan ini menggunakan teknologi perakitan multi-tahap gambar. <br><br>  Bayangkan kami sedang mengerjakan proyek frontend yang memiliki banyak dependensi, dan kami menggunakan webpack untuk membangun proyek ini.  Dengan pendekatan ini, kita dapat, demi mengurangi ukuran gambar, memanfaatkan kemampuan Docker untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perakitan gambar multi-tahap</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Dengan pendekatan ini, gambar yang dihasilkan jauh lebih kecil dari gambar sebelumnya, dan kami juga menggunakan <code>node:alpine</code> gambar <code>node:alpine</code> , yang itu sendiri sangat kecil.  Dan di sini adalah perbandingan sepasang gambar, di mana dapat dilihat bahwa gambar <code>node:alpine</code> jauh lebih kecil daripada gambar <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Membandingkan gambar dari repositori Node</font></i> <br><br><h3>  <font color="#3AC1EF">▍3.</font>  <font color="#3AC1EF">Gunakan Docker Cache</font> </h3><br>  Berusaha keras untuk menggunakan kemampuan cache Docker untuk membangun gambar Anda.  Kami sudah memperhatikan fitur ini ketika bekerja dengan file yang diakses oleh <code>package*.json</code> nama <code>package*.json</code> .  Ini mengurangi waktu pembuatan gambar.  Namun kesempatan ini jangan digunakan dengan gegabah. <br><br>  Misalkan kita jelaskan di Dockerfile menginstal paket dalam gambar yang dibuat dari gambar dasar <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Ketika sistem akan memproses file ini, jika ada banyak paket yang diinstal, operasi pembaruan dan instalasi akan memakan banyak waktu.  Untuk memperbaiki situasi, kami memutuskan untuk mengambil keuntungan dari kemampuan caching lapisan Docker dan menulis ulang Dockerfile sebagai berikut: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Sekarang, ketika merakit gambar untuk pertama kalinya, semuanya berjalan sebagaimana mestinya, karena cache belum terbentuk.  Bayangkan sekarang bahwa kita perlu menginstal paket lain, <code>package-2</code> .  Untuk melakukan ini, kami menulis ulang file: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  Sebagai hasil dari perintah seperti itu, <code>package-2</code> tidak akan diinstal atau diperbarui.  Mengapa  Faktanya adalah bahwa ketika menjalankan instruksi <code>RUN apt-get update</code> , Docker tidak melihat perbedaan antara instruksi ini dan instruksi yang dieksekusi sebelumnya, sebagai akibatnya, ia mengambil data dari cache.  Dan data ini sudah usang.  Saat memproses instruksi <code>RUN apt-get install</code> sistem menjalankannya, untuk itu, itu tidak terlihat seperti instruksi serupa di Dockerfile sebelumnya, tetapi selama instalasi, kesalahan mungkin terjadi atau versi paket yang lama akan diinstal.  Hasilnya, ternyata perintah <code>update</code> dan <code>install</code> harus dijalankan dalam instruksi <code>RUN</code> sama, seperti yang dilakukan pada contoh pertama.  Caching adalah fitur yang hebat, tetapi penggunaan sembrono dari fitur ini dapat menyebabkan masalah. <br><br><h3>  <font color="#3AC1EF">▍4.</font>  <font color="#3AC1EF">Minimalkan jumlah lapisan gambar</font> </h3><br>  Disarankan, jika memungkinkan, berusaha untuk meminimalkan jumlah lapisan gambar, karena setiap lapisan adalah sistem file gambar Docker, yang berarti bahwa semakin kecil lapisan dalam gambar, semakin kompak akan.  Saat menggunakan proses multi-tahap perakitan gambar, pengurangan jumlah lapisan dalam gambar dan penurunan ukuran gambar tercapai. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami melihat proses pengemasan aplikasi Node.js dalam wadah Docker dan bekerja dengan wadah tersebut.  Selain itu, kami membuat beberapa rekomendasi yang, omong-omong, dapat digunakan tidak hanya ketika membuat wadah untuk proyek Node.js. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda menggunakan Docker secara profesional saat bekerja dengan proyek Node.js, silakan bagikan rekomendasi tentang penggunaan efektif sistem ini dengan pemula. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440656/">https://habr.com/ru/post/id440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440646/index.html">Frontend Weekly Digest (11 - 17 Feb 2019)</a></li>
<li><a href="../id440648/index.html">Tinjauan hukum Rusia di bidang aksesibilitas web</a></li>
<li><a href="../id440650/index.html">Bagaimana kesadaran bekerja: kesimpulan dari buku Alexander Nevzorov</a></li>
<li><a href="../id440652/index.html">Video yang dihitung dalam 755 megapiksel: plenoptik kemarin, hari ini dan besok</a></li>
<li><a href="../id440654/index.html">Belajar Python: modul argparse</a></li>
<li><a href="../id440658/index.html">Menjelajahi Docker, Bagian 4: Mengurangi Ukuran Gambar dan Mempercepat Perakitan Mereka</a></li>
<li><a href="../id440660/index.html">Learning Docker, Bagian 5: Perintah</a></li>
<li><a href="../id440662/index.html">Bereaksi Tutorial Bagian 18: Fase Keenam Bekerja pada Aplikasi TODO</a></li>
<li><a href="../id440666/index.html">Klasifikasi gambar tulisan tangan. Laporkan dalam Yandex</a></li>
<li><a href="../id440670/index.html">Bank Sentral menerbitkan rekomendasi tentang perlindungan kriptografi EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>