<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öñÔ∏è üí™ üò¨ Rekayasa Terbalik Klien Dropbox ‚è™ üë®üèº‚Äçüî¨ üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR. Artikel tersebut berbicara tentang pengembangan terbalik klien Dropbox, meretas mekanisme kebingungan dan dekompilasi klien dengan Python, ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekayasa Terbalik Klien Dropbox</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452276/">  <i>TL; DR.</i>  <i>Artikel tersebut berbicara tentang pengembangan terbalik klien Dropbox, meretas mekanisme kebingungan dan dekompilasi klien dengan Python, serta mengubah program untuk mengaktifkan fungsi debugging yang tersembunyi dalam mode normal.</i>  <i>Jika Anda hanya tertarik pada kode dan instruksi yang sesuai, gulir sampai akhir.</i>  <i>Pada saat penulisan ini, kode ini kompatibel dengan versi Dropbox terbaru berdasarkan penerjemah CPython 3.6.</i> <br><br><h3>  Pendahuluan </h3><br>  Dropbox langsung membuat saya terpesona.  Konsepnya masih tampak sederhana.  Ini foldernya.  Letakkan file di sana.  Ini disinkronkan.  Pergi ke perangkat lain.  Disinkronkan lagi.  Folder dan file sekarang juga muncul di sana! <br><br>  Jumlah pekerjaan latar belakang yang tersembunyi benar-benar menakjubkan.  Pertama, semua masalah yang harus Anda tangani saat membuat dan memelihara aplikasi lintas platform untuk sistem operasi desktop utama (OS X, Linux, Windows) tidak hilang.  Tambahkan juga dukungan berbagai browser web, berbagai sistem operasi seluler.  Dan kita hanya berbicara tentang sisi klien.  Saya juga tertarik pada backend Dropbox, yang memungkinkan saya mencapai skalabilitas dan latensi rendah seperti itu dengan beban kerja sangat besar yang diciptakan oleh setengah miliar pengguna. <br><a name="habracut"></a><br>  Karena alasan inilah saya selalu suka menonton apa yang dilakukan Dropbox di bawah tenda dan bagaimana itu berkembang selama bertahun-tahun.  Sekitar delapan tahun yang lalu, saya pertama kali mencoba mencari tahu bagaimana sebenarnya klien Dropbox bekerja ketika saya melihat siaran lalu lintas yang tidak diketahui saat berada di hotel.  Investigasi menunjukkan bahwa ini adalah bagian dari fitur Dropbox yang disebut LanSync, yang memungkinkan Anda untuk menyinkronkan lebih cepat jika host Dropbox di LAN yang sama memiliki akses ke file yang sama.  Namun, protokolnya tidak didokumentasikan, dan saya ingin tahu lebih banyak.  Oleh karena itu, saya memutuskan untuk melihat lebih detail, dan sebagai hasilnya saya melakukan rekayasa balik dari hampir seluruh program.  Penelitian ini tidak pernah dipublikasikan, meskipun saya terkadang berbagi catatan dengan beberapa orang. <br><br>  Ketika kami membuka Anvil Ventures, Chris dan saya menghargai sejumlah alat untuk penyimpanan, berbagi, dan kolaborasi dokumen.  Salah satunya, jelas, adalah Dropbox, dan bagi saya ini adalah alasan lain untuk menggali studi lama dan memeriksanya pada versi klien saat ini. <br><br><h3>  Dekripsi dan deobfusiasi </h3><br>  Pertama, saya mengunduh klien untuk Linux dan dengan cepat mengetahui bahwa itu ditulis dengan Python.  Karena lisensi Python cukup permisif, mudah bagi orang untuk memodifikasi dan mendistribusikan interpreter Python bersama dengan dependensi lain seperti perangkat lunak komersial.  Kemudian saya mulai melakukan reverse engineering untuk memahami cara kerja klien. <br><br>  Pada saat itu, file bytecode berada dalam file ZIP yang dikombinasikan dengan biner yang dapat dieksekusi.  Biner utama hanyalah interpreter Python yang dimodifikasi yang diambil dengan menangkap mekanisme impor Python.  Setiap panggilan impor berikutnya dialihkan ke biner ini dengan parsing file ZIP.  Tentu saja, mudah untuk mengekstrak ZIP ini dari biner.  Misalnya, alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">binwalk yang</a> berguna mengambilnya dengan semua file .pyc yang dikompilasi dengan byte. <br><br>  Kemudian saya tidak dapat memecahkan enkripsi untuk file .pyc, tetapi pada akhirnya saya mengambil objek umum dari perpustakaan Python standar dan mengkompilasi ulang, menyuntikkan backdoor di dalam.  Sekarang klien Dropbox sedang memuat objek ini, saya bisa dengan mudah mengeksekusi kode Python sewenang-wenang dalam juru bahasa yang berfungsi.  Meskipun saya menemukan ini sendiri, metode yang sama digunakan oleh Florian Leda dan Nicolas Raff dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> di Hack.lu pada 2012. <br><br>  Kemampuan untuk menjelajahi dan memanipulasi kode yang sedang berjalan di Dropbox telah mengungkapkan banyak hal.  Kode menggunakan beberapa trik perlindungan untuk membuatnya sulit untuk membuang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek kode</a> .  Misalnya, dalam juru bahasa CPython biasa, mudah untuk memulihkan bytecode yang dikompilasi mewakili suatu fungsi.  Contoh sederhana: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i * i ... &gt;&gt;&gt; f.__code__ &lt;code object f at <span class="hljs-number"><span class="hljs-number">0x109deb540</span></span>, file <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &gt;&gt;&gt; f.__code__.co_code <span class="hljs-string"><span class="hljs-string">b'|\x00|\x00\x14\x00S\x00'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dis &gt;&gt;&gt; dis.dis(f) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (i) <span class="hljs-number"><span class="hljs-number">2</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (i) <span class="hljs-number"><span class="hljs-number">4</span></span> BINARY_MULTIPLY <span class="hljs-number"><span class="hljs-number">6</span></span> RETURN_VALUE &gt;&gt;&gt;</code> </pre> <br>  Tetapi dalam versi <i>Objek / codeobject.c yang dikompilasi,</i> properti <i>co_code</i> <code>co_code</code> dihapus dari daftar terbuka.  Daftar anggota ini biasanya terlihat seperti ini: <br><br><pre> <code class="python hljs"> static PyMemberDef code_memberlist[] = { ... {<span class="hljs-string"><span class="hljs-string">"co_flags"</span></span>, T_INT, OFF(co_flags), READONLY}, {<span class="hljs-string"><span class="hljs-string">"co_code"</span></span>, T_OBJECT, OFF(co_code), READONLY}, {<span class="hljs-string"><span class="hljs-string">"co_consts"</span></span>, T_OBJECT, OFF(co_consts), READONLY}, ... };</code> </pre> <br>  Hilangnya properti <code>co_code</code> membuatnya tidak mungkin untuk membuang objek kode ini. <br><br>  Selain itu, perpustakaan lain, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disassembler</a> Python standar, telah dihapus.  Pada akhirnya, saya masih berhasil membuang objek kode ke file, tetapi saya masih tidak bisa mendekompilasi mereka.  Butuh beberapa saat sebelum saya menyadari bahwa opcodes yang digunakan oleh penerjemah Dropbox tidak cocok dengan opcodes standar Python.  Dengan demikian, perlu untuk memahami opcodes baru untuk menulis ulang objek kode kembali ke bytecode Python asli. <br><br>  Salah satu opsi adalah memetakan ulang opcode.  Sejauh yang saya tahu, teknik ini dikembangkan oleh Rich Smith dan diperkenalkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Defcon 18</a> .  Dalam pembicaraan itu, ia juga menunjukkan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pyretic</a> untuk reverse-engineering bytecode Python dalam memori.  Tampaknya kode pyretic kurang didukung, dan alat ini menargetkan biner Python 2.x "lama".  Untuk berkenalan dengan teknik-teknik yang muncul dengan Rich, sangat disarankan untuk menonton penampilannya. <br><br>  Metode terjemahan opcode mengambil semua objek kode dari pustaka Python standar dan membandingkannya dengan objek yang diekstrak dari biner Dropbox.  Misalnya, objek kode dari <i>hashlib.pyc</i> atau <i>socket.pyc</i> , yang ada di pustaka standar.  Katakanlah, jika setiap kali opcode <code>0x43</code> sesuai dengan <code>0x21</code> 0x21 yang didobobekan, kita secara bertahap dapat membangun tabel terjemahan untuk menulis ulang objek kode.  Objek kode ini kemudian dapat dilewatkan melalui dekompiler Python.  Untuk melakukan dump, Anda masih membutuhkan penerjemah yang diperbaiki dengan objek <code>co_code</code> benar. <br><br>  Pilihan lain adalah meretas format serialisasi.  Dalam Python, serialisasi disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">marshaling</a> .  Deserialisasi file yang dikaburkan dengan cara biasa tidak berhasil.  Ketika merekayasa balik biner dalam IDA Pro, saya menemukan langkah dekripsi.  Sejauh yang saya tahu, yang pertama mempublikasikan sesuatu tentang hal ini adalah Hagen Fritch di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blognya</a> .  Di sana ia merujuk pada perubahan dalam versi baru Dropbox (ketika Dropbox beralih dari Python 2.5 ke Python 2.7).  Algoritma bekerja sebagai berikut: <br><br><ul><li>  Saat membongkar file pyc, header dibaca untuk menentukan versi marshaling.  Format ini tidak didokumentasikan, kecuali untuk implementasi CPython itu sendiri. <br></li><li>  Format mendefinisikan daftar jenis yang dikodekan di dalamnya.  Jenis <code>True</code> , <code>False</code> , <code>floats</code> , dll., Tetapi yang paling penting adalah jenis <code>code object</code> Python di atas, <code>code object</code> . <br></li><li>  Saat memuat <code>code object</code> , dua nilai tambahan pertama kali dibaca dari file input. <br></li><li>  Yang pertama adalah nilai <code>random</code> 32-bit. <br></li><li>  Yang kedua adalah nilai <code>length</code> 32-bit yang menunjukkan ukuran objek kode serial. <br></li><li>  Kemudian nilai <code>rand</code> dan <code>length</code> <code>rand</code> ke fungsi RNG sederhana yang menghasilkan <code>seed</code> . <br></li><li>  Benih ini dikirim ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vortex Mersenne</a> , yang menghasilkan empat nilai 32-bit. <br></li><li>  Dikombinasikan bersama, keempat nilai ini menyediakan kunci enkripsi untuk data berseri.  Algoritme enkripsi kemudian mendekripsi data menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiny Encryption Algorithm</a> . </li></ul><br>  Dalam kode saya, saya menulis prosedur unmarshaling Python dari awal.  Bagian yang mendekripsi objek kode terlihat seperti fragmen di bawah ini.  Perlu dicatat bahwa metode ini harus disebut secara rekursif.  Objek tingkat atas untuk file pyc adalah objek kode yang berisi objek kode, yang bisa berupa kelas, fungsi, atau lambda.  Pada gilirannya, mereka juga dapat berisi metode, fungsi, atau lambda.  Ini semua adalah objek kode di hierarki! <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> rand = self.r_long() length = self.r_long() seed = rng(rand, length) mt = MT19937(seed) key = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): key.append(mt.extract_number()) <span class="hljs-comment"><span class="hljs-comment"># take care of padding for size calculation sz = (length + 15) &amp; ~0xf words = sz / 4 # convert data to list of dwords buf = self._read(sz) data = list(struct.unpack("&lt;%dL" % words, buf)) # decrypt and convert back to stream of bytes data = tea.tea_decipher(data, key) data = struct.pack("&lt;%dL" % words, *data)</span></span></code> </pre> <br>  Kemampuan untuk mendekripsi objek kode berarti bahwa setelah deserializing prosedur, Anda perlu menulis ulang kode byte yang sebenarnya.  Objek kode berisi informasi tentang nomor baris, konstanta, dan informasi lainnya.  <code>co_code</code> sebenarnya ada di objek <code>co_code</code> .  Ketika kami membangun tabel terjemahan opcode, kami cukup mengganti nilai Dropbox yang dikaburkan dengan standar Python 3.6. <br><br>  Sekarang objek kode berada dalam format Python 3.6 biasa, dan mereka dapat diteruskan ke dekompiler.  Kualitas dekompiler Python telah tumbuh secara signifikan berkat proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uncompyle6</a> R. Bernstein.  Dekompilasi memberikan hasil yang cukup baik, dan saya dapat menggabungkan semuanya dalam alat yang mendekompilasi versi klien Dropbox saat ini dengan kemampuan terbaiknya. <br><br>  Jika Anda mengkloning <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> ini dan mengikuti instruksi, hasilnya akan seperti ini: <br><br><pre>  ...
     __main__ - INFO - Dropbox / klien / fitur / browse_search / __ init __. pyc yang berhasil didekompilasi
     __main__ - INFO - Mengurai sandi, menambal, dan mendekompilasi _bootstrap_overrides.pyc
     __main__ - INFO - Berhasil mendekompilasi _bootstrap_overrides.pyc
     __main__ - INFO - Diproses 3713 file (3591 berhasil didekompilasi, 122 gagal)
     opcodemap - PERINGATAN - JANGAN menulis peta opcode karena force overwrite tidak diatur </pre><br>  Ini berarti bahwa Anda sekarang memiliki direktori <code>out/</code> dengan versi kode sumber Dropbox yang didekompilasi. <br><br><h3>  Mengaktifkan Pelacakan Dropbox </h3><br>  Di open source, saya mulai mencari sesuatu yang menarik, dan fragmen berikut menarik perhatian saya.  Penangan jejak di <code>out/dropbox/client/high_trace.py</code> diinstal hanya jika unit tidak beku atau kunci ajaib atau cookie yang membatasi fungsi tidak diatur dalam baris <code>1430</code> . <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1424</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install_global_trace_handlers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags=None, args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">1425</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> _tracing_initialized <span class="hljs-number"><span class="hljs-number">1426</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _tracing_initialized: <span class="hljs-number"><span class="hljs-number">1427</span></span> TRACE(<span class="hljs-string"><span class="hljs-string">'!! Already enabled tracing system'</span></span>) <span class="hljs-number"><span class="hljs-number">1428</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1429</span></span> _tracing_initialized = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">1430</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> build_number.is_frozen() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> magic_trace_key_is_set() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> limited_support_cookie_is_set(): <span class="hljs-number"><span class="hljs-number">1431</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">'DBNOLOCALTRACE'</span></span>): <span class="hljs-number"><span class="hljs-number">1432</span></span> add_trace_handler(db_thread(LtraceThread)().trace) <span class="hljs-number"><span class="hljs-number">1433</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">'DBTRACEFILE'</span></span>): <span class="hljs-number"><span class="hljs-number">1434</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Menyebutkan build beku mengacu pada build debug internal Dropbox.  Dan sedikit lebih tinggi di file yang sama Anda dapat menemukan baris seperti itu: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_valid_time_limited_cookie</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cookie)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">275</span></span> t_when = int(cookie[:<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>) ^ <span class="hljs-number"><span class="hljs-number">1686035233</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">278</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">279</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> abs(time.time() - t_when) &lt; SECONDS_PER_DAY * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> md5(make_bytes(cookie[:<span class="hljs-number"><span class="hljs-number">8</span></span>]) + <span class="hljs-string"><span class="hljs-string">b'traceme'</span></span>).hexdigest()[:<span class="hljs-number"><span class="hljs-number">6</span></span>] == cookie[<span class="hljs-number"><span class="hljs-number">8</span></span>:]: <span class="hljs-number"><span class="hljs-number">280</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">281</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception: <span class="hljs-number"><span class="hljs-number">282</span></span> report_exception() <span class="hljs-number"><span class="hljs-number">283</span></span> <span class="hljs-number"><span class="hljs-number">284</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">285</span></span> <span class="hljs-number"><span class="hljs-number">286</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limited_support_cookie_is_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">288</span></span> dbdev = os.getenv(<span class="hljs-string"><span class="hljs-string">'DBDEV'</span></span>) <span class="hljs-number"><span class="hljs-number">289</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dbdev <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_valid_time_limited_cookie(dbdev) build_number/environment.py</code> </pre> <br>  Seperti yang Anda lihat dari metode <code>limited_support_cookie_is_set</code> pada baris <code>287</code> , pelacakan hanya diaktifkan jika variabel lingkungan bernama <code>DBDEV</code> diatur dengan benar ke cookie dengan masa hidup terbatas.  Yah, itu menarik!  Dan sekarang kita tahu cara menghasilkan cookie dengan batas waktu tersebut.  Menilai dari namanya, insinyur Dropbox dapat menghasilkan cookie semacam itu, dan kemudian mengaktifkan penelusuran sementara untuk beberapa kasus saat diperlukan untuk mendukung pelanggan.  Setelah memulai ulang Dropbox atau menyalakan kembali komputer, bahkan jika cookie yang ditentukan masih ada, secara otomatis akan kedaluwarsa.  Saya kira ini harus mencegah, misalnya, penurunan kinerja karena penelusuran terus-menerus.  Ini juga menyulitkan untuk melakukan rekayasa ulang Dropbox. <br><br>  Namun, skrip kecil hanya dapat secara konstan menghasilkan dan mengatur cookie ini.  Sesuatu seperti ini: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 def output_env(name, value): print("%s=%s; export %s" % (name, value, name)) def generate_time_cookie(): t = int(time.time()) c = 1686035233 s = "%.8x" % (t ^ c) h = md5(s.encode("utf-8?") + b"traceme").hexdigest() ret = "%s%s" % (s, h[:6]) return ret c = generate_time_cookie() output_env("DBDEV", c)</span></span></code> </pre> <br>  Kemudian cookie berbasis waktu dibuat: <br><br><pre> <code class="python hljs"> $ python3 setenv.py DBDEV=<span class="hljs-number"><span class="hljs-number">38</span></span>b28b3f349714; export DBDEV;</code> </pre> <br>  Kemudian muat dengan benar output skrip ini ke lingkungan dan jalankan klien Dropbox. <br><br><pre> <code class="python hljs"> $ eval `python3 setenv.py` $ ~/.dropbox-dist/dropbox-lnx_64<span class="hljs-number"><span class="hljs-number">-71.4</span></span><span class="hljs-number"><span class="hljs-number">.108</span></span>/dropbox</code> </pre> <br>  Ini termasuk jejak hasil, dengan format warna-warni dan semua itu.  Itu terlihat seperti klien yang tidak terdaftar ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e83/d0a/a4f/e83d0aa4f475709108cb1cfc0cb16d74.png"><br><br><h3>  Terapkan Kode Baru </h3><br>  Semua ini sedikit lucu.  Mempelajari kode yang didekompilasi lebih lanjut, kami mencari <code>out/build_number/environment.pyc</code> .  Ada fungsi yang memeriksa apakah kunci ajaib tertentu diinstal.  Kunci ini tidak dikodekan dalam kode, tetapi dibandingkan dengan hash SHA-256.  Berikut ini cuplikan yang sesuai. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib, os <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Optional, Text <span class="hljs-number"><span class="hljs-number">3</span></span> _MAGIC_TRACE_KEY_IS_SET = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magic_trace_key_is_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> _MAGIC_TRACE_KEY_IS_SET <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _MAGIC_TRACE_KEY_IS_SET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> dbdev = os.getenv(<span class="hljs-string"><span class="hljs-string">'DBDEV'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(dbdev, Text): <span class="hljs-number"><span class="hljs-number">10</span></span> bytes_dbdev = dbdev.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> bytes_dbdev = dbdev <span class="hljs-number"><span class="hljs-number">13</span></span> dbdev_hash = hashlib.sha256(bytes_dbdev).hexdigest() <span class="hljs-number"><span class="hljs-number">14</span></span> _MAGIC_TRACE_KEY_IS_SET = dbdev_hash == <span class="hljs-string"><span class="hljs-string">'e27eae61e774b19f4053361e523c771a92e838026da42c60e6b097d9cb2bc825'</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _MAGIC_TRACE_KEY_IS_SET</code> </pre> <br>  Metode ini dipanggil beberapa kali dari tempat yang berbeda dalam kode untuk memeriksa apakah kunci jejak ajaib diatur.  Saya mencoba untuk memecahkan hash SHA-256 dengan kekuatan kasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John the Ripper</a> , tetapi kekuatan kasar sederhana terlalu lama, dan saya tidak dapat mengurangi jumlah opsi karena tidak ada dugaan tentang konten.  Di Dropbox, pengembang dapat memiliki kunci pengembangan kode-keras tertentu, yang mereka pasang jika perlu, mengaktifkan mode "kunci ajaib" klien untuk pelacakan. <br><br>  Ini mengganggu saya karena saya ingin menemukan cara cepat dan mudah untuk meluncurkan Dropbox dengan set kunci ini untuk dilacak.  Jadi saya menulis prosedur marshaling yang menghasilkan file pyc terenkripsi sesuai dengan enkripsi Dropbox.  Jadi, saya bisa memasukkan kode saya sendiri atau cukup mengganti hash di atas.  Kode ini di repositori Github ada di file <code>patchzip.py</code> .  Akibatnya, hash digantikan oleh hash SHA-256 dari <code>ANVILVENTURES</code> .  Kemudian objek kode dienkripsi ulang dan ditempatkan di zip, di mana semua kode yang dikaburkan disimpan.  Ini memungkinkan Anda melakukan hal berikut: <br><br><pre>  $ DBDEV = ANVILVENTURES;  ekspor DBDEV;
     $ ~ / .dropbox-dist / dropbox-lnx_64-71.4.108 / dropbox </pre><br>  Sekarang semua fungsi debugging ditampilkan ketika Anda mengklik kanan ikon Dropbox di baki sistem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/c68/385/619c6838574ff7023a0dbdf27b880b2d.png"></div><br><br>  Mempelajari sumber-sumber yang didekompilasi lebih lanjut, di file <code>dropbox/webdebugger/server.py</code> saya menemukan metode yang disebut <code>is_enabled</code> .  Sepertinya sedang memeriksa apakah akan mengaktifkan debugger web bawaan.  Pertama-tama, dia memeriksa kunci ajaib yang disebutkan.  Karena kami mengganti hash SHA-256, kami cukup mengatur nilainya menjadi <code>ANVILVENTURES</code> .  Bagian kedua pada baris <code>201</code> dan <code>202</code> memeriksa untuk melihat apakah ada variabel lingkungan bernama <code>DB&lt;x&gt;</code> yang memiliki <code>x</code> sama dengan hash SHA-256.  Nilai lingkungan menetapkan cookie terbatas waktu, seperti yang telah kita lihat. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">191</span></span> @classmethod <span class="hljs-number"><span class="hljs-number">192</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">193</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cls._magic_key_set: <span class="hljs-number"><span class="hljs-number">194</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls._magic_key_set <span class="hljs-number"><span class="hljs-number">195</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">196</span></span> cls._magic_key_set = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">197</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> magic_trace_key_is_set(): <span class="hljs-number"><span class="hljs-number">198</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">199</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.environ: <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.startswith(<span class="hljs-string"><span class="hljs-string">'DB'</span></span>): <span class="hljs-number"><span class="hljs-number">201</span></span> var_hash = hashlib.sha256(make_bytes(var[<span class="hljs-number"><span class="hljs-number">2</span></span>:])).hexdigest() <span class="hljs-number"><span class="hljs-number">202</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var_hash == <span class="hljs-string"><span class="hljs-string">'5df50a9c69f00ac71f873d02ff14f3b86e39600312c0b603cbb76b8b8a433d3ff0757214287b25fb01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_valid_time_limited_cookie(os.environ[var]): <span class="hljs-number"><span class="hljs-number">203</span></span> cls._magic_key_set = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">204</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">205</span></span> <span class="hljs-number"><span class="hljs-number">206</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Menggunakan teknik yang persis sama, mengganti hash ini dengan SHA-256 yang digunakan sebelumnya, kita sekarang dapat mengubah skrip <code>setenv</code> ditulis sebelumnya menjadi seperti ini: <br><br><pre> <code class="python hljs"> $ cat setenv.py ‚Ä¶ c = generate_time_cookie() output_env(<span class="hljs-string"><span class="hljs-string">"DBDEV"</span></span>, <span class="hljs-string"><span class="hljs-string">"ANVILVENTURES"</span></span>) output_env(<span class="hljs-string"><span class="hljs-string">"DBANVILVENTURES"</span></span>, c) $ python3 setenv.py DBDEV=ANVILVENTURES; export DBDEV; DBANVILVENTURES=<span class="hljs-number"><span class="hljs-number">38</span></span>b285c4034a67; export DBANVILVENTURES $ eval `python3 setenv.py` $ ~/.dropbox-dist/dropbox-lnx_64<span class="hljs-number"><span class="hljs-number">-71.4</span></span><span class="hljs-number"><span class="hljs-number">.108</span></span>/dropbox</code> </pre> <br>  Seperti yang Anda lihat, setelah memulai klien, port TCP baru terbuka untuk mendengarkan.  Itu tidak akan terbuka jika variabel lingkungan tidak diatur dengan benar. <br><br><pre>  $ netstat --tcp -lnp |  grep dropbox
     tcp 0 0 127.0.0.1:4242 0.0.0.0:* DENGARKAN 1517 / dropbox </pre><br>  Lebih lanjut dalam kode, Anda dapat menemukan antarmuka WebSocket di file <code>webpdb.pyc</code> .  Ini adalah pembungkus untuk utilitas standar python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pdb</a> .  Akses ke antarmuka adalah melalui server HTTP pada port ini.  Mari kita instal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien websocket</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencobanya</a> : <br><br><pre>  $ websocat -t ws: //127.0.0.1: 4242 / pdb
     --Kembali--
    
     &gt; /home/gvb/dropbox/webdebugger/webpdb.pyc(101)run()-&gt;Tidak ada
     &gt;
     (Pdb) dari build_number.environment import magic_trace_key_is_set sebagai ms
     (Pdb) ms ()
     Benar </pre><br>  Dengan demikian, sekarang kami memiliki debugger lengkap di klien, yang dalam semua hal lain berfungsi seperti sebelumnya.  Kami dapat mengeksekusi kode Python sewenang-wenang, kami dapat mengaktifkan menu debug internal dan melacak fungsi.  Semua ini akan sangat membantu dalam analisis lebih lanjut dari klien Dropbox. <br><br><h3>  Kesimpulan </h3><br>  Kami dapat merekayasa balik Dropbox, menulis dekripsi kode, dan alat injeksi yang berfungsi dengan klien Dropbox saat ini berdasarkan Python 3.6.  Kami merekayasa balik fungsi tersembunyi individu dan mengaktifkannya.  Jelas, debugger akan sangat membantu dalam peretasan lebih lanjut.  Terutama dengan sejumlah file yang tidak dapat berhasil didekompilasi karena kelemahan dari decompyle6. <br><br><h3>  Kode </h3><br>  Kode dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Github</a> .  Instruksi untuk digunakan di sana.  Repositori ini juga berisi kode lama saya yang ditulis pada tahun 2011.  Seharusnya hanya berfungsi dengan beberapa modifikasi, asalkan seseorang memiliki versi Dropbox yang lebih lama berdasarkan Python 2.7. <br><br>  Repositori juga berisi skrip untuk menyiarkan opcode, instruksi untuk mengatur variabel lingkungan Dropbox dan semua yang diperlukan untuk mengubah file zip. <br><br><h3>  Ucapan Terima Kasih </h3><br>  Terima kasih kepada Brian dari Anvil Ventures karena meninjau kode saya.  Bekerja pada kode ini berlanjut selama beberapa tahun, dari waktu ke waktu saya memperbaruinya, memperkenalkan metode baru dan menulis ulang fragmen untuk mengembalikannya agar berfungsi pada versi baru Dropbox. <br><br>  Seperti disebutkan sebelumnya, titik awal yang bagus untuk aplikasi reverse engineering Python adalah karya Rich Smith, Florian Ledoux dan Nicolas Raff, serta Hagen Fritch.  Pekerjaan mereka sangat relevan untuk pengembangan sebaliknya dari salah satu aplikasi Python terbesar di dunia - klien Dropbox. <br><br>  Perlu dicatat bahwa dekompilasi kode Python telah sangat maju berkat proyek uncompyle6 yang dipimpin oleh R. Bernstein.  Dekompiler ini telah mengkompilasi dan meningkatkan banyak dekompiler Python yang berbeda. <br><br>  Juga banyak terima kasih kepada rekan-rekan Brian, Austin, Stefan dan Chris untuk meninjau artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452276/">https://habr.com/ru/post/id452276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452264/index.html">Bagaimana kami membuat situs untuk penghargaan mobil Mascot</a></li>
<li><a href="../id452266/index.html">Rak Tanpa Server</a></li>
<li><a href="../id452268/index.html">C # WPF analogue Window.ShowDialog () atau berurusan dengan DispatcherFrame</a></li>
<li><a href="../id452270/index.html">Dokumentasi Xamarin API sekarang tersedia untuk umum</a></li>
<li><a href="../id452272/index.html">Gadis di bawah air terjun</a></li>
<li><a href="../id452278/index.html">Bluetooth LE tidak begitu menakutkan, atau Bagaimana meningkatkan pengalaman pengguna tanpa banyak usaha</a></li>
<li><a href="../id452280/index.html">PostgreSQL 11: Evolusi partisi dari Postgres 9.6 ke Postgres 11</a></li>
<li><a href="../id452282/index.html">Dasar, Watson: Anda berintegrasi dengan Voximplant</a></li>
<li><a href="../id452284/index.html">Klasifikasi tutupan lahan menggunakan eo-learning. Bagian 1</a></li>
<li><a href="../id452288/index.html">Situasi: operator seluler AS dituduh melakukan perdagangan ilegal di geodata pelanggan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>