<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåΩ ‚¨õÔ∏è ‚úÖ Was ist striktes Aliasing und warum sollten wir uns darum k√ºmmern? Teil 2 ‚òÇÔ∏è ü§õ üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(ODER streiten tippen, vages Verhalten und Ausrichtung, oh mein Gott!) 

 Freunde, es bleibt nur sehr wenig Zeit, bis ein neuer Thread zum Kurs "C ++ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist striktes Aliasing und warum sollten wir uns darum k√ºmmern? Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/">  <b><i>(ODER streiten tippen, vages Verhalten und Ausrichtung, oh mein Gott!)</i></b> <br><br>  Freunde, es bleibt nur sehr wenig Zeit, bis ein neuer Thread zum Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer"</a> gestartet wird.  Es ist Zeit, eine √úbersetzung des zweiten Teils des Materials zu ver√∂ffentlichen, die erz√§hlt, was ein Wortspiel tippt. <br><br>  <b>Was ist eine Wortspiel-Typisierung?</b> <br><br>  Wir haben den Punkt erreicht, an dem wir uns fragen k√∂nnen, warum wir √ºberhaupt Pseudonyme brauchen k√∂nnten.  Normalerweise f√ºr die Implementierung von Wortspielen, tk.  h√§ufig verwendete Methoden versto√üen gegen strenge Aliasing-Regeln. <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br>  Manchmal m√∂chten wir das Typsystem umgehen und das Objekt als einen anderen Typ interpretieren.  Das Neuinterpretieren eines Speichersegments als ein anderer Typ wird als <i>Wortspiel bezeichnet</i> .  Das Eingeben von Wortspielen ist n√ºtzlich f√ºr Aufgaben, die Zugriff auf die Basisdarstellung eines Objekts erfordern, um die bereitgestellten Daten anzuzeigen, zu transportieren oder zu bearbeiten.  Typische Bereiche, in denen wir auf die Verwendung von Wortspielen sto√üen k√∂nnen: Compiler, Serialisierung, Netzwerkcode usw. <a name="habracut"></a><br>  Traditionell wurde dies erreicht, indem die Adresse des Objekts in einen Zeiger auf den Typ umgewandelt wurde, den wir interpretieren m√∂chten, und dann auf den Wert zugegriffen wurde, oder mit anderen Worten, unter Verwendung von Aliasen.  Zum Beispiel: <br><br><pre><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( ‚Äú%f\n‚Äù, *fp ) ;</code> </pre> <br>  Wie wir bereits gesehen haben, ist dies ein inakzeptables Aliasing, das zu undefiniertem Verhalten f√ºhrt.  Aber traditionell verwendeten Compiler keine strengen Aliasing-Regeln, und diese Art von Code funktionierte normalerweise nur, und Entwickler sind es leider gewohnt, solche Dinge zuzulassen.  Eine √ºbliche alternative Wortspielmethode ist die Vereinigung, die in C g√ºltig ist, in C ++ jedoch undefiniertes Verhalten verursacht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Beispiel</a> ): <br><br><pre> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n‚Äù, un ); // UB(undefined behaviour)  C++ ‚Äún is not the active member‚Äù</span></span></code> </pre> <br>  Dies ist in C ++ nicht akzeptabel, und einige glauben, dass Gewerkschaften ausschlie√ülich zur Implementierung von Variantentypen bestimmt sind, und halten die Verwendung von Gewerkschaften zum Eingeben von Wortspielen f√ºr einen Missbrauch. <br><br>  <b>Wie implementiere ich ein Wortspiel?</b> <br><br>  Die Standardmethode f√ºr die Eingabe von Wortspielen in C und C ++ ist memcpy.  Dies mag etwas kompliziert erscheinen, aber der Optimierer muss die Verwendung von memcpy f√ºr das Wortspiel erkennen, optimieren und ein Register erstellen, um die Bewegung zu registrieren.  Wenn wir beispielsweise wissen, dass int64_t dieselbe Gr√∂√üe wie double hat: <br><br><pre> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br>  Wir k√∂nnen <code>memcpy</code> : <br><br><pre> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //‚Ä¶</code> </pre><br>  Mit einem ausreichenden Optimierungsgrad generiert jeder anst√§ndige moderne Compiler Code, der mit der zuvor erw√§hnten Methode reinterpret_cast oder der Join-Methode identisch ist, um ein Wortspiel zu erhalten.  Wenn wir den generierten Code studieren, sehen wir, dass er nur das mov-Register verwendet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ). <br><br>  <b>Wortspielertypen und Arrays</b> <br><br>  Was aber, wenn wir das Wortspiel eines vorzeichenlosen char-Arrays in eine Reihe von vorzeichenlosen int implementieren und dann eine Operation f√ºr jeden vorzeichenlosen int-Wert ausf√ºhren m√∂chten?  Wir k√∂nnen memcpy verwenden, um ein nicht signiertes char-Array in einen tempor√§ren nicht gesungenen int-Typ umzuwandeln.  Das Optimierungsprogramm kann weiterhin alles √ºber memcpy anzeigen, sowohl das tempor√§re Objekt als auch die Kopie optimieren und direkt mit den zugrunde liegenden Daten arbeiten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ): <br><br><pre> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br>  In diesem Beispiel nehmen wir <code>char*p</code> , nehmen an, dass es auf mehrere Fragmente der <code>sizeof(unsigned int)</code> Daten zeigt, interpretieren jedes Datenfragment als <code>unsigned int</code> , berechnen <code>foo()</code> f√ºr jedes Fragment des Wortspiels, fassen es im Ergebnis zusammen und geben den Endwert zur√ºck . <br><br>  Die Assembly f√ºr den Schleifenk√∂rper zeigt, dass der Optimierer den K√∂rper in direkten Zugriff auf das <code>unsigned char</code> base-Array als <code>unsigned int</code> verwandelt und es direkt zu <code>eax</code> hinzuf√ºgt: <br><br><pre> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br>  Derselbe Code, jedoch mit <code>reinterpret_cast</code> , um ein Wortspiel zu implementieren (verst√∂√üt gegen striktes Aliasing): <br><br><pre> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20 und bit_cast</b> <br><br>  In C ++ 20 haben wir <code>bit_cast</code> , das eine einfache und sichere M√∂glichkeit zur Interpretation bietet und auch im Kontext von <code>constexpr</code> . <br><br>  Das folgende Beispiel zeigt, wie mit <code>bit_cast</code> eine vorzeichenlose Ganzzahl in einem <code>float</code> interpretiert wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ): <br><br><pre> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br>  F√ºr den Fall, dass die Typen An und Von nicht dieselbe Gr√∂√üe haben, m√ºssen wir eine Zwischenstruktur verwenden.  Wir werden eine Struktur verwenden, die ein Zeichenarray-Vielfaches von <code>sizeof(unsigned int)</code> (ein 4-Byte-vorzeichenloses int wird angenommen) als From-Typ und <code>unsigned int</code> als To-Typ enth√§lt: <br><br><pre> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br>  Leider ben√∂tigen wir diesen Zwischentyp - dies ist die aktuelle <code>bit_cast</code> Einschr√§nkung. <br><br>  <b>Ausrichtung</b> <br><br>  In fr√ºheren Beispielen haben wir gesehen, dass ein Versto√ü gegen strenge Aliasing-Regeln zum Ausschluss von Speicher w√§hrend der Optimierung f√ºhren kann.  Verst√∂√üe gegen striktes Aliasing k√∂nnen auch zu Verst√∂√üen gegen die Ausrichtungsanforderungen f√ºhren.  Sowohl die C-Standards als auch C ++ besagen, dass Objekte Ausrichtungsanforderungen unterliegen, die den Ort einschr√§nken, an dem Objekte platziert werden k√∂nnen (im Speicher) und daher zug√§nglich sind.  <i>C11 Abschnitt 6.2.8 Ausrichtung von Objektzust√§nden</i> : <br><br>  F√ºr vollst√§ndige Objekttypen gelten Ausrichtungsanforderungen, die die Adressen einschr√§nken, an denen Objekte dieses Typs platziert werden k√∂nnen.  Die Ausrichtung ist ein implementierungsdefinierter ganzzahliger Wert, der die Anzahl der Bytes zwischen aufeinanderfolgenden Adressen darstellt, an denen dieses Objekt platziert werden kann.  Der Typ des Objekts stellt f√ºr jedes Objekt dieses Typs eine Ausrichtungsanforderung: Mit dem <code>_Alignas</code> kann eine strengere Ausrichtung angefordert werden. <br><br>  <b>Der C ++ 17-Projektstandard in Abschnitt 1 [basic.align]</b> : <br><br>  F√ºr Objekttypen gelten Ausrichtungsanforderungen (6.7.1, 6.7.2), die die Adressen einschr√§nken, an denen ein Objekt dieses Typs platziert werden kann.  Die Ausrichtung ist ein implementierungsdefinierter ganzzahliger Wert, der die Anzahl der Bytes zwischen aufeinanderfolgenden Adressen darstellt, an denen ein bestimmtes Objekt platziert werden kann.  Ein Objekttyp stellt f√ºr jedes Objekt dieses Typs eine Ausrichtungsanforderung.  Eine strengere Ausrichtung kann mit dem Ausrichtungsspezifizierer (10.6.2) angefordert werden. <br><br>  Sowohl C99 als auch C11 weisen ausdr√ºcklich darauf hin, dass eine Konvertierung, die zu einem nicht ausgerichteten Zeiger f√ºhrt, ein undefiniertes Verhalten ist (Abschnitt 6.3.2.3).  <i>Zeiger</i> sagt: <br><blockquote>  Ein Zeiger auf ein Objekt oder einen Teiltyp kann in einen Zeiger auf ein anderes Objekt oder einen Teiltyp konvertiert werden.  Wenn der resultierende Zeiger f√ºr den Zeigertyp nicht korrekt ausgerichtet ist, ist das Verhalten undefiniert.  ... <br></blockquote>  Obwohl C ++ nicht so offensichtlich ist, glaube ich, dass dieser Satz aus Absatz 1 <code>[basic.align]</code> ausreicht: <br><blockquote>  ... Der Objekttyp stellt f√ºr jedes Objekt dieses Typs eine Ausrichtungsanforderung.  ... </blockquote>  <i><b>Beispiel</b></i> <br><br>  Nehmen wir also an: <br><br><ul><li>  alignof (char) und alignof (int) sind 1 bzw. 4 </li><li>  sizeof (int) ist 4 </li></ul><br>  Das Interpretieren eines char-Arrays der Gr√∂√üe 4 als <code>int</code> verst√∂√üt somit gegen striktes Aliasing und kann auch gegen die Ausrichtungsanforderungen versto√üen, wenn das Array eine Ausrichtung von 1 oder 2 Bytes aufweist. <br><br><pre> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br>  Dies kann in einigen Situationen zu Leistungseinbu√üen oder Busfehlern f√ºhren.  W√§hrend die Verwendung von Alignas zum Erzwingen der gleichen Ausrichtung f√ºr ein Array in int verhindert, dass die Ausrichtungsanforderungen nicht erf√ºllt werden: <br><br><pre> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>Atomizit√§t</b></i> <br><br>  Eine weitere unerwartete Strafe f√ºr unausgeglichenen Zugriff besteht darin, dass die Atomizit√§t einiger Architekturen verletzt wird.  Atomspeicher werden f√ºr andere Threads in x86 m√∂glicherweise nicht atomar angezeigt, wenn sie nicht ausgerichtet sind. <br><br>  <b>Auffangen strenger Aliasing-Verst√∂√üe</b> <br><br>  Wir haben nicht viele gute Tools, um striktes Aliasing in C ++ zu verfolgen.  Die Tools, die wir haben, werden einige F√§lle von Verst√∂√üen und einige F√§lle von unsachgem√§√üem Laden und Speichern auffangen. <br><br>  gcc mit den <code>-fstrict-aliasing</code> und <code>-Wstrict-aliasing</code> kann einige F√§lle abfangen, allerdings nicht ohne Fehlalarme / Probleme.  In den folgenden F√§llen wird beispielsweise eine Warnung in gcc generiert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ): <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br>  obwohl er diesen zus√§tzlichen Fall nicht erfassen wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ): <br><br><pre> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br>  Obwohl <code>clang</code> diese Flags aufl√∂st, scheint es die Warnung nicht tats√§chlich zu implementieren. <br><br>  Ein weiteres Tool, das wir haben, ist ASan, das falsch ausgerichtete Aufzeichnungen und Speicherungen erkennen kann.  Obwohl es sich nicht um direkte Verst√∂√üe gegen striktes Aliasing handelt, ist dies ein recht h√§ufiges Ergebnis.  In den folgenden F√§llen werden beispielsweise Laufzeitfehler w√§hrend der Assemblierung mithilfe von clang mit <code>-fsanitize=address</code> <br><br><pre> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br>  Das letzte Tool, das ich empfehle, ist spezifisch f√ºr C ++ und in der Tat nicht nur ein Tool, sondern auch eine Codierungspraxis, die kein Casting im C-Stil erlaubt. Sowohl <code>gcc</code> als auch <code>clang</code> f√ºhren eine Diagnose f√ºr <code>-Wold-style-cast</code> mit <code>-Wold-style-cast</code> .  Dadurch werden alle undefinierten Wortspiele gezwungen, reinterpret_cast zu verwenden.  Im Allgemeinen sollte <code>reinterpret_cast</code> ein Signal f√ºr eine gr√ºndlichere Codeanalyse sein. <br>  Es ist auch einfacher, die Codebasis nach <code>reinterpret_cast</code> zu durchsuchen, um eine Pr√ºfung durchzuf√ºhren. <br><br>  F√ºr C verf√ºgen wir √ºber alle bereits beschriebenen Tools und √ºber einen <code>tis-interpreter</code> , einen statischen Analysator, der das Programm ausf√ºhrlich auf eine gro√üe Teilmenge von C analysiert. In den C-Versionen des vorherigen Beispiels wird bei Verwendung von -fstrict-aliasing ein Fall √ºbersprungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ) <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  Der TIS-Interpreter kann alle drei abfangen. Im folgenden Beispiel wird der TIS-Kernel als TIS-Interpreter bezeichnet (die Ausgabe wird der K√ºrze halber bearbeitet): <br><br><pre> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br>  Und schlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TySan</a> , das sich in der Entwicklung befindet.  Dieses Desinfektionsprogramm f√ºgt dem Schattenspeichersegment Informationen zur Typpr√ºfung hinzu und √ºberpr√ºft die Zugriffe, um festzustellen, ob sie gegen die Aliasing-Regeln versto√üen.  Das Tool sollte m√∂glicherweise in der Lage sein, alle Aliasing-Verst√∂√üe zu verfolgen, kann jedoch zur Laufzeit einen hohen Overhead haben. <br><br>  <b>Fazit</b> <br><br>  Wir haben etwas √ºber Aliasing-Regeln in C und C ++ gelernt, was bedeutet, dass der Compiler von uns erwartet, dass wir diese Regeln strikt befolgen und die Konsequenzen akzeptieren, wenn wir sie nicht erf√ºllen.  Wir haben einige Tools kennengelernt, mit denen wir Pseudonymmissbrauch identifizieren k√∂nnen.  Wir haben gesehen, dass die √ºbliche Verwendung von Aliasing ein Wortspiel der Typisierung ist.  Wir haben auch gelernt, wie man es richtig implementiert. <br><br>  Optimierer verbessern schrittweise die typbasierte Alias-Analyse und brechen bereits Code, der auf strengen Aliasing-Verst√∂√üen basiert.  Wir k√∂nnen erwarten, dass Optimierungen besser werden und noch mehr Code brechen, der gerade funktioniert hat. <br><br>  Wir haben vorgefertigte kompatible Standardmethoden f√ºr die Interpretation von Typen.  Manchmal sollten diese Methoden f√ºr Debug-Builds freie Abstraktionen sein.  Wir haben verschiedene Tools zum Erkennen schwerwiegender Aliasing-Verst√∂√üe, aber f√ºr C ++ werden sie nur einen kleinen Teil der F√§lle erfassen, und f√ºr C k√∂nnen wir mit dem tis-Interpreter die meisten Verst√∂√üe verfolgen. <br><br>  Vielen Dank an diejenigen, die diesen Artikel kommentiert haben: JF Bastien, Christopher Di Bella, Pascal Quoc, Matt P. Dziubinski, Patrice Roy und Olafur Vaage <br>  Am Ende geh√∂ren nat√ºrlich alle Fehler dem Autor. <br><br>  Damit ist die √úbersetzung eines ziemlich gro√üen Materials beendet, dessen erster Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> .  Und wir laden Sie traditionell zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen T√ºr ein</a> , der am 14. M√§rz vom Leiter der Abteilung f√ºr Technologieentwicklung bei Rambler &amp; Co - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Shebordaev abgehalten wird.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443602/">https://habr.com/ru/post/de443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443590/index.html">Data Science: Vorhersage von Gesch√§ftsereignissen zur Verbesserung des Service</a></li>
<li><a href="../de443592/index.html">RFID-Frontend-Standard ISO 11785 von einem alten FM-Empf√§nger und Aufzugsabf√§llen</a></li>
<li><a href="../de443594/index.html">Der Scheideweg von Test und Architektur: Ein Interview mit Neil Ford</a></li>
<li><a href="../de443598/index.html">Es gibt einen massiven Widerruf von TLS-Zertifikaten von einer Vielzahl von Zertifizierungsstellen, die versehentlich auf einem 63-Bit-RNG anstelle eines 64-Bit-Zertifikats generiert wurden</a></li>
<li><a href="../de443600/index.html">Die besten und schlechtesten Trends der MWC 2019</a></li>
<li><a href="../de443604/index.html">MOBILE FIRST: Hackathon bei OZON</a></li>
<li><a href="../de443606/index.html">Jenkins f√ºr Android Build mit Docker</a></li>
<li><a href="../de443608/index.html">Smart Home / Updates bei Lazurite</a></li>
<li><a href="../de443612/index.html">Wir verwenden alte schlechte Festplatten</a></li>
<li><a href="../de443614/index.html">YouTrack 2019.1: W√§hlen Sie Agile Boards, anpassbare Kartenfelder auf Agile Boards und mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>