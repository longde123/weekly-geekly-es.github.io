<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏻 🏡 🛫 学习OpenGL。 第7.1课-调试 🅾️ ♊️ 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="图形化编程不仅是乐趣的来源，而且当某些内容未按预期显示或屏幕上什么也不显示时，感到沮丧。 看到我们所做的大多数事情都与像素操作有关，当某些事情无法正常工作时，很难找出错误的原因。 调试这种类型的错误比调试CPU上的错误更加困难。 我们没有可以输出文本的控制台，不能在着色器中放置断点，也不能仅获取并检...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学习OpenGL。 第7.1课-调试</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="图片" align="left" width="300"> 图形化编程不仅是乐趣的来源，而且当某些内容未按预期显示或屏幕上什么也不显示时，感到沮丧。 看到我们所做的大多数事情都与像素操作有关，当某些事情无法正常工作时，很难找出错误的原因。 调试这种类型的错误比调试CPU上的错误更加困难。 我们没有可以输出文本的控制台，不能在着色器中放置断点，也不能仅获取并检查GPU上程序的状态。 </p><br><p> 在本教程中，我们将向您介绍OpenGL程序的一些调试方法和技术。 在OpenGL中调试并不是那么困难，学习一些技巧绝对会有所收获。 </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">目录内容</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">第1部分。入门</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">窗口创建</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好窗口</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好三角形</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转变</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">坐标系</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摄影机</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第2部分。基本照明</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">色彩</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">照明基础</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用料</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纹理贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多种光源</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第3部分。下载3D模型</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阿辛普图书馆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网格多边形类</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3D模型类</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第4部分。高级OpenGL功能</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混色</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">裁剪面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帧缓冲</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">立方卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的数据处理</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实例化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平滑处理</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第5部分。高级照明</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的照明。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Blinn Fong模型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伽玛校正</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">影子卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全向阴影贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">法线贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视差映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高动态范围</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布卢姆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟渲染</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第6部分。PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理论</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漫射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">镜面曝光</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">第7部分。练习</b> <div class="spoiler_text"><ol><li>  <b>侦错</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文字渲染</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError（） </h1><br><p>当您错误地使用OpenGL时（例如，当您设置一个缓冲区而忘记绑定它时），OpenGL将注意到并在幕后创建一个或多个自定义错误标志。 我们可以通过调用<code>glGetError()</code>函数跟踪这些错误，该函数仅检查设置的错误标志并在发生错误时返回错误值。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p> 此函数返回错误标志或完全没有错误。 返回值列表： </p><br><div class="scrollable-table"><table><thead><tr><th> 旗 </th><th> 代号 </th><th> 内容描述 </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td> 自上次glGetError调用以来未生成错误 </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td> 枚举参数无效时设置 </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td> 值无效时设置 </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td> 带有指定参数的命令无效时设置 </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td> 在将数据推入堆栈（推入）的操作导致堆栈溢出时建立。 </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td> 当从堆栈的最小点开始从堆栈中弹出数据（pop）的操作时，将建立此标记。 </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td> 当内存分配操作无法分配足够的内存时设置。 </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td> 从未完成的帧缓冲区读取/写入数据时设置 </td></tr></tbody></table></div><br><p> 在OpenGL函数的文档中，您可以找到由错误使用的函数生成的错误代码。 例如，如果您查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>glBindTexture()</code></a>函数的文档，则可以在“错误”部分中找到此函数生成的错误代码。 <br> 设置错误标志后，将不会生成其他错误标志。 此外，当<code>glGetError</code>时，该函数将擦除所有错误标志（或在分布式系统上仅清除一个错误标志，请参见下文）。 这意味着，如果在每帧之后调用一次<code>glGetError</code>并得到一个错误，这并不意味着这是唯一的错误，并且您仍然不知道该错误发生在哪里。 </p><br><blockquote> 请注意，当OpenGL以分布式方式工作时（通常在具有X11的系统上），当其他人使用不同的代码时，可能会生成其他错误。 然后，调用<code>glGetError</code>仅刷新错误代码标志之一，而不是全部。 因此，他们建议循环调用此函数。 </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  <code>glGetError</code>一个独特功能是，它可以相对容易地确定可能在何处发生错误并验证OpenGL是否正确使用。 假设您什么都没画，也不知道是什么原因：帧缓冲区设置不正确？ 忘记设置纹理了吗？ 通过在任何地方调用<code>glGetError</code> ，您可以快速找出发生第一个错误的位置。 <br> 默认情况下， <code>glGetError</code>仅报告错误号，在记住代码号之前不容易理解。 编写一个小的函数来帮助打印错误字符串以及调用该函数的位置通常是有意义的。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p> 如果您决定对<code>glCheckError</code>进行更多调用，了解错误发生的位置将很有用。 </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p> 结论： </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br> 还有一件重要的事情： <code>glewInit()</code>存在一个长期存在的错误： <code>glewInit()</code>始终设置<code>GL_INVALID_ENUM</code>标志。 要解决此问题，只需在<code>glGetError</code>之后调用<code>glewInit</code>以清除该标志： </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code>并没有多大帮助，因为返回的信息相对简单，但是它通常有助于捕获错别字或捕获发生错误的地方。 这是一个简单但有效的调试工具。 </p><br><h1 id="otladochnyy-vyvod"> 调试输出 </h1><br><p> 该工具鲜为人知，但比<code>glCheckError</code> （OpenGL扩展“调试输出”，包含在OpenGL 4.3核心配置文件中）有用。 使用此扩展，OpenGL将向用户发送错误消息，其中包含错误的详细信息。 此扩展不仅提供更多信息，而且还允许您使用调试器捕获错误发生的地方。 </p><br><blockquote> 从版本4.3开始，调试输出包含在OpenGL中，这意味着您将在支持OpenGL 4.3及更高版本的任何计算机上找到此功能。 如果此版本不可用，则可以检查扩展名<code>ARB_debug_output</code>和<code>AMD_debug_output</code> 。 还存在未经验证的信息，表明OS X不支持调试输出（原件的作者和翻译者尚未进行测试，如果您发现或反对这一事实，请通过错误纠正机制以私密消息的形式将原件的作者或本人告知我； <strong>UPD：</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Jeka178RUS对此</a>进行了检查实际上：开箱即用，调试输出不起作用，他没有检查扩展名）。 </blockquote><p> 要开始使用调试输出，我们需要在初始化过程中请求OpenGL调试上下文。 在不同的窗口系统上，此过程有所不同，但是这里我们仅讨论GLFW，但是在“其他材料”部分的文章结尾，您可以找到有关其他窗口系统的信息。 </p><br><h4 id="otladochnyy-vyvod-v-glfw"> 在GLFW中调试输出 </h4><br><p> 在GLFW中请求调试上下文非常简单：您需要做的就是给GLFW一个提示，即我们想要一个支持调试输出的上下文。 我们需要在调用<code>glfwCreateWindow</code>之前执行此<code>glfwCreateWindow</code> ： </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p> 初始化GLFW后，如果我们使用OpenGL 4.3或更高版本，则应该有一个调试上下文，否则我们应该试试运气，希望系统仍然可以创建调试上下文。 万一失败，我们需要通过OpenGL扩展机制请求调试输出。 </p><br><blockquote>  OpenGL调试上下文的速度可能比正常情况慢，因此在进行优化时或发布之前，应删除或注释掉这一行。 </blockquote><p> 要检查初始化调试上下文的结果，只需执行以下代码即可： </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p> 调试输出如何工作？ 我们将回调函数传递给OpenGL中的消息处理程序（类似于GLFW中的回调），并且在此函数中，我们可以根据需要处理OpenGL数据，在这种情况下，将有用的错误消息发送到控制台。 该函数的原型： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p> 请注意，在某些操作系统上，最后一个参数的类型可能是<code>const void*</code> 。 <br> 给定我们拥有的庞大数据集，我们可以创建一个有用的错误打印工具，如下所示： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p> 当扩展程序检测到OpenGL错误时，它将调用此函数，我们可以打印大量错误信息。 请注意，我们忽略了一些错误，因为它们是无用的（例如，NVidia驱动程序中的131185表示成功创建了缓冲区）。 <br> 现在我们有了所需的回调，是时候初始化调试输出了： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p> 因此，我们告诉OpenGL我们要启用调试输出。 对<code>glEnable(GL_DEBUG_SYNCRHONOUS)</code>的调用告诉OpenGL我们希望在错误发生时收到错误消息。 </p><br><h4 id="filtraciya-otladochnogo-vyvoda"> 调试输出过滤 </h4><br><p> 使用<code>glDebugMessageControl</code>函数<code>glDebugMessageControl</code>您可以选择要接收的错误类型。 在我们的情况下，我们会遇到各种错误。 如果我们只想要OpenGL API错误，例如Error和显着性级别High，我们将编写以下代码： </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p> 使用此配置和调试上下文，每个不正确的OpenGL命令都会发送很多有用的信息： </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov"> 通过调用堆栈查找错误源 </h4><br><p> 调试输出的另一个技巧是，您可以相对轻松地在代码中建立错误的确切位置。 通过在<code>DebugOutput</code>函数中为所需的错误类型设置断点（或者在函数的开头，如果要捕获所有错误），调试器将捕获该错误，并且您可以浏览调用堆栈以找出错误发生的位置： </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br> 这需要一些手动干预，但是如果您大致了解要查找的内容，则快速确定导致错误的呼叫非常有用。 </p><br><h4 id="svoi-oshibki"> 自己的错误 </h4><br><p> 除了读取错误，我们还可以使用<code>glDebugMessageInsert</code>将它们发送到调试输出系统： </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p> 如果要连接到使用调试上下文的另一个应用程序或OpenGL代码，这将非常有用。 其他开发人员将能够快速找出自定义OpenGL代码中发生的任何报告的错误。 <br> 通常，调试输出（如果可用）对于快速发现错误非常有用，并且绝对值得在调优上投入精力，因为它节省了大量的开发时间。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>使用<code>glGetError</code>和调试输出找到源代码的副本。 有错误，请尝试解决它们。 </p><br><h1 id="otladochnyy-vyvod-sheydera"> 着色器调试输出 </h1><br><p> 对于GLSL，我们无法使用<code>glGetError</code>之类的功能，也无法访问调试器中逐步执行代码的功能。 当您遇到黑屏或完全不正确的显示时，如果问题出在着色器上，将很难理解会发生什么。 是的，编译错误报告语法错误，但是捕获语义错误的是那首歌。 <br> 找出着色器存在问题的常用方法之一是将着色器程序中的所有相关变量直接发送到片段着色器的输出通道。 通过将着色器变量直接以颜色输出到输出通道，我们可以通过检查输出中的图片来找到有趣的信息。 例如，我们需要找出法线对于该模型是否正确。 我们可以将它们（无论是否经过变换）从顶点发送到片段着色器，从中派生出如下所示的法线： <br>  （请注意：为什么GLSL没有语法高亮显示？） </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p> 通过将非颜色变量以现在的颜色输出到输出通道，我们可以快速检查该变量的值。 例如，如果结果是黑屏，则很明显法线被错误地转移到了着色器，并且在显示法线时，检查它们的正确性相对容易： </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p> 从视觉结果中，我们可以看到法线是正确的，因为西服的右侧主要是红色（这意味着法线在漂洗x轴的方向上大致显示），并且西服的前侧在z轴的正方向（蓝色）上着色。 </p><br><p> 该方法可以扩展到您要测试的任何变量。 每次卡住并假定错误在于着色器时，请尝试绘制一些变量或中间结果，并找出算法的哪一部分存在错误。 </p><br><h1 id="opengl-glsl-reference-compiler">  OpenGL GLSL参考编译器 </h1><br><p> 每个视频驱动程序都有自己的怪癖。 例如，NVIDIA驱动程序稍微降低了规范的要求，而AMD驱动程序更好地满足了规范（在我看来，这更好）。 问题在于，由于驱动程序的差异，在一台计算机上运行的着色器可能无法在另一台计算机上赚钱。 </p><br><p> 凭借多年的经验，您可以了解不同GPU之间的所有差异，但是如果您想确保着色器可以在任何地方使用，则可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GLSL参考编译器</a>根据官方规范验证代码。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> ）下载所谓的<em>GLSL lang验证程序</em> 。 </p><br><p> 使用此程序，可以通过将着色器作为第一个参数传递给程序来测试它们。 请记住，该程序通过扩展名确定着色器的类型： </p><br><ul><li>  <code>.vert</code> ：顶点着色器 </li><li>  <code>.frag</code> ：片段着色器 </li><li>  <code>.geom</code> ：几何着色器 </li><li>  <code>.tesc</code> ：镶嵌控制着色器 </li><li>  <code>.tese</code> ：镶嵌计算着色器 </li><li>  <code>.comp</code> ：计算着色器 </li></ul><br><p> 运行程序很容易： </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p> 请注意，如果没有错误，程序将不会输出任何内容。 在折断的顶点着色器上，输出如下所示： </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p> 该程序不会显示AMD，NVidia或Intel的GLSL编译器之间的差异，甚至无法报告着色器中的所有错误，但至少会检查着色器是否符合标准。 </p><br><h1 id="vyvod-bufera-kadra"> 帧缓冲器输出 </h1><br><p> 工具箱的另一种方法是在屏幕的特定部分显示帧缓冲区的内容。 最有可能的是，您经常使用帧缓冲区，并且由于所有魔术都在幕后发生，因此很难确定正在发生的事情。 帧缓冲区内容的输出是验证事情是否正确的有用技巧。 </p><br><blockquote> 请注意，如此处所述，帧缓冲区的内容适用于纹理，而不适用于图形缓冲区中的对象 </blockquote><p> 使用一个绘制单个纹理的简单着色器，我们可以编写一个小的函数来快速在屏幕的右上角绘制任何纹理： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p> 这将在屏幕角落为您提供一个小窗口，用于调试帧缓冲区的输出。 例如，当您尝试检查法线的正确性时，它很有用： </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p> 您还可以扩展此功能，以使其渲染多个纹理。 这是从帧缓冲区中的任何内容获取连续反馈的快速方法。 </p><br><h1 id="vneshnie-programmy-otladchiki"> 外部调试器程序 </h1><br><p> 当所有其他方法都失败时，还有另外一个技巧：使用第三方程序。 它们内置在OpenGL驱动程序中，可以拦截所有OpenGL调用，从而为您提供有关应用程序的许多有趣数据。 这些应用程序可以剖析OpenGL功能的使用，查找瓶颈，并监视帧缓冲区，纹理和内存。 在处理（大型）代码时，这些工具会变得无价。 </p><br><p> 我列出了几种流行的工具。 尝试每个，然后选择最适合您的一个。 </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc是一个很好的（完全<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放的</a> ）单独的调试工具。 要开始捕获，请选择可执行文件和工作目录。 您的应用程序照常工作，当您要观看单个框架时，您可以允许RenderDoc捕获应用程序的多个框架。 在捕获的帧中，您可以查看管道的状态，所有OpenGL命令，缓冲区存储和使用的纹理。 </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl"> 法典 </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeXL</a> -GPU调试工具，可作为Visual Studio的独立应用程序和插件。  CodeXL提供了大量信息，非常适合分析图形应用程序。  CodeXL还可以在NVidia和Intel的图形卡上运行，但不提供OpenCL调试支持。 </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p> 我没有使用CodeXL，因为RenderDoc对我来说似乎更简单，但是我将CodeXL包含在此列表中是因为它看起来像是一种非常可靠的工具，并且主要由GPU的主要制造商之一开发。 </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nsight</a>是一种流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUIDIA</a> GPU调试工具。 它不仅是Visual Studio和Eclipse的插件，还是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单独的应用程序</a> 。  Nsight插件对于图形开发人员而言非常有用，因为它收集了大量有关GPU使用情况和GPU逐帧状态的实时统计信息。 </p><br><p> 从使用调试命令或Nsight配置文件通过Visual Studio或Eclipse启动应用程序的那一刻起，它将开始在应用程序内部进行。  Nsight中的一件好事：在正在运行的应用程序之上呈现一个GUI系统（GUI，图形用户界面），您可以使用它来实时或逐帧分析收集有关应用程序的各种信息。 </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight是一个非常有用的工具，我认为它超越了上述工具，但有一个严重的缺点：它<em>仅适用</em>于NVIDIA图形卡。 如果您使用的是NVIDIA图形卡和Visual Studio，那么Nsight绝对值得一试。 </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">   </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    ?</a> —           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://web.archive.org/web/20150225171555/"> </a> —            Vallentin Source. </li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我们有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电报会议，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以协调转账。</font><font style="vertical-align: inherit;">如果您有强烈的帮助翻译的愿望，欢迎您！</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462897/">https://habr.com/ru/post/zh-CN462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462885/index.html">容错IPoE网络在手</a></li>
<li><a href="../zh-CN462887/index.html">使用动态推荐示例个性化在线商店的体验</a></li>
<li><a href="../zh-CN462889/index.html">续篇：Pascal自己的Windows编译器</a></li>
<li><a href="../zh-CN462893/index.html">城市人脸识别：安全与隐私</a></li>
<li><a href="../zh-CN462895/index.html">用pwnable.kr 17解决工作-memcpy。 数据对齐</a></li>
<li><a href="../zh-CN462903/index.html">我们如何在莫斯科办公室的华为上设计和实现新网络，第3部分：服务器工厂</a></li>
<li><a href="../zh-CN462905/index.html">使用Telebot库第2部分在Python中编写电报Bot</a></li>
<li><a href="../zh-CN462907/index.html">ngFanatic每周</a></li>
<li><a href="../zh-CN462909/index.html">ASIC进化的成果：关于制造商，SHA-256的矿工以及天文哈希率的怪异</a></li>
<li><a href="../zh-CN462911/index.html">电动汽车落后一年</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>