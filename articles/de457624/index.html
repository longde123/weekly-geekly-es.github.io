<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔵 👩‍🎨 ⚱️ Wie wir die alte Hütte zerbrochen und an ihrer Stelle einen Wolkenkratzer gebaut haben ☔️ 👩🏼‍🚀 👩🏿‍🤝‍👩🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zurab Bely, Teamleiter der Java-Praxis, erzählt seine Geschichte von der Arbeit in einem Projekt für ein großes Unternehmen und teilt seine Erfahrunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die alte Hütte zerbrochen und an ihrer Stelle einen Wolkenkratzer gebaut haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457624/">  Zurab Bely, Teamleiter der Java-Praxis, erzählt seine Geschichte von der Arbeit in einem Projekt für ein großes Unternehmen und teilt seine Erfahrungen. <br><br><h4>  Wie ich mich niedergelassen habe ... </h4><br>  Ich bin Ende Sommer 2017 als gewöhnlicher Entwickler in das Projekt eingestiegen.  Ich kann nicht sagen, dass es mir damals sehr gut gefallen hat: Die im Projekt verwendeten Technologien waren alt, die Kommunikation innerhalb des Teams wurde minimiert, die Kommunikation mit dem Kunden war schwierig und unproduktiv.  Das Projekt hat mich also getroffen.  Zu dieser Zeit hatte ich nur einen Wunsch: schnell rauszukommen. <br><br>  Ich werde ein wenig über das gesamte Projekt erzählen.  Dies ist das offizielle Portal eines großen Unternehmens mit allgemeinen Informationen, Nachrichten, Werbeaktionen und anderen Inhalten.  Alle Marketing-Newsletter enthalten Links zu bestimmten Seiten der Website, dh die Auslastung ist stabil durchschnittlich, kann jedoch zu bestimmten Zeitpunkten hohe Werte erreichen.  Die Stabilität und Zugänglichkeit der Webanwendung erfordert besondere Aufmerksamkeit - jede Minute Ausfallzeit führt zu großen Verlusten für den Kunden. <br><a name="habracut"></a><br><h4>  Shanty, die im Wind blinzelte </h4><br>  Zuerst habe ich hauptsächlich den technischen Zustand des Projekts untersucht, kleinere Fehler behoben und kleinere Verbesserungen vorgenommen.  Aus technischer Sicht sah die Anwendung schrecklich aus: Eine monolithische Architektur, die auf einer veralteten kommerziellen Version von dotCMS basiert, Code, der in der 6. Java-Version geschrieben wurde, als das neunte serverseitige Rendern des Client-Teils auf dem Velocity-Framework erfolgte, das bis vor einigen Jahren noch nicht stattgefunden hatte wurde unterstützt.  Jede Instanz wurde in JBoss AS gestartet und mit Nginx geroutet.  Speicherlecks führten zu einem ständigen Neustart der Knoten, und das Fehlen eines normalen Cachings führte zu einer Erhöhung der Serverlast.  Der größte Splitter waren jedoch die Änderungen am CMS-Code.  Sie schlossen die Möglichkeit eines schmerzlosen Upgrades auf eine neuere Version aus.  Ein gutes Beispiel dafür war der Übergang von Version 3.2 zu 3.7, der gerade zu diesem Zeitpunkt endete.  Der Übergang zur nächsten Nebenversion dauerte mehr als ein Jahr.  Keine gängigen Lösungen wie Spring Framework, React.js, Microservice-Architektur, Docker usw. kamen nicht in Frage.  Bei einem tieferen Einblick in das Projekt wurden die Konsequenzen eines solchen technischen Zustands sichtbar.  Am akutesten war die Unfähigkeit, die Anwendung für die Entwicklung und das Debuggen lokal auszuführen.  Das gesamte Team von 8 Mitarbeitern arbeitete an einem Entwicklungsstand, an dem eine Kopie der Produktionsversion der Anwendung bereitgestellt wurde.  Dementsprechend konnte nur ein Entwickler gleichzeitig seinen Code debuggen, und das Rollen des aktualisierten Codes blockierte das gesamte Team.  Der Höhepunkt war ein fehlgeschlagener Verkauf, bei dem Millionen von Briefen, SMS- und Push-Benachrichtigungen über Zehntausende von Kanälen an verschiedene Benutzer gesendet wurden - Zehntausende von Sitzungen wurden gleichzeitig eröffnet.  Die Server konnten es nicht aushalten und die meiste Zeit war das Portal nicht verfügbar.  Die Anwendung lässt sich nicht gut skalieren.  Es gab nur einen Weg, dies zu tun: eine weitere Kopie nebeneinander bereitstellen und die Lasten mithilfe von Nginx zwischen ihnen ausgleichen.  Und jede Lieferung des Produktionscodes war mit viel manueller Arbeit verbunden und dauerte mehrere Stunden. <br><br>  Sechs Monate nach meiner Beteiligung an dem Projekt, als die Situation bereits außer Kontrolle geriet, wurde beschlossen, die Situation radikal zu ändern.  Der Übergangsprozess hat begonnen.  Änderungen betrafen alle Bereiche: Teamzusammensetzung, Arbeitsprozesse, Architektur und technische Komponente der Anwendung. <br><br><h4>  Wir haben gebaut, gebaut ... </h4><br>  Zunächst sind personelle Veränderungen eingetreten.  Sie wurden von mehreren Entwicklern ersetzt und haben mich zum Teamleiter gemacht.  Der Übergang zu modernen Lösungen begann mit der Einbeziehung von Mitarbeitern in das Team, die Erfahrung in der Arbeit mit ihnen hatten. <br><br>  Verfahrensänderungen waren globaler.  Zu diesem Zeitpunkt wurde bereits die Agile- + Scrum-Methode entwickelt, zweiwöchige Sprints mit Lieferung am Ende jeder Iteration.  Tatsächlich hat dies jedoch nicht nur die Arbeitsgeschwindigkeit nicht erhöht, sondern im Gegenteil verlangsamt.  Die täglichen Rallyes dauerten anderthalb bis zwei Stunden und führten zu keinen Ergebnissen.  Planung und Pflege wurden zu Streitigkeiten, Fluchen oder einfacher Kommunikation.  Damit hatte etwas zu tun.  Es war anfangs sehr schwierig, etwas in dieser Richtung zu ändern - im Namen des Kunden verlor das Team fast das Vertrauen, insbesondere nach einem erfolglosen Verkauf.  Jede Änderung musste lange begründet, diskutiert und bewiesen werden.  Seltsamerweise kam die Initiative aber vom Kunden.  Ihrerseits war ein Scrum-Master beteiligt, um die korrekte Anwendung von Ansätzen und Methoden zu kontrollieren, Prozesse zu debuggen und das Team an die Arbeit zu bringen.  Obwohl er nur von wenigen Sprints angezogen wurde, half es uns, das Fundament richtig zusammenzubauen.  Der Ansatz zur Kommunikation mit dem Kunden hat sich stark verändert.  Wir haben begonnen, Probleme in Prozessen häufiger zu diskutieren, Rückblicke wurden produktiver, Entwickler waren eher bereit, Feedback zu geben, und der Kunde seinerseits hat den Übergangsprozess in jeder Hinsicht unterstützt. <br><br>  Aber ehrlich gesagt, ich sage ehrlich: Es gab einige Momente, in denen einige Änderungen innerhalb des Teams „blind“ durchgeführt wurden, und nach dem Auftreten positiver Ergebnisse wurde dies dem Kunden gemeldet.  Seit sechs Monaten ändert sich die Einstellung zu einer komfortablen Arbeitskommunikation.  Es folgten mehrere Teambuildings, eintägige und zweitägige Besprechungen des gesamten Entwicklungsteams mit dem Kundenteam (Vermarkter, Analyst, Designer, Produktberater, Content Manager usw.) sowie gemeinsame Besuche an der Bar.  Nach einem Jahr und bis heute kann Kommunikation als freundlich bezeichnet werden.  Die Atmosphäre ist freundlich, entspannt und komfortabel geworden.  Natürlich kommt es nicht ohne Konflikte aus, aber selbst in der glücklichsten Familie gibt es manchmal Streitigkeiten. <br><br>  In diesem Zeitraum gab es keine weniger interessanten Änderungen im Anwendungscode, in der Architektur und in den verwendeten Lösungen.  Wenn Sie technisch nicht versiert sind, können Sie den gesamten Text sicher zum Abschluss überspringen.  Und wenn Sie wie ich Glück haben - willkommen!  Der gesamte Übergang kann in mehrere Stufen unterteilt werden.  Über jeden im Detail. <br><br>  <b>Stufe 1. Identifizierung kritischer Problembereiche.</b> <br><br>  Alles war so einfach und klar wie möglich.  Zunächst war es notwendig, die Abhängigkeit eines kommerziellen Produkts von Drittanbietern zu beseitigen, einen Monolithen zu schneiden und ein lokales Debuggen zu ermöglichen.  Ich wollte den Client- und Servercode trennen, um ihn architektonisch und physisch zu verteilen.  Ein weiterer Problembereich ist die Qualifikation.  Dem Projekt fehlten jegliche automatischen Tests.  Dies machte den Übergang etwas schwierig, da alles manuell überprüft werden musste.  Da es nie technische Aufgaben für die Funktion gegeben hat (die Besonderheiten des Projekts sind hier betroffen), bestand eine hohe Wahrscheinlichkeit, dass etwas fehlte.  Nachdem wir die Problembereiche gestrichen hatten, sahen wir uns noch einmal die Liste an.  Es sah aus wie ein Plan.  Es ist Zeit, einen Wolkenkratzer zu bauen! <br><br>  <b>Stufe 2. Aktualisieren der Codebasis.</b> <br><br>  Die am längsten laufende Etappe.  Alles begann mit dem Übergang zu einer Service-Architektur (nicht zu verwechseln mit Microservices).  Die Idee war folgende: die Anwendung in mehrere separate Dienste aufzuteilen, von denen jeder seine spezifische Aufgabe behandelt.  Dienstleistungen sollten nicht „Mikro“ sein, aber ich wollte auch nicht alles in einen Kessel packen.  Jeder Dienst sollte eine Spring Boot-Anwendung sein, die in Java SE 8 geschrieben und auf Tomcat ausgeführt wurde. <br><br>  Der erste war der sogenannte.  "Content Service", der zu einer Schicht zwischen der zukünftigen Anwendung und dem CMS geworden ist.  Es ist eine Abstraktion auf dem Weg zum Inhalt geworden.  Es wurde davon ausgegangen, dass alle Anforderungen, die wir zuvor direkt im CMS gestellt haben, über diesen Dienst ausgeführt werden, jedoch bereits das HTTP-Protokoll verwenden.  Eine solche Lösung ermöglichte es uns, die Konnektivität zu reduzieren und die Möglichkeit zu schaffen, dotCMS später durch ein moderneres Analog zu ersetzen oder sogar die Verwendung kommerzieller Produkte zu eliminieren und unsere eigene Lösung zu schreiben, die auf unsere Aufgaben zugeschnitten ist (mit Blick auf die Zukunft werde ich sagen, dass dies der Weg ist, den wir gegangen sind). <br><br>  Sofort wurde der Grundstein für die Trennung von Front- und Backend-Code gelegt.  Sie erstellten einen Front-End-Service, der für die Verteilung des auf die Reaktion geschriebenen Codes verantwortlich wurde.  Wir haben npm geschraubt, den Knoten konfiguriert und die Baugruppe debuggt - alles ist so, wie es sollte, entsprechend den modernen Trends des Client-Teils. <br><br>  Im Allgemeinen wurde die Funktionalität dem Dienst gemäß dem folgenden Algorithmus zugewiesen: <br><br><ul><li>  hat eine neue Spring Boot-Anwendung mit allen erforderlichen Abhängigkeiten und Einstellungen erstellt; </li><li>  portierte die gesamte Grundlogik (schrieb sie oft von Grund auf neu und bezog sich dabei auf den alten Code, nur um sicherzustellen, dass Sie keine Nuancen vergessen haben). Für den Caching-Dienst sind dies beispielsweise die Optionen zum Hinzufügen zum Cache, Lesen aus dem Cache und Deaktivieren. </li><li>  Alle neuen Funktionen wurden immer mit dem neuen Dienst geschrieben. </li><li>  schrittweise Umschreiben alter Teile der Anwendung in einen neuen Dienst in der Reihenfolge ihrer Wichtigkeit. </li></ul><br>  Zu Beginn hatten wir einige davon: <br><br><ul><li>  Inhaltsservice.  Wirkte als Schicht zwischen der Anwendung und dem CMS. </li><li>  Cache-Dienst.  Einfaches Repository im Spring Cache. </li><li>  AA-Service.  Zu Beginn war er nur mit der Verbreitung von Informationen über einen autorisierten Benutzer beschäftigt.  Der Rest blieb in dotCMS. </li><li>  Frontservice.  Verantwortlich für die Verteilung des Kundencodes. </li></ul><br>  <b>Stufe 3. Autotests.</b> <br><br>  Unter Berücksichtigung aller Erfahrungen des Projekts haben wir festgestellt, dass das Vorhandensein von Funktionstests das Leben und die mögliche weitere Aktualisierung der Anwendung erheblich vereinfacht.  Es ist Zeit, sie in das Projekt einzuführen.  Unit-Tests des Codes kamen leider fast sofort zum Stillstand.  Das Schreiben und der Support haben viel Zeit in Anspruch genommen, und wir hatten sehr wenig davon, da neben dem Umschreiben des Codes auch aktuelle Aufgaben zu neuen Funktionen an uns hingen und häufig Fehler auftauchten.  Es wurde beschlossen, sich nur auf das Testen der Anwendungsoberfläche mit Selenium zu konzentrieren.  Dies erleichterte uns einerseits die Durchführung von Regressionstests vor der Auslieferung an die Produktion, andererseits wurde es möglich, auf der Serverseite ein Refactoring durchzuführen und den Status auf der Clientseite zu überwachen.  Das Team hatte keinen Automator, und das Schreiben und Aufrechterhalten der Relevanz von Autotests erfordert zusätzliche Kosten.  Sie haben keinen der Tester umgeschult, und eine andere Person wurde dem Team hinzugefügt. <br><br>  <b>Phase 4. Automatisierung der Bereitstellung.</b> <br><br>  Jetzt, da wir separate Services haben, wenn sich das Frontend vom Backend getrennt hat und die Hauptfunktionalität durch Selbsttests abgedeckt wurde, ist es an der Zeit, eine Dose Bier zu öffnen und alle manuellen Arbeiten zur lokalen Bereitstellung und Unterstützung der Anwendung auf Demo- und Produktservern zu automatisieren.  Das Schneiden des Monolithen in Stücke und die Verwendung von Spring Boot haben uns neue Horizonte eröffnet. <br><br>  Die Entwickler konnten den Code lokal debuggen und nur den Teil der Funktionalität ausführen, der dafür benötigt wird.  Endlich wurden die Prüfstände für den vorgesehenen Zweck verwendet - es wurde bereits mehr oder weniger debuggter Code für Erst- und Qualifikationstests bereitgestellt.  Aber es gab immer noch viel handgemachte Arbeit, die unsere kostbare Zeit und Energie verschwendete.  Nachdem wir das Problem untersucht und die Lösungen sortiert hatten, entschieden wir uns für eine Reihe von Gradle + TeamCity.  Da das Projekt von Gradle erstellt wurde, machte es keinen Sinn, etwas Neues hinzuzufügen, und die geschriebenen Skripte erwiesen sich als plattformunabhängig. Sie können auf jedem Betriebssystem, remote oder lokal ausgeführt werden.  Dies ermöglichte nicht nur die Verwendung einer beliebigen Lösung für CI / CD, sondern auch die schmerzlose Umstellung der Plattform auf eine andere.  TeamCity wurde aufgrund seiner umfangreichen integrierten Funktionalität, der Präsenz einer großen Community und einer langen Liste von Plug-Ins für alle Gelegenheiten sowie der Integration in die Intellij IDEA-Entwicklungsumgebung ausgewählt. <br><br>  Derzeit gibt es mehr als 100 Optimierungsskripte und mehr als 300 Aufgaben im CI-System, um sie mit unterschiedlichen Parametern auszuführen.  Dies ist nicht nur eine Bereitstellung zum Testen von Bänken und zur Lieferung an die Produktion, sondern auch zum Arbeiten mit Protokollen, Serververwaltung, Routing und nur Lösungen für Routineaufgaben des gleichen Typs.  Einige der Aufgaben wurden von unseren Schultern genommen.  Content Manager konnten den Cache selbst leeren.  Die Mitarbeiter des technischen Supports hatten die Möglichkeit, einzelne Dienste selbst in Anspruch zu nehmen und primäre Wiederbelebungsmaßnahmen durchzuführen.  Der Schlaf der Entwickler ist tiefer und ruhiger geworden. <br><br>  <b>Stufe 5. Eigenes CMS.</b> <br><br>  Nachdem es möglich war, vom kommerziellen CMS zu abstrahieren, wurde es möglich, Daten von einer anderen Quelle zu empfangen, ohne den Anwendungscode neu zu schreiben.  Woher diese oder jene Daten kommen, wurde vom Inhaltsdienst festgelegt.  Nachdem wir nach vorgefertigten Lösungen gesucht und diese analysiert hatten, beschlossen wir, ein eigenes Content-Management-System zu schreiben, da keines von ihnen unsere Anforderungen vollständig erfüllte.  Das Schreiben Ihres eigenen CMS ist ein endloser Prozess, ständig tauchen neue Bedürfnisse und Wünsche auf.  Wir haben einige grundlegende Funktionen ausgewählt und sind in die schöne Welt der Entwicklung gegangen.  Um die erste Version in Prod zu starten, hatten wir eineinhalb Mannmonate.  Da die Funktionalität im neuen CMS bereit ist, übertragen wir Inhalte vom alten auf das CMS.  Alle neuen Seiten haben nichts mehr mit dotCMS zu tun.  Im Laufe der Zeit war es möglich, die kostenpflichtige Version aufzugeben und zur Community-Version zu wechseln und in Zukunft etwas von Drittanbietern vollständig aufzugeben. <br><br>  <b>Stufe 6. Korrekturlesen.</b> <br><br>  Nachdem wir unsere Hosen hochgekrempelt hatten, begannen wir unsere Reise in die Welt der Hipster-Programmierung.  Diese Phase für mein Projekt war die letzte im Umstrukturierungsprozess.  Es geht bis heute weiter.  Der Hauptbereich, für den diese Phase im Allgemeinen auftrat, ist die Skalierung.  Mit dem Docker + Kubernetes + Consul-Bundle können Sie nicht nur die Bereitstellung auf verschiedenen Servern vereinfachen und jeden Dienst separat verwalten, sondern auch die gesamte Anwendung flexibel skalieren, nur an den Stellen, an denen dies erforderlich ist, und nur so lange, wie dies erforderlich ist.  Im Detail kann ich nur malen, wenn wir in der Produktion vollständig auf diese Lösung umsteigen. <br><br><h4>  ... und endlich gebaut.  Hurra! </h4><br><br>  Seit Beginn des Anwendungsupdates ist ein Jahr vergangen.  Dies sind jetzt 26 REST-Services, die in Spring Boot geschrieben wurden.  Jedes hat eine detaillierte API-Dokumentation in der Swagger-Benutzeroberfläche.  Die Clientseite ist in React.js geschrieben und von der Serverseite getrennt.  Alle Hauptseiten des Portals sind mit Tests abgedeckt.  Durchführung mehrerer wichtiger Verkäufe.  Der Übergang zu modernen Technologien, die Beseitigung von altem Code und der stabile Betrieb von Servern motivieren Entwickler stark.  Von „wie gesagt, wir machen es“ hat sich das Projekt in den Mainstream verlagert, wo jeder am Erfolg interessiert ist und seine eigenen Optionen für Verbesserungen und Optimierungen bietet.  Die Einstellung des Kunden zum Team hat sich geändert, eine freundliche Atmosphäre wurde geschaffen. <br><br>  Dies ist das Ergebnis der Arbeit des gesamten Teams, jedes Entwicklers und Testers, Managers und Kunden.  Es war sehr schwer, nervös und manchmal kurz vor einem Foul.  Der Zusammenhalt des Teams, die kompetente Planung und das Bewusstsein für die Ergebnisse ermöglichten es jedoch, alle Schwierigkeiten zu überwinden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457624/">https://habr.com/ru/post/de457624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457612/index.html">Wie kann die LZ4-Dekomprimierung in ClickHouse beschleunigt werden?</a></li>
<li><a href="../de457614/index.html">Geheimnisse der Arbeitssuche im Ausland bei einem praktizierenden Headhunter</a></li>
<li><a href="../de457616/index.html">Mein "Wow, das wusste ich nicht!" Momente mit Scherz</a></li>
<li><a href="../de457618/index.html">Ein moderner Full-Stack-Entwickler sein</a></li>
<li><a href="../de457622/index.html">Qt-Leistung messen</a></li>
<li><a href="../de457626/index.html">Überarbeitung der Benutzerzugriffsebenen mithilfe von Power BI am Beispiel von Bitrix CMS (BUS)</a></li>
<li><a href="../de457628/index.html">Effektives P2M-Programm- und Projektmanagement</a></li>
<li><a href="../de457630/index.html">Erfahrung in der Entwicklung von Anforderungen an professionelle Datenwissenschaftler</a></li>
<li><a href="../de457632/index.html">Was kosten Unit-Tests?</a></li>
<li><a href="../de457634/index.html">DDS-Synthesizer auf Verilog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>