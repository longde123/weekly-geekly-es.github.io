<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏫 🏇🏽 🚮 分层密钥生成 ✅ 🈳 👏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将讨论确定性钱包，分层密钥生成及其在数学上的工作方式，以及在哪种情况下便于实践。 该材料对于其活动与支付网关，比特币钱包和其他硬币商店有关的专家很有用。 另外，对椭圆密码学和电子签名密钥部署方案感兴趣的人也将感兴趣。 

 确定性钱包 
 首先，让我们定义什么是确定性钱包。 在谈到密钥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>分层密钥生成</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/distributedlab/blog/413627/"> 在本文中，我们将讨论确定性钱包，分层密钥生成及其在数学上的工作方式，以及在哪种情况下便于实践。 该材料对于其活动与支付网关，比特币钱包和其他硬币商店有关的专家很有用。 另外，对椭圆密码学和电子签名密钥部署方案感兴趣的人也将感兴趣。 <br><a name="habracut"></a><br><h2>  <b>确定性钱包</b> </h2><br> 首先，让我们定义什么是确定性钱包。 在谈到密钥生成时，我们经常使用“钱包”一词，因为在加密货币的背景下，拥有私钥就是硬币所有权的证明，在这种情况下，钱包和密钥具有相似的含义。 <br><br> 确定性钱包是其中所有使用的私钥都是由所有密钥共享的一个秘密生成的钱包。 特殊之处在于，可以从一个秘密生成任意数量的密钥对以进行电子签名。 您可以为每个收款和更改使用新地址。 <br><br> 方便地，这种钱包的密钥可以轻松地转移到另一台设备上，进行备份，然后再还原，因为实际上您只需要保留一个主要机密。 此外，从主机密生成的所有私钥都不相互连接。 不可能跟踪生成的地址之间的连接（以确定它们全部属于一个用户），并且拥有生成的私钥，就无法还原共享机密。 <br><br><h3> 基本秘密编码 </h3><br> 现在让我们谈谈编码的主要秘密。  BIP39中定义了一些标准化方法。 这是将主要秘密转换为助记词的所谓“检查编码”编码-一组易于在纸上书写的单词，如有必要，请记住。 输入时，可以检查校验和，即以很高的概率识别错误（如果有）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/c02/e0f/00ec02e0fe0b361673229ecc9fa59e14.png" alt="图片"><br><br> 如何运作？ 实际上，您有一个主要秘密（熵）-扩展钱包所有个人密钥的数据。 这个秘密可以有不同的长度。 至于校验和：对于熵的每32位，将有1位校验和，即，通过公式将校验和计算为以位为单位的熵的长度除以32。 <br><br> 熵与校验和连接在一起，该校验和被计算为双SHA-256哈希（SHA-2的长度为256位），此后将切断所需的位数。 串联的数据将传输到另一个数字系统：从二进制到基于2048的数字系统（如您所见，2048是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-msubsup" id="MJXp-Span-2"><span class="MJXp-mn" id="MJXp-Span-3" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-4" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-5">11</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-31" x="500" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {11} </script>  ） 并且，如果将熵位的长度和校验和相加，将得到11的倍数。 这样，我们得到了输出助记词短语中的单词数。 <br><br> 实际上，数据按11位部分“切片”。 有2048个单词的字典（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-6"><span class="MJXp-msubsup" id="MJXp-Span-7"><span class="MJXp-mn" id="MJXp-Span-8" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-9" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-10">11</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/distributedlab/blog/413627/&amp;usg=ALkJrhi1V3dx3Nzwqt56CQcTQMZVPWZB0w#MJMAIN-31" x="500" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {11} </script>  ）（某些要求适用于此）。 词典的默认语言是英语，但是任何人都可以使用。 单词长度不得超过一定长度（通常不得超过7个字符）。 所有字符都必须以UTF-8编码，并对所有字符进行某种标准化。 强制性的是前四个字符中每个单词的唯一性。 <br><br> 前四个字符唯一地标识字典中的单词，其余字符用于以方便的形式完成该单词，以供阅读，记忆等。因此，由11位组成的每条数据均以来自字典。 如果您的秘密熵为256位，则用于编码的数据将为264位，并且您的助记词短语将包含24个单词。 这是在实践中最常使用的BIP39中加密钱包机密的主要方法。 <br><br> 为了将来制作备份副本并使用它，请您将此短语写在外部介质上。 最好将纸张存放在安全的地方。 因此，您可以恢复对所有密钥的完全访问权限。 <br><br><h3> 确定性钱包的类型 </h3><br> 确定性钱包有两种类型。 考虑它们的主要区别。 <br><br> 第一个是最简单的。 这里的主要秘密是与我们想要获取的子键的索引连接在一起，然后对连接的数据进行哈希处理。 通常，这是使用SHA-256哈希函数发生的。 <br><br> 第二种类型包括分层确定性钱包（HD钱包），其原理在BIP32中定义，并且是用于分层密钥生成的非常常用的方法。 <br><br><h3> 确定性生成 </h3><br> 考虑图中这些类型的钱包之间的差异。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/271/a5a/477/271a5a47790684700751178bcee9d340.png" alt="图片"><br><br> 一个普通的确定性钱包有一些种子，可以直接生成大量的私钥。 它们的数量只能受索引的大小限制，索引的大小在散列之前连接到机密。 通常为4个字节，也就是说，可能的选项空间允许大约40亿个唯一的确定性钱包密钥。 实际上，对于任何情况，这都足够。 <br><br><h3> 分层确定性生成 </h3><br> 让我们继续进行分层的确定性钱包，到目前为止，它的密钥部署方案以简化的形式呈现。 有种子，可以从中直接获得一对主密钥。 如果在一个普通的确定性钱包中得到一个私钥，那么在这里我们得到一对密钥。 此外，还有层次结构级别，在每个层次结构上我们都计算索引以生成子项。 我们还可以建立公钥分支和私钥分支。 <br><br><h3> 层次级别 </h3><br> 关于HD钱包，值得注意的是，根据层次结构每个级别上的BIP32规则，生成节点具有三个对象：私钥，公钥和用于生成下一个层次结构级别的链代码。 <br><br><h3> 分层生成方案 </h3><br> 让我们更详细地考虑BIP32的密钥生成方案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/685/e79/e3e/685e79e3eae45b867f3033aad03f1743.png" alt="图片"><br><br> 一切都从种子开始，也称为主种子，从中计算层次结构的零级-一对主密钥和链码。 <br><br> 可以从一对主密钥中生成大量具有特定索引的密钥对。 正在形成一个新的层次结构，用于生成帐户。 假设一个用户有种子并且想创建几个彼此不同的地址。 这些地址的硬币不会混合在一起，也不会一起发布，并且在它们之间完成的交易中将无法找到连接。 这些键将完全彼此分开使用。 在其中一个帐户中，关键组将用于工作预算，在另一个帐户中将用于个人预算，另一个帐户将用于黑簿记。 硬币不会相互混合。 <br><br> 下一个层次结构级别定义了不同的密钥生成链。 最常见的情况是使用索引为0和1的链。索引为0的链将生成最终密钥以形成收款地址，索引为1的链将为用户发送给自己的硬币（即找零）生成钱包。 这样做是必要的，以便程序级别的钱包可以将来自外部的付款与更改区分开来，计算每个交易余额的更改，并编制包含所有付款历史的可视列表。 这简化了钱包的开发及其日常支付的使用。 <br><br><h3> 基于哈希的消息认证代码 </h3><br> 现在，让我们继续进行分层密钥生成过程的数学部分。 首先，请考虑基于哈希的消息身份验证代码。 这是用于计算哈希函数的不同类。 它的不同之处在于，它在输入时采用两个值，而不是一个。 第一个值是私钥，第二个值是消息本身。 <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">H</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">M</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">A</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">C</span><span class="MJXp-mrow" id="MJXp-Span-16"><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">K</span><span class="MJXp-mrow" id="MJXp-Span-19"><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">m</span><span class="MJXp-mrow" id="MJXp-Span-22"><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">H</span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">K</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-32" style="vertical-align: 0.5em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">d</span></span></span><span class="MJXp-mrow" id="MJXp-Span-37"><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">H</span><span class="MJXp-mrow" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">K</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-48" style="vertical-align: 0.5em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">d</span></span></span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-55"><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">m</span><span class="MJXp-mrow" id="MJXp-Span-60"><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-62"><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> HMAC（K，m）= H（（K ^ {opad}）|| H（K ^ {ipad}）|| m））</script></p><br><br>  K是关键 <br>  m-讯息 <br>  opad，ipad-在散列的不同阶段，生成彼此不同的密钥所必需的一些常量值。 <br> 作为哈希函数，使用SHA-512。 <br><br> 特殊之处在于，为了使用HMAC，您需要拥有一个秘密密钥才能获得消息的正确哈希值。 <br><br> 因此，要计算HMAC哈希值，将XOR密钥的值与ipad常量值进行比较，然后对结果进行哈希处理。 将消息连接到该值，然后使用恒定值计算密钥XOR，将其与哈希值连接，然后再次进行哈希处理。 结果，我们获得了512位的哈希值。 <br><br><h3> 推导函数 </h3><br> 让我们看一些用于计算层次键的函数。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96e/f47/b41/96ef47b4141a2060395a9933dd56c52f.png" alt="图片"><br><br> 首先，我们有兴趣将主种子转换为主密钥对。 之后，您需要从个人父密钥获取子私钥和子公钥。 在第二种情况下，使用与第一种情况完全相同的函数，但是将数字与基点相乘，因此将不单独考虑该函数。 下一步是从公用父密钥获取子级公用。 值得注意的是，不可能从父公钥获得孩子的个人身份。 此限制是由于HD钱包固有的某些属性，我们将进一步考虑这些属性。 <br><br> 因此，让我们分别研究每个生成函数。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/736/372/31c/73637231c62a14b4bf5f8e7a5d498d01.png" alt="图片"><br><br> 为了从主sid获取主密钥，使用了HMAC函数，其中将常量字符串“ Bitcoin seed”作为密钥进行传输，并将主秘密数据本身作为消息进行传输。 因此，获得了512位的哈希值，我们将其视为两个部分：左和右。 左侧是主私钥，右侧是链码。 此外，这些值将用于生成子密钥的后续级别。 <br><br> 为了公开主密钥，只需将基点的值乘以主私有密钥的值即可。 如您所见，这类似于椭圆曲线上一组点中的普通键。 <br><br> 现在，让我们来看一下子私钥如何来自父私钥。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6f/eeb/022/a6feeb0227ea2d2ba18ed42ce4d47d01.png" alt="图片"><br><br> 我们将再次使用HMAC函数。 作为密钥，我们传递当前层次结构级别的链代码，并作为消息（连接），其中第一部分将是个人父密钥乘以基点。 实际上，这是对这一点的强制转换和序列化。 串联与我们要接收的子密钥的索引发生，以32位（即4个字节）序列化。 <br><br> 基于HMAC函数的结果，我们得到值I，然后再次将其分开考虑：输出值的左右部分为256位。 然后子私钥 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-msubsup" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66" style="margin-right: 0.05em;">k</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-67" style="vertical-align: -0.4em;">i</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> k_i </script> 我们通过添加到左侧的输出值来计算 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">I</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-71" style="vertical-align: -0.4em;">l</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> I_l </script> 父私钥的值。 加法以n为模，其中n是椭圆曲线基点的顺序，以便不超过私钥的最大值。 因此，我们收到了一个孩子的私钥。 <br><br> 因此，子链代码将等于HMAC函数的正确输出值，即 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-msubsup" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74" style="margin-right: 0.05em;">I</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-75" style="vertical-align: -0.4em;">R</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> I_R </script>  。 如果要从个人父密钥中找到子公钥，请将该值乘以 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-76"><span class="MJXp-msubsup" id="MJXp-Span-77"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78" style="margin-right: 0.05em;">k</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-79" style="vertical-align: -0.4em;">i</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> k_i </script> 通过椭圆曲线上的基点值。 这样我们就得到了公钥 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-msubsup" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82" style="margin-right: 0.05em;">K</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-83" style="vertical-align: -0.4em;">i</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> K_i </script>  。 <br><br> 我们如何从公共父密钥计算子公共密钥？ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/bbe/e55/39abbee5560b44abbe7a271a88153198.png" alt="图片"><br><br> 这里的计算将有所不同。 我们将当前层次结构级别的链层次结构作为HMAC函数的键传递，然后序列化父公钥，并将其与序列化为32位的所需索引连接起来。 输入数据的获取方式与前一种情况完全相同。 要计算公钥，我们取HMAC函数输出值的左侧，并将其视为按基点顺序取模的256位，将其带到椭圆曲线上的某个点，即乘以基点，然后将结果与父公钥相加。 加法的结果也很重要，它将是公共子密钥。 该键的链代码将在HMAC函数的输出值的右侧。 <br><br><h3> 相互匹配的密钥 </h3><br> 这可能引发一个逻辑问题，即以不同方式获得的私钥和公钥将如何相互对应。 通过采用以另一种方式获得的私钥并将其乘以基点，是否真的有可能从以公共方式生成的公钥中获得完全相同的值？ 这很容易验证。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e44/ac2/851/e44ac28516cc2774373bc76d94d0c244.png" alt="图片"><br><br> 如果我们回想起我们如何计算个人子密钥，然后将其乘以基点，即得出point函数，然后回想子公共密钥的计算并比较这些计算，我们会发现，如果我们将父公共密钥视为个人父项的乘积关键点，然后我们将看到执行相同的计算，只是顺序不同。 <br><br> 在一种情况下，我们将私钥相加并与基点相乘，在第二种情况下，我们首先将值与基点相乘，然后相加并得到结果。 基于在椭圆曲线上加点的操作是累加的事实，我们可以说这两个值相等-我们将获得以两种方式计算出的相同公钥。 <br><br><h3> 公钥示例 </h3><br> 为了引起兴趣，我们可以看一个为测试值和BIP32计算而获得的公共密钥的示例。 如果我们的熵由128位组成，那么在十六进制系统中，它将看起来像下面的图像。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64c/ca1/01a/64cca101a12268bda803fd8f447c719e.png" alt="图片"><br><br>  BIP39助记词短语中编码的相同值看起来像所示的12个单词。 如果将此助记词短语用作生成层次密钥的主种子，则将获得具有相应256位链码的主密钥。 <br><br><h3> 扩展键 </h3><br> 还存在诸如扩展的公共密钥和扩展的私钥的概念。 如何使用？ 为了更好地理解，我们描述了视觉情况。 <br><br> 假设我们有一个特定的用户和一些服务。 服务以一定频率将付款（例如比特币）转移给用户。 用户和服务都对每次付款都使用新地址感兴趣，以使外部观察者难以确定事实并混淆彼此的交互历史。 <br><br> 在最简单的情况下，它看起来像这样：用户为每次收到的付款生成一个新的密钥对，计算他传递给该服务的地址，之后该服务可以生成交易并完成付款。 但是，如果这些付款的强度很高，那么对于任何一方来说都是不方便的。 <br><br><h3> 扩展公钥 </h3><br> 在类似情况下，扩展的公共密钥（xPubKey）有助于消除不便之处。 用户可以使第三方服务生成地址，而不是由该服务知道的自身地址，但是只有用户才具有私钥。 该服务可以在用户不知情的情况下生成任意数量的地址并向他们汇款，并且用户可以在他方便的时候部署私钥并获得对任何这些地址的访问权限。 <br><br> 如何运作？ 用户需要在密钥层次结构的第二个级别上生成一个新帐户，为他计算当前级别的公共密钥和链式代码。 之后，您需要将公钥和链码都传输到服务。 为了方便起见，我们介绍了Base58Check编码（这里有一个特殊版本）。 接下来，将公钥，链码和校验和连接在一起。 所有这些都在基数系统58中进行了编码，我们得到了已经根据某种标准进行编码的公共扩展密钥。 它以易于识别的字符“ xpub”开头。 它将如图所示。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c61/aae/082/c61aae082f6a423d35712fcf63246f68.png" alt="图片"><br><br> 服务可以接受这样的密钥，并通过BIP32为用户部署公共密钥，从中接收地址并为其付费。 但是，只有用户可以计算相应的私钥。 <br><br><h3> 强化推导 </h3><br> 在密钥的分层生成中，存在诸如强化派生之类的事情。 这是一种不允许从相应的父公钥计算子公钥的方法。      ,          HMAC       ,   hardened derivation      . <br><br>  ,   .        32 ,   hardened derivation   :      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-84"><span class="MJXp-msubsup" id="MJXp-Span-85"><span class="MJXp-mn" id="MJXp-Span-86" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-87" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-88">31</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">2^{31}</script> ,      1 (    ). ,         ,    hardened derivation   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-msubsup" id="MJXp-Span-90"><span class="MJXp-mn" id="MJXp-Span-91" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-92" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-93">31</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10">2^{31}</script>  。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/160/ab3/cea160ab30c57ea702407dd53893d25e.png" alt="图片"><br><br>  ,      hardened derivation,     .      ,       . ,           .   normal derivation,    ,          . <br><br><h3>   </h3><br>    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/0bc/006/c7d0bc0061acf64d206c73d305de73c4.png" alt="图片"><br><br>       ,     .   -          .            “m”,       ,    “M”.    ,   ,     hardened derivation,   — normal derivation. <br><br>       ,    BIP32,      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ab/564/b7c/1ab564b7cbe935bfbe5aa2075c1fce31.png" alt="图片"><br><br>    ,      -.    ,       ,    ,     ,       ,    1    ,        (   ).        ,     . <br><br>      BIP32       0,    m, 0   hardened, chain — 0,  — 0 (m/0'/0/0).         . <br><br>     ,   BIP43,         ,      (m/bip_number'/*). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/652/61f/68c65261f576ac3e75c412c2de9b50b5.png" alt="图片"><br><br>  ,  BIP44,     ,         44,    :        ,     ,      .            . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/739/3bd/23b7393bd44abf5568d476c03d0a8bf8.png" alt="图片"><br><br>     ,  “m/44'/0'/0'/0/0”,  Bitcoin testnet — “m/44'/1'/0'/0/0”,  Litecoin — “m/44'/2'/0'/0/0”,  Dash — “m/44'/5'/0'/0/0”. ,  Ethereum           -          “m/44'/60'/0'/0/0”. <br><br>     — BIP45.    ,           multisignature      BIP16,   P2SH.      BIP43        45,          (cosigner). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bc/2c8/fd1/4bc2c8fd1c785ef5c9deb48417db9c53.png" alt="图片"><br><br> ,    3--5.   5 ,    ,    3 .  ,      HD    -,         .    ,     ,       . ,         ,     ,   ,        .  ,        ,          . <br><br>        ,   ,     ,  multisignature      . <br><br><h3>  </h3><br>     . <br><br> <i>—   master seeds   ?</i> <br><br> Seed —    , -  ,    , , ,  BIP39,     .        ,      —         .  ,   BIP44,               .         ,        . <br><br> <i>—   BIP39,  2048     ?         ?</i> <br><br>   ,      BIP39.   BIP39  : ,  , , , ,   . .      ,    BIP39        ,        .   ,    BIP39,   .        ,    ,   ,   . <br><br> <i>—       Coinbase           -  ?</i> <br><br>  ,        ,    ,  ,     ,    BIP32,     .  ,     ,       ,  ,      . ,    ,      . <br><br> <i>—  —     ,       X  Y?</i> <br><br>   — ,     ,    —   ,  ,         .        —   X  Y,      256 . <br><br> <i>—   “  ”     ?</i> <br><br>    ,    ,   ,   .         ,            ,        .         . ,   ,   .   ,    ,   Y   ,       ,   :   .      ,   , ,    ,      .   ,     .     ,   ,    .       — 4 .  ,       4-  .      ,    . <br><br> <i>—      derivation  HD ?    ,          ?</i> <br><br>      BIP32,     ,   BIP39,  . .   GitHub,     Bitcoin.     Bitcoin,     ,    BIPs (),       . <br><br>     ,         .     ,         ,       ,      .      ,     ,   ,   .     .  ,    -     ,  . <br><br> <i>— Hardened derivation      ?</i> <br><br>    .           hardened derivation     .  BIP44 hardened derivation     :       BIP,   —  ,   ,   —  ,     . ,    ,     ,           .          ,        hardened derivation    . <br><br> <i>—      ?</i> <br><br>      ,         .          .        ,              .       ,          .      ,       . <br><br>       -  Blockchain “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ”. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413627/">https://habr.com/ru/post/zh-CN413627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413615/index.html">事实证明，VPNFilter病毒感染了50万路由器，其危险性甚至超出了人们的想象。</a></li>
<li><a href="../zh-CN413617/index.html">更改了30％的职权范围，两次超出了计划：VTB如何自动报告</a></li>
<li><a href="../zh-CN413619/index.html">有关VPNFilter的新信息：对用户设备进行攻击，扩展了网络设备的列表</a></li>
<li><a href="../zh-CN413621/index.html">活下去。 死了 复活。 重覆</a></li>
<li><a href="../zh-CN413623/index.html">如何制作Omega 2或I2S传奇</a></li>
<li><a href="../zh-CN413631/index.html">使用JaCarta，Debian和Evolution邮件客户端的示例在Linux上的令牌上对证书令牌进行加密</a></li>
<li><a href="../zh-CN413633/index.html">我如何精通英语</a></li>
<li><a href="../zh-CN413635/index.html">我们设计了一个牧场。 并使用nanoCAD VK？</a></li>
<li><a href="../zh-CN413637/index.html">谷歌发布了7条AI伦理原则</a></li>
<li><a href="../zh-CN413639/index.html">受保护的智能手机：谁需要它，它们之间有何不同？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>