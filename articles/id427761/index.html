<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹 😌 😝 Implementasi algoritma k-means (k-means) menggunakan contoh bekerja dengan piksel ⭐️ 💿 🤛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Baru-baru ini, perlu untuk menulis kode untuk mengimplementasikan segmentasi gambar menggunakan metode k-means (Bahasa Inggris k-means)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi algoritma k-means (k-means) menggunakan contoh bekerja dengan piksel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Halo semuanya!  Baru-baru ini, perlu untuk menulis kode untuk mengimplementasikan segmentasi gambar menggunakan metode k-means (Bahasa Inggris k-means).  Nah, hal pertama yang dilakukan Google adalah bantuan.  Saya menemukan banyak informasi, seperti dari sudut pandang matematika (semua jenis coretan matematika kompleks di sana, Anda akan mengerti apa yang tertulis di sana), serta beberapa implementasi perangkat lunak yang ada di Internet Inggris.  Kode-kode ini tentu saja indah - tidak diragukan lagi, tetapi esensi dari gagasan ini sulit ditangkap.  Entah bagaimana semuanya rumit di sana, bingung, namun, dengan tangan, dengan tangan, Anda tidak akan menulis kode, Anda tidak akan mengerti apa pun.  Pada artikel ini saya ingin menunjukkan implementasi yang sederhana, tidak produktif, tetapi, saya harap, dapat dimengerti dari algoritma yang luar biasa ini.  Oke, ayo pergi! <br><a name="habracut"></a><br>  Jadi, apa pengelompokan dalam hal persepsi kita?  Biarkan saya memberi Anda sebuah contoh, katakanlah ada gambar yang bagus dengan bunga-bunga dari pondok nenek Anda. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  Pertanyaannya adalah: untuk menentukan berapa banyak area dalam foto ini yang diisi kira-kira dengan warna yang sama.  Yah, sama sekali tidak sulit: kelopak putih - satu, pusat kuning - dua (saya bukan ahli biologi, saya tidak tahu apa namanya), tiga hijau.  Bagian ini disebut cluster.  Cluster adalah kombinasi data yang memiliki fitur umum (warna, posisi, dll.).  Proses penentuan dan penempatan setiap komponen data apa pun dalam kelompok - bagian tersebut disebut pengelompokan. <br><br>  Ada banyak algoritma pengelompokan, tetapi yang paling sederhana adalah k - medium, yang akan dibahas kemudian.  K-means adalah algoritma sederhana dan efisien yang mudah diimplementasikan menggunakan metode perangkat lunak.  Data yang akan kami distribusikan dalam kelompok adalah piksel.  Seperti yang Anda ketahui, piksel warna memiliki tiga komponen - merah, hijau dan biru.  Pengenaan komponen ini dan menciptakan palet warna yang ada. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  Dalam memori komputer, setiap komponen warna ditandai oleh angka dari 0 hingga 255. Artinya, menggabungkan nilai yang berbeda dari merah, hijau dan biru, kita mendapatkan palet warna di layar. <br><br>  Menggunakan piksel sebagai contoh, kami menerapkan algoritma kami.  K-means adalah algoritma iteratif, yaitu, ia akan memberikan hasil yang benar, setelah sejumlah pengulangan beberapa perhitungan matematika. <br><br><h3>  Algoritma </h3><br><ol><li>  Anda harus tahu sebelumnya berapa banyak cluster yang Anda butuhkan untuk mendistribusikan data.  Ini adalah kelemahan yang signifikan dari metode ini, tetapi masalah ini diselesaikan dengan peningkatan implementasi algoritma, tetapi ini, seperti yang mereka katakan, adalah cerita yang sama sekali berbeda. </li><li>  Kita perlu memilih pusat awal dari kelompok kita.  Bagaimana?  Ya secara acak.  Mengapa  Sehingga Anda dapat mengambil setiap piksel ke tengah-tengah kluster.  Pusatnya seperti Raja, di mana subyeknya dikumpulkan - piksel.  Ini adalah "jarak" dari pusat ke piksel yang menentukan kepada siapa setiap piksel akan mematuhinya. </li><li>  Kami menghitung jarak dari setiap pusat ke setiap piksel.  Jarak ini dianggap sebagai jarak Euclidean antara titik-titik dalam ruang, dan dalam kasus kami, sebagai jarak antara tiga komponen warna: <p><math> </math> $$ menampilkan $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ menampilkan $$ </p>  Kami menghitung jarak dari piksel pertama ke setiap pusat dan menentukan jarak terkecil antara piksel ini dan pusat.  Untuk pusat, jarak ke yang terkecil, kami menghitung ulang koordinat sebagai rata-rata aritmatika antara setiap komponen piksel - raja dan piksel - subjek.  Pusat kami bergeser dalam ruang sesuai dengan perhitungan. </li><li>  Setelah menghitung ulang semua pusat, kami mendistribusikan piksel ke dalam kelompok, membandingkan jarak dari setiap piksel ke pusat.  Sebuah piksel ditempatkan dalam sebuah cluster, ke pusat yang lebih dekat daripada pusat-pusat lainnya. </li><li>  Semuanya dimulai lagi, selama piksel tetap berada di kelompok yang sama.  Seringkali ini mungkin tidak terjadi, karena dengan sejumlah besar data pusat akan bergerak dalam radius kecil, dan piksel di sepanjang tepi cluster akan melompat ke satu atau cluster lain.  Untuk melakukan ini, tentukan jumlah iterasi maksimum. </li></ol><br><h3>  Implementasi </h3><br>  Saya akan mengimplementasikan proyek ini dalam C ++.  File pertama adalah "k_means.h", di dalamnya saya mendefinisikan tipe data utama, konstanta, dan kelas utama untuk bekerja - "K_means". <br>  Untuk mengkarakterisasi setiap piksel, buat struktur yang terdiri dari tiga komponen piksel, untuk itu saya memilih tipe ganda untuk perhitungan yang lebih akurat, dan juga menentukan beberapa konstanta agar program dapat bekerja: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  K_means kelas itu sendiri: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Mari kita bahas komponen-komponen kelas: <br><br>  vectorpixcel - vektor untuk piksel; <br>  q_klaster - jumlah cluster; <br>  k_pixcel - jumlah piksel; <br>  vectorcentr - vektor untuk pusat pengelompokan, jumlah elemen di dalamnya ditentukan oleh q_klaster; <br>  ident_centers () - metode untuk memilih pusat awal secara acak di antara piksel input; <br>  compute () dan compute_s () adalah metode bawaan untuk menghitung jarak antara piksel dan pusat penghitungan ulang, masing-masing; <br>  tiga konstruktor: yang pertama adalah secara default, yang kedua adalah untuk menginisialisasi piksel dari sebuah array, yang ketiga adalah untuk menginisialisasi piksel dari file teks (dalam implementasi saya, file secara tidak sengaja diisi dengan data pada awalnya, dan kemudian piksel dibaca dari file ini untuk program untuk bekerja, mengapa tidak langsung ke vektor - hanya dibutuhkan dalam kasus saya); <br>  clustering (std :: ostream &amp; os) - metode clustering; <br>  metode dan kelebihan pernyataan output untuk mempublikasikan hasil. <br><br>  Implementasi Metode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Ini adalah metode untuk memilih pusat pengelompokan awal dan menambahkannya ke vektor pusat.  Pemeriksaan dilakukan untuk mengulangi pusat dan menggantinya dalam kasus ini. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Implementasi konstruktor untuk menginisialisasi piksel dari array. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Kami meneruskan objek input ke konstruktor ini untuk dapat memasukkan data dari file dan konsol. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  №"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   №"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" №"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         –  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  Metode utama pengelompokan. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - №"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  Output dari data awal. <br><br><h4>  Contoh keluaran </h4><br><div class="spoiler">  <b class="spoiler_title">Contoh keluaran</b> <div class="spoiler_text">  <em>Piksel mulai:</em> <em><br></em>  <em>255 140 50 - No. 0</em> <em><br></em>  <em>100 70 1 - No. 1</em> <em><br></em>  <em>150 20 200 - No. 2</em> <em><br></em>  <em>251 141 51 - No.3</em> <em><br></em>  <em>104 69 3 - No. 4</em> <em><br></em>  <em>153 22 210 - No. 5</em> <em><br></em>  <em>252 138 54 - No. 6</em> <em><br></em>  <em>101 74 4 - No. 7</em> <em><br><br></em>  <em>Pusat pengelompokan awal acak:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>Jumlah Cluster: 3</em> <em><br></em>  <em>Jumlah piksel: 8</em> <em><br><br></em>  <em>Mulai Cluster:</em> <em><br><br></em>  <em>Iterasi nomor 0</em> <em><br><br></em>  <em>Jarak dari piksel 0 ke pusat # 0: 218.918</em> <em><br></em>  <em>Jarak dari piksel 0 ke pusat # 1: 173.352</em> <em><br></em>  <em>Jarak dari piksel 0 ke pusat # 2: 176.992</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Menghitung ulang pusat # 1: 179.5 104.5 26.5</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 0: 211.189</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 1: 90.3369</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 2: 0</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung ulang pusat # 2: 100 70 1</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 0: 0</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 1: 195.225</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 2: 211.189</em> <em><br></em>  <em>Jarak Tengah Minimum # 0</em> <em><br></em>  <em>Menghitung pusat # 0: 150 20 200</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 0: 216.894</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 1: 83.933</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 2: 174.19</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Menghitung pusat # 1: 215.25 122.75 38.75</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 0: 208.149</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 1: 128.622</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 2: 4.58258</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung pusat # 2: 102 69.5 2</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 0: 10.6301</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 1: 208.212</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 2: 219.366</em> <em><br></em>  <em>Jarak Tengah Minimum # 0</em> <em><br></em>  <em>Hitung ulang pusatnya # 0: 151.5 21 205</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 0: 215.848</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 1: 42.6109</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 2: 172.905</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Hitung ulang pusat # 1: 233.625 130.375 46.375</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 0: 213.916</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 1: 150.21</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 2: 5.02494</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung ulang pusat # 2: 101.5 71.75 3</em> <em><br><br></em>  <em>Mari kita mengklasifikasikan piksel:</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 0: 221.129</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 1: 23.7207</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 2: 174.44</em> <em><br></em>  <em>Piksel # 0 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari piksel No. 1 ke pusat # 0: 216.031</em> <em><br></em>  <em>Jarak dari pixel No. 1 ke pusat # 1: 153.492</em> <em><br></em>  <em>Jarak dari pixel No. 1 ke pusat # 2: 3.05164</em> <em><br></em>  <em>Piksel # 1 paling dekat dengan pusat # 2</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 0: 5.31507</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 1: 206.825</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 2: 209.378</em> <em><br></em>  <em>Piksel # 2 paling dekat dengan pusat # 0</em> <em><br></em>  <em>Jarak dari angka pixel 3 ke pusat # 0: 219.126</em> <em><br></em>  <em>Jarak dari pixel No. 3 ke pusat # 1: 20.8847</em> <em><br></em>  <em>Jarak dari pixel No. 3 ke pusat # 2: 171.609</em> <em><br></em>  <em>Piksel # 3 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 0: 212.989</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 1: 149.836</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 2: 3.71652</em> <em><br></em>  <em>Piksel # 4 paling dekat dengan pusat # 2</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 0: 5.31507</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 1: 212.176</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 2: 219.035</em> <em><br></em>  <em>Piksel # 5 paling dekat dengan pusat # 0</em> <em><br></em>  <em>Jarak dari angka pixel 6 ke pusat # 0: 215.848</em> <em><br></em>  <em>Jarak dari pixel No. 6 ke pusat # 1: 21.3054</em> <em><br></em>  <em>Jarak dari angka pixel 6 ke pusat # 2: 172.164</em> <em><br></em>  <em>Piksel # 6 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 0: 213.916</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 1: 150.21</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 2: 2.51247</em> <em><br></em>  <em>Piksel # 7 paling dekat dengan pusat # 2</em> <em><br><br></em>  <em>Array piksel dan pusat yang cocok:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Hasil Clustering:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Pusat baru:</em> <em><br></em>  <em>151.5 21 205 - # 0</em> <em><br></em>  <em>233.625 130.375 46.375 - # 1</em> <em><br></em>  <em>101.5 71.75 3 - # 2</em> <em><br><br></em>  <em>Iterasi nomor 1</em> <em><br><br></em>  <em>Jarak dari piksel 0 ke pusat # 0: 221.129</em> <em><br></em>  <em>Jarak dari piksel 0 ke pusat # 1: 23.7207</em> <em><br></em>  <em>Jarak dari piksel 0 ke pusat # 2: 174.44</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Menghitung pusat # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 0: 216.031</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 1: 165.234</em> <em><br></em>  <em>Jarak dari piksel 1 ke pusat # 2: 3.05164</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung ulang pusat # 2: 100.75 70.875 2</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 0: 5.31507</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 1: 212.627</em> <em><br></em>  <em>Jarak dari piksel 2 ke pusat # 2: 210.28</em> <em><br></em>  <em>Jarak Tengah Minimum # 0</em> <em><br></em>  <em>Hitung ulang pusat # 0: 150.75 20.5 202.5</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 0: 217.997</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 1: 9.29613</em> <em><br></em>  <em>Jarak dari piksel 3 ke pusat # 2: 172.898</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Menghitung pusat # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 0: 210.566</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 1: 166.078</em> <em><br></em>  <em>Jarak dari piksel 4 ke pusat # 2: 3.88306</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung pusat # 2: 102.375 69.9375 2.5</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 0: 7.97261</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 1: 219.471</em> <em><br></em>  <em>Jarak dari piksel 5 ke pusat # 2: 218.9</em> <em><br></em>  <em>Jarak Tengah Minimum # 0</em> <em><br></em>  <em>Menghitung pusat # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 0: 216.415</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 1: 6.18805</em> <em><br></em>  <em>Jarak dari piksel 6 ke pusat # 2: 172.257</em> <em><br></em>  <em>Jarak Pusat Minimum # 1</em> <em><br></em>  <em>Menghitung ulang pusat # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 0: 215.118</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 1: 168.927</em> <em><br></em>  <em>Jarak dari piksel 7 ke pusat # 2: 4.54363</em> <em><br></em>  <em>Jarak Tengah Minimum # 2</em> <em><br></em>  <em>Menghitung ulang pusat # 2: 101.688 71.9688 3.25</em> <em><br><br></em>  <em>Mari kita mengklasifikasikan piksel:</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 0: 221.699</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 1: 5.81307</em> <em><br></em>  <em>Jarak dari pixel No. 0 ke pusat # 2: 174.122</em> <em><br></em>  <em>Piksel # 0 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari pixel No. 1 ke pusat # 0: 217.244</em> <em><br></em>  <em>Jarak dari pixel No. 1 ke pusat # 1: 172.218</em> <em><br></em>  <em>Jarak dari piksel No. 1 ke pusat # 2: 3.43309</em> <em><br></em>  <em>Piksel # 1 paling dekat dengan pusat # 2</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 0: 6.64384</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 1: 214.161</em> <em><br></em>  <em>Jarak dari pixel No. 2 ke pusat # 2: 209.154</em> <em><br></em>  <em>Piksel # 2 paling dekat dengan pusat # 0</em> <em><br></em>  <em>Jarak dari pixel No. 3 ke pusat # 0: 219.701</em> <em><br></em>  <em>Jarak dari piksel # 3 ke pusat # 1: 3.27555</em> <em><br></em>  <em>Jarak dari pixel No. 3 ke pusat # 2: 171.288</em> <em><br></em>  <em>Piksel # 3 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 0: 214.202</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 1: 168.566</em> <em><br></em>  <em>Jarak dari pixel No. 4 ke pusat # 2: 3.77142</em> <em><br></em>  <em>Piksel # 4 paling dekat dengan pusat # 2</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 0: 3.9863</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 1: 218.794</em> <em><br></em>  <em>Jarak dari pixel No. 5 ke pusat # 2: 218.805</em> <em><br></em>  <em>Piksel # 5 paling dekat dengan pusat # 0</em> <em><br></em>  <em>Jarak dari angka pixel 6 ke pusat # 0: 216.415</em> <em><br></em>  <em>Jarak dari pixel No. 6 ke pusat # 1: 3.09403</em> <em><br></em>  <em>Jarak dari pixel No. 6 ke pusat # 2: 171.842</em> <em><br></em>  <em>Piksel # 6 paling dekat dengan pusat # 1</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 0: 215.118</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 1: 168.927</em> <em><br></em>  <em>Jarak dari pixel No. 7 ke pusat # 2: 2.27181</em> <em><br></em>  <em>Piksel # 7 paling dekat dengan pusat # 2</em> <em><br><br></em>  <em>Array piksel dan pusat yang cocok:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Hasil Clustering:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Pusat baru:</em> <em><br></em>  <em>151.875 21.25 206.25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101.688 71.9688 3.25 - # 2</em> <em><br><br></em>  <em>Akhir dari pengelompokan.</em> <br></div></div><br>  Contoh ini direncanakan sebelumnya, piksel dipilih secara khusus untuk demonstrasi.  Dua iterasi sudah cukup bagi program untuk mengelompokkan data menjadi tiga kelompok.  Melihat pusat dari dua iterasi terakhir, Anda dapat melihat bahwa mereka praktis tetap di tempatnya. <br><br>  Yang lebih menarik adalah kasus piksel yang dihasilkan secara acak.  Setelah menghasilkan 50 poin yang perlu dibagi menjadi 10 cluster, saya mendapat 5 iterasi.  Setelah menghasilkan 50 poin yang perlu dibagi menjadi 3 kelompok, saya mendapatkan semua 100 iterasi maksimum yang diizinkan.  Anda mungkin memperhatikan bahwa semakin banyak kluster, semakin mudah bagi program untuk menemukan piksel yang paling mirip dan menggabungkannya ke dalam kelompok yang lebih kecil, dan sebaliknya - jika ada beberapa kluster dan ada banyak titik, algoritme sering berakhir hanya ketika jumlah iterasi maksimum terlampaui, karena beberapa piksel terus melonjak. dari satu cluster ke yang lain.  Namun, sebagian besar masih ditentukan dalam kelompok mereka sepenuhnya. <br><br>  Nah, sekarang mari kita periksa hasil pengelompokan.  Mengambil hasil dari beberapa cluster dari contoh 50 poin per 10 cluster, saya mengarahkan hasil data ini ke Illustrator dan inilah yang terjadi: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  Dapat dilihat bahwa di setiap kluster ada nuansa warna yang berlaku, dan di sini Anda perlu memahami bahwa piksel dipilih secara acak, analog dari gambar seperti itu dalam kehidupan nyata adalah semacam gambar di mana semua warna secara tidak sengaja disemprotkan dan sulit untuk memilih area dengan warna yang sama. <br><br>  Katakanlah kita punya foto seperti itu.  Kita dapat mendefinisikan sebuah pulau sebagai satu kelompok, tetapi dengan peningkatan kita melihat bahwa pulau itu terdiri dari berbagai nuansa hijau. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  Dan ini adalah cluster 8, tetapi dalam versi yang lebih kecil, hasilnya serupa: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  Versi lengkap dari program ini dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> saya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427761/">https://habr.com/ru/post/id427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427749/index.html">Apple dan Samsung untuk pertama kalinya didenda karena memperlambat ponsel lama</a></li>
<li><a href="../id427751/index.html">Gagasan Sublime CudaText</a></li>
<li><a href="../id427755/index.html">Rilis baru GitLab 11.4 dengan tinjauan rekan atas permintaan penggabungan dan bendera fitur</a></li>
<li><a href="../id427757/index.html">Prosesor X86 Rakitan Mikrokode di Belakang</a></li>
<li><a href="../id427759/index.html">Tentang solvabilitas masalah beltway dalam waktu polinomial</a></li>
<li><a href="../id427763/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 13: Protokol Jaringan, Bagian 1</a></li>
<li><a href="../id427767/index.html">Situasi: di Kanada mereka mengusulkan untuk memperkenalkan pajak streaming - kami sedang mendiskusikan apa masalahnya</a></li>
<li><a href="../id427771/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 13: Protokol Jaringan, Bagian 2</a></li>
<li><a href="../id427773/index.html">Saya menulis ekstensi lintas-browser untuk tab, tetapi Anda tidak melakukannya</a></li>
<li><a href="../id427775/index.html">Bot yang menyamar sebagai programmer mengoreksi kesalahan dalam kode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>