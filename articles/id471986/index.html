<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜¢ï¸ ğŸ¤¦ğŸ¾ ğŸ‘œ Tata Bahasa PEG Rekursif Kiri ğŸ˜© ğŸ˜· ğŸ‘¨ğŸ»â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menyebutkan rekursi kiri sebagai batu sandungan beberapa kali, dan inilah saatnya untuk mengetahuinya. Masalah utama adalah bahwa parser dengan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tata Bahasa PEG Rekursif Kiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p>  Saya menyebutkan rekursi kiri sebagai batu sandungan beberapa kali, dan inilah saatnya untuk mengetahuinya.  Masalah utama adalah bahwa parser dengan keturunan rekursif kiri langsung crash karena stack overflow. </p><br><div class="spoiler">  <b class="spoiler_title">Konten Seri Parser Python PEG</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengurai pasak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata Bahasa PEG Rekursif Kiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Tindakan ke Tata Bahasa PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata bahasa meta untuk pengurai PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan fitur PEG yang tersisa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEG pada Core Developer Sprint</a> </li></ul></div></div><br><p>  Pertimbangkan aturan tata bahasa hipotetis ini: </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p>  Jika kami menerapkan potongan tata bahasa ini ke metode parser rekursif kiri, kami akan mendapatkan sesuatu seperti berikut: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Jadi, <code>expr()</code> dimulai dengan panggilan ke <code>expr()</code> , yang dimulai dengan panggilan ke <code>expr()</code> , yang dimulai dengan panggilan ... Ini hanya dapat diakhiri dengan stack overflow, yang dinyatakan sebagai pengecualian <code>RecursionError</code> . </p><br><p>  Solusi tradisional adalah menulis ulang tata bahasa.  Di bagian sebelumnya, saya melakukan hal itu.  Bahkan, aturan tata bahasa di atas dapat ditulis ulang sebagai berikut: </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p>  Namun, pada langkah membangun pohon parse, bentuknya akan berbeda.  Ini dapat merusak situasi jika kita menambahkan operator <code>'-'</code> ke tata bahasa (karena <code>a - (b - c)</code> tidak sama dengan <code>(a - b) - c</code> ).  Ini biasanya diselesaikan dengan fungsi PEG yang lebih kuat, seperti pengelompokan dan iterasi, dan kita bisa menulis ulang aturan di atas sebagai: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p>  Sebenarnya, ini adalah bagaimana tata bahasa Python saat ini ditulis untuk pgen parser (yang memiliki masalah yang sama dengan aturan rekursif kiri). </p><br><p>  Namun, ada masalah kecil: karena operator seperti <code>'+'</code> dan <code>'-'</code> (dengan Python) sebagian besar adalah biner, ketika kita menganalisis sesuatu seperti <code>a + b + c</code> , kita harus melalui hasil parsing (yang pada dasarnya daftar <code>['a', '+', 'b', '+', 'c']</code> ) untuk membuat pohon parse rekursif kiri (yang akan terlihat seperti ini <code>[['a', '+', 'b'] , '+', 'c']</code> ). </p><br><p>  Tata bahasa rekursif kiri asli sudah mengisyaratkan asosiasi yang diinginkan, jadi alangkah baiknya untuk menghasilkan parser langsung dari formulir ini.  Dan kita bisa!  Seorang pembaca menunjukkan trik yang bagus dengan bukti matematika yang mudah diimplementasikan.  Sekarang saya akan coba jelaskan. </p><br><p>  Mari kita lihat contoh input <code>foo + bar + baz</code> .  Pohon parse yang ingin kita dapatkan dari ini berhubungan dengan <code>(foo + bar) + baz</code> .  Ini membutuhkan tiga panggilan rekursif kiri ke fungsi <code>expr()</code> : satu sesuai dengan operator tingkat atas <code>'+'</code> (yaitu, yang kedua);  satu lagi - ke operator internal <code>'+'</code> (mis. yang pertama);  dan yang ketiga adalah pilihan alternatif kedua (mis., <code>term</code> ). </p><br><p>  Karena saya tidak pandai menggambar diagram nyata menggunakan alat khusus, saya akan menunjukkan ini di sini menggunakan seni ASCII: </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p>  Idenya adalah bahwa dalam fungsi <code>expr()</code> , kita memerlukan "oracle" yang memberitahu kita apakah akan memilih alternatif pertama (yaitu, panggilan rekursif ke <code>expr()</code> ) atau yang kedua (yaitu, panggilan <code>term()</code> panggilan).  Pada panggilan pertama ke <code>expr()</code> oracle harus memberitahu kita untuk mengikuti alternatif pertama ( <code>expr()</code> );  dalam panggilan kedua (rekursif) - sama, tetapi pada panggilan ketiga harus meminta kita untuk memanggil <code>term()</code> .  Dalam kode tersebut, akan terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Bagaimana cara menulis ramalan seperti itu?  Mari kita lihat ... Kita dapat mencoba melacak jumlah panggilan <code>expr()</code> rekursif kiri) <code>expr()</code> di tumpukan panggilan dan membandingkannya dengan jumlah operator <code>'+'</code> dalam ekspresi berikut.  Jika tumpukan panggilan lebih dalam dari jumlah pernyataan, oracle akan mengembalikan false (memaksa kita untuk memilih <code>term()</code> ).  Saya tidak sabar untuk mengimplementasikan ini dengan <code>sys._getframe()</code> , tetapi ada cara yang lebih baik: mari balikkan tumpukan panggilan! </p><br><p>  Idenya adalah bahwa kita mulai dengan panggilan di mana oracle mengembalikan false, dan menyimpan hasilnya.  Ini memberi kita urutan <code>expr() -&gt; term() -&gt; 'foo'</code> .  (Seharusnya mengembalikan pohon parse untuk <code>term</code> awal, yaitu, <code>'foo'</code> . Kode di atas hanya mengembalikan <code>True</code> , tetapi di bagian kedua dari rangkaian artikel saya sudah menunjukkan cara mengembalikan pohon parse sebagai gantinya.) Peramalan seperti itu mudah diterapkan, karena seharusnya kembalikan <code>False</code> pada panggilan pertama - tidak ada tumpukan yang memeriksa atau mengintip masa depan yang diperlukan. </p><br><p>  Kemudian kami memanggil <code>expr()</code> lagi, dan kali ini oracle mengembalikan <code>True</code> , tetapi alih-alih panggilan rekursif kiri ke <code>expr()</code> kami mengganti hasil yang disimpan dari panggilan sebelumnya.  Dan karena operator yang diharapkan <code>'+'</code> dan token yang sesuai berikutnya juga hadir, ini akan memberi kita pohon parse untuk <code>foo + bar</code> . </p><br><p>  Sekali lagi kita ulangi algoritma, dan lagi semuanya ternyata: kali ini kita mendapatkan parsing tree untuk ekspresi penuh, dan itu benar-benar rekursif kiri ( <code>(foo + bar) + baz</code> ). </p><br><p>  Lalu kami ulangi algoritma itu lagi.  Tapi kali ini, meskipun Oracle mengembalikan <code>True</code> , dan hasil simpanan dari panggilan sebelumnya juga tersedia, tidak ada lagi operator <code>'+'</code> , dan alternatif pertama gagal.  Jadi, kami mencoba opsi kedua, yang berhasil, dan hanya menemukan istilah awal ( <code>'foo'</code> ).  Hasil ini lebih buruk daripada yang diperoleh dari alternatif pertama, jadi pada tahap ini kami berhenti dan menyimpan analisis terpanjang (mis. <code>(foo + bar) + baz</code> ). </p><br><p>  Untuk mengubahnya menjadi kode kerja, saya pertama-tama memodifikasi sedikit algoritma untuk menggabungkan panggilan <code>oracle()</code> dengan panggilan rekursif kiri ke <code>expr()</code> .  Sebut saja <code>oracle_expr()</code> .  Kode: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Selanjutnya, kita akan menulis pembungkus yang mengimplementasikan logika yang dijelaskan di atas.  Ini menggunakan variabel global (jangan khawatir, saya akan menyingkirkannya nanti).  Fungsi <code>oracle_expr()</code> akan membaca variabel global, dan wrapper akan mengendalikannya: </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p>  Kode, tentu saja, mengerikan, tetapi setidaknya itu menyampaikan esensi dari algoritma.  Mari kita refactor supaya kita bisa bangga dengannya. </p><br><p>  Pemahaman yang paling penting (yang menjadi milik saya, meskipun saya mungkin bukan yang pertama memperhatikan ini) adalah bahwa kita dapat menggunakan cache memoisasi alih-alih variabel global.  Di dalamnya kita akan menyimpan hasil dari panggilan ke panggilan.  Jadi kita menyingkirkan fungsi <code>oracle_expr()</code> , karena  kita dapat menghasilkan panggilan standar ke <code>expr()</code> terlepas dari apakah itu dalam posisi rekursif di sebelah kiri atau di sebelah kanan. </p><br><p>  Jadi, kita membutuhkan dekorator <code>@memoize_left_rec</code> terpisah, yang hanya digunakan untuk aturan rekursif kiri.  Ini memanggil fungsi <code>oracle_expr()</code> , menarik nilai yang disimpan dari cache memoisasi, dan berisi loop yang memanggil fungsi <code>expr()</code> beberapa kali, sampai setiap hasil baru sebanding dengan bagian yang lebih lama dari data input daripada yang sebelumnya.  Dan, tentu saja, karena setiap posisi input dan masing-masing metode parsing di-cache secara terpisah, itu tidak peduli tentang backtracking atau beberapa aturan rekursif (misalnya, dalam tata bahasa mainan yang saya gunakan, baik <code>expr</code> dan <code>term</code> dibiarkan rekursif). </p><br><p>  Kelebihan lain dari prototipe yang saya buat di bagian ketiga adalah membuatnya mudah untuk memeriksa apakah hasil baru lebih panjang dari yang lama: metode <code>mark()</code> mengembalikan indeks dalam array token input, jadi kita bisa menggunakannya daripada <code>parsed_length</code> . </p><br><p>  Saya menghilangkan bukti mengapa algoritma ini selalu bekerja, tidak peduli seberapa gilanya tata bahasanya.  Bahkan, saya bahkan tidak membacanya.  Saya melihat bahwa ini berfungsi untuk kasus-kasus sederhana, seperti <code>expr</code> dalam tata bahasa mainan saya, serta untuk kasus-kasus yang agak lebih rumit (misalnya, menggunakan rekursi kiri yang tersembunyi di balik elemen opsional dalam suatu alternatif, atau menggunakan rekursi bersama antara beberapa aturan).  Situasi paling sulit yang dapat saya ingat dalam tata bahasa Python masih diselesaikan oleh algoritma ini, jadi saya hanya percaya pada teorema dan orang-orang yang membuktikannya. </p><br><p>  Mari kita menulis kode pertempuran. </p><br><p>  Pertama, generator parser harus menentukan aturan mana yang dibiarkan rekursif.  Ini adalah masalah yang diselesaikan dalam teori grafik.  Saya tidak akan menunjukkan algoritme di sini, dan sebenarnya saya bahkan ingin lebih menyederhanakannya.  Saya berasumsi bahwa satu-satunya aturan kiri-rekursif dalam tata bahasa secara langsung kiri-rekursif, seperti <code>expr</code> dalam tata bahasa mainan kami.  Kemudian, untuk memeriksa kekambuhan kiri, Anda hanya perlu mencari alternatif yang akan dimulai dengan nama aturan saat ini: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Sekarang kita akan mengubah generator parser sehingga untuk aturan rekursif kiri menghasilkan dekorator lain.  Ingatlah bahwa di bagian ketiga, kami membungkus semua metode parser di <code>@memoize</code> .  Sekarang kita akan membuat satu perubahan kecil di generator sehingga untuk aturan rekursif kiri kita menggunakan <code>@memoize_left_rec</code> , dan kemudian kita akan menerapkan sihir dalam dekorator <code>memoize_left_rec</code> .  Sisa generator dan kode lainnya tidak perlu diubah!  (Meskipun saya harus mengutak-atik kode visualisasi) </p><br><p>  Untuk referensi, berikut adalah dekorator <code>@memoize</code> asli <code>@memoize</code> , disalin dari bagian 3. Ingat bahwa <code>self</code> adalah contoh <code>Parser</code> yang memiliki atribut <code>memo</code> (diinisialisasi dengan kamus kosong) dan <code>mark()</code> dan <code>reset()</code> metode yang mendapatkan dan mengatur posisi saat ini tokenizer: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  <code>@memoize</code> mengingat panggilan sebelumnya untuk setiap posisi dalam aliran input - untuk setiap posisi dalam array (malas) dari token input terdapat kamus <code>memo</code> terpisah.  Empat baris pertama <code>memoize_wrapper</code> didedikasikan untuk mendapatkan kamus <code>memo</code> benar. </p><br><p>  Dan ini adalah <code>@memoize_left_rec</code> .  Hanya cabang <code>else</code> yang sedikit berbeda dari implementasi di <code>@memoize</code> di atas: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p>  Mungkin menarik bagaimana ini bekerja untuk metode <code>expr()</code> .  Mari kita lihat bagaimana kode berikut akan dijalankan: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p>  Pada contoh parsing <code>foo + bar + baz</code> . </p><br><p>  Setiap kali Anda memanggil fungsi <code>expr()</code> , panggilan itu "ketagihan" oleh dekorator yang mencari panggilan sebelumnya di posisi saat ini.  Pada panggilan pertama, kita sampai ke cabang yang <code>else</code> , di mana kita berulang kali memanggil fungsi dihiasi <code>expr()</code> .  Tentunya, kita akan kembali ke dekorator terlebih dahulu, tetapi kali ini sudah ada nilai dalam cache, sehingga rekursi terputus. </p><br><p>  Apa yang terjadi selanjutnya?  Nilai cache awal dihitung pada baris ini: </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p>  Ini mengarah pada fakta bahwa <code>expr()</code> dikembalikan tidak <code>None</code> , setelah yang pertama <code>if</code> in <code>expr()</code> jatuh (ketika <code>expr: = self.expr()</code> ).  Artinya, kita beralih ke yang kedua <code>if</code> , yang berhasil mengenali <code>term</code> (dalam contoh kita, <code>'foo'</code> ) dan <code>expr</code> mengembalikan instance <code>Node</code> .  Dari mana kita akan kembali?  Untuk <code>while</code> di dekorator.  Kami memperbarui cache memoisasi dengan hasil baru (instance <code>Node</code> ), dan kemudian menjalankan iterasi berikutnya. </p><br><p>  <code>expr()</code> dipanggil lagi, dan kali ini panggilan rekursif yang dicegat mengembalikan instance <code>Node</code> (istilah) yang di-cache, dan kemudian melanjutkan ke panggilan yang <code>expect('+')</code> .  Semuanya beres, karena kita sekarang berada di operator <code>'+'</code> pertama.  Setelah itu, kami mencari istilah yang juga berhasil (ditemukan <code>'bar'</code> ). </p><br><p>  Jadi sekarang <code>expr()</code> , yang sudah dikenali <code>foo + bar</code> , kembali ke <code>while</code> , yang melakukan tindakan yang sama: memperbarui cache memoisasi dengan hasil yang baru (lebih lama) dan memulai iterasi berikutnya. </p><br><p>  Game ini diulangi lagi.  Sekali lagi, <code>expr()</code> panggilan rekursif yang dicegat <code>expr()</code> mengambil hasil baru (kali ini <code>foo + bar</code> ) dari cache, dan kami berharap melihat <code>'+'</code> (kedua) dan <code>term</code> lain ( <code>'baz'</code> ).  Kami membuat <code>Node</code> mewakili <code>(foo + bar) + baz</code> , dan mengembalikannya ke <code>while</code> , yang meletakkannya di cache dan mengulanginya lagi. </p><br><p>  Tapi sekarang kita akan pergi bersama cabang algoritma yang lain.  Kami berharap dapat bertemu <code>'+'</code> , tetapi tidak menemukannya!  Jadi, panggilan untuk <code>expr()</code> kembali ke alternatif kedua, dan hanya mengembalikan <code>term</code> .  Ketika ini muncul sebelum <code>while</code> , ternyata hasil ini lebih pendek dari yang terakhir.  Jadi itu memotong dan mengembalikan hasil yang lebih panjang ( <code>(foo + bar) + baz</code> ) kepada orang yang memprakarsai panggilan <code>expr()</code> (misalnya, panggilan <code>statement()</code> tidak ditampilkan di sini). </p><br><p>  Jadi, di sinilah kisah hari ini berakhir: kami berhasil menerapkan rekursi kiri dalam pengurai PEG.  Minggu depan saya berencana untuk membahas menambahkan "tindakan" ke tata bahasa, yang akan memungkinkan kita untuk menyesuaikan hasil yang dikembalikan oleh metode parser untuk alternatif ini (bukannya selalu mengembalikan instance <code>Node</code> ). </p><br><p>  Jika Anda ingin bermain-main dengan kode, periksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub</a> .  (Saya juga menambahkan kode visualisasi untuk rekursi kiri, tapi saya tidak cukup senang dengan itu, jadi saya tidak akan memberikan tautan ke sini.) </p><br><p>  Lisensi untuk artikel ini dan kode yang dikutip: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471986/">https://habr.com/ru/post/id471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471974/index.html">Bagaimana dua kapten menjadi jenderal: putih dan merah</a></li>
<li><a href="../id471976/index.html">Bagaimana seorang spesialis IT mendapatkan pekerjaan di luar negeri?</a></li>
<li><a href="../id471978/index.html">Kami tidak bisa mempercayai sistem AI yang dibangun di atas pembelajaran yang mendalam saja</a></li>
<li><a href="../id471980/index.html">Penipu telepon. Babak Empat, Final ...</a></li>
<li><a href="../id471982/index.html">Membahas masa depan PHP</a></li>
<li><a href="../id471988/index.html">Menambahkan Tindakan ke Tata Bahasa PEG</a></li>
<li><a href="../id471990/index.html">Tata bahasa meta untuk pengurai PEG</a></li>
<li><a href="../id471992/index.html">Menerapkan fitur PEG yang tersisa</a></li>
<li><a href="../id471994/index.html">Bekerja pada PEG pada Core Developer Sprint</a></li>
<li><a href="../id471998/index.html">F # 10: Daftar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>