<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèø üëÑ üßîüèª Transi√ß√£o do mon√≥lito para microsservi√ßos: hist√≥ria e pr√°tica üôãüèø üìÆ üßëüèø‚Äçü§ù‚Äçüßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre como o projeto no qual trabalho passou de um grande mon√≥lito para um conjunto de microsservi√ßos. 

 O projeto iniciou sua ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transi√ß√£o do mon√≥lito para microsservi√ßos: hist√≥ria e pr√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/458404/">  Neste artigo, falarei sobre como o projeto no qual trabalho passou de um grande mon√≥lito para um conjunto de microsservi√ßos. <br><br>  O projeto iniciou sua hist√≥ria h√° muito tempo, no in√≠cio de 2000. As primeiras vers√µes foram escritas no Visual Basic 6. Com o tempo, ficou claro que o desenvolvimento dessa linguagem no futuro seria dif√≠cil de suportar, uma vez que o IDE e a pr√≥pria linguagem s√£o pouco desenvolvidos.  No final dos anos 2000, foi decidido mudar para um C # mais promissor.  A nova vers√£o foi escrita em paralelo com o refinamento da antiga, gradualmente mais e mais c√≥digo estava no .NET.  O back-end em C # inicialmente focado na arquitetura de servi√ßo, no entanto, durante o desenvolvimento, bibliotecas compartilhadas com l√≥gica foram usadas e servi√ßos foram lan√ßados em um √∫nico processo.  Acabou o aplicativo, que chamamos de "mon√≥lito de servi√ßo". <br><br>  Uma das poucas vantagens desse pacote foi a capacidade dos servi√ßos de se chamarem atrav√©s de uma API externa.  Havia pr√©-requisitos √≥bvios para a transi√ß√£o para um servi√ßo mais correto e, no futuro, arquitetura de microsservi√ßo. <br><br>  Come√ßamos nosso trabalho de decomposi√ß√£o por volta de 2015.  Ainda n√£o atingimos um estado ideal - h√° partes de um grande projeto que s√£o dif√≠ceis de chamar de mon√≥litos, mas elas tamb√©m n√£o se parecem com microsservi√ßos.  No entanto, o progresso √© substancial. <br>  Eu vou falar sobre ele no artigo. <br><br><img src="https://habrastorage.org/webt/ha/af/ct/haafctbyxepfypvukpmypyt30ji.png"><br><a name="habracut"></a><br><h3>  Conte√∫do </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura e problemas da solu√ß√£o existente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Expectativas de microsservi√ßo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problemas de transi√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como mudar de mon√≥lito para microsservi√ßos</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira maneira</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda via</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terceira via</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quarta via</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhar com um banco de dados</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ramificar tabelas existentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Departamento de Processamento</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhando com c√≥digo fonte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problemas de infraestrutura</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instala√ß√£o manual em ambientes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Log separado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Servi√ßos relacionados a teste e depura√ß√£o</a> </li></ul></li></ul><br><br><a name="1"></a><h3>  Arquitetura e problemas da solu√ß√£o existente </h3><br>  Inicialmente, a arquitetura era a seguinte: A interface do usu√°rio √© um aplicativo separado, a parte monol√≠tica √© escrita no Visual Basic 6, o aplicativo no .NET era um conjunto de servi√ßos relacionados que trabalha com um banco de dados bastante grande. <br><br>  <b>Desvantagens da solu√ß√£o anterior</b> <br><br>  <u>Ponto √∫nico de falha</u> <br>  Tivemos um √∫nico ponto de falha: o aplicativo .NET foi executado em um processo.  Se algum dos m√≥dulos falhar, o aplicativo inteiro falhar√° e voc√™ precisar√° reinici√°-lo.  Como estamos automatizando um grande n√∫mero de processos para diferentes usu√°rios, devido a uma falha em um deles, alguns n√£o funcionaram por algum tempo.  E com um erro de software, a redund√¢ncia tamb√©m n√£o ajudou. <br><br>  <u>A linha de melhorias</u> <br>  Essa falha √© bastante organizacional.  Nossa aplica√ß√£o tem muitos clientes e todos desejam finaliz√°-la o mais r√°pido poss√≠vel.  Anteriormente, era imposs√≠vel fazer isso em paralelo, e todos os clientes ficavam na fila.  Esse processo causou um efeito negativo nos neg√≥cios, porque eles precisavam provar que sua tarefa era valiosa.  E a equipe de desenvolvimento passou um tempo organizando essa programa√ß√£o.  Isso exigiu muito tempo e esfor√ßo e, como resultado, o produto n√£o p√¥de ser alterado t√£o rapidamente quanto seria dele. <br><br>  <u>Uso inadequado de recursos</u> <br>  Ao colocar os servi√ßos em um √∫nico processo, sempre copiamos completamente a configura√ß√£o de servidor para servidor.  Quer√≠amos colocar os servi√ßos mais carregados separadamente, para n√£o desperdi√ßar recursos e obter um gerenciamento mais flex√≠vel de nosso esquema de implanta√ß√£o. <br><br>  <u>√â dif√≠cil introduzir tecnologia moderna</u> <br>  Um problema familiar a todos os desenvolvedores: h√° um desejo de introduzir tecnologias modernas no projeto, mas n√£o h√° possibilidade.  Com uma solu√ß√£o monol√≠tica grande, qualquer atualiza√ß√£o da biblioteca atual, sem mencionar a transi√ß√£o para uma nova, se transforma em uma tarefa n√£o trivial.  Demora muito tempo para provar ao l√≠der da equipe que ele trar√° mais b√¥nus do que os nervos gastos. <br><br>  <u>Dificuldade para emitir altera√ß√µes</u> <br>  Esse foi o problema mais s√©rio - lan√ßamos lan√ßamentos a cada dois meses. <br>  Cada lan√ßamento se transformou em um verdadeiro desastre para o banco, apesar dos testes e dos esfor√ßos dos desenvolvedores.  Os neg√≥cios entenderam que no in√≠cio da semana algumas das funcionalidades n√£o funcionariam para ele.  E os desenvolvedores entenderam que estavam esperando por uma semana de incidentes graves. <br>  Todos queriam mudar a situa√ß√£o. <br><br><a name="2"></a><h3>  Expectativas de microsservi√ßo </h3><br>  <u>Entrega de componentes mediante disponibilidade.</u>  Entrega dos componentes √† medida que se tornam dispon√≠veis devido √† decomposi√ß√£o da solu√ß√£o e separa√ß√£o de v√°rios processos. <br><br>  <u>Pequenas equipes de alimentos.</u>  Isso √© importante porque era dif√≠cil gerenciar uma grande equipe que trabalhava em um mon√≥lito antigo.  Essa equipe foi for√ßada a trabalhar de acordo com um processo rigoroso, mas eu queria mais criatividade e independ√™ncia.  Somente equipes pequenas podiam pagar. <br><br>  <u>Isolamento de servi√ßos em processos separados.</u>  Idealmente, eu queria isolar em cont√™ineres, mas um grande n√∫mero de servi√ßos escritos no .NET Framework s√£o executados apenas no Windows.  Agora, existem servi√ßos no .NET Core, mas at√© agora s√£o poucos. <br><br>  <u>Flexibilidade de implanta√ß√£o.</u>  Eu gostaria de combinar servi√ßos conforme necess√°rio, e n√£o como o c√≥digo for√ßa. <br><br>  <u>Uso de novas tecnologias.</u>  Isso √© interessante para qualquer programador. <br><br><a name="3"></a><h3>  Problemas de transi√ß√£o </h3><br>  Obviamente, se fosse simples dividir um mon√≥lito em microsservi√ßos, voc√™ n√£o precisaria falar sobre isso em confer√™ncias e escrever artigos.  Neste processo, existem muitas armadilhas, descreverei as principais que interferiram conosco. <br><br>  <b>O primeiro problema</b> √© t√≠pico da maioria dos mon√≥litos: a coer√™ncia da l√≥gica de neg√≥cios.  Quando escrevemos um mon√≥lito, queremos reutilizar nossas classes para n√£o escrever c√≥digo extra.  E ao mudar para microsservi√ßos, isso se torna um problema: todo o c√≥digo est√° bem conectado e √© dif√≠cil separar os servi√ßos. <br><br>  No in√≠cio do trabalho, o reposit√≥rio tinha mais de 500 projetos e mais de 700 mil linhas de c√≥digo.  Esta √© uma solu√ß√£o bastante grande e o <b>segundo problema</b> .  N√£o foi poss√≠vel simplesmente pegar e dividir em microsservi√ßos. <br><br>  <b>O terceiro problema</b> √© a falta de infraestrutura necess√°ria.  De fato, est√°vamos envolvidos na c√≥pia manual do c√≥digo fonte nos servidores. <br><br><a name="4"></a><h3>  Como mudar de mon√≥lito para microsservi√ßos </h3><br>  <u>Aloca√ß√£o de microsservi√ßos</u> <br><br>  Primeiro, imediatamente determinamos por n√≥s mesmos que a separa√ß√£o dos microsservi√ßos √© um processo iterativo.  Sempre fomos obrigados a conduzir o desenvolvimento de tarefas de neg√≥cios em paralelo.  Como vamos realizar isso tecnicamente j√° √© nosso problema.  Portanto, est√°vamos nos preparando para o processo iterativo.  N√£o funcionar√° de maneira diferente se voc√™ tiver um aplicativo grande e n√£o estiver pronto para ser reescrito desde o in√≠cio. <br><br>  Quais m√©todos usamos para isolar microsservi√ßos? <br><br><a name="5"></a>  <b>A primeira maneira</b> √© portar os m√≥dulos existentes como servi√ßos.  Nesse sentido, tivemos sorte: j√° havia servi√ßos formalizados que funcionavam no protocolo WCF.  Eles foram lan√ßados em montagens separadas.  N√≥s os movemos separadamente, adicionando um pequeno iniciador a cada montagem.  Foi escrito usando a maravilhosa biblioteca Topshelf, que permite executar o aplicativo como um servi√ßo e como um console.  Isso √© conveniente para depura√ß√£o, pois n√£o s√£o necess√°rios projetos adicionais na solu√ß√£o. <br><br>  Os servi√ßos foram conectados de acordo com a l√≥gica comercial, pois usavam assemblies comuns e trabalhavam com um banco de dados comum.  Era dif√≠cil cham√°-los de microsservi√ßos em sua forma pura.  No entanto, poder√≠amos emitir esses servi√ßos separadamente, em diferentes processos.  Isso j√° permitiu reduzir sua influ√™ncia um sobre o outro, reduzindo o problema com o desenvolvimento paralelo e um √∫nico ponto de falha. <br><br>  Construir com um host √© apenas uma linha de c√≥digo na classe Program.  Escondemos a prateleira superior em uma classe auxiliar. <br><br><pre><code class="plaintext hljs">namespace RBA.Services.Accounts.Host { internal class Program { private static void Main(string[] args) { HostRunner&lt;Accounts&gt;.Run("RBA.Services.Accounts.Host"); } } }</code> </pre> <br><a name="6"></a>  <b>A segunda maneira de isolar microsservi√ßos:</b> crie-os para resolver novos problemas.  Se o mon√≥lito n√£o cresce ao mesmo tempo, isso j√° √© excelente, o que significa que estamos nos movendo na dire√ß√£o certa.  Para resolver novos problemas, tentamos fazer servi√ßos separados.  Se houve essa oportunidade, criamos mais servi√ßos "can√¥nicos" que controlam completamente seu modelo de dados, um banco de dados separado. <br><br>  Como muitos, come√ßamos com servi√ßos de autentica√ß√£o e autoriza√ß√£o.  Eles s√£o perfeitos para isso.  Eles s√£o independentes, como regra, eles t√™m um modelo de dados separado.  Eles mesmos n√£o interagem com o mon√≥lito, apenas ele se volta para eles para resolver alguns problemas.  Nesses servi√ßos, voc√™ pode iniciar a transi√ß√£o para uma nova arquitetura, depurar a infraestrutura neles, experimentar algumas abordagens relacionadas √†s bibliotecas de rede etc.  Em nossa organiza√ß√£o, n√£o h√° equipes que n√£o pudessem fazer um servi√ßo de autentica√ß√£o. <br><br><a name="7"></a>  <b>A terceira maneira de isolar os microsservi√ßos</b> que usamos √© um pouco espec√≠fica para n√≥s.  Isso est√° retirando a l√≥gica de neg√≥cios da camada da interface do usu√°rio.  Temos o aplicativo principal da interface do usu√°rio da √°rea de trabalho, que, como o back-end, √© escrito em C #.  Os desenvolvedores periodicamente cometiam erros e executavam as partes da l√≥gica da interface do usu√°rio que deveriam existir no back-end e reutilizadas. <br><br>  Se voc√™ observar um exemplo real do c√≥digo da parte da interface do usu√°rio, poder√° ver que a maior parte desta solu√ß√£o cont√©m l√≥gica de neg√≥cios real, que √© √∫til em outros processos, n√£o apenas na cria√ß√£o de um formul√°rio de interface do usu√°rio. <br><br><img src="https://habrastorage.org/webt/7s/_e/rb/7s_erbatvtbzompywj94igyvwho.jpeg"><br><br>  A l√≥gica real da interface do usu√°rio existe apenas as duas √∫ltimas linhas.  N√≥s o transferimos para o servidor para podermos reutiliz√°-lo, reduzindo assim a interface do usu√°rio e alcan√ßando a arquitetura correta. <br><br><a name="8"></a>  <b>A quarta maneira mais importante de isolar microsservi√ßos</b> , o que permite reduzir o mon√≥lito, √© a remo√ß√£o dos servi√ßos existentes com o processamento.  Quando retiramos os m√≥dulos existentes, o resultado nem sempre √© agrad√°vel para os desenvolvedores e o processo de neg√≥cios a partir do momento em que a funcionalidade foi criada pode ficar desatualizado.  Gra√ßas √† refatora√ß√£o, podemos oferecer suporte a um novo processo comercial, porque os requisitos comerciais est√£o mudando constantemente.  Podemos melhorar o c√≥digo fonte, remover defeitos conhecidos, criar um melhor modelo de dados.  H√° muitas vantagens. <br><br>  O departamento de servi√ßos de processamento est√° intimamente ligado ao conceito de um contexto limitado.  Este √© um conceito do design orientado ao assunto.  Significa uma se√ß√£o de modelo de dom√≠nio na qual todos os termos de um √∫nico idioma s√£o definidos exclusivamente.  Considere o contexto de seguros e contas como um exemplo.  Temos uma aplica√ß√£o monol√≠tica e √© necess√°rio trabalhar com a conta no seguro.  Esperamos que o desenvolvedor encontre a classe "Account" existente em outro assembly, fa√ßa um link para ele a partir da classe "Insurance" e obteremos um c√≥digo funcional.  O princ√≠pio DRY ser√° respeitado, a tarefa atrav√©s do uso do c√≥digo existente ser√° realizada mais rapidamente. <br><br>  Como resultado, verifica-se que os contextos de contas e seguros est√£o conectados.  Quando novos requisitos surgem, essa conex√£o interfere no desenvolvimento, aumentando a complexidade de uma l√≥gica de neg√≥cios j√° complexa.  Para resolver esse problema, voc√™ precisa encontrar os limites entre os contextos no c√≥digo e remover suas viola√ß√µes.  Por exemplo, no contexto do seguro, √© bem poss√≠vel que o n√∫mero da conta de 20 d√≠gitos do Banco Central e a data de abertura da conta sejam suficientes. <br><br>  Para separar esses contextos limitados um do outro e iniciar o processo de extra√ß√£o de microsservi√ßos de uma solu√ß√£o monol√≠tica, usamos uma abordagem como a cria√ß√£o de APIs externas no aplicativo.  Se soub√©ssemos que algum m√≥dulo deveria se tornar um microsservi√ßo, de alguma forma mudar dentro do processo, imediatamente fizemos chamadas para a l√≥gica, que pertence a outro contexto limitado, atrav√©s de chamadas externas.  Por exemplo, atrav√©s de REST ou WCF. <br><br>  Decidimos por n√≥s mesmos que n√£o evitar√≠amos c√≥digo que exigiria transa√ß√µes distribu√≠das.  No nosso caso, foi bastante f√°cil cumprir essa regra.  Ainda n√£o encontramos essas situa√ß√µes em que transa√ß√µes realmente distribu√≠das s√£o realmente necess√°rias - a consist√™ncia final entre os m√≥dulos √© suficiente. <br><br>  Considere um exemplo espec√≠fico.  Temos o conceito de uma orquestra - transportadora, que processa a ess√™ncia da "aplica√ß√£o".  Ele alterna a cria√ß√£o de clientes, contas e cart√µes banc√°rios.  Se o cliente e a conta foram criados com √™xito e a cria√ß√£o do cart√£o falhou, o aplicativo n√£o entra no status "com √™xito" e permanece no status "cart√£o n√£o criado".  No futuro, a atividade em segundo plano ir√° busc√°-la e encerr√°-la.  O sistema est√° em estado de inconsist√™ncia por algum tempo, mas isso, no geral, nos conv√©m. <br><br>  Se, no entanto, surgir uma situa√ß√£o em que ser√° necess√°rio salvar parte dos dados de maneira consistente, provavelmente iremos aumentar o servi√ßo para processar isso em um √∫nico processo. <br><br>  Vamos considerar um exemplo de aloca√ß√£o de microsservi√ßo.  Como ele pode ser trazido para produ√ß√£o com relativa seguran√ßa?  Neste exemplo, temos uma parte separada do sistema - o m√≥dulo de servi√ßo de sal√°rio, uma das se√ß√µes do c√≥digo da qual gostar√≠amos de fazer microsservi√ßo. <br><br><img src="https://habrastorage.org/webt/g2/kn/he/g2knhebep6zxxcl-14mfdxd6xow.jpeg"><br><br>  Primeiro, criamos um microsservi√ßo reescrevendo o c√≥digo.  Melhoramos alguns pontos que n√£o nos agradaram.  Atendemos novos requisitos de neg√≥cios do cliente.  Adicionamos ao pacote entre a interface do usu√°rio e o back-end da API do Gateway, que fornecer√° o encaminhamento de chamadas. <br><br><img src="https://habrastorage.org/webt/g4/eo/sw/g4eoswb9nmxcoom9tbsug5quwsu.png"><br><br>  Em seguida, lan√ßamos essa configura√ß√£o em opera√ß√£o, mas no estado do piloto.  A maioria dos nossos usu√°rios ainda trabalha com processos de neg√≥cios antigos.  Para novos usu√°rios, estamos desenvolvendo uma nova vers√£o de um aplicativo monol√≠tico que esse processo n√£o cont√©m mais.  De fato, temos um monte de mon√≥litos e microsservi√ßos trabalhando na forma de um piloto. <br><br><img src="https://habrastorage.org/webt/vw/hn/p3/vwhnp3x9xxb1qrnz9rqe-552mvs.jpeg"><br><br>  Com um piloto bem-sucedido, entendemos que a nova configura√ß√£o √© realmente operacional, podemos remover o mon√≥lito antigo da equa√ß√£o e deixar a nova configura√ß√£o no lugar da solu√ß√£o antiga. <br><br><img src="https://habrastorage.org/webt/4w/pk/a3/4wpka3wcyexlk-ohyvab4vucbts.png"><br><br>  No total, usamos quase todos os m√©todos existentes para separar o c√≥digo fonte de um mon√≥lito.  Todos eles permitem reduzir o tamanho de partes do aplicativo e transferi-los para novas bibliotecas, criando um melhor c√≥digo-fonte. <br><br><a name="9"></a><h3>  <b>Trabalhar com um banco de dados</b> </h3><br>  O banco de dados pode ser dividido pior que o c√≥digo-fonte, pois cont√©m n√£o apenas o esquema atual, mas tamb√©m os dados hist√≥ricos acumulados. <br><br>  Nosso banco de dados, como muitos outros, teve outra desvantagem importante - seu tamanho enorme.  Esse banco de dados foi projetado de acordo com a l√≥gica comercial complexa do mon√≥lito, e os links foram acumulados entre tabelas de v√°rios contextos limitados. <br><br>  No nosso caso, al√©m de todos os problemas (um banco de dados grande, muitos relacionamentos, √†s vezes fronteiras incompreens√≠veis entre tabelas), surgiu um problema em muitos projetos grandes: usando o modelo de banco de dados compartilhado.  Os dados foram obtidos das tabelas atrav√©s da visualiza√ß√£o, atrav√©s da replica√ß√£o e enviados para outros sistemas onde essa replica√ß√£o √© necess√°ria.  Como resultado, n√£o foi poss√≠vel remover as tabelas em um esquema separado, porque elas foram usadas ativamente. <br><br>  A separa√ß√£o nos ajuda a dividir em contextos limitados no c√≥digo.  Geralmente, nos d√° uma boa id√©ia de como dividimos os dados no n√≠vel do banco de dados.  Entendemos quais tabelas se relacionam com um contexto limitado e quais se relacionam com outro. <br><br>  Aplicamos duas maneiras globais de particionar o banco de dados: particionando tabelas existentes e particionando com processamento. <br><br>  A separa√ß√£o de tabelas existentes √© um m√©todo que √© bom usar se a estrutura de dados for de alta qualidade, atender aos requisitos de neg√≥cios e atender a todos.  Nesse caso, podemos selecionar as tabelas existentes em um esquema separado. <br><br>  Um departamento de processamento √© necess√°rio quando o modelo de neg√≥cios mudou muito e as tabelas n√£o nos satisfazem completamente. <br><br><a name="10"></a>  <b>Separe as tabelas existentes.</b>  Precisamos determinar o que separaremos.  Sem esse conhecimento, nada resultar√°, e aqui a separa√ß√£o de contextos limitados no c√≥digo nos ajudar√°.  Como regra, se for poss√≠vel entender os limites dos contextos no c√≥digo-fonte, fica claro quais tabelas devem ser inclu√≠das na lista para separa√ß√£o. <br><br>  Imagine que temos uma solu√ß√£o na qual dois m√≥dulos monol√≠ticos interagem com um banco de dados.  Precisamos garantir que apenas um m√≥dulo interaja com a parte das tabelas separadas e o outro comece a interagir com ele atrav√©s da API.  Para iniciantes, basta que apenas uma entrada seja feita por meio da API.  Essa √© uma condi√ß√£o necess√°ria para que possamos falar sobre a independ√™ncia dos microsservi√ßos.  Os links de leitura podem permanecer at√© que haja um grande problema. <br><br><img src="https://habrastorage.org/webt/ed/tk/ea/edtkeafsmsewkmmwbaxh-nicpou.jpeg"><br><br>  Como pr√≥xima etapa, j√° podemos selecionar uma se√ß√£o de c√≥digo que funcione com tabelas separ√°veis ‚Äã‚Äãcom ou sem processamento em um microsservi√ßo separado e execut√°-la em um cont√™iner de processo separado.  Este ser√° um servi√ßo separado com comunica√ß√£o com o banco de dados monol√≠tico e com as tabelas que n√£o est√£o diretamente relacionadas a ele.  O mon√≥lito ainda interage com a parte destac√°vel para leitura. <br><br><img src="https://habrastorage.org/webt/39/xe/qp/39xeqpzjbsxcjtdxwh8_jgt4uxa.jpeg"><br><br>  Posteriormente removeremos essa conex√£o, ou seja, a leitura dos dados do aplicativo monol√≠tico das tabelas separadas tamb√©m ser√° transferida para a API. <br><br><img src="https://habrastorage.org/webt/qu/j9/hx/quj9hx6oj3ovg71xy_lge9ziovg.png"><br><br>  A seguir, selecionamos no banco de dados geral as tabelas com as quais apenas o novo microsservi√ßo funciona.  Podemos colocar tabelas em um esquema separado ou mesmo em um banco de dados f√≠sico separado.  Havia uma conex√£o para leitura entre o microsservi√ßo e o banco de dados monol√≠tico, mas n√£o h√° com o que se preocupar, pois nessa configura√ß√£o ele pode permanecer por um longo tempo. <br><br><img src="https://habrastorage.org/webt/os/uc/zq/osuczqkdtaoxzmdmii1oni3qhlm.png"><br><br>  O √∫ltimo passo √© remover completamente todas as conex√µes.  Nesse caso, talvez seja necess√°rio migrar dados do banco de dados principal.  √Äs vezes, queremos reutilizar em v√°rios bancos de dados alguns dados ou diret√≥rios replicados de sistemas externos.  Periodicamente, encontramos isso. <br><br><img src="https://habrastorage.org/webt/9e/ws/m9/9ewsm976maj96yzqj_-atbml4ae.png"><br><br><a name="11"></a>  <b>Departamento de processamento.</b>  Este m√©todo √© muito semelhante ao primeiro, apenas na ordem inversa.  Temos imediatamente um novo banco de dados e um novo microsservi√ßo que interage com o mon√≥lito por meio da API.  Mas, ao mesmo tempo, ainda existe um conjunto de tabelas de banco de dados que queremos excluir no futuro.  N√£o precisaremos mais dele, no novo modelo o substitu√≠mos. <br><br><img src="https://habrastorage.org/webt/fy/ic/jx/fyicjxxkjagnsd_acgimthenabs.png"><br><br>  Para que esse esquema funcione, provavelmente precisaremos de um per√≠odo de transi√ß√£o. <br><br>  Existem duas abordagens poss√≠veis. <br><br>  <b>Primeiro</b> : duplicamos todos os dados nos bancos de dados novos e antigos.  Nesse caso, temos redund√¢ncia de dados, pode haver problemas com a sincroniza√ß√£o.  Mas ent√£o podemos atender dois clientes diferentes.  Um ir√° trabalhar com a nova vers√£o, o outro com a antiga. <br><br>  <b>Segundo</b> : compartilhamos dados de acordo com alguma caracter√≠stica do neg√≥cio.  Por exemplo, em nosso sistema, havia 5 produtos armazenados no banco de dados antigo.  O sexto como parte de uma nova tarefa de neg√≥cios, colocamos em um novo banco de dados.  Mas precisamos da API do Gateway, que sincroniza esses dados e mostra ao cliente onde e o que levar. <br><br>  Ambas as abordagens est√£o funcionando, escolha de acordo com a situa√ß√£o. <br><br>  Depois de garantir que tudo funcione, a parte do mon√≥lito que funciona com as estruturas antigas do banco de dados pode ser desativada. <br><br><img src="https://habrastorage.org/webt/1j/tf/tg/1jtftgwoy_c-bcfa8yddp5whppc.png"><br><br>  A etapa final √© remover as estruturas de dados antigas. <br><br><img src="https://habrastorage.org/webt/4r/4o/m_/4r4om_wgj3wwxi25mf45eg_umss.png"><br><br>  Resumindo, podemos dizer que temos problemas com o banco de dados: √© dif√≠cil trabalhar com ele comparado ao c√≥digo fonte, √© mais dif√≠cil separar, mas isso pode e deve ser feito.  Encontramos algumas maneiras que permitem que isso seja feito com seguran√ßa, mas √© mais f√°cil cometer um erro com os dados do que com o c√≥digo-fonte. <br><br><a name="12"></a><h3>  <b>Trabalhando com c√≥digo fonte</b> </h3><br>  √â assim que o diagrama do c√≥digo fonte era quando come√ßamos a analisar um projeto monol√≠tico. <br><br><img src="https://habrastorage.org/webt/wx/z2/2m/wxz22mn86ej9jfyhkjww7zmvnoe.png"><br><br>  Pode ser condicionalmente dividido em tr√™s camadas.  Essa √© uma camada de m√≥dulos, plugins, servi√ßos e atividades individuais lan√ßados.  De fato, esses eram os pontos de entrada na solu√ß√£o monol√≠tica.  Todos eles estavam fortemente ligados a uma camada comum.  Ele tinha l√≥gica comercial compartilhada entre servi√ßos e muitas conex√µes.  Cada servi√ßo e plug-in usava at√© 10 ou mais assemblies comuns, dependendo do tamanho e da consci√™ncia dos desenvolvedores. <br><br>  Tivemos sorte, t√≠nhamos bibliotecas de infraestrutura que podiam ser usadas separadamente. <br><br>  √Äs vezes, surgiu uma situa√ß√£o em que alguns dos objetos Comuns na verdade n√£o pertenciam a essa camada, mas eram bibliotecas de infraestrutura.  Isso foi decidido renomeando. <br><br>  Mais preocupado com contextos limitados.  Costumava ser que 3-4 contextos se misturavam em uma montagem comum e se usavam nas mesmas fun√ß√µes de neg√≥cios.  Era necess√°rio entender onde isso pode ser dividido e em quais limites, e o que fazer em seguida com o mapeamento dessa separa√ß√£o em assemblies de c√≥digo-fonte. <br><br>  N√≥s formulamos v√°rias regras para o processo de separa√ß√£o de c√≥digo. <br><br>  <b>Primeiro</b> : n√£o quer√≠amos mais compartilhar a l√≥gica de neg√≥cios entre servi√ßos, atividades e plugins.  Eles queriam tornar a l√≥gica de neg√≥cios independente dentro da estrutura de microsservi√ßos.  Por outro lado, os microsservi√ßos, no caso ideal, s√£o percebidos como servi√ßos que existem de forma completamente independente.  Acredito que essa abordagem seja um pouco in√∫til, e √© dif√≠cil alcan√ß√°-la, porque, por exemplo, os servi√ßos em C # ser√£o, em qualquer caso, conectados por uma biblioteca padr√£o.  Nosso sistema est√° escrito em C #, outras tecnologias ainda n√£o foram usadas.  Portanto, decidimos que podemos dar ao luxo de usar conjuntos t√©cnicos comuns.  O principal √© que eles n√£o possuem fragmentos da l√≥gica de neg√≥cios.  Se voc√™ tiver um inv√≥lucro conveniente sobre o ORM usado, copi√°-lo de servi√ßo para servi√ßo √© muito caro. <br><br>  Nossa equipe √© f√£ do design orientado ao assunto, portanto a "arquitetura da cebola" √© perfeita para n√≥s.  A base de nossos servi√ßos n√£o era uma camada de acesso a dados, mas uma montagem com l√≥gica de dom√≠nio, que cont√©m apenas l√≥gica de neg√≥cios e √© desprovida de conex√µes de infraestrutura.  Ao mesmo tempo, podemos modificar independentemente o conjunto do dom√≠nio para resolver os problemas associados √†s estruturas. <br><br>  Nesta fase, encontramos o primeiro problema s√©rio.  O servi√ßo deveria se referir a um assembly de dom√≠nio, quer√≠amos tornar a l√≥gica independente e, aqui, o princ√≠pio DRY interferiu fortemente conosco.  Para evitar duplica√ß√£o, os desenvolvedores queriam reutilizar classes de assemblies vizinhos e, como resultado, os dom√≠nios come√ßaram a se comunicar novamente.  Analisamos os resultados e decidimos que talvez o problema tamb√©m esteja na √°rea do dispositivo de armazenamento do c√≥digo-fonte.  T√≠nhamos um grande reposit√≥rio no qual estavam todos os c√≥digos-fonte.  A solu√ß√£o para todo o projeto foi muito dif√≠cil de montar em uma m√°quina local.  Portanto, pequenas solu√ß√µes separadas foram criadas para as partes do projeto e ningu√©m proibiu a adi√ß√£o de nenhum assembly Comum ou de dom√≠nio a elas e a sua reutiliza√ß√£o.  A √∫nica ferramenta que n√£o nos permitiu fazer isso foi o c√≥digo de revis√£o.  Mas √†s vezes ele tamb√©m caiu. <br><br>  Ent√£o come√ßamos a mudar para um modelo com reposit√≥rios separados.  A l√≥gica comercial deixou de fluir de servi√ßo em servi√ßo; os dom√≠nios se tornaram verdadeiramente independentes.  Contextos limitados s√£o suportados com mais clareza.  Como reutilizamos as bibliotecas de infraestrutura?  N√≥s os alocamos em um reposit√≥rio separado e os colocamos nos pacotes Nuget que colocamos no Artifactory.  Com qualquer altera√ß√£o, a montagem e a publica√ß√£o ocorrem automaticamente. <br><br><img src="https://habrastorage.org/webt/so/tk/g_/sotkg_uskgxq41d3swhkewhkzcy.png"><br><br>  Nossos servi√ßos come√ßaram a se referir a pacotes de infraestrutura interna da mesma maneira que a externos.  Fazemos o download de bibliotecas externas do Nuget.  Para trabalhar com o Artifactory, onde colocamos esses pacotes, usamos dois gerenciadores de pacotes.  Em pequenos reposit√≥rios, tamb√©m usamos o Nuget.  Nos reposit√≥rios com v√°rios servi√ßos, usamos o Paket, que fornece mais consist√™ncia de vers√£o entre os m√≥dulos. <br><br><img src="https://habrastorage.org/webt/dr/0g/qe/dr0gqecxnqni4wcer4m1ogw-x70.png"><br><br>  Assim, trabalhando no c√≥digo fonte, alterando ligeiramente a arquitetura e compartilhando reposit√≥rios, tornamos nossos servi√ßos mais independentes. <br><br><a name="13"></a><h3>  <b>Problemas de infraestrutura</b> </h3><br>  A maioria das desvantagens da mudan√ßa para microsservi√ßos est√° relacionada √† infraestrutura.  Voc√™ precisar√° de implanta√ß√£o automatizada, novas bibliotecas para a infraestrutura. <br><br><a name="16"></a>  <b>Instala√ß√£o manual em ambientes</b> <br><br>  Inicialmente, instalamos a solu√ß√£o no ambiente manualmente.  Para automatizar esse processo, criamos um pipeline de CI / CD.  Escolhemos o processo de entrega cont√≠nua, porque a implanta√ß√£o cont√≠nua para n√≥s ainda n√£o √© aceit√°vel do ponto de vista dos processos de neg√≥cios.  Portanto, o envio para opera√ß√£o √© realizado pelo bot√£o e para teste - automaticamente. <br><br><img src="https://habrastorage.org/webt/vz/lp/yw/vzlpyw7h9ej1gdxvkzqwivl_gqu.png"><br><br>  Usamos Atlassian, Bitbucket para armazenar o c√≥digo-fonte e Bamboo para montagem.  Gostamos de escrever scripts de montagem no Cake, porque √© o mesmo C #.  Pacotes prontos chegam ao Artifactory, e o Ansible chega automaticamente aos servidores de teste, ap√≥s o que eles podem ser testados imediatamente. <br><br><img src="https://habrastorage.org/webt/-g/5p/dn/-g5pdnzpev-odvgxu-woy7qtcny.png"><br><br><a name="14"></a><h3>  <b>Log separado</b> </h3><br>  Ao mesmo tempo, uma das id√©ias do mon√≥lito era o fornecimento de explora√ß√£o conjunta.  Tamb√©m precisamos entender o que fazer com os logs individuais que se encontram nos discos.  Os registros s√£o gravados para n√≥s em arquivos de texto.  Decidimos usar a pilha ELK padr√£o.  N√£o gravamos diretamente no ELK por meio de provedores, mas decidimos finalizar os logs de texto e anotar o ID de rastreamento neles como um identificador, adicionando o nome do servi√ßo para que esses logs pudessem ser analisados. <br><br><img src="https://habrastorage.org/webt/e5/pd/ws/e5pdwsgrrb-9cpjhxabejxqdpt8.png"><br><br>  Usando o Filebeat, temos a oportunidade de coletar nossos logs dos servidores e convert√™-los, usando o Kibana para criar solicita√ß√µes na interface do usu√°rio e observar como foi a chamada entre os servi√ßos.  O ID de rastreamento ajuda muito nisso. <br><br><a name="15"></a><h3>  <b>Servi√ßos relacionados a teste e depura√ß√£o</b> </h3><br>  Inicialmente, n√£o entendemos completamente como depurar servi√ßos desenvolvidos.  Tudo era simples com o mon√≥lito, rodamos na m√°quina local.  No in√≠cio, eles tentaram fazer o mesmo com os microsservi√ßos, mas √†s vezes para iniciar completamente um microsservi√ßo, √© necess√°rio iniciar v√°rios outros, o que √© inconveniente.  ,     ,          ,   .     ,     prod.  ,  ,          .  ,     ,        . <br><br>  ,     production- .      ,         . <br><br>           Specflow.      NUnit     Ansible.     ,      .   -    .  ,      ,     Jira. <br><br>      ,       .      JMeter,    ‚Äî InfluxDB,      ‚Äî Grafana. <br><br><h3> <b>  ?</b> </h3><br> -,     ¬´¬ª.    ,      production-,    -.        1,5 ,  ,        . <br><br>      .      ,       ,      .     . <br><br>     .        ,     . <br><br>  ,        .      ,      .     Scrum-.        ,    . <br><br><h3> <b></b> </h3><br><ul><li>       .     ,     ,    ,    .            . </li><li>    .        ,        ,     .    ,         , ,     Scrum. </li><li>  ‚Äî   .        .      .       legacy,      ,            . <br><br> <i> :</i>       .        . ,     ,     ,     ,        , , ,  ‚Äî   ,    .   .     ,     ,          . <br><br> PS    (    ) ‚Äì  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br>    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458404/">https://habr.com/ru/post/pt458404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458390/index.html">Ceph - de "no joelho" a "produ√ß√£o" parte 2</a></li>
<li><a href="../pt458394/index.html">Protegendo protocolos sem fio usando o LoRaWAN como exemplo</a></li>
<li><a href="../pt458396/index.html">Como eu tornei o desenvolvimento no Vue.js conveniente com a renderiza√ß√£o no servidor</a></li>
<li><a href="../pt458398/index.html">Higiene do trabalho remoto ou os benef√≠cios da telepatia</a></li>
<li><a href="../pt458400/index.html">Arquitetura e implementa√ß√£o de microsservi√ßos passo a passo, parte 1</a></li>
<li><a href="../pt458406/index.html">Mais de 30 perguntas sobre programas utilit√°rios e n√£o utilit√°rios</a></li>
<li><a href="../pt458408/index.html">Semana 27 de Seguran√ßa: vulnerabilidades da bomba de insulina</a></li>
<li><a href="../pt458410/index.html">Como desenvolver uma estrutura de loja online com base em cluster e lematiza√ß√£o de sem√¢ntica</a></li>
<li><a href="../pt458412/index.html">O blockchain est√° aqui apenas para rela√ß√µes p√∫blicas e hype?</a></li>
<li><a href="../pt458414/index.html">Como mudar sua carreira, tornar-se desenvolvedor front-end aos 30 anos e trabalhar √† vontade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>