<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüíª ü§ß üïï O primeiro problema do visualizador ou as dificuldades de converter fluxos de v√≠deo WebRTC em HLS üë©üèæ‚Äçü§ù‚Äçüë®üèø üçê üèÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="George fechou o laptop e esfregou os olhos vermelhos privados de sono. "Os clientes continuam reclamando sobre o congelamento do fluxo; o novo pacote ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O primeiro problema do visualizador ou as dificuldades de converter fluxos de v√≠deo WebRTC em HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/481668/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  George fechou o laptop e esfregou os olhos vermelhos privados de sono.  "Os clientes continuam reclamando sobre o congelamento do fluxo; o novo pacote de corre√ß√µes n√£o ajudou em nada! O que fa√ßo com este HLS (censurado)?"  ele disse. </p><br><h2 id="the-browser-is-not-only-hypertext-but-also-a-streamer">  O navegador n√£o √© apenas um hipertexto, mas tamb√©m uma serpentina </h2><br><p>  Os navegadores possuem players h√° muito tempo, mas a hist√≥ria √© diferente com o codificador de v√≠deo e o streaming.  Agora, em quase qualquer navegador da vers√£o mais recente, podemos encontrar m√≥dulos para codifica√ß√£o, streaming, decodifica√ß√£o e reprodu√ß√£o.  Essas fun√ß√µes est√£o dispon√≠veis atrav√©s da API JavaScript e a implementa√ß√£o √© chamada Web Real Time Communications ou WebRTC.  Essa biblioteca incorporada nos navegadores pode fazer bastante: capturar v√≠deo de uma c√¢mera embutida, virtual ou USB, compact√°-lo com os codecs H.264, VP8 e VP9 e envi√°-lo √† rede via protocolo SRTP;  isto √©, funciona como um codificador de v√≠deo de serpentina de software.  Como resultado, vemos um navegador que tem algo semelhante ao ffmpeg ou gstreamer, compacta bem o v√≠deo, transmite em RTP e reproduz fluxos de v√≠deo. </p><a name="habracut"></a><br><p>  O WebRTC nos d√° a liberdade de implementar uma variedade de casos de streaming em JavaScript: </p><br><ul><li>  transmitir do navegador para o servidor para grava√ß√£o e distribui√ß√£o subsequente </li><li>  distribuir fluxos ponto a ponto </li><li>  reproduzir o fluxo de outro usu√°rio e enviar o seu pr√≥prio (bate-papo por v√≠deo) </li><li>  converter outros protocolos pelo servidor, por exemplo, RTMP, RTSP, etc., e reproduzi-los no navegador como WebRTC </li></ul><br><p>  Os scripts de controle de fluxo refinados podem ter esta apar√™ncia: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Launching broadcast from browser to server session.createStream({name:‚Äùmystream‚Äù}).publish(); //Playing broadcast by the browser session.createStream({name:‚Äùmystream‚Äù}).play();</span></span></code> </pre> <br><h2 id="hls-works-where-webrtc-does-not-work">  HLS funciona onde o WebRTC n√£o funciona </h2><br><p>  O WebRTC √© executado nas vers√µes mais recentes dos navegadores, no entanto, existem os dois fatores a seguir: 1) Nem todos os usu√°rios atualizam seus navegadores em tempo h√°bil e podem usar a vers√£o antiga do Chrome por tr√™s anos.  2) Atualiza√ß√µes e novos navegadores, o WebView, assim como outros clientes e mensageiros instant√¢neos que ajudam os usu√°rios a navegar na Internet s√£o lan√ßados quase uma vez por semana.  Escusado ser√° dizer que nem todos eles t√™m suporte WebRTC e, se tiverem, pode ser limitado.  Veja como est√£o as coisas agora: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Os dispositivos favoritos de todos da Apple podem ser uma dor de cabe√ßa.  Eles come√ßaram a dar suporte ao WebRTC apenas recentemente e, √†s vezes, seu comportamento em compara√ß√£o com os navegadores de kits da web pode parecer surpreendente.  Onde o WebRTC n√£o funciona ou n√£o funciona muito bem, o HLS funciona bem.  Nesse sentido, √© necess√°ria compatibilidade, e algo como um conversor que nos permita converter o WebRTC para HLS e reproduzi-lo em praticamente qualquer dispositivo. </p><br><p>  O HLS n√£o foi originalmente concebido para fluxos em tempo real.  De fato, como podemos transmitir v√≠deo em tempo real via HTTP?  A tarefa do HLS √© cortar o v√≠deo em peda√ßos e entreg√°-lo ao player sem problemas, sem pressa, baixando-o um por um.  Um player HLS espera um fluxo de v√≠deo estritamente formado e suave.  Aqui temos um conflito, j√° que o WebRTC, ao contr√°rio, pode se dar ao luxo de perder pacotes devido a requisitos em tempo real e baixa lat√™ncia e ter um FPS / GOP flutuante e uma taxa de bits vari√°vel - ser exatamente o oposto do HLS em termos de previsibilidade e regularidade do fluxo. </p><br><p>  Uma abordagem √≥bvia - a despacketization (WebRTC) (SRTP) e a subsequente <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">convers√£o para HLS</a> podem n√£o funcionar em um player Apple HLS nativo ou funcionar com congelamento, que √© um formato inadequado para produ√ß√£o.  O player nativo significa um player usado no Apple iOS Safari, Mac OS Safari e Apple TV. </p><br><p>  Portanto, se voc√™ observar o congelamento do HLS no player nativo, talvez seja esse o caso, e a origem do fluxo seja WebRTC ou outro fluxo din√¢mico com marca√ß√£o irregular.  Al√©m disso, na implementa√ß√£o dos players nativos da Apple, existe um comportamento que s√≥ pode ser entendido empiricamente.  Por exemplo, o servidor deve come√ßar a enviar segmentos HLS imediatamente ap√≥s o retorno da lista de reprodu√ß√£o m3u8.  Um atraso de 1 segundo pode resultar em congelamento.  Se a configura√ß√£o do fluxo de bits tiver sido alterada no processo (o que √© bastante comum durante o streaming do WebRTC), tamb√©m haver√° congelamento. </p><br><h2 id="fighting-freezing-in-native-players">  Combate ao congelamento em jogadores nativos </h2><br><p>  Assim, a despacketization WebRTC e a embalagem HLS geralmente n√£o funcionam.  No <a href="https://flashphoner.com/">servidor de</a> streaming de v√≠deo do <a href="https://flashphoner.com/">Web Call Server (WCS)</a> , resolvemos o problema de duas maneiras e oferecemos o terceiro como alternativa: </p><br><p>  1) Transcodifica√ß√£o. </p><br><p>  Essa √© a maneira mais confi√°vel de alinhar um fluxo WebRTC com os requisitos de HLS, definir o GOP, FPS desejado etc.  No entanto, em alguns casos, a transcodifica√ß√£o n√£o √© uma boa solu√ß√£o;  por exemplo, transcodificando fluxos de 4k <br>  de v√≠deo VR √© realmente uma m√° ideia.  Tais fluxos pesados ‚Äã‚Äãs√£o muito caros para transcodificar em termos de tempo de CPU ou recursos de GPU. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Adapta√ß√£o e alinhamento do fluxo WebRTC em movimento para atender aos requisitos de HLS. </p><br><p>  Estes s√£o analisadores especiais que analisam o fluxo de bits H.264 e o ajustam para corresponder aos recursos / bugs dos players HLS nativos da Apple.  √â certo que jogadores n√£o nativos como video.js e hls.js s√£o mais tolerantes com fluxos <br>  com taxa de bits din√¢mica e FPS em execu√ß√£o no WebRTC e n√£o diminua a velocidade onde a implementa√ß√£o de refer√™ncia do Apple HLS resulta essencialmente em congelamento. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Usando RTMP como fonte de fluxo em vez de WebRTC. </p><br><p>  Apesar do Flash player j√° estar obsoleto, o protocolo RTMP √© usado ativamente para streaming;  Veja o OBS Studio, por exemplo.  Devemos reconhecer que os codificadores RTMP produzem geralmente mais <br>  fluxos que WebRTC e, portanto, praticamente n√£o causam congelamento no HLS, ou seja, a convers√£o RTMP&gt; HLS parece muito mais adequada em termos de congelamento, inclusive em players nativos de HLS.  Portanto, se a transmiss√£o for <br>  feito usando a √°rea de trabalho e o OBS, √© melhor us√°-lo para a convers√£o em HLS.  Se a fonte for o navegador Chrome, o RTMP n√£o poder√° ser usado sem a instala√ß√£o de plug-ins e apenas o WebRTC funcionar√° nesse caso. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"><br>  Todos os tr√™s m√©todos descritos acima foram testados e funcionam, para que voc√™ possa escolher com base na tarefa. </p><br><h2 id="webrtc-to-hls-on-cdn">  WebRTC para HLS na CDN </h2><br><p>  Existem alguns indesej√°veis ‚Äã‚Äãque voc√™ encontrar√° em um sistema distribu√≠do quando houver v√°rios servidores de entrega de fluxo WebRTC entre a fonte de fluxo WebRTC e o player HLS, ou seja, <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN</a> , no nosso caso, com base em um servidor WCS.  √â assim: Existe o Origin - um servidor que aceita o fluxo WebRTC e o Edge - servidores que distribuem esse fluxo, inclusive via HLS.  Pode haver muitos servidores, o que permite o dimensionamento horizontal do sistema.  Por exemplo, 1000 servidores HLS podem ser conectados a um servidor Origin;  nesse caso, a capacidade do sistema √© escalada 1000 vezes. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  O problema j√° foi destacado acima;  geralmente surge em players nativos: iOS Safari, Mac OS Safari e Apple TV.  Por nativo, queremos dizer um jogador que trabalha com uma indica√ß√£o direta do URL da playlist em <br>  a tag, por exemplo <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Assim que o jogador solicita uma lista de reprodu√ß√£o - e essa a√ß√£o √© realmente o primeiro passo na reprodu√ß√£o do fluxo HLS - o servidor deve imediatamente, sem <br>  atraso, comece a enviar segmentos de v√≠deo HLS.  Se o servidor n√£o come√ßar a enviar segmentos imediatamente, o jogador decidir√° que foi enganado e parar√° de jogar.  Esse comportamento √© t√≠pico dos players HLS nativos da Apple, mas n√£o podemos apenas dizer aos usu√°rios "por favor, n√£o use o iPhone Mac e o Apple TV para reproduzir fluxos HLS". </p><br><p>  Portanto, quando voc√™ tenta reproduzir um fluxo HLS no servidor de Borda, o servidor deve come√ßar imediatamente a retornar segmentos, mas como ele deve ser feito se n√£o tiver um fluxo?  De fato, quando voc√™ tenta jogar, h√° <br>  n√£o h√° fluxo neste servidor.  A l√≥gica da CDN funciona com o princ√≠pio do Lazy Loading - n√£o carrega o fluxo no servidor at√© que algu√©m solicite esse fluxo neste servidor.  H√° um problema da primeira conex√£o <br>  usu√°rio;  o primeiro que solicitou o fluxo HLS do servidor de borda e teve a imprud√™ncia de fazer isso no Apple player padr√£o ficar√° congelado pelo motivo de levar algum tempo para solicitar esse fluxo <br>  no servidor Origin, coloque-o no Edge e inicie o fatiamento HLS.  Mesmo se demorar tr√™s segundos, isso n√£o ajudar√°.  Vai congelar. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Aqui temos duas solu√ß√µes poss√≠veis: uma √© OK e a outra √© menos.  Pode-se abandonar a abordagem Lazy Loading na CDN e enviar tr√°fego para todos os n√≥s, independentemente de haver ou n√£o visualizadores.  Uma solu√ß√£o, possivelmente adequada para quem n√£o est√° limitado em recursos de tr√°fego e computa√ß√£o.  O Origin enviar√° tr√°fego para todos os servidores de Borda, como resultado, todos os servidores e a rede entre eles ser√£o carregados constantemente.  Talvez esse esquema seja adequado apenas para algumas solu√ß√µes espec√≠ficas com um pequeno n√∫mero de fluxos de entrada.  Ao replicar um grande n√∫mero de fluxos, esse esquema ser√° claramente <br>  ineficiente em termos de recursos.  E se voc√™ se lembra de que estamos apenas resolvendo o ‚Äúproblema do primeiro usu√°rio conectado a partir do navegador nativo‚Äù, fica claro que n√£o vale a pena. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  A segunda op√ß√£o √© mais elegante, mas tamb√©m √© apenas uma solu√ß√£o alternativa.  Damos ao primeiro usu√°rio conectado uma imagem de v√≠deo, mas ainda n√£o √© o fluxo que ele deseja ver - este √© um pr√©-carregador.  Como j√° devemos fornecer algo a eles e faz√™-lo imediatamente, mas n√£o temos o fluxo de origem (ele ainda est√° sendo solicitado e entregue pela Origin), decidimos pedir ao cliente que espere um pouco e mostre a eles um v√≠deo do <br>  preloader com anima√ß√£o em movimento.  O usu√°rio espera alguns segundos enquanto o pr√©-carregador gira, e quando o fluxo real finalmente chega, o usu√°rio come√ßa a obter o fluxo real.  Como resultado, o primeiro usu√°rio ver√° o <br>  preloader e aqueles que se conectarem depois disso finalmente ver√£o o fluxo HLS regular vindo da CDN operando com o princ√≠pio Lazy Loading.  Assim, o problema de engenharia foi resolvido. </p><br><h2 id="but-not-yet-fully-solved">  Mas ainda n√£o totalmente resolvido </h2><br><p>  Parece que tudo funciona bem.  A CDN est√° funcionando, os fluxos HLS s√£o carregados dos servidores de Borda e o problema do primeiro usu√°rio conectado √© resolvido.  E aqui est√° outra armadilha - damos a <br>  pr√©-carregador em uma propor√ß√£o fixa de 16: 9, enquanto fluxos de qualquer formato podem entrar no CDN: 16: 9, 4: 3, 2: 1 (v√≠deo VR).  E isso √© um problema, porque se voc√™ enviar um pr√©-carregador no formato 16: 9 para o player e o fluxo ordenado for 4: 3, o player nativo voltar√° a congelar. </p><br><p>  Portanto, surge uma nova tarefa - voc√™ precisa saber com qual propor√ß√£o o fluxo entra na CDN e fornecer a mesma propor√ß√£o ao pr√©-carregador.  Um recurso dos fluxos WebRTC √© a preserva√ß√£o da propor√ß√£o quando <br>  altera√ß√£o da resolu√ß√£o e transcodifica√ß√£o - se o navegador decide diminuir a resolu√ß√£o, diminui-a na mesma propor√ß√£o.  Se o servidor decidir transcodificar o fluxo, ele manter√° a propor√ß√£o na mesma propor√ß√£o.  Portanto, faz sentido que, se queremos mostrar o pr√©-carregador para HLS, mostremos na mesma propor√ß√£o em que o fluxo entra. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  A CDN funciona da seguinte maneira: quando o tr√°fego entra no servidor Origin, ele informa outros servidores na rede, incluindo servidores Edge, sobre o novo fluxo.  O problema √© que, neste momento, a resolu√ß√£o do <br>  o fluxo de origem ainda n√£o pode ser conhecido.  A resolu√ß√£o √© realizada pelas configura√ß√µes de fluxo de bits H.264 junto com o quadro-chave.  Portanto, o servidor de borda pode receber informa√ß√µes sobre um fluxo, mas n√£o saber√° sobre seus <br>  resolu√ß√£o e propor√ß√£o, o que n√£o permitir√° gerar corretamente o pr√©-carregador.  Nesse sentido, √© necess√°rio sinalizar a presen√ßa do fluxo na CDN apenas se houver um quadro-chave - isso garante informa√ß√µes ao tamanho do servidor Edge e permite que o pr√©-carregador correto seja gerado para evitar ‚Äúo primeiro problema de visualizador conectado . ‚Äù </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="summary">  Sum√°rio </h2><br><p>  A convers√£o do WebRTC para HLS geralmente resulta em congelamento quando reproduzida nos players padr√£o da Apple.  O problema √© resolvido analisando e ajustando o fluxo de bits H.264 aos requisitos de HLS da Apple, seja por ranscoding, <br>  ou migrando para o protocolo RTMP e codificador como uma fonte de fluxo.  Em uma rede distribu√≠da com Carregamento Pregui√ßoso de fluxos, h√° o problema do primeiro visualizador conectado, que √© resolvido usando o pr√©-carregador e determinando a resolu√ß√£o no lado do servidor Origin - o ponto de entrada do fluxo na CDN. </p><br><h2 id="links">  Liga√ß√µes </h2><br><p>  <a href="https://flashphoner.com/">Servidor de Chamada pela Web</a> - servidor WebRTC </p><br><p>  <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN para streaming WebRTC de baixa lat√™ncia</a> - CDN baseado em WCS </p><br><p>  <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Reprodu√ß√£o de fluxos de v√≠deo WebRTC e RTMP via HLS</a> - Fun√ß√µes de servidor para converter fluxos de v√°rias fontes em HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481668/">https://habr.com/ru/post/pt481668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481654/index.html">A hist√≥ria de como o engenheiro de controle de qualidade tornou a vida mais f√°cil para voc√™ com a ajuda do Test IT, usando o Bot Framework</a></li>
<li><a href="../pt481656/index.html">PagerDuty, ou por que o departamento de opera√ß√µes pode n√£o dormir √† noite</a></li>
<li><a href="../pt481662/index.html">Tentando novas ferramentas para criar e automatizar a implanta√ß√£o no Kubernetes</a></li>
<li><a href="../pt481664/index.html">Pre√ßos e custos sem servidor: AWS Lambda</a></li>
<li><a href="../pt481666/index.html">Regras personalizadas do SwiftLint</a></li>
<li><a href="../pt481670/index.html">Crie um plano de a√ß√£o usando o AWS Cloud Adoption Framework</a></li>
<li><a href="../pt481672/index.html">Aut√¥matos celulares no navegador</a></li>
<li><a href="../pt481674/index.html">Funil de vendas de carros ou como n√£o mesclar clientes e at√© trabalhar com aqueles que recusaram seus servi√ßos?</a></li>
<li><a href="../pt481676/index.html">Semana de seguran√ßa 52: seguran√ßa para alto-falantes inteligentes e c√¢meras IP</a></li>
<li><a href="../pt481678/index.html">Revis√£o pr√©-feriado: N6IIT01 Player e fones de ouvido com armadura YB04 - Hi-Fi do sul da China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>