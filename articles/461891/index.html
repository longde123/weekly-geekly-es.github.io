<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 💬 ♻️ Cómo nos hicimos amigos en la infraestructura bancaria usando ManageIQ 🤹🏽 👰🏿 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de años, las principales tendencias fueron la automatización, las prácticas de DevOps y la aceleración de la entrega de valores al mercado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo nos hicimos amigos en la infraestructura bancaria usando ManageIQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/461891/"><p>  Hace un par de años, las principales tendencias fueron la automatización, las prácticas de DevOps y la aceleración de la entrega de valores al mercado.  Home Credit Bank decidió mantenerse al día y se dirigió al desarrollo de la tecnología, más aún cuando el susurro abierto de los usuarios que estaban cansados ​​de esperar varios días para esperar nuevos recursos para sus importantes proyectos se extendió más en el espacio abierto. </p><br><p>  Decidimos comenzar con el proceso de aprobación de solicitudes por departamentos, que, como en muchas grandes empresas, requería tiempo y esfuerzo.  Como primera tarea, elegimos el proceso de creación de una máquina virtual independientemente del entorno de virtualización.  Al hacer una lista de tareas, nos dimos cuenta de que sería necesario integrarlo con otros sistemas utilizados en la infraestructura de nuestro banco, por ejemplo, a través de API. </p><br><p><img src="https://habrastorage.org/webt/tt/h7/br/tth7br6euodgo1dklwgmaqhdxu4.png" alt="imagen"></p><a name="habracut"></a><br><p> La solución más adecuada fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ManageIQ</a> .  Este es un proyecto que Red Hat adquirió en 2012 y basado en él creó el producto comercial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Red Hat CloudForms</a> .  Al mismo tiempo, ManageIQ se mantuvo en el estado de un producto de código abierto y se está desarrollando en paralelo con CloudForms. </p><br><p>  ManageIQ está escrito en Ruby y admite una gran cantidad de proveedores diferentes de virtualización, nubes públicas y contenedorización.  Por el momento, estamos utilizando una versión de Gaprindashvili en la configuración de alta disponibilidad en el hogar. </p><br><h2>  Cómo ha cambiado el proceso </h2><br><p>  Anteriormente, cada equipo requería configuraciones separadas en su área de responsabilidad.  Después de la preparación preliminar, todos los datos se recopilaron y se enviaron al administrador, quien implementó y configuró la máquina virtual.  Luego fue necesario informar, por ejemplo, al equipo de monitoreo de que había aparecido un nuevo host que necesitaba ser agregado al monitoreo.  Los retrasos en la comunicación, la carga de trabajo de los especialistas, los errores causados ​​por el factor humano, podrían extender este proceso a varios días. </p><br><p>  Habiendo encajado todo el proceso en ManageIQ, obtuvimos los siguientes resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tipo de recurso virtual </th><th>  Antes de presentar ManageIQ </th><th>  Después de implementar ManageIQ </th></tr></thead><tbody><tr><td>  Máquina virtual Linux en VMware / oVirt </td><td>  A uno </td><td>  ~ 10 minutos </td></tr><tr><td>  Entorno de máquina virtual de rancher </td><td>  trabajando </td><td>  ~ 15 minutos </td></tr><tr><td>  Máquina virtual de Windows en VMware </td><td>  semanas </td><td>  ~ 25 minutos </td></tr></tbody></table></div><br><p>  La diferencia horaria se debe al hecho de que, en el segundo caso, se requiere tiempo adicional para preparar el host para trabajar con Docker, descargar e integrar imágenes para contenedores de infraestructura de Artifactory, porque en esta etapa todavía no hay acceso al Docker Hub.  En el caso de Windows, la diferencia se logra debido al hecho de que, en primer lugar, el tiempo de creación de una VM Linux sin personalización es de aproximadamente 2 minutos, y el de una VM de Windows es de 6 minutos.  En segundo lugar, la personalización de Windows en sí lleva unos 10 minutos, frente a 2 minutos para Linux. </p><br><p>  10 minutos no es tan rápido, dado que se gastan aproximadamente 2-3 minutos directamente en el proceso de creación de una VM.  Para el tiempo restante, ManageIQ logra hacer lo siguiente: </p><br><ol><li>  El sistema recopila los parámetros especificados por el usuario en el formulario de pedido y los descompone en variables. </li><li>  Se crea una nueva solicitud de cambio en el sistema de gestión de incidentes, que muestra datos sobre el nuevo recurso. </li><li>  El sistema de consulta de nombre de recurso ManageIQ envía un valor para un nuevo recurso. </li><li>  El sistema de administración de direcciones IP emite una nueva dirección basada en los parámetros ingresados. </li><li>  Se registra un nuevo registro DNS en el servidor DNS local. </li><li>  Según los parámetros, el entorno y la carga de recursos, se selecciona el tipo de virtualización y el clúster para la ubicación. </li><li>  A continuación, el proceso de creación de una máquina virtual con los parámetros especificados. </li><li>  Cuando la máquina virtual se implementa desde la plantilla, debe ejecutar scripts que realizarán la configuración final: <br><ul><li>  expansión de disco a un tamaño especificado, </li><li>  generar una nueva contraseña de root, cambiarla en un host de Linux y escribir en un administrador de contraseñas, </li><li>  creando un archivo YAML de configuración para Puppet en GitLab, </li><li>  ejecutar runbooks que traen las configuraciones y actualizaciones necesarias para máquinas virtuales de Windows o </li><li>  inicie Puppet, que actualizará y configurará máquinas Linux. </li></ul></li><li>  Después de todo esto, la solicitud de cambio creada en el paso 2 se cierra.  Se le agregan datos nuevos, como la dirección IP y el nombre de host. </li><li>  Se registra una nueva unidad en la Base de administración de recursos informáticos (CMDB). </li><li>  La máquina virtual se registra en Zabbix y se agrega a la supervisión. </li><li>  El cliente y otras partes interesadas reciben un correo electrónico con información sobre la nueva unidad creada con ManageIQ. </li></ol><br><h2 id="chto-vnutri">  Que hay dentro </h2><br><p>  Profundicemos en los detalles técnicos del producto.  De manera predeterminada, ManageIQ puede crear una máquina virtual a partir de una plantilla.  ¿Cómo difiere esto de lo que hacemos, por ejemplo, en vCenter?  La respuesta correcta es nada.  ManageIQ utiliza los mismos métodos que los sistemas de virtualización, pero lo hace desde un solo lugar.  Además de esto, puede agregar sus propios scripts que no se ajustan al conjunto estándar de características.  Por lo tanto, si tiene recursos, por ejemplo, en Azure público, en vCenter, que se implementa en su propio hardware, además de que el clúster de Kubernetes está girando en otro lugar, todo esto se puede administrar convenientemente desde ManageIQ. </p><br><p>  Además de una amplia variedad de proveedores para la integración, ManageIQ tiene herramientas convenientes para la personalización.  Esto, por ejemplo, creando formas convenientes para resolver su problema: </p><br><p><img src="https://habrastorage.org/webt/ku/7y/l3/ku7yl3xi9trq-9wndv-ad_vlpvu.png"></p><br><p>  Gracias a esto, fue posible construir una interfaz completa para ordenar una máquina virtual, ajustando todos los parámetros necesarios en ella: </p><br><p><img src="https://habrastorage.org/webt/v7/ey/tf/v7eytf_hbcxxjcpw4hvrzuwyzve.png"></p><br><p>  Seleccionamos la cantidad de recursos informáticos, SO, completamos toda la información adicional que se necesita para la integración con sistemas externos.  Además, utilizando mecanismos internos (sobre ellos un poco más tarde), el sistema elige dónde se colocarán los nuevos recursos: el centro de datos, el clúster, el host y el almacén de datos se seleccionan en función de todos los parámetros ingresados ​​y los recursos se cargan. </p><br><p>  No olvides que las personas pueden pedir demasiados recursos o nada de lo que realmente necesitan.  Aquí entra en juego el sistema de solicitudes y confirmaciones: </p><br><p><img src="https://habrastorage.org/webt/mj/yv/28/mjyv28hsy0ggf6t68jjdkgc8mwc.png"></p><br><p>  Cualquier recurso solicitado por el usuario debe ser aprobado por la persona responsable.  En Home, un grupo de arquitectos hace esto. </p><br><h2 id="struktura-avtomatizacii">  Estructura de automatización </h2><br><p>  Si descompone todos los procesos de automatización en ManageIQ en partes pequeñas, notará una cierta estructura. </p><br><h3 id="automate-domain">  Automatizar Dominio </h3><br><img align="right" src="https://habrastorage.org/webt/xy/ea/c_/xyeac_nx3if-e4txuiuriic4h0w.png"><br><p>  El almacén de datos aloja todos los dominios que ManageIQ tiene. </p><br><p>  Por defecto, hay un dominio ManageIQ, que está bloqueado y es algo así como un modelo de referencia.  Si necesita realizar cambios, se crea otro dominio, en el que los elementos del dominio ManageIQ se copian y cambian para sus propias tareas. </p><br><h3 id="automate-namespace">  Automatizar espacio de nombres </h3><br><img align="right" src="https://habrastorage.org/webt/yf/e1/t3/yfe1t3kjxb4rhvenndkfkwtsad4.png"><br><p>  En el interior, los dominios se dividen en partes que son responsables de los procesos individuales: esta puede ser la sección responsable de administrar la infraestructura (Infraestructura) o de trabajar con los servicios (Servicio).  Tenemos nuestro propio espacio de nombres, que contiene todo lo relacionado con los sistemas del banco. </p><br><p>  Considere la estructura con más detalle utilizando el ejemplo del proceso de aprovisionamiento para una nueva máquina virtual.  Se describe en la clase Automatizar llamada <em>VMProvision_VM</em> . </p><br><h3 id="automate-class">  Automatizar clase </h3><br><p>  La clase tiene una estructura que incluye <strong>instancias</strong> , <strong>métodos</strong> , <strong>propiedades</strong> y <strong>esquema</strong> .  Desde el punto de vista de la automatización, Schema es de gran interés: <br><img src="https://habrastorage.org/webt/vm/jt/lf/vmjtlfd9qpyrqpdpemtxfw2yczs.png"></p><br><p>  El diseño es similar a la tubería en los sistemas CI / CD.  Describe los pasos que se realizarán en el proceso de automatización. </p><br><h3 id="automate-instance">  Instancia automatizada </h3><br><img align="right" src="https://habrastorage.org/webt/ie/wj/fj/iewjfjuzq9rplkcszwsh7wemsqu.png"><br><p>  La clase descrita anteriormente tiene dos instancias de automatización.  Cada uno de ellos hereda del circuito las etapas para las que se establece el <em>Valor predeterminado</em> .  Las etapas que tienen valores nulos se describen en la instancia. </p><br><p><img src="https://habrastorage.org/webt/wy/sl/5c/wysl5c2zze_9_sfplsnykplbf_m.png"></p><br><p>  En la instancia, los valores aparecieron para los pasos que estaban vacíos en la descripción del esquema.  También puede ver quién y cuándo realizó el último cambio. </p><br><p>  Veamos qué representa uno de los valores de Valor: <br><img src="https://habrastorage.org/webt/rd/j_/v7/rdj_v7hc3wgt7dty2zckjltiacg.png"></p><br><p>  Esta es una clase de automatización llamada métodos, que tiene una instancia de automatización.  Su diagrama describe el atributo <em>ipam_base_uri</em> y el método de <em>ejecución</em> .  El método de ejecución, a su vez, llama al Método de Automate <em>adquirir_ip</em> . </p><br><h3 id="automate-method">  Método de automatización </h3><br><p>  Este es un script Ruby que permite que una máquina virtual se comunique a través de la API REST con otros sistemas.  Por ejemplo, como es el caso con el sistema de gestión de espacio de direcciones IPAM.  En IPAM obtenemos la dirección, la máscara, la subred y la VLAN para la VM.  La dificultad es que la máquina se puede implementar en un entorno de prueba o productivo, para aplicaciones o bases de datos.  O tal vez el servicio de seguridad decidió colocarlo en el bucle PCI-DSS.  Toda esta información se recopila en la etapa de creación de la VM o se transmite en los parámetros de la instancia llamada (en la captura de pantalla anterior, puede ver que el parámetro contiene la uri por la cual el método accederá a IPAM): </p><br><div class="spoiler">  <b class="spoiler_title">Aquí hay un código Ruby</b> <div class="spoiler_text"><pre><code class="ruby hljs">base_uri = $evm.object[<span class="hljs-string"><span class="hljs-string">'ipam_base_uri'</span></span>] prov = $evm.root[<span class="hljs-string"><span class="hljs-string">"miq_provision"</span></span>] site = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:site</span></span>) app = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_list_information_system</span></span>) crq = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:crq</span></span>) descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_textarea_box_usernotes</span></span>) owner = $evm.root[<span class="hljs-string"><span class="hljs-string">'user'</span></span>].name scope = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_scope</span></span>) environment = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:landscape</span></span>)</code> </pre> <br><p>  <em>$ evm.root</em> es un método que devuelve todo lo que se puede almacenar en ManageIQ.  Puede ser información sobre el usuario, el entorno, las variables, la solicitud actual ('miq_request'), etc.  Estamos interesados ​​en el proceso de provisión actual. <br><img src="https://habrastorage.org/webt/4m/hz/lm/4mhzlmb6p_lvkagsl7apu41mpdm.png"></p><br><p>  A continuación, podemos recoger los valores necesarios: <em>get_option (: site)</em> recoge el valor que se transfirió en una de las etapas anteriores y, por ejemplo, <em>get_option (: dialog_dropdown_list_information_system)</em> recoge del formulario que el usuario llena al solicitar nuevos recursos. <br>  Todos los valores recibidos son transmitidos por variables en el cuerpo de la solicitud en formato JSON: </p><br><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">body:</span></span> { <span class="hljs-string"><span class="hljs-string">"site"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{site}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"env"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{env}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"app"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{app}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"scope"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{scope}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"role"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{role}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"crq"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{crq}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"descr"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{descr}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{owner}</span></span></span><span class="hljs-string">"</span></span>, }.to_json, }</code> </pre> <br><p>  Usando este conjunto de parámetros, IPAM determinará inequívocamente en qué VLAN debe ubicarse la máquina virtual y devolverá los parámetros de red. </p></div></div><br><p>  Además de recibir datos para la configuración correcta de VM, ManageIQ también puede generar información adicional con el fin de realizar algunas configuraciones en la etapa del llamado aprovisionamiento posterior (después de que la máquina virtual se implemente y se inicie).  En Home, utilizamos Puppet para administrar las configuraciones de host de Linux.  Para cada unidad informática, cree un archivo GAML en YAML con un conjunto de grupos: </p><br><div class="spoiler">  <b class="spoiler_title">Un poco más de código Ruby</b> <div class="spoiler_text"><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Private-Token"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{api_token}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, } body = { <span class="hljs-string"><span class="hljs-string">"branch"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{branch}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_email"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"email@your.domain"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_name"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ManageIQ Bot"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"commit_message"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"New host created by ManageIQ"</span></span>, } descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:long_description</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) &amp;&amp; descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n - user-devops-UDCR"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$is_id}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Los grupos dependen del tipo de máquina virtual, el entorno en el que se crea y el sistema de información. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/hv/ig/1ihvigmykpbqlihq2l8oturxxk0.png"></div><br><p>  Después de completar con éxito el procedimiento, el usuario recibe un correo electrónico con información: <br><img src="https://habrastorage.org/webt/qf/j-/br/qfj-brpfqe1ukkcvrw_jdtdpigm.png"></p><br><p>  El texto de la carta también se puede ajustar agregando la información necesaria. <br>  Si se produce un error en cualquiera de las etapas críticas del proceso, puede agregar una condición que indique explícitamente que el proceso debe interrumpirse.  Si el error no tiene consecuencias fatales, indique también qué se puede continuar, a pesar del problema. </p><br><h2 id="logirovanie">  Registro </h2><br><p>  ManageIQ escribe registros de todo lo que se puede rastrear.  El proceso de automatización está escrito en automation.log.  Además, hay registros de API, varios proveedores de nube, registros de seguridad, incluso se registra la salida del comando superior. </p><br><p>  Para cada evento en el circuito, puede configurar una entrada de registro de su inicio y finalización: <br><img src="https://habrastorage.org/webt/tv/z0/yy/tvz0yyygspvyltb6d_x4ja00hpg.png"></p><br><p>  Además, puede escribir sus mensajes en los registros: </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"Call job status uri: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{item_uri}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{job_id}</span></span></span><span class="hljs-string">/api/json"</span></span>)</code> </pre> <br><p>  Esto es muy útil cuando se accede a los sistemas por API para comprender por qué algo salió mal.  O, para rastrear el estado actual de un proceso largo, como ejecutar un trabajo de Jenkins o un Runbook de SCCM: </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"acquire_osname --- naming jobStatus: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{jobStatus}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> jobStatus.to_s == <span class="hljs-string"><span class="hljs-string">"Completed"</span></span></code> </pre> <br><p>  Puede usar las funciones estándar para excepciones para escribir en los registros: </p><br><pre> <code class="ruby hljs">raise “VM <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified” <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> vm.<span class="hljs-literal"><span class="hljs-literal">nil</span></span>?</code> </pre> <br><p>  Por defecto, todos los registros se almacenan en la sección / var / log / manageiq / *, pero desde mi propia experiencia puedo decir que buscar un problema a través de tail y grep no es la solución más conveniente.  Dado que ManageIQ escribe muchos registros diferentes, debe tener cuidado de redirigir los registros, por ejemplo, a la pila ELK. </p><br><h2 id="manageiq-api">  API ManageIQ </h2><br><p>  Además de una interfaz web fácil de usar, ManageIQ tiene una API funcional.  Con él, por ejemplo, resolvimos el problema de determinar dinámicamente el identificador de la plantilla que se especificará </p><br><div class="spoiler">  <b class="spoiler_title">al crear una VM:</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vendor, os, ems)</span></span></span></span> user = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">'</span></span> pass = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">'</span></span> options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Accept"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"*/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"accept-encoding"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"gzip, deflate"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">basic_auth:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">username:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">password:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">"</span></span> }, } response = HTTParty.get(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{host}</span></span></span><span class="hljs-string">/api/templates?filter[]=vendor=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{vendor}</span></span></span><span class="hljs-string">%27&amp;filter[]=name=%27%2A</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{os}</span></span></span><span class="hljs-string">%2A%27&amp;filter[]=ems_id=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ems}</span></span></span><span class="hljs-string">%27"</span></span>, options).to_s link = JSON.parse(response) link[<span class="hljs-string"><span class="hljs-string">"resources"</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|r|</span></span> $url = r[<span class="hljs-string"><span class="hljs-string">"href"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> response = HTTParty.get($url,options).to_s template = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'id'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>+<span class="hljs-string"><span class="hljs-string">", "</span></span>+<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'name'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Usando una solicitud POST y especificando filtros para la búsqueda, obtenemos la plantilla deseada. <br>  Además de resolver problemas internos, puede crear nuevos métodos API para uso de sistemas externos.  Al comienzo del artículo, se mostró el proceso de ordenar una nueva máquina virtual utilizando la interfaz web.  Y así es como se ve si lo haces con </p><br><div class="spoiler">  <b class="spoiler_title">Solicitud POST:</b> <div class="spoiler_text"><pre> <code class="ruby hljs">curl -X POST \ <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/Manageiq.hostname/api</span></span><span class="hljs-regexp"><span class="hljs-regexp">/service_catalogs/</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>/service_templates/<span class="hljs-number"><span class="hljs-number">31</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Authorization: Basic Token-Value'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{ "action": "order", "resource": { "radio_button_vcpu": "a_2", "radio_button_vram": "a_2", "hdd_size": "40", "dropdown_os": "CentOS", "text_box_filter": "dns", "dropdown_list_information_system": "DNS ", "text_box_validator": "OK (DNS )", "textarea_box_usernotes": " ", "dropdown_env": "production", "date_control_retirement_dt": "2022-05-21", "dropdown_scope": "-" } }'</span></span></code> </pre> </div></div><br><h2 id="zaklyuchenie">  Conclusión </h2><br><h3 id="plyusy">  Pros: </h3><br><ul><li>  Flexibilidad increíble: ManageIQ no solo le permite personalizar el proceso de automatización según lo necesite, sino que también le permite cambiar su parte visual agregando botones, campos, etc. </li><li>  Editor de código incorporado con resaltado de sintaxis y validación de código.  Me pareció una muy buena solución, si necesitas arreglar algo rápidamente. </li><li>  Una gran cantidad de fuentes con las que el sistema puede trabajar.  Nubes: Amazon EC2, Google Compute Engine, Azure, OpenStack, VMware vCloud.  Infraestructura: Microsoft SCVMM, OpenStack Platform Director, Red Hat Virtualization, VMware vCenter.  Contenedores: Kubernetes, OpenShift. </li></ul><br><h3 id="minusy">  Contras: </h3><br><ul><li>  Las grandes capacidades de la herramienta también tienen un punto negativo.  No toda la documentación está bien estructurada y, a veces, es difícil determinar dónde buscar lo que necesita.  Sin embargo, vale la pena señalar que la situación está cambiando para mejor, la documentación se complementa y mejora. </li><li>  Pequeña comunidad  Si encuentra algún problema muy específico, es posible que no pueda "googlear" rápidamente la respuesta.  O no tener éxito en absoluto. </li><li>  Un párrafo que se sigue de los dos anteriores.  Algunas cosas básicas, configuraciones y escenarios se pueden encontrar en la documentación o en Internet, pero las preguntas más específicas y limitadas requieren mucho tiempo para comprender y estudiar, incluido el método de búsqueda científica: sonrisa:. </li></ul><br><h3 id="kak-u-nas-seychas">  Como tenemos ahora: </h3><br><p>  Debido al hecho de que ManageIQ puede aprovechar al máximo el lenguaje Ruby, pudimos integrarlo para trabajar con las siguientes API: </p><br><ul><li>  Administrador de contraseñas  Genera una contraseña raíz de acuerdo con los requisitos del servicio de seguridad, la escribe en su base de datos y ManageIQ la usa dentro del sistema operativo; </li><li>  Centro de servicios Servicios de orquestación para administrar registros DNS y nombres de host; </li><li>  Remedio BMC.  Todo el proceso se registra como comentarios en la solicitud.  Después de una ejecución exitosa, la solicitud se cierra; </li><li>  CMDB  La información sobre las nuevas unidades de configuración se crea en la base de datos con todos los datos necesarios. </li><li>  Zabbix  Dependiendo de la afiliación con el sistema de información y el entorno, los hosts se agregan a los grupos de monitoreo correspondientes. </li><li>  Ranchero.  Implementé la creación de nuevos entornos, la instalación de agentes y el registro de hosts en entornos existentes. </li><li>  Jenkins  Jenkins ejecuta trabajos para configurar máquinas virtuales en oVirt; </li><li>  LDAP  Cree nuevos grupos que se utilizan para controlar el acceso en entornos Rancher y para configurar políticas en Vault; </li><li>  Bóveda  En Home, la integración de este producto en los procesos bancarios acaba de comenzar, pero ya hemos creado métodos para crear nuevos grupos, políticas y secciones para el almacenamiento; </li><li>  Puppet e IPAM se mencionaron anteriormente. </li></ul><br><p>  La funcionalidad y las capacidades del sistema son muy amplias, y me familiaricé con muchas de ellas y sigo familiarizándome con el proceso de implementación del sistema. <br>  Por ejemplo, no mencioné que el sistema tiene la capacidad de crear sus propios paneles con estadísticas, configuraciones de facturación o botones, a los que puede adjuntar guiones individuales o guiones completos.  Puede agregar sus propios campos para registrar información adicional sobre servicios y máquinas virtuales, etc. </p><br><h3 id="k-chemu-stremitsya-houm">  Para qué se esfuerza Home: </h3><br><ul><li>  Una actualización a la versión Hammer, en la que en el modo HA puede intentar trabajar con el Ansible incorporado. </li><li>  La transición de la coordinación para cada unidad de recursos virtuales a la gestión.  Los equipos podrán recibir nuevas máquinas virtuales aún más rápido si la cuota no se agota. </li><li>  Desarrollo de nuevos métodos para su posterior suministro a sistemas externos. </li><li>  Por ejemplo, varios SaaS como jenkins, logstash, etc. </li><li>  Implementación de nuevos métodos API en un portal existente para propietarios de sistemas de información.  Los usuarios no necesitarán pensar en cómo integrarse con el nuevo elemento de infraestructura, solo lo usarán como un servicio para obtener nuevos recursos o cambiar los existentes. </li></ul><br><p>  <em>Al final, me gustaría recordarles que las herramientas son excelentes, pero no olviden la importancia de la interacción entre los diferentes equipos.</em>  <em>Los cambios descritos en el artículo no habrían sido posibles sin una comunicación bien establecida y una interacción constante sobre temas emergentes de todas las partes interesadas.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461891/">https://habr.com/ru/post/461891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461877/index.html">Java vs Kotlin para Android: opiniones de desarrolladores</a></li>
<li><a href="../461879/index.html">El libro "Linux en acción"</a></li>
<li><a href="../461881/index.html">Guía de registro de Node.js</a></li>
<li><a href="../461885/index.html">EDS es otro tipo de fraude</a></li>
<li><a href="../461887/index.html">Entrando en Aeronet Episodio 2: Homing Drone</a></li>
<li><a href="../461895/index.html">Aprenda mientras viaja: cómo conducimos el 1er Día Europeo del Análisis Empresarial</a></li>
<li><a href="../461897/index.html">Cómo mantenemos la estabilidad de la aplicación Lamoda</a></li>
<li><a href="../461899/index.html">Event Generation, CQRS y Laravel</a></li>
<li><a href="../461901/index.html">Tres años de autotest: cómo aumentar la velocidad y no solo</a></li>
<li><a href="../461903/index.html">Adversario misterioso: préstamos borrosos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>