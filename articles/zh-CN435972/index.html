<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📺 ⬆️ 👨‍🎤 在Spring中引入反应式编程 ✍🏼 👨🏾‍🚀 🧛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 本周，我们期望印刷厂出版一本新的Spring 5 书籍 ： 


 在Spring 5的有趣特性中，应该特别提及反应式编程，Matt Raible的拟议文章简要描述了在该框架中的实现。 在上述书籍中，第11章讨论了反应模式。 

 马特（Matt）由乔什·朗（Josh Long）合着...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Spring中引入反应式编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/435972/"> 哈Ha！ <br><br> 本周，我们期望印刷厂<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出版</a>一本新的Spring 5 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">书籍</a> ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br> 在Spring 5的有趣特性中，应该特别提及反应式编程，Matt Raible的拟议文章简要描述了在该框架中的实现。 在上述书籍中，第11章讨论了反应模式。 <br><br> 马特（Matt）由乔什·朗（Josh Long）合着，乔什·朗（Josh Long）是去年夏天发行的另一本关于Java和Spring的伟大著作《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云中的Java</a> 》的作者。 <br><a name="habracut"></a><br> 反应性编程是构建耐高负荷系统的方法。 处理大量流量不再是问题，因为服务器处于非阻塞状态，并且客户端进程不必等待响应。 客户端无法直接观察程序如何在服务器上运行并与其同步。 当API发现难以处理请求时，它仍应给出合理的响应。 不应以不受控制的方式拒绝和丢弃消息。 它必须告知较高的组件它正在负载下工作，以便它们可以部分地摆脱负载。 这种技术称为反压，这是反应式编程的重要方面。 <br><br> 我们与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Josh Long</a>共同撰写了这篇文章。  Josh是Java冠军，Spring Developer Advocate，并且通常是在Pivotal工作的全球人员。 我已经与Spring合作了很长时间，但是Josh向我展示了Spring Boot，那是在比利时的Devoxx会议上。 从那时起，我们成为好朋友，我们喜欢Java并编写了出色的应用程序。 <br><br>  <b>反应式编程或I / O，I / O，我们开始工作...</b> <br><br> 响应式编程是一种创建主动使用异步I / O的软件的方法。 异步I / O是一个很小的主意，充满了编程方面的巨大变化。 这个想法本身很简单：使用效率低下的资源分配来纠正这种情况，释放那些无需我们干预就可以闲置的资源，等待I / O完成。 异步输入/输出颠倒了常规的I / O处理方法：客户端被释放，可以执行其他任务，等待新的通知。 <br><br> 考虑一下同步和异步输入/输出之间的共同点，以及它们之间的区别是什么。 <br><br> 我们将编写一个简单的程序，该程序从源中读取数据（特别是我们在谈论<code>java.io.File</code>链接）。 让我们从使用良好的旧<code>java.io.InputStream</code>的实现开始： <br><br>  <i>例子1.从文件同步读取数据</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol><li> 我们提供了一个用于读取的文件，该文件具有通常的<code>java.io.File</code> </li><li> 一次从源中提取结果一行... </li><li> 我编写了这段代码以使用<code>Consumer&lt;BytesPayloadgt;</code> 新数据到达时调用 </li></ol><br> 很简单，你怎么说？ 运行此代码，您将在日志输出中（每行左侧）看到该代码，指示所有操作均在单个线程中发生。 <br> 在这里，我们从源中获取的数据中提取字节（在本例中，我们所讨论的是从<code>java.io.InputStream</code>继承的<code>java.io.InputStream</code>的子类）。 这个例子有什么问题？ 在这种情况下，我们使用一个InputStream指向位于文件系统上的数据。 如果文件存在，并且硬盘驱动器正在运行，则此代码将按预期工作。 <br><br> 但是，如果我们不是从<code>File</code>而是从网络套接字读取数据，而是使用<code>InputStream</code>另一种实现，将会发生什么？ 不用担心！ 当然，如果网络的速度无限高，绝对没有什么可担心的。 并且如果此节点与另一个节点之间的网络通道永远不会失败。 如果满足这些条件，则代码将完美运行。 <br><br> 但是，如果网络变慢或瘫痪怎么办？ 在这种情况下，我的意思是我们将增加周期，直到操作<code>in.read(…)</code>为止。 实际上，她可能根本不回来！ 如果我们尝试对要从中读取数据的流执行其他操作，那么这将是一个问题。 当然，您始终可以创建另一个流并通过该流读取数据。 可以做到这一点，但最终，我们将达到极限，仅增加线程以进一步扩展就不再足够了。 除了我们机器上的内核数量之外，我们将没有真正的竞争。 死胡同！ 在这种情况下，仅由于额外的流量，我们才可以增加输入/输出处理（此处是指读数），但在此我们迟早会达到极限。 <br><br> 在此示例中，主要工作是阅读-在其他方面几乎没有任何反应。 我们依赖于I / O。 考虑一下异步解决方案如何帮助我们部分克服流程的垄断。 <br><br>  <i>例子2.从文件异步读取数据</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol><li> 这次我们改编<code>java.io.File</code> ，从中制作<code>Java NIO java.nio.file.Path</code> </li><li> 创建<code>Channel</code> ，尤其要指定<code>java.util.concurrent.ExecutorService</code>服务，该服务将在必要数据出现时用于调用<code>CompletionHandler</code>处理程序。 </li><li> 我们通过传递指向<code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code>的链接开始阅读<code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li> 在回调中，将字节<code>ByteBuffer</code>的<code>byte[]</code>读取为<code>byte[]</code>容量<code>byte[]</code> </li><li> 就像在<code>Synchronous</code>示例中一样， <code>byte[]</code>数据被传递给使用者。 </li></ol><br> 我们将立即进行预订：事实证明，这段代码要难得多！ 这里发生了很多事情，您的头脑马上就转动了，但是，让我指出...此代码从<code>Java NIO Channel</code>读取数据，然后在负责回调的单独线程中处理此数据。 因此，开始读取的流不会被独占。 调用<code>.read(..)</code>之后，我们几乎立即返回，最后，当我们拥有可用的数据时，就会进行回调-已经在另一个线程中。 如果对<code>.read()</code>调用之间存在延迟<code>.read()</code>可以在线程中执行其他操作来处理其他问题。 从第一个字节到最后一个字节的异步读取操作的持续时间最多不超过同步读取操作的持续时间。 通常，异步操作的时间可以忽略不计。 但是，面对这些额外的困难，我们可以更有效地处理流程。 做更多的工作，在有限数量的线程池中复用I / O。 <br><br> 我在一家云计算公司工作。 我们希望您获得该应用程序的新实例，以解决水平缩放问题！ 当然，我这里有点不屑一顾。 异步I / O使事情变得有些复杂，但是我希望该示例说明反应式代码是如此有用：如果性能高度依赖于I / O，它允许您处理更多请求并在现有硬件上执行更多工作。 如果性能取决于处理器的使用（例如，我们正在谈论斐波那契数字的运算，挖掘比特币或加密技术），那么反应式编程将不会给我们任何帮助。 <br><br> 当前，我们大多数人在日常工作中都不使用<code>Channel</code>或<code>InputStream</code>实现！ 我们必须在更高级别的抽象级别上考虑问题。 它与数组之类的东西有关，或者与<code>java.util.Collection</code>层次结构有关。  <code>java.util.Collection</code>集合在InputStream上显示得非常好：两个实体都假定您可以一次并几乎立即操作所有数据。 预期您将能够较早而不是以后完成对大多数<code>InputStreams</code>读取。 当移至大量数据时，收集类型变得有些不舒服。 如果您要处理潜在的无限（无限）事件，例如Web套接字或服务器事件，该怎么办？ 如果两次录音之间有延迟怎么办？ <br><br> 我们需要一种更好的方式来描述此类数据。 我们正在谈论异步事件，这些事件最终会发生。 似乎<code>Future&lt;T&gt;</code>或<code>CompletableFuture&lt;T&gt;</code>很适合此目的，但它们仅描述了最后发生的一件事。 实际上，Java没有提供合适的隐喻来描述这种数据。  Java 8中的<code>Iterator</code>和<code>Stream</code>类型可能都不相关，但是，两者都是针对拉的。 您自己请求下一个条目，而不是类型应向您的代码发送回调。 假定如果在这种情况下支持基于推的处理，这将允许在线程级别实现更多功能，则API还将提供线程和调度控制。  <code>Iterator</code>实现对线程一无所知，并且所有Java 8线程共享相同的fork-join池。 <br><br> 如果<code>Iterator</code>和<code>Stream</code>确实支持推送处理，那么我们将遇到另一个在I / O上下文中确实升级的问题：我们将需要某种反向渗透机制！ 由于数据使用者是异步处理的，因此我们不知道何时将数据放入管道中以及数量。 我们不知道在下一个回调中需要处理多少数据：一个字节或一个TB！ <br><br> 从<code>InputStream</code>提取数据，您所读取的信息已准备就绪，可以处理的数量就更多了。 在前面的示例中，我们将数据读取到固定长度和已知长度的<code>byte[]</code>缓冲区中。 在异步上下文中，我们需要某种方式来告知提供者我们愿意处理多少数据。 <br> 是的，长官 这里肯定缺少一些东西。 <br><br>  <b>搜索丢失的隐喻</b> <br><br> 在这种情况下，我们正在寻找一个隐喻，该隐喻可以完美地反映异步I / O的本质，支持这种用于数据反向传输的机制，并允许我们控制分布式系统中的执行流程。 在反应式编程中，客户端发信号通知其能够处理的负载的能力称为“反向流”。 <br><br> 现在有许多好的项目-Vert.x，Akka Streams和RxJava-支持反应式编程。  Spring团队还运行一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reactor</a>的项目。 在这些不同的标准之间，存在一个相当广泛的通用领域，实际上分配给了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reactive Streams主动</a>标准。 反应流计划定义了四种类型： <br><br>  <code>Publisher&lt;T&amp;gt</code>界面<code>Publisher&lt;T&amp;gt</code> 产生可能最终到达的价值。  <code>Publisher&lt;T&amp;gt</code>界面<code>Publisher&lt;T&amp;gt</code> 为<code>Subscriber&lt;T&gt;</code>产生类型<code>T</code>值。 <br><br>  <i>示例3.反应性流： <code>Publisher&lt;T&gt;</code>接口</i> 。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  <code>Subscriber</code>类型订阅<code>Publisher&lt;T&gt;</code> ，并通过其<code>onNext(T)</code>方法接收类型<code>T</code>的任何新值的通知。 如果发生任何错误，则<code>onError(Throwable)</code>其<code>onError(Throwable)</code>方法。 当处理正常完成时，将调用订户的<code>onComplete</code>方法。 <br><br>  <i>示例4. Jet流： <code>Subscriber&lt;T&gt;</code>接口。</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br> 当<code>Subscriber</code>首次连接到<code>Publisher</code> ，它会通过<code>Subscriber#onSubscribe</code>接收<code>Subscription</code> 。 订阅<code>Subscription</code>可能是整个规范中最重要的部分。 是她提供了回流。 订户订户使用<code>Subscription#request</code>方法请求其他数据，或使用<code>Subscription#cancel</code>方法停止处理。 <br><br>  <i>示例5.反应性流： <code>Subscription&lt;T&gt;</code>接口</i> 。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br> 反应性流规范提供了另一种有用的（尽管很明显）类型： <code>Processor&lt;A,B&gt;</code>只是一个继承了<code>Subscriber&lt;A&gt;</code>和<code>Publisher&lt;B&gt;</code> 。 <br><br>  <i>示例6. Jet流： <code>Processor&lt;T&gt;</code>接口</i> 。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br> 规范不作为实现的处方；实际上，其目的是定义支持互操作性的类型。 与响应流相关联的类型的明显好处是，它们仍然在Java 9发行版中找到了位置，而且在语义上它们是“一对一”的，对应于<code>java.util.concurrent.Flow</code>类的接口，例如： <code>java.util.concurrent.Flow.Publisher</code> 。 <br><br>  <b>认识反应堆</b> <br><br> 仅反应流的类型是不够的。 需要更高阶的实现来支持诸如过滤和转换之类的操作。 这样，Reactor项目很方便。 它建立在Reactive Streams规范的基础上，并提供了两个<code>Publisher&lt;T&gt;</code>专长。 <br><br> 首先， <code>Flux&lt;T&gt;</code>是产生零个或多个值的发布者。 第二个， <code>Mono&lt;T&gt;</code> ，是<code>Publisher&lt;T&gt;</code> ，产生零或一个值。 它们都可以发布值并可以相应地处理它们，但是它们的功能比Reactive Streams规范要广泛得多。 两者都提供了允许您处理价值流的运算符。  Reactor类型组成良好-其中一个的输出可以用作另一个的输入，并且如果一个类型需要与其他数据流一起使用，则它们依赖<code>Publisher&lt;T&gt;</code>实例。 <br><br>  <code>Mono&lt;T&gt;</code>和<code>Flux&lt;T&gt;</code>实现<code>Publisher&lt;T&gt;</code> ； 我们建议您的方法接受<code>Publisher&lt;T&gt;</code>实例，但返回<code>Flux&lt;T&gt;</code>或<code>Mono&lt;T&gt;</code> ； 这将帮助客户区分他接收的数据类型。 <br><br> 假设您被授予<code>Publisher&lt;T&gt;</code>并要求显示该<code>Publisher&lt;T&gt;</code>的用户界面。 然后，由于您可以获得<code>CompletableFuture&lt;T&gt;</code> ，因此我是否应该显示一个包含详细记录的页面？ 还是显示带有列表或网格的概览页面，其中所有条目都逐页显示？ 很难说。 <br><br> 反过来， <code>Flux&lt;T&gt;</code>和<code>Mono&lt;T&gt;</code>非常具体。 您知道，如果收到<code>Flux&lt;T&gt;</code>需要显示一个评论页面，而当收到<code>Mono&lt;T&gt;</code>时，则需要显示一个包含一个（或非单个）记录的详细信息的页面。 <br><br>  Reactor是Pivotal启动的一个开源项目； 现在他变得非常受欢迎。  Facebook在其喷气<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎中</a>使用它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来调用远程过程</a> ，并在RxJava创造者Ben Christensen领导的Rsocket中使用它。  Salesforce在其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反应性gRPC实现中</a>使用它。  Reactor实现了Reactive Streams类型，因此它可以与支持这些类型的其他技术进行交互，例如，与Netflix的<a href="">RxJava 2</a> ， <a href="">Lightbend的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Akka Streams</a>以及Eclipse Foundation的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vert.x</a>项目。  RxJava 2的主管David Cairnock也积极与Pivotal合作开发Reactor，从而使该项目变得更好。 另外，当然，从Spring Framework 4.0开始，它在Spring Framework中以一种或另一种形式出现。 <br><br>  <b>使用Spring WebFlux进行反应式编程</b> <br><br> 尽管有其所有用途，Reactor只是基础。 我们的应用程序必须与数据源通信。 必须支持身份验证和授权。  Spring提供了所有这些。 如果Reactor给我们提供了缺失的隐喻，那么Spring可以帮助我们所有人说一种共同的语言。 <br><br>  Spring Framework 5.0于2017年9月发布。它基于Reactor和Reactive Streams规范。 它具有一个称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring WebFlux</a>的新的反应式运行时和组件模型。 <br><br>  Spring WebFlux独立于Servlet API，不需要它们工作。 它带有适配器，如有必要，可让您在Servlet引擎上使用它，但这不是必需的。 它还提供了一个全新的基于Netty的运行时，称为Spring WebFlux。 与Java 8和Java EE 7及更高版本一起使用的Spring Framework 5现在成为许多Spring生态系统的基础，包括Spring Data Kay，Spring Security 5，Spring Boot 2和Spring Cloud Finchley。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435972/">https://habr.com/ru/post/zh-CN435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435960/index.html">思想实验：随心所欲</a></li>
<li><a href="../zh-CN435962/index.html">Aeron成立25周年：Aeron Remastered更新版本的感召和印象</a></li>
<li><a href="../zh-CN435964/index.html">以太坊计划经济性提高99％</a></li>
<li><a href="../zh-CN435968/index.html">机器人的深度机器学习算法概述</a></li>
<li><a href="../zh-CN435970/index.html">使用Node.js进行Web服务器开发的初学者指南</a></li>
<li><a href="../zh-CN435974/index.html">Three.js-做控制空间或天文馆</a></li>
<li><a href="../zh-CN435976/index.html">Web生产中的组装和智能电视的“雷区”：Andrei Nagih访谈</a></li>
<li><a href="../zh-CN435978/index.html">生物识别保护解决方法</a></li>
<li><a href="../zh-CN435984/index.html">神经网络与语言哲学</a></li>
<li><a href="../zh-CN435986/index.html">Windows将为系统更新保留7 GB，以避免用完硬盘空间</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>