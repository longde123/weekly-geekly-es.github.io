<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥌 👩🏿‍🤝‍👩🏼 🦈 Pengembangan operator Kubernetes dengan Kerangka Operator 👲🏼 ⏳ 🐊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti yang disebutkan dalam artikel Teknologi Radar , Lamoda aktif bergerak menuju arsitektur layanan mikro. Sebagian besar layanan kami dikemas men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan operator Kubernetes dengan Kerangka Operator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/446648/"><p><img src="https://habrastorage.org/getpro/habr/post_images/352/5c8/f16/3525c8f16510afa2b61b0ff9b8434a02.png" alt="Gambar"></p><br><p>  Seperti yang disebutkan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi Radar</a> , Lamoda aktif bergerak menuju arsitektur layanan mikro.  Sebagian besar layanan kami dikemas menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> dan digunakan untuk Kubernetes.  Pendekatan ini sepenuhnya memenuhi kebutuhan kita dalam 99% kasus.  1% tetap ketika fungsionalitas Kubernetes standar tidak cukup, misalnya, ketika Anda perlu mengkonfigurasi cadangan atau pembaruan layanan untuk acara tertentu.  Untuk mengatasi masalah ini, kami menggunakan pola operator.  Dalam seri artikel ini, I - Grigory Mikhalkin, pengembang tim R&amp;D di Lamoda - akan berbicara tentang pelajaran yang saya pelajari dari pengalaman saya dalam mengembangkan operator K8 menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Operator</a> . </p><a name="habracut"></a><br><h2 id="chto-takoe-operator">  Apa itu operator? </h2><br><p>  Salah satu cara untuk memperluas fungsionalitas Kubernetes adalah dengan membuat pengontrol Anda sendiri.  Abstraksi utama dalam Kubernet adalah objek dan pengontrol.  Objek menggambarkan keadaan cluster yang diinginkan.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pod</a> menjelaskan wadah mana yang harus dimulai dan parameter startup, dan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReplicaSet</a> memberitahu berapa banyak replika dari Pod yang diberikan perlu diluncurkan.  Kontroler mengontrol keadaan gugus berdasarkan pada deskripsi objek, dalam kasus yang dijelaskan di atas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReplicationController</a> akan mendukung jumlah replika Pod yang ditentukan dalam ReplicaSet.  Dengan bantuan pengontrol baru, Anda dapat menerapkan logika tambahan, seperti mengirim pemberitahuan acara, pulih dari kegagalan, atau mengelola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber daya pihak ketiga</a> . </p><br><p> Operator adalah aplikasi kubernet yang mencakup satu atau lebih pengontrol yang melayani sumber daya pihak ketiga.  Konsep ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diciptakan oleh tim CoreOS</a> pada tahun 2016, dan baru-baru ini, popularitas operator telah berkembang pesat.  Anda dapat mencoba menemukan operator yang diinginkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar di kubedex</a> , (lebih dari 100 operator yang tersedia untuk publik terdaftar di sini), serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OperatorHub</a> .  Ada 3 alat populer untuk pengembangan operator: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubebuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator SDK</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metacontroller</a> .  Di Lamoda kami menggunakan Operator SDK, jadi kami akan membicarakannya nanti. </p><br><h2 id="operator-sdk">  Operator SDK </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7e/56d/194/f7e56d1948a2f5291ef189e7a03df9be.png" alt="Gambar"></p><br><p>  Operator SDK adalah bagian dari Kerangka Operator, yang mencakup dua bagian penting: Manajer Siklus Hidup Operator dan Pengukuran Operator. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator SDK</a> adalah pembungkus untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime pengontrol</a> , perpustakaan populer untuk mengembangkan pengontrol (yang, pada gilirannya, adalah pembungkus untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">client-go</a> ), kerangka pembuat kode + untuk menulis tes E2E. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator Siklus Hidup Operator</a> - kerangka kerja untuk mengelola operator yang ada;  menyelesaikan situasi ketika operator memasuki mode zombie atau versi baru diluncurkan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengukuran Operator</a> - sesuai dengan namanya, ia mengumpulkan data pada pekerjaan operator, dan juga dapat menghasilkan laporan berdasarkan pada itu. </li></ul><br><h2 id="sozdanie-novogo-proekta">  Buat proyek baru </h2><br><p>  Contohnya adalah operator yang memantau file dengan konfigurasi di repositori dan, ketika diperbarui, memulai kembali penyebaran layanan dengan konfigurasi baru.  Kode sampel lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4c0/e84/ebc/4c0e84ebcba8cad49b2bea8506f79d32.png" alt="Gambar"></p><br><p>  Buat proyek dengan operator baru: </p><br><pre><code class="plaintext hljs">operator-sdk new config-monitor</code> </pre> <br><p>  Pembuat kode akan membuat kode untuk operator yang bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">namespace yang</a> dialokasikan.  Pendekatan ini lebih disukai untuk memberikan akses ke seluruh cluster, karena jika terjadi kesalahan, masalah akan diisolasi dalam namespace yang sama.  Operator <code>cluster-wide</code> dapat dihasilkan dengan menambahkan <code>--cluster-scoped</code> .  Direktori berikut akan berlokasi di dalam proyek yang dibuat: </p><br><ul><li>  cmd - berisi <code>main package</code> , di mana <code>Manager</code> diinisialisasi dan diluncurkan; </li><li>  deploy - berisi pernyataan operator, CRD dan objek yang diperlukan untuk mengatur operator RBAC </li><li>  pkg - ini akan menjadi kode utama kita untuk objek dan pengendali baru. </li></ul><br><p>  Hanya ada satu <a href=""><code>cmd/manager/main.go</code></a> file dalam <a href=""><code>cmd/manager/main.go</code></a> . </p><br><div class="spoiler">  <b class="spoiler_title">Cuplikan kode</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// Become the leader before proceeding err = leader.Become(ctx, "config-monitor-lock") if err != nil { log.Error(err, "") os.Exit(1) } // Create a new Cmd to provide shared dependencies and start components mgr, err := manager.New(cfg, manager.Options{ Namespace: namespace, MetricsBindAddress: fmt.Sprintf("%s:%d", metricsHost, metricsPort), }) ... // Setup Scheme for all resources if err := apis.AddToScheme(mgr.GetScheme()); err != nil { log.Error(err, "") os.Exit(1) } // Setup all Controllers if err := controller.AddToManager(mgr); err != nil { log.Error(err, "") os.Exit(1) } ... // Start the Cmd if err := mgr.Start(signals.SetupSignalHandler()); err != nil { log.Error(err, "Manager exited non-zero") os.Exit(1) }</code> </pre> </div></div><br><p>  Di baris pertama: <code>err = leader.Become(ctx, "config-monitor-lock")</code> - seorang pemimpin dipilih.  Dalam sebagian besar skenario, hanya satu instance aktif pernyataan di namespace / cluster yang diperlukan.  Secara default, Operator SDK menggunakan strategi <a href="">Leader for life</a> - instance yang diluncurkan pertama dari operator akan tetap menjadi pemimpin sampai dihapus dari cluster. </p><br><p>  Setelah instance operator ini ditunjuk sebagai pemimpin, <code>Manager</code> baru diinisialisasi - <code>mgr, err := manager.New(...)</code> .  Tanggung jawabnya meliputi: </p><br><ul><li>  <code>err := apis.AddToScheme(mgr.GetScheme())</code> - pendaftaran skema sumber daya baru; </li><li>  <code>err := controller.AddToManager(mgr)</code> - pendaftaran pengendali; </li><li>  <code>err := mgr.Start(signals.SetupSignalHandler())</code> - luncurkan dan kendalikan pengontrol. </li></ul><br><p>  Saat ini, kami tidak memiliki sumber daya baru, atau pengontrol untuk pendaftaran.  Anda dapat menambahkan sumber daya baru menggunakan perintah: </p><br><pre> <code class="plaintext hljs">operator-sdk add api --api-version=services.example.com/v1alpha1 --kind=MonitoredService</code> </pre> <br><p>  Perintah ini akan menambahkan definisi skema sumber daya <code>MonitoredService</code> ke direktori <code>pkg/apis</code> , serta yaml dengan definisi <code>CRD</code> di <code>deploy/crds</code> .  Dari semua file yang dihasilkan, Anda hanya perlu mengubah definisi skema secara manual di <a href=""><code>monitoredservice_types.go</code></a> .  Tipe <code>MonitoredServiceSpec</code> mendefinisikan status sumber daya yang diinginkan: apa yang ditentukan pengguna dalam yaml dengan definisi sumber daya.  Dalam konteks operator kami, bidang <code>Size</code> menentukan jumlah replika yang diinginkan, <code>ConfigRepo</code> menunjukkan dari mana konfigurasi saat ini dapat ditarik.  <code>MonitoredServiceStatus</code> menentukan keadaan sumber daya yang diamati, misalnya, ia menyimpan nama-nama Pods yang dimiliki sumber daya ini dan Pods <code>spec</code> saat ini. </p><br><p>  Setelah mengedit skema, Anda perlu menjalankan perintah: </p><br><pre> <code class="plaintext hljs">operator-sdk generate k8s</code> </pre> <br><p>  Ini akan memperbarui definisi <code>CRD</code> di <code>deploy/crds</code> . </p><br><p>  Sekarang mari kita buat bagian utama dari operator kami, controller: </p><br><pre> <code class="plaintext hljs">operator-sdk add controller --api-version=services.example.com/v1alpha1 --kind=Monitor</code> </pre> <br><p>  File <a href=""><code>monitor_controller.go</code></a> akan muncul di <a href=""><code>monitor_controller.go</code></a> <code>pkg/controller</code> , di mana kita menambahkan logika yang kita butuhkan. </p><br><h2 id="razrabotka-kontrollera">  Pengembangan Kontroler </h2><br><p>  Pengontrol adalah unit kerja utama operator.  Dalam kasus kami, ada dua pengontrol: </p><br><ul><li>  Kontroler monitor memantau perubahan konfigurasi layanan; </li><li>  Pengontrol pemutakhiran memperbarui layanan dan mempertahankannya dalam kondisi yang diinginkan. </li></ul><br><p>  Pada intinya, controller adalah loop kontrol, memonitor antrian dengan peristiwa berlangganannya dan memprosesnya: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/220/2e6/a09/2202e6a0931df3e5b87c4442dd839615.png" alt="Gambar"></p><br><p>  Kontroler baru dibuat dan didaftarkan oleh manajer dalam metode <code>add</code> : </p><br><pre> <code class="plaintext hljs">c, err := controller.New("monitor-controller", mgr, controller.Options{Reconciler: r})</code> </pre> <br><p>  Menggunakan metode <code>Watch</code> , kami berlangganan ke acara terkait penciptaan sumber daya baru atau pembaruan <code>Spec</code> dari sumber daya <code>MonitoredService</code> ada: </p><br><pre> <code class="plaintext hljs">err = c.Watch(&amp;source.Kind{Type: &amp;servicesv1alpha1.MonitoredService{}}, &amp;handler.EnqueueRequestForObject{}, common.CreateOrUpdateSpecPredicate)</code> </pre> <br><p>  Jenis acara dapat dikonfigurasi menggunakan parameter <code>src</code> dan <code>predicates</code> .  <code>src</code> menerima objek bertipe <code>Source</code> . </p><br><ul><li>  <code>Informer</code> - secara berkala polling <code>apiserver</code> untuk peristiwa yang cocok dengan filter, jika ada peristiwa seperti itu, masukkan ke dalam antrian pengontrol.  Di <code>controller-runtime</code> ini adalah pembungkus atas <code>SharedIndexInformer</code> dari <code>client-go</code> . </li><li>  <code>Kind</code> juga merupakan pembungkus lebih dari <code>SharedIndexInformer</code> , tetapi, tidak seperti <code>Informer</code> , itu secara independen membuat contoh informan berdasarkan parameter yang dikirimkan (skema sumber daya yang dipantau). </li><li>  <code>Channel</code> - menerima acara <code>chan event.GenericEvent</code> sebagai parameter, peristiwa yang datang melaluinya ditempatkan dalam antrian pengontrol. </li></ul><br><p>  <code>redicates</code> mengharapkan objek yang memenuhi antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Predicate</code></a> .  Bahkan, ini adalah filter tambahan untuk acara, misalnya, saat memfilter <code>UpdateEvent</code> Anda bisa melihat perubahan apa yang dibuat dalam <code>spec</code> sumber daya. </p><br><p>  Ketika suatu peristiwa tiba, seorang <code>EventHandler</code> menerimanya - argumen kedua dari metode <code>Watch</code> - yang membungkus peristiwa tersebut dalam format permintaan yang diharapkan oleh <code>Reconciler</code> : </p><br><ul><li>  <code>EnqueueRequestForObject</code> - membuat permintaan dengan nama dan namespace objek yang menyebabkan peristiwa; </li><li>  <code>EnqueueRequestForOwner</code> - membuat permintaan dengan data induk objek.  Ini diperlukan, misalnya, jika <code>Pod</code> dikontrol sumber daya telah dihapus, dan Anda perlu memulai penggantinya; </li><li>  <code>EnqueueRequestsFromMapFunc</code> - sebagai parameter fungsi <code>map</code> yang menerima acara (dibungkus dengan <code>MapObject</code> ) dan mengembalikan daftar permintaan.  <a href="">Contoh ketika pawang</a> ini <a href="">diperlukan</a> - ada timer, untuk setiap centang yang Anda butuhkan untuk mengeluarkan konfigurasi baru untuk semua layanan yang tersedia. </li></ul><br><p>  Permintaan ditempatkan di antrian pengontrol, dan salah satu pekerja (secara default pengontrol memiliki satu) menarik peristiwa keluar dari antrian dan meneruskannya ke <code>Reconciler</code> . </p><br><p>  <strong>Reconciler</strong> mengimplementasikan hanya satu metode - <code>Reconcile</code> , yang berisi logika dasar pemrosesan peristiwa: </p><br><div class="spoiler">  <b class="spoiler_title">metode rekonsiliasi</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">func (r *ReconcileMonitor) Reconcile(request reconcile.Request) (reconcile.Result, error) { reqLogger := log.WithValues("Request.Namespace", request.Namespace, "Request.Name", request.Name) reqLogger.Info("Checking updates in repo for MonitoredService") // fetch the Monitor instance instance := &amp;servicesv1alpha1.MonitoredService{} err := r.client.Get(context.Background(), request.NamespacedName, instance) if err != nil { if errors.IsNotFound(err) { // Request object not found, could have been deleted after reconcile request. // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers. // Return and don't requeue return reconcile.Result{}, nil } // Error reading the object - requeue the request. return reconcile.Result{}, err } // check if service's config was updated // if it was, send event to upgrade controller if podSpec, ok := r.isServiceConfigUpdated(instance); ok { // Update instance Spec instance.Status.PodSpec = *podSpec instance.Status.ConfigChanged = true err = r.client.Status().Update(context.Background(), instance) if err != nil { reqLogger.Error(err, "Failed to update service status", "Service.Namespace", instance.Namespace, "Service.Name", instance.Name) return reconcile.Result{}, err } r.eventsChan &lt;- event.GenericEvent{Meta: &amp;servicesv1alpha1.MonitoredService{}, Object: instance} } return reconcile.Result{}, nil }</code> </pre> </div></div><br><p>  Metode menerima objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Request</code></a> dengan bidang <code>NamespacedName</code> , di mana sumber daya dapat ditarik dari cache: <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> .  Dalam contoh ini, permintaan dibuat ke file dengan konfigurasi layanan yang dirujuk oleh bidang <code>ConfigRepo</code> dalam <code>spec</code> sumber daya.  Jika konfigurasi diperbarui, acara baru dari tipe <code>GenericEvent</code> dan dikirim ke saluran yang didengarkan pengontrol pemutakhiran. </p><br><p>  Setelah memproses permintaan, <code>Reconcile</code> mengembalikan objek bertipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Result</code></a> dan <code>error</code> .  Jika bidang <code>Result</code> adalah <code>Requeue: true</code> atau <code>error != nil</code> , controller akan mengembalikan permintaan kembali ke antrian menggunakan metode <code>queue.AddRateLimited</code> .  Permintaan akan dikembalikan ke antrian dengan penundaan, yang ditentukan oleh <code>RateLimiter</code> .  Secara default, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ItemExponentialFailureRateLimiter</code></a> digunakan, yang meningkatkan waktu tunda secara eksponensial dengan peningkatan jumlah permintaan "pengembalian".  Jika bidang <code>Requeue</code> tidak disetel, dan tidak ada kesalahan terjadi selama pemrosesan permintaan, controller akan memanggil metode <code>Queue.Forget</code> , yang akan menghapus permintaan dari cache <code>RateLimiter</code> (dengan demikian mengatur ulang jumlah pengembalian).  Pada akhir pemrosesan permintaan, pengontrol menghapusnya dari antrian menggunakan metode <code>Queue.Done</code> . </p><br><h2 id="zapusk-operatora">  Peluncuran operator </h2><br><p>  Komponen operator dijelaskan di atas, dan satu pertanyaan tetap: bagaimana memulainya.  Pertama, Anda perlu memastikan bahwa semua sumber daya yang diperlukan sudah diinstal (untuk pengujian lokal, saya sarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyiapkan minikube</a> ): </p><br><pre> <code class="plaintext hljs"># Setup Service Account kubectl create -f deploy/service_account.yaml # Setup RBAC kubectl create -f deploy/role.yaml kubectl create -f deploy/role_binding.yaml # Setup the CRD kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_crd.yaml # Setup custom resource kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_cr.yaml</code> </pre> <br><p>  Setelah prasyarat dipenuhi, ada dua cara mudah untuk menjalankan pernyataan untuk pengujian.  Cara termudah adalah memulainya di luar cluster menggunakan perintah: </p><br><pre> <code class="plaintext hljs">operator-sdk up local --namespace=default</code> </pre> <br><p>  Cara kedua adalah menggunakan operator di cluster.  Pertama, Anda perlu membuat gambar Docker dengan operator: </p><br><pre> <code class="plaintext hljs">operator-sdk build config-monitor-operator:latest</code> </pre> <br><p>  Dalam file <code>deploy/operator.yaml</code> , ganti <code>REPLACE_IMAGE</code> dengan <code>config-monitor-operator:latest</code> : </p><br><pre> <code class="plaintext hljs">sed -i "" 's|REPLACE_IMAGE|config-monitor-operator:latest|g' deploy/operator.yaml</code> </pre> <br><p>  Buat Penempatan dengan pernyataan: </p><br><pre> <code class="plaintext hljs">kubectl create -f deploy/operator.yaml</code> </pre> <br><p>  Sekarang dalam daftar <code>Pod</code> pada cluster akan muncul <code>Pod</code> dengan layanan tes, dan dalam kasus kedua - yang lain dengan operator. </p><br><h2 id="vmesto-zaklyucheniya-ili-best-practices">  Alih-alih kesimpulan atau praktik terbaik </h2><br><p>  Masalah utama pengembangan operator saat ini adalah dokumentasi alat yang lemah dan kurangnya praktik terbaik yang ada.  Ketika pengembang baru mulai mengembangkan operator, ia tidak punya tempat untuk melihat contoh penerapan persyaratan tertentu, sehingga kesalahan tidak dapat dihindari.  Berikut adalah beberapa pelajaran yang kami pelajari dari kesalahan kami: </p><br><ul><li>  Jika ada dua aplikasi terkait, Anda harus menghindari keinginan untuk menggabungkannya dengan satu operator.  Jika tidak, prinsip layanan kopling longgar dilanggar. </li><li>  Anda harus ingat tentang pemisahan masalah: Anda tidak harus mencoba menerapkan semua logika dalam satu pengontrol.  Sebagai contoh, ada baiknya menyebarkan fungsi pemantauan konfigurasi dan membuat / memperbarui sumber daya. </li><li>  Memblokir panggilan harus dihindari dalam metode <code>Reconcile</code> .  Misalnya, Anda dapat menarik konfigurasi dari sumber eksternal, tetapi jika operasinya lebih lama, buat goroutine untuk ini, dan kirim permintaan kembali ke antrian, yang menunjukkan dalam respons <code>Requeue: true</code> . </li></ul><br><p>  Dalam komentar, akan menarik untuk mendengar tentang pengalaman Anda dalam mengembangkan operator.  Dan di bagian selanjutnya kita akan berbicara tentang pengujian operator. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446648/">https://habr.com/ru/post/id446648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446632/index.html">Dari Hukum ke Pengembangan Data Besar</a></li>
<li><a href="../id446634/index.html">Digest SDN - Enam Emulator Open Source</a></li>
<li><a href="../id446638/index.html">Cisco HyperFlex vs. pesaing: menguji kinerja</a></li>
<li><a href="../id446640/index.html">20 proyek, 20 bahasa, batas waktu kemarin. Bagian 2</a></li>
<li><a href="../id446642/index.html">Daftar periksa untuk membuat dan menerbitkan aplikasi web</a></li>
<li><a href="../id446654/index.html">Bagaimana kami menyimpan ulasan kode</a></li>
<li><a href="../id446656/index.html">Pengodean suara 1600bit / s dengan neural vocoder LPCNet</a></li>
<li><a href="../id446660/index.html">AI, siswa dan hadiah besar: bagaimana melakukan pembelajaran mesin di kelas 8</a></li>
<li><a href="../id446662/index.html">Transaksi dan mekanisme untuk kontrol mereka</a></li>
<li><a href="../id446664/index.html">SAP Forum 2019 hanya 2 minggu lagi! Apa yang akan ada di sana?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>