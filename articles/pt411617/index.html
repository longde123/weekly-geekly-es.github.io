<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö™Ô∏è üé¶ üë©üèª‚Äçüíº Sistema de m√≠dia para Toyota Prius (Restayl) üê∂ üö¥üèø üöØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este √© o primeiro artigo (introdut√≥rio) da s√©rie sobre como vou refinar o sistema de m√≠dia do carro. O projeto em si est√° em andamento, n√£o h√° tempo, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de m√≠dia para Toyota Prius (Restayl)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411617/"><img src="https://habrastorage.org/webt/pw/a0/k_/pwa0k_aaxeguedncth7a5fdkm70.jpeg"><br><br>  Este √© o primeiro artigo (introdut√≥rio) da s√©rie sobre como vou refinar o sistema de m√≠dia do carro.  O projeto em si est√° em andamento, n√£o h√° tempo, como todo mundo, portanto, queridos leitores, por favor, seja paciente, porque muitas vezes n√£o prometo rebitar artigos. <br><br>  Tudo come√ßou com o fato de eu ter um Prius. <br><br>  E a primeira coisa que chamou minha aten√ß√£o foram os problemas com a atualiza√ß√£o da navega√ß√£o.  A seguir, s√£o muito escassos, mas em alguns lugares os recursos necess√°rios de um dispositivo chamado "Monitor Multifuncional" (em pessoas comuns - a cabe√ßa).  E isso acontece no contexto de um grande n√∫mero de r√°dios chinesas com Android a bordo e de muitas comodidades.  Mas sua instala√ß√£o em um local regular implica a priva√ß√£o de tais "p√£es" como um diagrama da distribui√ß√£o de energia e controle clim√°tico. <br><br>  A id√©ia nasceu para, de alguma forma, conectar o r√°dio Android ao carro com mais for√ßa do que os irm√£os chineses sugerem.  Sobre isso e o artigo. <br><a name="habracut"></a><br><h3>  Situa√ß√£o inicial </h3><br>  Ent√£o  A bordo, h√° uma tela de 7 polegadas com uma tela de toque resistiva, conectada a outros eletr√¥nicos com as linhas TX + e TX-.  E j√° existem 3 pares desse tipo na cabe√ßa.No circuito, esse milagre √© chamado AVC-LAN, e se parece com isso: <br><br><img src="https://habrastorage.org/webt/ml/uo/le/mluolei1uqdz85xpjdh43hxjyvk.png"><br><br><h2>  Parte 1: Olhando em volta </h2><br>  Como voc√™ pode ver, a cabe√ßa est√° na brecha da rede, entre o roteador e a cadeia posterior do r√°dio, o amplificador (eu o tenho separadamente) e uma conex√£o com a unidade de navega√ß√£o segue um canal separado.  Em outro lugar, uma unidade de estacionamento est√° suspensa, n√£o mencionada de nenhuma maneira nos meus esquemas.  Bem, bem ... eu decidi adiar a proximidade com ela at√© tempos melhores.  Al√©m disso, o estacionamento √© mais uma fun√ß√£o do jogo do que uma necessidade real. <br><br>  Depois de remover todos os desnecess√°rios, obtemos aproximadamente o seguinte diagrama de blocos dos dispositivos: <br><br><img src="https://habrastorage.org/webt/qb/az/gl/qbazglszcggkjhudk80w91l9tdg.png"><br><br><h3>  Reflex√µes </h3><br>  Havia uma id√©ia de simplesmente substituir a unidade de navega√ß√£o por algo android, mas desapareceu quando eu entendi mais profundamente como eles se comunicavam com a cabe√ßa.  Al√©m da AVC-LAN, esses m√≥dulos tamb√©m s√£o conectados pela linha GVIF (Gigabit Video InterFace), e essa mesma face dos fabricantes de conversores pode quebrar acidentalmente se eu tamb√©m comprar um conversor de sinal de v√≠deo na GVIF por mais de US $ 100. ‚ÄúViver sem rosto √© ser pode ser dif√≠cil, mas .. "- soou na minha cabe√ßa o motivo de uma m√∫sica famosa, e eu n√£o gostei da decis√£o. <br><br>  Havia solu√ß√µes na rede com a instala√ß√£o de um r√°dio chin√™s em vez de um receptor de r√°dio.  Isso n√£o me agradou, porque os dois monitores s√£o redund√¢ncia irracional.  IMHO. <br><br><h2>  Solu√ß√£o </h2><br>  Nasceu a seguinte solu√ß√£o: substituir a cabe√ßa inteira e finalizar o r√°dio Android, fazendo amizade com o Prius, pelo qual: <br><br><ol><li>  Conversor de hardware USB &lt;-&gt; AVC-LAN de design </li><li>  Desenvolva firmware para ele, para que ele se conecte como um USB-HID. </li><li>  Torne-o composto para que uma das fun√ß√µes seja detectada como um teclado de hardware normal (para us√°-lo como um controle nativo nos bot√µes no painel) </li><li>  Desenvolva um aplicativo Android com funcionalidade semelhante ao (ou superior) ao nativo Priusovsky </li><li>  Alinhar a c√¢mera traseira </li><li>  Resolver problemas na parte mec√¢nica (instala√ß√£o em local regular) </li></ol><br>  No processo, ser√° necess√°rio desenvolver outro aplicativo para Android - um sniffer comum, para que seja mais conveniente reverter pacotes no AVC-LAN.  Ao mesmo tempo e pr√°tica. <br><br>  Deve ficar assim: <br><br><img src="https://habrastorage.org/webt/_x/7j/f2/_x7jf2mr_9mp0ow3yxwds8yuhuc.png"><br><br>  Como base de hardware, foi decidido usar uma placa de treinamento no SM32F103: <br><br><img src="https://habrastorage.org/webt/oo/u8/1y/oou81yrznrr2hcnayb2emjfb_lw.jpeg"><br><br>  Encomendado no AliExpress por US $ 2,05. <br><br><div class="spoiler">  <b class="spoiler_title">Ou pesquise - spoiler</b> <div class="spoiler_text">  Talvez o lote j√° tenha sido exclu√≠do pelo vendedor, por isso dou a sequ√™ncia m√°gica para pesquisar no Ali: <br>  STM32F103C8T6 M√≥dulo m√≠nimo da placa de desenvolvimento do sistema do BRA√áO STM32 <br></div></div><br>  O que eu gosto nela: <br><br><ul><li>  M√≥dulo de hardware USB (dispositivo) a bordo do processador </li><li>  Pilha USB adequada do fabricante (diferente da Freescale-ovsky, n√£o √© lembrada √† noite). </li><li>  Portas GPIO gratuitas que podem ser usadas para conectar bot√µes regulares nas laterais do monitor.  Talvez isso oculte os bot√µes de hardware do r√°dio abaixo do painel.  N√£o sei o que ela vai ser </li><li>  E nele voc√™ pode pendurar o conversor AVC-LAN em n√≠veis l√≥gicos </li></ul><br>  Descreverei mais adiante na ordem de implementa√ß√£o, que √© devida, antes de tudo, ao meu conhecimento pessoal.  I.e.  Tentei perceber os lugares em que eles n√£o estavam no come√ßo, deixando o que certamente deveria acontecer. <br><br>  De qualquer forma, v√°rios artigos s√£o planejados em diferentes hubs.  O projeto acaba sendo muito FullStack - da conex√£o de hardware ao aplicativo Android. <br><br><h2>  Parte 2: USB, HID, descritores e tudo para obter um prot√≥tipo piloto </h2><br>  O primeiro passo era obter um monte de dispositivos e telefones, para que o dispositivo pudesse transferir o pacote para o telefone, e isso - para exibi-lo no aplicativo. <br>  Como Gagarin disse: Vamos! <br><br><h3>  Dispositivo composto USB HID no STM32 </h3><br>  O que eu decidi fazer foi adaptar o exemplo ST de minhas tarefas e obter um dispositivo USB que seja reconhecido pelo host como parte do teclado e "outra coisa" - o Dispositivo RAW HID.  O primeiro, como eu j√° disse, destina-se ao controle nativo do Android, o segundo - √† troca direta de pacotes AVC-LAN com o programa no dispositivo. <br><br>  Com base no CubeMX da STM, e depois de ler muitos artigos sobre como implementar o HID personalizado, descobri uma coisa desagrad√°vel na rede: a quest√£o da cria√ß√£o de dispositivos compostos √© praticamente ausente ou muito escassa. <br><br><div class="spoiler">  <b class="spoiler_title">Os c√≥digos-fonte ser√£o mais tarde</b> <div class="spoiler_text">  Ainda n√£o carreguei os c√≥digos-fonte, devido ao fato de o projeto estar agora sendo implementado no modo de treinamento experimental.  Se o projeto for conclu√≠do com √™xito, arraste-os para o Github e edite o artigo com um link para eles. <br>  Na forma em que est√£o, n√£o faz sentido fazer o upload - h√° bastante bagun√ßa na Internet sem mim. <br></div></div><br><h4>  USB, Composto, HID </h4><br>  Apenas algumas palavras sobre este assunto.  Sup√µe-se que voc√™ esteja mais ou menos familiarizado com o padr√£o USB.  Caso contr√°rio, √© melhor primeiro se familiarizar e experimentar exemplos do CubeMX. <br><br>  Ent√£o n√≥s temos: <br><br>  Exemplo de implementa√ß√£o de pilha e mouse USB do STM.  L√°, configuramos alguns descritores e um ponto de extremidade funcional.  Isso al√©m de um par de 0x00 e 0x80 para controlar o dispositivo inteiro. <br><br>  Para implementar meu projeto, preciso que o endpoint do teclado seja bidirecional (n√£o sei por que - √© √∫til) e mais alguns endpoints que ser√£o usados ‚Äã‚Äãpara trocar dados com a segunda fun√ß√£o - RAW.  Adicione-os. <br><br>  Tornamos o ponto bidirecional adicionando o ponto OUT ao descritor: <br><br><div class="spoiler">  <b class="spoiler_title">Descritor de configura√ß√£o.</b> <div class="spoiler_text">  Ao editar um descritor, fique de olho nos √≠ndices e tamanhos. <br>  (2c5cf968121f0d8fa43a6755c09e15ef3a317791): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPOUT_ADDR, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPOUT_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL,</code> </pre> <br></div></div><br>  E adicione mais alguns pontos: <br><br><div class="spoiler">  <b class="spoiler_title">Descritor de configura√ß√£o</b> <div class="spoiler_text">  (bc2bd583c98715e106fcb3ab07b266bc9221be36): <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* 59 */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPIN_ADDR2, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPIN_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL, <span class="hljs-comment"><span class="hljs-comment">/*bInterval: Polling Interval (10 ms)*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 66 */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPOUT_ADDR2, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPOUT_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL, <span class="hljs-comment"><span class="hljs-comment">/*bInterval: Polling Interval (10 ms)*/</span></span></code> </pre><br></div></div><br>  Era um descritor de configura√ß√£o.  Agora, o host ter√° certeza de que temos algum tipo de dispositivo HID composto e voc√™ poder√° enviar dados para todos esses pontos.  Mas isso n√£o √© verdade. <br>  Para tornar isso verdade: <br><br>  1. Nosso controlador possui uma mem√≥ria especialmente alocada que √© sincronizada com os m√≥dulos CAN e USB.  Dado que o m√≥dulo USB est√° envolvido de maneira independente no processo de recebimento / transmiss√£o de um pacote de dados, √© necess√°rio definir buffers nesta parte da mem√≥ria para cada terminal individual: <br><br><div class="spoiler">  <b class="spoiler_title">USBD_LL_Init no arquivo usbd_conf.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x00</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x18</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x80</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x58</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPOUT_ADDR , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPIN_ADDR , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x140</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPOUT_ADDR2 , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x180</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPIN_ADDR2 , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x1B0</span></span>);</code> </pre><br></div></div><br>  Os endere√ßos de buffer s√£o arbitr√°rios, se eles n√£o se sobrepuserem. <br><br>  Por alguma raz√£o, a pilha ST √© gravada com a expectativa de que o dispositivo n√£o tenha mais que um ponto de extremidade bidirecional, portanto, modificaremos a pilha um pouco: <br><br><h4>  Transferir </h4><br>  Renomeie o procedimento USBD_HID_SendReport para USBD_HID_SendReportEP, adicionando mais um par√¢metro - o n√∫mero do terminal.  Deixamos o procedimento com o nome antigo para compatibilidade com vers√µes anteriores, mas no corpo chamamos USBD_HID_SendReportEP com uma constante na forma de um terminal.  A solu√ß√£o ainda n√£o √© a mais est√©tica, mas funcionar√° para o experimento e, mesmo que permane√ßa, n√£o interferir√° em um projeto espec√≠fico. <br><br><div class="spoiler">  <b class="spoiler_title">usbd_hid.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_HID_SendReportEP (USBD_HandleTypeDef *pdev, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ep, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *report, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len) { ... ,   USBD_HID_SendReport } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_HID_SendReport (USBD_HandleTypeDef *pdev, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *report, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_HID_SendReportEP(pdev,HID_EPIN_ADDR,report,len); }</code> </pre><br></div></div><br>  Agora tudo est√° pronto para enviar dados, resta apenas no momento certo para chamar esta fun√ß√£o. <br><br><h4>  Finaliza√ß√£o </h4><br>  Por uma quest√£o de ordem, procuramos o projeto e chamamos USBD_LL_CloseEP novamente, mas os pontos de extremidade rec√©m-criados. <br><br><h4>  Recep√ß√£o </h4><br>  Para que os pontos de extremidade sejam ajustados moralmente para funcionarem, voc√™ precisa chamar USBD_LL_PrepareReceive para eles.  Eu recomendo que o leitor repasse a pesquisa do projeto para esta linha e adapte essas chamadas √†s suas necessidades. <br><br>  Eu tenho esse choco feio no meu c√≥digo: <br><br><div class="spoiler">  <b class="spoiler_title">usbd_core.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs">USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR+(epnum&amp;<span class="hljs-number"><span class="hljs-number">0x7F</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span> , hhid-&gt;Report_buf, USBD_HID_OUTREPORT_BUF_SIZE);</code> </pre><br></div></div><br>  I.e.  Eu procedi do fato de que o n√∫mero de pontos de extremidade √© seguido.  Isso √© ruim, IMHO.  N√£o fa√ßa isso.  No entanto, tamb√©m n√£o gosta do ST. <br><br>  Tudo o que resta √© acessar o arquivo usbd_hid.c e, especificamente, a fun√ß√£o USBD_HID_DataOut, e certifique-se de que a chamada para o manipulador de dados recebido corresponda √†s suas id√©ias pessoais sobre o belo.  Como tamb√©m n√£o tive sucesso, o c√≥digo e a descri√ß√£o ser√£o longos e incompreens√≠veis.  Mais f√°cil de fazer voc√™ mesmo. <br><br><h4>  Relat√≥rio </h4><br>  Tudo, neste local, temos um dispositivo composto capaz de trocar dados atrav√©s de dois pontos bidirecionais.  No √∫ltimo golpe, "calamos a boca" a curiosidade do motorista da HID, descrevendo um descritor de relat√≥rio: <br><br><pre> <code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> HID_ReportDesc2[<span class="hljs-number"><span class="hljs-number">33</span></span>] __ALIGN_END = { <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE_PAGE (Vendor Defined Page 1) 0x09, 0x01, // USAGE (Vendor Usage 1) 0xa1, 0x01, // COLLECTION (Application) 0x85, 0x01, // REPORT_ID (1) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x26, 0xff, 0x00, // LOGICAL_MAXIMUM (255) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x1f, // REPORT_COUNT (31) 0x09, 0x00, // USAGE (Undefined) 0x81, 0x00, // INPUT (Data,Ary,Abs) 0x85, 0x02, // REPORT_ID (2) 0x09, 0x01, // USAGE (Vendor Usage 1) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x1f, // REPORT_COUNT (31) 0x91, 0x00, // OUTPUT (Data,Ary,Abs) 0xc0 // END_COLLECTION };</span></span></code> </pre><br>  Este relat√≥rio informa ao driver HID: haver√° cerca de 31 bytes de dados.  N√£o h√° necessidade de descobrir o que s√£o - basta fornec√™-los ao programa que abriu este dispositivo.  Em um relat√≥rio f√≠sico, o byte zero ser√° igual ao √≠ndice do relat√≥rio (REPORT_ID (2)).  Assim, um total de 32 bytes vir√°. <br><br>  E insira os dados sobre isso em usbd-hid.c, fun√ß√£o USBD_HID_Setup. <br><br><div class="spoiler">  <b class="spoiler_title">usbd-hid.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (req-&gt;bRequest) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_DESCRIPTOR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;wValue &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> == HID_REPORT_DESC) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> !!!   ,     req-&gt;wIndex !!! THIDDescPtrLen * rep = (req-&gt;wIndex==1)?&amp;HID_ReportDesc:&amp;HID_ReportDesc2; len = MIN(rep-&gt;len , req-&gt;wLength); pbuf = rep-&gt;ptr; }</span></span></code> </pre></div></div><br><h3>  Mais adiante no programa: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Montagem do conversor de n√≠vel l√≥gico AVC-LAN e conex√£o √† placa.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">An√°lise da camada f√≠sica do AVC-LAN, formas de onda reais.</a> </li><li>  Processando a interface no n√≠vel do controlador e enviando pacotes com relat√≥rios </li><li>  Interface ponta a ponta e engenharia reversa Prius.  Sniffer de pacote (ou meu primeiro aplicativo Android) </li></ol><br><h4>  PS </h4><br><ul><li>  Decidi escrever um artigo porque fui for√ßado (quase), convencendo que isso deveria ser compartilhado.  Mesmo se eu n√£o concluir o projeto, algumas das informa√ß√µes mais recentes podem ajudar algu√©m, mesmo que de forma "bruta". </li><li>  As cr√≠ticas ao projeto s√£o bem-vindas, pois  Eu mesmo ainda n√£o imagino completamente que vai dar certo. </li><li>  Cr√≠ticas ao artigo, design, apresenta√ß√£o - principalmente porque  Este √© o primeiro artigo para o recurso.  Com a continua√ß√£o do trabalho, gostaria de expressar meus pensamentos da forma usual e diger√≠vel para os leitores </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt411617/">https://habr.com/ru/post/pt411617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt411603/index.html">Como Nike 3D imprime t√™nis de corrida exclusivos para corredores de elite</a></li>
<li><a href="../pt411605/index.html">"THIS_". Como √© organizado o escrit√≥rio das empresas de TI da Kuzbass</a></li>
<li><a href="../pt411609/index.html">5 fotos da NASA que mudaram o mundo</a></li>
<li><a href="../pt411611/index.html">A lei de Spring-Ozerov - das palavras √†s a√ß√µes</a></li>
<li><a href="../pt411613/index.html">Clash of the Titans: comparando os principais leitores do PocketBook 740 e Amazon Kindle Oasis 2017</a></li>
<li><a href="../pt411621/index.html">A SpaceX construir√° o Big Fucking Rocket em Los Angeles</a></li>
<li><a href="../pt411623/index.html">Os cientistas criaram uma enzima que quebra o pl√°stico</a></li>
<li><a href="../pt411625/index.html">Radio-86RK no ESP-01S</a></li>
<li><a href="../pt411629/index.html">Como restauramos a programa√ß√£o de √¥nibus interurbanos</a></li>
<li><a href="../pt411631/index.html">O telegrama na R√∫ssia pode ser bloqueado devido aos planos de Durov de lan√ßar sua pr√≥pria criptomoeda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>