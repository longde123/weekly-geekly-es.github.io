<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏾 🧒🏾 👩‍🎨 Was ist neu in der Angular 8-Version? ♎️ 👩🏻‍🤝‍👨🏽 🦍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So kam Winkel 8 heraus, es enthält eine Efeu-Vorschau, Unterstützung für Servicemitarbeiter, differenzielles Laden und ein paar andere Feinarbeiten. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist neu in der Angular 8-Version?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455493/">  So kam Winkel 8 heraus, es enthält eine Efeu-Vorschau, Unterstützung für Servicemitarbeiter, differenzielles Laden und ein paar andere Feinarbeiten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Manfred Steyer</a> erklärt die wichtigsten Änderungen in der neuesten Version. <br><br>  Wie geplant gab es keine Überraschungen: Die Aktualisierung des Frameworks und der CLI kann mithilfe von ng update erfolgen, und neue Funktionen sind eine schöne Ergänzung zum Motto „Evolution statt Revolution“. <br><br>  In diesem Artikel spricht der Autor über die wichtigsten neuen Funktionen von Angular 8 und Angular CLI 8. Die im Artikel verwendeten Beispiele finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br><h4>  Unter dem Schnitt: </h4><br><ul><li>  Schauen Sie sich zuerst Ivy an </li><li>  Web-Worker </li><li>  Differenzbelastung </li><li>  Faule Lademodule </li><li>  Kritische Änderungen in ViewChild und ContentChild </li><li>  Neue Funktionen ngUpgrade </li></ul><br><a name="habracut"></a><br><h2>  Schauen Sie sich zuerst Ivy an </h2><br>  Die nächste große Neuigkeit, auf die die Angular-Community wartet, ist Ivy, ein neuer Compiler und auch eine neue Rendering-Engine.  Ivy kann erheblich kleinere Bundles und inkrementelle Kompilierungen generieren und ist auch die Grundlage für zukünftige Innovationen in Angular. <br><br>  Da viele der grundlegenden Teile von Angular geändert wurden, hat das Angular-Team besonderes Augenmerk auf die Kompatibilität mit früheren Versionen gelegt: Nach dem Upgrade auf Ivy sollten vorhandene Anwendungen auf die gleiche Weise wie zuvor funktionieren.  Bestenfalls erhalten Sie viel kleinere Bündel.  Dies ist nicht desinteressiert, da mehr als 600 Anwendungen bei Google offiziell auf Angular basieren - die tatsächliche Anzahl soll viel höher sein. <br><br>  Mit Angular 8 steht eine vorläufige Version von Ivy zum Testen zur Verfügung.  Der Zweck dieser Version ist es, schnelles Feedback zu erhalten.  Aus diesem Grund empfiehlt das Angular-Team, Ivy derzeit nicht im Produkt zu verwenden, sondern weiterhin die klassische Ansichts-Engine zu verwenden (Abb. 1). <br><img src="https://habrastorage.org/webt/wn/rb/ti/wnrbtie8kro1xuebbrv-emal3te.png"><br><br>  Dank der unterschiedlichen Belastung (siehe unten) können die Bündelgrößen jetzt optimiert werden. <br><br>  Laut Brad Green, CTO des Angular-Teams bei Google, wird Ivy auf der ngconf 2019 die Paketgrößen im Kompatibilitätsmodus in Kombination mit der unterschiedlichen Belastung erheblich verbessern.  So können Draufgänger bereits die zukünftige Ivy-API testen.  Insbesondere dieser Modus bietet ein großes Optimierungspotential.  Die API ist weiterhin als privat markiert.  Wenn man sich seine Klassen und Funktionen ansieht, kann man sagen: Sie beginnen mit einem speziellen Symbol ɵ. <br><br>  Wenn Sie Ivy bereits ausprobieren möchten, können Sie mit dem Schalter enable-ivy ein neues Projekt erstellen: <br><pre><code class="bash hljs">ng new ivy-project --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-ivy</code> </pre> <br>  Dieser Schlüssel weist die CLI an, den folgenden Eintrag in der Konfiguration tsconfig.app.json zu speichern: <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Dieser Eintrag kann auch manuell nach dem Upgrade auf Version 8 hinzugefügt werden, um eine vorhandene Anwendung mit Ivy zu testen. <br>  Um die Anwendung im Debug-Modus auszuführen, wird empfohlen, AOT zu verwenden: <br><pre> <code class="bash hljs">ng serve --aot</code> </pre> <br>  Außerdem sollten Sie auf die Größe der Anwendung achten, die mit ng build erstellt wurde.  Mit Winkel 9 sollte Ivy standardmäßig aktiviert sein.  Bis dahin plant das Angular-Team, weiter daran zu arbeiten, die Kompatibilität mit älteren Versionen sicherzustellen. <br><br><h2>  Web-Worker </h2><br>  JavaScript ist per Definition Single-Threaded.  Aus diesem Grund werden zeitaufwändige Aufgaben wie das Abfragen von Daten normalerweise asynchron ausgeführt.  Dies hilft natürlich nicht bei komplexen Berechnungen.  Sie werden besonders häufig bei umfangreichen JavaScript-Lösungen verwendet, sodass wir Web-Worker in fast allen Webbrowsern unterstützen.  Dies sind Skripte, die vom Browser in einem separaten Thread gestartet werden.  Die Kommunikation mit dem Stream auf der Registerkarte Browser erfolgt über Nachrichten. <br>  Obwohl Web-Worker nicht mit Angular als solchem ​​verwandt sind, sollten sie beim Erstellen berücksichtigt werden.  Ziel ist es, für jeden Webworker ein Paket bereitzustellen.  Diese Aufgabe wurde von der neuen CLI abgeschlossen. <br>  Um eine neue Funktion zu demonstrieren, werde ich JavaScript die Implementierung des sogenannten " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n Queens" -Problems zeigen</a> . Die Idee ist, eine Königin hintereinander auf einem Schachbrett zu platzieren, ohne sich gegenseitig bedrohen zu können Die gleiche Zeile, Spalte oder Diagonale sollte keine andere Königin sein. <br><img src="https://habrastorage.org/webt/wx/px/es/wxpxesfv9odlgydmnrejoxjw-eq.png"><br>  Der Algorithmus zur Berechnung aller möglichen Lösungen auf einem Schachbrett wird als rechenintensiv angesehen.  Obwohl die Berechnungen für ein normales Schachbrett mit acht Zeilen und acht Spalten ziemlich schnell sind, haben herkömmliche Computer mit einem 12 x 12-Brett die Grenze erreicht. Die Lösung für ein 27 x 27-Brett ist der aktuelle Rekord.  Für diese Aufgabe wurden russische Supercomputer eingesetzt. <br>  Um diese Berechnung in den Hintergrund zu übersetzen, müssen wir zuerst einen Web-Worker mithilfe der CLI erstellen: <br><pre> <code class="bash hljs">ng generate worker n-queens</code> </pre> <br>  Diese Anweisung erstellt eine Datei nicht nur für den Mitarbeiter, sondern auch für die für den Erstellungsprozess erforderlichen Konfigurationsdateien und die Einträge in vorhandenen Dateien.  Wenn derselbe Ordner eine Komponente mit demselben Namen und einer gemeinsamen Dateierweiterung .component.ts enthält, fügt die CLI auch Code für die Interaktion mit dem Web Worker hinzu. <br>  Der Arbeiter selbst besteht aus einem Zuhörer für die Veranstaltung: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nQueens <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./n-queens'</span></span>; addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, ({ data }) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = nQueens(data.count); postMessage(result, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); });</code> </pre><br>  Das Ereignis wird ausgeführt, wenn der Hauptthread eine Nachricht an den Worker sendet.  Der Parameter enthält Informationen, die vom Hauptstrom gesendet werden.  In diesem Fall wird es durch die count-Eigenschaft begrenzt, die die Größe des Schachbretts festlegt.  Nach Auswertung der hier weggelassenen Funktion nQueens sendet eventListener das Ergebnis über postMessage an den Hauptthread zurück.  Somit löst der Browser ein Nachrichtenereignis aus. <br>  Die Worker-Klasse wird in der using-Komponente verwendet, um mit dem Worker-Skript zu interagieren: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-string"><span class="hljs-string">'../logic/n-queens.worker'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'module'</span></span> <span class="hljs-comment"><span class="hljs-comment">// Worker uses EcmaScript modules }); worker.postMessage({count}); worker.addEventListener('message', (event) =&gt; { // tslint:disable-next-line: no-console console.debug('worker result', event.data); // Update chessboard this.processResult(event.data); });</span></span></code> </pre><br>  Die Komponente sendet über postMessage eine Nachricht mit der gewünschten Größe des Schachbretts an den Arbeiter und startet dort die Berechnung.  Es empfängt das Ergebnis über das Nachrichtenereignis. <br>  In Zukunft sorgt die CLI für die korrekte Zusammenstellung von Arbeiterskripten.  Der TypeScript-Compiler erkennt sie am Ende von .worker.ts, das in tsconfig.worker.json registriert ist, das mit dem Befehl <i>ng generate worker erstellt wurde</i> .  Um sicherzustellen, dass die CLI diese Dateien beim Erstellen der Hauptanwendung nicht erneut beeinflusst, platziert <i>ng generate worker</i> dieselbe Dateivorlage im Ausschlussabschnitt von tsconfig.app.json. <br>  Die vollständige Implementierung erfolgt im Projekt mit Beispielen des Autors.  Zum Vergleich kann ein Beispiel für die Aufgabe N Königinnen sowohl im Hauptthread als auch im Webworker gelöst werden.  Wenn Sie beispielsweise versuchen, ein Problem für ein 12 x 12-Schachbrett zu lösen, werden Sie feststellen, dass die Benutzeroberfläche im ersten Fall hängt, während die Hintergrundberechnung mit dem Web-Worker die Leistung nicht beeinträchtigt. <br><br><h2>  Differenzbelastung </h2><br>  Bisher war es üblich, Anwendungen in das gute alte ES 5 zu kompilieren, da diese Version von „JavaScript unserer Väter“ fast überall funktioniert.  Dies bedeutet, dass sowohl IE11 als auch der Webcrawler von Google diesen Code ausführen können. <br>  Die neue ES 2015 und ihre nachfolgenden Versionen sind jedoch effizienter: Sie ermöglichen es Ihnen, kompaktere Pakete zu erstellen, und der Browser kann sie auch effizienter interpretieren.  Da es bisher üblich war, auf ES 5 als kleinsten gemeinsamen Nenner zurückzusetzen, konnten moderne Browser die neue Version der Sprache leider nicht nutzen. <br>  Jetzt ist es vorbei: Ab Version 8 verfügt die CLI über eine Funktion namens Differential Loading.  Die Idee ist, zwei Gruppen von Paketen bereitzustellen: eine basiert auf ECMAScript 5 und wurde für ältere Browser entwickelt, die andere basiert auf einer neuen Version von ECMAScript wie ECMAScript 2015 und bietet modernen Browsern die zuvor genannten Vorteile. <br>  Sie müssen nicht viel arbeiten, um das differenzielle Laden zu ermöglichen. Sie müssen lediglich die Ober- und Untergrenze der unterstützten Versionen von ECMAScript festlegen.  Die Obergrenze wird in tsconfig.json wie folgt angegeben: <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es2015"</span></span></code> </pre> <br>  Die Untergrenze wird in der Browserlistendatei definiert.  Diese Datei enthält Browser, die nach bestimmten Kriterien unterstützt werden, z. B. nach Marktanteilen.  Sie können beispielsweise in der Browserlistendatei gespeichert werden, die die CLI beim Erstellen eines neuen Projekts im Stammverzeichnis des Projekts erstellt: <br> <code>&gt; 0.5% <br> last 2 versions <br> Firefox ESR <br> not dead <br> IE 9-11 <br></code> <br>  In diesem Fall enthält die Liste der Browser ES 5-Browser mit einem IE 9-11-Eintrag.  Daher definiert die CLI den unteren Schwellenwert als diese Version.  Wenn die CLI den Befehl ng build empfängt, wird der Erstellungsprozess für beide Versionen ausgeführt: <br><img src="https://habrastorage.org/webt/ao/ln/iv/aolnivkwgyupqjziwm1whw6mlhg.png"><br>  Der Nachteil dieses Verfahrens ist folgender: Die für die Montage erforderliche Zeit verdoppelt sich. <br>  Browser können nun entscheiden, welche Version von Paketen heruntergeladen werden soll.  Zu diesem Zweck erhalten sie Links zu Skripten im Add-On index.html: Wer auf ECMAScript 5-Pakete verweist, erhält ein Nomodul.  Daher ignorieren Browser mit ECMAScript-Unterstützung und daher ECMAScript 2015+ dieses Skript nicht.  Andererseits werden ECMAScript 2015+ -Pakete von der CLI mit dem Typ = ”Modul” implementiert.  Daher ignorieren ältere Browser diese Skripte: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main-es2015.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main-es5.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">nomodule</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Im Gegensatz zu ng build verwenden die restlichen CLI-Befehle nur (!) Die Obergrenze der ES-Unterstützung.  In unserem Fall ist dies ECMAScript 2015. Dies geschieht auch aus Gründen der Effizienz: Während des Debuggens und Testens möchten Entwickler das Ergebnis normalerweise so schnell wie möglich sehen, ohne auf den zweiten Build zu warten. <br><br><h2>  Faule Lademodule </h2><br>  Angular Router unterstützt von den ersten Tagen an das verzögerte Laden.  Bisher wurde dies mit der magischen Definition eines ladbaren Moduls erreicht: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'lazy'</span></span>, <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'./lazy/lazy.module#LayzModule'</span></span> }</code> </pre><br>  Der Wert vor # beschreibt den Pfad, der zur Modulimplementierungsdatei führt.  Der Wert nach bedeutet die darin enthaltene Klasse.  Dieser Beschreibungsstil funktioniert in Angular 8, ist jedoch in Bezug auf dynamische ECMAScript-Importe veraltet: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'lazy'</span></span>, <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./lazy/lazy.module'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.LazyModule) }</code> </pre><br>  Die neue Datensatzoption enthält weiterhin den Dateinamen als magischen Wert.  Da Importe jedoch von vielen IDEs unterstützt werden, geben ungültige Werte sofort einen Fehler zurück. <br><br><h2>  Kritische Änderungen in ViewChild und ContentChild </h2><br>  Es gibt kritische Änderungen bei der Verwendung von ViewChild und ContentChild, die in der Vergangenheit leider nicht immer vorhersehbar funktionierten.  Wenn sie in früheren Versionen von einer Komponente zum Abfragen von Elementen verwendet wurden, die nicht in der Strukturanweisung enthalten sind, z. B. ngIf oder ngFor, war das Abfrageergebnis bereits in ngOnInit verfügbar.  Andernfalls könnten wir nicht früher als ngAfterViewInit (oder ngAfterContentInit für ContentChild) auf sie zugreifen.  Für Elemente, die später aufgrund von Datenbindung in das DOM geladen wurden, sollte der Programmcode ngAfterViewChecked oder dementsprechend ngAfterContentChecked haben. <br>  Da dieses Verhalten verwirrend war, sollte die Komponente jetzt angeben, wann eine Auflösung erfolgen soll: <br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'info'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">static</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) paragraph: ElementRef;</code> </pre><br>  Wenn das statische Flag true ist, versucht Angular, die Elemente zu finden, wenn die Komponente initialisiert wird.  Dies funktioniert nur, wenn sie nicht in der Strukturrichtlinie enthalten sind.  Bei Verwendung von static: false wird die Auflösung nach dem Initialisieren oder Aktualisieren der Ansicht durchgeführt. <br>  ng update versucht automatisch, den richtigen Wert einzugeben. Wenn dies nicht möglich ist, wird ein Kommentar mit TODO hinzugefügt. <br>  Diese Änderung wirkt sich nicht auf Abfragen mit ViewChildren- und ContentChildren-Dekoratoren aus.  Sie hatten immer ein dynamisches Verhalten, neu ausgedrückt im Sinne von statisch: falsch. <br><br><h2>  Neue Funktionen ngUpgrade </h2><br>  Bisher bestand eines der Probleme mit AngularJS 1.X und Angular in Verbindung mit ngUpgrade darin, dass die Router beider Frameworks aufgrund der URL miteinander konkurrierten.  Dies führte zu schwer zu erklärenden Nebenwirkungen.  Um dies zu vermeiden, wurde die Möglichkeit hinzugefügt, in beiden Versionen einen einzigen URL-Standortdienst zu verwenden. <br>  Zu diesem Zweck erweiterte das Angular-Team die Funktionen der Angular-Ortungsdienste und stellte damit einen Ersatz für $ location in AngularJS bereit. <br>  Aus diesem Grund wurde dem Standortdienst eine neue onUrlChange-Methode hinzugefügt, um URL-Änderungen zu verfolgen: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(loc: Location, pLoc: PlatformLocation) { loc.onUrlChange(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.debug(<span class="hljs-string"><span class="hljs-string">'url change'</span></span>, url)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.debug(<span class="hljs-string"><span class="hljs-string">'hostname: '</span></span>, pLoc.hostname); } }</code> </pre><br>  Der PlatformLocation-Dienst bietet zusätzlichen Zugriff auf bestimmte Teile der URL.  Eine detaillierte Beschreibung, wie der darauf basierende $ location-Ersatz zur besseren Integration von Frameworks verwendet wird, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Außerdem finden Sie jetzt die AngularJS Lazy Loading-Lösung, die auf dem oben genannten dynamischen ECMAScript-Import basiert. <br><br><h2>  Fazit </h2><br>  Auch hier hat das Angular-Team sein Wort gehalten: Der Übergang zur neuen Version von Angular ist einfach und beinhaltet keine wesentlichen Änderungen.  Im Gegenteil, einige Ecken wurden geglättet, wodurch die Arbeit mit dem SPA-Framework von Google noch komfortabler wurde.  Das differenzielle Laden bietet Möglichkeiten zur weiteren Optimierung der Paketgrößen, wenn ältere Browser entweder nicht oder von separaten Paketen unterstützt werden.  Die Unterstützung für Web Worker zeigt, dass rechenintensive Aufgaben im Browser verarbeitet werden.  Enthusiasten können jetzt ihre ersten Schritte mit Ivy machen. <br><br>  PS: Dies ist meine erste Übersetzung. Bitte beachten Sie Kommentare, Vorschläge und Fehler in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455493/">https://habr.com/ru/post/de455493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455481/index.html">Drei Geschichten über wilde Jagd</a></li>
<li><a href="../de455483/index.html">Ai-Da-Künstler: Humanoider Roboter bereitet sich auf seine erste Einzelausstellung vor</a></li>
<li><a href="../de455485/index.html">Prüfpunktskripte - Führen Sie Skripte direkt von der Smart Console aus</a></li>
<li><a href="../de455487/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 10. Betriebsarten des Ports wechseln</a></li>
<li><a href="../de455489/index.html">Verbinden von Audio- und Videolösungen von Drittanbietern mit Microsoft-Teams</a></li>
<li><a href="../de455497/index.html">Optimale lineare Filterung: vom Gradientenabstieg bis zum adaptiven Filter</a></li>
<li><a href="../de455499/index.html">Extraktion von Weisheitszähnen: Wie geht das?</a></li>
<li><a href="../de455501/index.html">Wie Hollywood heimlich KI verwendet, um wichtige Drehentscheidungen zu treffen</a></li>
<li><a href="../de455503/index.html">19 Konzepte, die Sie lernen müssen, um ein effektiver Angular-Entwickler zu werden</a></li>
<li><a href="../de455505/index.html">Reaktionsbeschleunigung vierfach reagieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>