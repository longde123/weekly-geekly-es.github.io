<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ŒğŸ¿ ğŸ‘±ğŸ¿ ğŸ•¤ ZIO y Efecto Gatos: una alianza exitosa ğŸ¦ â˜ğŸ» ğŸ•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect se ha convertido en una especie de "Corrientes reactivas" para el mundo funcional de Scala, lo que le permite combinar todo el ecosistema ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO y Efecto Gatos: una alianza exitosa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect se ha convertido en una especie de "Corrientes reactivas" para el mundo funcional de Scala, lo que le permite combinar todo el ecosistema diverso de bibliotecas. <br><br>  Muchas bibliotecas excelentes: http4s, fs2, doobie, se implementan solo en base a las clases de tipos de Cats Effect.  Y las bibliotecas como ZIO y Monix, a su vez, proporcionan instancias de estas clases de tipos para sus tipos de efectos.  A pesar de algunos problemas que se solucionarÃ¡n en la versiÃ³n 3.0, Cats Effect ayuda a muchos contribuyentes de cÃ³digo abierto a soportar orgÃ¡nicamente todo el ecosistema funcional del lenguaje Scala.  Los desarrolladores que usan Cats Effect se enfrentan a una elecciÃ³n difÃ­cil: quÃ© implementaciÃ³n de efectos usar para sus aplicaciones. <br><br>  Hoy hay tres alternativas: <br><br><ul><li>  Cats IO, implementaciÃ³n de referencia; </li><li>  Monix, el tipo de datos de la tarea y su reactividad en el cÃ³digo; </li><li>  ZIO, el tipo de datos ZIO y su alcance de subprocesamiento cruzado. </li></ul><br>  En esta publicaciÃ³n, intentarÃ© demostrarle que para crear su aplicaciÃ³n utilizando Cats Effect, ZIO es una buena opciÃ³n con soluciones de diseÃ±o y capacidades que son bastante diferentes de la implementaciÃ³n de referencia en Cats IO. <br><a name="habracut"></a><br><h2>  1. Mejor arquitectura MTL / Tagless-Final </h2><br>  MTL (Monad Transformers Library) es un estilo de programaciÃ³n en el que las funciones son polimÃ³rficas por su tipo de efecto y expresan sus requisitos a travÃ©s de una "restricciÃ³n de clase de tipo".  En Scala, esto a menudo se denomina estilo final sin etiqueta (aunque no es lo mismo), especialmente cuando la clase de tipo no tiene leyes. <br><br>  Es bien sabido que no es posible definir una instancia global para clases de tipo MTL clÃ¡sicas como Writer y State, ni para tipos de efectos como Cats IO.  El problema es que las instancias de estas clases de tipos para estos tipos de efectos requieren acceso a un estado mutable, que no se puede crear globalmente, porque crear un estado mutable tambiÃ©n es un efecto. <br><br>  Sin embargo, para obtener el mejor rendimiento, es importante evitar los "transformadores de mÃ³nada" y proporcionar la implementaciÃ³n de Escritura y Estado directamente, ademÃ¡s del tipo de efecto principal. <br><br>  Para lograr esto, los programadores de Scala usan un truco: crean instancias (pero limpias) en el nivel superior de sus programas con efectos y luego las proporcionan mÃ¡s en el programa como implicaciones locales: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  A pesar de que tal truco es Ãºtil, sigue siendo una "muleta".  En un mundo ideal, todas las instancias de clases de tipos podrÃ­an ser coherentes (una instancia por tipo), y no crearse localmente, generando efectos, luego envolverse mÃ¡gicamente en valores implÃ­citos para su uso por mÃ©todos posteriores. <br><br>  Una gran caracterÃ­stica de MTL / tagless-final es que puede definir directamente la mayorÃ­a de las instancias ademÃ¡s del tipo de datos ZIO utilizando el entorno ZIO. <br><br>  AquÃ­ hay una forma de crear una definiciÃ³n global de MonadState para un tipo de datos ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Ahora se define una instancia de forma global para cualquier entorno que admita al menos <code>State[S]</code> . <br><br>  De manera similar para <code>FunctorListen</code> , tambiÃ©n conocido como <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Y, por supuesto, podemos hacer lo mismo con <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Esta tÃ©cnica es fÃ¡cilmente aplicable a otras clases de tipos, incluidas las clases de tipo final sin etiqueta, cuyas instancias pueden requerir generar efectos (cambios, configuraciones), probar funciones que generan efectos (combinando efectos ambientales con final sin etiqueta) o cualquier otra cosa fÃ¡cilmente accesible desde el entorno . <br><br>  Â¡No mÃ¡s transformaciones monÃ¡dicas lentas!  Digamos "no" a la creaciÃ³n de efectos al inicializar instancias de la clase clase, a las implicaciones locales.  No se necesitan mÃ¡s muletas.  InmersiÃ³n directa en programaciÃ³n puramente funcional. <br><br><h2>  2. Ahorro de recursos para simples mortales. </h2><br>  Una de las primeras caracterÃ­sticas de ZIO fue la interacciÃ³n: la capacidad del tiempo de ejecuciÃ³n de ZIO para interrumpir instantÃ¡neamente cualquier efecto ejecutable y garantizar la liberaciÃ³n de todos los recursos.  Una implementaciÃ³n cruda de esta caracterÃ­stica golpeÃ³ a Cats IO. <br><br>  Haskell llamÃ³ a tal funcionalidad excepciÃ³n asÃ­ncrona, que le permite crear y usar de manera eficiente latencia, operaciones paralelas y competitivas eficientes, y cÃ¡lculos Ã³ptimos a nivel mundial.  Dichas interrupciones no solo traen grandes beneficios, sino que tambiÃ©n plantean tareas complejas en el campo de apoyar el acceso seguro a los recursos. <br><br>  Los programadores estÃ¡n acostumbrados a rastrear errores en programas a travÃ©s de un anÃ¡lisis simple.  Esto tambiÃ©n se puede hacer con ZIO, que utiliza un sistema de tipos para ayudar a detectar errores.  Pero la interrupciÃ³n es otra cosa.  Un efecto creado a partir de muchos otros efectos puede interrumpirse en cualquier borde. <br><br>  Considere el siguiente efecto: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  La mayorÃ­a de los desarrolladores no se sorprenderÃ¡n de este escenario: <code>closeFile</code> no se ejecutarÃ¡ si se bloquea <code>readFile</code> .  Afortunadamente, el sistema de efectos tiene una <code>ensuring</code> ( <code>guarantee</code> en Efecto Gatos) que le permite agregar un controlador final al efecto finalizador, similar a finalmente. <br><br>  Entonces, el problema principal del cÃ³digo anterior se puede resolver fÃ¡cilmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Ahora el efecto se ha vuelto "resistente a caÃ­das", en el sentido de que si se rompe el archivo <code>readFile</code> , el archivo seguirÃ¡ cerrado.  Y si <code>readFile</code> tiene Ã©xito, el archivo tambiÃ©n se cerrarÃ¡.  En todos los casos, el archivo se cerrarÃ¡. <br><br>  Pero todavÃ­a no del todo.  InterrupciÃ³n significa que el efecto se puede interrumpir en todas partes, incluso entre <code>openFile</code> y <code>readFile</code> .  Si esto sucede, el archivo abierto no se cerrarÃ¡ y se producirÃ¡ una pÃ©rdida de recursos. <br><br>  El patrÃ³n de obtener y liberar un recurso estÃ¡ tan extendido que ZIO introdujo un operador de soporte, que tambiÃ©n apareciÃ³ en Cats Effect 1.0.  La instrucciÃ³n Bracket protege contra interrupciones: si el recurso se recibe con Ã©xito, se producirÃ¡ la liberaciÃ³n incluso si se interrumpe el efecto que usa el recurso.  AdemÃ¡s, ni el recibo ni la liberaciÃ³n del recurso pueden interrumpirse, lo que proporciona una garantÃ­a de seguridad del recurso. <br><br>  Usando el soporte, el ejemplo anterior se verÃ­a asÃ­: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Desafortunadamente, el soporte encapsula solo un patrÃ³n de consumo de recursos (bastante general).  Hay muchos otros, especialmente con estructuras de datos competitivas, cuyo acceso debe ser accesible para las interrupciones, de lo contrario son posibles las fugas. <br><br>  En general, todo trabajo de interrupciÃ³n se reduce a dos cosas principales: <br><br><ul><li>  prevenir interrupciones en algunas Ã¡reas que pueden ser interrumpidas; </li><li>  permita la interrupciÃ³n en Ã¡reas que pueden congelarse. </li></ul><br>  ZIO tiene la capacidad de implementar ambos.  Por ejemplo, podemos desarrollar nuestra propia versiÃ³n de soporte utilizando abstracciones ZIO de bajo nivel: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  En este cÃ³digo, el <code>use(a)</code> es la Ãºnica parte que se puede interrumpir.  El cÃ³digo circundante garantiza la ejecuciÃ³n de la <code>release</code> en cualquier caso. <br><br>  En cualquier momento, puede verificar si existe la posibilidad de interrupciones.  Para esto, solo se necesitan dos operaciones primitivas (todas las demÃ¡s se derivan de ellas). <br><br>  Este modelo de interrupciÃ³n de composiciÃ³n con todas las funciones le permite implementar no solo una implementaciÃ³n simple de soporte, sino tambiÃ©n implementar otros escenarios en la gestiÃ³n de recursos, en los que se encuentra un equilibrio entre las ventajas y desventajas de las interrupciones. <br><br>  Cats IO proporciona solo una operaciÃ³n para controlar las interrupciones: el combinador no cancelable.  Hace que todo el bloque de cÃ³digo sea ininterrumpido.  Aunque esta operaciÃ³n rara vez se usa, puede provocar una pÃ©rdida de recursos o bloqueos. <br><br>  Al mismo tiempo, resulta que puede definir una primitiva dentro de Cats IO, que le permite lograr un mayor control sobre las interrupciones.  La implementaciÃ³n muy complicada de Fabio Labella resultÃ³ ser extremadamente lenta. <br><br>  ZIO le permite escribir cÃ³digo con interrupciones, operando a un alto nivel con declaraciones compuestas declarativas, y no lo obliga a elegir entre una complejidad severa combinada con un bajo rendimiento y fugas de bloqueo. <br><br>  AdemÃ¡s, la memoria transaccional de software recientemente agregada en ZIO permite al usuario escribir de forma declarativa estructuras de datos y cÃ³digo que son automÃ¡ticamente asÃ­ncronos, competitivos y permiten interrupciones. <br><br><h2>  3. Finalizadores garantizados </h2><br>  El bloque try / finally en muchos lenguajes de programaciÃ³n proporciona las garantÃ­as necesarias para escribir cÃ³digo sincrÃ³nico sin pÃ©rdida de recursos. <br><br>  En particular, este bloque garantiza lo siguiente: si un bloque try comienza a ejecutarse, el bloque finalmente se ejecutarÃ¡ cuando el try se detenga. <br><br>  Esta garantÃ­a se aplica a: <br><br><ul><li>  hay bloques anidados de "prueba / finalmente"; </li><li>  hay errores en el "bloque de prueba"; </li><li>  hay errores en el bloque anidado finalmente. </li></ul><br>  La operaciÃ³n "asegurar" de ZIO se puede usar como probar / finalmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO ofrece las siguientes garantÃ­as para "effect.ensuring (finalizer)": si se comenzÃ³ a ejecutar "effect", entonces "finalizer" comenzarÃ¡ a ejecutarse cuando se detenga "effect". <br><br>  Como prueba / finalmente, estas garantÃ­as permanecen en los siguientes casos: <br><br><ul><li>  Hay composiciones "aseguradoras" anidadas; </li><li>  hay errores en el "efecto"; </li><li>  hay errores en el "finalizador" anidado. </li></ul><br>  AdemÃ¡s, la garantÃ­a se mantiene incluso si el efecto se interrumpe (las garantÃ­as en el "soporte" son similares, de hecho, el "soporte" se implementa en "garantizar"). <br><br>  El tipo de datos Cats IO proporciona otra garantÃ­a mÃ¡s dÃ©bil.  Para "effect.guarantee (finalizer)", se debilita de la siguiente manera: si "effect" comenzÃ³ a ejecutarse, "finalizer" comenzarÃ¡ a ejecutarse cuando "effect" se detenga, si el efecto del problema no se inserta en "effect". <br><br>  Una garantÃ­a mÃ¡s dÃ©bil tambiÃ©n se encuentra en la implementaciÃ³n del "soporte" en Cats IO. <br><br>  Para obtener una fuga de recursos, simplemente use el efecto usado dentro del efecto "garantÃ­a" o "soporte.use", compÃ³ngalo con algo como esto: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Cuando bigTrouble se inserta de esta manera en otro efecto, el efecto se vuelve ininterrumpido: no se ejecutarÃ¡n "finalizadores" a travÃ©s de la "garantÃ­a" o no se ejecutarÃ¡ la limpieza de los recursos a travÃ©s del "soporte".  Todo esto conduce a una pÃ©rdida de recursos, incluso cuando hay un "finalizador" en el bloque. <br><br>  Por ejemplo, el "finalizador" en el siguiente cÃ³digo nunca comenzarÃ¡ a ejecutarse: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!Â«)))</span></span></code> </pre> <br>  Al evaluar el cÃ³digo sin tener en cuenta el contexto global, es imposible determinar si un efecto, como "bigTrouble", se insertarÃ¡ en cualquier parte del efecto "uso" de la operaciÃ³n "soporte" o dentro del bloque "finalizador". <br><br>  Por lo tanto, no podrÃ¡ averiguar si el programa Cats IO funcionarÃ¡ con pÃ©rdidas de recursos o bloques "finalizadores" faltantes sin evaluar todo el programa.  Todo el programa solo puede evaluarse manualmente, y este proceso siempre va acompaÃ±ado de errores que el compilador no puede verificar.  AdemÃ¡s, este proceso debe repetirse cada vez que ocurran cambios importantes en el cÃ³digo. <br><br>  ZIO tiene una implementaciÃ³n personalizada de "garantÃ­a" de Cats Effect, "garantÃ­aCase" y "soporte".  Las implementaciones usan semÃ¡ntica nativa de ZIO (no semÃ¡ntica de Cats IO), lo que nos permite evaluar posibles problemas con fugas de recursos aquÃ­ y ahora, sabiendo que en todas las situaciones se lanzarÃ¡n finalizadores y se liberarÃ¡n recursos. <br><br><h2>  4. ConmutaciÃ³n estable </h2><br>  Cats Effect tiene el mÃ©todo "evalOn" de "ContextShift", que le permite mover la ejecuciÃ³n de algÃºn cÃ³digo a otro contexto de ejecuciÃ³n. <br><br>  Esto es Ãºtil por varias razones: <br><br><ul><li>  muchas bibliotecas de clientes lo obligan a trabajar en su grupo de subprocesos; </li><li>  Las bibliotecas de IU requieren que se realicen algunas actualizaciones en el subproceso de IU; </li><li>  Algunos efectos requieren aislamiento en grupos de subprocesos adaptados a sus caracterÃ­sticas especÃ­ficas. </li></ul><br>  La operaciÃ³n "EvalOn" ejecuta el efecto donde debe ejecutarse y luego vuelve al contexto de ejecuciÃ³n original.  Por ejemplo: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Nota: Cats IO tiene una construcciÃ³n similar de "cambio", que le permite cambiar a un contexto diferente sin tener que retroceder, pero en la prÃ¡ctica, este comportamiento rara vez es necesario, por lo que se prefiere "evalOn". <br><br>  La implementaciÃ³n de ZIO de "evalOn" (realizada en el "bloqueo" primitivo de ZIO) proporciona las garantÃ­as necesarias para comprender de forma Ãºnica dÃ³nde funciona el efecto: el efecto siempre se ejecutarÃ¡ en un contexto especÃ­fico. <br><br>  Cats IO tiene una garantÃ­a diferente y mÃ¡s dÃ©bil: el efecto se ejecutarÃ¡ en un determinado contexto hasta la primera operaciÃ³n asincrÃ³nica o la conmutaciÃ³n interna. <br><br>  Teniendo en cuenta un pequeÃ±o fragmento de cÃ³digo, es imposible saber con certeza si un efecto asincrÃ³nico (o una conmutaciÃ³n anidada) se integrarÃ¡ en el efecto que cambiarÃ¡, porque la asincronÃ­a no se muestra en tipos. <br><br>  Por lo tanto, como en el caso de la seguridad de los recursos, para comprender dÃ³nde se lanzarÃ¡ el efecto Cats IO, es necesario estudiar todo el programa.  En la prÃ¡ctica, y desde mi experiencia, los usuarios de Cats IO se sorprenden cuando, al usar "evalOn" en un contexto, posteriormente se descubre que la mayor parte del efecto se realizÃ³ accidentalmente en otro. <br><br>  ZIO le permite determinar dÃ³nde deben activarse los efectos y confiar en que sucederÃ¡ en todos los casos, sin importar cÃ³mo se incorporen los efectos a otros efectos. <br><br><h2>  5. Seguridad de los mensajes de error. </h2><br>  Cualquier efecto que admita concurrencia, concurrencia o acceso seguro a los recursos se encontrarÃ¡ con un modelo de error lineal: en general, no se pueden guardar todos los errores. <br><br>  Esto es cierto tanto para 'Throwable', un tipo de error fijo integrado en Cats IO como para el tipo de error polimÃ³rfico compatible con ZIO. <br><br>  Ejemplos de situaciones con mÃºltiples errores Ãºnicos: <br><br><ul><li>  El finalizador lanza una excepciÃ³n; </li><li>  dos efectos (descendentes) se combinan en ejecuciÃ³n paralela; </li><li>  dos efectos (caÃ­das) en un estado de carrera; </li><li>  el efecto interrumpido cae antes de dejar la secciÃ³n protegida de interrupciones. </li></ul><br>  Dado que no se guardan todos los errores, ZIO proporciona una estructura de datos "Causa [E]" basada en un semired libre (una abstracciÃ³n del Ã¡lgebra abstracta, su conocimiento no se supone aquÃ­), que permite conectar errores en serie y paralelos para cualquier tipo de error.  Durante todas las operaciones (incluida la limpieza de un efecto caÃ­do o interrumpido), ZIO agrega errores en la estructura de datos "Causa [E]".  Esta estructura de datos estÃ¡ disponible en cualquier momento.  Como resultado, ZIO siempre almacena todos los errores: siempre estÃ¡n disponibles, se pueden registrar, estudiar y transformar segÃºn lo requieran los requisitos comerciales. <br><br>  Cats IO eligiÃ³ un modelo con pÃ©rdida de informaciÃ³n de error.  Mientras que ZIO conectarÃ¡ los dos errores a travÃ©s de la Causa [E], Cats IO "perderÃ¡" uno de los mensajes de error, por ejemplo, llamando al "e.printStackTrace ()" en el error que ocurre. <br><br>  Por ejemplo, se perderÃ¡ un error en el "finalizador" en este cÃ³digo. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2Â«)))</span></span></code> </pre> <br>  Este enfoque para rastrear errores significa que no puede localizar y procesar localmente todo el espectro de errores que ocurren debido a la combinaciÃ³n de efectos.  ZIO le permite usar cualquier tipo de error, incluido "Throwable" (o subtipos mÃ¡s especÃ­ficos como "IOExceptio" u otra jerarquÃ­a de excepciÃ³n personalizada), asegurando que no se pierdan errores durante la ejecuciÃ³n del programa. <br><br><h2>  6. AsincronÃ­a sin puntos muertos </h2><br>  Tanto ZIO como Cats IO proporcionan un constructor que le permite tomar cÃ³digo con una devoluciÃ³n de llamada y envolverlo en efecto <br><br>  Esta caracterÃ­stica se proporciona a travÃ©s de la clase de tuberÃ­a Async en Efecto Gatos: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Esto crea un efecto asincrÃ³nico que, cuando se ejecuta, esperarÃ¡ hasta que aparezca el valor y luego continuarÃ¡, y todo esto serÃ¡ obvio para el usuario del efecto.  Por lo tanto, la programaciÃ³n funcional es tan atractiva para desarrollar cÃ³digo asincrÃ³nico. <br><br>  Tenga en cuenta que tan pronto como el cÃ³digo de devoluciÃ³n de llamada se convierta en un efecto, se llama a la funciÃ³n de devoluciÃ³n de llamada (aquÃ­ se llama `k`).  Esta funciÃ³n de devoluciÃ³n de llamada sale con un valor de Ã©xito / error.  Cuando se llama a esta funciÃ³n de devoluciÃ³n de llamada, se reanuda la ejecuciÃ³n del efecto (previamente pausado). <br><br>  ZIO garantiza que el efecto reanudarÃ¡ la ejecuciÃ³n en el grupo de subprocesos de tiempo de ejecuciÃ³n si el efecto no se asignÃ³ a ningÃºn contexto especial en particular, oa otro contexto al que se adjuntÃ³ el efecto. <br><br>  Cats IO reanuda el efecto en el hilo de devoluciÃ³n de llamada.  La diferencia entre estas opciones es bastante profunda: el hilo que causa la devoluciÃ³n de llamada no espera que el cÃ³digo de devoluciÃ³n de llamada se ejecute para siempre, pero solo permite un ligero retraso antes de que regrese el control.  Por otro lado, Cats IO no ofrece tal garantÃ­a en absoluto: el hilo de llamada, la devoluciÃ³n de llamada de inicio, puede congelarse, esperando un tiempo indefinido cuando regrese el control de ejecuciÃ³n. <br><br>  Las versiones anteriores de las estructuras de datos competitivas en Cats Effect ("Diferido", "SemÃ¡foro") reanudaron los efectos que no devolvieron el control de ejecuciÃ³n al hilo de llamada.  Como resultado, se descubrieron problemas relacionados con puntos muertos y un programador de ejecuciÃ³n roto.  Aunque se han encontrado todos estos problemas, solo se corrigen para estructuras de datos competitivas en Cats Effect. <br><br>  El cÃ³digo de usuario que utiliza un enfoque similar al de Cats IO se meterÃ¡ en tales problemas, ya que tales tareas no son deterministas, los errores solo pueden ocurrir muy raramente en tiempo de ejecuciÃ³n, lo que hace que la depuraciÃ³n y la detecciÃ³n de problemas sean un proceso difÃ­cil. <br><br>  ZIO proporciona protecciÃ³n de punto muerto y un programador de tareas normal fuera de la caja, y tambiÃ©n hace que el usuario elija explÃ­citamente el comportamiento de Cats IO (por ejemplo, usando "unsafeRun" en "Promise", que terminÃ³ en un efecto asincrÃ³nico reanudado). <br><br>  Aunque ninguna de las soluciones es adecuada para absolutamente todos los casos, y ZIO y Cats IO proporcionan suficiente flexibilidad para resolver todas las situaciones (de diferentes maneras), elegir ZIO significa usar "Async" sin preocupaciones y lo obliga a poner el cÃ³digo del problema en "unsafeRun", que se sabe que causa un punto muerto <br><br><h2>  7. Compatible con el futuro </h2><br>  Usar "Future" de la biblioteca estÃ¡ndar de Scala es una realidad para una gran cantidad de bases de cÃ³digo.  ZIO viene con un mÃ©todo "fromFuture", que proporciona un contexto de ejecuciÃ³n listo: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Cuando este mÃ©todo se utiliza para ajustar Future en un efecto, ZIO puede establecer dÃ³nde se ejecutarÃ¡ Future, y otros mÃ©todos, como evalOn, transferirÃ¡n correctamente Future al contexto de ejecuciÃ³n deseado.  Cats IO acepta "Future", que se creÃ³ con un "ExecutionContext" externo.  Esto significa que Cats IO no puede mover la ejecuciÃ³n de Future de acuerdo con los requisitos de los mÃ©todos de evaluaciÃ³n o cambio.  AdemÃ¡s, esto carga al usuario con la determinaciÃ³n del contexto de ejecuciÃ³n para el Futuro, lo que significa una selecciÃ³n limitada y un entorno separado. <br><br>  Dado que se puede ignorar el ExecutionContext proporcionado, ZIO se puede representar como la suma de las caracterÃ­sticas de Cats IO, garantizando una interacciÃ³n mÃ¡s fluida y precisa con Future en el caso general, pero todavÃ­a hay excepciones. <br><br><h2>  8. Bloqueo de IO </h2><br>  Como se mostrÃ³ en el artÃ­culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupo de subprocesos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejores prÃ¡cticas con ZIO</a> â€, para aplicaciones de servidor, se requieren al menos dos grupos separados para una mÃ¡xima eficiencia: <br><br><ul><li>  grupo fijo para CPU / efectos asincrÃ³nicos; </li><li>  dinÃ¡mico, con la posibilidad de aumentar el nÃºmero de hilos de bloqueo. </li></ul><br>  La decisiÃ³n de ejecutar todos los efectos en un grupo de subprocesos fijo algÃºn dÃ­a conducirÃ¡ a un punto muerto, mientras que desencadenar todos los efectos en un grupo dinÃ¡mico puede conducir a la pÃ©rdida de rendimiento. <br><br>  En la JVM, ZIO proporciona dos operaciones que admiten efectos de bloqueo: <br><br><ul><li>  Operador "Bloqueo (efecto)", que cambia la ejecuciÃ³n de un cierto efecto en el conjunto de subprocesos de bloqueo que tienen buenos ajustes preestablecidos que se pueden cambiar si se desea); </li><li> Â«effectBlocking(effect)Â» ,          ,        . </li></ul><br>     ,     ,       ,       Â«blockingÂ».   ,    -    ,  ,       Â«effectBlockingÂ»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     Â«blockingÂ»,    Â«evalOnÂ», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> Â«ReaderTÂ»/ Â«KleisliÂ»,       ; </li><li> Â«EitherTÂ»,      ( Â«OptionTÂ»,     Â«EitherTÂ»   Â«UnitÂ»    ). </li></ul><br>    ,          (, http4s   Â«KleisliÂ»  Â«OptionTÂ»).        (Â«effect totationÂ»), ZIO   Â«readerÂ»  Â«typed errorÂ»      ZIO.         Â«readerÂ»  Â«typed errorÂ» , ZIO    ,    . , Â«Task[A]Â»,    Â«readerÂ»  Â«typed errorsÂ». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   Â«readerÂ»  Â«typed errorsÂ»      Â«stateÂ», Â«writerÂ»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    Â«typed errorsÂ»  ,       â€”     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : Â«ZIO. succeedÂ»  Â«Applicative[F].pureÂ», Â«zipÂ»  Â«Apply[F].productÂ», Â«ZIO.foreachÂ»  Â«Traverse[F].traverseÂ». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  Â«RuntimeÂ»,      Cats Effect  -   Cats Effect).  â€”        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazyÂ«. <br></li><li>      ,        Â«Â».   ZIO    IDE. </li><li>      Scala  ZIO  : Â«ZIO.fromFutureÂ», Â«ZIO.fromOptionÂ», Â«ZIO.fromEitherÂ», Â«ZIO.fromTryÂ». </li><li>         Â«Â». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO â€”  - ,           . <br><br>     : <br><br><ul><li>     ,  Â«RefÂ», Â«PromiseÂ», Â«QueueÂ», Â«SemaphoreÂ»   Â«StreamÂ»    //; </li><li> STM,       , ,     ; </li><li> Â«ScheduleÂ»,    ; </li><li>    Â«ClockÂ», Â«RandomÂ», Â«ConsoleÂ»  Â«SystemÂ» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  ConclusiÃ³n </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      â€”    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472386/">https://habr.com/ru/post/472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472372/index.html">AutomatizaciÃ³n de Android GuÃ­a sÃºper fÃ¡cil para crear tu primera prueba de Espresso</a></li>
<li><a href="../472374/index.html">Â¿Por quÃ© mudamos servidores a Islandia?</a></li>
<li><a href="../472378/index.html">Fiabilidad de flash: esperada e inesperada. Parte 2. XIV conferencia de la asociaciÃ³n USENIX. TecnologÃ­as de almacenamiento de archivos</a></li>
<li><a href="../472380/index.html">MIRO: una plataforma robotizada de interior abierta</a></li>
<li><a href="../472384/index.html">Una mirada a las actualizaciones de Android desde la perspectiva de un desarrollador</a></li>
<li><a href="../472388/index.html">Walmart declara guerra de precios en Amazon</a></li>
<li><a href="../472392/index.html">El aumento, la caÃ­da y el posible regreso de los casetes de audio: tratamos los mitos y damos una visiÃ³n general de la situaciÃ³n</a></li>
<li><a href="../472394/index.html">Evaluar el impacto de la inteligencia artificial en el petrÃ³leo y el gas en alta mar</a></li>
<li><a href="../472396/index.html">La vuelta al mundo en 4 segundos en Columnstore (Parte 1)</a></li>
<li><a href="../472402/index.html">TransmisiÃ³n de videollamadas RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>