<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèø üë±üèø üï§ ZIO y Efecto Gatos: una alianza exitosa ü¶Å ‚òùüèª üïû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect se ha convertido en una especie de "Corrientes reactivas" para el mundo funcional de Scala, lo que le permite combinar todo el ecosistema ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO y Efecto Gatos: una alianza exitosa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect se ha convertido en una especie de "Corrientes reactivas" para el mundo funcional de Scala, lo que le permite combinar todo el ecosistema diverso de bibliotecas. <br><br>  Muchas bibliotecas excelentes: http4s, fs2, doobie, se implementan solo en base a las clases de tipos de Cats Effect.  Y las bibliotecas como ZIO y Monix, a su vez, proporcionan instancias de estas clases de tipos para sus tipos de efectos.  A pesar de algunos problemas que se solucionar√°n en la versi√≥n 3.0, Cats Effect ayuda a muchos contribuyentes de c√≥digo abierto a soportar org√°nicamente todo el ecosistema funcional del lenguaje Scala.  Los desarrolladores que usan Cats Effect se enfrentan a una elecci√≥n dif√≠cil: qu√© implementaci√≥n de efectos usar para sus aplicaciones. <br><br>  Hoy hay tres alternativas: <br><br><ul><li>  Cats IO, implementaci√≥n de referencia; </li><li>  Monix, el tipo de datos de la tarea y su reactividad en el c√≥digo; </li><li>  ZIO, el tipo de datos ZIO y su alcance de subprocesamiento cruzado. </li></ul><br>  En esta publicaci√≥n, intentar√© demostrarle que para crear su aplicaci√≥n utilizando Cats Effect, ZIO es una buena opci√≥n con soluciones de dise√±o y capacidades que son bastante diferentes de la implementaci√≥n de referencia en Cats IO. <br><a name="habracut"></a><br><h2>  1. Mejor arquitectura MTL / Tagless-Final </h2><br>  MTL (Monad Transformers Library) es un estilo de programaci√≥n en el que las funciones son polim√≥rficas por su tipo de efecto y expresan sus requisitos a trav√©s de una "restricci√≥n de clase de tipo".  En Scala, esto a menudo se denomina estilo final sin etiqueta (aunque no es lo mismo), especialmente cuando la clase de tipo no tiene leyes. <br><br>  Es bien sabido que no es posible definir una instancia global para clases de tipo MTL cl√°sicas como Writer y State, ni para tipos de efectos como Cats IO.  El problema es que las instancias de estas clases de tipos para estos tipos de efectos requieren acceso a un estado mutable, que no se puede crear globalmente, porque crear un estado mutable tambi√©n es un efecto. <br><br>  Sin embargo, para obtener el mejor rendimiento, es importante evitar los "transformadores de m√≥nada" y proporcionar la implementaci√≥n de Escritura y Estado directamente, adem√°s del tipo de efecto principal. <br><br>  Para lograr esto, los programadores de Scala usan un truco: crean instancias (pero limpias) en el nivel superior de sus programas con efectos y luego las proporcionan m√°s en el programa como implicaciones locales: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  A pesar de que tal truco es √∫til, sigue siendo una "muleta".  En un mundo ideal, todas las instancias de clases de tipos podr√≠an ser coherentes (una instancia por tipo), y no crearse localmente, generando efectos, luego envolverse m√°gicamente en valores impl√≠citos para su uso por m√©todos posteriores. <br><br>  Una gran caracter√≠stica de MTL / tagless-final es que puede definir directamente la mayor√≠a de las instancias adem√°s del tipo de datos ZIO utilizando el entorno ZIO. <br><br>  Aqu√≠ hay una forma de crear una definici√≥n global de MonadState para un tipo de datos ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Ahora se define una instancia de forma global para cualquier entorno que admita al menos <code>State[S]</code> . <br><br>  De manera similar para <code>FunctorListen</code> , tambi√©n conocido como <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Y, por supuesto, podemos hacer lo mismo con <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Esta t√©cnica es f√°cilmente aplicable a otras clases de tipos, incluidas las clases de tipo final sin etiqueta, cuyas instancias pueden requerir generar efectos (cambios, configuraciones), probar funciones que generan efectos (combinando efectos ambientales con final sin etiqueta) o cualquier otra cosa f√°cilmente accesible desde el entorno . <br><br>  ¬°No m√°s transformaciones mon√°dicas lentas!  Digamos "no" a la creaci√≥n de efectos al inicializar instancias de la clase clase, a las implicaciones locales.  No se necesitan m√°s muletas.  Inmersi√≥n directa en programaci√≥n puramente funcional. <br><br><h2>  2. Ahorro de recursos para simples mortales. </h2><br>  Una de las primeras caracter√≠sticas de ZIO fue la interacci√≥n: la capacidad del tiempo de ejecuci√≥n de ZIO para interrumpir instant√°neamente cualquier efecto ejecutable y garantizar la liberaci√≥n de todos los recursos.  Una implementaci√≥n cruda de esta caracter√≠stica golpe√≥ a Cats IO. <br><br>  Haskell llam√≥ a tal funcionalidad excepci√≥n as√≠ncrona, que le permite crear y usar de manera eficiente latencia, operaciones paralelas y competitivas eficientes, y c√°lculos √≥ptimos a nivel mundial.  Dichas interrupciones no solo traen grandes beneficios, sino que tambi√©n plantean tareas complejas en el campo de apoyar el acceso seguro a los recursos. <br><br>  Los programadores est√°n acostumbrados a rastrear errores en programas a trav√©s de un an√°lisis simple.  Esto tambi√©n se puede hacer con ZIO, que utiliza un sistema de tipos para ayudar a detectar errores.  Pero la interrupci√≥n es otra cosa.  Un efecto creado a partir de muchos otros efectos puede interrumpirse en cualquier borde. <br><br>  Considere el siguiente efecto: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  La mayor√≠a de los desarrolladores no se sorprender√°n de este escenario: <code>closeFile</code> no se ejecutar√° si se bloquea <code>readFile</code> .  Afortunadamente, el sistema de efectos tiene una <code>ensuring</code> ( <code>guarantee</code> en Efecto Gatos) que le permite agregar un controlador final al efecto finalizador, similar a finalmente. <br><br>  Entonces, el problema principal del c√≥digo anterior se puede resolver f√°cilmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Ahora el efecto se ha vuelto "resistente a ca√≠das", en el sentido de que si se rompe el archivo <code>readFile</code> , el archivo seguir√° cerrado.  Y si <code>readFile</code> tiene √©xito, el archivo tambi√©n se cerrar√°.  En todos los casos, el archivo se cerrar√°. <br><br>  Pero todav√≠a no del todo.  Interrupci√≥n significa que el efecto se puede interrumpir en todas partes, incluso entre <code>openFile</code> y <code>readFile</code> .  Si esto sucede, el archivo abierto no se cerrar√° y se producir√° una p√©rdida de recursos. <br><br>  El patr√≥n de obtener y liberar un recurso est√° tan extendido que ZIO introdujo un operador de soporte, que tambi√©n apareci√≥ en Cats Effect 1.0.  La instrucci√≥n Bracket protege contra interrupciones: si el recurso se recibe con √©xito, se producir√° la liberaci√≥n incluso si se interrumpe el efecto que usa el recurso.  Adem√°s, ni el recibo ni la liberaci√≥n del recurso pueden interrumpirse, lo que proporciona una garant√≠a de seguridad del recurso. <br><br>  Usando el soporte, el ejemplo anterior se ver√≠a as√≠: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Desafortunadamente, el soporte encapsula solo un patr√≥n de consumo de recursos (bastante general).  Hay muchos otros, especialmente con estructuras de datos competitivas, cuyo acceso debe ser accesible para las interrupciones, de lo contrario son posibles las fugas. <br><br>  En general, todo trabajo de interrupci√≥n se reduce a dos cosas principales: <br><br><ul><li>  prevenir interrupciones en algunas √°reas que pueden ser interrumpidas; </li><li>  permita la interrupci√≥n en √°reas que pueden congelarse. </li></ul><br>  ZIO tiene la capacidad de implementar ambos.  Por ejemplo, podemos desarrollar nuestra propia versi√≥n de soporte utilizando abstracciones ZIO de bajo nivel: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  En este c√≥digo, el <code>use(a)</code> es la √∫nica parte que se puede interrumpir.  El c√≥digo circundante garantiza la ejecuci√≥n de la <code>release</code> en cualquier caso. <br><br>  En cualquier momento, puede verificar si existe la posibilidad de interrupciones.  Para esto, solo se necesitan dos operaciones primitivas (todas las dem√°s se derivan de ellas). <br><br>  Este modelo de interrupci√≥n de composici√≥n con todas las funciones le permite implementar no solo una implementaci√≥n simple de soporte, sino tambi√©n implementar otros escenarios en la gesti√≥n de recursos, en los que se encuentra un equilibrio entre las ventajas y desventajas de las interrupciones. <br><br>  Cats IO proporciona solo una operaci√≥n para controlar las interrupciones: el combinador no cancelable.  Hace que todo el bloque de c√≥digo sea ininterrumpido.  Aunque esta operaci√≥n rara vez se usa, puede provocar una p√©rdida de recursos o bloqueos. <br><br>  Al mismo tiempo, resulta que puede definir una primitiva dentro de Cats IO, que le permite lograr un mayor control sobre las interrupciones.  La implementaci√≥n muy complicada de Fabio Labella result√≥ ser extremadamente lenta. <br><br>  ZIO le permite escribir c√≥digo con interrupciones, operando a un alto nivel con declaraciones compuestas declarativas, y no lo obliga a elegir entre una complejidad severa combinada con un bajo rendimiento y fugas de bloqueo. <br><br>  Adem√°s, la memoria transaccional de software recientemente agregada en ZIO permite al usuario escribir de forma declarativa estructuras de datos y c√≥digo que son autom√°ticamente as√≠ncronos, competitivos y permiten interrupciones. <br><br><h2>  3. Finalizadores garantizados </h2><br>  El bloque try / finally en muchos lenguajes de programaci√≥n proporciona las garant√≠as necesarias para escribir c√≥digo sincr√≥nico sin p√©rdida de recursos. <br><br>  En particular, este bloque garantiza lo siguiente: si un bloque try comienza a ejecutarse, el bloque finalmente se ejecutar√° cuando el try se detenga. <br><br>  Esta garant√≠a se aplica a: <br><br><ul><li>  hay bloques anidados de "prueba / finalmente"; </li><li>  hay errores en el "bloque de prueba"; </li><li>  hay errores en el bloque anidado finalmente. </li></ul><br>  La operaci√≥n "asegurar" de ZIO se puede usar como probar / finalmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO ofrece las siguientes garant√≠as para "effect.ensuring (finalizer)": si se comenz√≥ a ejecutar "effect", entonces "finalizer" comenzar√° a ejecutarse cuando se detenga "effect". <br><br>  Como prueba / finalmente, estas garant√≠as permanecen en los siguientes casos: <br><br><ul><li>  Hay composiciones "aseguradoras" anidadas; </li><li>  hay errores en el "efecto"; </li><li>  hay errores en el "finalizador" anidado. </li></ul><br>  Adem√°s, la garant√≠a se mantiene incluso si el efecto se interrumpe (las garant√≠as en el "soporte" son similares, de hecho, el "soporte" se implementa en "garantizar"). <br><br>  El tipo de datos Cats IO proporciona otra garant√≠a m√°s d√©bil.  Para "effect.guarantee (finalizer)", se debilita de la siguiente manera: si "effect" comenz√≥ a ejecutarse, "finalizer" comenzar√° a ejecutarse cuando "effect" se detenga, si el efecto del problema no se inserta en "effect". <br><br>  Una garant√≠a m√°s d√©bil tambi√©n se encuentra en la implementaci√≥n del "soporte" en Cats IO. <br><br>  Para obtener una fuga de recursos, simplemente use el efecto usado dentro del efecto "garant√≠a" o "soporte.use", comp√≥ngalo con algo como esto: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Cuando bigTrouble se inserta de esta manera en otro efecto, el efecto se vuelve ininterrumpido: no se ejecutar√°n "finalizadores" a trav√©s de la "garant√≠a" o no se ejecutar√° la limpieza de los recursos a trav√©s del "soporte".  Todo esto conduce a una p√©rdida de recursos, incluso cuando hay un "finalizador" en el bloque. <br><br>  Por ejemplo, el "finalizador" en el siguiente c√≥digo nunca comenzar√° a ejecutarse: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!¬´)))</span></span></code> </pre> <br>  Al evaluar el c√≥digo sin tener en cuenta el contexto global, es imposible determinar si un efecto, como "bigTrouble", se insertar√° en cualquier parte del efecto "uso" de la operaci√≥n "soporte" o dentro del bloque "finalizador". <br><br>  Por lo tanto, no podr√° averiguar si el programa Cats IO funcionar√° con p√©rdidas de recursos o bloques "finalizadores" faltantes sin evaluar todo el programa.  Todo el programa solo puede evaluarse manualmente, y este proceso siempre va acompa√±ado de errores que el compilador no puede verificar.  Adem√°s, este proceso debe repetirse cada vez que ocurran cambios importantes en el c√≥digo. <br><br>  ZIO tiene una implementaci√≥n personalizada de "garant√≠a" de Cats Effect, "garant√≠aCase" y "soporte".  Las implementaciones usan sem√°ntica nativa de ZIO (no sem√°ntica de Cats IO), lo que nos permite evaluar posibles problemas con fugas de recursos aqu√≠ y ahora, sabiendo que en todas las situaciones se lanzar√°n finalizadores y se liberar√°n recursos. <br><br><h2>  4. Conmutaci√≥n estable </h2><br>  Cats Effect tiene el m√©todo "evalOn" de "ContextShift", que le permite mover la ejecuci√≥n de alg√∫n c√≥digo a otro contexto de ejecuci√≥n. <br><br>  Esto es √∫til por varias razones: <br><br><ul><li>  muchas bibliotecas de clientes lo obligan a trabajar en su grupo de subprocesos; </li><li>  Las bibliotecas de IU requieren que se realicen algunas actualizaciones en el subproceso de IU; </li><li>  Algunos efectos requieren aislamiento en grupos de subprocesos adaptados a sus caracter√≠sticas espec√≠ficas. </li></ul><br>  La operaci√≥n "EvalOn" ejecuta el efecto donde debe ejecutarse y luego vuelve al contexto de ejecuci√≥n original.  Por ejemplo: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Nota: Cats IO tiene una construcci√≥n similar de "cambio", que le permite cambiar a un contexto diferente sin tener que retroceder, pero en la pr√°ctica, este comportamiento rara vez es necesario, por lo que se prefiere "evalOn". <br><br>  La implementaci√≥n de ZIO de "evalOn" (realizada en el "bloqueo" primitivo de ZIO) proporciona las garant√≠as necesarias para comprender de forma √∫nica d√≥nde funciona el efecto: el efecto siempre se ejecutar√° en un contexto espec√≠fico. <br><br>  Cats IO tiene una garant√≠a diferente y m√°s d√©bil: el efecto se ejecutar√° en un determinado contexto hasta la primera operaci√≥n asincr√≥nica o la conmutaci√≥n interna. <br><br>  Teniendo en cuenta un peque√±o fragmento de c√≥digo, es imposible saber con certeza si un efecto asincr√≥nico (o una conmutaci√≥n anidada) se integrar√° en el efecto que cambiar√°, porque la asincron√≠a no se muestra en tipos. <br><br>  Por lo tanto, como en el caso de la seguridad de los recursos, para comprender d√≥nde se lanzar√° el efecto Cats IO, es necesario estudiar todo el programa.  En la pr√°ctica, y desde mi experiencia, los usuarios de Cats IO se sorprenden cuando, al usar "evalOn" en un contexto, posteriormente se descubre que la mayor parte del efecto se realiz√≥ accidentalmente en otro. <br><br>  ZIO le permite determinar d√≥nde deben activarse los efectos y confiar en que suceder√° en todos los casos, sin importar c√≥mo se incorporen los efectos a otros efectos. <br><br><h2>  5. Seguridad de los mensajes de error. </h2><br>  Cualquier efecto que admita concurrencia, concurrencia o acceso seguro a los recursos se encontrar√° con un modelo de error lineal: en general, no se pueden guardar todos los errores. <br><br>  Esto es cierto tanto para 'Throwable', un tipo de error fijo integrado en Cats IO como para el tipo de error polim√≥rfico compatible con ZIO. <br><br>  Ejemplos de situaciones con m√∫ltiples errores √∫nicos: <br><br><ul><li>  El finalizador lanza una excepci√≥n; </li><li>  dos efectos (descendentes) se combinan en ejecuci√≥n paralela; </li><li>  dos efectos (ca√≠das) en un estado de carrera; </li><li>  el efecto interrumpido cae antes de dejar la secci√≥n protegida de interrupciones. </li></ul><br>  Dado que no se guardan todos los errores, ZIO proporciona una estructura de datos "Causa [E]" basada en un semired libre (una abstracci√≥n del √°lgebra abstracta, su conocimiento no se supone aqu√≠), que permite conectar errores en serie y paralelos para cualquier tipo de error.  Durante todas las operaciones (incluida la limpieza de un efecto ca√≠do o interrumpido), ZIO agrega errores en la estructura de datos "Causa [E]".  Esta estructura de datos est√° disponible en cualquier momento.  Como resultado, ZIO siempre almacena todos los errores: siempre est√°n disponibles, se pueden registrar, estudiar y transformar seg√∫n lo requieran los requisitos comerciales. <br><br>  Cats IO eligi√≥ un modelo con p√©rdida de informaci√≥n de error.  Mientras que ZIO conectar√° los dos errores a trav√©s de la Causa [E], Cats IO "perder√°" uno de los mensajes de error, por ejemplo, llamando al "e.printStackTrace ()" en el error que ocurre. <br><br>  Por ejemplo, se perder√° un error en el "finalizador" en este c√≥digo. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2¬´)))</span></span></code> </pre> <br>  Este enfoque para rastrear errores significa que no puede localizar y procesar localmente todo el espectro de errores que ocurren debido a la combinaci√≥n de efectos.  ZIO le permite usar cualquier tipo de error, incluido "Throwable" (o subtipos m√°s espec√≠ficos como "IOExceptio" u otra jerarqu√≠a de excepci√≥n personalizada), asegurando que no se pierdan errores durante la ejecuci√≥n del programa. <br><br><h2>  6. Asincron√≠a sin puntos muertos </h2><br>  Tanto ZIO como Cats IO proporcionan un constructor que le permite tomar c√≥digo con una devoluci√≥n de llamada y envolverlo en efecto <br><br>  Esta caracter√≠stica se proporciona a trav√©s de la clase de tuber√≠a Async en Efecto Gatos: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Esto crea un efecto asincr√≥nico que, cuando se ejecuta, esperar√° hasta que aparezca el valor y luego continuar√°, y todo esto ser√° obvio para el usuario del efecto.  Por lo tanto, la programaci√≥n funcional es tan atractiva para desarrollar c√≥digo asincr√≥nico. <br><br>  Tenga en cuenta que tan pronto como el c√≥digo de devoluci√≥n de llamada se convierta en un efecto, se llama a la funci√≥n de devoluci√≥n de llamada (aqu√≠ se llama `k`).  Esta funci√≥n de devoluci√≥n de llamada sale con un valor de √©xito / error.  Cuando se llama a esta funci√≥n de devoluci√≥n de llamada, se reanuda la ejecuci√≥n del efecto (previamente pausado). <br><br>  ZIO garantiza que el efecto reanudar√° la ejecuci√≥n en el grupo de subprocesos de tiempo de ejecuci√≥n si el efecto no se asign√≥ a ning√∫n contexto especial en particular, oa otro contexto al que se adjunt√≥ el efecto. <br><br>  Cats IO reanuda el efecto en el hilo de devoluci√≥n de llamada.  La diferencia entre estas opciones es bastante profunda: el hilo que causa la devoluci√≥n de llamada no espera que el c√≥digo de devoluci√≥n de llamada se ejecute para siempre, pero solo permite un ligero retraso antes de que regrese el control.  Por otro lado, Cats IO no ofrece tal garant√≠a en absoluto: el hilo de llamada, la devoluci√≥n de llamada de inicio, puede congelarse, esperando un tiempo indefinido cuando regrese el control de ejecuci√≥n. <br><br>  Las versiones anteriores de las estructuras de datos competitivas en Cats Effect ("Diferido", "Sem√°foro") reanudaron los efectos que no devolvieron el control de ejecuci√≥n al hilo de llamada.  Como resultado, se descubrieron problemas relacionados con puntos muertos y un programador de ejecuci√≥n roto.  Aunque se han encontrado todos estos problemas, solo se corrigen para estructuras de datos competitivas en Cats Effect. <br><br>  El c√≥digo de usuario que utiliza un enfoque similar al de Cats IO se meter√° en tales problemas, ya que tales tareas no son deterministas, los errores solo pueden ocurrir muy raramente en tiempo de ejecuci√≥n, lo que hace que la depuraci√≥n y la detecci√≥n de problemas sean un proceso dif√≠cil. <br><br>  ZIO proporciona protecci√≥n de punto muerto y un programador de tareas normal fuera de la caja, y tambi√©n hace que el usuario elija expl√≠citamente el comportamiento de Cats IO (por ejemplo, usando "unsafeRun" en "Promise", que termin√≥ en un efecto asincr√≥nico reanudado). <br><br>  Aunque ninguna de las soluciones es adecuada para absolutamente todos los casos, y ZIO y Cats IO proporcionan suficiente flexibilidad para resolver todas las situaciones (de diferentes maneras), elegir ZIO significa usar "Async" sin preocupaciones y lo obliga a poner el c√≥digo del problema en "unsafeRun", que se sabe que causa un punto muerto <br><br><h2>  7. Compatible con el futuro </h2><br>  Usar "Future" de la biblioteca est√°ndar de Scala es una realidad para una gran cantidad de bases de c√≥digo.  ZIO viene con un m√©todo "fromFuture", que proporciona un contexto de ejecuci√≥n listo: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Cuando este m√©todo se utiliza para ajustar Future en un efecto, ZIO puede establecer d√≥nde se ejecutar√° Future, y otros m√©todos, como evalOn, transferir√°n correctamente Future al contexto de ejecuci√≥n deseado.  Cats IO acepta "Future", que se cre√≥ con un "ExecutionContext" externo.  Esto significa que Cats IO no puede mover la ejecuci√≥n de Future de acuerdo con los requisitos de los m√©todos de evaluaci√≥n o cambio.  Adem√°s, esto carga al usuario con la determinaci√≥n del contexto de ejecuci√≥n para el Futuro, lo que significa una selecci√≥n limitada y un entorno separado. <br><br>  Dado que se puede ignorar el ExecutionContext proporcionado, ZIO se puede representar como la suma de las caracter√≠sticas de Cats IO, garantizando una interacci√≥n m√°s fluida y precisa con Future en el caso general, pero todav√≠a hay excepciones. <br><br><h2>  8. Bloqueo de IO </h2><br>  Como se mostr√≥ en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupo de subprocesos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejores pr√°cticas con ZIO</a> ‚Äù, para aplicaciones de servidor, se requieren al menos dos grupos separados para una m√°xima eficiencia: <br><br><ul><li>  grupo fijo para CPU / efectos asincr√≥nicos; </li><li>  din√°mico, con la posibilidad de aumentar el n√∫mero de hilos de bloqueo. </li></ul><br>  La decisi√≥n de ejecutar todos los efectos en un grupo de subprocesos fijo alg√∫n d√≠a conducir√° a un punto muerto, mientras que desencadenar todos los efectos en un grupo din√°mico puede conducir a la p√©rdida de rendimiento. <br><br>  En la JVM, ZIO proporciona dos operaciones que admiten efectos de bloqueo: <br><br><ul><li>  Operador "Bloqueo (efecto)", que cambia la ejecuci√≥n de un cierto efecto en el conjunto de subprocesos de bloqueo que tienen buenos ajustes preestablecidos que se pueden cambiar si se desea); </li><li> ¬´effectBlocking(effect)¬ª ,          ,        . </li></ul><br>     ,     ,       ,       ¬´blocking¬ª.   ,    -    ,  ,       ¬´effectBlocking¬ª     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     ¬´blocking¬ª,    ¬´evalOn¬ª, , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> ¬´ReaderT¬ª/ ¬´Kleisli¬ª,       ; </li><li> ¬´EitherT¬ª,      ( ¬´OptionT¬ª,     ¬´EitherT¬ª   ¬´Unit¬ª    ). </li></ul><br>    ,          (, http4s   ¬´Kleisli¬ª  ¬´OptionT¬ª).        (¬´effect totation¬ª), ZIO   ¬´reader¬ª  ¬´typed error¬ª      ZIO.         ¬´reader¬ª  ¬´typed error¬ª , ZIO    ,    . , ¬´Task[A]¬ª,    ¬´reader¬ª  ¬´typed errors¬ª. <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   ¬´reader¬ª  ¬´typed errors¬ª      ¬´state¬ª, ¬´writer¬ª  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    ¬´typed errors¬ª  ,       ‚Äî     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : ¬´ZIO. succeed¬ª  ¬´Applicative[F].pure¬ª, ¬´zip¬ª  ¬´Apply[F].product¬ª, ¬´ZIO.foreach¬ª  ¬´Traverse[F].traverse¬ª. <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  ¬´Runtime¬ª,      Cats Effect  -   Cats Effect).  ‚Äî        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy¬´. <br></li><li>      ,        ¬´¬ª.   ZIO    IDE. </li><li>      Scala  ZIO  : ¬´ZIO.fromFuture¬ª, ¬´ZIO.fromOption¬ª, ¬´ZIO.fromEither¬ª, ¬´ZIO.fromTry¬ª. </li><li>         ¬´¬ª. </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO ‚Äî  - ,           . <br><br>     : <br><br><ul><li>     ,  ¬´Ref¬ª, ¬´Promise¬ª, ¬´Queue¬ª, ¬´Semaphore¬ª   ¬´Stream¬ª    //; </li><li> STM,       , ,     ; </li><li> ¬´Schedule¬ª,    ; </li><li>    ¬´Clock¬ª, ¬´Random¬ª, ¬´Console¬ª  ¬´System¬ª ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Conclusi√≥n </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      ‚Äî    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472386/">https://habr.com/ru/post/472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472372/index.html">Automatizaci√≥n de Android Gu√≠a s√∫per f√°cil para crear tu primera prueba de Espresso</a></li>
<li><a href="../472374/index.html">¬øPor qu√© mudamos servidores a Islandia?</a></li>
<li><a href="../472378/index.html">Fiabilidad de flash: esperada e inesperada. Parte 2. XIV conferencia de la asociaci√≥n USENIX. Tecnolog√≠as de almacenamiento de archivos</a></li>
<li><a href="../472380/index.html">MIRO: una plataforma robotizada de interior abierta</a></li>
<li><a href="../472384/index.html">Una mirada a las actualizaciones de Android desde la perspectiva de un desarrollador</a></li>
<li><a href="../472388/index.html">Walmart declara guerra de precios en Amazon</a></li>
<li><a href="../472392/index.html">El aumento, la ca√≠da y el posible regreso de los casetes de audio: tratamos los mitos y damos una visi√≥n general de la situaci√≥n</a></li>
<li><a href="../472394/index.html">Evaluar el impacto de la inteligencia artificial en el petr√≥leo y el gas en alta mar</a></li>
<li><a href="../472396/index.html">La vuelta al mundo en 4 segundos en Columnstore (Parte 1)</a></li>
<li><a href="../472402/index.html">Transmisi√≥n de videollamadas RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>