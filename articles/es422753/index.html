<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìâ üìá ‚õ∞Ô∏è Comprender las particiones en PostgreSQL 9 üïµÔ∏è üíÜ üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 10 se lanz√≥ a principios de octubre de 2017, hace casi un a√±o. 

 Una de las nuevas "caracter√≠sticas" m√°s interesantes es la partici√≥n inco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprender las particiones en PostgreSQL 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422753/"> PostgreSQL 10 se lanz√≥ a principios de octubre de 2017, hace casi un a√±o. <br><br>  Una de las nuevas "caracter√≠sticas" m√°s interesantes es la partici√≥n incondicionalmente declarativa.  Pero, ¬øqu√© pasa si no tienes prisa por actualizar a 10k?  Amazon, por ejemplo, no tiene prisa, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">present√≥ el soporte PostgreSQL</a> 10 solo en los √∫ltimos d√≠as de febrero de 2018. <br><br>  Entonces, una buena partici√≥n a trav√©s de la herencia viene al rescate.  Soy el arquitecto de software del departamento de finanzas de una compa√±√≠a de taxis, por lo que todos los ejemplos estar√°n relacionados con los viajes de una forma u otra (dejaremos los problemas de dinero para otro momento). <br><br>  Desde que comenzamos a reescribir nuestro sistema financiero en 2015, cuando me un√≠ a la compa√±√≠a, no se habl√≥ de ninguna partici√≥n declarativa.  Hasta el d√≠a de hoy, la t√©cnica descrita a continuaci√≥n se ha utilizado con √©xito. <br><br>  La raz√≥n original para escribir este art√≠culo fue que la mayor√≠a de los ejemplos de particiones en PostgreSQL que encontr√© eran muy b√°sicos.  Aqu√≠ hay una tabla, aqu√≠ hay una columna que estamos viendo, y tal vez incluso sepamos de antemano qu√© valores contiene.  Parece que todo es simple.  Pero la vida real hace sus propios ajustes. <br><a name="habracut"></a><br>  En nuestro caso, dividimos las tablas en dos columnas, una de las cuales contiene fechas de viaje.  Es este caso el que consideraremos. <br><br>  Comencemos con el aspecto de nuestra mesa: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rides ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> bigserial <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, tenant_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ride_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, created_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, metadata jsonb <span class="hljs-comment"><span class="hljs-comment">-- Probably more columns and indexes coming here );</span></span></code> </pre> <br>  Para cada inquilino, la tabla contiene millones de filas por mes.  Afortunadamente, los datos entre los inquilinos nunca se cruzan, y las solicitudes m√°s dif√≠ciles se hacen al cabo de uno o dos meses. <br><br>  Para aquellos que no han profundizado en c√≥mo funcionan las particiones PostgreSQL (¬°qu√© suerte de Oracle, hola!), Describir√© brevemente el proceso. <br><br>  PostgreSQL se basa en dos de sus "caracter√≠sticas" para esto: la capacidad de heredar tablas, herencia de tablas y condiciones verificadas. <br><br>  Comencemos con la herencia.  Usando la palabra clave INHERITS, indicamos que la tabla que creamos hereda todos los campos de la tabla heredada.  Esto tambi√©n crea una relaci√≥n entre las dos tablas: al hacer una consulta desde el padre, tambi√©n obtenemos todos los datos de los hijos. <br><br>  Las condiciones marcadas complementan la imagen al garantizar que los datos no se crucen.  Por lo tanto, el optimizador PostgreSQL puede cortar parte de las tablas secundarias al confiar en los datos de la consulta. <br><br>  El primer escollo de este enfoque parecer√≠a bastante obvio: cualquier solicitud debe contener tenant_id.  Y, sin embargo, si no se recuerda constantemente esto, tarde o temprano usted mismo escribir√° un SQL personalizado en el que olvidar√° especificar este tenant_id.  Como resultado, una exploraci√≥n de todas las particiones y una base de datos que no funciona. <br><br>  Pero volvamos a lo que queremos lograr.  A nivel de aplicaci√≥n, me gustar√≠a transparencia: siempre escribimos en la misma tabla, y la base de datos ya elige exactamente d√≥nde colocar estos datos. <br><br>  Para hacer esto, utilizamos el siguiente procedimiento almacenado: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> insert_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> partition_env <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>; partition_date TIMESTAMP; partition_name TEXT; sql TEXT; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- construct partition name partition_env := lower(NEW.tenant_id); partition_date := date_trunc('month', NEW.created_at AT TIME ZONE 'UTC'); partition_name := format('%s_%s_%s', TG_TABLE_NAME, partition_env, to_char(partition_date, 'YYYY_MM')); -- create partition, if necessary IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN PERFORM create_new_partition(TG_TABLE_NAME, NEW.tenant_id, partition_date, partition_name); END IF; select format('INSERT INTO %s values ($1.*)', partition_name) into sql; -- Propagate insert EXECUTE sql USING NEW; RETURN NEW; -- RETURN NULL; if no ORM END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Lo primero a lo que debe prestar atenci√≥n es al uso de TG_TABLE_NAME.  Dado que esto es un desencadenante, PostgreSQL llena bastantes variables para nosotros a las que podemos acceder.  La lista completa se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar aqu√≠</a> . <br><br>  En nuestro caso, queremos obtener el nombre del padre de la tabla en la que funcion√≥ el desencadenador.  En nuestro caso, ser√°n paseos.  Utilizamos un enfoque similar en varios microservicios, y esta parte se puede transferir pr√°cticamente sin cambios. <br><br>  <code>PERFORM</code> es √∫til si queremos llamar a una funci√≥n que no devuelve nada.  Por lo general, en los ejemplos, intentan poner toda la l√≥gica en una funci√≥n, pero tratamos de tener cuidado. <br><br>  <code>USING NEW</code> indica que en esta consulta usamos los valores de la cadena que intentamos agregar. <br><br>  <code>$1.*</code> expandir√° todos los valores de nueva l√≠nea.  De hecho, esto se puede traducir a <code>NEW.*</code> .  Lo que se traduce en <code>NEW.ID, NEW.TENANT_ID, ‚Ä¶</code> <br><br>  El siguiente procedimiento, que llamamos con <code>PERFORM</code> , crear√° una nueva partici√≥n, si a√∫n no existe.  Esto suceder√° una vez por per√≠odo para cada inquilino. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> create_new_partition(parent_table_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, env <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, partition_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Notifying RAISE NOTICE 'A new % partition will be created: %', parent_table_name, partition_name; select format('CREATE TABLE IF NOT EXISTS %s (CHECK ( tenant_id = ''%s'' AND created_at AT TIME ZONE ''UTC'' &gt; ''%s'' AND created_at AT TIME ZONE ''UTC'' &lt;= ''%s'')) INHERITS (%I)', partition_name, env, partition_date, partition_date + interval '1 month', parent_table_name) into sql; -- New table, inherited from a master one EXECUTE sql; PERFORM index_partition(partition_name); END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Como se describi√≥ anteriormente, usamos <code>INHERITS</code> para crear una tabla similar a la principal, y <code>CHECK</code> para determinar qu√© datos deben ir all√≠. <br><br>  <code>RAISE NOTICE</code> simplemente imprime una cadena en la consola.  Si ahora ejecutamos <code>INSERT</code> desde psql, podemos ver si se cre√≥ la partici√≥n. <br><br>  Tenemos un nuevo problema  <code>INHERITS</code> no hereda √≠ndices.  Para hacer esto, tenemos dos soluciones: <br><br>  Crear √≠ndices usando herencia: <br>  Use <code>CREATE TABLE LIKE</code> y luego <code>ALTER TABLE INHERITS</code> <br><br>  O cree √≠ndices procesales: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_partition(partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Ensure we have all the necessary indices in this partition; EXECUTE 'CREATE INDEX IF NOT EXISTS ' || partition_name || '_tenant_timezone_idx ON ' || partition_name || ' (tenant_id, timezone(''UTC''::text, created_at))'; -- More indexes here... END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Es muy importante no olvidarse de indexar tablas secundarias, porque incluso despu√©s de la partici√≥n, cada una de ellas tendr√° millones de filas.  Los √≠ndices en padre no son necesarios en nuestro caso, ya que el padre siempre permanecer√° vac√≠o. <br><br>  Finalmente, creamos un disparador que se llamar√° cuando se cree una nueva l√≠nea: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> before_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> insert_row();</code> </pre> <br>  Hay otra sutileza en la que rara vez prestan atenci√≥n.  Particionar es mejor en columnas donde los datos nunca cambian.  En nuestro caso, esto funciona: el viaje nunca cambia tenant_id y created_at.  El problema que surge si esto no es as√≠ es que PostreSQL no nos devolver√° parte de los datos.  Luego le prometimos VERIFICAR que todos los datos son v√°lidos. <br><br>  Hay varias soluciones (excepto lo obvio: no mute los datos para los que estamos particionando): <br><br>  En lugar de <code>UPDATE</code> siempre hacemos <code>DELETE+INSERT</code> a nivel de aplicaci√≥n <br>  Agregamos un disparador m√°s en <code>UPDATE</code> que transferir√° datos a la partici√≥n correcta <br><br>  Otra advertencia que vale la pena considerar es c√≥mo indexar correctamente las columnas que contienen fechas.  Si usamos AT TIME ZONE en las consultas, no debemos olvidar que esta es realmente una llamada de funci√≥n.  Y eso significa que nuestro √≠ndice debe estar basado en funciones.  Lo olvid√©  Como resultado, la base est√° muerta nuevamente por la carga. <br><br>  El √∫ltimo aspecto que vale la pena considerar es c√≥mo las particiones interact√∫an con varios marcos ORM, ya sea ActiveRecord en Ruby o GORM en Go. <br><br>  Las particiones en PostgreSQL se basan en el hecho de que la tabla primaria siempre estar√° vac√≠a.  Si no usa ORM, puede regresar con seguridad al primer procedimiento almacenado y cambiar RETURN NEW;  en RETURN NULL;  Luego, la fila en la tabla principal simplemente no se agregar√°, que es exactamente lo que queremos. <br><br>  Pero el hecho es que la mayor√≠a de los ORM utilizan la cl√°usula RETURNING con INSERT.  Si devolvemos NULL desde nuestro disparador, el ORM entrar√° en p√°nico, creyendo que la fila no se ha agregado.  Se agrega, pero no donde ORM est√° buscando. <br><br>  Hay varias formas de evitar esto: <br><br><ul><li>  No use ORM para INSERTOS </li><li>  Parche ORM (que a veces se recomienda en el caso de ActiveRecord) </li><li>  Agregue otro disparador, que eliminar√° la l√≠nea del padre. </li></ul><br>  La √∫ltima opci√≥n no es deseable, porque para cada operaci√≥n realizaremos tres.  Sin embargo, a veces es inevitable, porque lo consideraremos por separado: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> delete_parent_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = NEW.ID; RETURN null; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $BODY$ LANGUAGE plpgsql;</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> after_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> delete_parent_row();</code> </pre> <br>  Lo √∫ltimo que debemos hacer es probar nuestra soluci√≥n.  Para hacer esto, generamos un cierto n√∫mero de l√≠neas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $script$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> year_start_epoch <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'20170101'</span></span>::timestamptz <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>); delta bigint := extract(epoch from '20171231 23:59:59'::timestamptz at time zone 'UTC') - year_start_epoch; tenant varchar; tenants varchar[] := array['tenant_a', 'tenant_b', 'tenant_c', 'tenant_d']; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> FOREACH tenant <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span> tenants <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> rides (tenant_id, created_at, ride_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (tenant, to_timestamp(random() * delta + year_start_epoch) <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $script$;</code> </pre> <br>  Y veamos c√≥mo se comporta la base de datos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tenant_id = <span class="hljs-string"><span class="hljs-string">'tenant_a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'20171102'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &lt;= <span class="hljs-string"><span class="hljs-string">'20171103'</span></span>;</code> </pre> <br>  Si todo sali√≥ bien, deber√≠amos ver el siguiente resultado: <br><br><pre> <code class="sql hljs"> Append (cost=0.00..4803.76 rows=4 width=196) -&gt; Seq Scan on rides (cost=0.00..4795.46 rows=3 width=196) Filter: (((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone) AND ((tenant_id)::text = 'tenant_a'::text)) -&gt; Index Scan using rides_tenant_a_2017_11_tenant_timezone_idx on rides_tenant_a_2017_11 (cost=0.28..8.30 rows=1 width=196) Index Cond: (((tenant_id)::text = 'tenant_a'::text) AND ((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone)) (5 rows)</code> </pre> <br>  A pesar de que cada inquilino tiene cientos de miles de filas, solo seleccionamos del segmento de datos deseado.  √âxito! <br><br>  Espero que este art√≠culo sea interesante para aquellos que a√∫n no est√°n familiarizados con lo que es el particionamiento y c√≥mo se implementa en PostgreSQL.  Pero aquellos para quienes este tema ya no es nuevo, sin embargo, aprendieron un par de trucos interesantes. <br><br>  UPD: <br>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">bigtrot</a> observ√≥ correctamente, toda esta magia callejera no funcionar√° si la configuraci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CONSTRAINT_EXCLUSION</a> est√° desactivada. <br><br>  Puedes verificar esto usando el comando <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> CONSTRAINT_EXCLUSION</code> </pre> <br><br>  La configuraci√≥n tiene tres valores: encendido, apagado y partici√≥n <br><br>  La configuraci√≥n de la partici√≥n es m√°s √≥ptima si de repente le gusta usar CHECK CONSTRAINTS no solo para las particiones, sino tambi√©n para la normalizaci√≥n de datos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422753/">https://habr.com/ru/post/es422753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422739/index.html">Las plantas de energ√≠a e√≥lica y solar en el Sahara ayudar√°n a mejorar el clima en el desierto</a></li>
<li><a href="../es422743/index.html">C√≥mo siente el cerebro el tiempo</a></li>
<li><a href="../es422745/index.html">Estrella de conocimiento cautivador</a></li>
<li><a href="../es422747/index.html">Posici√≥n de soporte de cifrado fuerte oficial de IEEE</a></li>
<li><a href="../es422751/index.html">10 herramientas de diagn√≥stico SSL / TLS gratuitas para webmasters</a></li>
<li><a href="../es422755/index.html">¬øLa cartera proteger√° contra el hundimiento criptogr√°fico?</a></li>
<li><a href="../es422757/index.html">No pol√≠tica ¬øC√≥mo transformar permanentemente las protestas callejeras usando una aplicaci√≥n m√≥vil?</a></li>
<li><a href="../es422759/index.html">Mapa interactivo para una aplicaci√≥n web en un par de horas.</a></li>
<li><a href="../es422761/index.html">Cuatro formas de Yandex Data Analysis School</a></li>
<li><a href="../es422763/index.html">Eventos digitales en Mosc√∫ del 10 al 16 de septiembre.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>