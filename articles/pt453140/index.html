<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜïÔ∏è üñïüèø üñ±Ô∏è Quem est√° roubando o tempo da CPU virtual? üåΩ üë©üèΩ ü§≥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Neste artigo, quero explicar, em termos leigos, como o roubo aparece nas VMs e falar sobre alguns dos artefatos menos do que √≥bvios que encontramos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quem est√° roubando o tempo da CPU virtual?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453140/"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/ede/bb8/9d4edebb8a0253cb1b973bd5df46a9a9.jpg"><br><br>  Oi  Neste artigo, quero explicar, em termos leigos, como o <i>roubo</i> aparece nas VMs e falar sobre alguns dos artefatos menos do que √≥bvios que encontramos durante a pesquisa sobre o t√≥pico em que eu estava envolvido como CTO do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mail. com a</a> plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cloud Solutions</a> .  A plataforma executa o KVM. <br><a name="habracut"></a><br>  Tempo de roubo de CPU √© o tempo durante o qual uma VM n√£o recebe os recursos necess√°rios para operar.  Esse tempo s√≥ pode ser calculado em um sistema operacional convidado em ambientes de virtualiza√ß√£o.  N√£o √© muito claro onde os recursos alocados s√£o perdidos, como em situa√ß√µes da vida real.  No entanto, decidimos descobrir e realizamos uma s√©rie de testes para fazer isso.  Isso n√£o quer dizer que sabemos tudo sobre <i>roubar,</i> mas h√° algumas coisas fascinantes que gostar√≠amos de compartilhar com voc√™. <br><br><h2>  1. O que √© <i>roubo</i> ? </h2><br>  <i>Roubar</i> √© uma m√©trica que indica uma falta de tempo de CPU para processos de VM.  Conforme descrito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kvm</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KVM</a> , <i>roubo</i> √© o tempo que um hipervisor gasta executando outros processos em um sistema operacional host, enquanto o processo da VM est√° em uma fila de execu√ß√£o.  Em outras palavras, o <i>roubo</i> √© calculado como a diferen√ßa entre o momento em que um processo est√° pronto para ser executado e o momento em que o tempo da CPU √© alocado para o processo. <br><br>  O kernel da VM obt√©m a m√©trica de <i>roubo</i> do hipervisor.  O hypervisor n√£o especifica quais processos ele est√° executando.  Apenas diz: "Estou ocupado e n√£o posso alocar nenhum tempo para voc√™".  Em uma KVM, o c√°lculo de <i>roubo</i> √© suportado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patches</a> .  Existem dois pontos principais em rela√ß√£o a isso: <br><br><ul><li>  Uma VM aprende sobre <i>roubo</i> do hipervisor.  Isso significa que, em termos de perdas, o <i>roubo</i> √© uma medida indireta que pode ser distorcida de v√°rias maneiras. <br></li><li>  O hypervisor n√£o compartilha com as informa√ß√µes da VM sobre o que est√° ocupado.  O ponto mais crucial √© que ele n√£o aloca tempo para isso.  A pr√≥pria VM, portanto, n√£o pode detectar distor√ß√µes na m√©trica de <i>roubo</i> <i>,</i> que pode ser estimada pela natureza dos processos concorrentes. <br></li></ul><br><h2>  2. O que afeta o <i>roubo</i> ? </h2><br><h4>  2.1  Calculando <i>roubo</i> </h4><br>  Essencialmente, o <i>roubo</i> √© calculado mais ou menos da mesma maneira que o tempo de utiliza√ß√£o da CPU.  N√£o h√° muitas informa√ß√µes sobre como a utiliza√ß√£o √© calculada.  Provavelmente porque a maioria dos profissionais acha √≥bvio.  No entanto, existem algumas armadilhas.  O processo √© descrito em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo de Brendann Gregg</a> .  Ele discute uma s√©rie de nuances sobre como calcular a utiliza√ß√£o e os cen√°rios nos quais o c√°lculo estar√° errado: <br><br><ul><li>  Superaquecimento e limita√ß√£o da CPU. <br></li><li>  Ativar / desativar o Turbo Boost, resultando em uma altera√ß√£o na taxa de clock da CPU. </li><li> A mudan√ßa de intervalo de tempo que ocorre quando as tecnologias de economia de energia da CPU, por exemplo, SpeedStep, s√£o usadas. <br></li><li>  Problemas relacionados ao c√°lculo de m√©dias: medir a utiliza√ß√£o por um minuto a 80% da energia pode ocultar um aumento de 100% no curto prazo. <br></li><li>  Um spinlock que resulta em um cen√°rio no qual o processador √© utilizado, mas o processo do usu√°rio n√£o progride.  Como resultado, a utiliza√ß√£o calculada da CPU ser√° 100%, mas o processo n√£o consumir√° realmente o tempo da CPU. <br></li></ul><br>  N√£o encontrei nenhum artigo descrevendo esses c√°lculos de <i>roubo</i> (se voc√™ souber de algum, compartilhe-o na se√ß√£o de coment√°rios).  Como voc√™ pode ver no c√≥digo-fonte, o mecanismo de c√°lculo √© o mesmo da utiliza√ß√£o.  A √∫nica diferen√ßa √© que outro contador √© adicionado especificamente para o processo KVM (processo VM), que calcula quanto tempo o processo KVM aguarda o tempo da CPU.  O contador obt√©m dados da CPU de suas especifica√ß√µes e verifica se todos os seus ticks est√£o sendo utilizados pelo processo da VM.  Se todos os ticks estiverem sendo usados, a CPU estar√° ocupada apenas com o processo da VM.  Caso contr√°rio, sabemos que a CPU estava fazendo outra coisa e o <i>roubo</i> aparece. <br><br>  O processo pelo qual o <i>roubo</i> √© calculado est√° sujeito aos mesmos problemas que o c√°lculo regular da utiliza√ß√£o.  Esses problemas n√£o s√£o t√£o comuns, mas podem parecer bastante confusos. <br><br><h4>  2.2  Tipos de virtualiza√ß√£o KVM </h4><br>  Em geral, existem tr√™s tipos de virtualiza√ß√£o e todos s√£o suportados por uma KVM.  O mecanismo pelo qual o <i>roubo</i> ocorre pode depender do tipo de virtualiza√ß√£o. <br><br>  Tradu√ß√£o  Nesse caso, o sistema operacional da VM funcionar√° com dispositivos de hipervisor f√≠sico da seguinte maneira: <br><br><ol><li>  O SO convidado envia um comando para seu dispositivo convidado. <br></li><li>  O driver de dispositivo convidado aceita o comando, cria uma solicita√ß√£o de dispositivo do BIOS e envia o comando ao hipervisor. <br></li><li>  O processo do hypervisor converte o comando em um comando de dispositivo f√≠sico, tornando-o mais seguro, entre outras coisas. <br></li><li>  O driver de dispositivo f√≠sico aceita o comando modificado e o encaminha para o pr√≥prio dispositivo f√≠sico. <br></li><li>  Os resultados da execu√ß√£o do comando retornam seguindo o mesmo caminho. <br></li></ol><br>  A vantagem da tradu√ß√£o √© que ela nos permite emular qualquer dispositivo e n√£o requer nenhuma prepara√ß√£o especial do kernel do SO.  Mas isso ocorre √†s custas do desempenho. <br><br>  Virtualiza√ß√£o de hardware.  Nesse caso, um dispositivo recebe comandos do sistema operacional no n√≠vel do hardware.  Este √© o melhor m√©todo mais r√°pido e geral.  Infelizmente, nem todos os dispositivos f√≠sicos, hipervisores e sistemas operacionais convidados s√£o compat√≠veis.  Por enquanto, os principais dispositivos que suportam a virtualiza√ß√£o de hardware s√£o CPUs. <br><br>  Paravirtualiza√ß√£o.  A op√ß√£o mais comum para virtualiza√ß√£o de dispositivos em um KVM e o tipo mais difundido de virtualiza√ß√£o para sistemas operacionais convidados.  Sua principal caracter√≠stica √© que ele trabalha com alguns subsistemas de hipervisor (por exemplo, rede ou pilha de unidades) e aloca p√°ginas de mem√≥ria usando uma API de hipervisor sem converter comandos de baixo n√≠vel.  A desvantagem desse m√©todo de virtualiza√ß√£o √© a necessidade de modificar o kernel do sistema operacional convidado para permitir a intera√ß√£o com o hipervisor usando a mesma API.  A solu√ß√£o mais comum para esse problema √© instalar drivers especiais no sistema operacional convidado.  Em uma KVM, essa API √© chamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API virtio</a> . <br><br>  Quando a paravirtualiza√ß√£o √© usada, o caminho para o dispositivo f√≠sico √© muito menor do que nos casos em que a tradu√ß√£o √© usada, porque os comandos s√£o enviados diretamente da VM para o processo do hypervisor no host.  Isso acelera a execu√ß√£o de todas as instru√ß√µes na VM.  Em um KVM, uma API virtio √© respons√°vel por isso.  Funciona apenas para alguns dispositivos, como adaptadores de rede e unidade.  √â por isso que os drivers virtio s√£o instalados nas VMs. <br><br>  O outro lado dessa acelera√ß√£o √© que nem todos os processos executados em uma VM permanecem na VM.  Isso resulta em v√°rios efeitos, que podem causar <i>roubo</i> .  Se voc√™ quiser saber mais, comece com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma API para E / S virtual: virtio</a> . <br><br><h4>  2.3  Programa√ß√£o justa </h4><br>  Uma VM em um hypervisor √©, de fato, um processo regular, sujeito a leis de agendamento (distribui√ß√£o de recursos entre processos) em um kernel Linux.  Vamos dar uma olhada mais de perto nisso. <br><br>  O Linux usa o chamado CFS, Completely Fair Scheduler, que se tornou o padr√£o no kernel 2.6.23.  Para entender esse algoritmo, leia Linux Kernel Architecture ou o c√≥digo fonte.  A ess√™ncia do CFS reside na distribui√ß√£o do tempo da CPU entre os processos, dependendo do tempo de execu√ß√£o.  Quanto mais tempo de CPU um processo requer, menor √© o tempo de CPU.  Isso garante a execu√ß√£o "justa" de todos os processos e ajuda a evitar que um processo ocupe todos os processadores, o tempo todo e permita que outros processos tamb√©m sejam executados. <br><br>  √Äs vezes, esse paradigma resulta em artefatos interessantes.  Os usu√°rios antigos do Linux, sem d√∫vida, se lembrar√£o de como um editor de texto comum na √°rea de trabalho congelaria ao executar aplicativos com muitos recursos, como um compilador.  Isso aconteceu porque tarefas leves de recursos, como aplicativos de desktop, estavam competindo com tarefas que usavam muitos recursos, como um compilador.  O CFS considera isso injusto e, portanto, interrompe o editor de texto periodicamente e permite que a CPU processe as tarefas do compilador.  Isso foi corrigido usando o mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sched_autogroup</a> ;  existem, no entanto, muitas outras peculiaridades da distribui√ß√£o de tempo da CPU.  Este artigo n√£o √© realmente sobre o qu√£o ruim √© o CFS.  √â uma tentativa de chamar a aten√ß√£o para o fato de que a distribui√ß√£o "justa" do tempo da CPU n√£o √© a tarefa mais trivial. <br><br>  Outro aspecto importante de um agendador √© a preemp√ß√£o.  Isso √© necess√°rio para livrar a CPU de qualquer processo excessivo e permitir que outros trabalhem tamb√©m.  Isso √© chamado de <i>altern√¢ncia de contexto</i> .  Todo o contexto da tarefa √© mantido: status da pilha, registradores etc., ap√≥s o qual o processo √© deixado em espera e √© substitu√≠do por outro processo.  Esta √© uma opera√ß√£o cara para um sistema operacional.  √â raramente usado, mas na verdade n√£o √© ruim.  A altern√¢ncia frequente de contexto pode ser um indicador de um problema no SO, mas geralmente ocorre continuamente e n√£o √© sinal de nenhum problema em particular. <br><br>  Esse longo discurso foi necess√°rio para explicar um fato: em um planejador Linux justo, quanto mais recursos de CPU o processo consome, mais r√°pido ele ser√° parado para permitir que outros processos funcionem.  Se isso √© certo ou n√£o, √© uma quest√£o complexa, e a solu√ß√£o √© diferente dependendo da carga.  At√© recentemente, o agendador do Windows priorizava os aplicativos da √°rea de trabalho, o que resultava em processos de segundo plano mais lentos.  No Sun Solaris, havia cinco classes diferentes de agendadores.  Quando a virtualiza√ß√£o foi introduzida, eles adicionaram outro, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agendador de compartilhamento justo</a> , porque os outros n√£o estavam funcionando corretamente com a virtualiza√ß√£o do Solaris Zones.  Para aprofundar isso, recomendo come√ßar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solaris Internals: Solaris 10 e OpenSolaris Kernel Architecture</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entendendo o kernel do Linux</a> . <br><br><h4>  2.4  Como podemos monitorar o <i>roubo</i> ? </h4><br>  Assim como qualquer outra m√©trica da CPU, √© f√°cil monitorar o <i>roubo</i> dentro de uma VM.  Voc√™ pode usar qualquer ferramenta de medi√ß√£o m√©trica da CPU.  O principal √© que a VM deve estar no Linux.  Por alguma raz√£o, o Windows n√£o fornece essas informa√ß√µes ao usu√°rio.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/9f8/5b1/fff9f85b10523ddaecfc176f1fa18f33.png"><br>  <i>sa√≠da superior: especifica√ß√£o da carga da CPU com roubo na coluna da direita</i> <br><br>  As coisas ficam complicadas ao tentar obter essas informa√ß√µes de um hipervisor.  Voc√™ pode tentar prever <i>roubo</i> em uma m√°quina host, usando Load Average (LA), por exemplo.  Este √© o valor m√©dio do n√∫mero de processos na fila de execu√ß√£o.  O m√©todo de c√°lculo para esse par√¢metro n√£o √© simples, mas, em geral, se um AL padronizado de acordo com o n√∫mero de encadeamentos da CPU for maior que 1, isso significa que o servidor Linux est√° sobrecarregado. <br><br>  Ent√£o, o que todos esses processos est√£o esperando?  Obviamente, a CPU.  Essa resposta n√£o √© muito precisa, no entanto, porque √†s vezes a CPU √© livre e o LA √© muito alto.  Lembre-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que o NFS cai e o LA aumenta ao mesmo tempo</a> .  Uma situa√ß√£o semelhante pode ocorrer com a unidade e outros dispositivos de entrada / sa√≠da.  De fato, os processos podem estar aguardando o fim de um bloqueio: f√≠sico (relacionado a dispositivos de entrada / sa√≠da) ou l√≥gico (um objeto mutex, por exemplo).  O mesmo vale para bloqueios no n√≠vel do hardware (por exemplo, resposta do disco) ou bloqueios no n√≠vel l√≥gico (chamados "primitivas de bloqueio"), que incluem v√°rias entidades, adaptabilidade e rota√ß√£o mutex, sem√°foros, vari√°veis ‚Äã‚Äãde condi√ß√£o, bloqueios rw, bloqueios de ipc ...). <br><br>  Outra caracter√≠stica do LA √© que ele √© calculado como um valor m√©dio dentro do sistema operacional.  Por exemplo, se 100 processos competem por um arquivo, o LA √© 50. Esse grande n√∫mero pode parecer ruim para o sistema operacional.  No entanto, para c√≥digos mal escritos, isso pode ser normal.  Somente esse c√≥digo espec√≠fico seria ruim e o restante do sistema operacional pode ser bom. <br><br>  Devido a essa m√©dia (por menos de um minuto), determinar qualquer coisa usando um AL n√£o √© a melhor ideia, pois pode produzir resultados extremamente amb√≠guos em alguns casos.  Se voc√™ tentar descobrir mais sobre isso, descobrir√° que a Wikipedia e outros recursos dispon√≠veis descrevem apenas os casos mais simples, e o processo n√£o √© descrito em detalhes.  Se voc√™ estiver interessado nisso, visite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brendann Gregg</a> e siga os links. <br><br><h2>  3. efeitos especiais </h2><br>  Agora vamos aos principais casos de <i>roubo</i> que encontramos.  Permitam-me explicar como eles resultam do exposto acima e como eles se correlacionam com as m√©tricas do hipervisor. <br><br>  Superutiliza√ß√£o.  O caso mais simples e mais comum: o hypervisor est√° sendo superutilizado.  De fato, com muitas VMs executando e consumindo muitos recursos da CPU, a concorr√™ncia √© alta e a utiliza√ß√£o de acordo com o LA √© maior que 1 (padronizada de acordo com os threads da CPU).  Tudo fica dentro de todas as VMs.  <i>O roubo</i> enviado pelo hypervisor tamb√©m cresce.  Voc√™ precisa redistribuir a carga ou desativar algo.  No geral, tudo isso √© l√≥gico e direto. <br><br>  Paravirtualiza√ß√£o vs inst√¢ncias √∫nicas.  H√° apenas uma VM em um hypervisor.  A VM consome uma pequena parte dela, mas fornece alta carga de entrada / sa√≠da, por exemplo, para uma unidade.  Inesperadamente, um pequeno <i>roubo</i> de menos de 10% aparece (como mostram alguns dos testes que realizamos). <br><br>  Este √© um caso curioso.  Aqui, o <i>roubo</i> aparece devido a bloqueios no n√≠vel dos dispositivos paravirtualizados.  Dentro da VM, um ponto de interrup√ß√£o √© criado.  Isso √© processado pelo driver e vai para o hipervisor.  Devido ao processamento do ponto de interrup√ß√£o no hypervisor, a VM v√™ isso como uma solicita√ß√£o enviada.  Est√° pronto para ser executado e aguarda a CPU, mas n√£o recebe tempo de CPU.  A VM pensa que o tempo foi roubado. <br><br>  Isso acontece quando o buffer √© enviado.  Ele vai para o espa√ßo do kernel do hypervisor e esperamos por ele.  Do ponto de vista da VM, ela deve retornar imediatamente.  Portanto, de acordo com nosso algoritmo de c√°lculo de <i>roubo</i> , esse tempo √© considerado roubado.  √â prov√°vel que outros mecanismos possam estar envolvidos nisso (por exemplo, o processamento de outras <i>chamadas do sistema</i> ), mas eles n√£o devem diferir em grau significativo. <br><br>  Agendador vs VMs altamente carregadas.  Quando uma VM sofre mais <i>roubos do</i> que as outras, isso √© conectado diretamente ao agendador.  Quanto maior a carga que um processo coloca em uma CPU, mais r√°pido o agendador a joga fora, para permitir que outros processos funcionem.  Se a VM estiver consumindo pouco, quase n√£o haver√° <i>roubo.</i>  Seu processo est√° parado e esperando, e precisa ser concedido mais tempo.  Se a VM colocar uma carga m√°xima em todos os n√∫cleos, o processo ser√° descartado com mais frequ√™ncia e a VM ter√° menos tempo. <br><br>  √â ainda pior quando os processos dentro da VM tentam obter mais CPU, porque eles n√£o podem processar os dados.  Em seguida, o sistema operacional no hipervisor fornecer√° menos tempo de CPU por causa da otimiza√ß√£o justa.  Esse processo processa bolas de neve e <i>rouba</i> ondas no c√©u, enquanto outras VMs podem nem perceber.  Quanto mais n√∫cleos existem, pior √© a infeliz VM.  Em resumo, as VMs altamente carregadas com muitos n√∫cleos sofrem mais. <br><br>  LA baixo, mas <i>roubo</i> est√° presente.  Se o AL for de cerca de 0,7 (o que significa que o hipervisor parece estar sobrecarregado), mas h√° <i>roubos</i> em algumas VMs: <br><br><ul><li>  O exemplo de paravirtualiza√ß√£o mencionado acima se aplica.  A VM pode estar recebendo m√©tricas que indicam <i>roubo</i> , enquanto o hipervisor n√£o tem problemas.  De acordo com os resultados de nossos testes, esse <i>roubo</i> n√£o costuma exceder 10% e n√£o tem um impacto significativo no desempenho do aplicativo na VM. <br></li><li>  O par√¢metro LA foi calculado incorretamente.  Mais precisamente, foi calculado corretamente em um momento espec√≠fico, mas, na m√©dia, √© mais baixo do que deveria ser por um minuto.  Por exemplo, se uma VM (um ter√ßo do hypervisor) consumir todas as CPUs por 30 segundos, o LA por um minuto ser√° 0,15.  Quatro dessas VMs, trabalhando ao mesmo tempo, resultar√£o em um valor de 0,6.  Com base no LA, voc√™ n√£o seria capaz de deduzir que, por 30 segundos para cada um deles, o <i>roubo</i> era quase 25%. <br></li><li>  Novamente, isso aconteceu por causa do agendador, que decidiu que algu√©m estava "comendo" demais e os fez esperar.  Enquanto isso, ele alternar√° contexto, processar√° pontos de interrup√ß√£o e atender√° a outros assuntos importantes do sistema.  Como resultado, algumas VMs n√£o enfrentam problemas e outras sofrem perdas significativas de desempenho. <br></li></ul><br><h2>  4. Outras distor√ß√µes </h2><br>  H√° um milh√£o de raz√µes poss√≠veis para distor√ß√£o da aloca√ß√£o justa do tempo da CPU em uma VM.  Por exemplo, hyperthreading e NUMA adicionam complexidade aos c√°lculos.  Eles complicam a escolha do n√∫cleo usado para executar um processo porque um planejador usa coeficientes;  isto √©, pesos, o que complica ainda mais os c√°lculos ao alternar contextos. <br><br>  Existem distor√ß√µes que surgem de tecnologias como o Turbo Boost ou seu oposto, o modo de economia de energia, que pode aumentar ou diminuir artificialmente a velocidade do n√∫cleo da CPU e at√© a fatia de tempo.  Ativando o Turbo Boost, diminuindo a produtividade de um thread da CPU devido a um aumento de desempenho em outro.  Nesse momento, as informa√ß√µes sobre a velocidade atual do clock da CPU n√£o s√£o enviadas para a VM, que pensa que algu√©m est√° roubando seu tempo (por exemplo, solicitou 2 GHz e obteve metade do valor). <br><br>  De fato, pode haver muitas raz√µes para distor√ß√£o.  Voc√™ pode encontrar algo totalmente diferente em qualquer sistema.  Eu recomendo come√ßar com os livros vinculados acima e obter estat√≠sticas do hypervisor usando ferramentas como perf, sysdig, systemtap e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dezenas de outras</a> . <br><br><h2>  5. Conclus√µes </h2><br><ol><li>  Alguns <i>roubos</i> podem aparecer devido √† paravirtualiza√ß√£o e isso pode ser considerado normal.  Fontes online dizem que esse valor pode ser de 5 a 10%.  Depende do aplicativo em uma VM e da carga que a VM coloca em seus dispositivos f√≠sicos.  √â importante prestar aten√ß√£o em como os aplicativos se sentem dentro de uma VM. <br></li><li>  A correla√ß√£o entre a carga no hypervisor e o <i>roubo</i> dentro de uma VM nem sempre √© certa.  Os dois c√°lculos de <i>roubo</i> podem estar errados em alguns casos e com cargas diferentes. <br></li><li>  O Agendador n√£o favorece processos que solicitam muitos recursos.  Ele tenta dar menos √†queles que pedem mais.  Grandes inst√¢ncias s√£o m√°s. <br></li><li>  Um pouco de <i>roubo tamb√©m</i> pode ser normal sem paravirtualiza√ß√£o (levando em considera√ß√£o a carga na VM, as particularidades das cargas dos vizinhos, a distribui√ß√£o da carga entre os threads e outros fatores). <br></li><li>  Se voc√™ deseja calcular o <i>roubo</i> em um sistema espec√≠fico, pesquise as v√°rias possibilidades, colete m√©tricas, analise-as minuciosamente e pense em como distribuir a carga de maneira justa.  Independentemente, pode haver desvios, que devem ser verificados usando testes ou visualizados em um depurador do kernel. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453140/">https://habr.com/ru/post/pt453140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453126/index.html">UIAppearance n√£o era t√£o simples</a></li>
<li><a href="../pt453128/index.html">Resumo de telecomunica√ß√µes: 15 materiais especializados em IPv6, IS, padr√µes e legisla√ß√£o em TI</a></li>
<li><a href="../pt453130/index.html">C√≥digos corretivos sistem√°ticos. C√≥digo de grupo linear</a></li>
<li><a href="../pt453136/index.html">API de grava√ß√£o - XML ‚Äã‚Äãquebrado (duas)</a></li>
<li><a href="../pt453138/index.html">Arte e ci√™ncia: projeto VITAE - muitas impress√µes de palmeiras em uma flor da lua</a></li>
<li><a href="../pt453146/index.html">Como tirar o m√°ximo proveito de uma confer√™ncia</a></li>
<li><a href="../pt453154/index.html">Hist√≥rico da Internet: Aprimorando a interatividade</a></li>
<li><a href="../pt453156/index.html">General Motors dar√° alma a todos os seus novos carros (shell digital)</a></li>
<li><a href="../pt453158/index.html">Como eu n√£o sabia como os processadores funcionam, escrevi um simulador de software.</a></li>
<li><a href="../pt453162/index.html">Antiguidades: ThinkPad 380E, Classe Econ√¥mica dos anos 90 e Windows 95</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>