<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏳️‍🌈 📇 👩🏿‍🤝‍👩🏾 Tetris als Drucker 🖕🏼 🐖 👨🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Tetris-Druckeralgorithmus wandelt eine vorgegebene Folge von Formen um, ordnet sie neu und senkt sie nach unten. Dabei werden mithilfe der Tetris-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetris als Drucker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br>  Der Tetris-Druckeralgorithmus wandelt eine vorgegebene Folge von Formen um, ordnet sie neu und senkt sie nach unten. Dabei werden mithilfe der Tetris-Mechanik beliebige Bitmaps generiert. <br><br><h2>  Beschreibung des Algorithmus </h2><br>  Der Algorithmus konvertiert die Pixel des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellbildes</a> zeilenweise in die Quadrate des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tetris-</a> Feldes und bewegt sich von unten nach oben.  Um ein einzelnes Quadrat zu erzeugen, setzt der Algorithmus eine Struktur zusammen, die aus einem rechteckigen Bereich besteht, der vollständig von einem Quadrat darunter unterstützt wird.  Nachdem der Zusammenbau des rechteckigen Bereichs abgeschlossen ist, werden seine Linien gelöscht, wobei ein Quadrat darunter verbleibt.  Hier sind drei Beispiele für dieses Verhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br>  Wie unten gezeigt, kann der Algorithmus auch mehrere Quadrate mit einer Struktur erzeugen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br>  Bei der Erstellung einer Reihe müssen alle auf diese Weise erstellten Quadrate auf etwas basieren.  In den oben gezeigten Bildern befinden sich die erzeugten Quadrate auf dem Boden des Spielfelds.  Wenn jedoch eine beliebige Linie Löcher enthält, kann sie nicht die Unterstützung bieten, die zum Erstellen einer Linie darüber erforderlich ist.  Der Algorithmus löst dieses Problem, indem er eine flache Plattform mit Löchern auf der Saite erstellt.  In der Animation unten besteht eine Plattform, die auf einer Linie aufgebaut ist, aus einem roten Quadrat.  Eine Plattform ist eine temporäre Struktur, die durch Einfügen der letzten Form entfernt wird. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br>  Die unten gezeigte Reihe von 5 roten Quadraten befindet sich über der Reihe von 3 roten Quadraten.  Dies wird durch den Bau einer flachen Plattform über dem Endergebnis erreicht.  Die Plattform bietet die notwendige Unterstützung, um 5 rote Quadrate zu generieren.  Am Ende wird die Plattform durch Einfügen der letzten Form gelöscht und die neue Linie wird eingefügt.  Beachten Sie, dass die Plattform nicht benötigt wird, wenn der Algorithmus Linien in umgekehrter Reihenfolge erzeugen muss (eine Linie aus 3 roten Quadraten über einer Linie aus 5 roten Quadraten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2>  Ein Quadrat Muster </h2><br>  Als Referenz gebe ich die Namen von 7 Tetramino (Spielfiguren) an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br>  Die in diesem Artikel vorgestellte Version von Tetris Printer Algorithm wurde speziell für das Rendern von Sprites aus alten Videospielen entwickelt.  Diese Spiele packten Grafiken in 8 × 8 Kacheln, und jedem Pixel wurden 2 Bytes zugewiesen.  Daher enthielten Sprites normalerweise nur 3 Farben plus transparente Bereiche und hatten meist eine Größe von 16 × 16 oder 16 × 32 Pixel. <br><br>  Die Animation unten zeigt alle Muster, die zum Erstellen einzelner Quadrate verwendet werden.  Jedes Muster verwendet austauschbare Tetramino J, T und L, wodurch am unteren Rand ein einzelnes Quadrat entsteht.  Der Algorithmus weist dieses Tetramino einer der drei im Sprite vorhandenen Farben zu.  Dem Rest des Tetraminos werden beliebige Farben zugewiesen.  Während des gesamten Spiels bleiben alle Farben konstant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br>  Aufgrund der Form der drei Tetramino ist es unmöglich, aus allen drei Farben in den ersten beiden und letzten beiden Spalten ein Quadrat zu erstellen.  Daher beträgt die Mindestbreite des Spielfelds zum Rendern eines Sprites mit einer Breite von 16 Pixeln 2 + 16 + 2 = 20 Quadrate.  Es stellte sich jedoch heraus, dass 20 zu wenig ist. <br><br>  Wie unten gezeigt, kann der Bereich über dem einzelnen unteren Quadrat nicht aus nur einer Linie bestehen, da die einzigen Figuren, die darin passen (Tetramino I), keine Unterstützung haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br>  Bei zwei Linien kann das gesamte Spielfeld nur mit Tetramino S und Z gestreckt werden. In diesem Fall bleiben jedoch Löcher in der obersten Linie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br>  Die Mindestanzahl der Zeilen, die über dem unteren Quadrat erforderlich sind, beträgt 3, und wie oben mehrfach gezeigt, existieren solche Muster.  20 Quadrate sind die Mindestbreite, die erforderlich ist, um ein Sprite mit einer Breite von 16 Pixeln zu platzieren.  Aber 20 × 3 + 1 = 61, und diese Zahl ist nicht teilbar durch 4, was bedeutet, dass sie nicht aus Tetramino aufgebaut werden kann.  Eine Breite von 21 ergibt jedoch 21 × 3 + 1 = 64, und es kann aus 16 Tetramino gebaut werden.  Diese Breite ermöglicht es dem Algorithmus, Sprites mit einer Breite von bis zu 17 Pixeln zu rendern. <br><br>  Das Spielfeld des ursprünglichen Tetris hat eine Größe von 10 × 20 Quadraten (Verhältnis 1: 2).  In dieser Version des Algorithmus bleibt dieses Verhältnis erhalten - das Spielfeld hat eine Größe von 21 × 42 Quadraten. <br><br>  Da Tetramino J, T und L bei der Erstellung eines Quadrats austauschbar sind und 3 Quadrate dieses Tetramino bei der Erstellung einer Linie darüber beteiligt sind, gibt es 21 - 3 = 18 Muster für die Erstellung eines einzelnen Quadrats.  Aufgrund der Spiegelsymmetrie gibt es jedoch nur 9 Zeilen. Für die meisten dieser 9 Zeilen gibt es 3 Zeilen. Eine gründliche Computeruntersuchung ergab jedoch, dass die beiden Muster mehr benötigen.  Die nächste mögliche Option sind 7 Zeilen, da 21 × 7 + 1 = 148, was 37 Tetraminos erfordert.  Wie in den folgenden Bildern gezeigt, existieren solche Muster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2>  Mehrere quadratische Muster </h2><br>  Die Muster zum Erstellen mehrerer Quadrate sind auf die gleichen drei Farben beschränkt, die durch die Muster eines einzelnen Quadrats erstellt werden.  Die resultierenden Quadrate werden aus Tetramino J, T und L erzeugt, von denen jedes 3 Quadrate in einer Linie oberhalb der Erzeugungslinie belegt.  Die maximale Anzahl von Quadraten, die möglicherweise mit einem einzelnen Muster erstellt werden können, beträgt 21/3 = 7. Bei Sprites mit einer Breite von 16 Pixeln kann das Tetramino ganz rechts jedoch kein Quadrat erstellen.  Selbst bei Sprites mit einer Breite von 17 Pixeln kann ein Quadrat mit nur einer Farbe erstellt werden.  Daher wird das Muster des Erzeugens aus 7 Quadraten selten verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br>  Die Anzahl der Muster zum Erstellen einer beliebigen Anzahl von Quadraten kann unter Verwendung der Kombinatorik von Aufzählungen bestimmt werden.  Betrachten Sie das Muster unten, das eine Reihe über einer Reihe von drei Quadraten darstellt.  Jeder Block von drei benachbarten weißen Quadraten bezeichnet einen Teil von Tetramino;  erstellte Quadrate werden nicht angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br>  Drei Tetramino erzeugen 4 Hohlräume.  Es gibt 21 - 3 × 3 = 12 dunkle Quadrate, die beliebig in diese Hohlräume eingefügt werden können, um ein bestimmtes Muster zu bilden.  Die Anzahl der Möglichkeiten zur Verteilung dieser dunklen Quadrate kann berechnet werden, indem sie auf eine Linie gesetzt werden, in der einzelne weiße Quadrate als Teiler behandelt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br>  Die Aufgabe war also darauf beschränkt, den Wert des Koeffizienten des Polynoms zu berechnen.  Wenn Sie sich diese weißen Quadrate ansehen, können Sie verstehen, dass dies eine Frage der Anzahl der Möglichkeiten ist, 3 von 15 zu wählen. <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455. <br><br>  Im allgemeinen Fall ist für <i>n</i> gleich <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  .  Aber aufgrund der Spiegelsymmetrie sind sie tatsächlich halb so groß.  Wenn die Menge ungerade ist, dann dividieren wir durch zwei und runden auf die nächste ganze Zahl, um ein perfekt symmetrisches Muster darin aufzunehmen, das in dieser Menge existieren sollte, wie zum Beispiel unten für den Fall mit 455 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br>  Wenn wir diese Formel auf 7 Tetramino anwenden, bestätigen wir das Offensichtliche: Es gibt nur ein Muster zum Erstellen von 7 Quadraten. <br><br>  Das Muster zum Erstellen von 6 Quadraten kann auf zwei Arten erstellt werden: zwei gefüllte Linien (2 × 21 + 6 = 48) und sechs gefüllte Linien (6 × 21 + 6 = 132), für die 12 und 33 Tetramino erforderlich sind.  Die obige Formel zeigt, dass es 84 Muster zum Erstellen von 6 Quadraten gibt, von denen jedoch nur 35 aus 2 vollständigen Linien erstellt werden können.  49 Muster erfordern 6 Zeilen.  Die Zahlen sind aufgrund der unten gezeigten symmetrischen Muster ungerade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br>  Es ist auch erwähnenswert, dass hier 2 Linien möglich sind, da im Gegensatz zu dem Muster zum Erzeugen eines Quadrats, das Tetramino S und Z erfordert, 6 Figuren in diesen Mustern verwendet werden. <br><br>  Die nachstehende Tabelle zeigt die Anzahl der Quadrate, die durch die einzelnen Mustertypen erstellt wurden, die Anzahl der vollständigen Linien, die Anzahl der verwendeten Tetramino und die Anzahl der Muster. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Quadrate erstellt </th><th>  Volle Zeilen </th><th>  Tetramino </th><th>  Muster </th></tr><tr><td>  1 </td><td>  7 und 3 </td><td>  37 und 16 </td><td>  19 (4 und 15) </td></tr><tr><td>  2 </td><td>  6 </td><td>  32 </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 </td><td>  4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 </td><td>  2 und 6 </td><td>  12 und 33 </td><td>  84 (35 und 49) </td></tr><tr><td>  7 </td><td>  1 </td><td>  7 </td><td>  1 </td></tr></tbody></table></div><br>  Beispiele für Muster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2>  Plattformen </h2><br>  Vor dem Erstellen einer Linie untersucht der Algorithmus die Linie darunter.  Wenn die untere Reihe nicht alle darüber liegenden Quadrate unterstützen kann, ist eine temporäre Plattform erforderlich.  Wenn die Plattform entfernt wird, fällt eine neue Linie ab, und aufgrund der Schwerkraft, die im ursprünglichen Tetris implementiert ist, bleiben einige Quadrate in der Luft hängen. <br><br>  Die folgende Abbildung zeigt 10 Plattformmuster.  Der Bau der Plattform beginnt mit dem Absenken des Tetramino T auf eines der Quadrate der zuletzt erzeugten Linie.  Die verbleibenden Tetraminos basieren auf diesem ersten T. Wenn die zuvor erzeugte Linie mindestens 1 Quadrat enthält, wie z. B. das rote Quadrat in der Abbildung unten, können Sie darüber eine flache Plattform erstellen, um die nächste Linie zu erzeugen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br>  Während des Baus der Plattform wird die unterste Zeile vervollständigt und gelöscht, wobei drei Zeilen darüber verbleiben.  Das letzte Tetramino J oder L, das diese Zeilen löscht, wird erst eingefügt, wenn die Erstellungsmuster die nächste Sprite-Zeile oben auf der Plattform erzeugen.  Diese letzte Zahl verhindert die Erstellung von Quadraten in der ersten und letzten beiden Zeilen.  Wie oben erwähnt, sind die Muster zum Erzeugen von Quadraten aufgrund der Geometrie der Tetramino J, T und L, die in diesem Prozess verwendet werden, auf 17 innere Spalten beschränkt. <br><br>  Darüber hinaus gibt es oben nur 10 von 19 möglichen Möglichkeiten, Plattformen auf Tetramino T zu bauen. <br><br><h2>  Gepackte Matrizen </h2><br>  Wie oben erwähnt, werden bei einer Teilmenge der 6 Quadrate nur zwei Zeilen gelöscht.  Alle anderen Muster erfordern 6 Zeilen.  Um zu verstehen, warum dies der Fall ist, betrachten Sie das folgende Muster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br>  Diese Tetramino sind austauschbar mit Tetramino J und L, und jedes von ihnen fügt der gemeinsamen Reihe 3 benachbarte Quadrate hinzu.  Die auszufüllenden Zeilen werden durch die unten gezeigte Matrix dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br>  Jetzt packt das Ganze den leeren Raum mit Tetramino.  Links beginnend besteht die einzige Möglichkeit darin, die Tetramino I-Sequenz zu verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br>  Der verbleibende Platz kann nur mit J und O oder I und L gefüllt werden. Beide Optionen werden unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br>  Leider werden Tetramino O und L in den oben gezeigten Matrizen nicht unterstützt.  Dieses 6-Quadrate-Muster erfordert eine größere Matrix. <br><br>  Ein ähnliches Problem tritt bei zwei Mustern zum Erzeugen eines Quadrats auf.  Betrachten Sie die folgende Matrix: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br>  Die einzige Möglichkeit, die untere Zeile rechts auszufüllen, besteht darin, die Sequenz Z zu verketten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br>  Ebenso ist der einzige Weg, um 3 leere Felder in der unteren linken Ecke zu bekommen, Tetramino S. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br>  In der mittleren Zeile befindet sich ein leeres Quadrat zwischen S und Z. Sie können es nur mit Tetramino J, T oder L füllen, wie in den folgenden Abbildungen gezeigt. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br>  Durch Einfügen einer dieser Formen wird die Leerstelle geteilt.  Der leere Bereich auf der linken Seite enthält 5, 6 bzw. 7 Lücken.  Da keiner dieser Werte durch 4 teilbar ist, ist eine Fortsetzung nicht möglich.  Für dieses einzelne quadratische Muster ist eine größere Matrix erforderlich. <br><br>  Dasselbe gilt für ein anderes Muster zum Erstellen eines Quadrats, das in der folgenden Matrix dargestellt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br>  Nachdem Tetramino S und Z verwendet wurden, um den größten Teil der unteren Zeile auszufüllen, befindet sich in der mittleren Zeile ein Leerzeichen zwischen ihnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br>  Wie in den folgenden Abbildungen gezeigt, unterteilt der Locheinsatz den leeren Bereich und der leere Bereich auf der linken Seite enthält 9, 10 oder 11 Quadrate.  Keine der Zahlen ist durch 4 teilbar. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br>  Packungsmatrizen sind jedoch nicht die einzige Möglichkeit, ein Quadratmuster zu erzeugen.  Schauen Sie sich zum Beispiel den 4-Quadrate-Ersteller unten an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br>  Das Folgende ist ein Versuch, das Muster als Satz von verpackten Tetraminos zu rendern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br>  Das letzte L wird übersprungen, weil der Platz dafür erst nach der Vervollständigung und Entfernung der dritten Reihe gebildet wird. <br><br>  Nach einer gründlichen Suche wurde jedoch festgestellt, dass diese Technik die oben genannten Ein-Quadrat-Muster nicht mit der Fähigkeit ausstattet, mit nur 3 Linien zu arbeiten.  Außerdem ist es nicht möglich, neue Muster von 6 Quadraten in zwei Zeilen zu implementieren.  Die verbleibenden Muster müssen nicht außerhalb der gepackten Matrizen gesucht werden, da sie bereits die geringstmögliche Menge an Tetramino verwenden.  Und wenn wir uns auf gepackte Matrizen beschränken, werden wir alle notwendigen Muster viel schneller finden. <br><br><h2>  Mustersuche </h2><br>  Um die Datenausgabe zu vereinfachen, ist der Tetris-Druckeralgorithmus darauf beschränkt, Tetramino am oberen Mittelpunkt des Spielfelds zu erstellen, es zu drehen, horizontal zu bewegen und abzusenken.  Er muss die Figur niemals horizontal bewegen, nachdem er eine Strecke zurückgelegt hat.  Diese Einschränkung reduziert den Suchraum erheblich, da es nicht möglich ist, Lücken unter den der Matrix hinzugefügten Zahlen zu bilden.  Schauen wir uns als Beispiel die folgende 3-Quadrate-Matrix an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br>  Wenn wir J in die Mitte der Matrix werfen, wie oben gezeigt, erhalten wir eine Lücke von 2 leeren Quadraten, die nicht mit nachfolgenden Zahlen gefüllt werden können.  Daher folgt die Suche diesem Pfad nicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br>  Da abgedeckte Lücken nicht zulässig sind, kann jede Spalte in der Matrix als Stapel gefüllter Quadrate betrachtet werden, und die Höhe dieser Stapel beschreibt den Inhalt der gesamten Matrix vollständig.  Unabhängig von der Anzahl der Zeilen reicht ein eindimensionales ganzzahliges Array mit 21 Elementen aus, um eine zweidimensionale Matrix zu beschreiben. <br><br>  Wenn eine Figur in die Matrix fällt, nehmen die Stapelhöhen der entsprechenden Spalten zu.  Um diesen Prozess zu beschleunigen, werden alle Tetramine im Voraus analysiert.  Es gibt 19 Tetramino-Kurven, und die Suche betrachtet jede von ihnen als eine einzigartige Figur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br>  Tetramino J in der oberen linken Ecke des Bildes belegt 3 Spalten.  Beim Absenken auf die Matrix erhöhen sich die Höhen von 3 benachbarten Stapeln um jeweils 1, 1 und 2 Quadrate.  Bevor die Figur abgesenkt werden kann, muss das untere Profil der Figur dem oberen Profil der jeweiligen Stapel entsprechen.  Wenn dieses J auf dem Boden des Spielfeldes gelegen hätte, hätte es unter jeder dieser Spalten Lücken von 1, 1 und 0 leeren Feldern geben müssen.  Da Abstände verboten sind, müssen die relativen Höhen von 3 Stapeln vollständig mit dem Muster übereinstimmen. <br><br>  Eine weitere Folge des Fehlens von Lücken war, dass die Zeilen von unten nach oben gefüllt werden, wenn die Figuren in die Matrix fallen.  Es ist nicht möglich, eine Zeile in der Mitte einer Matrix zu füllen, bevor oder gleichzeitig nicht alle Zeilen darunter zu vervollständigen.  Während des Füllens der Matrix bewegt sich ihre untere Grenze tatsächlich nach oben.  Folglich kann ein Matrixspaltenstapel nur dann Unterstützung bieten, wenn seine Höhe abzüglich der Anzahl der vervollständigten Zeilen größer als 0 ist. Wenn der Matrix eine Form hinzugefügt wird, muss mindestens eine der entsprechenden Spalten Unterstützung bieten. <br><br>  Die Suche speichert ein zweites eindimensionales Array, das die Anzahl der ausgefüllten Quadrate in jeder Zeile enthält.  Das obige J enthält in den entsprechenden Zeilen 3 und 1 ein Quadrat.  Wenn Sie es in die Matrix einfügen, werden diese Werte zu den entsprechenden Elementen des Arrays hinzugefügt.  Die Anzahl der ausgefüllten Zeilen entspricht der Anzahl der Elemente mit dem Wert 21. <br><br>  Wie im vorherigen Abschnitt angegeben, sollten, wenn die hinzugefügte Figur die Matrix teilt, die Größen der resultierenden Bereiche durch 4 geteilt werden. In der folgenden Abbildung werden durch Hinzufügen von I beispielsweise 2 Bereiche erstellt, von denen jeder 46 leere Quadrate enthält.  Da 46 nicht durch 4 teilbar ist, gibt es keine Möglichkeit mehr, den Rest der Matrix auszufüllen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br>  Die Trennung wird angezeigt, wenn die Höhe des Stapels der Höhe der Matrix entspricht.  Nach dem Einfügen der Figur durch Erhöhen der Höhen der jeweiligen Stapel können die Abmessungen aller unterteilten Bereiche des leeren Raums bestimmt werden, indem die Anordnung der Höhen abgetastet wird und der in jedem Stapel verbleibende Raum addiert wird.  Diese Nummer wird überprüft und zurückgesetzt, wenn ein Split erkannt wird. <br><br>  Die zur Erzeugung aller Muster verwendete Suche verwendet eine zufällige inkrementelle Konstruktion, einen Rückverfolgungsalgorithmus, der systematisch alle Kombinationen in zufälliger Reihenfolge überprüft.  Die inkrementelle Konstruktion einer Lösung durch zufälliges Einfügen von Formen lässt sie wie einen Kristall wachsen.  Zufälligkeit stellt eine Unregelmäßigkeit mit gebrochenen Flächen bereit, die als Grundlage für nachfolgende hinzugefügte Formen dienen.  Der größte Teil der Matrix wird sehr schnell zufällig gepackt, und wenn der leere Raum knapp wird, kommt das Backtracking ins Spiel. <br><br>  Vor dem Durchführen der Suche werden zufällige Permutationen von 371 Möglichkeiten zum Hinzufügen einer Figur zur Matrix durchgeführt.  Der Pseudocode der Suchfunktion wird unten angezeigt. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br>  Die ursprüngliche Matrix, die an die Suchfunktion übergeben wurde, ist leer, mit Ausnahme der untersten Reihe mit Blöcken aus 3 benachbarten Quadraten.  Es wird zusammen mit der Anzahl der verbleibenden Zahlen übertragen, die hinzugefügt werden müssen.  Wenn der <code>remaining</code> Wert 0 ist, enthält die Matrix die Lösung und die Funktion kehrt zurück.  Jeder rekursive Aufruf erhöht die globale Anzahl der <code>attempts</code> .  Wenn der Wert <code>MAX_ATTEMPTS</code> mit dem Wert 1000 überschritten <code>MAX_ATTEMPTS</code> , wird die Suche erneut <code>MAX_ATTEMPTS</code> . <br><br>  Die dritte <code>if</code> versucht, Tetramino S oder Z am unteren Rand der Matrix einzufügen, wenn der Platz dies zulässt.  Dies bedeutet, Situationen wie die unten gezeigte zu vermeiden, in denen der Algorithmus Zeit damit verbringt, einen Teil der Matrix zu füllen, und den Rest aufgrund mangelnder Unterstützung nicht füllen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br>  Dank der <code>if</code> schnell eine Plattform, auf der aufgebaut werden kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br>  Um zu versuchen, der Matrix eine Zahl hinzuzufügen, sind die obigen Prüfungen erforderlich.  Der Algorithmus prüft anhand der ausgefüllten Zeilen, ob die Figur unterstützt wird.  Außerdem wird geprüft, ob die Größe jedes einzelnen leeren Bereichs, der durch das Einfügen der Form erstellt wird, durch 4 geteilt wird. <br><br><h2>  Bildkonvertierung </h2><br>  Tetris Printer Algorithm konvertiert jede Zeile der Bitmap in eine Reihe von Durchläufen.  Von links nach rechts bewegt, fügt jede Passage auf "gierige" Weise Tetramino J, T und L dort ein, wo sie platziert sind.  Das folgende Bild zeigt beispielsweise eine Zeile mit 16 Pixeln einer Bitmap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br>  Das Bild unten zeigt die 5 Durchgänge, die erforderlich sind, um diese 16 Pixel abzudecken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br>  Die Folge von Formen, die der Algorithmus einzufügen versucht, wird durch die Farben der Pixel bestimmt.  Damit sich die Formen nicht überlappen, wird ein eindimensionales Array von Booleschen Werten verwendet.  Um eine Zahl einzufügen, müssen 3 Nullelemente im Array vorhanden sein.  Nach dem erfolgreichen Einfügen von Abbildung 3 nehmen die entsprechenden Array-Elemente den Wert 1 an. <br><br>  Um vervollständigte Pixel zwischen mehreren Durchläufen zu verfolgen, wird ein zweites eindimensionales Array von Booleschen Werten verwendet.  Wenn jedes Element 1 ist, ist die Zeile abgeschlossen. <br><br>  Am Ende jedes Durchgangs durchsucht der Bildkonverter die Tabelle nach allen Mustern, um ein oder mehrere Quadrate zu erstellen.  Für die Ausgabe wird das entsprechende Muster mit den unten eingefügten Tetramino J, T und L übergeben. Der oben gezeigte erste Durchgang wird beispielsweise als das folgende Muster zum Erstellen von 5 Quadraten angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2>  Echtzeitsuche </h2><br>  Der im vorherigen Abschnitt beschriebene Bildkonverter ist extrem schnell, da er eine konstante Tabelle verwendet, die alle Muster zum Erstellen von Quadraten enthält, und diese nicht in Echtzeit durchsucht.  Bei der Echtzeitsuche können jedoch Muster verwendet werden, die nicht in der Tabelle enthalten sind, und daher wird die Menge an Tetramino, die zum Generieren des Bildes benötigt wird, erheblich reduziert.  Er verwendet die in früheren Passagen erstellten Quadrate als zusätzliche Stützen.  Wie oben erwähnt, sind für das folgende Muster zum Erstellen eines Quadrats 7 vollständige Linien erforderlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br>  Ein rotes Quadrat, das im vorherigen Abschnitt in der unteren linken Ecke des Bilds unten erstellt wurde, bietet jedoch zusätzliche Unterstützung und reduziert die Anzahl der gefüllten Linien auf 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br>  Zusätzlich kann eine Echtzeitsuche 3 benachbarte Pixel derselben Farbe durch Umdrehen von Tetramino J, T oder L erfassen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br>  Tatsächlich kann es invertiertes und invertiertes Tetramino kombinieren und eine große Anzahl von Pixeln in einem Durchgang abdecken.  Beispielsweise können die obigen 5 Durchgänge, die zum Abdecken von 16 Pixeln erforderlich sind, auf den unten gezeigten einzelnen Durchgang reduziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br>  Um dieses Muster zu erhalten, beginnt der Bildkonverter mit dem eifrigen Packen der umgedrehten Tetramino J, T und L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br>  Dann versucht er eifrig, die nicht umgedrehten Versionen hinzuzufügen, und in diesem Fall schafft er es, ein weiteres J hinzuzufügen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br>  Grundsätzlich kann in diesem Prozess auch eine vorberechnete Nachschlagetabelle verwendet werden, die jedoch aufgrund ihrer Größe in der Praxis nicht anwendbar ist. <br><br>  In diesem Beispiel werden 8 Quadrate in einer Reihe über der zu erstellenden Reihe zur unteren Reihe der leeren Matrix hinzugefügt.  Für <i>n</i> Felder auf einem 21 Felder breiten Spielfeld ist die Höhe der Matrix <i>h</i> die kleinste positive ganze Zahl, so dass <i>21h - n</i> durch 4 teilbar ist. In diesem Fall ist eine Matrix der Höhe 4 erforderlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br>  Die Echtzeitsuche funktioniert genauso wie der oben beschriebene Suchalgorithmus, weist jedoch geringfügige Verbesserungen auf.  Wie zuvor bietet der Matrixspaltenstapel nur dann Unterstützung, wenn die Spaltenhöhe abzüglich der Anzahl der vervollständigten Zeilen größer als Null ist.  Wenn die Differenz Null ist, sollte der Spaltenstapel keine Unterstützung bieten.  Wenn es in dieser Version jedoch gleich Null ist, werden die Quadrate in der erstellten Linie überprüft, die durch vorherige Durchgänge generiert wurden.  Das heißt, alle Quadrate in der Zeile unter der unteren Zeile der Matrix unterstützen leere Spalten. <br><br>  Da die Suche in Echtzeit durchgeführt wird, ist es außerdem unpraktisch, sie vollständig zu gestalten.  Wenn er nach einer bestimmten Anzahl von Versuchen keine Lösung gefunden hat, fügt er 4 weitere Zeilen oben in die Matrix ein und versucht es dann erneut.  Wenn er nach einer bestimmten Anzahl von Versuchen immer noch keine Lösung finden konnte, kehrt er in der aktuellen Passage zu der im vorherigen Abschnitt des Artikels beschriebenen Methode mit vorberechneten Suchtabellen und Bildkonvertierung zurück. <br><br><h2>  Drucken </h2><br>  Zum Drucken müssen Sie die Anweisungen befolgen, die vom Bildkonverter auf dem Tetris-Spielfeld angezeigt werden.  Der Drucker erstellt ein bestimmtes Tetramino am oberen Mittelpunkt des Spielfelds in einer Standardausrichtung.  Dann dreht der Drucker ihn, bewegt ihn horizontal und senkt ihn ab.  Dieser Vorgang wird im Video gezeigt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Quellcode </h2><br>  Der Quellcode für das Java 7-Projekt ist <a href="">hier</a> verfügbar. <br><br>  Suchalgorithmen für vorbereitete Tabellen und in Echtzeit befinden sich in den Paketen <code>search.precomputed</code> und <code>search.realtime</code> .  Sie verwenden einige gängige Klassen im Suchpaket.  Die Ergebnisse einer vorberechneten Suche werden als Folge von Textdateien im Musterpaket gespeichert.  Textdateien speichern gepackte Matrizen als ASCII-Zeichen, beginnend mit <code>A</code>  Zum Beispiel sehen die ersten 3 Matrizen in <code>emitters1.txt</code> (der Satz von Mustern zum Erstellen eines Quadrats) folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br>  Wie im Artikel wiederholt angegeben, können 3 benachbarte <code>A</code> Symbole in den obigen Matrizen durch Tetramino J, T oder L ersetzt werden. Die Symbole <code>B</code> , <code>C</code> , <code>D</code> usw. repräsentieren die Sequenz von Tetramino, die Sie erstellen müssen. <br><br>  Die <code>imageconverter.ImageConverter</code> Klasse enthält die <code>main</code> Methode, die ein einziges Befehlszeilenargument empfängt: den Namen der Image-Sprite-Datei.  Ein Bild kann nicht größer als 17 × 32 Pixel sein und nicht mehr als 3 undurchsichtige Farben enthalten.  Alle anderen Pixel müssen transparent sein. <br><br>  Interessanterweise verwendeten Entwickler in alten Videospielen häufig den Hintergrund, um zusätzliche Farben zu erhalten.  Zum Beispiel Pupillen und Mund von Bubble von Bubble bobble, Pupillen von Donkey Kong von Donkey Kong und Augenbrauen mit Miss Pakmans Maulwurf von Frau  Pac-Man ist eigentlich transparent.  Schwarz wird von einem festen Hintergrund erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br>  Der Hintergrund des Tetris-Spielfelds kann auf ähnliche Weise verwendet werden. <br><br>  <code>ImageConverter</code> Ausgabe von <code>ImageConverter</code> sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br>  Die 3 Hex-Werte in der ersten Zeile sind 3 undurchsichtige Farben, die aus der Sprite-Bilddatei extrahiert wurden.  Sie entsprechen den Farben von Tetramino J, T und L. Die Farben anderer Tetramino beeinflussen das Bild nicht.  Die verbleibenden Blöcke sind Musterpakete, die auf dem Spielfeld ausgeführt werden (für Zeichen nach <code>Z</code> und bis zu <code>a</code> siehe die <a href="">Tabelle der ASCII-Zeichen</a> ).  Die hervorgehobenen gelben Blöcke bilden die Plattform.  Der erste Block fügt die Plattform hinzu, der zweite entfernt sie. <br><br>  Die <code>printer.Printer</code> Klasse empfängt eine Textdatei in diesem Format und generiert eine Bilddatei, indem sie Tetris spielt. <br><br>  Der Druckeralgorithmus, der zum Erzeugen eines Videos verwendet wird, das der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NES-Version von Tetris</a> ähnelt, definiert jeden Tetramino-Typ in jedem Block einer Textdatei.  Dann bewegt es sich in umgekehrter Reihenfolge vom Startpunkt und der ursprünglichen Ausrichtung zum Drehwinkel und den Koordinaten des Absenkens der in der Datei angegebenen Figur.  Hinweis: Aufgrund der extrem hohen Geschwindigkeit fallender Figuren ist es in der echten NES-Version von Tetris unmöglich, Level 30 zu überschreiten.  Es wird davon ausgegangen, dass der Drucker alle seine Befehle schnell genug auf das Spielfeld überträgt.  um dies zu kompensieren. <br><br>  Verwenden Sie <code>search.precomputed.PatternSearcher</code> , um <code>search.precomputed.PatternSearcher</code> .  Es kann angepasst werden, indem die Konstanten am Anfang der Quellcodedatei geändert werden. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code> ist die Anzahl der zufälligen Permutationen von 371 Möglichkeiten, der Matrix eine Zahl hinzuzufügen.  Bei Einstellung auf <code>100000</code> dauert es einige Sekunden, um die Permutationen beim Start zu initialisieren.  Darüber hinaus benötigt ihr Speicher mehr als ein Gigabyte Speicher. <br><br>  <code>MAX_ATTEMPTS</code> steuert die Ausführungszeit der Suche.  Ein relativ kleiner Wert von <code>1000</code> ermöglicht es der Suche, zufällige Anfänge, die sich nicht gut zeigen, schnell zu verwerfen.  Um jedoch zu beweisen, dass es für eine bestimmte Matrixgröße und die Anzahl der erstellten Quadrate keine Lösung gibt, muss der gesamte Suchraum vollständig untersucht werden.  Dazu können Sie <code>MAX_ATTEMPTS</code> auf <code>Integer.MAX_VALUE</code> . <br><br>  Ähnliche Konstanten finden Sie in <code>search.realtime.RealtimeSearcher</code> , das vom Bildkonverter verwendet wird.  Wie oben erwähnt, erfordert ein großer <code>RANDOM_SETS</code> Wert eine Erhöhung des maximalen Speichers und führt zu einem längeren Start.  <code>MAX_RETRIES</code> steuert die Anzahl der Versuche, nach denen die Echtzeitsuche <code>MAX_RETRIES</code> wird und mit einer vorberechneten Tabelle zur Suche zurückkehrt. <br><br>  Beachten Sie, dass beide Suchalgorithmen 100% der CPU belegen und viele parallele Threads erstellen, deren Größe der Anzahl der verfügbaren Prozessoren entspricht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474848/">https://habr.com/ru/post/de474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474838/index.html">SIBUR Challenge 2019 - Wettbewerb für industrielle Datenanalyse</a></li>
<li><a href="../de474840/index.html">Was studieren sie im Fach Data Science an ausländischen Universitäten?</a></li>
<li><a href="../de474842/index.html">Fall: Autoservice. Entwicklung von Werbekampagnen und Implementierung von Bitrix24</a></li>
<li><a href="../de474844/index.html">Dell XPS 13 7390: Ein sehr kompakter Laptop für alle, die häufig außerhalb des Büros arbeiten</a></li>
<li><a href="../de474846/index.html">Das Programm, die Flüsse der Welt vom Müll zu befreien</a></li>
<li><a href="../de474850/index.html">Googles Quantenwette auf KI - und was es für die ganze Menschheit bedeutet</a></li>
<li><a href="../de474852/index.html">Lexikalische Umgebung und Closures in EcmaScript</a></li>
<li><a href="../de474854/index.html">E-Mails auslösen - So binden Sie Ihr Publikum ein</a></li>
<li><a href="../de474856/index.html">Strategien zur Inhaltslokalisierung</a></li>
<li><a href="../de474858/index.html">Was Sie über Red Hat OpenShift Service Mesh wissen müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>