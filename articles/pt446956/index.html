<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ä üëçüèº üê¥ √â prejudicial √† luz ou como manter a carga de uma bateria de carro üò• üï∫üèæ üëêüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuo a s√©rie de artigos sobre constru√ß√£o de bicicletas no campo do gerenciamento de circuitos de baixa tens√£o. Desta vez, falarei sobre um disposi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√â prejudicial √† luz ou como manter a carga de uma bateria de carro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446956/">  Continuo a s√©rie de artigos sobre constru√ß√£o de bicicletas no campo do gerenciamento de circuitos de baixa tens√£o.  Desta vez, falarei sobre um dispositivo que impede a descarga profunda de uma bateria de carro por v√°rios consumidores secund√°rios. <br><br><img src="https://habrastorage.org/webt/_p/pt/zv/_pptzvndfwivnln2xsqz7aae224.jpeg"><br>  <i>Uma das poss√≠veis conseq√º√™ncias de uma descarga n√£o controlada.</i> <br><a name="habracut"></a><br>  Comprar o primeiro carro ou moto √© um marco significativo na vida de todas as pessoas, especialmente de um engenheiro.  Afinal, quem mais al√©m das vantagens √≥bvias de seu novo cavalo de ferro presta aten√ß√£o imediatamente √†s suas desvantagens n√£o √≥bvias?  Quem imediatamente come√ßa a pensar em quaisquer melhorias e acr√©scimos ao padr√£o?  Obviamente, se este √© um carro do segmento superior e at√© uma marca "na moda", a princ√≠pio pode parecer que ele tem absolutamente tudo.  Mas, como mostra a pr√°tica, neste caso, o tempo refuta as primeiras impress√µes.  Se voc√™ compra um carro de classe econ√¥mica, suas m√£os come√ßam a co√ßar literalmente no primeiro dia! <br><br>  O desejo de "encher" seu carro com v√°rios dispositivos eletr√¥nicos auxiliares √© bastante natural.  No entanto, logo ap√≥s a implementa√ß√£o de todos esses planos, a vida confronta o propriet√°rio do carro com uma dura realidade.  Acontece que mesmo os dispositivos mais modernos constru√≠dos na base elementar mais recente ainda est√£o bastante ansiosos por eletricidade.  E uma bateria de carro que parece t√£o grande n√£o √© um reator nuclear e pode facilmente "sentar-se" sob o peso de todos esses consumidores aparentemente inofensivos em quest√£o de dias. <br><br>  Para n√£o avan√ßar ainda mais em situa√ß√µes abstratas e hipot√©ticas, irei direto √† minha hist√≥ria.  Depois de comprar um carro, o primeiro foi o desejo de colocar um registrador nele.  Isso foi feito no menor tempo poss√≠vel, quase completamente ditado pela velocidade de entrega do pacote no AliExpress.  √â claro que a fonte de alimenta√ß√£o regular do isqueiro era extremamente inconveniente, e o gravador rapidamente conseguiu uma conex√£o estacion√°ria √† linha mais pr√≥xima da rede de bordo por meio de um conversor de pulso de 12 / 5v.  E desde  foi, para dizer o m√≠nimo, n√£o ontem, esse conversor n√£o era nem moderno, para suas pr√≥prias necessidades, como se viu mais tarde, estava consumindo at√© 21 mA de corrente.  Agora vamos estimar quanto esse conversor poderia alimentar apenas uma bateria nova e totalmente carregada, com uma capacidade de 60 Ah.  A aritm√©tica √© extremamente simples e decepcionante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/kz/tb/ljkztbra63ol-bs6xwdpdxd4xjg.png"></div><br>  Assim, em menos de quatro meses, um conversor que n√£o esteja carregado com nada aterrar√° a bateria literalmente "a zero".  Se levarmos em conta que uma bateria que n√£o √© totalmente nova pode facilmente ficar vi√∫va e a carga ap√≥s a cidade pokatushki est√° longe de 100%, um dia chuvoso come√ßa facilmente dentro de um m√™s com um gancho. <br><br>  E isso √© tudo, repito, apenas um conversor de tens√£o.  Sim, hoje voc√™ pode comprar um conversor que leva apenas meio miliampere para suas pr√≥prias necessidades, mas eu dei este exemplo apenas para mostrar com que lentid√£o e confian√ßa a <s>√°gua afia uma pedra,</s> mesmo que insignificante, mas constantemente atuando, o consumidor consome energia do que parece ser t√£o grande bateria. <br><br>  Vamos al√©m: o gravador no modo de grava√ß√£o FHD a 30fps consome quase 300 mA da fonte + 5v, que ap√≥s a convers√£o, levando em considera√ß√£o a efici√™ncia, fornece cerca de 150 mA de corrente da rede de bordo.  Suponha que o conversor seja substitu√≠do por um conversor moderno e calculemos o tempo de descarga somente com essa corrente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/p8/fl/ufp8fldn4t5bfzpl8u8udb6fd3o.png"></div><br>  Pouco mais de duas semanas, mas na pr√°tica - dez dias.  Agora, a perspectiva de ilumina√ß√£o (e possivelmente a troca da bateria) est√° se aproximando ap√≥s as pr√≥ximas f√©rias ou viagem de neg√≥cios. <br><br>  E assim aconteceu comigo: quando sa√≠ de f√©rias curtas e for√ßadas, n√£o pensei que em uma semana mais ou menos uma fechadura central n√£o pudesse abrir a porta para mim. <br><br>  Muitos dir√£o que a culpa √© deles, que tudo deve ser desenergizado, ou pelo menos parar de gravar, e eles estar√£o certos.  Mas a vida √© vida, e a mem√≥ria n√£o √© a mesma, e quanto tempo dura a folga por doen√ßa nem sempre √© poss√≠vel saber com anteced√™ncia.  Portanto, a id√©ia de um disjuntor surgiu imediatamente. <br><br>  √â claro que existe uma op√ß√£o para ligar o gravador a partir do interruptor de igni√ß√£o, para que ele funcione apenas em movimento, mas essa op√ß√£o tamb√©m n√£o √© muito, porque  se o carro bater no estacionamento, eu gostaria de ter a chance de ver o culpado.  Al√©m disso, ap√≥s um curto per√≠odo de tempo ap√≥s a instala√ß√£o do gravador, o carro estava com poucos dispositivos, incluindo um rastreador GPS oculto, que deveria funcionar, se n√£o at√© o fim, pelo menos at√© quando "quase tudo" j√° estivesse l√°. <br><br>  Em geral, durante v√°rias semanas de reflex√£o passiva, a id√©ia de um dispositivo que deve controlar a tens√£o da rede de bordo e com base nesses dados para controlar a fonte de alimenta√ß√£o de dois grupos de consumidores: secund√°rio (gravador, soquete USB) e b√°sico (rastreador GPS e alguns o que). <br><br><h3>  Como isso p√¥de ser feito </h3><br>  Os primeiros prot√≥tipos virtuais do dispositivo foram "constru√≠dos" com base nos comparadores anal√≥gicos LM393N e conseguiram tudo o que foi originalmente planejado para ser recebido do dispositivo.  O esquema abstrato era algo assim. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/la/yb/cflaybsmn6m3e6o7mshcfb_1j20.png"></div><br>  Aqui, dois comparadores s√£o usados ‚Äã‚Äãpara alternar cargas.  Um gerador de tens√£o de refer√™ncia comum, dois divisores que determinam os limites de opera√ß√£o, comparadores de cintas, dois interruptores de energia.  A liga√ß√£o externa do dispositivo acabado √© planejada da seguinte maneira. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0m/77/ew/0m77ewzvozy52h6zr-fg7uaivg0.png"></div><br>  A chave prim√°ria permanece ativada por mais tempo que a secund√°ria, portanto, o pr√≥prio conversor abaixador √© alimentado por ela.  As cargas prim√°rias s√£o conectadas diretamente ao conversor.  O interruptor secund√°rio comuta as cargas secund√°rias j√° no circuito + 5v na sa√≠da do inversor. <br><br><h3>  O que saiu no final </h3><br>  Parece ser tudo o que √© necess√°rio, mas, como costuma acontecer, com o pensamento dos detalhes, surgiram id√©ias de implementa√ß√µes alternativas.  Em primeiro lugar, o circuito anal√≥gico continha uma montanha decente de elementos discretos que fornecem modos de opera√ß√£o do comparador e, em segundo lugar, os limites de trip devem ser definidos usando resistores de compensa√ß√£o, o que complica a configura√ß√£o e cria a probabilidade de "fugir" dos solavancos e do tempo.  Portanto, no final, optou-se por uma implementa√ß√£o digital, que acabou sendo muito mais simples, tanto esquematicamente quanto em configura√ß√£o, ao mesmo tempo em que abriu enormes oportunidades para melhorar o algoritmo de controle e, mais importante, nesse contexto, tornou-se uma ordem de magnitude mais econ√¥mica em termos de consumo atual. <br><br>  O controlador ATtiny13A simplesmente solicitou o cora√ß√£o do dispositivo, que, al√©m da facilidade de uso e baixo custo, ainda est√° dispon√≠vel em uma caixa DIP de tubo quente e quente para oldfag.  Inicialmente, os recursos de um controlador t√£o pequeno pareciam redundantes em todas as frentes, desde o n√∫mero de entradas / sa√≠das at√© a quantidade de programa e RAM, no entanto, como voc√™ sabe, o apetite vem com uma refei√ß√£o.  Como resultado, olhando para o futuro, direi que a vers√£o final do caso acabou sendo todas as conclus√µes do microcircuito, e a mem√≥ria do software livre n√£o deixou mais do que duas d√∫zias de bytes. <br><br>  Para medir a tens√£o da rede de bordo, o microcontrolador exigiu apenas uma entrada, que est√° vinculada ao ADC.  Mais duas sa√≠das l√≥gicas foram gerenciar os consumidores.  Antes de tudo, ap√≥s a transi√ß√£o mental final para o "digital", havia o desejo de adaptar dois GPIOs gratuitos aos neg√≥cios, e a decis√£o n√£o demorou a chegar.  Quando, mais uma vez, no frio, o motor de partida ligou o motor com uma l√°grima mal oculta, a presen√ßa de um sensor de temperatura no circuito e no algoritmo parecia muito √∫til.  Como resultado, o segundo ADC foi usado para medir a temperatura.  E, para que o termistor consuma corrente somente quando necess√°rio, foi decidido aliment√°-lo a partir da √∫ltima sa√≠da l√≥gica restante. <br><br>  Como resultado, o diagrama do dispositivo adquiriu uma forma final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ct/dt/jhctdt_pol1pk6xum1wwn_n7jzo.png"></div><br>  Aqui vemos o m√≠nimo de detalhes e, entre eles, nada est√° sujeito a nenhum tipo de "distor√ß√£o".  Vamos examinar brevemente os pontos principais. <br><br>  Para a fonte de alimenta√ß√£o, o controlador precisa de uma tens√£o est√°vel de 1,8 a 5,5 V, o que significa que deve haver um estabilizador no circuito que diminua a tens√£o da rede de bordo para o n√≠vel necess√°rio.  Do ponto de vista da economia de energia, pode parecer que existe um local para um conversor de redu√ß√£o de pulso exclusivamente, mas isso √© apenas √† primeira vista.  O fato √© que o ATtiny13A, mesmo no modo de opera√ß√£o com maior consumo de energia (frequ√™ncia 8 MHz, execu√ß√£o de c√≥digo ativo), consome n√£o mais que 6 mA.  Nesse esquema, o controlador 99% do tempo est√° no modo de sono profundo e tamb√©m opera a uma frequ√™ncia de 1,2 MHz, resultando em um consumo m√©dio de aproximadamente menos de 15 ¬µA.  Al√©m disso, aproximadamente 80 ¬µA √†s correntes de base dos transistores de controle (se as duas cargas estiverem ativadas).  Bem, por uma pequena fra√ß√£o de segundo, a energia do termistor √© ativada, o que adiciona cerca de 25 microamperes √† corrente m√©dia.  E aqui est√° a resposta para a pergunta "vale a pena carregar um conversor de pulsos por uma carga com um consumo n√£o superior a 120 ¬µA?"  N√£o parece t√£o simples.  E se considerarmos que estamos lidando com medi√ß√µes anal√≥gicas, definitivamente n√£o vale a pena.  Portanto, o estabilizador linear LP2950 foi usado, um an√°logo funcional do popular 78L05, mas muito mais econ√¥mico.  Este conversor pode fornecer at√© 100 mA de corrente na sa√≠da, enquanto consome n√£o mais que 75 ¬µA para o ente querido. <br><br>  O divisor de tens√£o da rede de bordo, protegido por um diodo zener e um capacitor, permite medir tens√µes de at√© 15 V. <br><br><blockquote>  Sei que agora uma onda de cr√≠ticas me impressionar√° por essa decis√£o, mas seremos objetivos.  Em primeiro lugar, n√£o estou desenvolvendo um sat√©lite e, em segundo lugar, n√£o existe um fator √∫nico que leve ao desastre.  A resist√™ncia do ombro √© alta, o diodo zener √© capaz de desviar muito mais corrente do que aquela que pode fluir atrav√©s do divisor, mesmo no cen√°rio mais pessimista.  Dos pulsos de alta frequ√™ncia, quando o diodo zener n√£o tem velocidade suficiente, o capacitor C2 protege (com um resistor R7, ele cria um filtro passa-baixo com uma frequ√™ncia de corte de apenas 7 Hz).  D1 e R6, em certa medida, asseguram que o esquema n√£o caia.  E n√£o se deve esquecer a linearidade, qualquer m√©todo de isolamento galv√¢nico em tal local tornar√° o c√°lculo te√≥rico dos valores completamente irrealista, teremos que calibrar pelo menos o prot√≥tipo, mas n√£o precisamos dele. </blockquote><br>  A resist√™ncia de sa√≠da do divisor √© dez vezes maior que os 10 kOhm recomendados para a fonte de sinal ADC, mas, gra√ßas ao capacitor C2, n√£o h√° problemas de medi√ß√£o. <br><br><blockquote>  Em geral, a imped√¢ncia de entrada dos circuitos ADC dos controladores AVR de acordo com a folha de dados √© declarada em pelo menos 100 megaegohms.  No entanto, a mesma folha de dados recomenda o uso de fontes com resist√™ncia interna de at√© 10 kOhm.  Porque  O ponto √© o princ√≠pio de opera√ß√£o deste pr√≥prio ADC.  O conversor opera com o princ√≠pio da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aproxima√ß√£o sequencial</a> e seu circuito de entrada √© um filtro passa-baixo de um resistor e capacitor.  A obten√ß√£o de uma amostra de 10 bits √© iterativa e √© necess√°rio que o capacitor seja carregado com toda a tens√£o medida durante todo o tempo de medi√ß√£o.  Se a imped√¢ncia de sa√≠da da fonte for muito grande, o capacitor continuar√° sendo carregado diretamente durante o processo de convers√£o e o resultado ser√° impreciso.  No nosso caso, a capacit√¢ncia C2 √© mais de sete mil vezes a capacidade do filtro ADC, o que significa que quando a carga √© redistribu√≠da entre esses capacitores quando eles s√£o ligados no momento da medi√ß√£o, a tens√£o de entrada diminui em n√£o mais que 1/7000, o que √© sete vezes menor que a precis√£o m√°xima de um ADC de 10 bits.  √â verdade que voc√™ precisa ter em mente que esse truque funciona apenas para medi√ß√µes √∫nicas com pausas significativas entre elas; portanto, n√£o deve "melhorar" o programa de controle adicionando um ciclo a ele para v√°rias medi√ß√µes consecutivas com a m√©dia do resultado. </blockquote><br>  O divisor com um termistor devido √† presen√ßa de uma fonte de energia controlada √© constru√≠do usando as classifica√ß√µes recomendadas.  O NTCLE100E3 √© usado como sensor, mas n√£o h√° restri√ß√µes, voc√™ pode usar qualquer termistor com aproximadamente a mesma classifica√ß√£o, o principal √© fazer corre√ß√µes correspondentes √† sua caracter√≠stica nas constantes do c√≥digo fonte, para que a tens√£o do divisor seja convertida no valor correto de temperatura. <br><br>  Como teclas de controle, MOSFETs de canal P de qualquer tipo s√£o usados ‚Äã‚Äãcom uma resist√™ncia de canal aberto aceit√°vel e uma tens√£o m√°xima de fonte de dreno de pelo menos 30 volts.  O circuito acima usa diferentes transistores.  Isso √© feito porque eles precisam alternar tens√µes diferentes e o tipo de cada uma delas foi selecionado para condi√ß√µes de trabalho espec√≠ficas.  O transistor superior deve ter mais alta voltagem e o menor, se poss√≠vel, ter uma resist√™ncia m√≠nima de canal aberto.  Mas, repito, essa decis√£o √© ditada pelo circuito de comuta√ß√£o do dispositivo (veja acima), com outra inclus√£o os requisitos para o transistor inferior podem ser diferentes. <br><br>  Para controlar os interruptores de energia, √© usado um par de transistores bipolares id√™nticos.  A princ√≠pio, pode parecer que esses transistores sejam sup√©rfluos, mas aqui n√£o √© t√£o simples.  Os transistores de efeito de campo com uma porta isolada come√ßam a abrir n√£o a partir de qualquer voltagem da polaridade necess√°ria na porta, mas somente ap√≥s atingir um certo n√≠vel de limite, que aparece nas folhas de dados sob o nome "tens√£o limite de porta a fonte" e geralmente √© igual a 2..4 V. Agora vamos apenas conte.  O circuito de sa√≠da do controlador pode formar dois n√≠veis l√≥gicos: "0" l√≥gico com tens√£o tendendo a zero;  e ‚Äú1‚Äù l√≥gico com tens√£o tendendo a fornecer.  Quando alimentados por 5 volts, ser√£o tens√µes de cerca de 0 e 5 V, respectivamente.  Como resultado, ao alternar uma fonte de 12 volts, um ‚Äú0‚Äù l√≥gico no port√£o criar√° uma diferen√ßa de tens√£o no port√£o da fonte 12 - 0 = 12 volts, o transistor de pot√™ncia est√° aberto.  Tudo parece estar normal, mas o l√≥gico "1" com sua voltagem de 5 V criar√° uma voltagem entre 12 - 5 = 7 volts entre a fonte e a porta, e o transistor de energia ainda permanecer√° aberto.  Assim, o sinal de controle de cinco volts n√£o pode controlar a tecla, que alterna a tens√£o acima de 7..9 volts.  Portanto, os transistores bipolares de controle n√£o funcionam tanto com teclas de sinal quanto com amplificadores que aumentam a tens√£o de controle de 5 volts para a tens√£o da rede de bordo. <br><br>  O resistor no circuito base de cada um dos transistores de controle limita simplesmente a corrente das sa√≠das do controlador a um n√≠vel suficiente para control√°-lo.  Suas classifica√ß√µes podem ser reduzidas duas a tr√™s vezes, sem consequ√™ncias para a opera√ß√£o do circuito. <br><br><blockquote>  √â f√°cil ver que os transistores de controle n√£o estavam no circuito anal√≥gico baseado no LM393N.  O fato √© que o est√°gio de sa√≠da do comparador selecionado √© constru√≠do de acordo com o circuito coletor aberto, ou seja, sua sa√≠da √© simplesmente a sa√≠da do coletor de transistor terminal.  Esse princ√≠pio de constru√ß√£o exige que pe√ßas adicionais sejam penduradas no chip para criar a carga do est√°gio de sa√≠da, mas, por outro lado, torna o chip muito flex√≠vel.  Um coletor aberto permite que o comparador controle qualquer fonte de corrente aceit√°vel, e n√£o apenas compat√≠vel com a que fornece energia ao pr√≥prio comparador. </blockquote><br>  Devo dizer que limitar a tens√£o de limiar de um MOSFET de pot√™ncia funciona n√£o apenas para altas tens√µes, como mencionado acima, mas tamb√©m para baixas.  Afinal, se a tens√£o m√≠nima de abertura do transistor for, digamos, 4 volts, ao trocar a fonte de 3,3 V, mesmo conectar a porta ao terra n√£o criar√° a diferen√ßa de tens√£o desejada entre a fonte e a porta e o transistor permanecer√° fechado.  Portanto, 5 volts √©, talvez, a tens√£o m√≠nima que pode ser comutada com seguran√ßa pelos transistores selecionados. <br><br><h3>  Personaliza√ß√£o </h3><br>  A configura√ß√£o de um dispositivo √© uma conversa separada.  Por um lado, n√£o h√° um √∫nico elemento de ajuste no circuito, mas, por outro lado, estamos lidando com medi√ß√µes de tens√µes com uma precis√£o n√£o inferior a 0,1 V. Como conectar tudo isso?  Existem duas maneiras.  O primeiro √© usar os resistores R6, R7 e R8 com uma toler√¢ncia de pelo menos 1% (ou melhor, 0,1%).  O segundo envolve o uso de resistores convencionais com a medi√ß√£o de suas resist√™ncias reais e a corre√ß√£o de coeficientes no c√≥digo fonte do programa. <br><br>  O primeiro m√©todo √© bom para a produ√ß√£o em massa, mas √© muito mais atraente para n√≥s n√£o nos preocuparmos com a busca pelos valores de alta precis√£o necess√°rios, ent√£o vamos pelo segundo caminho.  A resist√™ncia pode ser medida com um mult√≠metro comum, sua precis√£o aqui √© suficiente.  Outro objeto de medi√ß√£o ser√° a tens√£o do estabilizador que alimenta o circuito.  O ADC do controlador pode funcionar em modos diferentes, mas por v√°rias raz√µes, √© mais conveniente usarmos aquele em que o resultado da convers√£o digital seja contado em rela√ß√£o √† tens√£o de alimenta√ß√£o.  √â por isso que √© importante conhec√™-lo com a maior precis√£o poss√≠vel. <br><br>  O c√°lculo √© extremamente simples e consiste em calcular o coeficiente de divis√£o do divisor resistivo e a propor√ß√£o da convers√£o do resultado em LSB durante a convers√£o anal√≥gica para digital. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s-/-q/vf/s--qvfm_z0imo_xg5r7tnskhze0.png"></div><br>  Ux √© a tens√£o de entrada do divisor; <br>  Ru √© a resist√™ncia do bra√ßo do divisor (ao qual Ux √© fornecido); <br>  Rd √© a resist√™ncia do bra√ßo inferior do divisor (que est√° conectado ao ch√£o); <br>  Uref - tens√£o de refer√™ncia do ADC (ou seja, tens√£o de alimenta√ß√£o do controlador); <br>  1024 - o n√∫mero de valores discretos na sa√≠da de um ADC de 10 bits; <br>  LSB √© o valor num√©rico obtido pelo programa do ADC. <br><br>  Vamos come√ßar com o divisor de tens√£o R6-R7.          .     5.0 .      13.5 : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/ic/a2/nrica2q5vtygw-ck3mstvspkm4y.png"></div><br>      ,      ,       ,    . <br><br>   ,  ,     ,      Ru,  Ux    Uref.     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/t7/qi/zvt7qi05g21ecwvaquqnjdbhjli.png"></div><br>     R8  ,  R9    NTCLE100E3   0‚Å∞C: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j5/gp/_k/j5gp_kzjcx3buv0ayejxoazlwcu.png"></div><br><blockquote>   ,        R8  R9      ,  , ,  . .       ,    R9   ,        0.5 m,       .   ,            ,   0.01 . </blockquote><br>         ,  , ,   .     ,                         .    -     ,        . <br><br> ,         ,      ,           . <br><br><h3>  Firmware </h3><br>     AtmelStudio ( gcc-avr 5.4.0)   <a href=""></a> ,     <a href="">hex</a> .      ,    . <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre><code class="cpp">//#define F_CPU 1200000UL //    <font></font>
<font></font>
#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/wdt.h&gt;<font></font>
#include &lt;avr/sleep.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt; <font></font>
#include &lt;util/delay.h&gt;<font></font>
<font></font>
//#define DBG<font></font>
<font></font>
#define TEMPERATURE_OVERHEAT 753 // LSB-  +50‚Å∞C<font></font>
#define TEMPERATURE_GIST     8   //    ( LSB)     <font></font>
#define VOLTAGE_GIST         3   //    ( LSB)     <font></font>
<font></font>
#define INTERVAL             WDTO_1S //     (1 )<font></font>
#ifndef DBG<font></font>
#define CELL_CHANGE_TIMEOUT  90  //      (  INTERVAL,   254)<font></font>
#define OVERHEAT_TIMEOUT     300 //      "" (  INTERVAL)<font></font>
#else<font></font>
#define CELL_CHANGE_TIMEOUT  2<font></font>
#define OVERHEAT_TIMEOUT     3<font></font>
#endif<font></font>
<font></font>
typedef unsigned char bool; //    <font></font>
#define true  0 == 0        //     <font></font>
#define false 0 != 0        //      <font></font>
<font></font>
typedef enum {st_none = 0b00, st_primary = 0b01, st_secondary = 0b10, st_both = 0b11} t_states; //    <font></font>
                                                                                                //       ,      <font></font>
typedef enum {adc_temperature, adc_voltage} t_measure;                                          //   <font></font>
typedef enum {move_null, move_up, move_down} t_movement;                                        //      <font></font>
<font></font>
//    <font></font>
struct t_coordidates {<font></font>
  signed char row, col;<font></font>
};<font></font>
<font></font>
//       <font></font>
struct t_correction {<font></font>
  t_movement voltage, temperature;<font></font>
};<font></font>
<font></font>
#define CELLS_ROWS 3 //      ( )<font></font>
#define CELLS_COLS 5 //      ( )<font></font>
<font></font>
//  <font></font>
const t_states CELLS[CELLS_ROWS][CELLS_COLS] = {<font></font>
  {st_both, st_both,    st_both,    st_primary, st_none},<font></font>
  {st_both, st_both,    st_primary, st_none,    st_none},<font></font>
  {st_both, st_primary, st_none,    st_none,    st_none}<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int ROWS_EDGES[CELLS_ROWS - 1] = {<font></font>
  241, // 0‚Å∞C<font></font>
  157  // -10‚Å∞C<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int COLS_EDGES[CELLS_COLS - 1] = {<font></font>
  864, // 13.5V<font></font>
  800, // 12.5V<font></font>
  787, // 12.3V<font></font>
  768  // 12.0V<font></font>
};<font></font>
<font></font>
unsigned int overheat_rest_time = 0; //       ""<font></font>
unsigned char cell_change_time  = 0; //      <font></font>
unsigned char no_cur_cell_time  = 0; //  ,            <font></font>
<font></font>
#define NULL_CELL (struct t_coordidates){.col = -1, .row = -1} // ,   <font></font>
#define NULL_CORRECTION (struct t_correction){.voltage = move_null, .temperature = move_null} // ,   <font></font>
<font></font>
struct t_correction moved_from = NULL_CORRECTION; //       <font></font>
struct t_coordidates cur_cell  = NULL_CELL,       //      <font></font>
                     next_cell = NULL_CELL;       //  -   <font></font>
<font></font>
//  <font></font>
static void init_pins() {<font></font>
  DDRB |= (1 &lt;&lt; PB0) | (1 &lt;&lt; PB1) | (1 &lt;&lt; PB3);     //   2 (PB3), 5 (PB0)  6 (PB1)  <font></font>
  PORTB &amp;= ~(1 &lt;&lt; PB0) &amp; ~(1 &lt;&lt; PB1) &amp; ~(1 &lt;&lt; PB3); //      2 (PB3), 5 (PB0)  6 (PB1)<font></font>
}<font></font>
<font></font>
// /    <font></font>
static void toggle_thermal_sensor(bool state) {<font></font>
  if(state) {<font></font>
    PORTB |= (1 &lt;&lt; PB1);  //  state ,      6 (PB1)<font></font>
<font></font>
    _delay_ms(5); //    <font></font>
  } else {<font></font>
    PORTB &amp;= ~(1 &lt;&lt; PB1); //  state  ,      6 (PB1)<font></font>
  }<font></font>
}<font></font>
<font></font>
//   <font></font>
static unsigned int measure_adc(t_measure measure) {<font></font>
  if(measure == adc_temperature) {<font></font>
    toggle_thermal_sensor(true); //    ,    <font></font>
<font></font>
    ADMUX = 0b10; //      -   3 (PB4)<font></font>
  } else {<font></font>
    ADMUX = 0b01; //      -   7 (PB2)<font></font>
  }<font></font>
<font></font>
  ADCSRA = (1 &lt;&lt; ADPS2) | //       = 16 (75 )<font></font>
           (1 &lt;&lt; ADIE) |  //    <font></font>
           (1 &lt;&lt; ADEN);   //  <font></font>
<font></font>
  set_sleep_mode(SLEEP_MODE_ADC); //   "" <font></font>
  do {<font></font>
    sleep_cpu(); //      ,      ,   <font></font>
  } while(ADCSRA &amp; (1 &lt;&lt; ADSC)); //        ,  <font></font>
<font></font>
  ADCSRA = 0; //  <font></font>
<font></font>
  toggle_thermal_sensor(false); //     <font></font>
<font></font>
  return ADC; //  10-  <font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
static void init_interrupts(void) {<font></font>
  sleep_enable(); //   <font></font>
<font></font>
  WDTCR = (1 &lt;&lt; WDCE) | (1 &lt;&lt; WDE); //  watchdog<font></font>
  WDTCR = (1 &lt;&lt; WDTIE) | INTERVAL; // watchdog      ,  1 <font></font>
<font></font>
  sei(); //  <font></font>
}<font></font>
<font></font>
//          <font></font>
static void toggle_loads(t_states states) {<font></font>
  unsigned char port = PORTB &amp; ~((1 &lt;&lt; PB3) | (1 &lt;&lt; PB0)),     //           ,   <font></font>
                bits = (((states &amp; st_primary) &gt;&gt; 0) &lt;&lt; PB3) | //        <font></font>
                       (((states &amp; st_secondary) &gt;&gt; 1) &lt;&lt; PB0);<font></font>
<font></font>
  PORTB = port | bits; //    <font></font>
}<font></font>
<font></font>
//     t_coordidates<font></font>
static bool cells_equal(struct t_coordidates cell1, struct t_coordidates cell2) {<font></font>
  return cell1.row == cell2.row &amp;&amp; cell1.col == cell2.col;<font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_row(unsigned int temperature) {<font></font>
  signed char row = 0;<font></font>
<font></font>
  while(row &lt; CELLS_ROWS - 1) {          //          <font></font>
    if(temperature &gt;= ROWS_EDGES[row]) { //  temperature     ,    <font></font>
      return row;<font></font>
    } else {<font></font>
      ++row;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_ROWS - 1; //  temperature         ,       <font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_col(unsigned int voltage) {<font></font>
  signed char col = 0;<font></font>
<font></font>
  while(col &lt; CELLS_COLS - 1) {      //          <font></font>
    if(voltage &gt;= COLS_EDGES[col]) { //  voltage     ,    <font></font>
      return col;<font></font>
    } else {<font></font>
      ++col;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_COLS - 1; //  voltage         ,       <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_row_edges(signed char row, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = row &gt; 0 ? ROWS_EDGES[row - 1] : 0xffff - TEMPERATURE_GIST; //       ,    <font></font>
  *lower = row &lt; CELLS_ROWS - 1 ? ROWS_EDGES[row] : TEMPERATURE_GIST; //       ,    <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_col_edges(signed char col, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = col &gt; 0 ? COLS_EDGES[col - 1] : 0xffff - VOLTAGE_GIST; //      (  )  ,    <font></font>
  *lower = col &lt; CELLS_COLS - 1 ? COLS_EDGES[col] : VOLTAGE_GIST; //      (  )  ,    <font></font>
}<font></font>
<font></font>
//    -              <font></font>
static void gisteresis_correction(struct t_coordidates* new_cell, unsigned int temperature, unsigned int voltage) {<font></font>
  unsigned int upper_edge, lower_edge;<font></font>
<font></font>
  get_row_edges(cur_cell.row, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;row &gt; cur_cell.row &amp;&amp; moved_from.temperature == move_up &amp;&amp; temperature &gt;= lower_edge - TEMPERATURE_GIST) {<font></font>
    --new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;row &lt; cur_cell.row &amp;&amp; moved_from.temperature == move_down &amp;&amp; temperature &lt;= upper_edge + TEMPERATURE_GIST) {<font></font>
    ++new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  get_col_edges(cur_cell.col, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;col &gt; cur_cell.col &amp;&amp; moved_from.voltage == move_up &amp;&amp; voltage &gt;= lower_edge - VOLTAGE_GIST) {<font></font>
    --new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;col &lt; cur_cell.col &amp;&amp; moved_from.voltage == move_down &amp;&amp; voltage &lt;= upper_edge + VOLTAGE_GIST) {<font></font>
    ++new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
}<font></font>
<font></font>
//       stdlib::abs()<font></font>
 static unsigned char absolute(signed char value) {<font></font>
  return value &gt;= 0 ? value : -value;<font></font>
}<font></font>
<font></font>
//      -<font></font>
static void calc_movement(struct t_coordidates new_cell) {<font></font>
  moved_from = NULL_CORRECTION;                                                   // -   <font></font>
  if(!cells_equal(new_cell, NULL_CELL) &amp;&amp; !cells_equal(cur_cell, NULL_CELL)) {    //         ,  -<font></font>
    if(absolute(new_cell.row - cur_cell.row) == 1) {                              //      <font></font>
      moved_from.temperature = new_cell.row &lt; cur_cell.row ? move_up : move_down; //   <font></font>
    }<font></font>
<font></font>
    if(absolute(new_cell.col - cur_cell.col) == 1) {                              //      <font></font>
      moved_from.voltage = new_cell.col &lt; cur_cell.col ? move_up : move_down;     //   <font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//   -<font></font>
static void set_next_cell(struct t_coordidates cell) {<font></font>
  next_cell = cell;<font></font>
  cell_change_time = 0; //    <font></font>
}<font></font>
<font></font>
//    <font></font>
static void set_cur_cell(struct t_coordidates cell) {<font></font>
  cur_cell = cell;<font></font>
  no_cur_cell_time = 0; //        <font></font>
  set_next_cell(NULL_CELL); //  -<font></font>
}<font></font>
<font></font>
// ,      <font></font>
static void change_cell(struct t_coordidates new_cell) {<font></font>
  if(cells_equal(new_cell, NULL_CELL)) { //         <font></font>
    toggle_loads(st_none);<font></font>
  } else {<font></font>
    toggle_loads(CELLS[new_cell.row][new_cell.col]); //         <font></font>
  }<font></font>
<font></font>
  calc_movement(new_cell); //     <font></font>
  set_cur_cell(new_cell);  //   <font></font>
}<font></font>
<font></font>
//  <font></font>
static void main_proc(void) {<font></font>
  unsigned int temperature, voltage; // 10- LSB-    <font></font>
  struct t_coordidates cell;         //      -<font></font>
<font></font>
  if(overheat_rest_time) { //      ""  ,          <font></font>
    --overheat_rest_time;<font></font>
  } else {<font></font>
    temperature = measure_adc(adc_temperature); //  <font></font>
    if(temperature &gt;= TEMPERATURE_OVERHEAT) {   //      +50C,  :<font></font>
      change_cell(NULL_CELL);                   //      (   )<font></font>
      overheat_rest_time = OVERHEAT_TIMEOUT;    //        <font></font>
    } else {<font></font>
      voltage = measure_adc(adc_voltage);   //  <font></font>
<font></font>
      cell.col = get_cell_col(voltage);     //    -  <font></font>
      cell.row = get_cell_row(temperature); //    -  <font></font>
<font></font>
      if(cells_equal(cur_cell, NULL_CELL)) { //        ,         <font></font>
        change_cell(cell);<font></font>
      } else {<font></font>
        gisteresis_correction(&amp;cell, temperature, voltage); //              <font></font>
<font></font>
        if(cells_equal(cell, cur_cell)) { //   -   ,      <font></font>
          set_next_cell(NULL_CELL);<font></font>
          no_cur_cell_time = 0; //    ,  <font></font>
        } else {<font></font>
          if(no_cur_cell_time++ &gt; CELL_CHANGE_TIMEOUT) { //    CELL_CHANGE_TIMEOUT+1        cur_cell,      <font></font>
            change_cell(cell); //    ,     <font></font>
          } else {<font></font>
            if(cells_equal(next_cell, NULL_CELL) || !cells_equal(next_cell, cell)) { //  -       ,   <font></font>
              set_next_cell(cell);<font></font>
            } else {<font></font>
              if(++cell_change_time &gt;= CELL_CHANGE_TIMEOUT) { //   ,       , ,    <font></font>
                change_cell(cell);<font></font>
              }<font></font>
            }<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
ISR(WDT_vect) {<font></font>
  WDTCR |= (1 &lt;&lt; WDTIE); //    watchdog   ""    <font></font>
}<font></font>
<font></font>
//    ,        ADSC  measure_adc()<font></font>
EMPTY_INTERRUPT(ADC_vect);<font></font>
<font></font>
//  <font></font>
int main(void) {<font></font>
  init_pins();       //  <font></font>
  init_interrupts(); //    watchdog<font></font>
	<font></font>
  while(true) {                          //  ,       <font></font>
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); //        <font></font>
    sleep_cpu();                         //        watchdog <font></font>
<font></font>
    main_proc();                         //          <font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<br>
    : L:0x6A, H:0xFF.<br>
</div></div><br>
   .    ,     ‚Äì  ,    ‚Äì .            ,    .     :<br>
<br>
<a href=""><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/wx/ez/0jwxezo197qadbln8crg05zwlhq.png"></div></a><br>
          ,      .<br>
<br>
,           .        ,        .   ,        ,       .<br>
<br>
<blockquote>,  -      ,       .                ,    ,      . , - ,  ,    ,   ,                .  ..  -   ,           ,      .    .         .      ,      ,     .</blockquote><br>
        ,                  .  ,  , ,  12.5   ,      ,      12.4 .                . ,             .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/d5/9e/_od59e61ylpgaqhsrwwlwsro3dw.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/bu/uu/lobuuuqhkbahdsyinpg5hhokeyw.png"></div><br>
 ,               , ,   .            ,    .           ¬´¬ª 8-9 .<br>
<br>
<blockquote>         ,     .        ¬´¬ª    ,          .   ,      ,    ¬´¬ª ,     -    (,   ,   ,    ,  ,     -  ).</blockquote><br>
      ,        +50‚Å∞C  ,     .        ,  ,  ,       .                 .<br>
<br>
  ¬´¬ª,   ,    (watchdog).                    .<br>
<br>
<blockquote> ,          ‚Äì  .       . Watchdog   ,  ,     ,     .  ,    ,         ,     watchdog.   ,      ,        .</blockquote><br>
           .       1006 ,      -  .<br>
<br>
<blockquote>,       ,  .   ,        O2,   ,       Os  ,      1024 .             -,      .</blockquote><br>
                       .<br>
<br>
<div class="spoiler"><b class="spoiler_title">    </b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/gg/nv/1bggnvmw6h-x7nab-h9ljuag1lq.png"></div><br>
     Eagle  <a href=""></a>.<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446956/">https://habr.com/ru/post/pt446956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446942/index.html">Servidor, voc√™ pode me ouvir? Ataque do BROP ao exemplo da tarefa NeoQUEST-2019</a></li>
<li><a href="../pt446944/index.html">Por que investir em empresas n√£o lucrativas?</a></li>
<li><a href="../pt446948/index.html">Como o Trojan Gustuff Android remove o creme (decreto e criptografia) de suas contas</a></li>
<li><a href="../pt446950/index.html">76% dos fabricantes n√£o t√™m experi√™ncia em implementar aditivos - por que √© bom</a></li>
<li><a href="../pt446952/index.html">Crie histogramas animados usando R</a></li>
<li><a href="../pt446958/index.html">Tricky Perl Quine</a></li>
<li><a href="../pt446960/index.html">A casa que Jack construiu</a></li>
<li><a href="../pt446962/index.html">Phishing e sem qu√≠mica</a></li>
<li><a href="../pt446964/index.html">Integra√ß√£o com SAP ERP. Implementa√ß√£o de um verificador de pre√ßo m√≥vel em uma loja</a></li>
<li><a href="../pt446966/index.html">Not√≠cias da semana: principais eventos em TI e ci√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>