<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê• üç∏ ‚öïÔ∏è Topologia e an√°lise abrangente para um desenvolvedor de jogos desavisado: compactando vetores 3D √∫nicos ‚èØÔ∏è üé≥ üé™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como voc√™ j√° pode entender nos meus artigos anteriores, gosto de usar o desenvolvimento de jogos como uma desculpa para demonstrar matem√°tica complexa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Topologia e an√°lise abrangente para um desenvolvedor de jogos desavisado: compactando vetores 3D √∫nicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="imagem"></div><br>  Como voc√™ j√° pode entender nos meus artigos anteriores, gosto de usar o desenvolvimento de jogos como uma desculpa para demonstrar matem√°tica complexa para a qual a maioria das pessoas n√£o teria utilidade.  E este artigo n√£o √© exce√ß√£o!  Quero mostrar uma t√©cnica muito bacana, correspondente a pontos interessantes para mim: <br><br><ul><li>  o processo √© claro o suficiente </li><li>  √© muito mais r√°pido que a t√©cnica usual que executa a mesma tarefa </li><li>  ele usa uma propriedade muito incomum de representar n√∫meros de ponto flutuante no formato de ponto flutuante, o que implica que ... </li><li>  <strong>n√£o funciona na an√°lise cl√°ssica</strong> .  Para que esse algoritmo funcione na teoria, voc√™ precisa entrar no maravilhoso mundo da matem√°tica n√£o cl√°ssica!  E se isso n√£o despertou sua curiosidade, n√£o sei mais o que fazer. </li></ul><br>  Este artigo √© bastante longo e te√≥rico, porque requer um estudo aprofundado das explica√ß√µes; portanto, reserve um tempo e releia as partes que lhe pareciam n√£o t√£o √≥bvias na primeira vez. <br><br><h2>  Um pouco sobre o contexto (GPU) </h2><br>  Um dos aspectos importantes que voc√™ deve prestar aten√ß√£o no desenvolvimento de jogos e, em um sentido mais amplo - em qualquer √°rea com o uso ativo de gr√°ficos - √© a largura de banda da GPU.  O processador central e a GPU s√£o dispositivos f√≠sicos separados e precisam de sincroniza√ß√£o para trocar dados.  Se voc√™ j√° fez o processamento paralelo, sabe que quando dois dispositivos precisam ser sincronizados, isso significa perder uma quantidade significativa de tempo.  A intera√ß√£o da CPU-GPU nesse sentido n√£o √© diferente, por isso nos esfor√ßamos para minimizar a transfer√™ncia de dados, tanto no n√∫mero de opera√ß√µes quanto na quantidade de dados transferidos. <br><a name="habracut"></a><br>  A minimiza√ß√£o do n√∫mero de opera√ß√µes de transfer√™ncia de dados geralmente √© realizada usando o buffer: n√≥s nos esfor√ßamos para ajustar todos os dados no menor n√∫mero poss√≠vel de matrizes e depois transferimos tudo de uma s√≥ vez para que n√£o precisemos mais nos preocupar com eles.  Minimizar a quantidade de dados nas opera√ß√µes de transfer√™ncia √© um t√≥pico completamente diferente, e as solu√ß√µes para esse problema s√£o quase sempre individuais.  Como um exemplo extremo disso, voc√™ pode ver <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">como o mecanismo de renderiza√ß√£o Destiny consegue se ajustar √† posi√ß√£o, normais da superf√≠cie, sinalizadores de material e par√¢metros BSDF anisotr√≥picos completos de 96 bits, ou seja,</a>  <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">tr√™s n√∫meros de ponto flutuante</a> (p. 62 em diante).  No entanto, bons resultados podem ser alcan√ßados por m√©todos gerais, aos quais s√£o adicionadas solu√ß√µes individuais para otimiza√ß√£o. <br><br>  Hoje discutiremos a <strong>compacta√ß√£o sem perdas de vetores 3D individuais individuais</strong> .  Esta frase cont√©m v√°rias palavras-chave: <br><br><ul><li>  <strong>Vetores 3D √∫nicos</strong> : <strong>vetores</strong> 3D com um comprimento de 1 </li><li>  <strong>compacta√ß√£o sem perdas</strong> : reduza o tamanho das descri√ß√µes de vetores 3D √∫nicos sem perda de precis√£o.  √â o oposto da <em>compacta√ß√£o com perdas.</em> </li><li>  <strong>Separado</strong> : a codifica√ß√£o e decodifica√ß√£o de vetores √© realizada sem informa√ß√µes sobre seus vizinhos.  Se a situa√ß√£o fosse oposta, poderia ser algo como compacta√ß√£o em <em>lote</em> , na qual n√£o vetores individuais s√£o compactados, mas suas matrizes </li></ul><br>  Antes de prosseguir, devo mencionar o excelente artigo <a href="http://jcgt.org/published/0003/02/01/" rel="noopener"><em>‚ÄúUma Pesquisa de Representa√ß√µes Eficientes para</em> <em>Vetores de</em> <em>Unidades Independentes</em> <em>‚Äù,</em></a> de Cigolle, Donow, Evangelakos, Mara, McGuire e Meyer, da qual me inspirei para o meu cargo.  Devo dizer <strong><em>imediatamente</em></strong> que o <strong>algoritmo sobre o qual falarei √© menos eficiente que o algoritmo de <em>outubro</em> apresentado no artigo</strong> .  Se voc√™ deseja a m√°xima efici√™ncia, leia o artigo e use o <em>oct</em> .  O objetivo do meu post √© mostrar a beleza de usar matem√°tica muito incomum, enquanto cria, como veremos mais adiante, um algoritmo muito conveniente. <br><br><h2>  Topologia diretamente no seu videogame </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>  <i>No caso da esfera unit√°ria, apenas Œ∏ e œÜ s√£o importantes, porque œÅ √© sempre 1 e, portanto, redundante.</i> <br><br>  O ponto de partida do algoritmo √© a observa√ß√£o de que os vetores unit√°rios 3D s√£o equivalentes aos pontos em uma esfera.  Como voc√™ provavelmente sabe, uma esfera √© uma superf√≠cie bidimensional, ou seja, para a identifica√ß√£o exclusiva de pontos em uma esfera, s√£o necess√°rias apenas duas coordenadas.  Um exemplo muito comum disso s√£o as coordenadas esf√©ricas, nas quais um ponto na esfera √© definido por dois √¢ngulos, Œ∏ e œÜ. <br><br>  Curiosamente, uma propriedade bastante desagrad√°vel √© que, embora a esfera e o quadrado preenchido (um espa√ßo poss√≠vel para coordenadas 2D) sejam objetos 2D, realmente n√£o h√° correspond√™ncia entre eles.  Isso significa que n√£o h√° como anexar um ponto √∫nico na esfera a cada ponto √∫nico do quadrado (pelo menos de maneira cont√≠nua);  eles s√£o considerados <em>n√£o-homeom√≥rficos</em> (em outras palavras, um tem um limite e o outro n√£o).  Um resultado desagrad√°vel disso √© que algumas coordenadas 2D s√£o perdidas no sentido de que coordenadas diferentes correspondem a pontos id√™nticos na esfera (por exemplo, no caso de coordenadas esf√©ricas, quando œÜ √© 0, o ponto correspondente ser√° o polo norte, independentemente da coordenada Œ∏).  Em termos de compacta√ß√£o, perdemos padr√µes de bits valiosos com os quais poder√≠amos descrever os pontos de uma esfera! <br><br>  Se voc√™ deseja mais matem√°tica e deseja provar que o quadrado e a esfera n√£o s√£o homeom√≥rficos, pode usar o fato de que a esfera, em contraste com o quadrado, n√£o √© contrat√°vel e a contratabilidade √© uma propriedade topol√≥gica;  O teorema de Borsuk-Ulam tamb√©m pode ser usado como prova.  Eles tamb√©m me disseram que os grupos de homotopia podem ajudar com a prova, mas isso j√° est√° fora da minha √°rea de especializa√ß√£o. <br><br>  No entanto, esse problema surge n√£o apenas com coordenadas esf√©ricas;  qualquer representa√ß√£o 2D cont√≠nua dos pontos da esfera sofrer√° com isso.  No entanto, lembre-se disso para o futuro. <br><br>  As coordenadas esf√©ricas tamb√©m t√™m outras propriedades ruins: <br><br><ul><li>  Eles t√™m uma m√° distribui√ß√£o sobre a esfera.  Se coordenadas esf√©ricas aleat√≥rias forem geradas e convertidas de volta para pontos 3D, elas formar√£o aglomerados em torno dos p√≥los e ser√£o rarefeitas perto do equador.  Isso se deve ao fato de que os vetores 3D pr√≥ximos ao equador ser√£o menos precisamente distingu√≠veis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>  <i>Distribui√ß√£o em uma esfera de 10.000 coordenadas esf√©ricas uniformemente distribu√≠das</i> </li><li>  Sua embalagem e desembalagem s√£o caras.  Para empacotar (3D ‚Üí 2D), s√£o necess√°rias uma opera√ß√£o <em>acos</em> e uma <em>atan2</em> , que s√£o fun√ß√µes trigonom√©tricas inversas bastante caras, e para descompactar (2D ‚Üí 3D) s√£o necess√°rias duas opera√ß√µes <em>cos</em> e duas opera√ß√µes <em>sin</em> , que tamb√©m est√£o longe de serem econ√¥micas. </li></ul><br>  Confira o artigo acima para aprender sobre outras compara√ß√µes de coordenadas esf√©ricas e outros m√©todos de compress√£o. <br><br><h2>  A tarefa de preservar padr√µes de bits ... e velocidade </h2><br>  O m√©todo que consideraremos tem uma grande vantagem - seu c√°lculo √© muito mais r√°pido, mais do que o dobro do valor de refer√™ncia ing√™nuo n√£o otimizado (testado na embalagem e na descompacta√ß√£o de 10 milh√µes de vetores aleat√≥rios em C ++ no Visual Studio 19 no Intel Core i5 7a gera√ß√£o).  Al√©m disso, o m√©todo n√£o possui singularidade, ou seja, cada ponto empacotado corresponde a um √∫nico ponto n√£o empacotado, em contraste com as coordenadas esf√©ricas mencionadas acima. <br><br>  Como mencionado anteriormente, n√£o h√° homeomorfismo entre a esfera unit√°ria e o quadrado unit√°rio, ou seja, n√£o podemos amarrar adequadamente cada ponto √∫nico do quadrado a outro ponto √∫nico da esfera.  Mas vamos considerar as seguintes constru√ß√µes - at√© agora, apenas o hemisf√©rio norte, em que h√° pontos com uma coordenada Z positiva ou zero, nos interessar√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>  <i>N√≥s ‚Äúachatamos‚Äù o hemisf√©rio norte no disco, <strong>descartando a coordenada Z de cada ponto</strong> (ou atribuindo a ele um valor 0).</i> <br><br>  Encontramos uma maneira de anexar todos os pontos do hemisf√©rio norte a todos os pontos em um √∫nico disco.  Alguns pontos dignos de nota: <br><br><ul><li>  o polo norte cai em (0, 0). </li><li>  cada ponto no limite do hemisf√©rio permanece o mesmo.  Mais especificamente, o hemisf√©rio e o disco t√™m o mesmo limite.  Isso √© l√≥gico, porque os pontos no limite do hemisf√©rio t√™m Z = 0, ou seja, descartando a coordenada Z, n√£o mudamos nada. </li></ul><br><h3>  Compacta√ß√£o de disco: uma tarefa complexa simples </h3><br>  A constru√ß√£o a seguir requer uma pequena introdu√ß√£o.  Apenas no caso, direi que n√∫meros complexos s√£o uma extens√£o do espa√ßo de n√∫meros reais (n√∫meros comuns como 0, 1, 129,43, pi, 335/117, raiz quadrada 2 e assim por diante), que usa um n√∫mero especial chamado <em>imagin√°rio unidade</em> .  N√∫meros complexos t√™m a forma <em>a + ib</em> , onde <em>a</em> e <em>b</em> s√£o alguns n√∫meros reais (respectivamente, as partes real e imagin√°ria), e <em>i</em> tem a propriedade <em>i</em> ¬≤ = -1.  Isso nos permite combinar n√∫meros complexos com pontos em um plano 2D.  Se tomarmos para <em>z um</em> n√∫mero complexo da forma <em>z = a + ib</em> , poderemos representar <em>z como um</em> ponto com coordenadas ( <em>a</em> , <em>b</em> ) no plano.  As fun√ß√µes de extra√ß√£o da ‚Äúparte real‚Äù e da ‚Äúparte imagin√°ria‚Äù do n√∫mero complexo <em>z s√£o</em> denotadas por <em>Re (z)</em> e <em>Im (z)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>  <i>O n√∫mero complexo <em>z</em> e seus valores.</i> <br><br>  Al√©m das partes reais e imagin√°rias do n√∫mero complexo, tamb√©m √© poss√≠vel considerar o comprimento e o √¢ngulo formado por ele com o eixo X. Isso √© chamado de <em>representa√ß√£o polar</em> .  O comprimento polar e o √¢ngulo polar s√£o a norma <em>| z |</em>  e argumento <em>Arg (z)</em> .  Uma propriedade conveniente de ambas as representa√ß√µes √© que a <strong>adi√ß√£o de n√∫meros complexos √© feita adicionando as partes reais e imagin√°rias</strong> , e a <strong>multiplica√ß√£o de n√∫meros complexos √© feita multiplicando as normas e adicionando os argumentos</strong> . <br><br>  Aqui estamos interessados ‚Äã‚Äãem duas opera√ß√µes: quadratura e obten√ß√£o da raiz quadrada de um n√∫mero complexo.  Esquadrar um n√∫mero complexo √© exatamente o mesmo que para n√∫meros reais: simplesmente o multiplicamos por n√≥s mesmos, essencialmente <strong>esquadrando a norma e dobrando o argumento</strong> .  Observe que, se a norma de um n√∫mero complexo for menor que 1, ao quadr√°-lo, seu comprimento permanecer√° menor que um;  Assim, se pegarmos cada n√∫mero complexo no disco que possui uma parte real positiva e os colocarmos em um quadrado, obteremos essencialmente o disco inteiro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>  <i>√Ä esquerda, existem v√°rios n√∫meros complexos na metade do disco com a parte real positiva (coordenada X).</i>  <i>√Ä direita est√° o resultado da quadratura de todos esses pontos.</i>  <i>Metade do disco agora preenche todo o disco!</i> <br><br>  Um truque est√° associado √† ‚Äúduplica√ß√£o de um argumento‚Äù: depende do lado do eixo X no qual o ponto se encontra.  A regra √© mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>  <i>Um n√∫mero complexo com uma parte imagin√°ria positiva (coordenada Y) gira para a esquerda e um n√∫mero complexo com uma parte imagin√°ria negativa (coordenada Y) gira para a direita.</i> <br><br>  Como no caso de n√∫meros reais, a raiz quadrada √© o inverso do quadrado: para um determinado n√∫mero complexo <em>z</em> , as ra√≠zes quadradas (duas delas) s√£o os n√∫meros <em>c</em> , de modo que <em>c¬≤ = z</em> .  Como no caso de n√∫meros reais, se <em>c</em> √© a raiz quadrada de <em>z</em> , ent√£o <em>-c</em> tamb√©m √©.  O dos n√∫meros <em>c</em> e <em>-c</em> , cujo argumento √© igual √† metade do argumento <em>z</em> , √© chamado o valor principal da raiz quadrada (√© semelhante a obter a raiz quadrada positiva de um n√∫mero real em vez da raiz quadrada negativa). <br><br>  Se voc√™ entender que, quando um n√∫mero complexo √© elevado ao quadrado, sua norma √© elevada ao quadrado e seu argumento √© dobrado, √© f√°cil adivinhar que o valor principal da raiz quadrada retira a raiz quadrada da norma e reduz pela metade o argumento (seguindo a regra mostrada acima, mas com as setas viradas ao contr√°rio) .  Como no caso da quadratura, ao obter a raiz quadrada de um n√∫mero complexo com uma norma menor que 1, a norma permanece menor que 1;  portanto, "comprime" o disco da unidade em seus n√∫meros reais semi positivos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>  <i>√Ä esquerda, existem v√°rios pontos em um √∫nico disco.</i>  <i>O lado direito mostra o resultado de obter a raiz quadrada de todos esses pontos.</i>  <i>O disco inteiro agora cabe na metade de si!</i> <br><br>  Esta √© a base do algoritmo: na verdade, compactamos todo o disco da unidade em metade e meia com a parte real positiva.  Como voc√™ se lembra, recentemente achatamos a metade superior de uma esfera em um √∫nico disco;  Agora vale a pena ver o que faremos com isso. <br><br><h3>  Juntando tudo </h3><br>  Vamos resumir o que acabamos de fazer: achatamos metade da esfera em um disco unit√°rio, descartando a coordenada Z de todos os seus pontos e comprimimos o disco unit√°rio em sua pr√≥pria metade com a parte real positiva usando o valor da raiz quadrada principal complexa.  De fato, achatamos metade da esfera em metade do disco!  Agora, com algumas altera√ß√µes, podemos fazer o mesmo para comprimir a metade restante da esfera na metade restante do disco. <br><br>  Da mesma forma, a metade inferior da esfera (todos os pontos da esfera com uma coordenada Z negativa) √© achatada em um disco unit√°rio, eliminando repetidamente as coordenadas Z. No entanto, para todos os n√∫meros complexos <em>z</em> no disco, assumimos o valor oposto √† raiz quadrada principal de <em>z</em> (ou seja, pegamos <em>-c em</em> vez de <em>c</em> )  Como o valor principal da raiz quadrada sempre tem uma parte real positiva, o valor oposto sempre ter√° uma parte real negativa;  de fato, achatamos a metade restante da esfera na metade restante do disco e o est√°gio de compacta√ß√£o agora est√° completo! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>  <i>Etapa de compacta√ß√£o completa.</i>  <i>Observe que os hemisf√©rios norte e sul (azul e laranja) s√£o achatados em duas c√≥pias de um √∫nico disco e, em seguida, compactados em duas metades de um √∫nico disco.</i> <br><br>  O algoritmo de compacta√ß√£o √© o seguinte: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit)</span></span></span><span class="hljs-function"> disk </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(unit.x, unit.y) packed = principalSquareRoot(disk) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit.z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -packed : packed</code> </pre> <br>  E assim, em apenas tr√™s linhas de pseudoc√≥digo, aplicamos toda a teoria que examinamos para criar um algoritmo eficaz.  Se o seu ambiente n√£o possui uma f√≥rmula para o valor principal da raiz quadrada, ela pode ser encontrada <a href="https://en.wikipedia.org/wiki/Square_root" rel="noopener">na Wikipedia</a> (aten√ß√£o especial deve ser dada √† escolha do sinal da parte imagin√°ria).  Aqui est√° a implementa√ß√£o de C ++ de refer√™ncia que eu uso no meu c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Principal complex square root of 'x + iy' float2 csqrt(float x, float y) { float r = sqrt(x * x + y * y); return float2(sqrt((r + x) / 2), (y &lt; 0 ? -1 : 1) * sqrt((r - x) / 2)); }</span></span></code> </pre> <br><h3>  Volta </h3><br>  Lidamos com a compacta√ß√£o, agora procedemos √† descompacta√ß√£o. <br><br>  A descompacta√ß√£o consiste na ordem inversa de todas as etapas de compacta√ß√£o: <br><br><ul><li>  expandimos as metades positiva e negativa das partes materiais de um √∫nico disco em dois discos completos </li><li>  combine cada disco completo com seu hemisf√©rio correspondente </li></ul><br>  Em resumo, come√ßamos com o valor compactado de <em>p</em> , esquadr√°-lo para retornar ao ponto no disco obtido de um dos hemisf√©rios e, em seguida, usamos o sinal <em>Re (p)</em> para descobrir de qual hemisf√©rio o ponto no disco √© retirado.  Usando a equa√ß√£o <em>x¬≤ + y¬≤ + z¬≤ = 1</em> , que define os pontos na esfera unit√°ria, podemos recriar a coordenada Z ausente do ponto empacotado. <br><br>  Note-se que o c√°lculo do quadrado do valor compactado sempre nos dar√° o ponto correto do disco, independentemente do seu hemisf√©rio inicial (superior ou inferior), porque <em>z¬≤ =</em> <em>(-z) ¬≤</em> . <br><br>  O algoritmo de descompress√£o √© o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  E, portanto, obtivemos um algoritmo que cria com efici√™ncia uma representa√ß√£o 2D de vetores 3D √∫nicos, que, diferentemente das coordenadas esf√©ricas, n√£o perde nenhum padr√£o de bits e n√£o possui singularidade.  Se voc√™ n√£o levar em considera√ß√£o alguns truques de otimiza√ß√£o para acelerar os c√°lculos, esta √© uma vers√£o quase pronta do algoritmo. <br><br>  ... ou n√£o?  Se voc√™ assistiu com aten√ß√£o, notou que algo est√° errado aqui.  Eu disse que a esfera e o quadrado unit√°rio n√£o s√£o homeom√≥rficos e, de alguma forma, conseguiram vincular um ponto √∫nico do disco a cada ponto √∫nico da esfera?  Al√©m disso, n√£o mencionamos nenhuma matem√°tica n√£o cl√°ssica, ent√£o o que est√° acontecendo? <br><br>  De fato, nosso algoritmo tem uma s√©ria desvantagem: ele funciona para todos os pontos da esfera inteira, exceto para os pontos no hemisf√©rio norte com Y = 0 e X &lt;= 0, que, ao empacotar e descompactar, s√£o erroneamente comparados com o ponto correspondente no hemisf√©rio norte. <br><br>  A raz√£o para isso √© que, quando suas coordenadas Z s√£o descartadas, o n√∫mero complexo correspondente √© um n√∫mero real negativo, n√£o possui uma parte imagin√°ria.  Quando assumimos o valor principal da raiz quadrada de um n√∫mero real negativo, obtemos um n√∫mero complexo completamente imagin√°rio que n√£o possui uma parte real (isso √© semelhante ao fato de que o valor principal da raiz quadrada de -1 √© igual a <em>i</em> ).  Em seguida, tentamos manter o sinal da coordenada Z no que √© essencialmente zero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>  <i>Faixa de problema.</i>  <i>Pontos com Y = 0 e X &lt;= 0 s√£o agrupados em uma linha de n√∫meros puramente imagin√°rios com partes reais indefin√≠veis.</i> <br><br>  Vamos ver o que acontece quando empacotamos dois desses pontos (n√£o esque√ßa que x &lt;= 0). <br><br><blockquote><pre>  |  Ponto norte |  Ponto sul
  unidade  (x, 0, z) |  (x, 0, -z)
  disco  x + 0i  x + 0i
 embalado |  0 + ‚àö (-x) i |  -0 - ‚àö (-x) i </pre></blockquote><br>  Como a parte imagin√°ria da proje√ß√£o no disco de ambos os pontos √© igual a zero, n√£o podemos armazenar o sinal da coordenada Z no sinal da parte real do valor principal da raiz quadrada, porque ela pr√≥pria √© igual a zero.  Podemos simplesmente insistir nisso, aceitando o fato de que o algoritmo n√£o funciona para esses pontos - ou podemos seguir em frente. <br><br><h2>  Esque√ßa o que aprendemos </h2><br>  Em todas as √°reas e ramos da matem√°tica que conhe√ßo, assume-se que 0 = -0.  Isso decorre da defini√ß√£o de <em>-a</em> , que √© o oposto de <em>a</em> , afirmando que <em>"-a √© o √∫nico n√∫mero que d√° 0 quando somada com a"</em> .  Como 0 tamb√©m √© um elemento zero em rela√ß√£o √† adi√ß√£o ( <em>0 + a = a + 0 = a</em> ), a √∫nica coisa que voc√™ precisa adicionar a 0 para obter 0 √© o pr√≥prio 0. <br><br>  No entanto, no desenvolvimento de software, tudo √© diferente.  Na maioria das representa√ß√µes de n√∫meros de ponto flutuante, junto com o expoente e a mantissa, um bit extra √© usado para armazenar o caractere.  Isso significa que quando o expoente e a mantissa s√£o 0, o bit de sinal pode ser usado para distinguir entre zeros positivos e negativos.  Na maioria das linguagens de programa√ß√£o (se n√£o todas), esses dois zeros s√£o tratados como um √∫nico zero (tente fazer <em>0 == -0</em> ), mas h√° uma diferen√ßa, e isso pode ser visto se voc√™ tentar enviar ‚Äú-0‚Äù e ‚Äú0 para o terminal "- √© assim que eles ser√£o deduzidos. <br><br>  Isso √© extremamente importante para n√≥s: o valor zero pode realmente ser usado para armazenar informa√ß√µes sobre o sinal!  De fato, ele √© armazenado corretamente de qualquer maneira;  no nosso caso, o problema √© que n√£o √© lido corretamente.  Se observarmos a pen√∫ltima linha no algoritmo de descompacta√ß√£o, veremos o seguinte: <br><br><pre> <code class="cpp hljs">packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Esta opera√ß√£o l√™ o sinal da parte real do valor compactado para determinar a qual hemisf√©rio o ponto pertence - norte ou sul.  Entretanto, no caso em que <em>embal.real ()</em> √© 0 ou -0, o caractere √© ignorado pelo operador de compara√ß√£o e o operador tern√°rio sempre retorna 1. A maneira correta de ler o caracter √© uma solicita√ß√£o <em>real</em> para o status do bit de sinal, por exemplo, usando <em>std :: signbit</em> de C ++ ou <em>np .signbit</em> de Numpy para Python - a fun√ß√£o depende da linguagem.  Lembre-se de que o bit do sinal √© 1 quando o n√∫mero √© negativo e 0 quando o n√∫mero √© positivo. <br><br>  Assim, obtemos uma fun√ß√£o de trabalho corrigida e cem por cento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Isso √© tudo!  Agora o algoritmo est√° completo.  A matem√°tica n√£o cl√°ssica se manifesta no fato de que usamos 0 que difere de -0, o que √© falso para todas as √°reas da matem√°tica que eu conhe√ßo.  No entanto, existe uma maneira de tornar essa estranheza l√≥gica em um sentido te√≥rico, matematicamente rigoroso. <br><br><h2>  Espa√ßos que n√£o cumprem as regras: uma linha reta com dois pontos de origem </h2><br>  Para entender melhor o seguinte, voc√™ deve conhecer os conceitos de classes de equival√™ncia e vizinhan√ßas.  Isso √© opcional, mas ser√° mais claro. <br><br>  Podemos garantir a consist√™ncia dessa singularidade com um "sinal zero", come√ßando com um espa√ßo topol√≥gico interessante: uma linha reta com dois pontos de origem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>  <i>Uma linha reta com dois pontos de origem √© um eixo num√©rico real comum, que de alguma forma aumentou 0 para si.</i> <br><br>  Uma linha reta com dois pontos de origem √© obtida quando pegamos dois eixos num√©ricos reais e colamos cada n√∫mero com o seu oposto, com exce√ß√£o de 0. Formalmente, uma linha reta com dois pontos de origem √© um espa√ßo quociente R¬≤ com uma rela√ß√£o de equival√™ncia identificando dois n√∫meros se eles s√£o iguais <em>e</em> n√£o s√£o 0. O resultado √© uma linha reta de n√∫meros reais com dois zeros diferentes eq√ºidistantes de qualquer ponto, mas ao mesmo tempo diferentes um do outro.  Formalmente, quaisquer dois bairros de cada um dos zeros sempre t√™m um cruzamento n√£o vazio. <br><br>  Podemos expandir isso e tentar definir o objeto "tipo disco" usado neste artigo.  Anteriormente, mantivemos √† for√ßa o sinal da coordenada Z do ponto na parte real da raiz quadrada principal de sua proje√ß√£o no disco complexo, mesmo que essa parte real seja 0. Isso significa que n√£o usamos n√∫meros complexos, mas outro conceito semelhante a eles: um n√∫mero complexo, cuja parte imagin√°ria √© um n√∫mero real e a parte real √© um ponto em uma linha com dois pontos de origem, para que possamos distinguir a parte real igual a +0 e -0.  De fato, usamos <strong>n√∫meros complexos com dois pontos de origem!</strong> <br><br>  De fato, n√£o encontramos uma bije√ß√£o (mapeamento um a um) entre a esfera e o disco unit√°rio, mas encontramos uma bije√ß√£o entre a esfera e o disco unit√°rio com dois pontos de origem.  N√£o testei se essa bije√ß√£o √© um homeomorfismo (um homeomorfismo √© uma bije√ß√£o cont√≠nua em ambas as dire√ß√µes), mas talvez um dia eu o fa√ßa. <br><br><h3>  Um pouco de topologia no final </h3><br>  Concluindo, quero enfatizar que, embora o plano complexo que usamos com dois pontos de origem n√£o siga a mesma constru√ß√£o da linha reta com duas origens, na verdade, √© o equivalente a outro plano complexo com dois pontos de origem constru√≠do de maneira semelhante a uma linha reta com duas origens. <br><br>  No caso de uma linha reta com dois pontos de origem, colamos duas c√≥pias do eixo num√©rico real em todos os lugares, exceto 0. Podemos fazer o mesmo com duas c√≥pias do plano complexo colando juntos cada par de n√∫meros complexos iguais que n√£o s√£o 0 e, da mesma forma, ficamos complexos um plano com dois pontos de origem.  Essa constru√ß√£o difere da constru√ß√£o de um novo plano complexo a partir de uma linha reta com dois pontos de origem e um eixo num√©rico real comum: o primeiro √© um espa√ßo fatorial e o segundo √© um produto de espa√ßos.  No entanto, a √∫nica diferen√ßa entre os dois espa√ßos resultantes √© a maneira de <em>escrever</em> zeros diferentes em cada espa√ßo: no primeiro, eles s√£o contados como ( <em>0 + 0i) ae</em> ( <em>0 + 0i) b</em> (dois zeros tirados de dois espa√ßos diferentes n√£o colados), e no √∫ltimo eles s√£o lidos como <em>(0a + 0i)</em> e <em>(0b +</em> <em>0i)</em> .  De fato, os dois espa√ßos s√£o homeom√≥rficos, portanto voc√™ pode usar com seguran√ßa um onde o outro for necess√°rio. <br><br><h2>  Conclus√£o </h2><br>  Espero que voc√™ tenha gostado dessa excurs√£o ao mundo da matem√°tica bizarra e obscura.  Enfatizo novamente o fato de que, estritamente falando, esse algoritmo se comporta pior do que o algoritmo de <em>outubro</em> do artigo que mencionei no in√≠cio.  Embora seja pr√≥ximo ou at√© mais r√°pido no tempo de execu√ß√£o, sua distribui√ß√£o de pontos na esfera est√° longe de ser t√£o boa.  Escrevi este artigo para mostrar como a matem√°tica aparentemente alien√≠gena, semelhante ao absurdo abstrato, pode realmente ter uma aplica√ß√£o muito interessante no mundo real;  al√©m disso, acho essa absurda abstrata deliciosa.  Espero que voc√™ tenha aprendido algo √∫til com o artigo, obrigado pela leitura! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482348/">https://habr.com/ru/post/pt482348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482336/index.html">Os comerciantes t√™m acesso a coletivas de imprensa do Banco Central da Inglaterra antes de sua transmiss√£o p√∫blica</a></li>
<li><a href="../pt482338/index.html">Visual Studio para Mac: controle seu IDE com chaves</a></li>
<li><a href="../pt482340/index.html">De Junior'a a Middle'a: Analisador</a></li>
<li><a href="../pt482344/index.html">Prepare-se para a introdu√ß√£o de uma classifica√ß√£o social na R√∫ssia</a></li>
<li><a href="../pt482346/index.html">ASP.NET MVC - trabalhando com o MySQL atrav√©s do ADO.NET</a></li>
<li><a href="../pt482352/index.html">Como eu quase joguei 150k no vento ou na hist√≥ria da instala√ß√£o de ventila√ß√£o for√ßada no apartamento</a></li>
<li><a href="../pt482354/index.html">ConfigureAwait: perguntas freq√ºentes</a></li>
<li><a href="../pt482358/index.html">Como funciona o p√¢nico em Rust</a></li>
<li><a href="../pt482360/index.html">Detetive Habra: eles s√£o amigos dos OVNIs</a></li>
<li><a href="../pt482362/index.html">Quase anarquia: uma breve hist√≥ria da Fidonet, um projeto que n√£o se importa com a vit√≥ria na Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>