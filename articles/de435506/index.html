<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏿 🙅🏽 💇 Game Boy Supercomputer 🛠️ 👩‍🎤 📀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit einer Geschwindigkeit von über 1 Milliarde Bildern pro Sekunde ist dies wohl der schnellste der 8-Bit-Konsolencluster der Welt. 


 Distributed Te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game Boy Supercomputer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435506/">  Mit einer Geschwindigkeit von über 1 Milliarde Bildern pro Sekunde ist dies wohl der schnellste der 8-Bit-Konsolencluster der Welt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e7/0fa/97d/4e70fa97d86589ec00f0a570a3835feb.gif"><br>  <i>Distributed Tetris (1989)</i> <br><br><h2>  Wie baue ich einen solchen Computer? </h2><br><h3>  Rezept </h3><br>  Nehmen Sie eine Handvoll Silizium, wenden Sie Verstärkungstraining an, machen Sie Erfahrung mit Supercomputern, einer Leidenschaft für Computerarchitektur, fügen Sie Schweiß und Tränen hinzu, rühren Sie 1000 Stunden lang, bis es kocht - und voila. <br><br><h2>  Warum sollte jemand einen solchen Computer brauchen? </h2><br>  Kurz gesagt: Auf dem Weg zur Verbesserung der künstlichen Intelligenz. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/1bd/3ef/d7f1bd3ef8197d18fc1612235bfbc0df.png"><br>  <i>Eine von 48 IBM Neural Computer-Karten, die für Experimente verwendet wurden</i> <br><br><h2>  Und hier ist eine detailliertere Version </h2><br>  2016 Jahr.  Deep Learning ist allgegenwärtig.  Die Bilderkennung kann dank gefalteter neuronaler Netze als gelöste Aufgabe angesehen werden, und meine Forschungsinteressen streben nach neuronalen Netzen mit Gedächtnis und verstärktem Lernen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa6/7e2/2de/aa67e22de1d4c2eb58f415beb61628e9.png"><br><br>  Insbesondere in der Arbeit der Autoren von Google Deepmind wurde gezeigt, dass es möglich ist, das Niveau einer Person in verschiedenen Spielen für den Atari 2600 (Heimspielkonsole, veröffentlicht 1977) zu erreichen oder sogar zu übertreffen, indem ein einfacher Lernalgorithmus verwendet wird, der von Deep Q-Neural Network unterstützt wird.  Und das alles einfach beim Betrachten des Gameplays.  Es erregte meine Aufmerksamkeit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/dd5/f97/e3edd5f97096170a43b775859b539087.gif"><br>  <i>Eines der Spiele mit dem Atari 2600, Breakout.</i>  <i>Die Maschine wurde unter Verwendung eines einfachen Verstärkungslernalgorithmus trainiert.</i>  <i>Nach Millionen von Iterationen begann der Computer besser zu spielen als Menschen.</i> <br><br>  Ich habe angefangen, mit Atari 2600-Spielen zu experimentieren. Breakout ist zwar beeindruckend, kann aber nicht als kompliziert bezeichnet werden.  Der Schwierigkeitsgrad kann anhand des Schwierigkeitsgrades in Übereinstimmung mit Ihren Aktionen (Joystick) und Ihren Ergebnissen (Punkten) bestimmt werden.  Das Problem tritt auf, wenn der Effekt lange warten muss. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/849/950/f41849950d6af5392b78e51f838ec707.gif"><br>  <i>Illustration eines Problems am Beispiel komplexerer Spiele.</i>  <i>Links - Ausbruch (ATARI 2600) [Der Autor hat sich geirrt, dies ist ein Pong-Spiel / ca.</i>  <i>trans.] mit einer sehr schnellen Antwort und einem schnellen Feedback.</i>  <i>Richtig - Mario Land (Nintendo Game Boy) liefert keine sofortigen Informationen über die Auswirkungen der Aktion. Zwischen zwei wichtigen Ereignissen können lange Zeiträume irrelevanter Beobachtungen auftreten.</i> <br><br>  Um das Lernen effektiver zu gestalten, kann man sich Versuche vorstellen, einen Teil des Wissens aus einfacheren Spielen zu übertragen.  Diese Aufgabe bleibt ungelöst und ist ein aktives Forschungsthema.  Eine kürzlich veröffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabe</a> von OpenAI versucht genau das zu messen. <br><br>  Die Fähigkeit, Wissen zu übertragen, würde nicht nur das Training beschleunigen - ich glaube, dass einige Lernprobleme ohne Grundwissen überhaupt nicht gelöst werden können.  Wir brauchen Dateneffizienz.  Nehmen Sie das Spiel Prince of Persia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/139/4d7/aa6/1394d7aa679b5a687d07cd97a5c68d4b.gif"><br><br>  Es gibt keine offensichtlichen Punkte darin. <br>  Es dauert 60 Minuten, um das Spiel zu beenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/c4d/5b7/11bc4d5b76ad0a167c31067edd0d30ea.gif"><br><br>  Ist es möglich, denselben Ansatz anzuwenden, der beim Schreiben der Arbeit am Atari 2600 verwendet wurde?  Wie wahrscheinlich ist es, dass Sie durch Drücken von Zufallstasten zum Ende gelangen? <br><br>  Diese Frage veranlasste mich, einen Beitrag zur Community zu leisten, die darin besteht, dieses Problem zu lösen.  Tatsächlich haben wir die Aufgabe von Hühnchen und Eiern - wir brauchen einen besseren Algorithmus, mit dem wir eine Nachricht übertragen können. Dies erfordert jedoch Forschung, und Experimente sind zeitaufwändig, da wir keinen effizienteren Algorithmus haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc9/009/5f1/fc90095f174e9052dfb677996562ac14.png"><br>  <i>Ein Beispiel für Wissenstransfer: Stellen Sie sich vor, wir haben zuerst gelernt, ein einfaches Spiel wie das linke zu spielen.</i>  <i>Dann speichern wir Konzepte wie „Rennen“, „Auto“, „Strecke“, „Gewinnen“ und lernen Farben oder dreidimensionale Modelle.</i>  <i>Wir argumentieren, dass gemeinsame Konzepte zwischen Spielen „übertragen“ werden können.</i>  <i>Die Ähnlichkeit von Spielen kann durch die Anzahl der zwischen ihnen übertragenen Kenntnisse bestimmt werden.</i>  <i>Zum Beispiel werden die Spiele Tetris und F1 nicht ähnlich sein.</i> <br><br>  Aus diesem Grund habe ich mich für den zweiten idealen Ansatz entschieden, um die anfängliche Verlangsamung zu vermeiden und das System drastisch zu beschleunigen.  Meine Ziele waren: <br>  - beschleunigte Umgebung (stellen Sie sich vor, dass Prince of Persia 100-mal schneller abgeschlossen werden kann) und gleichzeitiger Start von 100.000 Spielen. <br>  - eine Umgebung, die besser für die Forschung geeignet ist (wir konzentrieren uns auf Aufgaben, aber nicht auf vorläufige Berechnungen, wir haben Zugang zu verschiedenen Spielen). <br><br>  Anfangs dachte ich, dass der Leistungsengpass irgendwie von der Komplexität des Emulatorcodes abhängen könnte (zum Beispiel ist die Stella-Codebasis groß und basiert auf C ++ - Abstraktionen - nicht die beste Wahl für Emulatoren). <br><br><h2>  Konsolen </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/900/dc8/c32/900dc8c322e070709af65b0f89d55146.jpg"><br><br>  Insgesamt habe ich auf mehreren Plattformen gearbeitet, angefangen mit einem der ersten Spiele, die jemals erstellt wurden (zusammen mit dem Pong-Spiel) - den Arcade Space Invaders, Atari 2600, NES und Game Boy.  Und das alles wurde in C geschrieben. <br><br>  Ich habe es geschafft, eine maximale Bildrate von 2000-3000 pro Sekunde zu erreichen.  Um die Ergebnisse von Experimenten zu erhalten, benötigen wir Millionen oder Milliarden von Frames, daher war die Lücke riesig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/677/cd2/ebd/677cd2ebda80be7e5eace8380911c084.gif"><br>  <i>Space Invaders arbeiten im FPGA - Debugging-Modus mit niedriger Geschwindigkeit.</i>  <i>Der FPGA-Zähler zeigt die Anzahl der verstrichenen Taktzyklen an.</i> <br><br>  Und dann dachte ich - was wäre, wenn wir mit Eisen die richtige Umgebung beschleunigen könnten.  Zum Beispiel gingen die ursprünglichen Space Invaders mit einer Frequenz von 1 MHz an die 8080-CPU.  Ich habe es geschafft, eine 8080 40 MHz CPU auf einem 3 GHz Xeon Prozessor zu emulieren.  Nicht schlecht, aber nachdem ich das alles in das FPGA gesteckt hatte, stieg die Frequenz auf 400 MHz.  Das bedeutete 24.000 FPS aus einem Stream - das entspricht einem 30-GHz-Xeon!  Habe ich erwähnt, dass Sie 100 8080-Prozessoren in ein durchschnittliches FPGA packen können?  Dies ergibt bereits 2,4 Millionen FPS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/82a/dd1/41582add164c44c52b01fdfec7160e20.gif"><br>  <i>Space Invaders mit 100 MHz Hardwarebeschleunigung, ein Viertel der vollen Geschwindigkeit</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/8a8/4e0/90d8a84e0053c30eb4b337b27c15dcfc.png"><br>  <i>Mehr als hundert Kerne im Xilinx Kintex 7045 FPGA (angezeigt durch helle Farben; der blaue Fleck in der Mitte ist die allgemeine Logik für die Demonstration).</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c1/dc9/f93/4c1dc9f93c26391a762466a8216053f9.png"><br>  <i>Ungleichmäßiger Ausführungspfad</i> <br><br>  Sie fragen sich vielleicht, was ist mit der GPU?  Kurz gesagt, wir brauchen Parallelität wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIMD</a> , nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIMD</a> .  Als Student habe ich einige Zeit an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung einer</a> Monte-Carlo-Baumsuche auf einer GPU gearbeitet (eine solche Suche wurde in AlphaGo verwendet). <br><br>  Zu dieser Zeit habe ich unzählige Stunden damit verbracht, die GPU und andere Hardwarekomponenten nach dem SIMD-Prinzip (IBM Cell, Xeon Phi, AVX-CPU) zum Ausführen eines solchen Codes zum Laufen zu bringen, und es wurde nichts daraus.  Vor einigen Jahren begann ich zu denken, dass es schön wäre, unabhängig Hardware entwickeln zu können, die speziell für die Lösung von Problemen im Zusammenhang mit dem Verstärkungstraining entwickelt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/730/b57/479730b5758c7bbccecd7be47f8ca310.gif"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d98/4ee/ad9/d984eead9cd837908580a0545210918b.png"><br>  <i>MIMD-Parallelität</i> <br><br><h2>  ATARI 2600, NES oder Game Boy? </h2><br>  Bei 8080 implementierte ich Space Invaders, NES, 2600 und Game Boy.  Und hier sind einige Fakten über sie und die Vorteile von jedem von ihnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/475/be6/f26475be6707be383030b9e116222a71.png"><br>  <i>NES Pacman</i> <br><br>  Space Invaders waren nur ein Aufwärmen.  Wir haben es geschafft, sie zum Laufen zu bringen, aber es war nur ein Spiel, daher war das Ergebnis nicht sehr nützlich. <br><br>  Der Atari 2600 ist tatsächlich der Standard in der Forschung zum verstärkten Lernen.  Der MOS 6507-Prozessor ist eine vereinfachte Version des berühmten 6502, sein Design ist eleganter und effizienter als der des 8080. Ich habe mich für 2600 entschieden, nicht nur wegen bestimmter Einschränkungen in Bezug auf Spiele und deren Grafik. <br><br>  Ich habe auch NES (Nintendo Entertainment System) implementiert, das die CPU mit 2600 teilt. Es gibt Spiele, die viel besser als 2600 sind. Beide Konsolen leiden jedoch unter einer übermäßig komplexen Grafikverarbeitungspipeline und mehreren Kassettenformaten, die unterstützt werden müssen. <br><br>  In der Zwischenzeit habe ich den Nintendo Game Boy wiederentdeckt.  Und das war es, wonach ich gesucht habe. <br><br><h2>  Warum ist der Game Boy so cool? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/447/518/78d/44751878d5be5df4e754fdee7913d224.jpg" alt="Bild"><br>  <i>1049 klassische Spiele und 576 Spiele für Game Boy Color</i> <br><br>  Insgesamt mehr als 1000 Spiele, eine sehr große Vielfalt, hohe Qualität, einige davon sind recht komplex (Prince), Spiele können gruppiert und komplexiert werden, um den Wissenstransfer und das Training zu erforschen (zum Beispiel gibt es Optionen für Tetris, Rennspiele, Mario).  Um das Spiel Prince of Persia zu lösen, müssen Sie möglicherweise Wissen aus einem anderen ähnlichen Spiel übertragen, in dem Punkte klar angegeben sind (in Prince ist dies nicht der Fall). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ff/f8e/9e7/5fff8e9e75b38f13eb5161b316c76030.gif"><br>  <i>Nintendo Game Boy ist meine Lieblingsforschungsplattform für Wissenstransfer.</i>  <i>In der Grafik habe ich versucht, die Spiele nach Komplexität (subjektiv) und Ähnlichkeit zu gruppieren (Konzepte wie Rennen, Springen, Schießen, verschiedene Spiele wie Tetris; hat jemand HATRIS gespielt?).</i> <br><br>  Der klassische Game Boy verfügt über einen sehr einfachen Bildschirm (160 x 144, 2-Bit-Farbe), sodass die Vorverarbeitung einfach wird und Sie sich auf wichtige Dinge konzentrieren können.  Bei 2600 haben sogar einfache Spiele viele Farben.  Darüber hinaus werden Objekte in Game Boy viel besser dargestellt, ohne zu blinken und ohne dass maximal zwei aufeinanderfolgende Frames benötigt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/9ae/843/7409ae843366b71257755bc7701af3c8.gif"><br><br>  Kein verrücktes Speicherlayout wie NES oder 2600. Die meisten Spiele können mit 2-3 Mappern verwendet werden. <br><br>  Kompakter Code - Ich habe es geschafft, den gesamten Emulator in C in nicht mehr als 700 Codezeilen einzupassen, und meine Verilog-Implementierung passt in 500 Zeilen. <br><br>  Es gibt dieselbe einfache Version von Space Invaders wie in der Spielhalle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10f/5d0/838/10f5d0838acb88b453ff82b778389265.gif"><br><br>  Und hier ist er, mein 1989er Dot-Matrix-Game Boy und die FPGA-Version, die über HDMI auf einem 4K-Bildschirm funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/dd5/77d/ca2dd577d1711be2ddb2d3426dc07c39.png"><br><br>  Und hier ist, was mein alter Game Boy nicht kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/343/e65/d45/343e65d45de2b5bac8bd31ffccb7be6e.gif"><br>  <i>Tetris beschleunigt mit Eisen - Aufnahme vom Bildschirm in Echtzeit, die Geschwindigkeit beträgt 1/4 des Maximums.</i> <br><br><h2>  Gibt es einen wirklichen Vorteil dafür? </h2><br>  Ja, gibt es.  Bisher habe ich das System unter einfachen Bedingungen mit einem externen Netzwerk von Regeln getestet, die mit einzelnen Game Boys interagieren.  Insbesondere habe ich den A3C-Algorithmus (Advantage Actor Critic) verwendet und möchte ihn in einem separaten Beitrag beschreiben.  Mein Kollege hat es über FPGA mit dem Faltungsnetzwerk verbunden, und es funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/202/75a/cb720275a2f42cf3e17fc28167ec55f0.png"><br>  <i>Wie FGPA mit einem neuronalen Netzwerk kommuniziert</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/f65/160/da4f6516036832a572de98a4bec081e4.png"><br>  <i>Verteiltes A3C</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/2b2/607/c3c2b26079064aa7ab6fee6f4a7f373e.gif"><br>  <i>Mario Land: Ausgangszustand.</i>  <i>Ein zufälliger Tastendruck bringt uns nicht weit.</i>  <i>Die obere rechte Ecke zeigt die verbleibende Zeit.</i>  <i>Wenn wir Glück haben, beenden wir das Spiel schnell, nachdem wir die Gumba berührt haben.</i>  <i>Wenn nicht, dauert es 400 Sekunden, um zu „verlieren“.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/088/0a9/618/0880a9618a01a45c6358469604dea92d.gif"><br>  <i>Mario Land: Nach einer Stunde Spiel lernte Mario laufen, springen und öffnete sogar einen geheimen Raum, der in eine Pfeife krabbelte.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3b/d37/a82/b3bd37a82e9692319784667a7be9c13c.gif"><br>  <i>Pac Man: Nach ungefähr einer Stunde Training konnte das neuronale Netzwerk das ganze Spiel sogar einmal beenden (indem es alle Punkte verzehrte).</i> <br><br><h2>  Fazit </h2><br>  Ich würde gerne glauben, dass das nächste Jahrzehnt die Zeit sein wird, in der Supercomputing und KI sich finden.  Ich hätte gerne Hardware, mit der ich mich auf ein bestimmtes Niveau einstellen kann, um mich an den gewünschten AI-Algorithmus anzupassen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d06/248/162/d062481627eb1e355c5488ead2ca7ef7.png"><br>  <i>Nächstes Jahrzehnt</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code für Game Boy in C.</a> <br><br><h2>  Debuggen </h2><br>  Die Leute fragen mich oft: Was war am schwierigsten?  Das war's - das ganze Projekt war ziemlich schmerzhaft.  Für den Anfang gibt es keine Spezifikation für einen Game Boy.  Alles, was wir gelernt haben, haben wir dank Reverse Engineering erhalten, dh wir haben eine Zwischenaufgabe wie ein Spiel gestartet und beobachtet, wie es ausgeführt wird.  Dies unterscheidet sich stark vom Standard-Software-Debugging, da hier die Hardware debuggt, auf der die Programme ausgeführt werden.  Ich musste mir verschiedene Wege einfallen lassen, um dies zu erreichen.  Und ich habe darüber gesprochen, wie schwierig es ist, einen Prozess zu überwachen, wenn er mit einer Frequenz von 100 MHz läuft.  Oh, und da ist kein Druck. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9df/173/ab1/9df173ab1b05d831461a16152646be72.png"><br>  <i>Ein Ansatz zur Implementierung einer CPU besteht darin, Anweisungen zu ihren Funktionen zu gruppieren.</i>  <i>Mit 6502 ist es viel einfacher.</i>  <i>LR35092 hat viel von allem „zufälligen“ Unsinn vollgestopft und es gibt viele Ausnahmen.</i>  <i>Ich habe diese Tabelle bei der Arbeit mit dem CPU Game Boy verwendet.</i>  <i>Ich habe eine gierige Strategie angewendet - ich habe die größte Anweisung genommen, sie implementiert, gelöscht und dann wiederholt.</i>  <i>1/4 der Anweisungen ist ALU, 1/4 ist das Laden von Registern, was ziemlich schnell implementiert werden kann.</i>  <i>Auf der anderen Seite des Spektrums gibt es alle möglichen Dinge, wie zum Beispiel „Upload von HL nach SP mit einem Vorzeichen“, die separat verarbeitet werden mussten.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96b/ec9/38b/96bec938bbac5dbab9b8c71f6024d31b.jpg"><br>  <i>Debugging: Führen Sie den Code auf der Hardware aus, die Sie debuggen, schreiben Sie ein Protokoll Ihrer Implementierung und zusätzliche Informationen (hier wird ein Vergleich des Verilog-Codes links mit meinem C-Emulator rechts angezeigt).</i>  <i>Führen Sie dann diff für die Protokolle aus, um Inkonsistenzen zu finden (blau).</i>  <i>Einer der Gründe für die Verwendung der Automatisierung ist, dass ich in vielen Fällen nach Millionen von Ausführungszyklen Probleme fand, als ein einzelnes CPU-Flag einen Schneeballeffekt verursachte.</i>  <i>Ich habe verschiedene Ansätze ausprobiert, und dieser erwies sich als der effektivste.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/bea/455/e50bea45577d7225024a0aa66174f9bd.png"><br>  <i>Sie brauchen viel Kaffee!</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/d2e/4eb/196d2e4ebf91bda8e1943dc5e7f81a89.png"><br>  <i>Diese Bücher sind 40 Jahre alt.</i>  <i>Es war erstaunlich, sie zu durchsuchen und die Welt der Computer mit den Augen dieser Benutzer zu betrachten - ich fühlte mich wie ein Gast aus der Zukunft.</i> <br><br><h2>  OpenAI-Forschungsanfrage </h2><br>  Zuerst wollte ich mit Spielen in Bezug auf das Gedächtnis arbeiten, wie in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> von OpenAI beschrieben. <br><br>  Überraschenderweise war es unerwartet schwierig, Q-Learning für Eingaben, die Speicherzustände darstellen, zum Laufen zu bringen. <br><br>  Dieses Projekt hat möglicherweise keine Lösung.  Es wäre unerwartet herauszufinden, dass Q-Learning in Atari niemals erfolgreich mit dem Gedächtnis arbeiten wird, aber es besteht die Möglichkeit, dass diese Aufgabe ziemlich schwierig wird. <br><br>  Angesichts der Tatsache, dass die Spiele auf Atari nur 128 b Speicher verwendeten, schien es sehr attraktiv, diese 128 b anstelle von Vollbildrahmen zu verarbeiten.  Ich habe gemischte Ergebnisse erzielt und angefangen, es herauszufinden. <br><br>  Und obwohl ich nicht beweisen kann, dass es unmöglich ist, aus dem Gedächtnis zu lernen, kann ich zeigen, dass die Annahme, dass das Gedächtnis den vollen Zustand des Spiels widerspiegelt, falsch ist.  Die Atari 2600-CPU (6507) verwendet 128 b Speicher, hat jedoch weiterhin Zugriff auf zusätzliche Register, die sich auf einem separaten Schaltkreis befinden (TIA, Adapter für ein Fernsehgerät, so etwas wie eine GPU).  Diese Register werden zum Speichern und Verarbeiten von Informationen über Objekte (Schläger, Rakete, Ball, Kollision) verwendet.  Mit anderen Worten, sie sind nicht zugänglich, wenn wir nur die Erinnerung betrachten.  NES und Game Boy verfügen außerdem über zusätzliche Register, mit denen Sie den Bildschirm steuern und scrollen können.  Nur ein Speicher gibt nicht den vollständigen Status des Spiels wieder. <br><br>  Nur der 8080 speichert Daten direkt im Videospeicher, sodass Sie den vollständigen Status des Spiels extrahieren können.  In anderen Fällen sind die "GPU" -Register außerhalb des RAM zwischen der CPU und dem Bildschirmpuffer verbunden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b9/d23/019/0b9d2301998c1cc9dcf414c36fe8e1e3.png"><br><br>  Eine interessante Tatsache: Wenn Sie die Geschichte der GPU untersuchen, ist der 8080 möglicherweise der erste „Grafikbeschleuniger“ - er verfügt über ein externes Schieberegister, mit dem Sie Space Invaders mit einem einzigen Befehl verschieben können, wodurch die CPU entlastet wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HyzD8pNlpwI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/16c/2d0/89916c2d015f8b881ec16411906ab2aa.png"><br>  Eof </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435506/">https://habr.com/ru/post/de435506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435496/index.html">Tesla klagte wegen eines Unfalls, bei dem Fahrer und Beifahrer des Modells S starben</a></li>
<li><a href="../de435498/index.html">vCloud Director Extender: Migration</a></li>
<li><a href="../de435500/index.html">Biometrische Handschuhe im Motorsport</a></li>
<li><a href="../de435502/index.html">Die Studie enthüllte die Vor- und Nachteile des Perfektionismus</a></li>
<li><a href="../de435504/index.html">Handmonster im Kampf um Sauberkeit: Xiaomi manuelle Staubsaugerauswahl</a></li>
<li><a href="../de435508/index.html">Wie mache ich die besten Computer in Russland? Interview mit Artyom Smirnov von HYPERPC</a></li>
<li><a href="../de435510/index.html">Mikroelektronik, Neurophysiologie und maschinelles Lernen schütteln, aber nicht mischen</a></li>
<li><a href="../de435512/index.html">Royole Entwickler zeigen faltbares flexibles Smartphone</a></li>
<li><a href="../de435514/index.html">In Russland entwickeln sie einen Prozessor zur Beschleunigung neuronaler Netze</a></li>
<li><a href="../de435520/index.html">Wir schreiben unsere Programmiersprache, Teil 3: Übersetzerarchitektur. Analyse von Sprachstrukturen und mathematischen Ausdrücken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>