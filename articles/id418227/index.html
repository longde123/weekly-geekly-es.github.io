<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏾 🤸🏽 🐷 Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Kotak Native Client, Bagian 3 😤 🔝 💿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Kotak Native Client, Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418227/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: “Pendahuluan: model ancaman” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: “Buffer Overflows: Exploits and Protection” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: “Pemisahan Hak Istimewa” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: “Peluang” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: “Kotak Pasir Klien Asli” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Ada satu peringatan dalam aturan <b>C4</b> .  Anda tidak dapat "melompati" akhir program.  Hal terakhir yang dapat Anda lompati adalah instruksi terakhir.  Jadi aturan ini menjamin bahwa ketika program dieksekusi dalam proses "mesin", tidak akan ada perbedaan. <br><br>  Aturan <b>C5</b> mengatakan bahwa tidak mungkin ada instruksi yang lebih besar dari 32 byte.  Kami menganggap varian aturan ini ketika kami berbicara tentang banyaknya ukuran instruksi hingga 32 byte, jika tidak, Anda dapat melompat ke tengah instruksi dan membuat masalah dengan pemanggilan sistem, yang dapat "bersembunyi" di sana. <br><br>  Peraturan <b>C6</b> menyatakan bahwa semua instruksi yang tersedia dapat dibongkar dari awal.  Dengan demikian, ini memastikan bahwa kita melihat setiap instruksi dan dapat memeriksa semua instruksi yang berjalan ketika program berjalan. <br><br>  Aturan <b>C7</b> menyatakan bahwa semua lompatan langsung benar.  Sebagai contoh, Anda melompat langsung ke bagian instruksi di mana target diindikasikan, dan meskipun bukan kelipatan 32, itu masih instruksi yang tepat yang pembongkaran diterapkan dari kiri ke kanan. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>Audiens:</b> apa perbedaan antara <b>C5</b> dan <b>C3</b> ? <br><br>  <b>Profesor:</b> Saya pikir <b>C5</b> mengatakan bahwa jika saya memiliki instruksi multi-byte, itu tidak dapat melewati batas alamat yang berdekatan.  Misalkan saya memiliki aliran instruksi, dan ada alamat 32 dan alamat 64. Jadi, sebuah instruksi tidak dapat melewati batas kelipatan 32 byte, yaitu, ia tidak boleh dimulai dengan alamat kurang dari 64 dan diakhiri dengan alamat yang lebih besar dari 64. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  Inilah yang dikatakan aturan <b>C5</b> .  Karena jika tidak, setelah melakukan lompatan multiplisitas 32, Anda dapat masuk ke tengah instruksi lain, di mana tidak diketahui apa yang terjadi. <br><br>  Dan aturan <b>C3</b> adalah analog dari larangan ini di sisi lompatan.  Ini menyatakan bahwa setiap kali Anda melompat, panjang lompatan Anda harus kelipatan 32. <br><br>  <b>C5</b> juga mengklaim bahwa apa pun dalam kisaran alamat yang merupakan kelipatan 32 adalah instruksi yang aman. <br><br>  Setelah membaca daftar aturan-aturan ini, saya merasa campur aduk, karena saya tidak bisa menilai apakah aturan-aturan ini cukup, artinya, daftar itu minimal atau lengkap. <br>  Jadi, mari kita pikirkan tentang pekerjaan rumah yang harus Anda selesaikan.  Saya pikir sebenarnya ada kesalahan dalam operasi <b>Klien Asli</b> ketika menjalankan beberapa instruksi rumit di kotak pasir.  Saya percaya bahwa mereka tidak memiliki pengkodean panjang yang benar, yang dapat menyebabkan sesuatu yang buruk, tetapi saya tidak ingat persis apa kesalahannya. <br><br>  Misalkan validator kotak pasir salah mendapatkan panjang semacam instruksi.  Apa yang buruk bisa terjadi dalam kasus ini?  Bagaimana Anda menggunakan slip ini? <br><br>  <b>Pemirsa:</b> misalnya, Anda dapat menyembunyikan panggilan sistem atau <b>ret</b> pernyataan kembali. <br><br>  <b>Profesor:</b> ya.  Misalkan ada beberapa versi mewah dari pernyataan <b>DAN</b> yang Anda tulis.  Mungkin saja validator salah dan menganggap bahwa panjangnya 6 byte dengan panjang sebenarnya 5 byte. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  Apa yang akan terjadi  Validator menganggap panjang instruksi ini menjadi 6 byte dan memiliki instruksi lain yang valid di belakangnya.  Tetapi prosesor, ketika meluncurkan kode, menggunakan panjang sebenarnya dari instruksi, yaitu 5 byte.  Sebagai hasilnya, kami memiliki byte gratis di akhir pernyataan <b>AND</b> , tempat kami dapat memasukkan panggilan sistem dan menggunakannya untuk keuntungan kami.  Dan jika kita memasukkan byte <b>CD di</b> sini, itu akan seperti awal instruksi lain.  Selanjutnya, kita akan meletakkan sesuatu dalam rentang 6-byte berikutnya, dan itu akan terlihat seperti instruksi yang dimulai dengan byte <b>CD</b> , meskipun sebenarnya itu adalah bagian dari instruksi <b>AND</b> .  Setelah itu, kita dapat melakukan panggilan sistem dan "melarikan diri" dari kotak pasir. <br><br>  Dengan demikian, validator <b>Native Client</b> harus menyinkronkan tindakannya dengan tindakan <b>CPU</b> , yaitu, “tebak” persis bagaimana prosesor akan menginterpretasikan setiap instruksi.  Dan ini harus di setiap tingkat kotak pasir, yang cukup sulit untuk diterapkan. <br><br>  Bahkan, ada kesalahan menarik lainnya di <b>Native Client</b> .  Salah satunya adalah pembersihan lingkungan prosesor yang salah saat masuk ke <b>Layanan Tepercaya Tepercaya</b> .  Saya pikir kita akan membicarakan ini sebentar lagi.  Tetapi <b>Runtime Layanan Tepercaya</b> pada dasarnya akan bekerja dengan set register <b>CPU</b> yang sama yang dirancang untuk menjalankan modul yang tidak terpercaya.  Jadi jika prosesor lupa untuk menghapus sesuatu atau reboot, runtime dapat diakali dengan mempertimbangkan modul yang tidak dapat diandalkan sebagai aplikasi tepercaya dan melakukan sesuatu yang seharusnya tidak dilakukan atau itu bukan maksud dari pengembang. <br><br>  Jadi di mana kita sekarang?  Saat ini, kami memahami cara membongkar semua instruksi dan cara mencegah pelaksanaan instruksi yang dilarang.  Sekarang mari kita lihat bagaimana kita menyimpan memori dan tautan untuk kode dan data dalam modul <b>Native Client</b> . <br><br>  Untuk alasan kinerja, para <b>klien Native</b> mulai menggunakan dukungan perangkat keras untuk memastikan bahwa penyimpanan memori dan tautan tidak benar-benar menyebabkan banyak overhead.  Tetapi sebelum mempertimbangkan dukungan perangkat keras yang mereka gunakan, saya ingin mendengar saran, bagaimana saya bisa melakukan hal yang sama tanpa dukungan perangkat keras?  Bisakah kita memberikan akses ke semua proses memori dalam batas yang ditentukan oleh mesin sebelumnya? <br><br>  <b>Pemirsa:</b> Anda dapat instruksi instrumen untuk menghapus semua bit tinggi. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Profesor:</b> ya, itu benar.  Faktanya, kita melihat bahwa kita memiliki instruksi <b>DAN</b> ini di sini, dan setiap kali, misalnya, kita melompat ke suatu tempat, itu akan membersihkan bit-bit rendah.  Tetapi jika kita ingin menyimpan semua kode yang mungkin berjalan dalam 256 MB yang rendah, kita cukup mengganti atribut <b>f</b> pertama dengan <b>0</b> dan mendapatkan <b>$ 0x0fffffe0</b> alih-alih <b>$ 0xffffffe0</b> .  Ini membersihkan bit-bit rendah dan menetapkan batas atas 256 MB. <br><br>  Jadi, ini melakukan persis apa yang Anda tawarkan, memastikan bahwa setiap kali Anda melompat, Anda berada dalam 256 MB.  Dan fakta bahwa kami melakukan pembongkaran juga memungkinkan untuk memverifikasi bahwa semua lompatan langsung berada dalam jangkauan. <br><br>  Alasan mengapa mereka tidak melakukan ini untuk kode mereka adalah bahwa pada platform <b>x86</b> Anda dapat dengan sangat mudah mengkodekan <b>AND</b> , di mana semua bit teratas adalah 1. Ini berubah menjadi keberadaan instruksi 3-byte untuk <b>DAN</b> dan instruksi 2-byte untuk lompat.  Jadi, kami memiliki biaya tambahan 3 byte.  Tetapi jika Anda memerlukan bit tinggi non-unit, seperti ini bukan <b>0</b> <b>f</b> , maka Anda tiba-tiba memiliki instruksi 5-byte.  Karena itu, saya pikir dalam hal ini mereka khawatir tentang overhead. <br><br>  <b>Hadirin:</b> Apakah ada masalah dengan adanya beberapa instruksi yang meningkatkan versi yang Anda coba dapatkan?  Artinya, Anda dapat mengatakan bahwa instruksi Anda mungkin memiliki bias konstan atau sesuatu seperti itu? <br><br>  <b>Profesor:</b> Saya kira begitu.  Anda mungkin akan melarang instruksi yang melompat ke beberapa formula alamat kompleks dan hanya akan mendukung instruksi yang langsung menuju ke nilai ini, dan nilai ini selalu mendapat <b>AND</b> . <br><br>  <b>Pemirsa:</b> lebih penting untuk akses ke memori daripada ... <br><br>  <b>Profesor:</b> ya, karena itu hanya kode.  Dan untuk mengakses memori pada platform <b>x86</b> , ada banyak cara aneh untuk mengakses lokasi memori tertentu.  Biasanya, Anda harus terlebih dahulu menghitung lokasi memori, lalu menambahkan <b>DAN</b> tambahan <b>,</b> dan hanya kemudian melakukan akses.  Saya pikir ini adalah alasan sebenarnya atas kekhawatiran mereka tentang penurunan kinerja karena penggunaan toolkit ini. <br><br>  Pada platform <b>x86</b> , atau setidaknya pada platform 32-bit yang dijelaskan dalam artikel, mereka menggunakan dukungan perangkat keras alih-alih membatasi kode dan data alamat yang merujuk ke modul yang tidak terpercaya. <br><br>  Mari kita lihat tampilannya sebelum mencari tahu bagaimana menggunakan modul <b>NaCl</b> di kotak pasir.  Perangkat keras ini disebut segmentasi.  Itu muncul bahkan sebelum platform <b>x86</b> mendapat file swap.  Pada platform <b>x86</b> , tabel perangkat keras yang didukung ada selama proses.  Kami menyebutnya tabel deskriptor segmen.  Ini adalah sekelompok segmen yang diberi nomor mulai dari 0 hingga akhir tabel dengan ukuran berapa pun.  Ini adalah sesuatu seperti deskriptor file di <b>Unix</b> , kecuali bahwa setiap entri terdiri dari 2 nilai: basis <b>dasar</b> dan <b>panjang</b> panjang. <br><br>  Tabel ini memberi tahu kita bahwa kita memiliki sepasang segmen, dan setiap kali kita merujuk ke segmen tertentu, ini dalam arti berarti kita berbicara tentang sepotong memori yang dimulai dari alamat <b>basis basis</b> dan berlanjut sepanjang <b>panjangnya</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  Ini membantu kami menjaga batasan memori pada platform <b>x86</b> , karena setiap instruksi, yang mengakses memori, merujuk ke segmen tertentu dalam tabel ini. <br><br>  Misalnya, ketika kita menjalankan <b>mov (% eax), (% ebx)</b> , yaitu, kita memindahkan nilai memori dari sebuah pointer yang disimpan dalam register <b>EAX</b> ke pointer lain yang disimpan dalam register <b>EBX</b> , program mengetahui apa alamat awal dan apa alamat akhir itu. mengingat, dan akan menyimpan nilai di alamat kedua. <br><br>  Tetapi sebenarnya, pada platform <b>x86</b> , ketika kita berbicara tentang memori, ada hal implisit yang disebut deskriptor segmen, mirip dengan deskriptor file di <b>Unix</b> .  Ini hanya indeks dalam tabel deskriptor, dan kecuali dinyatakan sebaliknya, maka setiap kode operasi berisi segmen default. <br><br>  Oleh karena itu, ketika Anda menjalankan <b>mov (% eax)</b> , ini merujuk ke <b>% ds</b> , atau ke register segmen data, yang merupakan register khusus di prosesor Anda.  Jika saya ingat dengan benar, itu adalah bilangan bulat 16-bit yang menunjuk ke tabel deskriptor ini. <br><br>  Dan hal yang sama berlaku untuk <b>(% ebx)</b> - mengacu pada pemilih segmen <b>% ds yang</b> sama.  Faktanya, di <b>x86</b> kami memiliki sekelompok 6 penyeleksi kode: <b>CS, DS, ES, FS, GS</b> dan <b>SS</b> .  <b>Pemilih panggilan CS</b> secara implisit digunakan untuk menerima instruksi.  Jadi, jika penunjuk instruksi Anda menunjuk ke sesuatu, maka itu merujuk ke yang memilih pemilih segmen <b>CS</b> . <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  Sebagian besar referensi data secara implisit menggunakan <b>DS</b> atau <b>ES</b> , <b>FS</b> dan <b>GS</b> menunjukkan beberapa hal khusus, dan <b>SS</b> selalu digunakan untuk operasi tumpukan.  Dan jika Anda melakukan <b>push &amp; pop</b> , maka mereka secara implisit berasal dari pemilih segmen ini.  Ini adalah mekanika yang agak kuno, tetapi ternyata sangat berguna dalam kasus khusus ini. <br><br>  Jika Anda mendapatkan akses ke beberapa alamat, misalnya, di pemilih <b>% ds: addr</b> , perangkat keras akan mengarahkannya ke operasi dengan tabel <b>adrr + T [% ds] .base</b> .  Ini berarti bahwa ia akan mengambil alamat panjang modul dari tabel yang sama.  Jadi, setiap kali Anda mengakses memori, ia memiliki database pemilih segmen dalam bentuk entri tabel deskriptor, dan dibutuhkan alamat yang Anda tentukan dan cocokkan dengan panjang segmen yang sesuai. <br><br>  <b>Pemirsa:</b> jadi mengapa tidak digunakan, misalnya, untuk melindungi buffer? <br><br>  <b>Profesor:</b> ya, itu pertanyaan yang bagus!  Bisakah kita menggunakan ini untuk melindungi dari buffer overflows?  Misalnya, untuk setiap buffer yang kita miliki, Anda dapat meletakkan basis buffer di sini, dan di sana ukuran buffer. <br><br>  <b>Hadirin:</b> bagaimana jika Anda tidak perlu menaruhnya di meja sebelum Anda ingin menulisnya?  Anda tidak perlu berada di sana terus-menerus. <br><br>  <b>Profesor:</b> ya.  Oleh karena itu, saya berpikir bahwa alasan bahwa pendekatan ini tidak sering digunakan untuk melindungi terhadap buffer overflow adalah karena jumlah catatan dalam tabel ini tidak dapat melebihi 2 pada kekuatan 16, karena deskriptor panjangnya 16 bit, tetapi sebenarnya pada kenyataannya, beberapa bit lagi digunakan untuk hal-hal lain.  Jadi sebenarnya Anda hanya bisa menempatkan 2 di kekuatan catatan ke-13 dalam tabel ini.  Oleh karena itu, jika Anda memiliki array data yang berukuran lebih dari <sup>13</sup> dalam kode Anda, tabel ini mungkin meluap. <br><br>  Selain itu, akan aneh bagi kompiler untuk secara langsung mengelola tabel ini, karena biasanya ia dimanipulasi menggunakan panggilan sistem.  Anda tidak dapat langsung menulis ke tabel ini, pertama-tama Anda perlu membuat panggilan sistem ke sistem operasi, setelah itu sistem operasi akan menempatkan catatan dalam tabel ini.  Oleh karena itu, saya pikir sebagian besar kompiler tidak akan mau berurusan dengan sistem manajemen buffer memori yang kompleks. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  Omong-omong, <b>Multex</b> menggunakan pendekatan ini: ia memiliki 2 <sup>18</sup> catatan untuk berbagai segmen dan 2 <sup>18</sup> catatan untuk kemungkinan offset.  Dan setiap fragmen perpustakaan umum atau fragmen memori adalah segmen yang terpisah.  Mereka semua diperiksa untuk jangkauan dan karenanya tidak dapat digunakan pada tingkat variabel. <br><br>  <b>Hadirin:</b> Agaknya, kebutuhan konstan untuk menggunakan kernel akan memperlambat proses. <br><br>  <b>Profesor:</b> ya, itu benar.  Jadi kita akan memiliki overhead karena fakta bahwa ketika buffer baru tiba-tiba dibuat di stack, kita perlu membuat system call untuk menambahkannya. <br><br>  Jadi berapa banyak elemen ini yang benar-benar menggunakan mekanisme segmentasi?  Anda bisa menebak cara kerjanya.  Saya pikir, secara default, semua segmen di <b>x86 ini</b> memiliki basis yang sama dengan 0, dan panjangnya adalah 2 hingga 32. Dengan demikian, Anda dapat mengakses seluruh rentang memori yang Anda inginkan.  Oleh karena itu, untuk <b>NaCl,</b> mereka menyandikan basis 0 dan mengatur panjangnya menjadi 256 megabita.  Kemudian mereka menunjuk ke semua register dari 6 penyeleksi segmen dalam catatan ini untuk area 256 MB.  Jadi, setiap kali peralatan mengakses memori, ia memodifikasinya dengan offset 256 MB.  Jadi kemampuan untuk mengubah modul akan dibatasi hingga 256 MB. <br><br>  Saya pikir Anda sekarang mengerti bagaimana perangkat keras ini didukung dan cara kerjanya, sehingga Anda bisa menggunakan pemilih segmen ini. <br>  Jadi apa yang salah jika kita menerapkan rencana ini?  Bisakah kita melompat keluar dari pemilih segmen dalam modul yang tidak dipercaya?  Saya pikir satu hal yang perlu diperhatikan adalah register ini seperti register biasa, dan Anda dapat memindahkan nilai ke dalam dan ke luarnya.  Oleh karena itu, Anda harus memastikan bahwa modul yang tidak dipercaya tidak mendistorsi register pemilih segmen ini.  Karena di suatu tempat di tabel deskriptor mungkin ada catatan, yang juga merupakan deskriptor segmen sumber untuk proses yang memiliki basis 0 dan panjang hingga 2 <sup>32</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  Jadi, jika modul yang tidak dapat diandalkan mampu mengubah <b>CS</b> , atau <b>DS</b> , atau <b>ES</b> , atau penyeleksi mana pun sehingga mereka mulai menunjuk ke sistem operasi asli ini, yang mencakup semua ruang alamat Anda, maka Anda dapat membuat tautan memori ke segmen ini dan " melompat keluar dari kotak pasir. <br><br>  Dengan demikian, <b>Klien Asli</b> harus menambahkan beberapa instruksi lagi ke daftar terlarang ini.  Saya pikir mereka melarang semua instruksi seperti <b>mov% ds, es,</b> dan sebagainya.  Karenanya, sekali di kotak pasir, Anda tidak dapat mengubah segmen yang dirujuk oleh beberapa hal.  Pada platform <b>x86,</b> instruksi untuk mengubah tabel deskriptor segmen adalah hak istimewa, tetapi mengubah <b>ds, es</b> sendiri <b>,</b> dll.  Tabel ini benar-benar tidak terjangkau. <br><br>  <b>Pemirsa:</b> dapatkah Anda menginisialisasi tabel sehingga panjang nol ditempatkan di semua slot yang tidak digunakan? <br><br>  <b>Profesor:</b> ya.  Anda dapat mengatur panjang tabel untuk sesuatu di mana tidak ada slot yang tidak digunakan.  Ternyata Anda benar-benar membutuhkan slot tambahan ini yang berisi 0 dan 2 <sup>32</sup> , karena lingkungan <b>runtime tepercaya</b> harus dimulai di segmen ini dan mendapatkan akses ke seluruh rentang memori.  Jadi entri ini diperlukan agar lingkungan <b>runtime</b> tepercaya berfungsi. <br><br>  Hadirin: apa yang dibutuhkan untuk mengubah panjang output dari tabel? <br>  Profesor: Anda harus memiliki hak akses root.  <b>Linux</b> sebenarnya memiliki sistem yang dinamakan <b>mod_ldt ()</b> untuk tabel deskriptor lokal, yang memungkinkan setiap proses untuk memodifikasi tabelnya sendiri, yaitu, sebenarnya ada satu tabel untuk setiap proses.  Tetapi pada platform <b>x86</b> ini lebih rumit, ada tabel global dan lokal.  Tabel lokal untuk proses tertentu dapat diubah. <br><br>  Sekarang mari kita coba mencari tahu bagaimana kita melompat dan melompat dari proses eksekusi <b>Native Client</b> atau melompat keluar dari kotak pasir.  Apa artinya melompat keluar dari kita? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  Jadi, kita perlu menjalankan kode tepercaya ini, dan kode tepercaya ini "hidup" di suatu tempat di atas batas 256 MB.  Untuk melompat ke sana, kita harus membatalkan semua perlindungan yang <b>telah</b> diinstal oleh <b>Klien Asli</b> .  Pada dasarnya mereka turun untuk mengubah enam penyeleksi ini.  Saya pikir validator kami tidak akan menerapkan aturan yang sama untuk hal-hal yang berada di atas batas 256 MB, jadi ini cukup sederhana. <br><br>  Tapi kemudian kita perlu entah bagaimana melompat ke <b>runtime runtime tepercaya</b> dan menginstal ulang pemilih segmen ke nilai yang benar untuk segmen raksasa ini, mencakup ruang alamat seluruh proses - kisaran ini adalah dari 0 hingga 2 <sup>32</sup> .  Mereka menyebut mekanisme semacam itu yang ada di trampolin <b>Native Client</b> "trampoline" dan "springboards".  Mereka tinggal di modul 64k rendah.  Yang paling keren adalah "trampolin" dan "lompatan" ini adalah potongan-potongan kode yang terletak di bawah 64k ruang proses.  Ini berarti bahwa modul yang tidak dapat diandalkan ini dapat melompat ke sana, karena ini adalah alamat kode yang valid yang berada dalam batas 32 bit dan dalam 256 MB.  Jadi Anda bisa melompat ke trampolin ini. <br><br>    <b>Native Client</b>    «» - .  ,  <b>Native Client</b>       «»,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    «»,  «»  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          «»? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       «»    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         «»,      <b>trusted runtime</b>   256     <b>Native Client</b> . «»   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        «»,       - . <br><br>      <b>halt</b>    32-   «».        «»,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   «»    ? <br><br> <b>:</b> «»     0  256   .        64-     ,    ,       «»,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      «»?   ? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : «,      »!      <b>EAX</b> ,    <b>mov</b> ,  «»      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       «»? <br><br> <b>:</b> ,        ,         .   … <br><br> <b>:</b> ,   ,       —  ,       ,            0  2 <sup>32</sup> .   .         «»,                256 . <br><br>  ,      «»,          .  , «»    ,    .    ,   «»   . <br><br> <b>:</b>    «»   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     «»,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    «».  ,       <b>DS</b> ,  ,  <b>CS</b>   - . <br><br> ,    ,        <b>x86</b> ,           <b>Native Client</b> . <br><br> ,        -. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps   </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Belanda dan Amerika Serikat! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca tentang</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara Membangun Infrastruktur Bldg. </font><font style="vertical-align: inherit;">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418227/">https://habr.com/ru/post/id418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418217/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 1</a></li>
<li><a href="../id418219/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: Peluang, Bagian 2</a></li>
<li><a href="../id418221/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 3</a></li>
<li><a href="../id418223/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Kotak Pasir Klien Asli, Bagian 1</a></li>
<li><a href="../id418225/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Native Client Sandbox Bagian 2</a></li>
<li><a href="../id418229/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 8: Model Keamanan Jaringan, Bagian 1</a></li>
<li><a href="../id418233/index.html">BMW mnemonics untuk menemukan nilai batas</a></li>
<li><a href="../id418235/index.html">Saga yang diatur atau cara membangun transaksi bisnis dalam layanan dengan database per pola layanan</a></li>
<li><a href="../id418237/index.html">Mengembangkan Aplikasi Multi-Penyewa pada Platform SAP Cloud di Neo, Bagian 2: Otorisasi dan Otentikasi</a></li>
<li><a href="../id418239/index.html">48 megapiksel untuk smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>