<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗽 🏇🏾 🤙🏾 Expérience dans la mise en œuvre de l'automatisation dans le processus de test manuel sur l'exemple d'une application Android 👩🏻‍✈️ 👨🏼 🤵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un bon testeur doté de capacités de réflexion critique ne peut pas être complètement remplacé par l'automatisation. Le rendre plus efficace est facile...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Expérience dans la mise en œuvre de l'automatisation dans le processus de test manuel sur l'exemple d'une application Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434252/">  <i>Un bon testeur doté de capacités de réflexion critique ne peut pas être complètement remplacé par l'automatisation.</i>  <i>Le rendre plus efficace est facile.</i>  <i>Avec cette conviction, je me suis rendu dans notre service d'essais avec une nouvelle tâche, où nous, avec Pavel, avons pris en charge sa mise en œuvre.</i>  <i>Voyons ce qu'il en est advenu.</i> <br><br>  En collaboration avec nos partenaires, nous développons, testons et soutenons activement une famille d'applications pour différentes plates-formes: Android, iOS, Windows.  Les applications se développent activement, avec lesquelles le volume de tests augmente, principalement la régression. <br><br>  Nous avons décidé d'essayer de faciliter et d'accélérer les tests en automatisant la plupart des scénarios de test.  Dans le même temps, nous ne voulions pas abandonner complètement le processus de test manuel, mais plutôt le modifier. <br><br>  La mise en œuvre de cette approche a commencé avec l'une des applications Android, dont je vais parler.  L'article sera intéressant pour les auteurs débutants de tests d'interface utilisateur, principalement pour les applications mobiles, ainsi que pour ceux qui souhaitent automatiser le processus de test manuel dans une certaine mesure. <br><br>  C'est parti! <a name="habracut"></a><br><br><h2>  Point de départ </h2><br>  Pour chaque plate-forme, nous en avons plusieurs similaires qui exécutent le même processus métier principal des applications.  Cependant, ils diffèrent les uns des autres par un ensemble de petites fonctionnalités auxiliaires, sont réalisées sous différentes marques en fonction du client (à cause de quoi l'interface change d'une application à l'autre), et le processus métier peut être personnalisé en ajoutant des étapes supplémentaires. <br><br>  Nous sommes confrontés à certains problèmes qui doivent être résolus.  Des difficultés similaires peuvent survenir dans une situation différente de la nôtre.  Par exemple, si vous avez une application volumineuse avec une logique métier difficile, envahie par de nombreux tests. <br><br><h4>  Problème n ° 1: beaucoup de tests de régression </h4><br>  Les ensembles de scénarios de test pour chaque application sont simultanément similaires et différents les uns des autres, ce qui contribue à une augmentation de la régression et la rend encore plus ennuyeuse.  Cependant, vous devez tester toutes les applications individuellement. <br><br>  Étant donné que les applications déjà en cours d'exécution sont régulièrement mises à jour et qu'il n'y en aura qu'à l'avenir, le nombre total de tests augmentera inexorablement. <br><br><h4>  Problème numéro 2: vous devez tester sur toutes les versions du système d'exploitation mobile </h4><br>  Une exigence importante est la disponibilité de nos applications mobiles sur une large gamme de versions de système d'exploitation.  Par exemple, dans le cas d'Android au moment de la rédaction, ce sont des niveaux d'API de 17 à 28. <br><br>  Idéalement, nous devrions tester sur chaque version d'Android, ce qui complique encore notre régression.  Le processus de test direct de l'application acquiert une routine supplémentaire multipliée par le nombre d'appareils: installer et exécuter l'application, la ramener à son état d'origine après chaque test individuel, la suppression.  Dans le même temps, la maintenance de votre propre batterie de périphériques nécessite beaucoup de travail. <br><br><h4>  Solution: intégrer l'automatisation dans le processus de test manuel </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  Une tâche typique de l'automatisation des tests consiste à automatiser les tests de régression.  Nous voulons donc améliorer l'efficacité du processus de test aujourd'hui et prévenir les conséquences possibles de la croissance de demain. <br><br>  Dans le même temps, nous sommes bien conscients qu'il est impossible et inutile d'éradiquer complètement les tests manuels par automatisation.  La pensée critique et l'œil humain sont difficiles à remplacer par quelque chose.  Il y a un bon article à ce sujet sur le blog de Michael Bolton, The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">End of Manual Testing</a> (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> d'Anna Rodionova). <br><br>  Nous avons pensé qu'il serait utile d'avoir un ensemble de tests automatisés qui couvrent les parties stables de l'application, et à l'avenir d'écrire des tests pour les bogues trouvés et les nouvelles fonctionnalités.  Dans le même temps, nous voulons associer les autotests aux suites de tests existantes dans notre système de gestion des tests (nous utilisons TestRail), et permettre également aux testeurs d'exécuter facilement des autotests sur des appareils physiques cloud (nous avons choisi Firebase Test Lab comme infrastructure cloud). <br><br>  Pour commencer et essayer, nous avons pris une de nos applications Android.  Il était important de considérer que si la solution réussissait, ses meilleures pratiques pourraient être appliquées à nos autres applications, y compris sur d'autres plateformes. <br><br>  Ce que nous voulons obtenir en conséquence: <br><br><ol><li>  Automatisation des tests de régression. </li><li>  Intégration avec le système de gestion des tests. </li><li>  Possibilité de démarrage manuel paramétré des autotests sur les appareils cloud. </li><li>  La possibilité de réutiliser la solution à l'avenir. </li></ol><br>  Ensuite, je parlerai séparément de la mise en œuvre de chacun de ces points avec une petite immersion dans la composante technique. <br><br><h2>  Schéma général d'implémentation de la solution </h2><br>  Mais d'abord, un aperçu général de ce que nous avons obtenu: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="image"><br><br>  Les tests automatiques s'exécutent de deux manières: <br><br><ol><li>  De CI après fusion ou extraction de la demande au maître. </li><li>  Testez manuellement depuis l'interface Web de Jenkins Job. </li></ol><br>  Dans le cas d'un lancement manuel, le testeur doit soit indiquer le numéro de la build correspondante, soit télécharger 2 APK depuis l'ordinateur: avec l'application et avec les tests.  Cette méthode est nécessaire pour que vous puissiez exécuter les tests nécessaires à tout moment sur tous les appareils disponibles. <br><br>  Pendant les tests, leurs résultats sont envoyés à TestRail.  Cela se produit de la même manière que si le testeur effectuait le test manuellement et saisissait les résultats d'une manière qui lui était familière. <br><br>  Ainsi, nous avons abandonné le processus établi de tests manuels, mais y avons ajouté une automatisation, qui effectue un ensemble spécifique de tests.  Le testeur «détecte» ce qui a été fait automatiquement et: <br><br><ul><li>  voit le résultat des cas de test sur chaque appareil qui ont été sélectionnés; </li><li>  peut vérifier manuellement n'importe quel cas de test; </li><li>  effectue des cas de test qui ne sont pas encore automatisés ou qui ne peuvent être optimisés pour aucune raison; </li><li>  prend la décision finale sur le test en cours. </li></ul><br>  Passons maintenant à la description promise de l'implémentation. <br><br><h2>  1. Tests automatiques </h2><br><h4>  Les outils </h4><br>  Nous avons utilisé 3 outils pour interagir avec l'interface utilisateur: <br><br><ul><li>  Espresso </li><li>  Barista. </li><li>  UI Automator. </li></ul><br>  L'outil principal et celui avec lequel nous avons commencé est Espresso.  Le principal argument en faveur de son choix était le fait qu'Espresso vous permet de tester en utilisant la méthode de la boîte blanche, donnant accès à Android Instrumentation.  Le code de test se trouve dans le même projet que le code d'application. <br><br>  L'accès au code de l'application Android est nécessaire pour appeler ses méthodes dans les tests.  Nous pouvons préparer notre demande pour un test spécifique à l'avance en l'exécutant dans le bon état.  Sinon, nous devons atteindre cet état via l'interface, ce qui prive les tests d'atomicité, les rendant dépendants les uns des autres, et mange simplement beaucoup de temps. <br><br>  Pendant la mise en œuvre, un autre outil a été ajouté à Espresso - UI Automator.  Les deux cadres font partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque de prise en charge des tests Android</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google</a> .  À l'aide de l'UI Automator, nous pouvons interagir avec diverses boîtes de dialogue système ou, par exemple, Notification Drawer. <br><br>  Et le dernier de notre arsenal était le framework Barista.  Il s'agit d'une enveloppe autour d'Espresso, vous permettant d'économiser le code passe-partout lors de la mise en œuvre d'actions utilisateur courantes. <br><br>  En gardant à l'esprit le désir de pouvoir réutiliser la solution dans d'autres applications, il est important de noter que les outils listés sont destinés exclusivement aux applications Android.  Si vous n'avez pas besoin d'accéder au code de l'application en cours de test, vous préférerez probablement utiliser un framework différent.  Par exemple, le très populaire Appium aujourd'hui.  Bien que vous puissiez également essayer d'accéder au code de l'application à l'aide de portes dérobées, c'est un bon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur le blog Badoo.  Le choix vous appartient. <br><br><h4>  Implémentation </h4><br>  Comme modèle de conception, nous avons choisi Testing Robots, proposé par Jake Wharton dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> éponyme.  L'idée de cette approche est similaire au modèle de conception d'objet de page commun utilisé dans les tests de systèmes Web.  Le langage de programmation est Java. <br><br>  Pour chaque fragment indépendant de l'application, une classe de robot spéciale est créée dans laquelle la logique métier est implémentée.  L'interaction avec chaque élément du fragment est décrite dans une méthode distincte.  De plus, toutes les assertions effectuées dans ce fragment sont également décrites ici. <br><br>  Prenons un exemple simple.  Le fragment décrit contient plusieurs champs pour entrer des données et un bouton d'action: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="image"><br><br>  Le code de la fonctionnalité de connexion se teste: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="image"><br><br>  Ici, nous vérifions le scénario positif lorsque les données d'authentification saisies sont correctes.  Les données elles-mêmes sont soumises aux tests d'entrée ou les valeurs par défaut sont utilisées.  Ainsi, le testeur a la possibilité de paramétrer en termes de données de test. <br><br>  Cette structure donne tout d'abord une excellente lisibilité aux tests lorsque l'ensemble du script est divisé en principales étapes d'exécution.  Nous avons également beaucoup aimé l'idée de transférer des assertions aux méthodes individuelles du robot correspondant.  Assert devient la même étape, sans rompre la chaîne générale, et vos tests ne savent toujours rien de l'application. <br><br>  Dans le rapport susmentionné, Jake Wharton donne une implémentation dans Kotlin, où elle est finie.  Nous l'avons déjà essayé sur un autre projet et nous l'avons vraiment aimé. <br><br><h2>  2. Intégration avec le système de gestion des tests </h2><br>  Avant l'introduction de l'automatisation, nous avons effectué tous nos tests dans le système de gestion des tests TestRail.  La bonne nouvelle était qu'il existe une assez bonne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API TestRail</a> , avec laquelle nous avons pu connecter des cas de test déjà établis dans le système avec des autotests. <br><br>  Pendant le test à l'aide de JUnit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RunListener</a> , divers événements sont interceptés, tels que <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , dans lesquels nous envoyons les résultats à TestRail.  Si vous utilisez AndroidJUnitRunner, alors il doit informer de votre RunListener d'une certaine manière, décrite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> officielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br><br>  Vous devez également communiquer avec diverses entités TestRail par leur ID.  Ainsi, pour connecter le test au <code>@CaseId</code> test correspondant, nous avons créé une annotation simple <code>@CaseId</code> , dont l'utilisation est illustrée dans l'exemple d'implémentation du test ci-dessus. <br><br>  Code pour implémenter l'annotation elle-même: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="image"><br><br>  Il ne reste plus qu'à obtenir sa valeur au bon endroit à partir de la description: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="image"><br><br><h2>  3. Démarrage manuel des autotests sur les appareils cloud </h2><br><h4>  Paramétrage de démarrage dans le travail Jenkins </h4><br>  Pour organiser le démarrage manuel des autotests, nous utilisons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail Jenkins de style libre</a> .  Cette option a été choisie parce que l'entreprise avait déjà une certaine expérience avec un travail similaire avec Jenkins Job dans d'autres domaines, en particulier avec les ingénieurs DevOps, qu'ils ont volontiers partagés. <br><br>  Jenkins Job exécute un script basé sur les données transférées depuis l'interface Web.  Ainsi, le paramétrage des cycles de test est implémenté.  Dans notre cas, le script Bash lance le lancement des tests sur les appareils cloud Firebase. <br><br>  Le paramétrage comprend: <br><br><ul><li>  Sélectionner l'APK souhaité en spécifiant le numéro de la build correspondante ou en les téléchargeant manuellement. </li><li>  Saisissez toutes sortes de données de test. </li><li>  Saisie de données personnalisées supplémentaires pour TestRail. </li><li>  Sélectionnez les périphériques physiques basés sur le cloud sur lesquels les tests seront exécutés dans la liste disponible dans le laboratoire de test Firebase. </li><li>  La sélection des kits de test à effectuer. </li></ul><br>  Regardons une partie de la page Web de notre travail Jenkins en utilisant un exemple d'interface de sélection de périphérique et de suites de tests: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="image"><br><br>  Chaque élément où vous pouvez entrer ou sélectionner des données est implémenté par des plugins Jenkins spéciaux.  Par exemple, l'interface de sélection de périphérique est réalisée à l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin Active Choices</a> .  En utilisant un script groovy de Firebase, une liste des périphériques disponibles est obtenue, qui est ensuite affichée sous la forme souhaitée sur la page Web. <br><br>  Une fois que toutes les données nécessaires ont été entrées, le script correspondant est lancé, dont la progression peut être observée dans la section Sortie de la console: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="image"><br><br>  À partir de là, le testeur qui a lancé le test peut accéder à TestRail ou à la console Firebase en utilisant les URL reçues, qui contiennent de nombreuses informations utiles sur l'exécution de tests sur chacun des périphériques sélectionnés. <br><br><h4>  Matrice de test finale dans Firebase Test Lab </h4><br>  La matrice des périphériques dans Firebase contient la distribution des tests par les périphériques sur lesquels ils ont été exécutés: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="image"><br><br>  Pour chaque appareil, vous pouvez consulter le journal complet, la vidéo du test, divers indicateurs de performance.  De plus, vous pouvez accéder à tous les fichiers qui auraient pu être créés lors de l'exécution des tests.  Nous l'utilisons pour télécharger des indicateurs de couverture de test depuis l'appareil. <br><br>  Nous avons choisi Firebase, car nous avons déjà utilisé ce service pour résoudre d'autres problèmes et nous sommes satisfaits de la politique de prix.  Si vous rencontrez 30 minutes de temps pur pour les tests par jour, vous n'avez pas besoin de payer du tout.  Cela peut être une raison supplémentaire pour laquelle il est important de pouvoir exécuter uniquement certains tests. <br><br>  Vous préférerez peut-être une infrastructure cloud différente qui s'intègre également bien à votre processus de test. <br><br><h2>  4. Réutilisation </h2><br>  Comment utiliser tout cela à l'avenir?  Du point de vue de la base de code, cette solution n'est applicable qu'aux applications Android.  Par exemple, pendant l'implémentation, nous avons ajouté les classes d'assistance <code>EspressoExtensions</code> et <code>UiAutomatorExtensions</code> , où nous encapsulons diverses options d'interaction avec l'interface et attendons que les éléments soient prêts.  Cela inclut également la classe RunListener, qui est responsable de l'intégration avec TestRail.  Nous les avons déjà placés dans des modules séparés et les utilisons pour automatiser d'autres applications. <br><br>  Si nous parlons d'autres plates-formes, l'expérience acquise peut être très utile pour construire et mettre en œuvre des processus similaires.  Nous le faisons activement dans le domaine iOS et pensons à Windows. <br><br><h2>  Conclusion </h2><br>  Il existe de nombreuses options pour implémenter et utiliser l'automatisation des tests.  Nous sommes d'avis que l'automatisation est avant tout un outil conçu pour faciliter le processus traditionnel de tests "humains", et non pour l'éradiquer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434252/">https://habr.com/ru/post/fr434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434236/index.html">Le réseau neuronal avec une amibe a résolu le problème des vendeurs ambulants pour 8 villes</a></li>
<li><a href="../fr434238/index.html">Intel OpenVINO sur Raspberry Pi: récolte 2018</a></li>
<li><a href="../fr434244/index.html">Je suis le marchand d'algo de maman: à la recherche de frameworks gratuits pour tester des hypothèses et lancer en mode bataille (Python)</a></li>
<li><a href="../fr434246/index.html">Apple confirme que certains iPad Pros sont légèrement incurvés, mais disent que c'est ok</a></li>
<li><a href="../fr434250/index.html">Tendances de la sécurité des réseaux 2019</a></li>
<li><a href="../fr434254/index.html">Chasser le meilleur</a></li>
<li><a href="../fr434258/index.html">Stage d'hiver pour développeurs mobiles chez Redmadrobot</a></li>
<li><a href="../fr434260/index.html">Microsoft organise un concours Minecraft AI</a></li>
<li><a href="../fr434262/index.html">Rédaction et compilation d'un album pour Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../fr434264/index.html">Intel ❄ 2018. Résultats de l'année</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>