<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔜 💱 ⚕️ Créer une passerelle API simple dans ASP.NET Core 😃 🌟 👨🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article " Création d'une passerelle API simple dans ASP.NET Core ". 


 10 minutes pour lire 


 Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créer une passerelle API simple dans ASP.NET Core</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419393/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création d'une passerelle API simple dans ASP.NET Core</a> ". </p><br><p>  <em>10 minutes pour lire</em> </p><br><p>  Dans mon article précédent, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Authentification JWT pour les microservices dans .NET</a> , j'ai examiné le processus de création d'un microservice pour l'authentification des utilisateurs.  Cela peut être utilisé pour vérifier l'identité de l'utilisateur avant d'effectuer toute action dans d'autres composants du système. </p><br><p><img src="https://habrastorage.org/webt/ue/_y/er/ue_yerdkj5miri4_b6b2vjldhhc.png" alt="Diagramme d'architecture de microservice"></p><br><p>  Un autre élément essentiel pour que le produit fonctionne est une passerelle API - un système entre l'application et le backend, qui, d'une part, achemine les demandes entrantes vers le microservice correspondant, et d'autre part, autorise l'utilisateur. </p><br><p>  Il existe de nombreux frameworks qui peuvent être utilisés pour créer une passerelle API, par exemple Ocelot dans le noyau .NET ou Netflix Zuul en Java.  Cependant, dans cet article, je décrirai le processus de création d'une passerelle API simple à partir de zéro dans .NET Core. </p><a name="habracut"></a><br><h2 id="sozdanie-proekta">  Création de projet </h2><br><p>  Tout d'abord, créez une nouvelle application en sélectionnant <em>Application Web ASP.NET Core</em> dans la fenêtre de création de projet et <em>Videz</em> comme modèle. </p><br><p><img src="https://habrastorage.org/webt/ce/f8/rh/cef8rhxwxvjlbnqipa-ps47ulfw.png"></p><br><p><img src="https://habrastorage.org/webt/-r/ta/vk/-rtavkwz1s0qwohtuuba7tkpyt0.png"></p><br><p>  Le projet contiendra les classes de <strong>démarrage</strong> et de <strong>programme</strong> .  Pour nous, la partie la plus importante est la méthode <strong>Configure</strong> de la classe <strong>Startup</strong> .  Ici, nous pouvons traiter la requête HTTP entrante et y répondre.  Peut-être que le code suivant sera dans la méthode <strong>Configure</strong> : </p><br><pre><code class="cs hljs">app.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (context) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>); });</code> </pre> <br><h2 id="napisanie-marshrutizatora">  Orthographe du routeur </h2><br><p>  Puisque c'est dans la méthode <strong>Configure</strong> que nous traiterons les requêtes, nous écrirons la logique nécessaire: </p><br><pre> <code class="cs hljs">Router router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(<span class="hljs-string"><span class="hljs-string">"routes.json"</span></span>); app.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (context) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> router.RouteRequest(context.Request); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> content.Content.ReadAsStringAsync()); });</code> </pre> <br><p>  Nous créons d'abord un objet de type <strong>Router</strong> .  Ses tâches comprennent le stockage des itinéraires existants, la validation et l'envoi de demandes en fonction des itinéraires.  Pour rendre le code plus propre, nous chargerons les routes à partir du fichier JSON. </p><br><p>  Le résultat est la logique suivante: une fois la demande arrivée à la passerelle, elle sera redirigée vers le routeur, qui, à son tour, l'enverra au microservice correspondant. </p><br><p>  Avant d'écrire la classe <strong>Router</strong> , créez un fichier <em>routes.json</em> .  Dans ce fichier, nous indiquons une liste de routes, chacune contenant une adresse externe (endpoint) et une adresse de destination (destination).  De plus, nous ajouterons un indicateur signalant la nécessité d'autoriser l'utilisateur avant de rediriger. </p><br><p>  Voici à quoi pourrait ressembler le fichier: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"routes"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"endpoint"</span></span>: <span class="hljs-string"><span class="hljs-string">"/movies"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"destination"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:8090/movies/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requiresAuthentication"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"endpoint"</span></span>: <span class="hljs-string"><span class="hljs-string">"/songs"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"destination"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:8091/songs/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requiresAuthentication"</span></span>: <span class="hljs-string"><span class="hljs-string">"false"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"authenticationService"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/auth/"</span></span> } }</code> </pre><br><h2 id="sozdaem-klass-destination">  Créer une classe de destination </h2><br><p>  Nous savons maintenant que chaque <strong>route</strong> doit avoir un <code>endpoint</code> et une <code>destination</code> , et chaque <strong>destination</strong> doit avoir un <code>uri</code> et <code>requiresAuthentication</code> champs d' <code>uri</code> . </p><br><p>  Écrivons maintenant la classe <strong>Destination</strong> , en nous souvenant de cela.  J'ajouterai deux champs, deux constructeurs et un constructeur privé sans paramètres pour la désérialisation JSON. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Destination</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Uri { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RequiresAuthentication { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destination</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uri, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requiresAuthentication</span></span></span><span class="hljs-function">)</span></span> { Uri = path; RequiresAuthentication = requiresAuthentication; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destination</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uri</span></span></span><span class="hljs-function">) :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uri, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destination</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Uri = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; RequiresAuthentication = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  En outre, il sera correct d'écrire la méthode <code>SendRequest</code> dans cette classe.  Cela montrera que chaque objet de la classe <strong>Destination</strong> sera responsable de l'envoi de la demande.  Cette méthode prendra un objet de type <code>HttpRequest</code> , qui décrit la demande entrante, en retirera toutes les informations nécessaires et enverra la demande à l'URI cible.  Pour ce faire, nous écrivons une méthode auxiliaire <code>CreateDestinationUri</code> , qui connectera les lignes avec l'adresse et les paramètres de la ligne d'adresse (chaîne de requête) du client. </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDestinationUri</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequest request</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> requestPath = request.Path.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queryString = request.QueryString.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> endpoint = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] endpointSplit = requestPath.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>).Split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endpointSplit.Length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) endpoint = endpointSplit[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Uri + endpoint + queryString; }</code> </pre> <br><p>  Nous pouvons maintenant écrire une méthode <code>SendRequest</code> qui enverra une demande de microservice et recevra une réponse. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequest request</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> requestContent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Stream receiveStream = request.Body) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (StreamReader readStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(receiveStream, Encoding.UTF8)) { requestContent = readStream.ReadToEnd(); } } HttpClient client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); HttpRequestMessage newRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequestMessage(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpMethod(request.Method), CreateDestinationUri(request)); HttpResponseMessage response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.SendAsync(newRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; }</code> </pre> <br><h2 id="sozdaem-json-parser">  Créez un analyseur JSON. </h2><br><p>  Avant d'écrire la classe <strong>Router</strong> , nous devons créer une logique pour désérialiser le fichier JSON avec les routes.  Je vais créer une classe d'assistance pour cela, dans laquelle il y aura deux méthodes: l'une pour créer un objet à partir d'un fichier JSON, et l'autre pour la désérialisation. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">JsonLoader</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T LoadFromFile&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filePath) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (StreamReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(filePath)) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = reader.ReadToEnd(); T result = JsonConvert.DeserializeObject&lt;T&gt;(json); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Deserialize&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> jsonObject) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonConvert.DeserializeObject&lt;T&gt;(Convert.ToString(jsonObject)); } }</code> </pre> <br><h2 id="klass-router">  Routeur de classe. </h2><br><p>  La dernière chose que nous ferons avant d'écrire <strong>Router</strong> est de décrire le modèle de route: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Route</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Endpoint { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Destination Destination { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Écrivons maintenant la classe Router en y ajoutant des champs et un constructeur. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Router</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;Route&gt; Routes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Destination AuthenticationService { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Router</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> routeConfigFilePath</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> router = JsonLoader.LoadFromFile&lt;<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>&gt;(routeConfigFilePath); Routes = JsonLoader.Deserialize&lt;List&lt;Route&gt;&gt;( Convert.ToString(router.routes) ); AuthenticationService = JsonLoader.Deserialize&lt;Destination&gt;( Convert.ToString(router.authenticationService) ); } }</code> </pre><br><p>  J'utilise un type dynamique pour lire à partir de JSON et y écrire des propriétés d'objet. </p><br><p>  Maintenant, tout est prêt à décrire les principales fonctionnalités de la passerelle API: le routage et l'autorisation utilisateur, qui se produiront dans la méthode <code>RouteRequest</code> .  Nous devons décompresser la partie de base de l'adresse externe (point de terminaison de base) de l'objet de demande.  Par exemple, pour l'adresse <code>/movies/add</code> base serait <code>/movies/</code> .  Après cela, nous devons vérifier s'il existe une description de cet itinéraire.  Si c'est le cas, autorisez l'utilisateur et envoyez la demande, sinon nous renverrons une erreur.  J'ai également créé la classe <strong>ConstructErrorMessage</strong> pour plus de commodité. </p><br><p>  Pour l'autorisation, j'ai préféré la méthode suivante: nous extrayons le jeton de l'en-tête de la demande et l'envoyons comme paramètre de demande.  Une autre option est possible: laissez le jeton dans l'en-tête, puis le microservice auquel la demande est destinée devrait déjà l'extraire. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RouteRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequest request</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = request.Path.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> basePath = <span class="hljs-string"><span class="hljs-string">'/'</span></span> + path.Split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Destination destination; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { destination = Routes.First(r =&gt; r.Endpoint.Equals(basePath)).Destination; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConstructErrorMessage(<span class="hljs-string"><span class="hljs-string">"The path could not be found."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destination.RequiresAuthentication) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> token = request.Headers[<span class="hljs-string"><span class="hljs-string">"token"</span></span>]; request.Query.Append(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, StringValues&gt;(<span class="hljs-string"><span class="hljs-string">"token"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringValues(token))); HttpResponseMessage authResponse = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AuthenticationService.SendRequest(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authResponse.IsSuccessStatusCode) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConstructErrorMessage(<span class="hljs-string"><span class="hljs-string">"Authentication failed."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> destination.SendRequest(request); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> HttpResponseMessage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructErrorMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error</span></span></span><span class="hljs-function">)</span></span> { HttpResponseMessage errorMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpResponseMessage { StatusCode = HttpStatusCode.NotFound, Content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(error) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorMessage; }</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  La création d'une passerelle API de base ne nécessite pas beaucoup d'efforts, mais elle ne fournit pas les fonctionnalités appropriées.  Si vous avez besoin d'un équilibreur de charge, vous pouvez consulter les infrastructures ou plates-formes existantes qui offrent des bibliothèques pour le routage des demandes. </p><br><p>  Tout le code de cet article est disponible dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel GitHub.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419393/">https://habr.com/ru/post/fr419393/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419383/index.html">Nouvelle technique d'attaque WPA2 qui ne nécessite pas de client sur l'AP</a></li>
<li><a href="../fr419385/index.html">Chirurgie cardiaque: comment nous avons réécrit le composant principal d'un système DLP</a></li>
<li><a href="../fr419387/index.html">Vulnérabilités de OWASP Top 10. A1: 2017 - Injections (Part 1)</a></li>
<li><a href="../fr419389/index.html">Moteur de rendu Angular 6 et Ivy</a></li>
<li><a href="../fr419391/index.html">Puissance, argent et open source. Expliquer comment la communauté fonctionne avec Apache Ignite</a></li>
<li><a href="../fr419395/index.html">Explication des expressions lambda</a></li>
<li><a href="../fr419399/index.html">OpenAI Five bat une équipe de personnes dans un match show Dota 2</a></li>
<li><a href="../fr419401/index.html">Interfaces de ligne de commande Java: picocli</a></li>
<li><a href="../fr419405/index.html">Comment vont les choses avec IPv6, ou ce qui entrave la transition vers une nouvelle version du protocole - discuter de la situation</a></li>
<li><a href="../fr419407/index.html">Une analyse détaillée de la correspondance Dota 2 entre OpenAI et les gens au format 5x5. Les gens ont perdu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>