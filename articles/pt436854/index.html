<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏻 🏇🏿 👩🏻‍🌾 Rust 1.32 Release 🧗 💹 🤲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A equipe de desenvolvimento do Rust tem o prazer de anunciar o lançamento de uma nova versão do Rust, 1.32.0. Rust é uma linguagem de programação que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.32 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436854/"><p>  A equipe de desenvolvimento do Rust tem o prazer de anunciar o lançamento de uma nova versão do Rust, 1.32.0.  Rust é uma linguagem de programação que permite a todos criar software confiável e eficiente. </p><br><p> Se você possui uma versão anterior do Rust instalada usando <code>rustup</code> , para fazer o upgrade do Rust para a versão 1.32.0, basta fazer o seguinte: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Se você ainda não instalou o <code>rustup</code> , poderá <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instalá-lo</a> na página correspondente do nosso site.  <a href="">Notas de versão detalhadas do Rust 1.32.0</a> estão disponíveis no GitHub. </p><br><blockquote>  Uma observação <code>rustup</code> : vários novos lançamentos de <code>rustup</code> foram <code>rustup</code> !  Para atualizar o <code>rustup</code> si, faça <code>rustup self update</code> do <code>rustup self update</code> . </blockquote><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1320">  O que está incluído na versão estável 1.32.0 </h2><br><p>  O Rust 1.32.0 adquiriu várias melhorias para melhorar a vida, alterou o alocador de memória padrão e tornou mais funções constantes.  Leia sobre essas alterações abaixo ou veja mais <a href="">nas notas de versão</a> . </p><a name="habracut"></a><br><h4 id="makros-dbg">  Macro dbg </h4><br><p>  Vamos começar com uma melhoria na melhoria da vida.  Você usa a depuração de impressão?  Nesse caso, e você deseja imprimir algum valor enquanto trabalha no código, você é forçado a fazer isso: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, x); <span class="hljs-comment"><span class="hljs-comment">//    println!("{:#?}", x);</span></span></code> </pre> <br><p>  Esse não é <em>o maior</em> obstáculo que atrasa o desenvolvimento, mas é preciso muito esforço para simplesmente depurar a saída do valor <code>x</code> .  Além disso, o contexto não é levado em consideração aqui.  Se você tiver vários desses <code>println!</code>  s, fica difícil determinar a que a saída se refere, até você adicionar informações de contexto a cada chamada, o que exige ainda mais trabalho. </p><br><p>  Para esses propósitos, no Rust 1.32.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, adicionamos uma nova macro dbg!</a>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; dbg!(x); }</code> </pre> <br><p>  Depois de iniciar este programa, você verá: </p><br><pre> <code class="plaintext hljs">[src/main.rs:4] x = 5</code> </pre> <br><p>  Juntamente com o nome da variável e seu valor, o nome do arquivo e o número da linha onde a chamada <code>dbg!</code> foi feita serão exibidos <code>dbg!</code>  . </p><br><p>  Além disso, <code>println!</code>  imprime na saída padrão, por isso é melhor usar o <code>eprintln!</code>  para imprimir no fluxo de erro padrão.  Macro <code>dbg!</code>  saídas para <code>stderr</code> , e com razão. </p><br><p>  Isso funciona mesmo em casos difíceis.  Considere um exemplo de implementação fatorial: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><p>  Para <code>eprintln!</code> lo, podemos usar o <code>eprintln!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n &lt;= 1"</span></span>); n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); n } }</code> </pre> <br><p>  Queremos produzir <code>n</code> em cada iteração e ver o contexto de cada uma das ramificações.  Para <code>factorial(4)</code> produzirá: </p><br><pre> <code class="plaintext hljs">n: 4 n: 3 n: 2 n: 1 n &lt;= 1 n: 2 n: 6 n: 24</code> </pre> <br><p>  Isso é aceitável, mas não particularmente bom.  Talvez possamos trabalhar para melhorar a saída de informações de contexto para tornar a conclusão mais clara.  Mas então, em vez de depurar nosso código, melhoraremos o código de depuração. </p><br><p>  Considere o mesmo exemplo usando <code>dbg!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbg!(n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { dbg!(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dbg!(n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) } }</code> </pre> <br><p>  Simplesmente envolvemos uma macro com cada uma das expressões que queremos gerar.  Como resultado, obtemos: </p><br><pre> <code class="plaintext hljs">[src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = true [src/main.rs:4] 1 = 1 [src/main.rs:5] n * factorial(n - 1) = 2 [src/main.rs:5] n * factorial(n - 1) = 6 [src/main.rs:5] n * factorial(n - 1) = 24 [src/main.rs:11] factorial(4) = 24</code> </pre> <br><p>  Uma vez que a macro é <code>dbg!</code>  retorna o próprio valor de depuração, diferente do <code>eprintln!</code>  que retorna <code>()</code> , não precisamos fazer alterações na estrutura do nosso código.  Além disso, temos uma conclusão <em>muito</em> mais útil. </p><br><p>  Demos muita atenção a uma macro tão pequena, pois esperamos que isso simplifique seu processo de depuração.  Obviamente, também continuamos a trabalhar no apoio ao <code>gdb</code> e à Co. </p><br><h4 id="po-umolchaniyu-ubran-jemalloc">  <code>jemalloc</code> removido por <code>jemalloc</code> </h4><br><p>  Era uma vez, Rust, um grande tempo de execução semelhante ao Erlang.  Para ele, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jemalloc</a> foi escolhido em vez do alocador do sistema, porque costumava ser mais produtivo.  Gradualmente, nos livramos do tempo de execução cada vez mais e, no final, quase tudo foi excluído, mas o jemalloc permaneceu.  Não tínhamos como escolher um alocador personalizado e, portanto, não conseguimos remover completamente o jemalloc, para não prejudicar aqueles que precisavam. </p><br><p>  Além disso, a afirmação de que <code>jemalloc</code> sempre foi o <code>jemalloc</code> padrão estava principalmente relacionada ao mundo UNIX, uma vez que, por padrão, era apenas em <em>algumas</em> plataformas.  Em particular, o objetivo do MSVC no Windows há muito tempo usa um alocador de sistema. </p><br><p>  Finalmente, embora o jemalloc <em>geralmente</em> tenha um bom desempenho, esse nem sempre é o caso.  Além disso, ele adiciona cerca de 300 kilobytes a cada executável.  Além disso, acumulamos muitos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros problemas</a> com o jemalloc.  Em geral, é estranho que o idioma do sistema não use o alocador de sistema por padrão. </p><br><p>  Por esses motivos, assim que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust 1.28 forneceu uma maneira de escolher um alocador global</a> , começamos a planejar mudar para o alocador de sistema padrão e fornecer o <code>jemalloc</code> como uma biblioteca externa.  No Rust 1.32, finalmente concluímos este trabalho e agora, por padrão, seu programa usará o alocador de sistema. </p><br><p>  Se você quiser continuar usando o jemalloc, use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a biblioteca jemallocator</a> .  Para fazer isso, especifique em <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">jemallocator = "0.1.8"</code> </pre> <br><p>  E no arquivo raiz do seu projeto: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;</code> </pre> <br><p>  Isso é tudo!  Se você não precisar do jemalloc, não será mais obrigado a usá-lo, mas se precisar, o problema será resolvido com algumas linhas de código. </p><br><h4 id="zaklyuchitelnye-uluchsheniya-sistemy-moduley">  Melhorias finais no sistema do módulo </h4><br><p>  Nos últimos dois lançamentos, falamos sobre várias melhorias no sistema de módulos.  No 1.32.0 e na edição de 2018, adicionamos a alteração mais recente.  Ele é chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"caminhos uniformes"</a> e permite trabalhar com os caminhos de importação da mesma maneira que com outros caminhos, que anteriormente funcionavam incorretamente.  Por exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Color::*;</code> </pre> <br><p>  Este código não foi compilado <em>antes</em> , pois os caminhos em <code>use</code> deveriam ter começado com <code>super</code> , <code>self</code> ou <code>crate</code> .  Agora, graças ao compilador que oferece suporte a caminhos consistentes, esse código funcionará e fará o que você espera: importando variantes da enumeração <code>Color</code> definida acima. </p><br><p>  Essa alteração conclui nossa revisão do sistema de módulos.  Esperamos que você goste de usar o sistema simplificado! </p><br><h4 id="uluchsheniya-makrosov">  Aprimoramentos de macro </h4><br><p>  O Rust 1.32.0 lançou vários aprimoramentos de macro.  Primeiro, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">novo especificador de fragmento literal</a> foi adicionado: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> m { ($lt:literal) =&gt; {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { m!(<span class="hljs-string"><span class="hljs-string">"some string literal"</span></span>); }</code> </pre> <br><p>  O fragmento <code>literal</code> é mapeado para literais de qualquer tipo: string, numérico e caractere. </p><br><p>  Na <code>macro_rules</code> 2018 <code>macro_rules</code> você também pode usar <code>macro_rules</code> <strong><code>?</code></strong>  : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> bar { ($(a)?) =&gt; {} }</code> </pre> <br><p>  Fragmento com <strong><code>?</code></strong>  uma ocorrência zero ou uma será correspondida, assim como um fragmento com <code>*</code> já corresponde a "zero ou mais" ocorrências e com <strong><code>+</code></strong> , uma ou mais ocorrências. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Estabilização da biblioteca padrão </h3><br><p>  Macro <code>dbg!</code>  , que já descrevemos acima, tornou-se uma adição importante à biblioteca padrão.  Além disso, 19 funções foram mantidas constantes e todos os tipos numéricos primitivos receberam funções de conversão em uma matriz de bytes e vice-versa com a ordem de bytes especificada.  Existem seis funções com os nomes <code>to_&lt;endian&gt;_bytes</code> e <code>from_&lt;endian&gt;_bytes</code> , onde <code>&lt;endian&gt;</code> é: </p><br><ul><li>  <code>ne</code> - ordem nativa (endianness nativo) </li><li>  <code>le</code> - ordem do junior ao senior (little endian) </li><li>  <code>be</code> - ordem do mais antigo para o mais novo (big endian) </li></ul><br><p>  Veja <a href="">as notas de versão para mais</a> detalhes. </p><br><h3 id="uluchsheniya-v-cargo">  Aprimoramentos de carga </h3><br><p>  Cargo recebeu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alias <strong>cargo c</strong> para o comando de <strong>verificação de carga</strong></a> e agora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">permite que nomes de usuários sejam usados ​​nos URLs do repositório</a> . </p><br><p>  Veja <a href="">as notas de versão para mais</a> detalhes. </p><br><h2 id="razrabotchiki-1320">  Desenvolvedores 1.32.0 </h2><br><p>  Muitas pessoas juntas criaram o Rust 1.32.0.  Não poderíamos ter concluído o trabalho sem cada um de vocês.  <a href="">Obrigada</a> </p><br><p>  <em>De um tradutor: expresso um agradecimento especial aos membros da comunidade Rustycrate e pessoalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@dashadee</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ozkriff</a> por sua ajuda na tradução e revisão.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436854/">https://habr.com/ru/post/pt436854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436842/index.html">Solução Veeam para backup e recuperação de máquinas virtuais na plataforma Nutanix AHV. Parte 2</a></li>
<li><a href="../pt436846/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 348 (14-20 de janeiro de 2019)</a></li>
<li><a href="../pt436848/index.html">NSA anuncia lançamento de ferramenta interna para engenharia reversa</a></li>
<li><a href="../pt436850/index.html">Erros comuns ao escrever testes de unidade. Palestra Yandex</a></li>
<li><a href="../pt436852/index.html">Abrandar para impulsionar o desenvolvimento</a></li>
<li><a href="../pt436856/index.html">Plano de desenvolvimento de TI de acordo com o Ministério das Comunicações: soberania digital, blockchain em serviços habitacionais e comunitários, software para “realidade mudada”</a></li>
<li><a href="../pt436858/index.html">Esperanto, Elven e Klingon</a></li>
<li><a href="../pt436860/index.html">Dell e Alienware na CES 2019: um guia para todas as principais inovações</a></li>
<li><a href="../pt436862/index.html">AMD Ryzen Matisse de terceira geração: Octa-Core Zen 2 com PCIe 4.0 para desktop</a></li>
<li><a href="../pt436864/index.html">Como testar sua própria distribuição de SO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>