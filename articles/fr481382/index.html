<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìõ üê© üëàüèº Applications natives Windows et Acronis Active Restore ü§ü üë®‚Äç‚öñÔ∏è üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous continuons l'histoire sur la fa√ßon dont nous, avec les gars de l'Universit√© Innopolis, d√©veloppons la technologie Active Restore pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Applications natives Windows et Acronis Active Restore</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/481382/">  Aujourd'hui, nous continuons l'histoire sur la fa√ßon dont nous, avec les gars de l'Universit√© Innopolis, d√©veloppons la technologie Active Restore pour permettre √† l'utilisateur de commencer √† travailler sur sa machine d√®s que possible apr√®s une panne.  Nous parlerons des applications Windows natives, y compris les fonctionnalit√©s de leur cr√©ation et de leur lancement.  Under the cut - un peu sur notre projet, ainsi qu'un guide pratique sur la fa√ßon d'√©crire des applications natives. <br><br><img src="https://habrastorage.org/webt/rc/bv/yl/rcbvylee_0ylshzywkrdlip0c9o.jpeg"><br><a name="habracut"></a><br>  Dans les articles pr√©c√©dents, nous avons d√©j√† parl√© de ce qu'est <a href="https://habr.com/ru/company/acronis/blog/477658/">Active Restore</a> et de la fa√ßon dont les √©tudiants d'Innopolis d√©veloppent le <a href="https://habr.com/ru/company/acronis/blog/479524/">service</a> .  Aujourd'hui, je veux me concentrer sur les applications natives, au niveau desquelles nous voulons ¬´enterrer¬ª notre service de r√©cup√©ration actif.  Si tout fonctionne, alors nous pouvons: <br><br><ul><li>  Beaucoup plus t√¥t pour d√©marrer le service lui-m√™me </li><li>  Beaucoup plus t√¥t pour contacter le cloud dans lequel se trouve la sauvegarde </li><li>  Il est beaucoup plus t√¥t pour comprendre dans quel mode est le syst√®me - d√©marrage normal ou r√©cup√©ration </li><li>  Pour restaurer beaucoup moins de fichiers √† l'avance </li><li>  Permettez √† l'utilisateur de d√©marrer encore plus rapidement. </li></ul><br><h3>  Qu'est-ce qu'une application native en g√©n√©ral? </h3><br>  Pour r√©pondre √† cette question, regardons la s√©quence d'appels que le syst√®me effectue, par exemple, si un programmeur dans son application essaie de cr√©er un fichier. <br><br><img src="https://habrastorage.org/webt/gb/d_/a7/gbd_a7c7l1d-6dlo4zh-fygf5dm.jpeg"><br>  <i>Pavel Yosifovich - Programmation du noyau Windows (2019)</i> <br><br>  Le programmeur utilise la fonction <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> , qui est d√©clar√©e dans le fichier d'en-t√™te fileapi.h et est impl√©ment√©e dans Kernel32.dll.  Cependant, cette fonction elle-m√™me ne cr√©e pas de fichier, elle v√©rifie uniquement les arguments √† l'entr√©e et appelle la fonction <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">NtCreateFile</a> (le pr√©fixe Nt indique simplement que la fonction est native).  Cette fonction est d√©clar√©e dans le fichier d'en-t√™te winternl.h et est impl√©ment√©e dans ntdll.dll.  Elle se pr√©pare √† sauter dans l'espace nucl√©aire, apr√®s quoi elle fait un appel syst√®me pour cr√©er un fichier.  Dans ce cas, il s'av√®re que Kernel32 n'est qu'un wrapper pour Ntdll.  L'une des raisons pour lesquelles cela est fait, Microsoft a donc la possibilit√© de modifier les fonctions du monde natif, mais ne touche pas aux interfaces standard.  Microsoft ne recommande pas d'appeler directement les fonctions natives et ne documente pas la plupart d'entre elles.  √Ä propos, des fonctionnalit√©s non document√©es peuvent √™tre trouv√©es <a href="http://undocumented.ntinternals.net/">ici</a> . <br><br>  Le principal avantage des applications natives est que ntdll se charge dans le syst√®me beaucoup plus t√¥t que kernel32.  C'est logique, car kernel32 n√©cessite ntdll pour fonctionner.  Par cons√©quent, les applications qui utilisent des fonctions natives peuvent commencer √† fonctionner beaucoup plus t√¥t. <br><br>  Ainsi, les applications natives Windows sont des programmes qui peuvent s'ex√©cuter √† un stade pr√©coce du d√©marrage de Windows.  Ils utilisent UNIQUEMENT les fonctions de ntdll.  Un exemple d'une telle application: <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/autochk">autochk</a> qui ex√©cute l' <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chkdsk">utilitaire chkdisk</a> pour rechercher des erreurs sur le disque avant de d√©marrer les services principaux.  C'est √† ce niveau que nous voulons voir notre restauration active. <br><br><h3>  De quoi avons-nous besoin? </h3><br><ul><li> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit), d√©sormais √©galement appel√© WDK 7 (Windows Driver Kit). </li><li>  Machine virtuelle (par exemple Windows 7 x64) </li><li>  Pas n√©cessairement, mais les fichiers d'en-t√™te peuvent √™tre t√©l√©charg√©s <a href="https://github.com/arizvisa/ndk">ici.</a> </li></ul><br><h3>  Que contient le code? </h3><br>  Pratiquons un peu et pour un exemple nous allons √©crire une petite application qui: <br><br><ol><li>  Affiche un message √† l'√©cran. </li><li>  Alloue un peu de m√©moire </li><li>  En attente de saisie au clavier </li><li>  Lib√®re la m√©moire occup√©e </li></ol><br>  Dans les applications natives, le point d'entr√©e n'est pas le principal ou le winmain, mais la fonction NtProcessStartup, car nous d√©marrons en fait directement le nouveau processus dans le syst√®me. <br><br>  Commen√ßons par afficher le message √† l'√©cran.  Pour ce faire, nous avons une fonction native <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FError%252FNtDisplayString.html">NtDisplayString</a> , qui prend comme argument un pointeur vers un objet de la structure UNICODE_STRING.  RtlInitUnicodeString nous aidera √† l'initialiser.  Par cons√©quent, pour afficher du texte √† l'√©cran, nous pouvons √©crire une si petite fonction: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//usage: WriteLn(L"Here is my text\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); }</span></span></code> </pre> <br>  √âtant donn√© que seules les fonctions de ntdll sont disponibles pour nous, et qu'il n'y a tout simplement pas d'autres biblioth√®ques en m√©moire pour le moment, nous aurons certainement des probl√®mes avec la fa√ßon d'allouer de la m√©moire.  Le nouvel op√©rateur n'existe pas encore (car il provient d'un monde C ++ de haut niveau), il n'y a pas non plus de fonction malloc (il a besoin de biblioth√®ques C d'ex√©cution).  Vous ne pouvez bien s√ªr utiliser que la pile.  Mais si nous devons allouer dynamiquement de la m√©moire, nous devrons le faire sur le tas (c'est-√†-dire le tas).  Par cons√©quent, cr√©ons un groupe pour nous-m√™mes et nous en prendrons la m√©moire lorsque nous en aurons besoin. <br><br>  La fonction <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap</a> convient √† cette t√¢che.  De plus, en utilisant RtlAllocateHeap et RtlFreeHeap, nous occuperons et lib√©rerons de la m√©moire lorsque nous en aurons besoin. <br><br><pre> <code class="cpp hljs">PVOID memory = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PVOID buffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ULONG bufferSize = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory);</span></span></code> </pre> <br>  Passons √† l'attente de la saisie au clavier. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //... HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } }</span></span></code> </pre> <br>  Tout ce que nous devons faire est d'utiliser <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FFile%252FNtReadFile.html">NtReadFile</a> sur un appareil ouvert et d'attendre que le clavier nous renvoie un clic.  Si vous appuyez sur la touche ESC, nous continuerons √† travailler.  Pour ouvrir l'appareil, nous devons appeler la fonction NtCreateFile (vous devrez ouvrir \ Device \ KeyboardClass0).  Nous appellerons √©galement <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">NtCreateEvent</a> pour initialiser l'objet √† attendre.  Nous d√©clarerons ind√©pendamment la structure KEYBOARD_INPUT_DATA qui repr√©sente les donn√©es du clavier.  Cela facilitera notre travail. <br><br>  L'application native se termine par un appel √† la fonction <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">NtTerminateProcess</a> , car nous venons de tuer notre propre processus. <br><br>  Tout le code de notre petite application: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntifs.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// \WinDDK\7600.16385.1\inc\ddk #include "ntdef.h" //------------------------------------ // Following function definitions can be found in native development kit // but I am too lazy to include `em so I declare it here //------------------------------------ NTSYSAPI NTSTATUS NTAPI NtTerminateProcess( IN HANDLE ProcessHandle OPTIONAL, IN NTSTATUS ExitStatus ); NTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); NTSTATUS NtWaitForSingleObject( IN HANDLE Handle, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout ); NTSYSAPI NTSTATUS NTAPI NtCreateEvent( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState ); // https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //---------------------------------------------------------- // Our code goes here //---------------------------------------------------------- // usage: WriteLn(L"Hello Native World!\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); } void NtProcessStartup(void* StartupArgument) { // it is important to declare all variables at the beginning HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; PVOID memory = NULL; PVOID buffer = NULL; ULONG bufferSize = 42; //use it if debugger connected to break //DbgBreakPoint(); WriteLn(L"Hello Native World!\n"); // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); WriteLn(L"Keyboard ready\n"); // create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); WriteLn(L"Heap ready\n"); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); WriteLn(L"Buffer allocated\n"); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory); WriteLn(L"Heap destroyed\n"); WriteLn(L"Press ESC to continue...\n"); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } } NtTerminateProcess(NtCurrentProcess(), 0); }</span></span></span></span></code> </pre> <br>  <b>PS:</b> Nous pouvons facilement utiliser la fonction DbgBreakPoint () dans le code pour nous arr√™ter dans le d√©bogueur.  Certes, vous devrez connecter WinDbg √† la machine virtuelle pour le d√©bogage du noyau.  Vous trouverez des instructions sur la fa√ßon de proc√©der <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">ici</a> ou utilisez simplement <a href="http://sysprogs.com/legacy/virtualkd/">VirtualKD</a> . <br><br><h3>  Compilation et assemblage </h3><br>  La fa√ßon la plus simple de cr√©er une application native consiste √† utiliser <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit).  Nous avons besoin exactement de l'ancienne septi√®me version, car les versions ult√©rieures ont une approche l√©g√®rement diff√©rente et fonctionnent en √©troite collaboration avec Visual Studio.  Si nous utilisons DDK, notre projet n'a besoin que de Makefile et de sources. <br><br>  <i>Makefile</i> <br><pre> <code class="bash hljs">!INCLUDE $(NTMAKEENV)\makefile.def</code> </pre> <br>  <i>sources:</i> <br><pre> <code class="bash hljs">TARGETNAME = MyNative TARGETTYPE = PROGRAM UMTYPE = nt BUFFER_OVERFLOW_CHECKS = 0 MINWIN_SDK_LIB_PATH = $(SDK_LIB_PATH) SOURCES = source.c INCLUDES = $(DDK_INC_PATH); \ C:\WinDDK\7600.16385.1\ndk; TARGETLIBS = $(DDK_LIB_PATH)\ntdll.lib \ $(DDK_LIB_PATH)\nt.lib USE_NTDLL = 1</code> </pre> <br>  Votre Makefile sera exactement le m√™me, mais revenons plus en d√©tail sur les sources.  Ce fichier contient les sources de votre programme (fichiers .c), les options de construction et d'autres param√®tres. <br><br><ul><li>  TARGETNAME - le nom du fichier ex√©cutable, qui devrait √™tre le r√©sultat. </li><li>  TARGETTYPE - type de fichier ex√©cutable, il peut s'agir d'un pilote (.sys), la valeur du champ doit √™tre DRIVER, si la biblioth√®que (.lib), alors la valeur est LIBRARY.  Dans notre cas, nous avons besoin d'un fichier ex√©cutable (.exe), nous d√©finissons donc la valeur sur PROGRAM. </li><li>  UMTYPE - valeurs possibles pour ce champ: console pour une application console, fen√™tres pour fonctionner en mode fen√™tr√©.  Mais nous devons sp√©cifier nt pour obtenir l'application native. </li><li>  BUFFER_OVERFLOW_CHECKS - v√©rifier la pile pour le d√©bordement de tampon, malheureusement pas notre cas, le d√©sactiver. </li><li>  MINWIN_SDK_LIB_PATH - cette valeur fait r√©f√©rence √† la variable SDK_LIB_PATH, ne vous inqui√©tez pas si vous n'avez pas d√©clar√© une telle variable syst√®me, au moment o√π nous ex√©cutons la construction v√©rifi√©e √† partir de DDK, cette variable sera d√©clar√©e et pointera vers les biblioth√®ques n√©cessaires. </li><li>  SOURCES - une liste des sources de votre programme. </li><li>  COMPREND - les fichiers d'en-t√™te n√©cessaires √† l'assemblage.  Ils indiquent g√©n√©ralement le chemin d'acc√®s aux fichiers fournis avec le DDK, mais vous pouvez √©ventuellement en sp√©cifier d'autres. </li><li>  TARGETLIBS - une liste de biblioth√®ques qui doivent √™tre li√©es. </li><li>  USE_NTDLL est un champ obligatoire qui doit √™tre d√©fini sur la position 1. Pour des raisons √©videntes. </li><li>  USER_C_FLAGS - tous les indicateurs que vous pouvez utiliser dans les directives de pr√©processeur lors de la pr√©paration du code d'application. </li></ul><br>  Donc, pour construire, nous devons ex√©cuter x86 (ou x64) Checked Build, changer le r√©pertoire de travail dans le dossier du projet et ex√©cuter la commande Build.  Le r√©sultat de la capture d'√©cran montre que nous avons rassembl√© un fichier ex√©cutable. <br><br><img src="https://habrastorage.org/webt/9a/aj/hp/9aajhpa858ohtthlkjnenl1nnic.jpeg" alt="Construire"><br><br>  Ce fichier ne peut pas √™tre ex√©cut√© si simplement, le syst√®me jure et nous envoie r√©fl√©chir √† son comportement avec l'erreur suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ev/zu/zwevzuxrc6zc8fvgye_msqa0k6y.jpeg" alt="Erreur"></div><br><br><h3>  Comment ex√©cuter une application native? </h3><br>  Au d√©but de autochk, la s√©quence de d√©marrage des programmes est d√©termin√©e par la valeur de la cl√© de registre: <br><br><pre> <code class="bash hljs">HKLM\System\CurrentControlSet\Control\Session Manager\BootExecute</code> </pre> <br>  Le gestionnaire de session ex√©cute les programmes de cette liste un par un.  Le gestionnaire de sessions lui-m√™me recherche les fichiers ex√©cutables dans le r√©pertoire system32.  Le format de la valeur de cl√© de registre est le suivant: <br><br><pre> <code class="bash hljs">autocheck autochk *MyNative</code> </pre> <br>  La valeur doit √™tre au format hexad√©cimal, et non au format ASCII habituel, par cons√©quent, la cl√© pr√©sent√©e ci-dessus aura le format: <br><br><pre> <code class="bash hljs">61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Pour convertir le nom, vous pouvez utiliser un service en ligne, par exemple, <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">celui-ci</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ii/ky/sn/iikysns0tim-qpz91mbazv4uepa.jpeg"></div><br>  Il s'av√®re que pour ex√©cuter l'application native, nous avons besoin de: <br><br><ol><li>  Copiez le fichier ex√©cutable dans le dossier system32 </li><li>  Ajouter une cl√© au registre </li><li>  Red√©marrez la machine </li></ol><br>  Pour plus de commodit√©, voici un script pr√™t √† l'emploi pour l'installation d'une application native: <br><br>  <i>install.bat</i> <br><br><pre> <code class="bash hljs">@<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> off copy MyNative.exe %systemroot%\system32\. regedit /s add.reg <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Native Example Installed pause</code> </pre> <br>  <i>add.reg</i> <br><br><pre> <code class="bash hljs">REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager] <span class="hljs-string"><span class="hljs-string">"BootExecute"</span></span>=hex(7):61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Apr√®s l'installation et le red√©marrage, avant m√™me que l'√©cran de s√©lection de l'utilisateur n'apparaisse, nous obtenons l'image suivante: <br><br><img src="https://habrastorage.org/webt/yi/5p/7_/yi5p7_4vygq1wttxg_edlw-keqi.jpeg" alt="r√©sultat"><br><br><h3>  R√©sum√© </h3><br>  En utilisant l'exemple d'une si petite application, nous √©tions convaincus qu'il √©tait tout √† fait possible d'ex√©cuter l'application au niveau Windows Native.  De plus, les gars de l'Universit√© Innopolis continueront de construire un service qui initiera le processus d'interaction avec le conducteur beaucoup plus t√¥t que dans la version pr√©c√©dente de notre projet.  Et avec l'av√®nement du shell win32, il sera logique de transf√©rer le contr√¥le √† un service √† part enti√®re qui a d√©j√† √©t√© d√©velopp√© (plus √† ce sujet <a href="https://habr.com/ru/company/acronis/blog/479524/">ici</a> ). <br><br>  Dans le prochain article, nous aborderons un autre composant du service Active Restore, √† savoir le pilote UEFI.  Abonnez-vous √† notre blog pour ne pas manquer le prochain post. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481382/">https://habr.com/ru/post/fr481382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481370/index.html">Greta Tunberg a raison? Avions VS trains</a></li>
<li><a href="../fr481372/index.html">Arbre binaire indexable</a></li>
<li><a href="../fr481374/index.html">Habr Weekly # 32 / Rambler a donn√© le dos, les manipulations au travail, comment prot√©ger un projet pour animaux de compagnie, les gadgets prennent des selfies tranquillement</a></li>
<li><a href="../fr481376/index.html">Analyse des le√ßons apprises √† la communaut√© par la situation NGINX</a></li>
<li><a href="../fr481378/index.html">Comment optimiser le d√©veloppement d'applications</a></li>
<li><a href="../fr481386/index.html">Tramage: signal bruyant pour l'am√©liorer</a></li>
<li><a href="../fr481388/index.html">Comment les √©changes de crypto-monnaies construisent leurs blockchains d√©fiant DeFi</a></li>
<li><a href="../fr481390/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../fr481392/index.html">Comme j'ai √©crit une crypto-monnaie centralis√©e en PHP. (Partie 1 - R√©sum√©s de base + D√©marrage rapide)</a></li>
<li><a href="../fr481394/index.html">Recr√©er dans un nouveau jeu ce que nous aimions pour les anciens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>