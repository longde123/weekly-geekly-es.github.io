<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔁 👨🏾‍🌾 👆🏽 iOS / OSX中的AudioKit和音频合成 🌹 ⚪️ 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AudioKit是由音频工程师，程序员和音乐家针对iOS和OSX开发的音频框架。 它提供了用于处理和合成声音的工具。 引擎盖下面是Swift，Objective-C，C ++和C以及A​​pple的Audio Unit API的组合。 令人敬畏的（而且相当复杂的）技术封装在非常友好的Swift AP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS / OSX中的AudioKit和音频合成</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/440226/"><img src="https://habrastorage.org/webt/y1/mf/ce/y1mfceq59vbcmxgabehfybmd5rc.jpeg"><br><br>  AudioKit是由音频工程师，程序员和音乐家针对iOS和OSX开发的音频框架。 它提供了用于<b>处理</b>和<b>合成</b>声音的工具。 引擎盖下面是Swift，Objective-C，C ++和C以及A​​pple的Audio Unit API的组合。 令人敬畏的（而且相当复杂的）技术封装在非常友好的Swift API中，可以直接从Xcode Playgrounds访问！ <br><br> 在本教程中，我们将继续学习AudioKit，以及声音合成的<b>历史</b> 。 您将学习声音物理学的基础知识，以及像Hammond Organ这样的首批合成器是如何工作的。 同样，将考虑现代技术，例如采样。 <br><br> 做自己喜欢的饮料，坐下来走！ <br><a name="habracut"></a><br><h1> 第一步 </h1><br> 从AudioKit 3.6开始，设置游乐场以使用框架变得非常简单。  <a href="">在此处</a>下载并解压缩入门播放列表。 <br><br> 旅程从几个步骤开始，以配置游乐场以使用AudioKit。 <br><br> 在Xcode中打开<b>AudioKitPlaygrounds.xcodeproj</b>文件。 单击屏幕左下角的<b>+</b>按钮，选择“ <b>文件...”</b> ，然后在“ <b>操场”</b>部分中选择“ <b>空白</b> ”，将新文件与演示操场一起保存在“操场”文件夹中。 <br><br> 新添加的游乐场将启动，并且将如下所示： <br><img src="https://habrastorage.org/webt/tz/db/cn/tzdbcnrjbmbep10dyndfyg3xu2s.png"><br><br> 将生成的代码替换为以下内容： <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit let oscillator = AKOscillator()  AudioKit.output = oscillator try AudioKit.start() oscillator.start() sleep(10)</code> </pre> <br> 直到您至少组装了一次项目，游乐场才会启动，为此，您可以使用菜单项<b>Product / Build</b>或组合键<b>⌘-B</b> 。 之后，再次运行游乐场，并听到嗡嗡声10秒钟。  （译者注：有时错误不会消失，您需要切换到另一个游乐场，然后再使它工作）。 您可以使用播放窗口左下方的“播放/停止”按钮停止播放或重新开始播放。 <br><blockquote>  <b>注意：</b>如果仍然看到错误，请尝试重新启动Xcode。 不幸的是，框架和游乐场不是彼此很好的朋友，它们的行为可能无法预测。 </blockquote><h1> 振荡器和声音物理 </h1><br> 人类已经通过各种物理对象播放音乐了数千年。 我们许多常用的乐器（例如吉他或鼓）已有数百年历史。  Elias Gray在1874年进行了使用电子电路产生声音的第一笔经记录的经验。  Elisha在电信领域工作，他发明了振荡器-最简单的音乐合成器。 和他一起，我们将开始潜水。 <br><br> 右键单击您的游乐场，选择“ <b>新建游乐场页面”，</b>然后将生成的代码替换为以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PlaygroundSupport <span class="hljs-comment"><span class="hljs-comment">// 1. Create an oscillator let oscillator = AKOscillator() // 2. Start the AudioKit 'engine' AudioKit.output = oscillator try AudioKit.start() // 3. Start the oscillator oscillator.start() PlaygroundPage.current.needsIndefiniteExecution = true</span></span></code> </pre> <br> 操场将开始产生连续的嗡嗡声-如预期的那样。 您可以单击停止停止它。 <br><br> 这几乎与我们在上一个游乐场中所做的相同，但是这次我们将深入研究细节。 <br><br> 按顺序考虑所有步骤： <br><br><ol><li> 在这里，我们创建一个振荡器。 振荡器是<code>AKNode</code>的后继者。 节点是构成生成和修改声音的音频链的元素。 <br></li><li> 在这里，我们将最后一个节点的输出与AudioKit引擎连接。 在我们的例子中，只有一个节点。 此外，框架会将节点的输出定向到音频回放设备。 <br></li><li> 好吧，我们启动振荡器，在输出端它开始发送声波。 <br></li></ol><br> 振荡器会产生一个不停止的重复信号。 在此剧本中， <code>AKOscillator</code>生成一个正弦波。 使用AudioKit，数字正弦波信号被发送到扬声器或耳机。 结果，我们听到的声音以与我们产生的正弦波相同的频率振荡。 这个正弦波听起来不很音乐。 <br><br><img src="https://habrastorage.org/webt/rx/yw/xw/rxywxwhvbneupuvsb3tx4egropi.png"><br><br> 振荡器的声音由两个参数决定：振幅-正弦波的高度，确定音量和频率-声音的高度取决于它。 <br><br> 在操场上，在创建振荡器之后立即添加以下代码行： <br><br><pre> <code class="swift hljs">oscillator.frequency = <span class="hljs-number"><span class="hljs-number">300</span></span> oscillator.amplitude = <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre><br> 声音发生了变化，现在听起来是安静的两倍，并且声音要低得多。 信号的频率以赫兹（每秒重复数）测量，并确定音符的音高。 振幅（振幅）设置为0到1，并负责音量。 <br><br>  Elijah Gray的发明记录在有史以来的第一项电子乐器专利中。 <br><br><img src="https://habrastorage.org/webt/33/xp/gy/33xpgyaps40rjq2tyojz5wdzfxi.png"><br><br> 许多年后，利奥·特雷敏（Leo Theremin）发明了一种至今使用的奇怪乐器-特雷敏（Theremin）。 在那儿，您可以通过手在乐器上方移动来改变声音的频率。 要了解Theremin的声音，您可以听海滩男孩的振动，Theremin的声音没什么可混淆的。 <br><br> 您可以模拟Thereminvox的声音，为此，将以下代码添加到振荡器设置中： <br><br><pre> <code class="swift hljs">oscillator.rampDuration = <span class="hljs-number"><span class="hljs-number">0.2</span></span></code> </pre> <br> 并用以下内容替换以AudioKit开头的行（ <code>try AudioKit.start()</code> ）： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> performance = <span class="hljs-type"><span class="hljs-type">AKPeriodicFunction</span></span>(every: <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { oscillator.frequency = oscillator.frequency == <span class="hljs-number"><span class="hljs-number">500</span></span> ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">500</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.start(withPeriodicFunctions: performance) performance.start()</code> </pre> <br>  <code>rampDuration</code>属性使振荡器能够平滑地更改其参数的值（例如，频率或幅度）。  <code>AKPeriodicFunction</code>是<code>AKPeriodicFunction</code>的有用工具，用于定期执行代码。 在我们的示例中，它每0.5秒将正弦波的频率从500Hz更改为100Hz。 <br><br> 恭喜你！ 您刚刚完成了第一批。 一个简单的振荡器可以产生音符，但是听起来并不好。 有许多因素会影响物理仪器（例如钢琴）的声音。 进一步，我们将考虑其中的一些。 <br><br><h1> 声音包络 </h1><br> 乐器弹奏音符时，其声音的音量会随着时间而变化，并且变化的性质因乐器而异。 可以模拟这种效果的模型称为Attack-Decay-Sustain-Release（ADSR）包络（注意：可购买的合成器从未本地化，因此曲线的名称与该合成器面板上的名称相同）。 <br><br><img src="https://habrastorage.org/webt/hj/nu/1i/hjnu1iomuddzc5t-p0egelaougy.png"><br><br>  ADSR信封包含： <br><br><ul><li>  <b>起</b>音：声音达到最大音量的起音或时间。 <br></li><li>  <b>衰减</b> ：狂野或音量从最大下降到主要的时间 <br></li><li>  <b>延音</b> ：与前两个参数不同，主要音量不是时间，在经过攻击和野蛮之后以及释放合成器琴键之前，此音量将产生声音 <br></li><li>  <b>释放</b> ：释放或音量变为零的时间 <br></li></ul><br> 在钢琴中，声音是通过敲击弦槌的锤子来提取的，因此在钢琴中很快，或者说是短促的打击和狂野。 小提琴的攻击力很强，狂野而持久，音乐家可以通过使用弓的方式来影响这些参数。 <br><br>  Hammond Novachord是最早的电子乐器之一。 该仪器于1939年制造，由163个真空管和1000多个电容器组成，重230千克。 不幸的是，只制作了几百本，他从未获得商业上的成功。 <br><br><img src="https://habrastorage.org/webt/xm/ag/oa/xmagoabyxwbjfzl97fil0x-xo1u.jpeg"><br><br> 右键单击“ <b>旅程</b> <b>游乐场”</b> ，选择“ <b>新建游乐场页面”，</b>然后创建一个名为<b>ADSR</b>的新页面。 将生成的代码替换为以下内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PlaygroundSupport          let oscillator = AKOscillator()</code> </pre><br> 它只是创建了一个我们已经熟悉的振荡器。 接下来，在游乐场的末尾添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> envelope = <span class="hljs-type"><span class="hljs-type">AKAmplitudeEnvelope</span></span>(oscillator) envelope.attackDuration = <span class="hljs-number"><span class="hljs-number">0.01</span></span> envelope.decayDuration = <span class="hljs-number"><span class="hljs-number">0.1</span></span> envelope.sustainLevel = <span class="hljs-number"><span class="hljs-number">0.1</span></span> envelope.releaseDuration = <span class="hljs-number"><span class="hljs-number">0.3</span></span></code> </pre> <br> 这将创建一个定义ADSR包络的<code>AKAmplitudeEnvelope</code> 。 持续时间参数（attackDuration，destroyDuration，releaseDuration）以秒为单位指定，音量（sustainLevel）的设置范围为0到1。 <br><br>  <code>AKAmplitudeEnvelope</code>是<code>AKAmplitudeEnvelope</code>的后继者，与<code>AKNode</code>相同，在上面的代码中，我们将振荡器包络节点传递给初始化程序，从而连接这些节点。 <br><br> 接下来，添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.output = envelope <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> performance = <span class="hljs-type"><span class="hljs-type">AKPeriodicFunction</span></span>(every: <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (envelope.isStarted) { envelope.stop() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { envelope.start() } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.start(withPeriodicFunctions: performance) performance.start() oscillator.start() <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.needsIndefiniteExecution = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 它将启动AudioKit，但是这次我们将ADSR节点的输出馈送到其输入。 为了听到ADSR效果，我们使用<code>AKPeriodicFunction</code>不断打开和关闭节点。 <br><br><img src="https://habrastorage.org/webt/q6/nl/s1/q6nls1yfzrh8wxwzwxhzc0wny1s.png"><br><br> 现在您可以听到音符如何循环播放，但是这次有点像钢琴。 <br><br> 该循环在每次迭代中每秒运行两次，以启动或停止ADSR。 当ADSR快速开始攻击时，音量在0.01秒内达到最大值，此后音量在0.1秒内下降到主音量并保持在0.5秒，最后在0.3秒后衰减。 <br><br> 您可以自己演奏这些参数，然后尝试演奏小提琴的声音。 <br><br> 我们遇到的声音基于<code>AKOscillator</code>生成的正弦波。 尽管ASDR有助于消除刺耳的声音，但您仍然不能将这些声音称为音乐声。 <br><br> 此外，我们将考虑如何获得更深的声音。 <br><br><h1> 加成合成 </h1><br> 每种乐器都有自己的特殊声音或音色。  <b>音色</b>是区分钢琴声音和小提琴声音的一种方法，即使它们可以演奏相同的音符。 音色的重要参数是声谱。 声谱描述了重现频率的范围，这些频率加在一起时会引起注意。 我们当前的游乐场使用的振荡器仅能以一种频率发出声音，而且听起来很人为。 <br><br> 使用一组振荡器演奏单个音符，您可以获得更生动的声音。 这种方法称为加成合成，这是我们下一个游乐场的主题。 <br><br> 右键单击操场，选择<b>New Playground Page</b>并创建一个名为<b>Additive Synthesis</b>的新页面。 将生成的代码替换为以下内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitUI <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PlaygroundSupport func createAndStartOscillator(frequency: Double) -&gt; AKOscillator { let oscillator = AKOscillator() oscillator.frequency = frequency return oscillator }</code> </pre> <br> 对于加法合成，您需要几个振荡器，为此我们将使用它。 <code>createAndStartOscillator</code> <br><br> 接下来，添加代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frequencies = (<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">5</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">261.63</span></span> }</code> </pre> <br> 在这里，我们采用从1到5的数字间隔，并将每个数字乘以261.53，即音符的频率。 由此产生的多个频率称为谐波。 <br><br> 现在添加代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oscillators = frequencies.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { createAndStartOscillator(frequency: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br> 在这里，我们为我们使用的每个频率创建了一个振荡器。 <br><br> 要组合振荡器，请添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mixer = <span class="hljs-type"><span class="hljs-type">AKMixer</span></span>() oscillators.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.connect(to: mixer) }</code> </pre> <br>  <code>AKMixer</code>是AudioKit节点的另一种类型。 它从一个或多个节点接收输入，并将它们组合为一个。 <br><br> 添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> envelope = <span class="hljs-type"><span class="hljs-type">AKAmplitudeEnvelope</span></span>(mixer) envelope.attackDuration = <span class="hljs-number"><span class="hljs-number">0.01</span></span> envelope.decayDuration = <span class="hljs-number"><span class="hljs-number">0.1</span></span> envelope.sustainLevel = <span class="hljs-number"><span class="hljs-number">0.1</span></span> envelope.releaseDuration = <span class="hljs-number"><span class="hljs-number">0.3</span></span> <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.output = envelope <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> performance = <span class="hljs-type"><span class="hljs-type">AKPeriodicFunction</span></span>(every: <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (envelope.isStarted) { envelope.stop() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { envelope.start() } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.start(withPeriodicFunctions: performance) performance.start() oscillators.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.start() }</code> </pre> <br> 使用此代码应该一切都清楚：将ADSR添加到混音器输出，通过AudioKit输出并定期打开/关闭它。 <br><br> 为了很好地处理加法合成，将这些频率的各种组合进行测试将很有用。 因此，像Live View这样的游乐场对我们来说是理想的机会。 <br><br> 为此，请添加代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiveView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AKLiveViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { addTitle(<span class="hljs-string"><span class="hljs-string">"Harmonics"</span></span>) oscillators.forEach { oscillator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> harmonicSlider = <span class="hljs-type"><span class="hljs-type">AKSlider</span></span>( property: <span class="hljs-string"><span class="hljs-string">"\(oscillator.frequency) Hz"</span></span>, value: oscillator.amplitude ) { amplitude <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> oscillator.amplitude = amplitude } addView(harmonicSlider) } } } <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.needsIndefiniteExecution = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.liveView = <span class="hljs-type"><span class="hljs-type">LiveView</span></span>()</code> </pre> <br> 在AudioKit中，有专门用于在操场上方便工作的类。 在我们的示例中， <code>AKLiveViewController</code>使用<code>AKLiveViewController</code> ，使用它我们垂直放置元素。 并为每个振荡器创建一个<code>AKSlider</code> 。 滑块由振荡器的频率和幅度值初始化，并在与它们相互作用时引起阻塞。 在每个滑块的块中，我们更改相应振荡器的幅度。 因此，您只需向操场添加互动即可。 <br><br> 为了查看运动场的结果，您需要在屏幕上显示实时视图。 为此，请在窗口右上方选择带有相交圆圈的按钮，并确保为实时显示选择了正确的播放列表。 <br><br><img src="https://habrastorage.org/webt/rz/sg/3p/rzsg3psadssk1spigpzyqaltcwq.png"><br><br> 为了更改乐器的音调，您可以分别更改每个滑块的值。 为了获得逼真的声音，建议您尝试上面屏幕截图中所示的配置。 <br><br>  Teleharmonium是最早使用添加剂合成的合成器之一，重达200吨！ 他难以置信的体重和体型，很可能成为他默默无闻的原因。 比较成功的哈蒙德风琴使用了类似的音调轮，但体积要小得多。 它是1935年发明的，在渐进摇滚时代仍然是一种广受欢迎的乐器。 <br><br><img src="https://habrastorage.org/webt/tb/nj/tn/tbnjtngmdjzwb6ddutkpmumkbqy.jpeg"><br><br> 音调轮是一个旋转盘，沿边缘有小孔，而拾音器位于边缘附近。  Hammond管风琴具有整套的音调轮，可以以不同的速度旋转。 产生声音的一种非常不寻常的方法是机电的而不是电子的。 <br><br> 为了产生更逼真的声谱，还有其他几种技术：频率调制（Frequency Modulation或FM）和脉冲宽度调制（Pulse Width Modulation或PWM），这两种技术分别在<code>AKFMOscillator</code>和<code>AKPWMOscillator</code>的<code>AKFMOscillator</code>中可用。 我建议您尝试将两者都替换，而不是我们之前使用的<code>AKOscillator</code> 。 <br><br><h1> 和弦 </h1><br> 在1970年代，运动开始于由模块化合成器（由单独的包络振荡器和滤波器组成）到微处理器的合成器。 代替使用模拟电路，声音开始以数字格式产生。 这使得合成器更便宜，更紧凑，雅马哈等品牌的合成器非常受欢迎。 <br><br><img src="https://habrastorage.org/webt/xi/2y/uc/xi2yucsslswbjqknyj0b_8cgtcw.jpeg"><br><br> 我们所有的游乐场都只能一次演奏一个音符。 许多乐器一次可以演奏多个音符，它们被称为<b>和弦</b> 。 只能演奏一个音符的乐器称为<b>单音</b> 。 <br><br> 为了获得和弦声音，可以创建多个振荡器并将其发送到混音器，但是在AudioKit中，有一种更合适的方法。 <br><br> 在操场上创建一个新页面并将其命名为Polyphony。 将生成的代码替换为以下内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitUI <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PlaygroundSupport let bank = AKOscillatorBank() AudioKit.output = bank try AudioKit.start()</code> </pre> <br> 在这里，我们创建了振荡器组<code>AKOscillatorBank</code> 。 如果转到类声明，则会发现它是<code>AKPolyphonicNode</code>的继承人，而后者又是我们已经知道的<code>AKNode</code>的继承人，并且还实现了<code>AKPolyphonic</code>协议。 <br><br> 结果，振荡器组与我们之前讨论的是相同的AudioKit节点。 它的输出可以发送到混音器，信封或任何其他滤镜和效果。  <code>AKPolyphonic</code>协议描述了如何在和弦音符上弹奏音符；让我们更详细地考虑它。 <br><br> 为了测试振荡器，我们需要一种同时演奏多个音符的方法。 这一点都不困难！ <br><br> 将以下代码添加到播放列表中，并确保实时显示处于打开状态： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiveView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AKLiveViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AKKeyboardDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboard = <span class="hljs-type"><span class="hljs-type">AKKeyboardView</span></span>(width: <span class="hljs-number"><span class="hljs-number">440</span></span>, height: <span class="hljs-number"><span class="hljs-number">100</span></span>) addView(keyboard) } } <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.liveView = <span class="hljs-type"><span class="hljs-type">LiveView</span></span>() <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.needsIndefiniteExecution = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 运动场编译时，您将看到以下内容： <br><br><img src="https://habrastorage.org/webt/c4/jc/ra/c4jcramxnalsdi-ksf1nfq5zm80.png"><br><br> 酷吧？ 音乐键盘就在操场上！ <br><br>  <code>AKKeyboardView</code>是<code>AKKeyboardView</code>的另一个实用程序，可让您轻松探索框架的可能性。 按这些键，您将发现它们没有发出任何声音。 <br><br> 使用以下命令更新<code>PlaygroundView</code>的设置： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboard = <span class="hljs-type"><span class="hljs-type">AKKeyboardView</span></span>(width: <span class="hljs-number"><span class="hljs-number">440</span></span>, height: <span class="hljs-number"><span class="hljs-number">100</span></span>) keyboard.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addView(keyboard)</code> </pre> <br> 这将使我们的<code>PlaygroundView</code>成为键盘代表，并允许您响应按键。 <br><br> 更新类声明，如下所示： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiveView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AKLiveViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AKKeyboardDelegate</span></span></span></span></code> </pre> <br><br> 还可以在<code>setUp</code>之后添加一些方法： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noteOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(note: MIDINoteNumber)</span></span></span></span> { bank.play(noteNumber: note, velocity: <span class="hljs-number"><span class="hljs-number">80</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noteOff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(note: MIDINoteNumber)</span></span></span></span> { bank.stop(noteNumber: note) }</code> </pre> <br> 每次您按下一个键， <code>noteOn</code>方法都会被<code>noteOn</code> ，它所做的只是告诉振荡器组开始播放该音符，在<code>noteOff</code>方法中，该<code>noteOff</code>将停止播放。 <br><br> 按住鼠标并滑动键，您会听到一个优美的渐强声（一个音乐术语，表示声功率逐渐增加）。 振荡器组已经包含一个内置的ADSR效果，因此，一个音符的衰减与下一个音符的攻击混合在一起，听起来非常不错。 <br><br> 您可能已经注意到，给我们提供按键的音符不是以频率的形式出现的。 它们被声明为<code>MIDINoteNumber</code> 。 如果您转到此类广告，则会看到以下内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">MIDINoteNumber</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br>  MIDI代表乐器数字接口。 这是乐器相互之间相互作用的一种普遍形式。 音符编号对应于标准音乐键盘上的音符。 第二个参数-此力度（力度）对应于按键的击打强度。 值越低，按键的触感越柔和，最终声音就越安静。 <br><br> 最后，您需要在按键上启用复音模式。 将以下代码添加到<code>setUp</code>方法： <br><br><pre> <code class="swift hljs">keyboard.polyphonicMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 现在，您可以同时演奏多个音符，如图所示： <br><br><img src="https://habrastorage.org/webt/ji/vq/_x/jivq_xdx2rewvc4prnyjtu4b2p8.png"><br><br> 顺便说一下，这是在C专业:) <br><br>  AudioKit的故事早就开始了。 今天，它使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Soundpipe</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Csound的</a>代码（1985年启动的MIT项目）。 令人惊讶的是，我们现在在操场上启动并添加到iPhone中的代码是大约30年前编写的。 <br><br><h1> 取样方式 </h1><br> 我们之前探讨的声音合成技术正在尝试使用简单的基本块（振荡器，滤波器和混音器）来再现逼真的声音。  1970年代初期，计算机功能的发展导致出现了一种新的方法-采样声音，其目的是创建声音的数字副本。 <br><br> 采样是一种非常简单的技术，类似于数码摄影。 在以固定间隔进行采样的过程中，将记录声波的振幅： <br><br><img src="https://habrastorage.org/webt/o4/a_/uu/o4a_uur6ow0lpjkukkaappxx25a.png"><br><br> 有两个参数会影响声音的录制精度： <br><br><ul><li>  <b>位深度</b> ：或位深度，采样器可以播放的各个音量级别的数量 <br></li><li>  <b>采样率</b> ：或采样率，表示多久进行一次幅度测量。 以赫兹为单位。 <br></li></ul><br> 让我们在一个新的游乐场中探索这些属性。 创建一个新页面并将其命名为“ Samples”。 将生成的代码替换为以下内容： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKitPlaygrounds <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AudioKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PlaygroundSupport let file = try AKAudioFile(readFileName: "climax-disco-part2.wav", baseDir: .resources) let player = try AKAudioPlayer(file: file) player.looping = true</code> </pre> <br> 上面的代码加载了样本，创建了音频播放器，并将其无休止地播放。 <br><br> 可<a href="">在此处</a>找到带有本教程的WAV文件的存档。 下载它并解压缩到游乐场的Resources文件夹。 <br><br> 然后在游乐场的末尾添加以下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.output = player <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.start() player.play() <span class="hljs-type"><span class="hljs-type">PlaygroundPage</span></span>.current.needsIndefiniteExecution = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 这将使您的音频播放器与AudioKit相连，您只需要调高音量即可欣赏！ <br><br>        ,         . <br><br> MP3-,    ,      ,      .                : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bitcrusher = <span class="hljs-type"><span class="hljs-type">AKBitCrusher</span></span>(player) bitcrusher.bitDepth = <span class="hljs-number"><span class="hljs-number">16</span></span> bitcrusher.sampleRate = <span class="hljs-number"><span class="hljs-number">40000</span></span></code> </pre> <br>      AudioKit: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.output = bitcrusher</code> </pre> <br>    .    ,      . <br><br> <code>AKBitCrusher</code> —   AudioKit,       . ,     ,       ZX Spectrum  BBC Micro.            ,  . <br><br>           ,     (. delay).     ,       <code>AKBitCrusher</code> .    : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delay = <span class="hljs-type"><span class="hljs-type">AKDelay</span></span>(player) delay.time = <span class="hljs-number"><span class="hljs-number">0.1</span></span> delay.dryWetMix = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>      0.1       .  <code>dryWetMix</code>          .     1 ,          . <br><br>   : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftPan = <span class="hljs-type"><span class="hljs-type">AKPanner</span></span>(player, pan: -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightPan = <span class="hljs-type"><span class="hljs-type">AKPanner</span></span>(delay, pan: <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> <code>AKPanner</code>     ,   - .             . <br><br>          AudioKit.  ,   <code>AKBitCrusher</code>  AudioKit   : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mix = <span class="hljs-type"><span class="hljs-type">AKMixer</span></span>(leftPan, rightPan) <span class="hljs-type"><span class="hljs-type">AudioKit</span></span>.output = mix</code> </pre> <br>  ,    ,         . <br><br><img src="https://habrastorage.org/webt/i0/6x/ha/i06xhaf2i0gnjeuebj3xqbdc3iw.png"><br><br><h1> 接下来是什么？ </h1><br>          AudioKit.    , -, ,  ,      .   ,      ,     . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440226/">https://habr.com/ru/post/zh-CN440226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440214/index.html">Spring和JDK 8：您还在Spring MVC注释中使用@Param和名称/值吗？ 那这篇文章是给你的</a></li>
<li><a href="../zh-CN440216/index.html">我如何教Zabbix监视节点并报告问题</a></li>
<li><a href="../zh-CN440218/index.html">无法封闭的DoS攻击：采购有其自身的氛围</a></li>
<li><a href="../zh-CN440220/index.html">冒名顶替综合症不仅有害，而且有益</a></li>
<li><a href="../zh-CN440222/index.html">水下超声波测距仪模块</a></li>
<li><a href="../zh-CN440230/index.html">国家杜马推迟了对新闻聚合者法案的讨论</a></li>
<li><a href="../zh-CN440232/index.html">关于“可持续性工作”条例草案的条例草案-二读之前该怎么办？</a></li>
<li><a href="../zh-CN440234/index.html">朱莉娅和一群粒子</a></li>
<li><a href="../zh-CN440236/index.html">职业类固醇。 基本算法</a></li>
<li><a href="../zh-CN440238/index.html">产品经理如何破坏最后一个阶段的发布</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>