<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ·ï¸ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ™ŒğŸ¼ Satu triliun lajang â˜˜ï¸ ğŸ¤˜ğŸ» ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sumber Gambar: www.nikonsmallworld.com 


 Anti-plagiarisme adalah mesin pencari khusus, yang sudah ditulis sebelumnya . Dan setiap mesin pencari, apa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Satu triliun lajang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/antiplagiat/blog/445952/"><p><img src="https://habrastorage.org/webt/hc/qv/ma/hcqvmaxyzdevsbs7cs8lw_fpile.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.nikonsmallworld.com</a></em></sub> </p><br><p>  Anti-plagiarisme adalah mesin pencari khusus, yang sudah ditulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Dan setiap mesin pencari, apa pun yang dikatakan, untuk bekerja dengan cepat, memerlukan indeks sendiri, yang memperhitungkan semua fitur dari area pencarian.  Dalam artikel pertama saya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Habr,</a> saya akan berbicara tentang implementasi saat ini dari indeks pencarian kami, sejarah perkembangannya dan alasan untuk memilih satu atau solusi lain.  Algoritme .NET yang efektif bukan mitos, tetapi kenyataan yang sulit dan produktif.  Kami akan terjun ke dunia hashing, kompresi bitwise, dan cache prioritas multi-level.  Bagaimana jika Anda membutuhkan pencarian lebih cepat daripada <b>O (1)</b> ? </p><br><p>  Jika orang lain tidak tahu di mana sinanaga dalam gambar ini, selamat datang ... </p><br><p><a name="habracut"></a></p><br><h1>  Herpes zoster, indeks dan mengapa mencari mereka </h1><br><p>  Sirap adalah sepotong teks beberapa kata dalam ukuran.  Herpes zoster saling tumpang tindih, maka nama (Inggris, herpes zoster - skala, ubin).  Ukuran spesifik mereka adalah rahasia terbuka - 4 kata.  Atau 5?  Yah, itu tergantung.  Namun, bahkan nilai ini memberikan sedikit dan tergantung pada komposisi kata berhenti, algoritma untuk menormalkan kata, dan detail lainnya yang tidak signifikan dalam kerangka kerja artikel ini.  Pada akhirnya, kita menghitung hash 64-bit berdasarkan sirap ini, yang akan kita sebut sirap di masa depan. </p><br><p>  Menurut teks dokumen, Anda dapat membuat banyak sirap, yang jumlahnya sebanding dengan jumlah kata dalam dokumen: </p><br><p>  <em>teks: string â†’ sirap: uint64 []</em> </p><br><p>  Jika beberapa herpes zoster bertepatan dalam dua dokumen, kami menganggap bahwa dokumen saling bersilangan.  Semakin banyak sinanaga cocok, semakin banyak teks identik dalam pasangan dokumen ini.  Indeks mencari dokumen yang memiliki jumlah persimpangan terbesar dengan dokumen yang diperiksa. </p><br><p><img src="https://habrastorage.org/webt/ud/th/z_/udthz_wa_avl6zbaij-cydicgx8.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><p>  Indeks herpes zoster memungkinkan Anda untuk melakukan dua operasi utama: </p><br><ol><li><p>  Buat indeks herpes zoster dokumen dengan pengidentifikasi mereka: </p><br><p>  <i>index.Add (docId, herpes zoster)</i> </p></li><li><p>  Cari dan tampilkan daftar pengidentifikasi peringkat untuk dokumen yang tumpang tindih: </p><br><p>  <i>index.Search (herpes zoster) â†’ (docId, skor) []</i> </p></li></ol><br><p>  Algoritme peringkat, saya yakin, layak untuk artikel yang terpisah secara umum, jadi kami tidak akan menulisnya di sini. </p><br><p> Indeks herpes zoster sangat berbeda dari rekan teks lengkap yang terkenal, seperti Sphinx, Elastic atau lebih besar: Google, Yandex, dll ... Di satu sisi, itu tidak memerlukan NLP dan kesenangan hidup lainnya.  Semua pemrosesan teks dikeluarkan dan tidak memengaruhi proses, serta urutan sirap dalam teks.  Di sisi lain, permintaan pencarian bukanlah kata atau frasa dari beberapa kata, tetapi hingga beberapa ratus ribu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hash</a> , yang semuanya penting dalam agregat, dan tidak secara terpisah. </p><br><p>  Secara hipotesis, Anda dapat menggunakan indeks teks lengkap sebagai pengganti indeks herpes zoster, tetapi perbedaannya terlalu besar.  Cara termudah untuk menggunakan beberapa penyimpanan kunci-nilai-terkenal, ini akan disebutkan di bawah ini.  Kami melihat implementasi <s>sepeda</s> kami, yang disebut - ShingleIndex. </p><br><p>  Kenapa kita repot-repot begitu?  Tapi kenapa. </p><br><ul><li>  <u>Volume</u> : <br><ol><li>  Ada banyak dokumen.  Sekarang kami memiliki sekitar 650 juta dari mereka, dan tahun ini jelas akan ada lebih banyak dari mereka; </li><li>  Jumlah herpes zoster unik tumbuh dengan pesat, dan sudah mencapai ratusan miliar.  Kami menunggu satu triliun. </li></ol></li><li>  <u>Kecepatan</u> : <br><ol><li>  Pada siang hari, selama sesi musim panas, lebih dari 300 ribu dokumen diperiksa melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem Anti-Plagiarisme</a> .  Ini sedikit menurut standar mesin pencari populer, tetapi tetap dalam nada; </li><li>  Untuk verifikasi dokumen yang berhasil karena keunikannya, jumlah dokumen yang diindeks harus lebih besar dari pada dokumen yang diperiksa.  Versi indeks kami saat ini rata-rata dapat diisi dengan kecepatan lebih dari 4000 dokumen sedang per detik. </li></ol></li></ul><br><p>  Dan itu semua dalam satu mesin!  Ya, kami dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mereplikasi</a> , kami secara bertahap mendekati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sharding</a> dinamis pada sebuah cluster, tetapi dari 2005 hingga hari ini, indeks pada satu mesin dengan perawatan yang cermat telah mampu mengatasi semua kesulitan di atas. </p><br><h1>  Pengalaman aneh </h1><br><p>  Namun, sekarang kami sangat berpengalaman.  Suka atau tidak, tetapi kita juga telah tumbuh dan telah mencoba berbagai hal dalam perjalanan pertumbuhan, yang menyenangkan untuk diingat sekarang. </p><br><p><img src="https://habrastorage.org/webt/nx/l4/jx/nxl4jxkzhzumxh91qyds84byk70.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><p>  Pertama-tama, pembaca yang tidak berpengalaman ingin menggunakan database SQL.  Anda bukan satu-satunya yang berpikir begitu, implementasi SQL telah membantu kami dengan baik selama beberapa tahun untuk mengimplementasikan koleksi yang sangat kecil.  Namun demikian, fokusnya langsung pada jutaan dokumen, jadi saya harus melangkah lebih jauh. </p><br><p>  Seperti yang Anda tahu, tidak ada yang suka sepeda, dan LevelDB belum dibuka untuk umum, jadi pada 2010 mata kami tertuju pada BerkeleyDB.  Semuanya keren - basis-nilai kunci bawaan yang persisten dengan metode akses btree dan hash yang cocok dan sejarah yang panjang.  Semuanya dengan dia luar biasa, tetapi: </p><br><ul><li>  Dalam kasus implementasi hash, ketika mencapai volume 2GB, itu hanya jatuh.  Ya, kami masih bekerja dalam mode 32-bit; </li><li>  Implementasi B + tree bekerja dengan stabil, tetapi dengan volume lebih dari beberapa gigabytes, kecepatan pencarian mulai menurun secara signifikan. </li></ul><br><p>  Kita harus mengakui bahwa kita tidak pernah menemukan cara untuk menyesuaikannya dengan tugas kita.  Mungkin masalahnya ada di .net-binding, yang masih harus diselesaikan.  Implementasi BDB akhirnya digunakan sebagai pengganti SQL sebagai indeks perantara sebelum mengisi yang utama. </p><br><p>  Waktu berlalu.  Pada 2014, mereka mencoba LMDB dan LevelDB, tetapi tidak menerapkannya.  Orang-orang dari Departemen Penelitian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anti-Plagiarisme kami</a> menggunakan RocksDB sebagai indeks mereka.  Pada pandangan pertama, itu adalah temuan.  Tetapi pengisian ulang yang lambat dan kecepatan pencarian biasa-biasa saja bahkan pada volume kecil membawa segalanya sia-sia. </p><br><p>  Kami melakukan semua hal di atas, sambil mengembangkan indeks kustom kami sendiri.  Akibatnya, ia menjadi sangat pandai memecahkan masalah kami sehingga kami meninggalkan "sumbat" sebelumnya dan berfokus untuk memperbaikinya, yang sekarang kami gunakan dalam produksi di mana-mana. </p><br><h1>  Lapisan indeks </h1><br><p>  Pada akhirnya, apa yang kita miliki sekarang?  Bahkan, indeks herpes zoster terdiri dari beberapa lapisan (array) dengan elemen dengan panjang konstan - dari 0 hingga 128 bit - yang tidak hanya bergantung pada lapisan dan tidak harus merupakan kelipatan dari delapan. </p><br><p>  Setiap lapisan berperan.  Beberapa membuat pencarian lebih cepat, beberapa menghemat ruang, dan beberapa tidak pernah digunakan, tetapi sangat dibutuhkan.  Kami akan mencoba menggambarkannya untuk meningkatkan efisiensi total dalam pencarian. </p><br><p><img src="https://habrastorage.org/webt/sd/y9/ze/sdy9zefei-lyrhgpafxq9viz9pc.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><h4>  1. Array Indeks </h4><br><p>  Tanpa kehilangan sifat umum, kita sekarang akan mempertimbangkan bahwa sirap tunggal ditugaskan ke dokumen, </p><br><p>  <i>(docId â†’ sirap)</i> </p><br><p>  Kami akan menukar elemen pasangan (terbalik, karena indeks sebenarnya "terbalik"!), </p><br><p>  <i>(sirap â†’ docId)</i> </p><br><p>  Urutkan berdasarkan nilai-nilai herpes zoster dan bentuk sebuah layer.  Karena  ukuran sirap dan pengidentifikasi dokumen adalah konstan, sekarang siapa pun yang memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian biner</a> dapat menemukan pasangan di luar pembacaan <b>O (logn)</b> file.  Sebanyak itu, sangat banyak.  Tapi ini lebih baik daripada hanya <b>O (n)</b> . </p><br><p>  Jika dokumen memiliki beberapa herpes zoster, maka akan ada beberapa pasangan dari dokumen tersebut.  Jika ada beberapa dokumen dengan sirap yang sama, maka ini juga tidak akan banyak berubah - akan ada beberapa pasangan berturut-turut dengan sirap yang sama.  Dalam kedua kasus ini, pencarian akan berlangsung untuk waktu yang sebanding. </p><br><h4>  2. Array kelompok </h4><br><p>  Kami membagi elemen indeks dengan hati-hati dari langkah sebelumnya ke dalam grup dengan cara apa pun yang mudah.  Sebagai contoh, sehingga mereka masuk ke <s>dalam sektor cluster, blok</s> unit alokasi (baca, 4096 bytes), dengan mempertimbangkan jumlah bit dan trik lainnya, akan membentuk kamus yang efektif.  Kami mendapatkan sederetan posisi grup seperti itu: </p><br><p>  <i>group_map (hash (sirap)) -&gt; group_position.</i> </p><br><p>  Saat mencari sirap, kami sekarang akan mencari posisi grup di kamus ini, dan kemudian membongkar grup dan mencari langsung di memori.  Seluruh operasi membutuhkan dua bacaan. </p><br><p>  Kamus posisi grup membutuhkan beberapa kali lipat lebih kecil dari indeks itu sendiri, seringkali dapat dengan mudah diturunkan ke memori.  Dengan demikian, tidak akan ada dua bacaan, tetapi satu.  Total, <b>O (1)</b> . </p><br><h4>  3. Filter Bloom </h4><br><p>  Pada wawancara, kandidat sering memecahkan masalah dengan mengeluarkan solusi unik dengan <b>O (n ^ 2)</b> atau bahkan <b>O (2 ^ n)</b> .  Tetapi kita tidak melakukan hal-hal bodoh.  Apakah ada <b>O (0)</b> di dunia, itu pertanyaannya?  Mari kita coba tanpa banyak harapan untuk hasilnya ... </p><br><p>  Mari kita beralih ke area subjek.  Jika siswa selesai dengan baik dan menulis karya sendiri, atau hanya tidak ada teks, tetapi sampah, maka sebagian besar herpes zoster akan menjadi unik dan tidak akan ditemukan dalam indeks.  Struktur data seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter Bloom</a> dikenal di dunia.  Sebelum mencari, periksa sirap di atasnya.  Jika tidak ada sirap dalam indeks, maka Anda tidak dapat melihat lebih jauh, jika tidak melangkah lebih jauh. </p><br><p>  Filter Bloom itu sendiri cukup sederhana, tetapi tidak masuk akal untuk menggunakan vektor hash dengan volume kami.  Cukup menggunakan satu: <b>+1</b> membaca dari filter Bloom.  Ini memberikan pembacaan <b>-1</b> atau <b>-2</b> dari tahap berikutnya, jika sirapnya unik, dan tidak ada false positive dalam filter.  Awasi tanganmu! </p><br><p>  Probabilitas kesalahan filter Bloom ditetapkan selama konstruksi, probabilitas sirap yang tidak diketahui ditentukan oleh kejujuran siswa.  Perhitungan sederhana bisa sampai pada ketergantungan berikut: </p><br><ul><li>  Jika kami mempercayai kejujuran orang (mis., Sebenarnya dokumen itu asli), maka kecepatan pencarian akan berkurang; </li><li>  Jika dokumen dijahit dengan jelas, maka kecepatan pencarian akan meningkat, tetapi kita membutuhkan banyak memori. </li></ul><br><p>  Dengan kepercayaan pada siswa, kami memiliki prinsip "kepercayaan, tetapi verifikasi", dan latihan menunjukkan bahwa masih ada keuntungan dari filter Bloom. </p><br><p>  Mengingat bahwa struktur data ini juga lebih kecil dari indeks itu sendiri dan dapat di-cache, dalam kasus terbaik, ini memungkinkan Anda untuk menjatuhkan sirap tanpa akses disk sama sekali. </p><br><h4>  4. Ekor yang berat </h4><br><p>  Ada herpes zoster yang ditemukan hampir di mana-mana.  Bagian mereka dalam jumlah total sangat sedikit, tetapi ketika membangun indeks pada langkah pertama, pada langkah kedua, kelompok puluhan dan ratusan MB dapat diperoleh.  Kami akan mengingatnya secara terpisah dan kami akan segera membuangnya dari permintaan pencarian. </p><br><p>  Ketika langkah sepele ini pertama kali digunakan pada tahun 2011, ukuran indeks dibelah dua, dan pencarian itu sendiri dipercepat. </p><br><h4>  5. Ekor lainnya </h4><br><p>  Meski begitu, sirap dapat memiliki banyak dokumen.  Dan ini normal.  Puluhan, ratusan, ribuan ... Menjaga mereka di dalam indeks utama menjadi tidak menguntungkan, mereka juga tidak dapat masuk ke dalam grup, dari mana volume kamus posisi grup meningkat.  Tempatkan mereka dalam urutan terpisah dengan penyimpanan yang lebih efisien.  Menurut statistik, keputusan seperti itu lebih dari dibenarkan.  Selain itu, berbagai paket bitwise dapat mengurangi jumlah akses disk dan mengurangi volume indeks. </p><br><p>  Akibatnya, untuk kemudahan perawatan, kami mencetak semua lapisan ini menjadi satu file besar - potongan.  Ada sepuluh lapisan di dalamnya.  Tetapi bagian tidak digunakan dalam pencarian, bagian sangat kecil dan selalu disimpan dalam memori, bagian secara aktif di-cache seperlunya / mungkin. </p><br><p>  Dalam pertempuran, paling sering pencarian sirap turun ke satu atau dua bacaan file acak.  Dalam kasus terburuk, Anda harus melakukan tiga.  Semua lapisan secara efektif (kadang-kadang bitwise) dikemas dengan susunan elemen dengan panjang konstan.  Begitulah normalisasi.  Waktu untuk membongkar tidak signifikan dibandingkan dengan harga total volume selama penyimpanan dan kemampuan untuk menyimpan lebih baik. </p><br><p>  Ketika membangun, ukuran lapisan terutama dihitung terlebih dahulu, ditulis berurutan, sehingga prosedur ini cukup cepat. </p><br><h1>  Bagaimana Anda sampai di sana, tidak tahu di mana </h1><br><p></p><blockquote><code>     2010         ,                .    ,          .  ,      .</code> </blockquote> <br><p><img src="https://habrastorage.org/webt/2x/f7/-f/2xf7-fs8nt4rmfx7cvmeyyb_ftq.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><p>  Awalnya, indeks kami terdiri dari dua bagian - konstanta, yang dijelaskan di atas, dan sementara, yang perannya adalah SQL, atau BDB, atau log pembaruannya sendiri.  Kadang-kadang, misalnya, sebulan sekali (dan kadang-kadang setahun), yang sementara diurutkan, disaring dan digabung dengan yang utama.  Hasilnya adalah yang bersatu, dan dua yang lama dihapus.  Jika yang sementara tidak dapat masuk ke dalam RAM, maka prosedur dilakukan melalui penyortiran eksternal. </p><br><p>  Prosedur ini agak merepotkan, itu dimulai dalam mode semi-manual dan diperlukan sebenarnya menulis ulang seluruh file indeks dari awal.  Menulis ulang ratusan gigabyte untuk beberapa juta dokumen - yah, sangat-sangat menyenangkan, saya katakan ... </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Kenangan dari masa lalu ...</b> <div class="spoiler_text"><blockquote> <code>       SSD.        ,  31    SSD          wcf-       .  ,          . ,  .</code> </blockquote> </div></div><br><p>  Agar SSD tidak terlalu tegang, dan indeks diperbarui lebih sering, pada tahun 2012 kami melibatkan rantai beberapa bagian, potongan sesuai dengan skema berikut: </p><br><p><img src="https://habrastorage.org/webt/v4/5s/xo/v45sxoctvil0bhwkf2pfp7vamrs.png"></p><br><p>  Di sini indeks terdiri dari rantai dengan tipe potongan yang sama, kecuali untuk yang pertama.  Yang pertama, addon, adalah log append-only dengan indeks dalam RAM.  Potongan berikutnya bertambah dalam ukuran (dan usia) hingga yang terakhir (nol, utama, root, ...). </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Catatan untuk pengendara sepeda ...</b> <div class="spoiler_text">  Terkadang Anda tidak harus bingung menulis kode dan bahkan tidak berpikir, tetapi cukup google saja.  Sampai dengan notasi, diagram ini mirip dengan yang ini dari artikel 1996 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pohon gabungan-log struktur"</a> : <img src="https://habrastorage.org/webt/1z/r2/yh/1zr2yhxxboh0syuyfozcujnm5hm.png"></div></div><br><p>  Saat menambahkan dokumen, pertama kali dilipat menjadi addon.  Ketika penuh atau dengan kriteria lain, sepotong permanen dibangun di atasnya.  Beberapa potongan tetangga, jika perlu, digabung menjadi yang baru, dan yang asli dihapus.  Memperbarui dokumen atau menghapusnya berhasil dengan cara yang sama. </p><br><p>  Gabungkan kriteria, panjang rantai, algoritma bypass, akuntansi untuk item yang dihapus dan pembaruan, parameter lainnya disetel.  Pendekatan itu sendiri terlibat dalam beberapa tugas serupa dan mengambil bentuk sebagai kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LSM</a> internal yang terpisah pada .net bersih.  Sekitar waktu yang sama, LevelDB menjadi populer. </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Sedikit komentar tentang LSM-tree</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LSM-Tree adalah</a> algoritma yang agak menarik, dengan justifikasi yang baik.  Tapi, IMHO, ada beberapa kekaburan dari arti Pohon istilah.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> aslinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> itu tentang rantai pohon dengan kemampuan untuk mentransfer cabang.  Dalam implementasi modern, ini tidak selalu terjadi.  Jadi kerangka kerja kami akhirnya dinamai sebagai LsmChain, yaitu rantai potongan lsm. </div></div><br><p>  Algoritme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LSM</a> dalam kasus kami memiliki fitur yang sangat cocok: </p><br><ol><li>  sisipkan / hapus / perbarui, </li><li>  mengurangi beban SSD saat memperbarui, </li><li>  format potongan disederhanakan, </li><li>  pencarian selektif hanya pada potongan lama / baru, </li><li>  cadangan sepele </li><li>  apa lagi yang diinginkan jiwa. </li><li>  ... </li></ol><br><p>  Secara umum, terkadang berguna untuk menciptakan sepeda untuk pengembangan diri. </p><br><h1>  Optimalisasi makro, mikro, nano </h1><br><p>  Dan akhirnya, kami akan berbagi kiat teknis tentang bagaimana kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antiplagiarisme</a> melakukan hal-hal seperti itu di Net (dan tidak hanya di atasnya). </p><br><p>  Perhatikan sebelumnya bahwa seringkali semuanya sangat tergantung pada perangkat keras khusus Anda, data atau mode penggunaan.  Setelah memutar di satu tempat, kami terbang keluar dari cache CPU, di tempat lain - kami mengalami bandwidth antarmuka SATA, di tempat ketiga - kami mulai menggantung di GC.  Dan di suatu tempat di inefisiensi pelaksanaan panggilan sistem tertentu. </p><br><p><img src="https://habrastorage.org/webt/gl/pq/sp/glpqspyystghvhhemtthxysivp0.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><h1>  Bekerja dengan file </h1><br><p>  Masalah dengan akses ke file tidak unik dengan kami.  Ada file besar <s>exabyte terabyte</s> , volume yang berkali-kali lebih besar dari jumlah RAM.  Tugasnya adalah membaca jutaan yang tersebar di sekitarnya dari beberapa nilai acak kecil.  Dan untuk melakukannya dengan cepat, efisien dan murah.  Kami harus memeras, membandingkan, dan banyak berpikir. </p><br><p>  Mari kita mulai dengan yang sederhana.  Untuk membaca byte berharga Anda perlu: </p><br><ol><li>  Buka file (FileStream baru); </li><li>  Pindah ke posisi yang diinginkan (Posisi atau Carilah, tidak ada perbedaan); </li><li>  Baca array byte yang diinginkan (Baca); </li><li>  Tutup file (Buang). </li></ol><br><p>  Dan ini buruk, karena panjang dan suram.  Melalui uji coba, kesalahan, dan berulang kali menginjak menyapu, kami mengidentifikasi algoritma tindakan berikut: </p><br><ul><li><p>  <b>Terbuka tunggal, banyak baca</b> </p><br><p>  Jika urutan ini dilakukan di dahi, untuk setiap permintaan ke disk, maka kami akan segera menekuk.  Masing-masing item masuk ke permintaan ke kernel OS, yang mahal. </p><br><p>  Jelas, Anda harus membuka file satu kali dan membaca secara berurutan dari semua jutaan nilai kami, yang kami lakukan </p></li><li><p>  <b>Tidak ada yang ekstra</b> </p><br><p>  Mendapatkan ukuran file, posisi saat ini di dalamnya juga cukup sulit dioperasikan.  Bahkan jika file tidak berubah. </p><br><p>  Setiap pertanyaan seperti mendapatkan ukuran file atau posisi saat ini di dalamnya harus dihindari. </p></li><li><p>  <b>Filestreampool</b> </p><br><p>  Selanjutnya  Sayangnya, FileStream pada dasarnya single-threaded.  Jika Anda ingin membaca file secara paralel, Anda harus membuat / menutup aliran file baru. </p><br><p>  Sampai Anda membuat sesuatu seperti aiosync, Anda harus menciptakan sepeda sendiri. </p><br><p>  Saran saya adalah membuat kumpulan aliran file per file.  Ini akan menghindari membuang-buang waktu membuka / menutup file.  Dan jika Anda menggabungkannya dengan ThreadPool dan memperhitungkan bahwa SSD mengeluarkan megaIOPS-nya dengan multithreading yang kuat ... Anda mengerti saya. </p></li><li><p>  <b>Unit alokasi</b> </p><br><p>  Selanjutnya  Perangkat penyimpanan (HDD, SSD, Optane) dan sistem file beroperasi dengan file pada level blok (cluster, sektor, unit alokasi).  Mereka mungkin tidak cocok, tetapi sekarang hampir selalu 4096 byte.  Membaca satu atau dua byte di perbatasan dua blok seperti itu di SSD sekitar satu setengah kali lebih lambat daripada di dalam blok itu sendiri. </p><br><p>  Anda harus mengatur data Anda sehingga elemen yang dikurangkan berada dalam batas-batas blok <s>sektor cluster</s> . </p></li><li><p>  <b>Tanpa buffer.</b> </p><br><p>  Selanjutnya  FileStream secara default menggunakan buffer 4096 byte.  Dan berita buruknya adalah Anda tidak bisa mematikannya.  Namun, jika Anda membaca lebih banyak data daripada ukuran buffer, maka yang terakhir akan diabaikan. </p><br><p>  Untuk pembacaan acak, Anda harus mengatur buffer ke 1 byte (tidak akan bekerja kurang) dan kemudian mempertimbangkan bahwa itu tidak digunakan. </p></li><li><p>  <b>Gunakan penyangga.</b> </p><br><p>  Selain bacaan acak, ada juga yang berurutan.  Di sini buffer sudah bisa menjadi berguna jika Anda tidak ingin membaca semuanya sekaligus.  Saya menyarankan Anda untuk mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini.  Ukuran buffer yang akan diatur tergantung pada apakah file tersebut ada pada HDD atau pada SSD.  Dalam kasus pertama, 1MB akan optimal, yang kedua, 4kB standar akan cukup.  Jika ukuran area data yang akan dibaca sebanding dengan nilai-nilai ini, maka lebih baik untuk mengurangkannya sekaligus, melompati buffer, seperti dalam kasus pembacaan acak.  Buffer besar tidak akan menghasilkan keuntungan dalam kecepatan, tetapi akan mulai menekan GC. </p><br><p>  Saat secara berurutan membaca potongan besar file, Anda harus mengatur buffer ke 1MB untuk HDD dan 4kB untuk SSD.  Yah, itu tergantung. </p></li></ul><br><h1>  MMF vs FileStream </h1><br><p>  Pada 2011, tip datang ke MemoryMappedFile, karena mekanisme ini telah diterapkan sejak .Net Framework v4.0.  Pertama, mereka menggunakannya ketika caching filter Bloom, yang sudah tidak nyaman dalam mode 32-bit karena keterbatasan 4GB.  Tetapi ketika pindah ke dunia 64 bit, saya menginginkan lebih.  Tes pertama sangat mengesankan.  Caching gratis, kecepatan aneh, antarmuka pembacaan struktur yang nyaman.  Tapi ada masalah: </p><br><ul><li>  Pertama, anehnya, kecepatan.  Jika data sudah di-cache, maka semuanya baik-baik saja.  Tetapi jika tidak, membaca satu byte dari file disertai dengan "mengangkat" jumlah data yang jauh lebih besar daripada dengan pembacaan reguler. </li><li>  Kedua, cukup aneh, daya ingat.  Ketika dipanaskan, memori bersama tumbuh, workingset - tidak, yang logis.  Tetapi kemudian proses tetangga mulai berperilaku tidak terlalu baik.  Mereka dapat melakukan swap, atau secara tidak sengaja jatuh dari OoM.  Volume yang ditempati oleh MMF dalam RAM, sayangnya, tidak dapat dikontrol.  Dan keuntungan dari cache dalam kasus ketika file yang dapat dibaca adalah beberapa pesanan lebih besar dari memori menjadi tidak berarti. </li></ul><br><p>  Masalah kedua masih bisa diperjuangkan.  Hilang jika indeks bekerja di buruh pelabuhan atau pada mesin virtual khusus.  Tapi masalah kecepatannya fatal. </p><br><p>  Akibatnya, MMF ditinggalkan sedikit lebih dari sepenuhnya.  Caching dalam Anti-Plagiarisme mulai dilakukan dalam bentuk eksplisit, jika mungkin mengingat-ingat lapisan yang paling sering digunakan pada prioritas dan batas yang diberikan. </p><br><p><img src="https://habrastorage.org/webt/qr/em/sd/qremsdrzpkqcxqrbam_finb4dyw.jpeg"></p><br><p>  <sub><em>Sumber Gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a></em></sub> </p><br><h1>  Bits / byte </h1><br><p>  Bukan byte dunia adalah satu.  Terkadang Anda harus turun ke level bit. </p><br><p>  Sebagai contoh: misalkan Anda memiliki triliun angka yang dipesan sebagian, berhasrat untuk menyimpan dan membaca sering.  Bagaimana cara mengatasi semua ini? </p><br><ul><li>  Penulisan Biner Sederhana.  - cepat tapi lambat.  Ukuran itu penting.  Pembacaan dingin terutama tergantung pada ukuran file. </li><li>  Variasi lain dari VarInt?  - cepat tapi lambat.  Masalah konsistensi.  Volume mulai tergantung pada data, yang membutuhkan memori tambahan untuk penentuan posisi. </li><li>  Packing sedikit?  - cepat tapi lambat.  Anda harus lebih hati-hati mengendalikan tangan Anda. </li></ul><br><p>  Tidak ada solusi yang ideal, tetapi dalam kasus khusus, cukup menekan kisaran dari 32 bit ke yang diperlukan untuk menyimpan ekor yang disimpan 12% lebih banyak (puluhan GB!) Daripada VarInt (tentu saja hanya menyimpan perbedaan yang bertetangga), dan itu beberapa kali opsi dasar. </p><br><p>  Contoh lain.  Anda memiliki tautan dalam file ke sejumlah array angka.  Tautan 64-bit, file per terabyte.  Segalanya tampak baik-baik saja.  Terkadang ada banyak angka dalam array, terkadang sedikit.  Seringkali sedikit.  Sangat sering.  Kemudian ambil dan simpan seluruh array dalam tautan itu sendiri.  Untung  Kemas dengan hati-hati tapi jangan lupa. </p><br><h1>  Struct, unsafe, batching, micro-opts </h1><br><p>  Nah dan optimalisasi mikro lainnya.  Saya tidak akan menulis di sini tentang dangkal "apakah layak menyimpan Panjang array dalam satu lingkaran" atau "yang lebih cepat, untuk atau foreach". </p><br><p>  Ada dua aturan sederhana, dan kami akan mematuhinya: 1. "benchmark semuanya", 2. "benchmark lebih banyak." </p><br><ul><li><p>  <b>Struct</b> .  Digunakan di mana-mana.  Jangan kirim GC.  Dan, seperti yang sedang modis saat ini, kami juga memiliki ValueList mega-cepat kami sendiri. </p></li><li><p>  <b>Tidak aman</b> .  Mengizinkan struktur mapit (dan tidak dipetakan) ke array byte saat digunakan.  Dengan demikian, kita tidak perlu alat serialisasi terpisah.  Benar, ada pertanyaan untuk menyematkan dan mendefragmentasi tumpukan, tetapi sejauh ini belum ditampilkan.  Yah, itu tergantung. </p></li><li><p>  <b>Batching</b> .  Pekerjaan dengan banyak elemen harus melalui paket / grup / blok.  Baca / tulis file, transfer antar fungsi.  Masalah terpisah adalah ukuran paket ini.  Biasanya ada yang optimal, dan ukurannya sering berkisar antara 1kB hingga 8MB (ukuran cache CPU, ukuran cluster, ukuran halaman, ukuran hal lain).  Cobalah memompa melalui fungsi &lt;nte&gt; IEnumerable atau IEnumerable &lt;byte [1024]&gt; dan rasakan perbedaannya. </p></li><li><p>  <b>Pooling</b> .  Setiap kali Anda menulis "baru," anak kucing mati di suatu tempat.  Sekali byte baru [ <a href="">85000</a> ] - dan traktor mengendarai satu ton angsa.  Jika tidak mungkin menggunakan stackalloc, maka buat kumpulan objek apa pun dan gunakan kembali. </p></li><li><p>  <b>Sebaris</b> .  Bagaimana cara membuat dua fungsi alih-alih satu dapat mempercepat semuanya sepuluh kali?  Sederhana  Semakin kecil ukuran tubuh dari fungsi (metode), semakin besar kemungkinan akan sejajar.  Sayangnya, di dunia dotnet masih tidak ada cara untuk melakukan inlining parsial, jadi jika Anda memiliki fungsi panas yang dalam 99% kasus keluar setelah memproses beberapa baris pertama, dan sisa seratus baris untuk memproses sisa 1%, maka dengan aman membaginya menjadi dua (atau tiga), membawa ekor yang berat ke fungsi yang terpisah. </p></li></ul><br><h1>  Apa lagi </h1><br><ul><li><p>  <b>Rentang &lt;T&gt;</b> , <b>Memori &lt;T&gt;</b> - menjanjikan.  Kode akan lebih sederhana dan mungkin sedikit lebih cepat.  Kami menunggu rilis .Net Core v3.0 dan Std v2.1 untuk beralih ke mereka, karena  kernel kami di .Net Std v2.0, yang biasanya tidak mendukung span. </p></li><li><p>  <b>Async / menunggu</b> - sejauh ini kontroversial.  Benchmark baca acak yang paling sederhana menunjukkan bahwa konsumsi CPU sebenarnya turun, tetapi kecepatan baca juga menurun.  Harus menonton.  Kami belum menggunakannya di dalam indeks. </p></li></ul><br><h1>  Kesimpulan </h1><br><p>  Saya berharap bahwa keterpencilan saya akan memberi Anda kesenangan dari memahami keindahan dari beberapa keputusan.  Kami sangat menyukai indeks kami.  Ini efisien, kode yang indah, bekerja dengan sangat baik.  Solusi yang sangat terspesialisasi dalam inti sistem, tempat kerja yang kritis, lebih baik daripada solusi umum.  Sistem kontrol versi kami mengingat insert assembler dalam kode C ++.  Sekarang ada empat plus - hanya C # murni, hanya. Net.  Di dalamnya kami menulis bahkan algoritma pencarian yang paling rumit dan tidak menyesal sama sekali.  Dengan munculnya .Net Core, transisi ke Docker, jalan menuju masa depan DevOps yang cerah telah menjadi lebih mudah dan lebih jelas.  Depan adalah solusi dari masalah shardisasi dan replikasi dinamis tanpa mengurangi efektivitas dan keindahan solusi. </p><br><p>  Terima kasih kepada semua orang yang membaca sampai akhir.  Untuk semua perbedaan dan ketidakkonsistenan lainnya, silakan tulis komentar.  Saya akan senang dengan saran dan bantahan yang masuk akal dalam komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445952/">https://habr.com/ru/post/id445952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445932/index.html">Keamanan Aplikasi Klien: Kiat Praktis untuk Pengembang Front-End</a></li>
<li><a href="../id445936/index.html">Pengembangan elektronik. Tentang mikrokontroler di jari</a></li>
<li><a href="../id445940/index.html">AMA dengan Habr, v 7.0. Lemon, Donat, dan Berita</a></li>
<li><a href="../id445946/index.html">MWC: petunjuk penggunaan</a></li>
<li><a href="../id445948/index.html">Warisan dalam C ++: pemula, menengah, lanjutan</a></li>
<li><a href="../id445954/index.html">Akselerator AI dari HSE, MTS dan Rostelecom</a></li>
<li><a href="../id445958/index.html">SPDS GraphiCS - sistem fasad dan atap</a></li>
<li><a href="../id445962/index.html">Magang di TI: pandangan manajer</a></li>
<li><a href="../id445964/index.html">MEPhI akan menyelenggarakan Olimpiade Keamanan Informasi Mahasiswa: cara berpartisipasi dan apa yang diberikannya</a></li>
<li><a href="../id445966/index.html">Catatan oleh arsitek frontend # 1. Anda tidak bisa mendapatkan dan menggunakan Redux.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>