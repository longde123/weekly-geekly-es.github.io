<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 🚸 🎅🏼 Bon, mauvais, mauvais - test dans un projet pour débutants ☺️ 👨🏿‍🤝‍👨🏻 🤽🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préface: l'université a reçu une tâche: constituer une équipe de mêlée, sélectionner un projet et travailler dessus pendant un semestre. Notre équipe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bon, mauvais, mauvais - test dans un projet pour débutants</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450290/"><p>  <strong>Préface:</strong> l'université a reçu une tâche: constituer une équipe de mêlée, sélectionner un projet et travailler dessus pendant un semestre.  Notre équipe a choisi le développement d'applications web (react + flask).  Dans cet article, je vais essayer de vous dire quels tests auraient dû être et d'analyser ce que nous avons fait sur le backend. </p><br><p><img src="https://habrastorage.org/webt/fb/z-/yc/fbz-ycgf0ewrp0logvj9mrosebi.png"></p><a name="habracut"></a><br><h1 id="ozhidaniya">  Les attentes </h1><br><p>  Les tests sont nécessaires, tout d'abord, pour convaincre tout le monde (y compris nous-mêmes) que le programme se comporte comme il se doit <em>dans les situations de test</em> .  Deuxièmement, ils assurent à l'avenir les performances <em>du</em> code <em>couvert par les tests</em> .  L'écriture de tests est un processus utile, car dans son processus, vous pouvez souvent tomber sur des zones à problèmes, rappeler des cas extrêmes, voir des problèmes d'interfaces, etc. </p><br><p> Lors du développement de systèmes, vous devez vous souvenir d'au moins trois types de tests: </p><br><ul><li>  <em>Les tests unitaires</em> sont des tests qui vérifient que les fonctions font ce dont elles ont besoin. </li><li>  <em>Les tests d'intégration</em> sont des tests qui vérifient que plusieurs fonctions ensemble agissent correctement. </li><li>  <em>Les tests système</em> sont des tests qui vérifient que l'ensemble du système fait ce dont il a besoin. </li></ul><br><p>  Dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un des articles</a> de google, un tableau a été publié avec une description de trois types de tests.  "Petit", "Moyen" et "Grand". </p><br><p><img src="https://habrastorage.org/webt/sy/ho/zj/syhozj8ytslkmlaxxnockcwv3b4.png"></p><br><h2 id="modulnye-testy">  Tests unitaires </h2><br><p>  Les tests unitaires correspondent à de petits tests - ils doivent être rapides et ne vérifier que l'exactitude de parties spécifiques du programme.  Ils ne doivent pas accéder à la base de données, ne doivent pas fonctionner dans des environnements complexes à plusieurs threads.  Ils contrôlent la conformité aux spécifications / normes, ils ont souvent le rôle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tests</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">régression</a> . </p><br><h2 id="integracionnye-testy">  Tests d'intégration </h2><br><p>  Les tests d'intégration sont les tests qui peuvent affecter plusieurs modules et fonctions.  De tels tests nécessitent plus de temps et peuvent nécessiter des environnements spéciaux.  Ils sont nécessaires pour garantir que les modules et fonctions individuels peuvent fonctionner ensemble.  C'est-à-dire  les tests unitaires vérifient la conformité des interfaces réelles aux tests attendus et d'intégration - que les fonctions et les modules interagissent correctement les uns avec les autres. </p><br><h2 id="sistemnye-testy">  Tests système </h2><br><p>  Il s'agit du plus haut niveau de tests automatiques.  Les tests système vérifient que l'ensemble du système fonctionne, que ses parties exécutent leurs tâches et sont capables d'interagir correctement. </p><br><h2 id="zachem-sledit-za-tipami">  Pourquoi garder une trace des types </h2><br><p>  Habituellement, avec la croissance du projet, la base de code augmentera également.  La durée des vérifications automatiques augmentera; prendre en charge un grand nombre de tests d'intégration et de système deviendra de plus en plus difficile.  Par conséquent, le défi pour les développeurs est de minimiser les tests nécessaires.  Pour ce faire, essayez d'utiliser des tests unitaires dans la mesure du possible et réduisez l'intégration à l'aide de «mocks» (mocks). </p><br><h1 id="realnost">  La réalité </h1><br><h2 id="tipichnyy-test-api">  Test API typique </h2><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_user_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.loads( client.post(url, json=data, content_type=<span class="hljs-string"><span class="hljs-string">'application/json'</span></span>).data ) response = client.post(<span class="hljs-string"><span class="hljs-string">'api/user.reg'</span></span>, json={ <span class="hljs-string"><span class="hljs-string">'email'</span></span>: <span class="hljs-string"><span class="hljs-string">'name@mail.ru'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>: <span class="hljs-string"><span class="hljs-string">'password1'</span></span>, <span class="hljs-string"><span class="hljs-string">'first_name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Name'</span></span>, <span class="hljs-string"><span class="hljs-string">'last_name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Last Name'</span></span> }) data = json.loads(response.data) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data[<span class="hljs-string"><span class="hljs-string">'code'</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  De la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle du flacon,</a> nous obtenons une recette prête à l'emploi pour initialiser l'application et créer la base de données.  Voici le travail avec la base de données.  Ce n'est pas un test unitaire, mais pas un test système.  Il s'agit d'un test d'intégration qui utilise une application de test de base de données. </p><br><p>  Pourquoi l'intégration plutôt que modulaire?  Parce que dans le traitement des requêtes, l'interaction est effectuée avec le flacon, avec l'ORM, avec notre logique métier.  Les gestionnaires agissent comme un élément unificateur des autres parties du projet, donc écrire des tests unitaires pour eux n'est pas trop facile (vous devez remplacer la base de données par des maquettes, une logique interne) et pas trop pratique (les tests d'intégration vérifieront des aspects similaires - "les fonctions nécessaires ont-elles été appelées?", " Les données ont-elles été correctement reçues? ", Etc.). </p><br><h2 id="nazvaniya-i-gruppirovka-testov">  Noms et regroupement des tests </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_not_empty_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_not_empty(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_not_empty(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_email_format(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'email is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_password_format(<span class="hljs-string"><span class="hljs-string">'pass'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'pass is empty'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is empty'</span></span>,)</code> </pre> <br><p>  Dans ce test, toutes les conditions pour les "petits" tests sont remplies - le comportement de la fonction sans dépendances est vérifié pour la conformité avec les attentes.  Mais le design soulève des questions. </p><br><p>  Il est recommandé d'écrire des tests qui se concentrent sur un aspect spécifique du programme.  Dans cet exemple, il existe différentes fonctions - <code>validate_password_format</code> , <code>validate_password_format</code> , <code>validate_datetime</code> .  Le regroupement des contrôles n'est pas basé sur le résultat, mais sur les objets de test. </p><br><p>  Le nom du test ( <code>test_not_empty_errors</code> ) ne décrit pas l'objet de test (quelle méthode est testée), il ne décrit que le résultat (les erreurs ne sont pas vides).  Cette méthode doit être appelée <code>test__validate_not_empty__error_on_empty</code> .  Ce nom décrit ce qui est testé et quel résultat est attendu.  Cela s'applique à presque tous les noms de test dans le projet car aucun temps n'a été pris pour discuter des conventions de dénomination des tests. </p><br><h2 id="regressionnye-testy">  Tests de régression </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_datetime_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'0123-24-31T;431'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-10-18T20:21:21+-23:1'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-13-20T20:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-02-29T20:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T25:20:20+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:61:20+22:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:61+20:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:20+25:20'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-12-20T20:20:20+20:61'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> validate_datetime(<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>, <span class="hljs-string"><span class="hljs-string">'2015-13-35T25:61:61+61:61'</span></span>) == (<span class="hljs-string"><span class="hljs-string">'datetime is invalid'</span></span>,)</code> </pre> <br><p>  Ce test consistait à l'origine des deux premières <code>assert</code> .  Après cela, un "bug" a été découvert - au lieu de vérifier la date, seule l'expression régulière a été vérifiée, c'est-à-dire  <code>9999-99-99</code> était considérée comme une date normale.  Le développeur l'a corrigé.  Naturellement, après avoir corrigé le bogue, vous devez ajouter des tests pour éviter une future régression.  Au lieu d'ajouter un nouveau test dans lequel écrire <em>pourquoi</em> ce test existe, des vérifications ont été ajoutées à ce test. </p><br><p>  Comment appeler un nouveau test pour ajouter la vérification?  <code>test__validate_datetime__error_on_bad_datetime</code> probablement <code>test__validate_datetime__error_on_bad_datetime</code> . </p><br><h2 id="ignorirovanie-instrumentov">  Ignorer les outils </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_get_providers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tmp</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id_external, token, username)</span></span></span><span class="hljs-function">:</span></span> self.id_external = id_external self.token = token self.username = username ...</code> </pre> <br><p>  <code>Tmp</code> ?  Il s'agit d'une substitution pour un objet qui n'est pas utilisé dans ce test.  Le développeur ne semble pas connaître l'existence de <code>@patch</code> et <code>MagicMock</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>unittest.mock</code></a> .  Pas besoin de compliquer le code en résolvant naïvement les problèmes quand il existe des outils plus adéquats. </p><br><p>  Il existe un tel test qui initialise les services (dans la base de données), utilise le contexte de l'application. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_get_posts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [one, two] handler = VKServiceHandler() handler.request = fake_request services_init() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> app.app_context(): posts = handler.get_posts(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(posts) == <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><p>  Vous pouvez exclure la base de données et le contexte du test en ajoutant simplement un <code>@patch</code> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@patch("mobius.services.service_vk.Service") def test_get_posts(mock): def fake_request(*args, **kwargs): return [one, two] handler = VKServiceHandler() handler.request = fake_request posts = handler.get_posts(None) assert len(posts) == 2</span></span></code> </pre> <br><h1 id="itogi">  Résumé </h1><br><ul><li>  Pour développer un logiciel de qualité, vous devez écrire des tests.  Au minimum, pour vous assurer d'écrire ce dont vous avez besoin. </li><li>  Pour les grands systèmes d'information, les tests sont encore plus importants - ils vous permettent d'éviter les modifications d'interface indésirables ou de renvoyer des bogues. </li><li>  Pour que les tests écrits ne se transforment pas en beaucoup de méthodes étranges au fil du temps, vous devez faire attention à la convention de dénomination des tests, respecter les bonnes pratiques et minimiser les tests. </li><li>  Les tests unitaires peuvent être un excellent outil pendant le développement.  Ils peuvent être exécutés après chaque petit changement pour s'assurer que rien n'est cassé. </li></ul><br><p>  Un point très important est que les tests ne garantissent pas la disponibilité ou l'absence de bugs.  Les tests garantissent que le résultat réel du programme (ou une partie de celui-ci) est attendu.  Dans ce cas, la vérification n'a lieu que pour les aspects pour lesquels des tests ont été écrits.  Par conséquent, lors de la création d'un produit de qualité, nous ne devons pas oublier les autres types de tests. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450290/">https://habr.com/ru/post/fr450290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450272/index.html">Frénésie physique</a></li>
<li><a href="../fr450274/index.html">IntelliSense pour C ++ dans Visual Studio fonctionne désormais sur la base d'exemples dans votre code</a></li>
<li><a href="../fr450278/index.html">Réseaux de télévision par câble pour les plus petits. Partie 5: Réseau de distribution coaxial</a></li>
<li><a href="../fr450282/index.html">Fonctionnement des applications Web</a></li>
<li><a href="../fr450288/index.html">UML & Enterprise Architect: conception du processus cible pour la création d'un système automatisé</a></li>
<li><a href="../fr450292/index.html">Nouveautés du noeud 12</a></li>
<li><a href="../fr450294/index.html">Les poisons les plus effrayants</a></li>
<li><a href="../fr450298/index.html">Futur quantique (suite)</a></li>
<li><a href="../fr450300/index.html">Arrêtez de discuter de la programmation fonctionnelle et de la POO</a></li>
<li><a href="../fr450302/index.html">Amateur Radio Technology: fabrication d'un prototype de carte de circuit imprimé dans une usine chinoise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>