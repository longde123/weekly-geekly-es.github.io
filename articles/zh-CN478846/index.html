<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 🧑‍🤝‍🧑 👨🏿‍⚕️ 系统化的交互式脚本和计时器 🆑 🍢 🏏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 在Linux上进行开发时，存在创建交互式脚本的任务，这些脚本在系统打开或关闭时执行。 在系统V中，这很容易完成，但是使用systemd可以进行调整。 但是它可以做它的计时器。 
 为什么我们需要目标 


 通常写为目标在系统V -init中充当运行级别的类似物。 我从根本上不同意。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>系统化的交互式脚本和计时器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478846/"><p><img src="https://habrastorage.org/webt/ly/oe/fh/lyoefhbfusu9nl4jpglhobshfb4.png"></p><br><h2 id="vvedenie"> 引言 </h2><br><p> 在Linux上进行开发时，存在创建交互式脚本的任务，这些脚本在系统打开或关闭时执行。 在系统V中，这很容易完成，但是使用systemd可以进行调整。 但是它可以做它的计时器。 </p><a name="habracut"></a><br><h2 id="zachem-nuzhny-target"> 为什么我们需要目标 </h2><br><p> 通常写为目标在系统V -init中充当运行级别的类似物。 我从根本上不同意。 其中有更多的服务，您可以将包分成几组，例如，与一个团队一起运行一组服务并执行其他操作。 此外，它们没有层次结构，只有依赖性。 </p><br><h2 id="primer-target-pri-vklyucheniiobzor-vozmozhnosti-s-zapuskom-interaktivnogo-skripta"> 启动示例（功能概述）并启动交互式脚本 </h2><br><p> 目标本身的描述： </p><br><pre><code class="bash hljs">cat installer.target [Unit] Description=My installer Requires=multi-user.target Conflicts=rescue.service rescue.target After=multi-user.target rescue.service rescue.target AllowIsolate=yes Wants=installer.service</code> </pre> <br><p> 该目标将在启动multi-user.target并调用installer.service时启动。 而且，可能有几种这样的服务。 </p><br><pre> <code class="bash hljs">cat installer.service [Unit] <span class="hljs-comment"><span class="hljs-comment">#  Description=installer interactive dialog [Service] #   ,     Type=idle #   -   ExecStart=/usr/bin/installer.sh #      tty3 StandardInput=tty TTYPath=/dev/tty3 TTYReset=yes TTYVHangup=yes [Install] WantedBy=installer.target</span></span></code> </pre> <br><p> 最后，是一个可执行脚本的示例： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   tty3 chvt 3 echo "Install, y/n ?" read user_answer</span></span></code> </pre> <br><p> 最重要的是选择final.target-target，系统在启动时应该到达该目标。 在启动过程中，systemd将检查依赖项并运行您需要的一切。 <br> 有几种方法可以选择final.target，为此我使用了bootloader选项。 </p><br><p> 最终的发布如下： </p><br><ol><li> 引导程序启动 </li><li> 引导加载程序通过传递final.target参数来启动固件 </li><li>  Systemd开始系统启动。 它从basic.target到它们的依赖项（例如multi-user.target）依次进入installer.target或work.target。 后者并导致系统以所需的模式工作 </li></ol><br><h2 id="podgotovka-proshivki-k-zapusku"> 准备启动固件 </h2><br><p> 创建固件时，始终需要在启动时恢复系统状态并在关闭电源时保存系统状态。 状态表示配置文件，数据库转储，接口设置等。 </p><br><p>  Systemd在一个目标中并行启动该过程。 有一些依赖关系可以让您确定脚本执行的顺序。 </p><br><p> 它如何在我的项目中工作（ <a href="https://habr.com/ru/post/477008/">https://habr.com/en/post/477008/</a> <a href="https://github.com/skif-web/monitor">https://github.com/skif-web/monitor</a> ） </p><br><ol><li> 系统启动 </li><li>  settings_restore.service服务启动，它将检查数据部分中的settings.txt文件。 如果不存在，则将参考文件放在其位置，然后还原系统设置： <br><ul><li> 管理员密码 </li><li> 主机名 </li><li> 时区 </li><li> 地区 </li><li> 确定是否正在使用所有媒体。 默认情况下，图像尺寸很小-为了方便复制和录制到媒体。 启动时，检查是否还有未使用的空间。 如果存在-磁盘已重新分区。 </li><li> 从MAC地址生成计算机ID。 这对于通过DHCP获取相同的地址很重要。 </li><li> 网络设置 </li><li> 日志大小有限 </li><li> 外部驱动器已准备好工作（如果启用了相应的选项并且驱动器是新的） </li></ul></li><li> 运行postgresq </li><li> 恢复服务启动。 需要准备zabbix本身及其数据库： <br><ul><li> 检查是否已经有一个zabbix数据库。 如果没有，它是通过初始化转储创建的（它们随zabbix一起提供） </li><li> 创建时区列表（需要在Web界面中显示它们） </li><li> 找到当前IP，它显示有问题（邀请进入控制台） </li></ul></li><li> 邀请发生变化-出现准备工作的短语 </li><li> 固件已准备就绪。 </li></ol><br><p> 服务文件很重要，正是它们为启动设置了顺序 </p><br><pre> <code class="bash hljs">[Unit] Description=restore system settings Before=network.service prepare.service postgresql.service systemd-networkd.service systemd-resolved.service [Service] Type=oneshot ExecStart=/usr/bin/settings_restore.sh [Install] WantedBy=multi-user.target</code> </pre> <br><p> 如您所见，我创建了依赖项，以便首先运行脚本，然后网络将启动，DBMS将启动。 </p><br><p> 和第二项服务（准备zabbix） </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh [Unit] Description=monitor prepare system After=postgresql.service settings_restore.service Before=zabbix-server.service zabbix-agent.service [Service] Type=oneshot ExecStart=/usr/bin/prepare.sh [Install] WantedBy=multi-user.target</span></span></code> </pre> <br><p> 这有点复杂，启动也是在multi-user.target中，但是在运行postgresql DBMS和我的setting_restore之后。 但是在运行zabbix服务之前。 </p><br><h3 id="servis-s-taymerom-dlya-logrotate"> 带有计时器的logrotate服务 </h3><br><p>  Systemd可以代替CRON。 说真的 此外，准确性不是一分钟，而是一秒（如果需要的话），并且您可以创建一个单调计时器，由事件超时调用。 <br> 这是单调的计时器，用于计数从我创建的计算机启动以来的时间。 <br> 这将需要2个文件 <br>  logrotateTimer.service-服务的实际描述： </p><br><pre> <code class="bash hljs">[Unit] Description=run logrotate [Service] ExecStart=logrotate /etc/logrotate.conf TimeoutSec=300</code> </pre> <br><p> 很简单-启动命令的描述。 <br> 第二个logrotateTimer.timer文件是设置计时器工作的文件： </p><br><pre> <code class="bash hljs">[Unit] Description=Run logrotate [Timer] OnBootSec=15min OnUnitActiveSec=15min [Install] WantedBy=timers.target</code> </pre> <br><p> 那里是什么： </p><br><ul><li> 计时器说明 </li><li> 第一次从系统启动开始 </li><li> 进一步发射的时期 </li><li> 计时器服务依赖性。实际上，这是使计时器工作的那条线 </li></ul><br><h2 id="interaktivnyy-skript-pri-vyklyuchenii-i-svoy-target-vyklyucheniya"> 有关关闭和自定义关闭目标的交互式脚本 </h2><br><p> 在另一个开发中，我必须通过自己的目标制作一个更复杂的关闭计算机的版本，以便执行许多操作。 通常建议使用RemainAfterExit选项创建oneshot服务，但这会阻止创建交互式脚本。 </p><br><p> 但是事实是，由ExecOnStop选项启动的命令是在TTY之外执行的！ 检查很简单-插入tty命令并保存其输出。 </p><br><p> 因此，我通过目标实现了关机。 我不假装是100％正确的，但是可以！ <br> 如何完成（一般而言）： <br> 创建了目标my_shutdown.target，该目标不依赖任何人： <br>  my_shutdown.target </p><br><pre> <code class="bash hljs">[Unit] Description=my shutdown AllowIsolate=yes Wants=my_shutdown.service</code> </pre> <br><p> 当切换到该目标时（通过systemctl隔离my_shutdwn.target），他启动了my_shutdown.service服务，该服务的任务很简单-执行my_shutdown.sh脚本： </p><br><pre> <code class="bash hljs">[Unit] Description=MY shutdown [Service] Type=oneshot ExecStart=/usr/bin/my_shutdown.sh StandardInput=tty TTYPath=/dev/tty3 TTYReset=yes TTYVHangup=yes WantedBy=my_shutdown.target</code> </pre> <br><ul><li> 在此脚本中，我执行必要的操作。 您可以向目标添加很多脚本，以提高灵活性和便利性： </li></ul><br><p>  my_shutdown.sh </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash --login if [ -f /tmp/reboot ];then command="systemctl reboot" elif [ -f /tmp/shutdown ]; then command="systemctl poweroff" fi #    #, cp /home/user/data.txt /storage/user/ $command</span></span></code> </pre> <br><p> 注意事项 使用/ tmp / reboot和/ tmp / shutdown文件。 您不能使用参数调用目标。 您只能服务。 </p><br><p> 但是我使用target来具有工作灵活性和有保证的动作顺序。 </p><br><p> 但是，最有趣的是后来。 机器必须关闭/重新启动。 共有2个选项： </p><br><ul><li> 用您自己的脚本替换reboot，shutdown和其他命令（在systemctl上它们仍然是符号链接），在脚本内，转到my_shutdown.target。 然后目标内的脚本将直接调用systemctl，例如systemctl reboot </li><li> 比较简单，但我不喜欢该选项。 在所有接口中，请勿调用shutdown / reboot / others，而应直接调用目标系统。ctl孤立my_shutdown.target </li></ul><br><p> 我选择了第一个选项。 在systemd中，重新引导（如关闭电源）是systemd上的符号链接。 </p><br><pre> <code class="bash hljs">ls -l /sbin/poweroff lrwxrwxrwx 1 root root 14  30 18:23 /sbin/poweroff -&gt; /bin/systemctl</code> </pre> <br><p> 因此，可以将它们替换为您自己的脚本： <br> 重新启动 </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh touch /tmp/reboot sudo systemctl isolate my_shutdown.target fi</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN478846/">https://habr.com/ru/post/zh-CN478846/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN478834/index.html">为什么我们对恐惧感到麻木：5-羟色胺对运动的影响</a></li>
<li><a href="../zh-CN478836/index.html">左轮手枪，垫圈和自动机器人之间的共同点</a></li>
<li><a href="../zh-CN478838/index.html">喷气背包的第一次死亡</a></li>
<li><a href="../zh-CN478840/index.html">市场的创建从哪里开始。 第二部分</a></li>
<li><a href="../zh-CN478844/index.html">对IT的恐惧与厌恶</a></li>
<li><a href="../zh-CN478848/index.html">数码摄影的演变</a></li>
<li><a href="../zh-CN478854/index.html">Web服务器之战。 第1部分-HTTP与现实脱节：</a></li>
<li><a href="../zh-CN478856/index.html">SD-WAN-2020年的最新趋势和预测</a></li>
<li><a href="../zh-CN478858/index.html">在XHProf Admin中比较分析会话</a></li>
<li><a href="../zh-CN478862/index.html">Yandex.Market中如何安排前端测试，以及为什么我们拒绝每周发布</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>