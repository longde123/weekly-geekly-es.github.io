<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏼 👈🏾 👨‍💼 Quarkus - Ein neuer Blick auf Cloud Native Java 📬 🐗 💚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Im kommenden neuen Jahr planen wir die ernsthafte Entwicklung der Containerthemen Cloud-Native Java und Kubernetes . Eine logische Forts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quarkus - Ein neuer Blick auf Cloud Native Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/482968/">  Hallo habr <br><br>  Im kommenden neuen Jahr planen wir die ernsthafte Entwicklung der Containerthemen <a href="https://www.piter.com/product_by_id/112863337">Cloud-Native Java</a> und <a href="https://www.piter.com/product_by_id/125705747">Kubernetes</a> .  Eine logische Fortsetzung dieser Themen auf Russisch wird die Geschichte über das <a href="https://quarkus.io/">Quarkus-</a> Framework sein, die bereits in einem guten Artikel über Habré behandelt wurde.  Der heutige Artikel befasst sich weniger mit dem " <a href="https://habr.com/ru/company/haulmont/blog/443242/">subatomaren ultraschnellen Java-</a> Gerät" als vielmehr mit den Perspektiven, die Quarkus für Enterprise bietet. <br><a name="habracut"></a><br>  Java und die JVM sind nach wie vor äußerst beliebt. Bei der Arbeit mit serverlosen Technologien und cloudorientierten Mikrodiensten werden Java und andere Sprachen für die JVM immer seltener verwendet, da sie zu viel Speicherplatz beanspruchen und zu langsam geladen werden, was sie für ungeeignet macht Verwendung mit kurzlebigen Behältern.  Glücklicherweise ändert sich diese Situation derzeit dank Quarkus. <br><br><h3>  Einleitung </h3><br>  Je mehr ich DevOps, Container und serverlose Technologien verwende, desto mehr schreibe <b>ich meinen containerisierten Code</b> in Lightweight-Containern oder <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25B0%25D0%25BA_%25D1%2583%25D1%2581%25D0%25BB%25D1%2583%25D0%25B3%25D0%25B0">FaaS</a> <b>in Python oder JavaScript.</b>  <b>Java ist einfach zu schwer zu booten</b> , um in einem serverlosen Framework verwendet zu werden.  In Bezug auf Microservices bieten JavaScript oder Python ein schnelleres Laden und kompaktere Container, wodurch Java effizienter wird. <br><br><img src="https://habrastorage.org/webt/bk/tu/uc/bktuuc-fn00w6i94twxguuygnx4.jpeg"><br><br>  <i>Python und JavaScript sind die besten Sprachen für die Erstellung cloudbasierter Microservices</i> <br><br>  Java ist <b>mehr als 20 Jahre alt</b> und zum Zeitpunkt seiner Gründung war die Welt völlig anders als heute.  Mit dem Aufkommen der JVM wurden große Probleme behoben - wir konnten Code einmal schreiben und auf vielen Plattformen und Betriebssystemen ausführen.  Mit Containern können Sie Anwendungen, Bibliotheken und Betriebssystemressourcen in separate Container packen, und jeder dieser Container kann überall verwendet werden.  <b>Die von JVM bereitgestellte Portabilität ist jetzt weniger relevant</b> .  Früher waren wir bereit, zusätzliche Kosten zu verursachen, um die Portabilität zu gewährleisten. Jetzt sind diese Zeiten vorbei.  <b>Jetzt müssen Sie schnell mit minimalen Verzögerungen und reaktiven Anwendungen arbeiten, die immer verfügbar sind</b> .  Container und Container-Orchestrierungs-Tools wie <a href="https://kubernetes.io/">Kubernetes</a> bieten diese Funktionen unabhängig von der Programmiersprache. <br><br>  Unternehmen, die auf Microservice-Architekturen umsteigen, verwenden ihre in Java geschriebenen <b>Spring-</b> basierten Services, verknüpfen sie mit <b>umfangreichen</b> JAR-Archiven, fügen <b>JDKs hinzu</b> und führen sie in einem Linux-basierten Container aus.  Diese Lösung funktioniert, Sie müssen sich jedoch mit schweren Containern mit einer Größe von 500 MB befassen, die jeweils 10 bis 30 Sekunden lang in einen barrierefreien Zustand versetzt werden.  Das ist ein ernstes Problem.  Nach der Migration stellen viele Unternehmen langsam auf Python um, lassen die serverseitigen Dienste in Java und beenden letztendlich FaaS. <br><br>  Serverlose Technologien und FaaS sind heutzutage sehr beliebt, da Sie sich auf das Schreiben von Funktionen konzentrieren können, ohne sich um die Infrastruktur kümmern zu müssen.  Wie auch immer, sie arbeiten alle in Containern, aber der Cloud-Anbieter verwaltet ihren Lebenszyklus.  Das Beste daran ist, dass der Anbieter nach einer bestimmten Zeit den Container vollständig stoppt und seine Arbeit erst nach dem nächsten Anruf wieder aufnimmt, dh Sie zahlen nur für die tatsächliche Arbeitszeit.  Der erste Funktionsaufruf kann etwas länger dauern als üblich, dies ist der berühmte <b>Kaltstart</b> .  Tatsache ist, dass der Container primär beladen werden muss.  Die Verwendung von Python oder JavaScript ist kein so großes Problem, aber im Fall von Java kann das erstmalige Laden 10 bis 15 Sekunden dauern. Dies ist ein Satz und einer der Gründe für den Rückgang der Beliebtheit von Java.  Jetzt brauchen wir einen <b>Code, der gestartet, die Aufgabe abgeschlossen und dann beendet werden kann</b> .  Wir möchten nicht mit vielen Threads oder lang laufenden Prozessen fertig werden, sondern benötigen <b>kurzlebige Prozesse, die sehr schnell geladen werden können</b> . <br><br><h3>  Quarkus stellt sich vor </h3><br>  Wenn Sie technische Blogs lesen oder den Nachrichten folgen, denken Sie wahrscheinlich, dass das <a href="https://aws.amazon.com/ru/serverless/">serverlose Paradigma</a> die Welt <a href="https://aws.amazon.com/ru/serverless/">erobert</a> , und jeder nimmt es mit äußerster Begeisterung auf.  Jetzt kann ein Startup Funktionen schreiben und - dank der Verwendung von JavaScript - in der Cloud als Service bereitstellen und sie auch skalieren, um Millionen von Benutzern zu unterstützen, ohne die Infrastruktur verwalten zu müssen.  Es stimmt, es gibt auch eine reale Welt außerhalb des Silicon Valley: Finanzinstitute, Behörden, Einzelhandel und viele andere Branchen, die mit Millionen von Java-Leitungen bedient werden, deren Neuschreibung zu teuer ist.  Wir müssen daher davon ausgehen, dass in diesen Branchen weiterhin schwere Container eingesetzt werden müssen. <br><br><img src="https://habrastorage.org/webt/if/hp/pd/ifhppdap0n0wb-8mfbwxmh9_a94.png"><br><br>  <a href="https://graalvm.org/">GraalVM</a> und insbesondere Substrate VM öffnen heute die Tür für die glorreiche und langfristige Zukunft der Java-Sprache.  GraalVM ist eine <b>universelle virtuelle Maschine</b> zum Ausführen von Anwendungen, die in JavaScript, Python, Ruby, R und Sprachen für die JVM geschrieben wurden, insbesondere Java, Scala oder Kotlin.  Das <b>Coolste</b> ist, <b>dass Sie mit GraalVM (im AOT-Modus) Programme in eine native ausführbare Datei vorkompilieren können</b> .  Dies bedeutet, dass Sie Ihren Java-Code direkt in maschinenspezifischen Code übersetzen können.  Das resultierende Programm funktioniert nicht auf Java HotSpot VM, sondern verwendet alle erforderlichen Komponenten, insbesondere die Speicherverwaltung und die Thread-Planung aus einer anderen Implementierung einer virtuellen Maschine namens Substrate VM.  Die Substrate-VM ist in Java geschrieben und ihr Code wird in eine native ausführbare Datei kompiliert.  Das resultierende Programm startet schneller und verursacht dementsprechend einen geringeren Overhead bei der Speichernutzung im Vergleich zu Java VM.  Das ist großartig, aber Sie denken wahrscheinlich: Frühes Kompilieren?  Dies widerspricht der Grundidee, für die die JVM erstellt wurde, dh die Verwendung von einmal geschriebenem Code überall!  Das ist verrückt !!!  Denken Sie jedoch selbst: Jetzt haben wir Container, für die keine JVM erforderlich ist.  Konventionelle <b>Containeranwendungen, die mit Spring Boot erstellt wurden, verfügen über eine zusätzliche Abstraktionsebene, die in der Welt von Kubernetes absolut unnötig ist</b> .  Auf der JVM im Container wird eine Java-Anwendung ausgeführt. Dieser Container bleibt unverändert, da das fertige Produkt heute ein Container und keine Anwendung ist.  Jetzt packen wir Container, keine WAR-Dateien.  Daher werden <b>alle mit der Verwendung der JVM-Anwendung im Container verbundenen Kosten unbrauchbar</b> , und AOT wird zu einer sehr logischen Entscheidung, wenn Sie Ihre Anwendungen in Container packen. <br><br>  Richtig, die AOT-Kompilierung schränkt die dynamischen Fähigkeiten von Java erheblich ein (Laden von Klassen zur Laufzeit, Reflektion, Proxies usw.).  In der Praxis bedeutet dies, dass 90% des Java-Ökosystems nicht unverändert funktionieren.  Dementsprechend <b>muss sich das Java-Ökosystem anpassen</b> .  Es gibt gute Nachrichten: Das meiste kann während der Montage gemacht werden! <br><br>  Das ist die Kraft von Quarkus.  Es verwendet GraalVM und stellt ein Ökosystem bereit, das die AOT-Kompilierung zum Zeitpunkt der Erstellung unterstützt.  Auf diese Weise können Sie mit Java native Binärdateien erstellen.  Dank Quarkus wird GraalVM <b>Java-Entwicklern zur Verfügung gestellt</b> . <br><br><h3>  Erste Schritte mit Quarkus </h3><br>  Wie oben erläutert, stellt Quarkus eine frühe Kompilierung für Java-Anwendungen bereit, und dies erzeugt ein Ökosystem mit subatomarem Überschall-Java.  Quarkus zeichnet sich durch ultraschnelles Laden aus - und Java kehrt auf dem Gebiet der cloudbasierten Entwicklung zum Spiel zurück.  Seit Jahren hat mich keine neue Technologie inspiriert - und damit <a href="https://dzone.com/articles/using-quarkus-to-run-java-apps-on-kubernetes-1">bin ich nicht allein</a> . <br><br>  Lesen Sie <a href="https://quarkus.io/guides/getting-started">den Anfängerleitfaden</a> - und überzeugen Sie sich selbst.  Es gibt immer noch viele Unternehmen, die Java + JPA im Container verwenden, aber in dieser Konfiguration kann das Laden 15 Sekunden dauern, und <b>im Fall von Quarkus 0,005!</b> <br><br><img src="https://habrastorage.org/webt/rc/ke/zy/rckezyrivwarr2wcwze7md18cru.png"><br><br>  <i>Quarkus Stats</i> <br><br>  Sie verwenden dieselbe IDE und dieselben Tools wie in der Spring Boot-Welt.  Verwenden Sie zum Erstellen Ihres Projekts Maven oder Gradle.  Das Projekt kann direkt in der IDE ausgeführt werden. Darüber hinaus ist ein Hot-Live-Neustart für alle Änderungen verfügbar, und Sie müssen die Anwendung nicht neu starten.  Quarkus ist nicht Spring. Wenn Sie also Spring Boot verwenden, müssen Sie Spring-spezifischen Code migrieren.  Glücklicherweise bietet Quarkus eine gewisse <a href="https://quarkus.io/guides/spring-di">Kompatibilität für die Implementierung von Spring-Abhängigkeiten</a> , was die Arbeit erheblich vereinfacht.  Das Quarkus-Framework ist standardkonform, was eine einfache Portierung und Unterstützung des Codes bedeutet. <br><br><h3>  Quarkus-Entwicklungsprozess </h3><br>  Quarkus kann im Entwicklungsmodus verwendet werden, der an Spring Boot erinnert.  Damit können Sie Ihr Projekt auch in ein dickes Glas packen.  Dies ist sehr praktisch zum Testen und Debuggen Ihres Codes, da ein Neustart in Echtzeit unterstützt wird.  Sie müssen jedoch im Voraus kompilieren, um in die Produktion zu gelangen.  Der gesamte Prozess ist in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/hr/bg/ka/hrbgkaa4flnejnwq-qiutmznacu.png"><br><br><ul><li> Erstellen Sie die Anwendung zunächst in Ihrer bevorzugten IDE, und führen Sie sie dann im Entwicklermodus aus: „ <code>mvnw compile quarkus:dev</code> “ (wie bei einer Spring Boot-Anwendung).  Sie können es auch in ein dickes Glas packen. </li><li>  Sobald Sie den vorherigen Schritt abgeschlossen haben und das Ergebnis zu Ihnen passt, können Sie die Java-Binärdatei erstellen. Führen Sie <code>mvnw package -Pnative</code> : „ <code>mvnw package -Pnative</code> “.  Dies wird einige Zeit in Anspruch nehmen, da der native Code bei der Kompilierung im Voraus generiert wird!  Wenn dieser Schritt abgeschlossen ist, steht Ihnen eine ultrakleine und ultraschnelle ausführbare Datei zur Verfügung, die jedoch nur auf Ihrer Plattform / Ihrem Betriebssystem funktioniert, dh nicht portiert wird!  Das ist aber normal, da wir es in einen Container packen können - und so die Portabilität gewährleisten.  <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> : <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> 4 - und wir entfernen die ausführbare Datei aus dem Docker-Container. Das heißt, wir führen eine native Assembly innerhalb des Containers durch und erstellen eine Binärdatei.  Diese Technik funktioniert möglicherweise nicht auf Ihrem Laptop, wenn sich das Betriebssystem von der Zielplattform unterscheidet, die in der <code>DockerFile</code> die von Quarkus während der Erstellung des Projekts generiert wurde. </li><li>  Nachdem Sie die Binärdatei erstellt haben, erstellen Sie einfach ein Image basierend auf der Docker-Datei.  <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . </li><li>  Schließlich kann die Anwendung in Docker oder Kubernetes gestartet werden: <code>docker run -i --rm -p 8080:8080 quarkus-quickstart/quickstart</code> </li></ul><br><h3>  Quarkus Funktionen </h3><br>  Quarkus bietet viel mehr Funktionen als nativer Java-Code. <br><br><ul><li>  Vereinheitlichung der imperativen und reaktiven Funktionen: Ermöglicht die Kombination von vertrautem imperativem Code mit nicht blockierendem Code, der in einem reaktiven Stil geschrieben ist. </li><li>  <a href="https://quarkus.io/vision/developer-joy">Der Entwickler ist erfreut</a> : einheitliche Konfiguration, Zero Config, sofortiger Live-Neustart, optimierter optimierter Code für 80% der gängigen Fälle und flexibler Code für die restlichen 20% der Fälle, Generierung von nativen ausführbaren Dateien ohne Aufwand, Live-Codierung. </li><li>  Erstaunlich schnelles Laden, ein unglaublich kleiner residenter Speicherbereich (ja, es geht nicht nur um die Größe des Heapspeichers!), Der bei der Orchestrierung von Containern auf Plattformen wie Kubernetes eine fast sofortige vertikale Skalierung und eine sehr hohe Speichernutzung ermöglicht.  <a href="https://quarkus.io/vision/container-first">Weitere Details</a> . </li><li>  Quarkus bietet ein ganzheitliches, benutzerfreundliches Full-Stack-Framework mit erstklassigen Bibliotheken, die Sie kennen und lieben und die in die unterstützenden Strukturen eingebettet sind.  <a href="https://quarkus.io/vision/standards">Weitere Details</a> . </li><li>  Bibliotheken für Ruhezustand, JPA, REST, JWT usw. werden unterstützt. </li><li>  Unterstützte Konfigurationen, die in <a href="https://kubernetes.io/">Kubernetes</a> und <a href="https://www.openshift.com/">OpenShift bereitgestellt werden</a> </li><li>  Öffnen Sie die Ablaufverfolgung mit Jaeger </li><li>  <a href="https://quarkus.io/guides/kotlin">Kotlin-</a> Unterstützung </li><li>  Messaging mit Kafka, Camel ... </li><li>  Schauen Sie sich auch die <a href="https://quarkus.io/extensions/">Liste der Erweiterungen an</a> ! </li></ul><br><h3>  Quarkus-Ökosystem </h3><br>  <b>Kurz gesagt, Sie können jetzt herkömmliche JPA / JTA-Transaktionsdienste in superschnellen, leichten Containern ausführen - sowohl in der Cloud als auch vor Ort</b> . <br><br><h3>  Quarkus-Beispiel </h3><br>  In diesem Abschnitt werfen wir einen vereinfachten Blick auf <a href="https://quarkus.io/guides/getting-started">den Einsteigerleitfaden,</a> um Ihnen einen Eindruck von der Leistungsfähigkeit von Quarkus zu vermitteln. <br><br><img src="https://habrastorage.org/webt/o6/ow/w8/o6oww8qnyoxtpobjavpm4drpz4o.png"><br><br>  Am einfachsten erstellen Sie ein neues Quarkus-Projekt, indem Sie ein Eingabeaufforderungsfenster öffnen und den folgenden Befehl ausführen: <br><br><pre> <code class="plaintext hljs">mvn io.quarkus:quarkus-maven-plugin:0.12.0:create \ -DprojectGroupId=org.acme \ -DprojectArtifactId=getting-started \ -DclassName="org.acme.quickstart.GreetingResource" \ -Dpath="/hello"</code> </pre> <br>  Dadurch wird ein Maven-Projekt generiert, bei dem GreetingResuce den Endpunkt / Hallo bereitstellt.  Dockerfile-Docker-Images für native Dateien und JVM (traditionelle Images in Form eines dicken JAR) werden ebenfalls generiert.  Der Code ist sehr sauber und einfach: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.TEXT_PLAIN) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; } }</code> </pre><br>  Verwenden <code>./mvnw compile quarkus:dev</code> zum Ausführen der Anwendung: <code>./mvnw compile quarkus:dev</code> <br>  Die Anwendung wird mit dem Paket ./mvnw gepackt.  Das Ergebnis sind 2 JAR-Dateien: <br><br><ul><li>  getting-started-1.0-SNAPSHOT.jar - enthält nur Klassen und Projektressourcen.  Dies ist ein häufiges Artefakt, das aus der Versammlung von Maven resultiert. </li><li>  getting-started-1.0-SNAPSHOT-runner.jar ist eine ausführbare jar.  Beachten Sie, dass dies nicht "uber-jar" ist, es gibt Abhängigkeiten hier, sie werden in das Zielverzeichnis / lib kopiert. </li></ul><br>  Sie können die Anwendung mit folgendem Befehl starten: java -jar target / getting-started-1.0-SNAPSHOT-runner.jar <br><br>  Anschließend müssen Sie GraalVM herunterladen und installieren und die Umgebungsvariable <code>GRAALVM_HOME</code> . <br><br>  Jetzt können Sie eine native ausführbare Datei erstellen mit: <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> . <br><br>  So erstellen Sie ein Docker-Image: <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . <br><br>  Jetzt kann es mit jeder Container-Orchestrierungs-Engine gestartet werden, wenn Sie <b>minishift verwenden</b> : <br><br><pre> <code class="plaintext hljs">kubectl run quarkus-quickstart --image=quarkus-quickstart/quickstart:latest --port=8080 --image-pull-policy=IfNotPresent</code> </pre> <br><pre> <code class="plaintext hljs">kubectl expose deployment quarkus-quickstart --type=NodePort</code> </pre> <br>  Das ist alles!;  Jetzt haben Sie einen Container mit einem Java-REST-Service, der in 0,004 Sekunden startet! <br><br><h3>  Fazit </h3><br>  Jetzt verstehe ich, warum ich von dem von Red Hat unterstützten Quarkus-Framework so beeindruckt bin.  Ich bin fest davon überzeugt, dass dies die technologische Landschaft von Java verändern und großen traditionellen Unternehmen eine echte Möglichkeit bieten wird, in die Cloud zu migrieren. <br><br>  <b>Kubernetes + Knative + Quarkus</b> ändern die Spielregeln in einer Cloud-orientierten Entwicklung und werden jedem Java-Entwickler gefallen. <br><br>  Dieses <a href="https://github.com/quarkusio/quarkus-quickstarts">Repository enthält</a> viele interessante Beispiele! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482968/">https://habr.com/ru/post/de482968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482948/index.html">"Eins, zwei, drei - verbrenne den Weihnachtsbaum!" Oder mein erster Blick auf den CANNY 3 winzigen Controller</a></li>
<li><a href="../de482950/index.html">Java: Dinge, die einem erfahrenen Entwickler neugierig erscheinen mögen</a></li>
<li><a href="../de482956/index.html">Überprüfung von WCS 5.2 - WebRTC Server für Webcast- und Webcam-Entwickler</a></li>
<li><a href="../de482958/index.html">"Wachstumsregeln: Vom Junior zum CTO", Auszug aus einem Webinar von Fedor Borshchev</a></li>
<li><a href="../de482960/index.html">WCS 5.2 Übersicht - WebRTC Server für Webentwickler von Online-Broadcasts und Video-Chats</a></li>
<li><a href="../de482970/index.html">Hack The Box - Walkthrough Craft. Wir stöbern in Git, nutzen Schwachstellen in der API aus, beschäftigen uns mit Vault</a></li>
<li><a href="../de482974/index.html">Psychologische Unterstützung mit Virtual Reality</a></li>
<li><a href="../de482976/index.html">Analyse anonymer Transaktionen im Aktienhandel</a></li>
<li><a href="../de482978/index.html">Blockchain-Parser mit 300 Zeilen in Python</a></li>
<li><a href="../de482980/index.html">Oracle selbst hat die API von Amazon S3 kopiert, und das ist vollkommen in Ordnung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>