<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôçÔ∏è üë©üèø‚Äçü§ù‚Äçüë®üèº ‚åõÔ∏è Backup para Linux ou como criar um instant√¢neo ü§õ üëÉüèª üìã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Trabalho na Veeam no projeto Veeam Agent for Linux. Com este produto, voc√™ pode fazer backup de uma m√°quina Linux. "Agente" no nome signi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backup para Linux ou como criar um instant√¢neo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Ol√° pessoal!  Trabalho na Veeam no projeto Veeam Agent for Linux.  Com este produto, voc√™ pode fazer backup de uma m√°quina Linux.  "Agente" no nome significa que o programa permite fazer backup de m√°quinas f√≠sicas.  O Virtualalkans tamb√©m faz backup, mas est√° localizado no SO convidado. <br><br>  A inspira√ß√£o para este artigo foi o meu relat√≥rio na confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linux Piter</a> , que decidi publicar como artigo para todos os habragiteli interessados. <br><br>  No artigo, vou revelar o t√≥pico de cria√ß√£o de um instant√¢neo que permite fazer backup e falar sobre os problemas que encontramos ao criar nosso pr√≥prio mecanismo para criar instant√¢neos de dispositivos de bloco. <br><br>  Todos os interessados ‚Äã‚Äãpedem um corte! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Um pouco de teoria no come√ßo </h2><br>  Historicamente, existem duas abordagens para a cria√ß√£o de backups: backup de arquivo e backup de volume.  No primeiro caso, copiamos cada arquivo como um objeto separado, no segundo, copiamos todo o conte√∫do do volume como um tipo de imagem. <br><br>  Ambos os m√©todos t√™m muitas vantagens e desvantagens, mas os consideraremos atrav√©s do prisma da recupera√ß√£o de falhas: <br><br><ul><li>  No caso de backup de arquivos, para recuperar completamente o servidor inteiro, precisamos primeiro instalar o sistema operacional, depois os servi√ßos necess√°rios e somente depois restaurar os arquivos do backup. </li><li>  No caso do backup de volume, para uma recupera√ß√£o completa, basta restaurar todos os volumes de uma m√°quina sem esfor√ßos desnecess√°rios por parte de uma pessoa. </li></ul><br>  Obviamente, no caso de backup de volume, voc√™ pode restaurar o sistema mais rapidamente, e essa √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caracter√≠stica</a> importante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do sistema</a> .  Portanto, para n√≥s mesmos, observamos o backup de volume como a op√ß√£o preferida. <br><br>  Como captamos e salvamos o volume inteiro?  Obviamente, simplesmente copiando, n√£o conseguiremos nada de bom.  Durante a c√≥pia, alguma atividade com dados ocorrer√° no volume; como resultado, os dados inconsistentes aparecer√£o no backup.  A estrutura do sistema de arquivos ser√° violada, os arquivos do banco de dados ser√£o corrompidos e outros arquivos com os quais as opera√ß√µes ser√£o executadas durante a c√≥pia. <br><br>  Para evitar todos esses problemas, a humanidade progressiva criou uma tecnologia de instant√¢neo - instant√¢neo.  Em teoria, tudo √© simples: criamos uma c√≥pia inalterada - um instant√¢neo - e fazemos backup dos dados.  Quando o backup termina, destru√≠mos o instant√¢neo.  Parece simples, mas, como sempre, existem nuances. <br><br>  Por causa deles, muitas implementa√ß√µes dessa tecnologia nasceram.  Por exemplo, solu√ß√µes baseadas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mapeador de dispositivos</a> , como o provisionamento LVM e Thin, fornecem instant√¢neos de volume total, mas exigem layout de disco especial no est√°gio de instala√ß√£o do sistema, o que significa que, em geral, eles n√£o s√£o adequados. <br><br>  O BTRFS e o ZFS possibilitam a cria√ß√£o de instant√¢neos das subestruturas do sistema de arquivos, o que √© muito legal, mas no momento a participa√ß√£o deles nos servidores √© pequena e estamos tentando criar uma solu√ß√£o universal. <br><br>  Suponha que exista uma EXT banal em nosso dispositivo de bloqueio.  Nesse caso, podemos usar o <a href="">dm-snap</a> (a prop√≥sito, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dm-bow</a> est√° sendo desenvolvido agora), mas aqui est√° sua pr√≥pria nuance.  Voc√™ precisa ter um dispositivo de bloco livre pronto para poder soltar os dados da captura instant√¢nea onde. <br>  Prestando aten√ß√£o √†s solu√ß√µes alternativas de backup, percebemos que, em regra, eles usam seu m√≥dulo do kernel para criar instant√¢neos de dispositivos de bloco.  Decidimos seguir esse caminho, escrevendo nosso m√≥dulo.  Foi decidido distribu√≠-lo sob a licen√ßa GPL, para que esteja dispon√≠vel publicamente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . <br><br><h2>  Como funciona - em teoria </h2><br><h3>  Instant√¢neo do microsc√≥pio </h3><br>  Portanto, agora consideraremos o princ√≠pio geral de opera√ß√£o do m√≥dulo e abordaremos as principais quest√µes com mais detalhes. <br><br>  De fato, o veeamsnap (como chamamos de m√≥dulo do kernel) √© um filtro de driver de dispositivo de bloco. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Seu trabalho √© interceptar solicita√ß√µes para um driver de dispositivo de bloco. <br><br>  Ap√≥s interceptar uma solicita√ß√£o de grava√ß√£o, o m√≥dulo copia dados do dispositivo de bloco original para a √°rea de dados da captura instant√¢nea.  Chamamos essa √°rea de snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  E qual √© o instant√¢neo em si?  Este √© um dispositivo de bloco virtual, uma c√≥pia do dispositivo original em um determinado momento.  Ao acessar os blocos de dados neste dispositivo, eles podem ser lidos no snap-in ou no dispositivo original. <br><br>  Quero observar que o instant√¢neo √© exatamente o dispositivo de bloco que √© completamente id√™ntico ao original no momento em que o instant√¢neo foi removido.  Gra√ßas a isso, podemos montar o sistema de arquivos em um instant√¢neo e executar o pr√©-processamento necess√°rio. <br><br>  Por exemplo, podemos obter um mapa dos blocos ocupados no sistema de arquivos.  A maneira mais f√°cil de fazer isso √© usar o ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GETFSMAP</a> . <br>  Dados em blocos ocupados permitem que voc√™ leia apenas os dados mais recentes de uma captura instant√¢nea. <br><br>  Voc√™ tamb√©m pode excluir alguns arquivos.  Bem, uma a√ß√£o completamente opcional: indexe os arquivos que caem no backup, para a possibilidade de um restaurante granular no futuro. <br><br><h3>  CoW vs RoW </h3><br>  Vamos nos concentrar um pouco na escolha do algoritmo de captura instant√¢nea.  A escolha aqui n√£o √© muito extensa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Copiar na grava√ß√£o ou Redirecionar na grava√ß√£o</a> . <br><br>  O redirecionamento na grava√ß√£o ao interceptar uma solicita√ß√£o de grava√ß√£o a redirecionar√° para o snap, ap√≥s o qual todas as solicita√ß√µes para ler este bloco tamb√©m ser√£o acessadas.  Um √≥timo algoritmo para sistemas de armazenamento criados com base em √°rvores B +, como BTRFS, ZFS e Thin Provisioning.  A tecnologia √© t√£o antiga quanto o mundo, mas se manifesta especialmente bem em hipervisores, onde √© poss√≠vel criar um novo arquivo e gravar novos blocos l√° durante o instant√¢neo.  O desempenho √© excelente em compara√ß√£o com o CoW.  Mas h√° um excesso de gordura - a estrutura do dispositivo original muda e, ao remover o instant√¢neo, voc√™ precisa copiar todos os blocos do snap para o local original. <br><br>  A c√≥pia na grava√ß√£o, ao interceptar uma solicita√ß√£o, copia os dados para o snapstore que devem sofrer uma altera√ß√£o, ap√≥s o que permite que eles sejam substitu√≠dos no local original.  Usado para criar capturas instant√¢neas para volumes LVM e c√≥pias de sombra do VSS.  Obviamente, √© mais adequado para criar instant√¢neos de dispositivos de bloco, porque  n√£o altera a estrutura do dispositivo original e, quando voc√™ exclui (ou falha), o instant√¢neo pode ser simplesmente descartado sem arriscar dados.  A desvantagem dessa abordagem √© a degrada√ß√£o do desempenho, pois algumas opera√ß√µes de leitura / grava√ß√£o s√£o adicionadas a cada opera√ß√£o de grava√ß√£o. <br><br>  Como a seguran√ßa dos dados √© nossa principal prioridade, nos concentramos em CoW. <br><br>  At√© agora, tudo parece simples, ent√£o vamos abordar os problemas da vida real. <br><br><h2>  Como funciona - na pr√°tica </h2><br><h3>  Condi√ß√£o Consistente </h3><br>  Por ele, tudo foi concebido. <br>  Por exemplo, se no momento da cria√ß√£o de um instant√¢neo (em uma primeira aproxima√ß√£o, podemos assumir que ele foi criado instantaneamente) um registro ser√° gravado em algum arquivo, em um instant√¢neo o arquivo ficar√° incompleto, o que significa que ser√° danificado e sem sentido.  A situa√ß√£o √© semelhante aos arquivos de banco de dados e ao pr√≥prio sistema de arquivos. <br><br>  Mas vivemos no s√©culo 21!  Existem mecanismos de registro que protegem contra esses problemas!  √â verdade que existe um ‚Äúmas‚Äù importante: essa prote√ß√£o n√£o √© do fracasso, mas de suas consequ√™ncias.  Ao restaurar para um estado consistente de acordo com o log, opera√ß√µes incompletas ser√£o descartadas, o que significa que elas ser√£o perdidas.  Portanto, √© importante mudar a prioridade da prote√ß√£o contra a causa, em vez de tratar as consequ√™ncias. <br><br>  O sistema pode ser avisado de que um instant√¢neo ser√° criado.  Para isso, o kernel possui as fun√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">freeze_bdev</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">thaw_bdev</a> .  Eles puxam as fun√ß√µes do sistema de arquivos freeze_fs e unfreeze_fs.  Quando voc√™ chama o primeiro, o sistema deve redefinir o cache, suspender a cria√ß√£o de novas solicita√ß√µes para o dispositivo de bloco e aguardar a conclus√£o de todas as solicita√ß√µes geradas anteriormente.  E quando unfreeze_fs √© chamado, o sistema de arquivos restaura seu funcionamento normal. <br><br>  Acontece que podemos avisar o sistema de arquivos.  E os aplicativos?  Aqui, infelizmente, tudo est√° ruim.  Enquanto no Windows existe um mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VSS</a> que, com a ajuda do Writers, fornece intera√ß√£o com outros produtos, cada um no Linux segue seu pr√≥prio caminho.  No momento, isso levou √† situa√ß√£o em que a tarefa do administrador do sistema de escrever (copiar, <s>roubar</s> , comprar, etc.) os scripts de pr√©-congelamento e p√≥s-descongelamento por conta pr√≥pria, preparar√° o aplicativo para o instant√¢neo.  De nossa parte, no pr√≥ximo lan√ßamento, apresentaremos o suporte ao Oracle Application Processing, como o recurso mais frequentemente solicitado por nossos clientes.  Em seguida, outros aplicativos podem ser suportados, mas no geral a situa√ß√£o √© bastante triste. <br><br><h3>  Onde colocar o snap? </h3><br>  Este √© o segundo problema que est√° no nosso caminho.  √Ä primeira vista, o problema n√£o √© √≥bvio, mas depois de um pouco de compreens√£o, vemos que isso ainda √© uma lasca. <br><br>  Obviamente, a solu√ß√£o mais f√°cil √© colocar o snap na RAM.  Para o desenvolvedor, a op√ß√£o √© √≥tima!  Tudo √© r√°pido, muito conveniente para a depura√ß√£o, mas h√° um batente: a RAM √© um recurso valioso e ningu√©m nos dar√° uma grande ajuda por l√°. <br><br>  OK, vamos fazer do snap-file um arquivo regular.  Mas surge outro problema - voc√™ n√£o pode fazer backup do volume no qual o snapstop est√° localizado.  O motivo √© simples: interceptamos solicita√ß√µes de grava√ß√£o, o que significa que interceptaremos nossas pr√≥prias solicita√ß√µes de grava√ß√£o no snap-in.  Os cavalos corriam de uma maneira cient√≠fica - impasse.  Depois, h√° um forte desejo de usar um disco separado para isso, mas ningu√©m adicionar√° discos ao nosso servidor por nossa causa.  Voc√™ deve poder trabalhar no que √©. <br><br>  Posicionar remotamente o snap-in √© uma excelente id√©ia, mas pode ser implementado em c√≠rculos muito estreitos de redes com alta largura de banda e latens microsc√≥picos.  Caso contr√°rio, enquanto mant√©m o instant√¢neo na m√°quina, haver√° uma estrat√©gia baseada em turnos. <br><br>  Portanto, voc√™ precisa, de alguma maneira, colocar o snap no disco local.  Mas, como regra, todo o espa√ßo nos discos locais j√° est√° distribu√≠do entre os sistemas de arquivos e, ao mesmo tempo, voc√™ precisa pensar muito sobre como contornar o problema do impasse. <br><br>  A dire√ß√£o da reflex√£o, em princ√≠pio, √© uma: voc√™ precisa, de alguma forma, alocar espa√ßo no sistema de arquivos, mas trabalhar diretamente com o dispositivo de bloco.  A solu√ß√£o para esse problema foi implementada no c√≥digo do espa√ßo do usu√°rio, no servi√ßo. <br><br>  H√° uma chamada do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fallocate</a> que permite criar um arquivo vazio do tamanho desejado.  No entanto, de fato, apenas os metadados s√£o criados no sistema de arquivos que descreve o local do arquivo no volume.  E o ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FIEMAP</a> nos permite obter um mapa da localiza√ß√£o dos blocos de arquivos. <br><br>  E pronto: criamos um arquivo sob snap usando fallocate, o FIEMAP fornece um mapa da localiza√ß√£o dos blocos desse arquivo, que podemos transferir para trabalhar em nosso m√≥dulo veeamsnap.  Al√©m disso, ao acessar o snapstor, o m√≥dulo faz solicita√ß√µes diretamente ao dispositivo de bloco em blocos conhecidos por n√≥s, e sem conflitos. <br><br>  Mas h√° uma nuance.  A chamada do sistema fallocate √© suportada apenas por XFS, EXT4 e BTRFS.  Para outros sistemas de arquivos como o EXT3, √© necess√°rio grav√°-lo completamente para alocar o arquivo.  A funcionalidade √© afetada por um aumento no tempo para preparar snappads, mas n√£o h√° escolha.  Novamente, voc√™ precisa ser capaz de trabalhar no que √©. <br><br>  E se o ioctl FIEMAP tamb√©m n√£o for suportado?  Essa √© a realidade do NTFS e do FAT32, onde nem sequer h√° suporte para o antigo FIBMAP.  Eu tive que implementar um certo algoritmo gen√©rico, cuja opera√ß√£o n√£o depende dos recursos do sistema de arquivos.  Em poucas palavras, o algoritmo √©: <br><br><ol><li>  O servi√ßo cria um arquivo e come√ßa a gravar um padr√£o espec√≠fico nele. </li><li>  O m√≥dulo intercepta solicita√ß√µes de grava√ß√£o, verifica os dados que est√£o sendo gravados. </li><li>  Se os dados do bloco corresponderem ao padr√£o especificado, o bloco ser√° marcado como pertencente ao snapstop. </li></ol><br>  Sim, dif√≠cil, sim, devagar, mas melhor que nada.  √â usado em casos raros para sistemas de arquivos sem suporte a FIEMAP e FIBMAP. <br><br><h3>  Estouro de instant√¢neo </h3><br>  Em vez disso, o local que alocamos no snapstore termina.  A ess√™ncia do problema √© que n√£o h√° lugar para descartar novos dados, o que significa que o instant√¢neo se torna inutiliz√°vel. <br>  O que fazer <br><br>  Obviamente, voc√™ precisa aumentar o tamanho dos snappants.  Quanto?  A maneira mais f√°cil de definir o tamanho dos snappants √© determinar a porcentagem de espa√ßo livre no volume (como feito no VSS).  Para um volume de 20 TB, 10% ser√° de 2 TB - o que √© muito para um servidor descarregado.  Para um volume de 200 GB, 10% s√£o 20 GB, o que pode ser muito pouco para um servidor que est√° atualizando intensivamente seus dados.  E ainda h√° volumes finos ... <br><br>  Em geral, apenas o administrador do sistema do servidor pode descobrir o tamanho ideal do snap-in necess√°rio, ou seja, voc√™ deve fazer a pessoa pensar e dar sua opini√£o de especialista.  Isso n√£o est√° de acordo com o princ√≠pio de "Simplesmente funciona". <br><br>  Para resolver esse problema, desenvolvemos o algoritmo de snapshot stretch.  A id√©ia √© dividir o snap em por√ß√µes.  Ao mesmo tempo, novas partes s√£o criadas ap√≥s a cria√ß√£o de um instant√¢neo, conforme necess√°rio. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Novamente, brevemente o algoritmo: <br><br><ol><li>  Antes de criar um instant√¢neo, a primeira parte do instant√¢neo √© criada e fornecida ao m√≥dulo. </li><li>  Quando o instant√¢neo √© criado, a parte come√ßar√° a ser preenchida. </li><li>  Assim que metade da parte estiver cheia, uma solicita√ß√£o √© enviada ao servi√ßo para criar uma nova. </li><li>  O servi√ßo cria, fornece os dados para o m√≥dulo. </li><li>  O m√≥dulo come√ßa a preencher o pr√≥ximo lote. </li><li>  O algoritmo √© repetido at√© que o backup seja conclu√≠do ou at√© que cheguemos ao limite do uso de espa√ßo livre em disco. </li></ol><br>  √â importante observar que o m√≥dulo deve ter tempo para criar novas partes de snapposts conforme necess√°rio, caso contr√°rio - exceda, redefina as capturas instant√¢neas e nenhum backup.  Portanto, a opera√ß√£o de um algoritmo desse tipo √© poss√≠vel apenas em sistemas de arquivos com suporte a fallocate, onde √© poss√≠vel criar rapidamente um arquivo vazio. <br><br>  O que fazer em outros casos?  Estamos tentando adivinhar o tamanho necess√°rio e criar todo o snappast inteiro.  Mas, de acordo com nossas estat√≠sticas, a grande maioria dos servidores Linux agora usa EXT4 e XFS.  EXT3 √© encontrado em m√°quinas mais antigas.  Mas no SLES / openSUSE, voc√™ pode encontrar o BTRFS. <br><br><h3>  CBT (Change Block Tracking) </h3><br>  Backup incremental ou diferencial (a prop√≥sito, rabanete de rabanete √© mais doce ou n√£o, sugiro que leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ) - sem ele, voc√™ n√£o pode imaginar nenhum produto de backup adulto.  E para que isso funcione, voc√™ precisa do CBT.  Se algu√©m perdeu: o CBT permite rastrear altera√ß√µes e gravar no backup apenas os dados alterados no √∫ltimo backup. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Muitos t√™m sua pr√≥pria experi√™ncia nesta √°rea.  Por exemplo, no VMware vSphere, esse recurso est√° dispon√≠vel desde a vers√£o 4 em 2009.  No Hyper-V, o suporte foi introduzido no Windows Server 2016 e, para oferecer suporte a vers√µes anteriores, seu pr√≥prio driver VeeamFCT foi desenvolvido em 2012.  Portanto, para o nosso m√≥dulo, n√£o nos tornamos originais e usamos algoritmos que j√° est√£o funcionando. <br>  Sobre como isso funciona. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  Todo o volume rastreado √© dividido em blocos.  O m√≥dulo simplesmente acompanha todas as solicita√ß√µes de grava√ß√£o, marcando os blocos alterados na tabela.  De fato, a tabela CBT √© uma matriz de bytes, em que cada byte corresponde a um bloco e cont√©m o n√∫mero do instant√¢neo no qual foi alterado. <br>  Durante o backup, o n√∫mero da captura instant√¢nea √© registrado nos metadados do backup.  Assim, conhecendo os n√∫meros do instant√¢neo atual e aquele a partir do qual o backup anterior bem-sucedido foi feito, √© poss√≠vel calcular o mapa da localiza√ß√£o dos blocos alterados. <br><br>  Existem duas nuances. <br><br>  Como eu disse, um byte √© alocado para o n√∫mero da captura instant√¢nea na tabela CBT, o que significa que o comprimento m√°ximo da cadeia incremental n√£o pode ser maior que 255. Quando esse limite √© atingido, a tabela √© redefinida e ocorre um backup completo.  Pode parecer inconveniente, mas, na verdade, uma cadeia de 255 incrementos est√° longe de ser a melhor solu√ß√£o ao criar um plano de backup. <br>  O segundo recurso √© o armazenamento da tabela CBT apenas na RAM.  Portanto, quando voc√™ reinicia a m√°quina de destino ou descarrega o m√≥dulo, ele ser√° redefinido e, novamente, voc√™ precisar√° criar um backup completo.  Essa solu√ß√£o permite n√£o resolver o problema de inicializa√ß√£o do m√≥dulo na inicializa√ß√£o do sistema.  Al√©m disso, n√£o h√° necessidade de salvar as tabelas CBT quando voc√™ desliga o sistema. <br><br><h3>  Problema de desempenho </h3><br>  O backup √© sempre uma carga t√£o boa nas E / S do seu equipamento.  Se j√° houver tarefas ativas suficientes nele, o processo de backup poder√° transformar seu sistema em uma esp√©cie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pregui√ßa</a> . <br>  Vamos ver o porqu√™. <br><br>  Imagine que o servidor simplesmente escreva linearmente alguns dados.  A velocidade de grava√ß√£o, neste caso, √© m√°xima, todos os atrasos s√£o minimizados, o desempenho tende ao m√°ximo.  Agora, adicionamos aqui o processo de backup, que a cada grava√ß√£o ainda precisa concluir o algoritmo Copy-on-Write, e essa √© uma opera√ß√£o de leitura adicional com grava√ß√£o subsequente.  E n√£o esque√ßa que, para backup, voc√™ ainda precisa ler dados do mesmo volume.  Em uma palavra, seu belo acesso linear se transforma em um acesso aleat√≥rio sem piedade, com todas as consequ√™ncias. <br><br>  Obviamente, precisamos fazer algo com isso e implementamos um pipeline para processar solicita√ß√µes n√£o uma de cada vez, mas em pacotes inteiros.  Funciona assim. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Ao interceptar solicita√ß√µes, elas s√£o colocadas em uma fila, onde um fluxo especial as leva em partes.  No momento, s√£o criadas solicita√ß√µes de COW, que tamb√©m s√£o processadas em lotes.  Ao processar solicita√ß√µes de CoW, primeiro todas as opera√ß√µes de leitura s√£o executadas para a parte inteira, ap√≥s o que as opera√ß√µes de grava√ß√£o s√£o executadas.  Somente ap√≥s o processamento de toda a parte das solicita√ß√µes de CoW, as solicita√ß√µes interceptadas s√£o executadas.  Esse transportador fornece acesso ao disco em grandes peda√ßos de dados, o que minimiza as perdas de tempo. <br><br><h3>  Limita√ß√£o </h3><br>  J√° no est√°gio de depura√ß√£o, outra nuance apareceu.  Durante o backup, o sistema ficou sem resposta, ou seja,  as solicita√ß√µes de E / S do sistema come√ßaram a ser executadas com longos atrasos.  Por√©m, os pedidos de leitura de dados de um instant√¢neo foram executados a uma velocidade pr√≥xima do m√°ximo. <br>  Eu tive que estrangular um pouco o processo de backup implementando o mecanismo de limita√ß√£o.  Para fazer isso, o processo de leitura da imagem da captura instant√¢nea √© colocado em um estado de espera se a fila de solicita√ß√µes interceptadas n√£o estiver vazia.  Espera-se que o sistema ganhe vida. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Como resultado, se a carga no sistema de E / S aumentar bastante, o processo de leitura do instant√¢neo aguardar√°.  Aqui decidimos ser guiados pelo princ√≠pio de que √© melhor encerrar o backup com um erro do que interromper o servidor. <br><br><h3>  Impasse </h3><br>  Acho que precisamos explicar com mais detalhes o que √©. <br><br>  J√° na fase de teste, come√ßamos a encontrar situa√ß√µes de paralisa√ß√£o completa do sistema com o diagn√≥stico de sete problemas - um reset. <br><br>  Eles come√ßaram a entender.  Aconteceu que essa situa√ß√£o pode ser observada se, por exemplo, voc√™ criar uma captura instant√¢nea do dispositivo de bloco no qual o volume LVM est√° localizado e colocar a captura instant√¢nea no mesmo volume LVM.  Deixe-me lembr√°-lo de que o LVM usa o m√≥dulo do kernel do mapeador de dispositivos. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  Nessa situa√ß√£o, ao interceptar uma solicita√ß√£o de grava√ß√£o, o m√≥dulo, copiando os dados para o snap-in, enviar√° a solicita√ß√£o de grava√ß√£o para o volume LVM.  O mapeador de dispositivos redirecionar√° essa solicita√ß√£o para o dispositivo de bloco.  Uma solicita√ß√£o do mapeador de dispositivos ser√° novamente interceptada pelo m√≥dulo.  Mas uma nova solicita√ß√£o n√£o pode ser processada at√© que a anterior tenha sido processada.  Como resultado, o processamento da solicita√ß√£o √© bloqueado, voc√™ √© recebido por um conflito. <br><br>  Para evitar essa situa√ß√£o, o pr√≥prio m√≥dulo do kernel fornece um tempo limite para a opera√ß√£o de c√≥pia de dados no snap-in.  Isso permite que voc√™ detecte o deadlock e o backup de falhas.  A l√≥gica aqui √© a mesma: √© melhor n√£o fazer backup do que suspender o servidor. <br><br><h3>  Banco de dados round robin </h3><br>  Este j√° √© um problema gerado pelos usu√°rios ap√≥s o lan√ßamento da primeira vers√£o. <br>  Descobriu-se que existem esses servi√ßos que est√£o envolvidos apenas na substitui√ß√£o constante dos mesmos blocos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo impressionante √© o monitoramento de servi√ßos, que constantemente geram dados sobre o estado do sistema e os sobrescrevem em um c√≠rculo. </font><font style="vertical-align: inherit;">Para tais tarefas, use bancos de dados c√≠clicos especializados ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aconteceu que, com um backup dessas bases, o instant√¢neo √© garantido para transbordar. </font><font style="vertical-align: inherit;">Em um estudo detalhado do problema, encontramos uma falha na implementa√ß√£o do algoritmo CoW. </font><font style="vertical-align: inherit;">Se o mesmo bloco foi substitu√≠do, os dados foram copiados para o snap-in sempre. </font><font style="vertical-align: inherit;">Resultado: duplica√ß√£o de dados no snap. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturalmente, mudamos o algoritmo. </font><font style="vertical-align: inherit;">Agora, o volume √© dividido em blocos e os dados s√£o copiados no bloco de snap. </font><font style="vertical-align: inherit;">Se o bloco j√° tiver sido copiado uma vez, esse processo n√£o ser√° repetido.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o de tamanho de bloco </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando o snapstrap √© dividido em blocos, surge a pergunta: qual √©, de fato, o tamanho dos blocos para quebrar os snapplugs? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema √© duplo. Se o bloco for grande, √© mais f√°cil para eles operarem, mas se pelo menos um setor mudar, ser√° necess√°rio enviar o bloco inteiro para a sonda e, como resultado, as chances de transbordar ser√£o aumentadas. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, quanto menor o tamanho do bloco, maior a porcentagem de dados √∫teis enviados para o snapstore, mas como isso afetar√° o desempenho? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eles procuraram a verdade empiricamente e criaram 16KiB. Observe tamb√©m que o Windows VSS tamb√©m usa 16 blocos KiB.</font></font><br><br><h2>  Em vez de uma conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por enquanto √© tudo. </font><font style="vertical-align: inherit;">Deixarei muitos outros problemas n√£o menos interessantes, como depend√™ncia de vers√µes do kernel, escolha de op√ß√µes de distribui√ß√£o de m√≥dulos, compatibilidade com kABI, trabalho em condi√ß√µes de backport etc. </font><font style="vertical-align: inherit;">O artigo acabou sendo volumoso, ent√£o decidi me concentrar nos problemas mais interessantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora estamos nos preparando para a vers√£o 3.0, o c√≥digo do m√≥dulo est√° no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e qualquer pessoa pode us√°-lo sob a licen√ßa GPL.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430770/">https://habr.com/ru/post/pt430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430754/index.html">Adicione profundidade a sprites 2D usando mapas normais desenhados √† m√£o</a></li>
<li><a href="../pt430756/index.html">Fazendo o mouse WX no Nova Slider 600</a></li>
<li><a href="../pt430762/index.html">Como escolher um no-break para otimizar custos</a></li>
<li><a href="../pt430766/index.html">√â tudo sobre o Agile 1: mitos populares da agenda</a></li>
<li><a href="../pt430768/index.html">Entrevista com o criador do ADOM, Thomas Biscap</a></li>
<li><a href="../pt430774/index.html">Voc√™ est√° pronto para a IA em outdoors?</a></li>
<li><a href="../pt430776/index.html">Fazer um IP √© a √∫nica maneira</a></li>
<li><a href="../pt430778/index.html">3DEXPERIENCE processo de projeto de sistema el√©trico de ponta a ponta</a></li>
<li><a href="../pt430780/index.html">Modelos de sequ√™ncia-sequ√™ncia-parte 1</a></li>
<li><a href="../pt430782/index.html">Quantos programadores voc√™ precisa para suportar c√≥digos escritos anteriormente?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>