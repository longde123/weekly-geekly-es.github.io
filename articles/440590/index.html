<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚝 ☔️ 🛄 ¿Dónde están las patas del modelo de memoria Java? 🤨 🔊 🍯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El hardware y los compiladores modernos están listos para cambiar nuestro código, si solo funciona más rápido. Y sus fabricantes esconden cuidadosamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Dónde están las patas del modelo de memoria Java?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> El hardware y los compiladores modernos están listos para cambiar nuestro código, si solo funciona más rápido.  Y sus fabricantes esconden cuidadosamente su cocina interior.  Y todo está bien siempre que el código se ejecute en un hilo. <br><br>  En un entorno de subprocesos múltiples, puede forzosamente observar cosas interesantes.  Por ejemplo, la ejecución de las instrucciones del programa no está en el orden que está escrito en el código fuente.  De acuerdo, es desagradable darse cuenta de que ejecutar el código fuente línea por línea es solo nuestra imaginación. <br><br>  Pero todos ya se han dado cuenta, porque de alguna manera hay que vivir con eso.  Y los programadores de Java incluso viven bien.  Debido a que Java tiene un modelo de memoria, el Modelo de Memoria Java (JMM), que proporciona reglas bastante simples para escribir el código correcto de subprocesos múltiples. <br><br>  Y estas reglas son suficientes para la mayoría de los programas.  Si no los conoce, pero escribe o desea escribir programas multiproceso en Java, entonces es mejor familiarizarse con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ellos</a> lo antes posible.  Y si lo sabes, pero no tienes suficiente contexto o es interesante saber de dónde crecen las piernas de JMM, entonces este artículo puede ayudarte. <br><a name="habracut"></a><br><h2>  Y persiguiendo la abstracción </h2><br>  En mi opinión, hay un pastel o, más convenientemente, un iceberg.  JMM es la punta del iceberg.  El iceberg en sí es una teoría de la programación multiproceso bajo el agua.  Debajo del iceberg está el infierno. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Un iceberg es una abstracción; si se filtra, ciertamente veremos el infierno.  Aunque están sucediendo muchas cosas interesantes allí, en el artículo de revisión no llegaremos a esto. <br><br>  En el artículo, estoy más interesado en los siguientes temas: <br><br><ul><li>  Teoria y Terminologia </li><li>  ¿Cómo se refleja la teoría de la programación multiproceso en JMM? </li><li>  Modelos de programación competitiva </li></ul><br>  La teoría de la programación multiproceso le permite alejarse de la complejidad de los procesadores y compiladores modernos, le permite simular la ejecución de programas multiproceso y estudiar sus propiedades.  Roman Elizarov hizo un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> , cuyo propósito es proporcionar una base teórica para comprender JMM.  Recomiendo el informe a todos los que estén interesados ​​en este tema. <br><br>  ¿Por qué es importante conocer la teoría?  En mi opinión, espero solo para los míos, algunos programadores tienen la opinión de que JMM es una complicación del lenguaje y la reparación de algunos problemas de plataforma con subprocesos múltiples.  La teoría muestra que Java no complicó, sino que simplificó y convirtió la programación multiproceso más compleja y predecible. <br><br><h2>  Competencia y concurrencia </h2><br>  Primero, veamos la terminología.  Desafortunadamente, no hay consenso en la terminología: al estudiar diferentes materiales, puede encontrar diferentes definiciones de competencia y concurrencia. <br><br>  El problema es que incluso si llegamos al fondo de la verdad y encontramos las definiciones exactas de estos conceptos, todavía no vale la pena esperar que todos signifiquen lo mismo con estos conceptos.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrarás los</a> extremos aquí. <br><br>  Roman Elizarov, en un informe, la teoría de la programación paralela para profesionales sugiere que a veces estos conceptos son mixtos.  La programación paralela a veces se distingue como un concepto general que se divide en competitivo y distribuido. <br><br>  Me parece que en el contexto de JMM todavía necesita separar la competencia y el paralelismo, o más bien incluso comprender que hay dos paradigmas diferentes, sin importar cómo se llamen. <br><br>  A menudo citado por Rob Pike, quien distingue entre conceptos de la siguiente manera: <br><br><ul><li>  La competencia es una forma de resolver simultáneamente muchos problemas. </li><li>  La concurrencia es una forma de realizar diferentes partes de una sola tarea. </li></ul><br>  La opinión de Rob Pike no es un estándar, pero en mi opinión, es conveniente aprovecharla para seguir estudiando el tema.  Lea más sobre las diferencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Lo más probable es que aparezca una mayor comprensión del problema si destacamos las características principales de un programa competitivo y paralelo.  Hay muchos signos, considere los más significativos. <br><br>  Señales de competencia. <br><br><ul><li>  La presencia de varios flujos de control (por ejemplo, Thread en Java, corutina en Kotlin), si solo hay un flujo de control, entonces no puede haber una ejecución competitiva </li><li>  Resultado no determinista.  El resultado depende de eventos aleatorios, implementación y cómo se realizó la sincronización.  Incluso si cada secuencia es completamente determinista, el resultado final será no determinista </li></ul><br>  Un programa paralelo tendrá un conjunto diferente de características. <br><br><ul><li>  Opcional tiene múltiples flujos de control </li><li>  Puede conducir a un resultado determinista, por ejemplo, el resultado de multiplicar cada elemento de la matriz por un número no cambiará si lo multiplica en partes en paralelo </li></ul><br>  Curiosamente, la ejecución en paralelo es posible en un solo flujo de control, e incluso en una arquitectura de un solo núcleo.  El hecho es que el paralelismo a nivel de tareas (o flujos de control) a los que estamos acostumbrados no es la única forma de realizar cálculos en paralelo. <br><br>  La concurrencia es posible a nivel de: <br><br><ul><li>  bits (por ejemplo, en máquinas de 32 bits, la adición se realiza en una acción, procesando los 4 bytes de un número de 32 bits en paralelo) </li><li>  instrucciones (en un núcleo, en un hilo, el procesador puede ejecutar instrucciones en paralelo, a pesar de que el código es secuencial) </li><li>  datos (hay arquitecturas con procesamiento de datos paralelo (Datos múltiples de instrucción única) que pueden ejecutar una instrucción en un conjunto de datos grande) </li><li>  tareas (implica la presencia de múltiples procesadores o núcleos) </li></ul><br>  La concurrencia a nivel de instrucción es un ejemplo de optimizaciones que ocurren con la ejecución de código que están ocultas para el programador. <br><br>  Se garantiza que el código optimizado será equivalente al original dentro del marco de un hilo, porque es imposible escribir código adecuado y predecible si no hace lo que el programador pretendía. <br><br>  No todo lo que se ejecuta en paralelo es importante para JMM.  La ejecución concurrente en el nivel de instrucción dentro de un solo hilo no se considera en JMM. <br><br>  La terminología es muy inestable, con una presentación de Roman Elizarov llamada "Teoría de la programación <b>paralela</b> para profesionales", aunque hay más sobre programación competitiva, si se atiene a lo anterior. <br><br>  En el contexto de JMM, en el artículo me limitaré al término competencia, ya que la competencia es a menudo sobre el estado general.  Pero aquí debe tener cuidado de no aferrarse a los términos, sino comprender que existen diferentes paradigmas. <br><br><h2>  Modelos con un estado común: "rotación de operaciones" y "sucedió antes" </h2><br>  En su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo,</a> Maurice Herlichi (autor de la programación The Art Of Multiprocessor) escribe que un sistema competitivo contiene una colección de procesos secuenciales (en trabajos teóricos significa lo mismo que un hilo) que se comunican a través de la memoria compartida. <br><br>  El modelo de estado general incluye cálculos con mensajes, donde el estado compartido es una cola de mensajes y cálculos con memoria compartida, donde el estado común son estructuras en la memoria. <br><br>  Cada uno de los cálculos puede ser simulado. <br><br>  El modelo se basa en una máquina de estados finitos.  El modelo se centra exclusivamente en el estado compartido y los datos locales de cada uno de los flujos se ignoran por completo.  Cada acción de flujos sobre un estado compartido es una función de la transición a un nuevo estado. <br><br>  Entonces, por ejemplo, si 4 hilos escriben datos en una variable compartida, entonces habrá 4 funciones para la transición a un nuevo estado.  Cuál de estas funciones se aplicará depende de la cronología de los eventos en el sistema. <br><br>  Los cálculos de paso de mensajes se modelan de manera similar, solo el estado y las funciones de transición dependen del envío o recepción de mensajes. <br><br>  Si el modelo le pareció complicado, en el ejemplo lo arreglaremos.  Es realmente muy simple e intuitivo.  Tanto es así que sin saber acerca de la existencia de este modelo, la mayoría de las personas aún analizará el programa como sugiere el modelo. <br><br>  Tal modelo se llama modelo de <b>rendimiento a través de la alternancia de operaciones</b> (el nombre se escuchó en un informe de Roman Elizarov). <br><br>  En la intuición y naturalidad, puede anotar con seguridad las ventajas del modelo.  Puede entrar en la naturaleza con las palabras clave <b>Consistencia secuencial</b> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo de</a> Leslie Lamport. <br><br>  Sin embargo, hay una aclaración importante sobre este modelo.  El modelo tiene la limitación de que todas las acciones en un estado compartido deben ser instantáneas y, al mismo tiempo, las acciones no pueden ocurrir simultáneamente.  Dicen que dicho sistema tiene un <b>orden lineal</b> : todas las acciones en el sistema están ordenadas. <br><br>  En la práctica, esto no sucede.  La operación no ocurre instantáneamente, sino que se realiza en un intervalo; en los sistemas de múltiples núcleos, estos intervalos pueden cruzarse.  Por supuesto, esto no significa que el modelo sea inútil en la práctica, solo necesita crear ciertas condiciones para su uso. <br><br>  Mientras tanto, considere otro <b>modelo: "sucedió antes",</b> que se centra no en el estado, sino en el conjunto de celdas de memoria de lectura y escritura durante la ejecución (historial) y sus relaciones. <br><br>  El modelo dice que los eventos en diferentes flujos no son instantáneos y atómicos, sino paralelos, y que no es posible construir un orden entre ellos.  Los eventos (escritura y lectura de datos compartidos) en flujos en una arquitectura multiprocesador o multinúcleo ocurren realmente en paralelo.  No existe un concepto de tiempo global en el sistema, no podemos entender cuándo terminó una operación y comenzó otra. <br><br>  En la práctica, esto significa que podemos escribir un valor en una variable en un hilo y hacerlo, por ejemplo, en la mañana, y leer el valor de esta variable en otro hilo en la noche, y no podemos decir que seguro leeremos el valor escrito en la mañana.  En teoría, estas operaciones tienen lugar en paralelo y no está claro cuándo terminará una y comenzará otra operación. <br><br>  Es difícil imaginar cómo resulta que las operaciones simples de lectura y escritura realizadas en diferentes momentos del día tienen lugar simultáneamente.  Pero si lo piensa, realmente no nos importa cuándo ocurren los eventos de escritura y lectura, si no podemos garantizar que veremos el resultado de la grabación. <br><br>  Y realmente no podemos ver el resultado de la grabación, es decir  en una variable cuyo valor es <i>0</i> en la secuencia <i>P,</i> escribimos <i>1</i> , y en la secuencia <i>Q</i> leemos esta variable.  No importa cuánto tiempo físico pase después de la grabación, aún podemos leer <i>0</i> . <br><br>  <b>Así es como funcionan las computadoras y el modelo lo refleja.</b> <br><br>  El modelo es completamente abstracto y necesita una visualización conveniente para un trabajo conveniente.  Para la visualización y solo para ello, se utiliza un modelo con tiempo global, con reservas de que al probar las propiedades de los programas, no se utiliza el tiempo global.  En la visualización, cada evento se representa como un intervalo con un principio y un final. <br><br>  Los eventos tienen lugar en paralelo, como descubrimos.  Pero aún así, el sistema tiene un <b>orden parcial</b> , ya que hay pares especiales de eventos que tienen un orden, en cuyo caso dicen que estos eventos tienen una relación "sucedió antes".  Si escuchas por primera vez acerca de la relación "sucedió antes", entonces probablemente saber el hecho de que esta relación organiza los eventos no te ayudará mucho. <br><br><h2>  Intentando analizar un programa Java </h2><br>  Consideramos un mínimo teórico, tratemos de seguir adelante y consideremos un programa multiproceso en un lenguaje específico: Java, a partir de dos hilos con un estado mutable común. <br><br>  Un ejemplo clásico <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Necesitamos simular la ejecución de este programa y obtener todos los resultados posibles: los valores de las variables x e y.  Habrá varios resultados, como recordamos de la teoría, tal programa no es determinista. <br><br>  ¿Cómo vamos a modelar?  Inmediatamente quiero usar el modelo de operaciones entrelazado.  Pero el modelo "sucedió antes" nos dice que los eventos en un hilo son paralelos a los eventos de otro hilo.  Por lo tanto, el modelo de operaciones alternas aquí no es apropiado si no existe una relación "ocurrida antes" entre las operaciones. <br><br>  El resultado de la ejecución de cada subproceso siempre está determinado, ya que los eventos en un subproceso siempre están ordenados, considere que reciben una relación "sucedió antes" de forma gratuita.  Pero cómo los eventos en diferentes flujos pueden obtener la relación "sucedió antes" no es del todo obvio.  Por supuesto, esta relación se formaliza en el modelo, todo el modelo está escrito en lenguaje matemático.  Pero qué hacer con esto en la práctica, en un idioma en particular, no se entiende de inmediato. <br><br>  Cuales son las opciones? <br><br>  Ignorar restricciones y simular intercalación.  Puedes probarlo, tal vez no pase nada malo. <br><br>  Para comprender qué tipo de resultados se pueden obtener, simplemente enumeramos todas las posibles variantes de ejecución. <br><br>  Todas las ejecuciones de programas posibles se pueden representar como una máquina de estados finitos. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Cada círculo es un estado del sistema, en nuestro caso las variables <i>a, b, x, y</i> .  Una función de transición es una acción en un estado que coloca al sistema en un nuevo estado.  Dado que dos flujos pueden realizar acciones en el estado general, habrá dos transiciones desde cada estado.  Los círculos dobles son los estados finales e iniciales del sistema. <br><br>  En total, son posibles 6 ejecuciones diferentes, que resultan en pares de valores x, y: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Podemos ejecutar el programa y verificar los resultados.  Como corresponde a un programa competitivo, tendrá un resultado no determinista. <br><br>  Para probar programas competitivos, es mejor usar herramientas especiales ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> ). <br><br>  Pero puede intentar ejecutar el programa varios millones de veces, o incluso mejor, escribir un ciclo que lo haga por nosotros. <br><br>  Si ejecutamos el código en una arquitectura de núcleo único o procesador único, entonces deberíamos obtener el resultado del conjunto que esperamos.  El modelo de rotación funcionará bien.  En la arquitectura multinúcleo, por ejemplo x86, podemos sorprendernos con el resultado: podemos obtener el resultado (0,0), que no puede ser de acuerdo con nuestro modelo. <br><br>  La explicación de esto se puede encontrar en Internet por la palabra clave: <b>reordenamiento</b> .  Ahora es importante comprender que <b>el modelado entrelazado realmente no es adecuado en una situación en la que no podemos determinar el orden de acceso al estado compartido</b> . <br><br><h2>  Teoría de la programación competitiva y JMM </h2><br>  Es hora de echar un vistazo más de cerca a la relación "sucedió antes" y cómo se hace amigo de JMM.  La definición original de la relación "sucedió antes" se puede encontrar en Hora, Relojes y Ordenación de eventos en un sistema distribuido. <br><br>  El modelo de memoria de lenguaje ayuda a escribir código competitivo, ya que determina qué operaciones están relacionadas con "sucedió antes".  Una lista de tales operaciones se presenta en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificación</a> en la sección Orden antes de que ocurra.  De hecho, esta sección responde a la pregunta: ¿bajo qué condiciones veremos el resultado de la grabación en otra transmisión? <br><br>  Hay varios pedidos en JMM.  Alexei Shipilev habla muy vigorosamente sobre las reglas en uno de sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes</a> . <br><br>  En el modelo de tiempo global, todas las operaciones en el mismo hilo están en orden.  Por ejemplo, los eventos de escribir y leer una variable se pueden representar como dos intervalos, luego el modelo garantiza que estos intervalos nunca se crucen dentro del marco de una sola secuencia.  En JMM, este orden se llama Orden de programa ( <i>PO</i> ). <br><br>  <i>PO</i> vincula acciones en un solo hilo y no dice nada sobre el orden de ejecución, solo habla sobre el orden en el código fuente.  Esto es suficiente para garantizar el <b>determinismo para cada flujo por separado</b> .  <i>PO</i> puede considerarse como datos sin procesar.  <i>PO es</i> siempre fácil de organizar en un programa: todas las operaciones (orden lineal) en el código fuente dentro de una sola secuencia tendrán <i>PO</i> . <br><br>  En nuestro ejemplo, obtenemos algo como lo siguiente: <br><br>  <code>P: a = 1 PO x = b</code> - escribir en ay leer b tiene orden de pedido <br>  <code>Q: b = 1 PO y = a</code> - escribe en b y lee a tiene orden de pedido <br><br>  Vi esta forma de escribir <i>w (a, 1) PO r (b): 0.</i> Realmente espero que nadie la haya patentado para informes.  Sin embargo, la especificación tiene una forma similar. <br><br>  Pero cada hilo individualmente no es particularmente interesante para nosotros, ya que los hilos tienen un estado común, estamos más interesados ​​en la interacción de los flujos.  Todo lo que queremos es asegurarnos de que veremos un registro de variables en otros hilos. <br><br>  Permítame recordarle que esto no funcionó para nosotros, porque las operaciones de escritura y lectura de variables en diferentes flujos no son instantáneas (estos son segmentos que se cruzan), respectivamente, es imposible analizar dónde están el comienzo y el final de las operaciones. <br><br>  La idea es simple: en el momento en que leemos la variable a en la secuencia <i>Q</i> , el registro de esta misma variable en la secuencia <i>P</i> podría no terminar todavía.  Y no importa cuánto tiempo físico compartan estos eventos: un nanosegundo o unas pocas horas. <br><br>  Para ordenar eventos, necesitamos la relación "sucedió antes".  JMM define esta relación.  La especificación corrige el orden en un hilo: <br><br>  <i>Si la operación x e y están en el mismo hilo y en <i>PO</i> x ocurre primero, y luego y, entonces x sucedió antes que y.</i> <i><br></i> <br><br>  Mirando hacia el futuro, podemos decir que podemos reemplazar todas las <i>OP</i> con Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Pero nuevamente volvemos dentro del marco de una secuencia.  <i>HB es</i> posible entre operaciones que ocurren en diferentes hilos, para tratar estos casos nos familiarizaremos con otras órdenes. <br><br>  Orden de sincronización ( <i>SO</i> ): vincula las acciones de sincronización ( <i>SA</i> ), se proporciona una lista completa de <i>SA</i> en la especificación, en la sección 17.4.2.  Acciones  Aquí hay algunos de ellos: <br><br><ul><li>  Lectura de variable volátil </li><li>  Escribir variable volátil </li><li>  Monitor de bloqueo </li><li>  Desbloquear monitor </li></ul><br>  <i>SO</i> es interesante para nosotros, porque tiene la propiedad de que todas las lecturas en el orden <i>SO</i> ven las últimas entradas en <i>SO</i> .  Y les recuerdo que solo lo estamos logrando. <br><br>  En este lugar, repetiré lo que buscamos.  Tenemos un programa multiproceso, queremos simular todas las ejecuciones posibles y obtener todos los resultados que puede dar.  Hay modelos que permiten que esto se haga de manera bastante simple.  Pero requieren que se ordenen todas las acciones en el estado compartido. <br><br>  De acuerdo con la propiedad <i>SO</i> : si todas las acciones del programa son <i>SA</i> , alcanzaremos nuestro objetivo.  Es decir  Podemos establecer un <i>modificador volátil</i> para todas las variables y podemos usar el modelo de alternancia.  Si la intuición te dice que esto no vale la pena, entonces tienes toda la razón.  Con estas acciones, simplemente prohibimos las optimizaciones sobre el código, por supuesto, a veces esta es una buena opción, pero definitivamente no es un caso general. <br><br>  Considere otra orden Sincronizar con ( <i>SW</i> ): orden SO para desbloqueo / bloqueo específico, escritura / lectura de pares volátiles.  No importa en qué flujos estarán estas acciones, lo principal es que están en el mismo monitor, variable volátil.  <i>SW</i> proporciona un puente entre hilos. <br><br>  Y ahora llegamos al orden más interesante: sucede antes ( <i>HB</i> ). <br>  <i>HB</i> es un cierre transitivo de la unión de <i>SW</i> y <i>PO</i> .  <i>PO</i> da un orden lineal dentro de la secuencia, y <i>SW</i> proporciona un puente entre las secuencias.  <i>HB es</i> transitivo, es decir  si <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  La especificación tiene una lista de relaciones <i>HB</i> , puede familiarizarse con ella con más detalle, aquí hay algunas de la lista: <br><br>  Dentro de un solo hilo, cualquier operación sucede antes que cualquier operación que la siga en el código fuente. <br><br>  Sale de un bloque / método sincronizado antes de ingresar un bloque / método sincronizado en el mismo monitor. <br><br>  Escribir un campo <i>volátil</i> sucede antes de leer el mismo campo <i>volátil</i> . <br><br>  Volvamos a nuestro ejemplo: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Volvamos a nuestro ejemplo e intentemos analizar el programa, teniendo en cuenta los pedidos. <br><br>  El análisis del programa utilizando JMM se basa en presentar cualquier hipótesis y confirmarla o refutarla. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Comenzamos nuestro análisis con la hipótesis de que ni una sola ejecución del programa da el resultado (0, 0).  La ausencia de un resultado (0, 0) en todas las ejecuciones es una supuesta propiedad del programa. <br><br>  Probamos la hipótesis construyendo diferentes ejecuciones. <br><br>  Vi la nomenclatura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> (a veces aparece en lugar de <code>…</code> palabra <code>race</code> con una flecha, Alexey mismo usa la flecha y la carrera de palabras en sus informes, pero advierte que este orden no existe en JMM y usa esta notación para mayor claridad). <br><br>  Hacemos una pequeña reserva. <br><br>  Dado que todas las acciones sobre variables comunes son importantes para nosotros, y en el ejemplo, las variables comunes son <i>a, b, x, y</i> .  Entonces, por ejemplo, la operación x = b debe considerarse como r (b) yw (x, b), <code>r(b) HB w(x,b)</code> (basada en <i>PO</i> ).  Pero dado que la variable x no se lee en ninguna parte de los hilos (la lectura impresa al final del código no es interesante, porque después de la operación de unión en el hilo veremos el valor x), no podemos considerar la acción w (x, b). <br><br>  Comprueba la primera actuación. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 … w(b, 1) HB r(a): 0</code> </pre> <br>  En la secuencia <i>Q,</i> leemos la variable a, escribimos en esta variable en la secuencia <i>P.</i>  No hay orden entre escribir y leer <i>(PO, SW, HB)</i> . <br><br>  Si la variable está escrita en un hilo y la lectura está en otro hilo y no hay una relación <i>HB</i> entre operaciones, entonces dicen que la variable se lee en carrera.  Y en la carrera según JMM podemos leer el último valor registrado en <i>HB</i> o cualquier otro valor. <br><br>  Tal actuación es posible.  La ejecución <b>no viola JMM</b> .  Al leer la variable a, puede ver cualquier valor, ya que la lectura ocurre bajo la carrera y no hay garantía de que veremos la acción w (a, 1).  Esto no significa que el programa funcione correctamente, simplemente significa que se espera ese resultado. <br><br>  No tiene sentido considerar el resto de la ejecución, ya que la <b>hipótesis ya está destruida</b> . <br><br>  JMM dice que si el programa no tiene carreras de datos, entonces todas las ejecuciones pueden considerarse como secuenciales.  Vamos a deshacernos de la carrera, para esto necesitamos simplificar las operaciones de lectura y escritura en diferentes hilos.  Es importante comprender que un programa multiproceso, en contraste con uno secuencial, tiene varias ejecuciones.  Y para decir que un programa tiene alguna propiedad, es necesario demostrar que el programa tiene esta propiedad no en una de las ejecuciones, sino en todas las ejecuciones. <br><br>  Para demostrar que el programa no es de carreras, debe hacer esto para todas las actuaciones.  Intentemos hacer <i>SA</i> y marquemos la variable a con un <i>modificador volátil</i> .  <i>Las</i> variables <i>volátiles</i> tendrán el prefijo v. <br><br>  <b>Presentamos una nueva hipótesis</b> .  Si la variable a se vuelve <i>volátil</i> , entonces ninguna ejecución del programa dará el resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 … w(b, 1) HB r(va): 0</code> </pre> <br>  La ejecución <b>no viola JMM</b> .  Leer va sucede bajo la carrera.  Cualquier raza destruye la transitividad de HB. <br><br>  <b>Presentamos otra hipótesis</b> .  Si la variable b se vuelve <i>volátil</i> , ninguna ejecución del programa dará el resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 … w(vb, 1) HB r(a): 0</code> </pre> <br>  La ejecución no viola JMM.  La lectura de ocurre bajo la carrera. <br><br>  Probemos <b>la hipótesis de</b> que si las variables a y b son <i>volátiles</i> , ninguna ejecución del programa dará el resultado (0, 0). <br><br>  Comprueba la primera actuación. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Dado que todas las acciones en el programa <i>SA</i> (específicamente leer o escribir una variable <i>volátil</i> ), obtenemos el orden <i>SO</i> completo entre todas las acciones.  Esto significa que r (va) debería ver w (va, 1).  Esta <b>ejecución viola JMM</b> . <br><br>  Es necesario proceder a la siguiente ejecución para confirmar la hipótesis.  Pero dado que habrá <i>SO</i> para cualquier ejecución, puede desviarse del formalismo: es obvio que el resultado (0, 0) viola el JMM para cualquier ejecución. <br><br>  Para usar el modelo de rotación, debe agregar <i>volátil</i> para las variables a y b.  Tal programa dará los resultados (1,1), (1,0) o (0,1). <br><br>  Al final, podemos decir que los programas muy simples son bastante simples de analizar. <br><br>  Pero los programas complejos con una gran cantidad de ejecuciones y datos compartidos son difíciles de analizar, ya que debe verificar todas las ejecuciones. <br><br><h2>  Otros modelos de ejecución competitiva </h2><br>  ¿Por qué considerar otros modelos de programación competitivos? <br><br>  El uso de hilos y primitivas de sincronización puede resolver todos los problemas.  Todo esto es cierto, pero el problema es que examinamos un ejemplo de una docena de líneas de código, donde 4 líneas de código hacen un trabajo útil. <br><br>  Y allí encontramos un montón de preguntas, hasta el punto de que sin la especificación ni siquiera podríamos calcular correctamente todos los resultados posibles.  Los hilos y las primitivas de sincronización son una cosa muy difícil, cuyo uso ciertamente está justificado en algunos casos.  Básicamente, estos casos están relacionados con el rendimiento. <br><br>  Lo siento, me refiero mucho a Elizarov, pero ¿qué puedo hacer si una persona realmente tiene experiencia en este campo?  Entonces, tiene otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> maravilloso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> "Millones de citas por segundo en Java puro", en el que dice que un estado inmutable es bueno, pero no copiaré mis millones de citas en cada transmisión, lo siento.  Pero no todos tienen millones de citas, muchas tienen tareas más modestas.  ¿Existen modelos de programación competitivos que le permitan olvidarse de JMM y aún así escribir código seguro y competitivo? <br><br>  Si está realmente interesado en esta pregunta, le recomiendo el libro de Paul Butcher, "Siete modelos de competencia en siete semanas".  Revelamos los secretos de los flujos ".  Desafortunadamente, no fue posible encontrar suficiente información sobre el autor, pero el libro debería abrir los ojos a nuevos paradigmas.  Desafortunadamente, no tengo experiencia con muchos otros modelos de competencia, así que obtuve la reseña de este libro. <br><br>  Respondiendo la pregunta anterior.  Según tengo entendido, existen modelos de programación competitivos que pueden al menos reducir en gran medida la necesidad de conocer los matices de JMM.  Sin embargo, si hay un estado mutable y flujos, entonces no arruines ninguna abstracción sobre ellos, todavía habrá un lugar donde estos flujos deberían sincronizar el acceso al estado.  Otra pregunta es que probablemente no tenga que sincronizar el acceso usted mismo, por ejemplo, un marco puede responder a esto.  Pero como hemos dicho, tarde o temprano, puede ocurrir abstracción. <br><br>  Puede excluir el estado mutable en absoluto.  En el mundo de la programación funcional, esta es una práctica normal.  Si no hay estructuras mutables, entonces probablemente no habrá problemas con la memoria compartida por definición.  Hay representantes de lenguajes funcionales en la JVM, como Clojure.  Clojure es un lenguaje funcional híbrido, porque todavía le permite cambiar las estructuras de datos, pero proporciona herramientas más eficientes y seguras para esto. <br><br>  Los lenguajes funcionales son una gran herramienta para trabajar con código competitivo.  Personalmente, no lo uso, porque mi área de actividad es el desarrollo móvil, y allí simplemente no es convencional.  Aunque se pueden adoptar ciertos enfoques. <br><br>  Otra forma de trabajar con datos mutables es evitar el intercambio de datos.  Los actores son un modelo de programación.  Los actores simplifican la programación al no permitir el acceso simultáneo a los datos.  Esto se logra por el hecho de que una función que realiza trabajo en un momento puede funcionar en un solo hilo. <br><br>  Sin embargo, un actor puede cambiar el estado interno.  Dado que en el siguiente momento, el mismo actor puede ejecutarse en otro hilo, esto puede ser un problema.  El problema se puede resolver de diferentes maneras, en lenguajes de programación como Erlang o Elixir, donde el modelo de actor es una parte integral del lenguaje, puede usar la recursión para llamar a un actor con un nuevo estado. <br><br>  En Java, las recursiones pueden ser demasiado caras.  Sin embargo, en Java existen marcos para un trabajo conveniente con este modelo, probablemente el más popular es Akka.  Los desarrolladores de Akka se han ocupado de todo, puede ir a la sección de documentación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Akka y el Modelo de memoria de Java</a> y leer sobre dos casos en los que el acceso a un estado compartido puede ocurrir desde diferentes hilos.  Pero lo más importante, la documentación dice qué eventos se relacionan con "sucedió antes".  Es decir  Esto significa que podemos cambiar el estado del actor tanto como queramos, pero cuando recibamos el siguiente mensaje y posiblemente lo procesemos en otro hilo, tenemos la garantía de ver todos los cambios realizados en otro hilo. <br><br><h2>  ¿Por qué es tan popular el modelo de subprocesamiento? </h2><br>  Examinamos dos modelos de programación competitiva, de hecho, hay aún más de ellos que hacen que la programación competitiva sea más fácil y segura. <br><br>  Pero, ¿por qué los hilos y las cerraduras siguen siendo tan populares? <br><br>  Creo que la razón es la simplicidad del enfoque, por supuesto, por un lado, es fácil cometer muchos errores no obvios con las transmisiones, dispararse en el pie, etc.  Pero, por otro lado <b>, no hay nada complicado en los flujos, especialmente si no piensa en las consecuencias</b> . <br><br>  En un momento dado, el núcleo puede ejecutar una instrucción (de hecho, hay paralelismo en el nivel de instrucción, pero ahora no importa), pero gracias a la multitarea, incluso en máquinas de un solo núcleo, se pueden ejecutar varios programas simultáneamente (por supuesto, pseudo simultáneamente). <br><br>  Para que la multitarea funcione, necesita competencia.  Como ya hemos descubierto, la competencia es imposible sin varios flujos de gestión. <br><br>  ¿Cuántos hilos cree usted que un programa que se ejecuta en un procesador de teléfono móvil de cuatro núcleos debe ser lo más rápido y receptivo posible? <br><br>  Puede haber varias docenas.  Ahora la pregunta es, ¿por qué necesitamos tantos subprocesos para un programa que se ejecuta en hardware que le permite ejecutar solo 2-4 subprocesos a la vez? <br><br>  Para intentar responder a esta pregunta, suponga que solo nuestro programa se ejecuta en el dispositivo y nada más.  ¿Cómo gestionaríamos los recursos que nos proporcionan? <br><br>  Puede asignar un núcleo para la interfaz de usuario, el resto del núcleo para cualquier otra tarea.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si uno de los hilos está bloqueado, por ejemplo, el hilo puede acceder al controlador de memoria y esperar una respuesta, entonces obtendremos un núcleo bloqueado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué tecnologías hay para resolver el problema? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay hilos en Java, podemos crear muchos hilos, y luego otros hilos podrán realizar operaciones mientras algunos hilos están bloqueados. Con una herramienta como hilos, podemos simplificar nuestras vidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El enfoque con subprocesos no es gratuito, la creación de subprocesos generalmente lleva tiempo (se decide por grupos de subprocesos), se les asigna memoria, el cambio entre subprocesos es una operación costosa. Pero es relativamente fácil de programar con ellos, por lo que esta es una tecnología masiva que se usa ampliamente en lenguajes generales, como Java.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java generalmente ama las transmisiones, no es necesario crear para cada acción una transmisión, hay cosas de nivel superior, como Executors, que le permiten trabajar con grupos y escribir código más escalable y flexible. Las transmisiones son realmente convenientes, puede realizar una solicitud de bloqueo a la red y escribir el procesamiento de resultados en la siguiente línea. Incluso si esperamos unos segundos para obtener el resultado, aún podemos realizar otras tareas, ya que el sistema operativo se encargará de la distribución del tiempo del procesador entre los subprocesos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las transmisiones son populares no solo en el desarrollo de back-end, en el desarrollo móvil se considera bastante normal crear docenas de transmisiones para que pueda bloquear una transmisión durante un par de segundos, esperando que los datos se descarguen a través de la red o los datos del socket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los lenguajes como Erlang o Clojure siguen siendo nicho y, por lo tanto, los modelos de programación competitivos que utilizan no son tan populares. </font><font style="vertical-align: inherit;">Sin embargo, los pronósticos para ellos son los más optimistas.</font></font><br><br><h2>  Conclusiones </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si está desarrollando en la plataforma JVM, debe aceptar las reglas del juego indicadas por la plataforma. </font><font style="vertical-align: inherit;">La única forma de escribir código multiproceso normal. </font><font style="vertical-align: inherit;">Es muy deseable comprender el contexto de todo lo que sucede, por lo que será más fácil aceptar las reglas del juego. </font><font style="vertical-align: inherit;">Es incluso mejor mirar a su alrededor y conocer otros paradigmas, aunque no puede llegar a ningún lado desde el submarino, pero puede descubrir nuevos enfoques y herramientas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiales adicionales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traté de colocar en el texto del artículo enlaces a fuentes de las cuales obtuve información. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, el material JMM es fácil de encontrar en Internet. </font><font style="vertical-align: inherit;">Aquí publicaré enlaces a algunos materiales adicionales que están asociados con JMM y que no pueden llamar mi atención de inmediato. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lectura</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog de Alexey Shipilev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sé lo que es obvio, pero es un pecado sin mencionar</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El blog de Cheremin Ruslan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : no ha escrito activamente últimamente, debe buscar sus entradas antiguas en el blog, créanme que vale la pena, hay una fuente</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : hay excelentes artículos sobre subprocesos múltiples y el modelo de memoria</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El blog de Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está abandonado, pero las excavaciones arqueológicas deben llevarse a cabo. </font><font style="vertical-align: inherit;">En general, Roman hizo mucho para educar a la gente en la teoría de la programación multiproceso, búsquela en los medios.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de </font><b><font style="vertical-align: inherit;">podcasts</font></b><font style="vertical-align: inherit;"> que me parecieron particularmente interesantes. </font><font style="vertical-align: inherit;">No se trata de JMM, se trata del infierno, que está sucediendo en la glándula. </font><font style="vertical-align: inherit;">Pero después de escucharlos, quiero besar a los creadores de JMM, que nos han protegido de todo esto.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alexander Titov y Amir Ayupov, ingenieros de Intel y Alexei Markin, programador del ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Lejos Alexei Markin, Programador de ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 107 Historias de escaladores</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informe: agallas # 154 - Ataque de Año Nuevo</font></font></a> <br></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Además de los discursos de las personas mencionadas anteriormente, preste atención al video académico.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Science Center - Lecture 11. Modelos de memoria y problemas de visibilidad</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teoría y práctica de la programación multiproceso.</font></font></a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440590/">https://habr.com/ru/post/440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440576/index.html">Cambios importantes en CTE en PostgreSQL 12</a></li>
<li><a href="../440582/index.html">¿Se arrastran los autos eléctricos al fondo de la corporación automotriz?</a></li>
<li><a href="../440584/index.html">¿Qué le pasa a la Raspberry Pi?</a></li>
<li><a href="../440586/index.html">Consenso de Exonum: cómo funciona</a></li>
<li><a href="../440588/index.html">MIT aprendió a transmitir sonido con un láser</a></li>
<li><a href="../440592/index.html">Creando un juego AR con Vuforia</a></li>
<li><a href="../440594/index.html">1C y Yandex. Cloud Compute Cloud. Arriba y abajo</a></li>
<li><a href="../440596/index.html">Flightradar24: ¿cómo funciona?</a></li>
<li><a href="../440598/index.html">La sonda InSight Martian funciona con éxito en el planeta rojo</a></li>
<li><a href="../440600/index.html">¿Cuántos nombres de dominio .com no se usan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>