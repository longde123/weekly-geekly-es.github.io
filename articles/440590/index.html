<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöù ‚òîÔ∏è üõÑ ¬øD√≥nde est√°n las patas del modelo de memoria Java? ü§® üîä üçØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El hardware y los compiladores modernos est√°n listos para cambiar nuestro c√≥digo, si solo funciona m√°s r√°pido. Y sus fabricantes esconden cuidadosamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øD√≥nde est√°n las patas del modelo de memoria Java?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> El hardware y los compiladores modernos est√°n listos para cambiar nuestro c√≥digo, si solo funciona m√°s r√°pido.  Y sus fabricantes esconden cuidadosamente su cocina interior.  Y todo est√° bien siempre que el c√≥digo se ejecute en un hilo. <br><br>  En un entorno de subprocesos m√∫ltiples, puede forzosamente observar cosas interesantes.  Por ejemplo, la ejecuci√≥n de las instrucciones del programa no est√° en el orden que est√° escrito en el c√≥digo fuente.  De acuerdo, es desagradable darse cuenta de que ejecutar el c√≥digo fuente l√≠nea por l√≠nea es solo nuestra imaginaci√≥n. <br><br>  Pero todos ya se han dado cuenta, porque de alguna manera hay que vivir con eso.  Y los programadores de Java incluso viven bien.  Debido a que Java tiene un modelo de memoria, el Modelo de Memoria Java (JMM), que proporciona reglas bastante simples para escribir el c√≥digo correcto de subprocesos m√∫ltiples. <br><br>  Y estas reglas son suficientes para la mayor√≠a de los programas.  Si no los conoce, pero escribe o desea escribir programas multiproceso en Java, entonces es mejor familiarizarse con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ellos</a> lo antes posible.  Y si lo sabes, pero no tienes suficiente contexto o es interesante saber de d√≥nde crecen las piernas de JMM, entonces este art√≠culo puede ayudarte. <br><a name="habracut"></a><br><h2>  Y persiguiendo la abstracci√≥n </h2><br>  En mi opini√≥n, hay un pastel o, m√°s convenientemente, un iceberg.  JMM es la punta del iceberg.  El iceberg en s√≠ es una teor√≠a de la programaci√≥n multiproceso bajo el agua.  Debajo del iceberg est√° el infierno. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Un iceberg es una abstracci√≥n; si se filtra, ciertamente veremos el infierno.  Aunque est√°n sucediendo muchas cosas interesantes all√≠, en el art√≠culo de revisi√≥n no llegaremos a esto. <br><br>  En el art√≠culo, estoy m√°s interesado en los siguientes temas: <br><br><ul><li>  Teoria y Terminologia </li><li>  ¬øC√≥mo se refleja la teor√≠a de la programaci√≥n multiproceso en JMM? </li><li>  Modelos de programaci√≥n competitiva </li></ul><br>  La teor√≠a de la programaci√≥n multiproceso le permite alejarse de la complejidad de los procesadores y compiladores modernos, le permite simular la ejecuci√≥n de programas multiproceso y estudiar sus propiedades.  Roman Elizarov hizo un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> , cuyo prop√≥sito es proporcionar una base te√≥rica para comprender JMM.  Recomiendo el informe a todos los que est√©n interesados ‚Äã‚Äãen este tema. <br><br>  ¬øPor qu√© es importante conocer la teor√≠a?  En mi opini√≥n, espero solo para los m√≠os, algunos programadores tienen la opini√≥n de que JMM es una complicaci√≥n del lenguaje y la reparaci√≥n de algunos problemas de plataforma con subprocesos m√∫ltiples.  La teor√≠a muestra que Java no complic√≥, sino que simplific√≥ y convirti√≥ la programaci√≥n multiproceso m√°s compleja y predecible. <br><br><h2>  Competencia y concurrencia </h2><br>  Primero, veamos la terminolog√≠a.  Desafortunadamente, no hay consenso en la terminolog√≠a: al estudiar diferentes materiales, puede encontrar diferentes definiciones de competencia y concurrencia. <br><br>  El problema es que incluso si llegamos al fondo de la verdad y encontramos las definiciones exactas de estos conceptos, todav√≠a no vale la pena esperar que todos signifiquen lo mismo con estos conceptos.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar√°s los</a> extremos aqu√≠. <br><br>  Roman Elizarov, en un informe, la teor√≠a de la programaci√≥n paralela para profesionales sugiere que a veces estos conceptos son mixtos.  La programaci√≥n paralela a veces se distingue como un concepto general que se divide en competitivo y distribuido. <br><br>  Me parece que en el contexto de JMM todav√≠a necesita separar la competencia y el paralelismo, o m√°s bien incluso comprender que hay dos paradigmas diferentes, sin importar c√≥mo se llamen. <br><br>  A menudo citado por Rob Pike, quien distingue entre conceptos de la siguiente manera: <br><br><ul><li>  La competencia es una forma de resolver simult√°neamente muchos problemas. </li><li>  La concurrencia es una forma de realizar diferentes partes de una sola tarea. </li></ul><br>  La opini√≥n de Rob Pike no es un est√°ndar, pero en mi opini√≥n, es conveniente aprovecharla para seguir estudiando el tema.  Lea m√°s sobre las diferencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Lo m√°s probable es que aparezca una mayor comprensi√≥n del problema si destacamos las caracter√≠sticas principales de un programa competitivo y paralelo.  Hay muchos signos, considere los m√°s significativos. <br><br>  Se√±ales de competencia. <br><br><ul><li>  La presencia de varios flujos de control (por ejemplo, Thread en Java, corutina en Kotlin), si solo hay un flujo de control, entonces no puede haber una ejecuci√≥n competitiva </li><li>  Resultado no determinista.  El resultado depende de eventos aleatorios, implementaci√≥n y c√≥mo se realiz√≥ la sincronizaci√≥n.  Incluso si cada secuencia es completamente determinista, el resultado final ser√° no determinista </li></ul><br>  Un programa paralelo tendr√° un conjunto diferente de caracter√≠sticas. <br><br><ul><li>  Opcional tiene m√∫ltiples flujos de control </li><li>  Puede conducir a un resultado determinista, por ejemplo, el resultado de multiplicar cada elemento de la matriz por un n√∫mero no cambiar√° si lo multiplica en partes en paralelo </li></ul><br>  Curiosamente, la ejecuci√≥n en paralelo es posible en un solo flujo de control, e incluso en una arquitectura de un solo n√∫cleo.  El hecho es que el paralelismo a nivel de tareas (o flujos de control) a los que estamos acostumbrados no es la √∫nica forma de realizar c√°lculos en paralelo. <br><br>  La concurrencia es posible a nivel de: <br><br><ul><li>  bits (por ejemplo, en m√°quinas de 32 bits, la adici√≥n se realiza en una acci√≥n, procesando los 4 bytes de un n√∫mero de 32 bits en paralelo) </li><li>  instrucciones (en un n√∫cleo, en un hilo, el procesador puede ejecutar instrucciones en paralelo, a pesar de que el c√≥digo es secuencial) </li><li>  datos (hay arquitecturas con procesamiento de datos paralelo (Datos m√∫ltiples de instrucci√≥n √∫nica) que pueden ejecutar una instrucci√≥n en un conjunto de datos grande) </li><li>  tareas (implica la presencia de m√∫ltiples procesadores o n√∫cleos) </li></ul><br>  La concurrencia a nivel de instrucci√≥n es un ejemplo de optimizaciones que ocurren con la ejecuci√≥n de c√≥digo que est√°n ocultas para el programador. <br><br>  Se garantiza que el c√≥digo optimizado ser√° equivalente al original dentro del marco de un hilo, porque es imposible escribir c√≥digo adecuado y predecible si no hace lo que el programador pretend√≠a. <br><br>  No todo lo que se ejecuta en paralelo es importante para JMM.  La ejecuci√≥n concurrente en el nivel de instrucci√≥n dentro de un solo hilo no se considera en JMM. <br><br>  La terminolog√≠a es muy inestable, con una presentaci√≥n de Roman Elizarov llamada "Teor√≠a de la programaci√≥n <b>paralela</b> para profesionales", aunque hay m√°s sobre programaci√≥n competitiva, si se atiene a lo anterior. <br><br>  En el contexto de JMM, en el art√≠culo me limitar√© al t√©rmino competencia, ya que la competencia es a menudo sobre el estado general.  Pero aqu√≠ debe tener cuidado de no aferrarse a los t√©rminos, sino comprender que existen diferentes paradigmas. <br><br><h2>  Modelos con un estado com√∫n: "rotaci√≥n de operaciones" y "sucedi√≥ antes" </h2><br>  En su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo,</a> Maurice Herlichi (autor de la programaci√≥n The Art Of Multiprocessor) escribe que un sistema competitivo contiene una colecci√≥n de procesos secuenciales (en trabajos te√≥ricos significa lo mismo que un hilo) que se comunican a trav√©s de la memoria compartida. <br><br>  El modelo de estado general incluye c√°lculos con mensajes, donde el estado compartido es una cola de mensajes y c√°lculos con memoria compartida, donde el estado com√∫n son estructuras en la memoria. <br><br>  Cada uno de los c√°lculos puede ser simulado. <br><br>  El modelo se basa en una m√°quina de estados finitos.  El modelo se centra exclusivamente en el estado compartido y los datos locales de cada uno de los flujos se ignoran por completo.  Cada acci√≥n de flujos sobre un estado compartido es una funci√≥n de la transici√≥n a un nuevo estado. <br><br>  Entonces, por ejemplo, si 4 hilos escriben datos en una variable compartida, entonces habr√° 4 funciones para la transici√≥n a un nuevo estado.  Cu√°l de estas funciones se aplicar√° depende de la cronolog√≠a de los eventos en el sistema. <br><br>  Los c√°lculos de paso de mensajes se modelan de manera similar, solo el estado y las funciones de transici√≥n dependen del env√≠o o recepci√≥n de mensajes. <br><br>  Si el modelo le pareci√≥ complicado, en el ejemplo lo arreglaremos.  Es realmente muy simple e intuitivo.  Tanto es as√≠ que sin saber acerca de la existencia de este modelo, la mayor√≠a de las personas a√∫n analizar√° el programa como sugiere el modelo. <br><br>  Tal modelo se llama modelo de <b>rendimiento a trav√©s de la alternancia de operaciones</b> (el nombre se escuch√≥ en un informe de Roman Elizarov). <br><br>  En la intuici√≥n y naturalidad, puede anotar con seguridad las ventajas del modelo.  Puede entrar en la naturaleza con las palabras clave <b>Consistencia secuencial</b> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo de</a> Leslie Lamport. <br><br>  Sin embargo, hay una aclaraci√≥n importante sobre este modelo.  El modelo tiene la limitaci√≥n de que todas las acciones en un estado compartido deben ser instant√°neas y, al mismo tiempo, las acciones no pueden ocurrir simult√°neamente.  Dicen que dicho sistema tiene un <b>orden lineal</b> : todas las acciones en el sistema est√°n ordenadas. <br><br>  En la pr√°ctica, esto no sucede.  La operaci√≥n no ocurre instant√°neamente, sino que se realiza en un intervalo; en los sistemas de m√∫ltiples n√∫cleos, estos intervalos pueden cruzarse.  Por supuesto, esto no significa que el modelo sea in√∫til en la pr√°ctica, solo necesita crear ciertas condiciones para su uso. <br><br>  Mientras tanto, considere otro <b>modelo: "sucedi√≥ antes",</b> que se centra no en el estado, sino en el conjunto de celdas de memoria de lectura y escritura durante la ejecuci√≥n (historial) y sus relaciones. <br><br>  El modelo dice que los eventos en diferentes flujos no son instant√°neos y at√≥micos, sino paralelos, y que no es posible construir un orden entre ellos.  Los eventos (escritura y lectura de datos compartidos) en flujos en una arquitectura multiprocesador o multin√∫cleo ocurren realmente en paralelo.  No existe un concepto de tiempo global en el sistema, no podemos entender cu√°ndo termin√≥ una operaci√≥n y comenz√≥ otra. <br><br>  En la pr√°ctica, esto significa que podemos escribir un valor en una variable en un hilo y hacerlo, por ejemplo, en la ma√±ana, y leer el valor de esta variable en otro hilo en la noche, y no podemos decir que seguro leeremos el valor escrito en la ma√±ana.  En teor√≠a, estas operaciones tienen lugar en paralelo y no est√° claro cu√°ndo terminar√° una y comenzar√° otra operaci√≥n. <br><br>  Es dif√≠cil imaginar c√≥mo resulta que las operaciones simples de lectura y escritura realizadas en diferentes momentos del d√≠a tienen lugar simult√°neamente.  Pero si lo piensa, realmente no nos importa cu√°ndo ocurren los eventos de escritura y lectura, si no podemos garantizar que veremos el resultado de la grabaci√≥n. <br><br>  Y realmente no podemos ver el resultado de la grabaci√≥n, es decir  en una variable cuyo valor es <i>0</i> en la secuencia <i>P,</i> escribimos <i>1</i> , y en la secuencia <i>Q</i> leemos esta variable.  No importa cu√°nto tiempo f√≠sico pase despu√©s de la grabaci√≥n, a√∫n podemos leer <i>0</i> . <br><br>  <b>As√≠ es como funcionan las computadoras y el modelo lo refleja.</b> <br><br>  El modelo es completamente abstracto y necesita una visualizaci√≥n conveniente para un trabajo conveniente.  Para la visualizaci√≥n y solo para ello, se utiliza un modelo con tiempo global, con reservas de que al probar las propiedades de los programas, no se utiliza el tiempo global.  En la visualizaci√≥n, cada evento se representa como un intervalo con un principio y un final. <br><br>  Los eventos tienen lugar en paralelo, como descubrimos.  Pero a√∫n as√≠, el sistema tiene un <b>orden parcial</b> , ya que hay pares especiales de eventos que tienen un orden, en cuyo caso dicen que estos eventos tienen una relaci√≥n "sucedi√≥ antes".  Si escuchas por primera vez acerca de la relaci√≥n "sucedi√≥ antes", entonces probablemente saber el hecho de que esta relaci√≥n organiza los eventos no te ayudar√° mucho. <br><br><h2>  Intentando analizar un programa Java </h2><br>  Consideramos un m√≠nimo te√≥rico, tratemos de seguir adelante y consideremos un programa multiproceso en un lenguaje espec√≠fico: Java, a partir de dos hilos con un estado mutable com√∫n. <br><br>  Un ejemplo cl√°sico <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Necesitamos simular la ejecuci√≥n de este programa y obtener todos los resultados posibles: los valores de las variables x e y.  Habr√° varios resultados, como recordamos de la teor√≠a, tal programa no es determinista. <br><br>  ¬øC√≥mo vamos a modelar?  Inmediatamente quiero usar el modelo de operaciones entrelazado.  Pero el modelo "sucedi√≥ antes" nos dice que los eventos en un hilo son paralelos a los eventos de otro hilo.  Por lo tanto, el modelo de operaciones alternas aqu√≠ no es apropiado si no existe una relaci√≥n "ocurrida antes" entre las operaciones. <br><br>  El resultado de la ejecuci√≥n de cada subproceso siempre est√° determinado, ya que los eventos en un subproceso siempre est√°n ordenados, considere que reciben una relaci√≥n "sucedi√≥ antes" de forma gratuita.  Pero c√≥mo los eventos en diferentes flujos pueden obtener la relaci√≥n "sucedi√≥ antes" no es del todo obvio.  Por supuesto, esta relaci√≥n se formaliza en el modelo, todo el modelo est√° escrito en lenguaje matem√°tico.  Pero qu√© hacer con esto en la pr√°ctica, en un idioma en particular, no se entiende de inmediato. <br><br>  Cuales son las opciones? <br><br>  Ignorar restricciones y simular intercalaci√≥n.  Puedes probarlo, tal vez no pase nada malo. <br><br>  Para comprender qu√© tipo de resultados se pueden obtener, simplemente enumeramos todas las posibles variantes de ejecuci√≥n. <br><br>  Todas las ejecuciones de programas posibles se pueden representar como una m√°quina de estados finitos. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Cada c√≠rculo es un estado del sistema, en nuestro caso las variables <i>a, b, x, y</i> .  Una funci√≥n de transici√≥n es una acci√≥n en un estado que coloca al sistema en un nuevo estado.  Dado que dos flujos pueden realizar acciones en el estado general, habr√° dos transiciones desde cada estado.  Los c√≠rculos dobles son los estados finales e iniciales del sistema. <br><br>  En total, son posibles 6 ejecuciones diferentes, que resultan en pares de valores x, y: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Podemos ejecutar el programa y verificar los resultados.  Como corresponde a un programa competitivo, tendr√° un resultado no determinista. <br><br>  Para probar programas competitivos, es mejor usar herramientas especiales ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> ). <br><br>  Pero puede intentar ejecutar el programa varios millones de veces, o incluso mejor, escribir un ciclo que lo haga por nosotros. <br><br>  Si ejecutamos el c√≥digo en una arquitectura de n√∫cleo √∫nico o procesador √∫nico, entonces deber√≠amos obtener el resultado del conjunto que esperamos.  El modelo de rotaci√≥n funcionar√° bien.  En la arquitectura multin√∫cleo, por ejemplo x86, podemos sorprendernos con el resultado: podemos obtener el resultado (0,0), que no puede ser de acuerdo con nuestro modelo. <br><br>  La explicaci√≥n de esto se puede encontrar en Internet por la palabra clave: <b>reordenamiento</b> .  Ahora es importante comprender que <b>el modelado entrelazado realmente no es adecuado en una situaci√≥n en la que no podemos determinar el orden de acceso al estado compartido</b> . <br><br><h2>  Teor√≠a de la programaci√≥n competitiva y JMM </h2><br>  Es hora de echar un vistazo m√°s de cerca a la relaci√≥n "sucedi√≥ antes" y c√≥mo se hace amigo de JMM.  La definici√≥n original de la relaci√≥n "sucedi√≥ antes" se puede encontrar en Hora, Relojes y Ordenaci√≥n de eventos en un sistema distribuido. <br><br>  El modelo de memoria de lenguaje ayuda a escribir c√≥digo competitivo, ya que determina qu√© operaciones est√°n relacionadas con "sucedi√≥ antes".  Una lista de tales operaciones se presenta en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> en la secci√≥n Orden antes de que ocurra.  De hecho, esta secci√≥n responde a la pregunta: ¬øbajo qu√© condiciones veremos el resultado de la grabaci√≥n en otra transmisi√≥n? <br><br>  Hay varios pedidos en JMM.  Alexei Shipilev habla muy vigorosamente sobre las reglas en uno de sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes</a> . <br><br>  En el modelo de tiempo global, todas las operaciones en el mismo hilo est√°n en orden.  Por ejemplo, los eventos de escribir y leer una variable se pueden representar como dos intervalos, luego el modelo garantiza que estos intervalos nunca se crucen dentro del marco de una sola secuencia.  En JMM, este orden se llama Orden de programa ( <i>PO</i> ). <br><br>  <i>PO</i> vincula acciones en un solo hilo y no dice nada sobre el orden de ejecuci√≥n, solo habla sobre el orden en el c√≥digo fuente.  Esto es suficiente para garantizar el <b>determinismo para cada flujo por separado</b> .  <i>PO</i> puede considerarse como datos sin procesar.  <i>PO es</i> siempre f√°cil de organizar en un programa: todas las operaciones (orden lineal) en el c√≥digo fuente dentro de una sola secuencia tendr√°n <i>PO</i> . <br><br>  En nuestro ejemplo, obtenemos algo como lo siguiente: <br><br>  <code>P: a = 1 PO x = b</code> - escribir en ay leer b tiene orden de pedido <br>  <code>Q: b = 1 PO y = a</code> - escribe en b y lee a tiene orden de pedido <br><br>  Vi esta forma de escribir <i>w (a, 1) PO r (b): 0.</i> Realmente espero que nadie la haya patentado para informes.  Sin embargo, la especificaci√≥n tiene una forma similar. <br><br>  Pero cada hilo individualmente no es particularmente interesante para nosotros, ya que los hilos tienen un estado com√∫n, estamos m√°s interesados ‚Äã‚Äãen la interacci√≥n de los flujos.  Todo lo que queremos es asegurarnos de que veremos un registro de variables en otros hilos. <br><br>  Perm√≠tame recordarle que esto no funcion√≥ para nosotros, porque las operaciones de escritura y lectura de variables en diferentes flujos no son instant√°neas (estos son segmentos que se cruzan), respectivamente, es imposible analizar d√≥nde est√°n el comienzo y el final de las operaciones. <br><br>  La idea es simple: en el momento en que leemos la variable a en la secuencia <i>Q</i> , el registro de esta misma variable en la secuencia <i>P</i> podr√≠a no terminar todav√≠a.  Y no importa cu√°nto tiempo f√≠sico compartan estos eventos: un nanosegundo o unas pocas horas. <br><br>  Para ordenar eventos, necesitamos la relaci√≥n "sucedi√≥ antes".  JMM define esta relaci√≥n.  La especificaci√≥n corrige el orden en un hilo: <br><br>  <i>Si la operaci√≥n x e y est√°n en el mismo hilo y en <i>PO</i> x ocurre primero, y luego y, entonces x sucedi√≥ antes que y.</i> <i><br></i> <br><br>  Mirando hacia el futuro, podemos decir que podemos reemplazar todas las <i>OP</i> con Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Pero nuevamente volvemos dentro del marco de una secuencia.  <i>HB es</i> posible entre operaciones que ocurren en diferentes hilos, para tratar estos casos nos familiarizaremos con otras √≥rdenes. <br><br>  Orden de sincronizaci√≥n ( <i>SO</i> ): vincula las acciones de sincronizaci√≥n ( <i>SA</i> ), se proporciona una lista completa de <i>SA</i> en la especificaci√≥n, en la secci√≥n 17.4.2.  Acciones  Aqu√≠ hay algunos de ellos: <br><br><ul><li>  Lectura de variable vol√°til </li><li>  Escribir variable vol√°til </li><li>  Monitor de bloqueo </li><li>  Desbloquear monitor </li></ul><br>  <i>SO</i> es interesante para nosotros, porque tiene la propiedad de que todas las lecturas en el orden <i>SO</i> ven las √∫ltimas entradas en <i>SO</i> .  Y les recuerdo que solo lo estamos logrando. <br><br>  En este lugar, repetir√© lo que buscamos.  Tenemos un programa multiproceso, queremos simular todas las ejecuciones posibles y obtener todos los resultados que puede dar.  Hay modelos que permiten que esto se haga de manera bastante simple.  Pero requieren que se ordenen todas las acciones en el estado compartido. <br><br>  De acuerdo con la propiedad <i>SO</i> : si todas las acciones del programa son <i>SA</i> , alcanzaremos nuestro objetivo.  Es decir  Podemos establecer un <i>modificador vol√°til</i> para todas las variables y podemos usar el modelo de alternancia.  Si la intuici√≥n te dice que esto no vale la pena, entonces tienes toda la raz√≥n.  Con estas acciones, simplemente prohibimos las optimizaciones sobre el c√≥digo, por supuesto, a veces esta es una buena opci√≥n, pero definitivamente no es un caso general. <br><br>  Considere otra orden Sincronizar con ( <i>SW</i> ): orden SO para desbloqueo / bloqueo espec√≠fico, escritura / lectura de pares vol√°tiles.  No importa en qu√© flujos estar√°n estas acciones, lo principal es que est√°n en el mismo monitor, variable vol√°til.  <i>SW</i> proporciona un puente entre hilos. <br><br>  Y ahora llegamos al orden m√°s interesante: sucede antes ( <i>HB</i> ). <br>  <i>HB</i> es un cierre transitivo de la uni√≥n de <i>SW</i> y <i>PO</i> .  <i>PO</i> da un orden lineal dentro de la secuencia, y <i>SW</i> proporciona un puente entre las secuencias.  <i>HB es</i> transitivo, es decir  si <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  La especificaci√≥n tiene una lista de relaciones <i>HB</i> , puede familiarizarse con ella con m√°s detalle, aqu√≠ hay algunas de la lista: <br><br>  Dentro de un solo hilo, cualquier operaci√≥n sucede antes que cualquier operaci√≥n que la siga en el c√≥digo fuente. <br><br>  Sale de un bloque / m√©todo sincronizado antes de ingresar un bloque / m√©todo sincronizado en el mismo monitor. <br><br>  Escribir un campo <i>vol√°til</i> sucede antes de leer el mismo campo <i>vol√°til</i> . <br><br>  Volvamos a nuestro ejemplo: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Volvamos a nuestro ejemplo e intentemos analizar el programa, teniendo en cuenta los pedidos. <br><br>  El an√°lisis del programa utilizando JMM se basa en presentar cualquier hip√≥tesis y confirmarla o refutarla. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Comenzamos nuestro an√°lisis con la hip√≥tesis de que ni una sola ejecuci√≥n del programa da el resultado (0, 0).  La ausencia de un resultado (0, 0) en todas las ejecuciones es una supuesta propiedad del programa. <br><br>  Probamos la hip√≥tesis construyendo diferentes ejecuciones. <br><br>  Vi la nomenclatura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (a veces aparece en lugar de <code>‚Ä¶</code> palabra <code>race</code> con una flecha, Alexey mismo usa la flecha y la carrera de palabras en sus informes, pero advierte que este orden no existe en JMM y usa esta notaci√≥n para mayor claridad). <br><br>  Hacemos una peque√±a reserva. <br><br>  Dado que todas las acciones sobre variables comunes son importantes para nosotros, y en el ejemplo, las variables comunes son <i>a, b, x, y</i> .  Entonces, por ejemplo, la operaci√≥n x = b debe considerarse como r (b) yw (x, b), <code>r(b) HB w(x,b)</code> (basada en <i>PO</i> ).  Pero dado que la variable x no se lee en ninguna parte de los hilos (la lectura impresa al final del c√≥digo no es interesante, porque despu√©s de la operaci√≥n de uni√≥n en el hilo veremos el valor x), no podemos considerar la acci√≥n w (x, b). <br><br>  Comprueba la primera actuaci√≥n. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(a): 0</code> </pre> <br>  En la secuencia <i>Q,</i> leemos la variable a, escribimos en esta variable en la secuencia <i>P.</i>  No hay orden entre escribir y leer <i>(PO, SW, HB)</i> . <br><br>  Si la variable est√° escrita en un hilo y la lectura est√° en otro hilo y no hay una relaci√≥n <i>HB</i> entre operaciones, entonces dicen que la variable se lee en carrera.  Y en la carrera seg√∫n JMM podemos leer el √∫ltimo valor registrado en <i>HB</i> o cualquier otro valor. <br><br>  Tal actuaci√≥n es posible.  La ejecuci√≥n <b>no viola JMM</b> .  Al leer la variable a, puede ver cualquier valor, ya que la lectura ocurre bajo la carrera y no hay garant√≠a de que veremos la acci√≥n w (a, 1).  Esto no significa que el programa funcione correctamente, simplemente significa que se espera ese resultado. <br><br>  No tiene sentido considerar el resto de la ejecuci√≥n, ya que la <b>hip√≥tesis ya est√° destruida</b> . <br><br>  JMM dice que si el programa no tiene carreras de datos, entonces todas las ejecuciones pueden considerarse como secuenciales.  Vamos a deshacernos de la carrera, para esto necesitamos simplificar las operaciones de lectura y escritura en diferentes hilos.  Es importante comprender que un programa multiproceso, en contraste con uno secuencial, tiene varias ejecuciones.  Y para decir que un programa tiene alguna propiedad, es necesario demostrar que el programa tiene esta propiedad no en una de las ejecuciones, sino en todas las ejecuciones. <br><br>  Para demostrar que el programa no es de carreras, debe hacer esto para todas las actuaciones.  Intentemos hacer <i>SA</i> y marquemos la variable a con un <i>modificador vol√°til</i> .  <i>Las</i> variables <i>vol√°tiles</i> tendr√°n el prefijo v. <br><br>  <b>Presentamos una nueva hip√≥tesis</b> .  Si la variable a se vuelve <i>vol√°til</i> , entonces ninguna ejecuci√≥n del programa dar√° el resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(va): 0</code> </pre> <br>  La ejecuci√≥n <b>no viola JMM</b> .  Leer va sucede bajo la carrera.  Cualquier raza destruye la transitividad de HB. <br><br>  <b>Presentamos otra hip√≥tesis</b> .  Si la variable b se vuelve <i>vol√°til</i> , ninguna ejecuci√≥n del programa dar√° el resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 ‚Ä¶ w(vb, 1) HB r(a): 0</code> </pre> <br>  La ejecuci√≥n no viola JMM.  La lectura de ocurre bajo la carrera. <br><br>  Probemos <b>la hip√≥tesis de</b> que si las variables a y b son <i>vol√°tiles</i> , ninguna ejecuci√≥n del programa dar√° el resultado (0, 0). <br><br>  Comprueba la primera actuaci√≥n. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Dado que todas las acciones en el programa <i>SA</i> (espec√≠ficamente leer o escribir una variable <i>vol√°til</i> ), obtenemos el orden <i>SO</i> completo entre todas las acciones.  Esto significa que r (va) deber√≠a ver w (va, 1).  Esta <b>ejecuci√≥n viola JMM</b> . <br><br>  Es necesario proceder a la siguiente ejecuci√≥n para confirmar la hip√≥tesis.  Pero dado que habr√° <i>SO</i> para cualquier ejecuci√≥n, puede desviarse del formalismo: es obvio que el resultado (0, 0) viola el JMM para cualquier ejecuci√≥n. <br><br>  Para usar el modelo de rotaci√≥n, debe agregar <i>vol√°til</i> para las variables a y b.  Tal programa dar√° los resultados (1,1), (1,0) o (0,1). <br><br>  Al final, podemos decir que los programas muy simples son bastante simples de analizar. <br><br>  Pero los programas complejos con una gran cantidad de ejecuciones y datos compartidos son dif√≠ciles de analizar, ya que debe verificar todas las ejecuciones. <br><br><h2>  Otros modelos de ejecuci√≥n competitiva </h2><br>  ¬øPor qu√© considerar otros modelos de programaci√≥n competitivos? <br><br>  El uso de hilos y primitivas de sincronizaci√≥n puede resolver todos los problemas.  Todo esto es cierto, pero el problema es que examinamos un ejemplo de una docena de l√≠neas de c√≥digo, donde 4 l√≠neas de c√≥digo hacen un trabajo √∫til. <br><br>  Y all√≠ encontramos un mont√≥n de preguntas, hasta el punto de que sin la especificaci√≥n ni siquiera podr√≠amos calcular correctamente todos los resultados posibles.  Los hilos y las primitivas de sincronizaci√≥n son una cosa muy dif√≠cil, cuyo uso ciertamente est√° justificado en algunos casos.  B√°sicamente, estos casos est√°n relacionados con el rendimiento. <br><br>  Lo siento, me refiero mucho a Elizarov, pero ¬øqu√© puedo hacer si una persona realmente tiene experiencia en este campo?  Entonces, tiene otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> maravilloso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> "Millones de citas por segundo en Java puro", en el que dice que un estado inmutable es bueno, pero no copiar√© mis millones de citas en cada transmisi√≥n, lo siento.  Pero no todos tienen millones de citas, muchas tienen tareas m√°s modestas.  ¬øExisten modelos de programaci√≥n competitivos que le permitan olvidarse de JMM y a√∫n as√≠ escribir c√≥digo seguro y competitivo? <br><br>  Si est√° realmente interesado en esta pregunta, le recomiendo el libro de Paul Butcher, "Siete modelos de competencia en siete semanas".  Revelamos los secretos de los flujos ".  Desafortunadamente, no fue posible encontrar suficiente informaci√≥n sobre el autor, pero el libro deber√≠a abrir los ojos a nuevos paradigmas.  Desafortunadamente, no tengo experiencia con muchos otros modelos de competencia, as√≠ que obtuve la rese√±a de este libro. <br><br>  Respondiendo la pregunta anterior.  Seg√∫n tengo entendido, existen modelos de programaci√≥n competitivos que pueden al menos reducir en gran medida la necesidad de conocer los matices de JMM.  Sin embargo, si hay un estado mutable y flujos, entonces no arruines ninguna abstracci√≥n sobre ellos, todav√≠a habr√° un lugar donde estos flujos deber√≠an sincronizar el acceso al estado.  Otra pregunta es que probablemente no tenga que sincronizar el acceso usted mismo, por ejemplo, un marco puede responder a esto.  Pero como hemos dicho, tarde o temprano, puede ocurrir abstracci√≥n. <br><br>  Puede excluir el estado mutable en absoluto.  En el mundo de la programaci√≥n funcional, esta es una pr√°ctica normal.  Si no hay estructuras mutables, entonces probablemente no habr√° problemas con la memoria compartida por definici√≥n.  Hay representantes de lenguajes funcionales en la JVM, como Clojure.  Clojure es un lenguaje funcional h√≠brido, porque todav√≠a le permite cambiar las estructuras de datos, pero proporciona herramientas m√°s eficientes y seguras para esto. <br><br>  Los lenguajes funcionales son una gran herramienta para trabajar con c√≥digo competitivo.  Personalmente, no lo uso, porque mi √°rea de actividad es el desarrollo m√≥vil, y all√≠ simplemente no es convencional.  Aunque se pueden adoptar ciertos enfoques. <br><br>  Otra forma de trabajar con datos mutables es evitar el intercambio de datos.  Los actores son un modelo de programaci√≥n.  Los actores simplifican la programaci√≥n al no permitir el acceso simult√°neo a los datos.  Esto se logra por el hecho de que una funci√≥n que realiza trabajo en un momento puede funcionar en un solo hilo. <br><br>  Sin embargo, un actor puede cambiar el estado interno.  Dado que en el siguiente momento, el mismo actor puede ejecutarse en otro hilo, esto puede ser un problema.  El problema se puede resolver de diferentes maneras, en lenguajes de programaci√≥n como Erlang o Elixir, donde el modelo de actor es una parte integral del lenguaje, puede usar la recursi√≥n para llamar a un actor con un nuevo estado. <br><br>  En Java, las recursiones pueden ser demasiado caras.  Sin embargo, en Java existen marcos para un trabajo conveniente con este modelo, probablemente el m√°s popular es Akka.  Los desarrolladores de Akka se han ocupado de todo, puede ir a la secci√≥n de documentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Akka y el Modelo de memoria de Java</a> y leer sobre dos casos en los que el acceso a un estado compartido puede ocurrir desde diferentes hilos.  Pero lo m√°s importante, la documentaci√≥n dice qu√© eventos se relacionan con "sucedi√≥ antes".  Es decir  Esto significa que podemos cambiar el estado del actor tanto como queramos, pero cuando recibamos el siguiente mensaje y posiblemente lo procesemos en otro hilo, tenemos la garant√≠a de ver todos los cambios realizados en otro hilo. <br><br><h2>  ¬øPor qu√© es tan popular el modelo de subprocesamiento? </h2><br>  Examinamos dos modelos de programaci√≥n competitiva, de hecho, hay a√∫n m√°s de ellos que hacen que la programaci√≥n competitiva sea m√°s f√°cil y segura. <br><br>  Pero, ¬øpor qu√© los hilos y las cerraduras siguen siendo tan populares? <br><br>  Creo que la raz√≥n es la simplicidad del enfoque, por supuesto, por un lado, es f√°cil cometer muchos errores no obvios con las transmisiones, dispararse en el pie, etc.  Pero, por otro lado <b>, no hay nada complicado en los flujos, especialmente si no piensa en las consecuencias</b> . <br><br>  En un momento dado, el n√∫cleo puede ejecutar una instrucci√≥n (de hecho, hay paralelismo en el nivel de instrucci√≥n, pero ahora no importa), pero gracias a la multitarea, incluso en m√°quinas de un solo n√∫cleo, se pueden ejecutar varios programas simult√°neamente (por supuesto, pseudo simult√°neamente). <br><br>  Para que la multitarea funcione, necesita competencia.  Como ya hemos descubierto, la competencia es imposible sin varios flujos de gesti√≥n. <br><br>  ¬øCu√°ntos hilos cree usted que un programa que se ejecuta en un procesador de tel√©fono m√≥vil de cuatro n√∫cleos debe ser lo m√°s r√°pido y receptivo posible? <br><br>  Puede haber varias docenas.  Ahora la pregunta es, ¬øpor qu√© necesitamos tantos subprocesos para un programa que se ejecuta en hardware que le permite ejecutar solo 2-4 subprocesos a la vez? <br><br>  Para intentar responder a esta pregunta, suponga que solo nuestro programa se ejecuta en el dispositivo y nada m√°s.  ¬øC√≥mo gestionar√≠amos los recursos que nos proporcionan? <br><br>  Puede asignar un n√∫cleo para la interfaz de usuario, el resto del n√∫cleo para cualquier otra tarea.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si uno de los hilos est√° bloqueado, por ejemplo, el hilo puede acceder al controlador de memoria y esperar una respuesta, entonces obtendremos un n√∫cleo bloqueado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tecnolog√≠as hay para resolver el problema? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay hilos en Java, podemos crear muchos hilos, y luego otros hilos podr√°n realizar operaciones mientras algunos hilos est√°n bloqueados. Con una herramienta como hilos, podemos simplificar nuestras vidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El enfoque con subprocesos no es gratuito, la creaci√≥n de subprocesos generalmente lleva tiempo (se decide por grupos de subprocesos), se les asigna memoria, el cambio entre subprocesos es una operaci√≥n costosa. Pero es relativamente f√°cil de programar con ellos, por lo que esta es una tecnolog√≠a masiva que se usa ampliamente en lenguajes generales, como Java.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java generalmente ama las transmisiones, no es necesario crear para cada acci√≥n una transmisi√≥n, hay cosas de nivel superior, como Executors, que le permiten trabajar con grupos y escribir c√≥digo m√°s escalable y flexible. Las transmisiones son realmente convenientes, puede realizar una solicitud de bloqueo a la red y escribir el procesamiento de resultados en la siguiente l√≠nea. Incluso si esperamos unos segundos para obtener el resultado, a√∫n podemos realizar otras tareas, ya que el sistema operativo se encargar√° de la distribuci√≥n del tiempo del procesador entre los subprocesos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las transmisiones son populares no solo en el desarrollo de back-end, en el desarrollo m√≥vil se considera bastante normal crear docenas de transmisiones para que pueda bloquear una transmisi√≥n durante un par de segundos, esperando que los datos se descarguen a trav√©s de la red o los datos del socket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los lenguajes como Erlang o Clojure siguen siendo nicho y, por lo tanto, los modelos de programaci√≥n competitivos que utilizan no son tan populares. </font><font style="vertical-align: inherit;">Sin embargo, los pron√≥sticos para ellos son los m√°s optimistas.</font></font><br><br><h2>  Conclusiones </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si est√° desarrollando en la plataforma JVM, debe aceptar las reglas del juego indicadas por la plataforma. </font><font style="vertical-align: inherit;">La √∫nica forma de escribir c√≥digo multiproceso normal. </font><font style="vertical-align: inherit;">Es muy deseable comprender el contexto de todo lo que sucede, por lo que ser√° m√°s f√°cil aceptar las reglas del juego. </font><font style="vertical-align: inherit;">Es incluso mejor mirar a su alrededor y conocer otros paradigmas, aunque no puede llegar a ning√∫n lado desde el submarino, pero puede descubrir nuevos enfoques y herramientas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiales adicionales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trat√© de colocar en el texto del art√≠culo enlaces a fuentes de las cuales obtuve informaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, el material JMM es f√°cil de encontrar en Internet. </font><font style="vertical-align: inherit;">Aqu√≠ publicar√© enlaces a algunos materiales adicionales que est√°n asociados con JMM y que no pueden llamar mi atenci√≥n de inmediato. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lectura</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog de Alexey Shipilev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : s√© lo que es obvio, pero es un pecado sin mencionar</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El blog de Cheremin Ruslan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : no ha escrito activamente √∫ltimamente, debe buscar sus entradas antiguas en el blog, cr√©anme que vale la pena, hay una fuente</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : hay excelentes art√≠culos sobre subprocesos m√∫ltiples y el modelo de memoria</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El blog de Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est√° abandonado, pero las excavaciones arqueol√≥gicas deben llevarse a cabo. </font><font style="vertical-align: inherit;">En general, Roman hizo mucho para educar a la gente en la teor√≠a de la programaci√≥n multiproceso, b√∫squela en los medios.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de </font><b><font style="vertical-align: inherit;">podcasts</font></b><font style="vertical-align: inherit;"> que me parecieron particularmente interesantes. </font><font style="vertical-align: inherit;">No se trata de JMM, se trata del infierno, que est√° sucediendo en la gl√°ndula. </font><font style="vertical-align: inherit;">Pero despu√©s de escucharlos, quiero besar a los creadores de JMM, que nos han protegido de todo esto.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alexander Titov y Amir Ayupov, ingenieros de Intel y Alexei Markin, programador del ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Lejos Alexei Markin, Programador de ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 107 Historias de escaladores</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informe: agallas # 154 - Ataque de A√±o Nuevo</font></font></a> <br></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s de los discursos de las personas mencionadas anteriormente, preste atenci√≥n al video acad√©mico.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Science Center - Lecture 11. Modelos de memoria y problemas de visibilidad</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teor√≠a y pr√°ctica de la programaci√≥n multiproceso.</font></font></a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440590/">https://habr.com/ru/post/440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440576/index.html">Cambios importantes en CTE en PostgreSQL 12</a></li>
<li><a href="../440582/index.html">¬øSe arrastran los autos el√©ctricos al fondo de la corporaci√≥n automotriz?</a></li>
<li><a href="../440584/index.html">¬øQu√© le pasa a la Raspberry Pi?</a></li>
<li><a href="../440586/index.html">Consenso de Exonum: c√≥mo funciona</a></li>
<li><a href="../440588/index.html">MIT aprendi√≥ a transmitir sonido con un l√°ser</a></li>
<li><a href="../440592/index.html">Creando un juego AR con Vuforia</a></li>
<li><a href="../440594/index.html">1C y Yandex. Cloud Compute Cloud. Arriba y abajo</a></li>
<li><a href="../440596/index.html">Flightradar24: ¬øc√≥mo funciona?</a></li>
<li><a href="../440598/index.html">La sonda InSight Martian funciona con √©xito en el planeta rojo</a></li>
<li><a href="../440600/index.html">¬øCu√°ntos nombres de dominio .com no se usan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>