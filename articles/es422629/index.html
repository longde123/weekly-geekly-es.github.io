<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíª üöç ü¶é ¬°Deja de alimentar a los madereros! ¬°Da m√°s modificadores! Campos finales est√°ticos perezosos. Borrador de croquis de funciones üëåüèæ üë©üèø‚Äçüé§ üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es suficiente que en Java, los registradores se inicialicen en el momento en que se inicializa la clase, ¬øpor qu√© ensucian todo el lanzamiento? John R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬°Deja de alimentar a los madereros! ¬°Da m√°s modificadores! Campos finales est√°ticos perezosos. Borrador de croquis de funciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p>  Es suficiente que en Java, los registradores se inicialicen en el momento en que se inicializa la clase, ¬øpor qu√© ensucian todo el lanzamiento?  John Rose al rescate! </p><br><p>  As√≠ es como podr√≠a verse: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Este documento ampl√≠a el comportamiento de las variables finales, permiti√©ndole, opcionalmente, admitir la ejecuci√≥n diferida, tanto en el lenguaje como en la JVM.  Se propone mejorar el comportamiento de los mecanismos existentes de la computaci√≥n diferida cambiando la granularidad: ahora no ser√° precisa para la clase, sino precisa para una variable espec√≠fica. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  Motivaci√≥n </h1><br><p>  Java ha construido profundamente en computaci√≥n perezosa  Casi todas las operaciones de enlace pueden extraer c√≥digo diferido.  Por ejemplo, ejecutando el m√©todo <code>&lt;clinit&gt;</code> ( <code>&lt;clinit&gt;</code> del inicializador de clase) o utilizando el m√©todo bootstrap (para un sitio de llamada din√°mico invocado o constantes din√°micas <code>CONSTANT_Dynamic</code> ). </p><br><p>  Los inicializadores de clase son algo muy grosero en t√©rminos de granularidad en comparaci√≥n con los mecanismos que utilizan m√©todos de arranque, ya que su contrato es ejecutar <em>todo el</em> c√≥digo de inicializaci√≥n para la clase en su <em>conjunto</em> , en lugar de limitarse a la inicializaci√≥n relacionada con un campo espec√≠fico de la clase.  Los efectos de tal cruda inicializaci√≥n son dif√≠ciles de predecir.  Es dif√≠cil aislar los efectos secundarios del uso de <em>un</em> campo est√°tico de una clase, ya que calcular un campo lleva a calcular <em>todos los</em> campos est√°ticos de esta clase. </p><br><p>  Si toca un campo, los afectar√° a todos.  En los compiladores AOT, esto hace que sea particularmente dif√≠cil optimizar las referencias de campo est√°tico, incluso para campos con un valor constante f√°cilmente analizable.  Una vez que al menos <em>un</em> campo est√°tico redise√±ado est√° desordenado entre los campos, se hace imposible analizar completamente <em>todos los</em> campos de esta clase.  Un problema similar se manifiesta con los mecanismos propuestos anteriormente para implementar la convoluci√≥n de constantes (durante la operaci√≥n <em>javac</em> ) para campos constantes con inicializadores complejos. </p><br><p>  Un ejemplo de una inicializaci√≥n de campo redise√±ada, que ocurre en diferentes proyectos en cada paso, en cada archivo, es la inicializaci√≥n del registrador. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Esta inicializaci√≥n de aspecto inocuo lanza bajo el cap√≥ una gran cantidad de trabajo que se realizar√° durante la inicializaci√≥n de la clase, y, sin embargo, es extremadamente improbable que el registrador sea realmente necesario en el momento en que se inicializa la clase, o tal vez no sea necesario.  La capacidad de posponer su creaci√≥n hasta el primer uso real simplificar√° la inicializaci√≥n y, en algunos casos, ayudar√° a evitar esta inicializaci√≥n por completo. </p><br><p>  Las variables finales son muy √∫tiles, son el mecanismo principal de la API de Java para indicar la constancia de los valores.  Las variables perezosas tambi√©n funcionaron bien.  Comenzando con Java 7, comenzaron a desempe√±ar un papel cada vez m√°s importante en las <code>@Stable</code> internas del JDK, y se marcaron con la anotaci√≥n <code>@Stable</code> .  JIT puede optimizar las variables finales y estables, mucho mejor que solo algunas variables.  Agregar variables finales perezosas permitir√° que este patr√≥n de uso √∫til se vuelva m√°s com√∫n, lo que permitir√° su uso en m√°s lugares.  Finalmente, el uso de variables finales perezosas permitir√° que las bibliotecas como el JDK reduzcan la dependencia del c√≥digo <code>&lt;clinit&gt;</code> , lo que a su vez deber√≠a reducir el tiempo de inicio y mejorar la calidad de las optimizaciones AOT. </p><br><h1 id="opisanie">  Descripci√≥n </h1><br><p>  El campo se puede declarar con el nuevo modificador diferido, que es una palabra clave contextual que se percibe exclusivamente como un modificador.  Tal campo se llama <em>campo</em> perezoso y tambi√©n debe tener modificadores <code>static</code> y <code>final</code> . </p><br><p>  Un campo perezoso debe tener un inicializador.  El compilador y el tiempo de ejecuci√≥n acuerdan iniciar el inicializador exactamente cuando la variable se usa por primera vez, y no cuando se inicializa la clase a la que pertenece este campo. </p><br><p>  Cada campo <code>lazy static final</code> diferido se asocia en tiempo de compilaci√≥n con un elemento de agrupaci√≥n constante que representa su valor.  Dado que los elementos de la agrupaci√≥n constante se calculan perezosamente, es suficiente asignar simplemente el valor correcto para cada variable final perezosa est√°tica asociada con este elemento.  (Puede vincular m√°s de una variable diferida a un elemento, pero esta no es una caracter√≠stica √∫til o significativa). El nombre del atributo es <code>LazyValue</code> , y debe referirse a un elemento de g√©nero constante que puede codificarse con ldc en un valor que sea convertible a un tipo de campo diferido. .  Solo <code>MethodHandle.invoke</code> lanzamientos que ya se utilizan en <code>MethodHandle.invoke</code> . </p><br><p>  Por lo tanto, un campo est√°tico vago puede considerarse como un alias con nombre para un elemento de agrupaci√≥n constante dentro de la clase que declar√≥ este campo.  Herramientas como los compiladores de alguna manera pueden intentar usar este campo. </p><br><p>  Un campo diferido nunca es una variable constante (en el sentido de JLS 4.12.4) y se excluye expl√≠citamente de participar en expresiones constantes (en el sentido de JLS 15.28).  Por lo tanto, nunca captura el atributo <code>ConstantValue</code> , incluso si su inicializador es una expresi√≥n constante.  En cambio, el campo diferido captura un nuevo tipo de atributo de archivo de clase llamado <code>LazyValue</code> , que la JVM consulta cuando se vincula a este campo en particular.  El formato de este nuevo atributo es similar al anterior, ya que tambi√©n apunta a un elemento del grupo constante, en este caso, el que se resuelve en el valor del campo. </p><br><p>  Cuando se vincula un campo est√°tico diferido, el proceso normal de ejecuci√≥n de inicializadores de clase <em>no</em> debe desaparecer.  En cambio, cualquier m√©todo de declaraci√≥n de clase <code>&lt;clinit&gt;</code> se inicializa de acuerdo con las reglas definidas en JVMS 5.5.  En otras palabras, el bytecode <code>getstatic</code> para un campo est√°tico <code>getstatic</code> realiza la misma vinculaci√≥n que para <em>cualquier</em> campo est√°tico.  Despu√©s de la inicializaci√≥n (o durante la inicializaci√≥n ya iniciada del subproceso actual), la JVM resuelve los elementos de agrupaci√≥n constante asociados con el campo y almacena los valores obtenidos de la agrupaci√≥n constante en este campo. </p><br><p>  Dado que el final est√°tico diferido no puede estar vac√≠o, no se les puede asignar ning√∫n valor, incluso en los pocos contextos donde esto funciona para variables finales vac√≠as. </p><br><p>  Durante la compilaci√≥n, todos los campos est√°ticos diferidos se inicializan independientemente de los campos est√°ticos no diferidos, independientemente de su ubicaci√≥n en el c√≥digo fuente.  Por lo tanto, las restricciones sobre la ubicaci√≥n de los campos est√°ticos no se aplican a los campos est√°ticos diferidos.  El inicializador de campo est√°tico diferido puede usar cualquier campo est√°tico de la misma clase, independientemente del orden en que aparecen en la fuente.  El inicializador de cualquier campo no est√°tico o el inicializador de clase puede acceder al campo diferido, independientemente del orden en la fuente en el que est√©n relacionados entre s√≠.  Por lo general, hacer esto no es la idea m√°s sensata, ya que se pierde todo el significado de los valores perezosos, pero posiblemente se pueda usar de alguna manera en expresiones condicionales o en el flujo de control.  Por lo tanto, los campos est√°ticos diferidos pueden tratarse m√°s como campos de otra clase, en el sentido de que pueden referenciarse en cualquier orden desde cualquier parte de la clase en la que se declaran. </p><br><p>  Los campos perezosos se pueden detectar utilizando la API de reflexi√≥n utilizando dos nuevos m√©todos de API en <code>java.lang.reflect.Field</code> .  El nuevo m√©todo <code>isLazy</code> devuelve <code>true</code> si y solo si el campo tiene un modificador diferido.  El nuevo m√©todo <code>isAssigned</code> devuelve <code>false</code> si y solo si el campo es vago y a√∫n no se ha inicializado en el momento en que <code>isAssigned</code> .  (Puede volverse verdadero casi en la pr√≥xima llamada en el mismo hilo, dependiendo de la presencia de razas).  No hay forma de averiguar si se inicializa un campo, aparte de usar <code>isAssigned</code> . </p><br><p>  (La llamada <code>isAssigned</code> es necesaria para ayudar con problemas raros relacionados con la resoluci√≥n de dependencias circulares. Quiz√°s podamos hacerlo sin implementar este m√©todo. Sin embargo, las personas que escriben c√≥digo con variables perezosas a veces quieren saber si el valor est√° configurado para tal variable o no todav√≠a, de la misma manera que los usuarios de mutex a veces quieren averiguar a trav√©s de mutex si est√° bloqueado o no, pero realmente no quieren bloquearse) </p><br><p>  Hay una limitaci√≥n inusual en los campos finales diferidos: nunca deben inicializarse a sus valores predeterminados.  Es decir, el campo de referencia diferido no debe inicializarse como <code>null</code> , y los tipos num√©ricos no deben tener un valor nulo.  Un valor booleano diferido se puede inicializar con un solo valor: <code>true</code> , ya que <code>false</code> es su valor predeterminado.  Si el inicializador de un campo est√°tico diferido devuelve su valor predeterminado, la vinculaci√≥n de este campo fallar√° con el error correspondiente. </p><br><p>  Esta restricci√≥n se introduce para eso.  para permitir que las implementaciones de JVM reserven los valores predeterminados como un valor de vigilancia interno que marca el estado de un campo no inicializado.  El valor predeterminado ya est√° establecido en el valor inicial de cualquier campo, establecido en el momento de la preparaci√≥n (esto se describe en JLS 5.4.2).  Por lo tanto, este valor ya existe naturalmente al comienzo del ciclo de vida de cualquier campo y, por lo tanto, es una opci√≥n l√≥gica para usar como valor de vigilancia que supervisa el estado de este campo.  Con estas reglas, nunca puede obtener el valor predeterminado original de un campo est√°tico diferido.  Para esto, la JVM puede, por ejemplo, implementar un campo diferido como un enlace inmutable al elemento de agrupaci√≥n constante correspondiente. </p><br><p>  Las restricciones sobre los valores predeterminados se pueden eludir envolviendo los valores (que posiblemente sean iguales a los valores predeterminados) en cajas o contenedores de alg√∫n tipo conveniente.  Un n√∫mero cero se puede incluir en una referencia de entero distinto de cero.  Los tipos no primitivos se pueden ajustar en Opcional, que se vac√≠a si llega a nulo. </p><br><p>  Para mantener la libertad en las formas de implementar caracter√≠sticas, los requisitos para el m√©todo <code>isAssigned</code> subestiman especialmente.  Si la JVM puede probar que una variable est√°tica perezosa puede inicializarse sin efectos externos observables, puede hacer esta inicializaci√≥n en cualquier momento.  En este caso, <code>isAssigned</code> devolver√° <code>true</code> incluso si nunca se ha llamado a <code>getfield</code> .  El √∫nico requisito impuesto a <code>isAssigned</code> es que si devuelve <code>false</code> , ninguno de los efectos secundarios de la inicializaci√≥n de variables debe observarse en el hilo actual.  Y si volvi√≥ <code>true</code> , entonces el hilo actual puede observar en el futuro los efectos secundarios de la inicializaci√≥n.  Dicho contrato permite que el compilador reemplace <code>ldc</code> con <code>getstatic</code> para sus propios campos, lo que le permite a la JVM no monitorear estados detallados de variables finales que tienen elementos comunes o degenerados en el grupo constante. </p><br><p>  Varios hilos pueden entrar en un estado de carrera para inicializar un campo final perezoso.  Como ya sucede con <code>CONSTANT_Dynamic</code> , la JVM selecciona un ganador arbitrario de esta carrera y proporciona el valor de este ganador a todos los hilos que participan en la carrera, y lo escribe para todos los intentos posteriores de obtener un valor.  Para sortear la carrera, las implementaciones espec√≠ficas de JVM pueden intentar utilizar las operaciones CAS, si la plataforma las admite, el ganador de la carrera ver√° el valor predeterminado anterior y los perdedores ver√°n el valor no predeterminado que gan√≥ la carrera. </p><br><p>  Por lo tanto, las reglas existentes para la asignaci√≥n √∫nica de variables finales contin√∫an funcionando y ahora capturan todas las dificultades de la computaci√≥n diferida. </p><br><p>  La misma l√≥gica se aplica a la publicaci√≥n segura utilizando campos finales: es la misma para los campos diferidos y no diferidos. </p><br><p>  Tenga en cuenta que una clase puede convertir un campo est√°tico en un campo est√°tico lento sin romper la compatibilidad binaria.  La declaraci√≥n del cliente <code>getstatic</code> id√©ntica en ambos casos.  Cuando una declaraci√≥n variable cambia a perezosa, <code>getstatic</code> vincula de una manera diferente. </p><br><h1 id="alternativnye-resheniya">  Soluciones alternativas </h1><br><p>  Puede usar clases anidadas como contenedores para variables perezosas. </p><br><p>  Puede definir algo como una API de biblioteca para administrar valores diferidos o (m√°s generalmente) cualquier informaci√≥n mon√≥tona. </p><br><p>  Refactorice lo que iban a hacer variables est√°ticas perezosas para que se convirtieran en m√©todos est√°ticos nulos y sus cuerpos se publicaran usando constantes ldc CONSTANT_Dynamics, de alguna manera. </p><br><p>  (Nota: Las soluciones anteriores no proporcionan una forma binaria compatible para desacoplar evolutivamente las constantes est√°ticas existentes de su <code>&lt;clinit&gt;</code> ) </p><br><p>  Si hablamos de proporcionar <em>m√°s</em> funcionalidad, puede permitir que los campos diferidos sean no est√°ticos o no finales, mientras se mantienen las correspondencias y analog√≠as actuales entre el comportamiento de los campos est√°ticos y no est√°ticos.  Un grupo constante no puede ser un repositorio para campos no est√°ticos, pero a√∫n puede contener m√©todos de arranque (dependiendo de la instancia actual).  Las matrices congeladas (si se implementan) pueden obtener una opci√≥n perezosa.  Dichos estudios son una buena base para futuros proyectos construidos sobre la base de este documento.  Y, por cierto, tales oportunidades hacen que nuestra decisi√≥n de prohibir los valores por defecto sea a√∫n m√°s significativa. </p><br><p>  Las variables perezosas deben inicializarse usando sus propias expresiones de inicializaci√≥n.  A veces esto parece una limitaci√≥n muy desagradable que nos remite al momento de la invenci√≥n de las variables finales vac√≠as.  Recuerde que estas variables finales vac√≠as se pueden inicializar con bloques de c√≥digo arbitrarios, incluida la l√≥gica try-finally, y se pueden inicializar en grupos en lugar de simult√°neamente.  En el futuro, ser√° posible intentar aplicar las mismas posibilidades a las variables finales perezosas.  Quiz√°s una o m√°s variables perezosas pueden asociarse con un bloque privado de c√≥digo de inicializaci√≥n cuya tarea es asignar cada variable exactamente una vez, como sucede con un inicializador de clase o un constructor de objetos.  La arquitectura de tal caracter√≠stica puede volverse m√°s clara despu√©s de la aparici√≥n de los deconstructores, ya que las tareas que resuelven se cruzan en cierto sentido. </p><br><blockquote>  Minuto de publicidad.  La Conferencia Joker 2018 se llevar√° a cabo muy pronto, donde habr√° muchos especialistas destacados en Java y JVM.  Vea la lista completa de oradores e informes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> . </blockquote><br><h1 id="avtor">  El autor </h1><br><p>  <strong>John Rose</strong> es ingeniero y arquitecto de JVM en Oracle.  Ingeniero principal Da Vinci Machine Project (parte de OpenJDK).  El ingeniero principal JSR 292 (Soporta lenguajes de tipo din√°mico en la plataforma Java), se especializa en llamadas din√°micas y temas relacionados, tales como perfiles de tipo y optimizaciones avanzadas de compiladores.  Anteriormente, trabaj√≥ en clases internas, cre√≥ el puerto HotSpot original en SPARC, API insegura, y tambi√©n desarroll√≥ muchos lenguajes din√°micos, paralelos e h√≠bridos, incluidos Common Lisp, Scheme ("esh"), carpetas din√°micas para C ++. </p><br><h1 id="perevodchik">  Traductor </h1><br><p>  <strong>Oleg Chirukhin</strong> : en el momento de escribir este texto, trabajaba como administrador comunitario en la empresa JUG.ru Group, se dedica a la popularizaci√≥n de la plataforma Java.  Antes de unirse a JRG, particip√≥ en el desarrollo de sistemas de informaci√≥n bancaria y gubernamental, un ecosistema de lenguajes de programaci√≥n autoescritos y juegos en l√≠nea.  Los intereses de investigaci√≥n actuales incluyen m√°quinas virtuales, compiladores y lenguajes de programaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422629/">https://habr.com/ru/post/es422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422615/index.html">Toda la verdad sobre RTOS. Art√≠culo # 9. Programador: implementaci√≥n</a></li>
<li><a href="../es422617/index.html">Toda la verdad sobre RTOS. Art√≠culo # 8. Nucleus SE: dise√±o interno y despliegue</a></li>
<li><a href="../es422623/index.html">C√≥mo asegurar C</a></li>
<li><a href="../es422625/index.html">Hablamos con Troy Miles, el programador de "Neuromancer"</a></li>
<li><a href="../es422627/index.html">MongoDB y la investigaci√≥n de mercado de trabajo de TI</a></li>
<li><a href="../es422631/index.html">Terminales QIWI. C√≥mo aprovechar al m√°ximo las tecnolog√≠as simples</a></li>
<li><a href="../es422633/index.html">C√≥mo automatizamos el monitoreo del trabajo de los empleados de la red federal de estaciones de servicio</a></li>
<li><a href="../es422635/index.html">A√∫n no has dicho la palabra "hola" y ya sabemos a qui√©n</a></li>
<li><a href="../es422637/index.html">Regalo de geek: protecci√≥n autom√°tica</a></li>
<li><a href="../es422641/index.html">Noche polar, bombeo de agua y caja fuerte inteligente: 5 proyectos de estudiantes en el campo de IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>