<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 🗞️ 🤮 L'histoire émotionnelle des processeurs pour les premiers ordinateurs des années 70 au début des années 90 🥟 ⛪️ 👋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il m'est arrivé de programmer des assembleurs de différents processeurs. Le dernier sur la liste est Xilinx MicroBlaze. J'ai décidé de poster certaine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'histoire émotionnelle des processeurs pour les premiers ordinateurs des années 70 au début des années 90</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410591/">  Il m'est arrivé de programmer des assembleurs de différents processeurs.  Le dernier sur la liste est Xilinx MicroBlaze.  J'ai décidé de poster certaines de mes observations sur les caractéristiques de ces morceaux de fer presque magiques, qui, comme la clé magique de Pinocchio, nous ont ouvert des portes dans le pays magique de la réalité virtuelle et de la créativité de masse.  À propos des fonctionnalités des systèmes modernes x86, x86-64, ARM, ARM-64, etc.  Je n'écrirai pas, peut-être une autre fois - le sujet est très vaste et complexe.  Par conséquent, je prévois de terminer avec Intel 80486 et Motorola 68040. Je voulais également inclure l'IBM / 370 avec lequel j'avais affaire.  Ces systèmes étaient assez loin de la masse des utilisateurs, mais en même temps ont eu un impact énorme sur la technologie informatique.  Ils n'avaient tout simplement pas assez de temps alloué sur le sujet, ils n'utilisaient pas de puces de processeur, et pour une raison quelconque, ils semblaient complètement disparus.  J'espère vraiment que mes matériaux attireront l'attention des connaisseurs qui peuvent ajouter quelque chose auquel ils n'ont pas pensé ou qu'ils ne savaient pas. <br><br>  À titre d'illustration, j'attache ma petite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">pierre de Rosetta</a> - des programmes pour calculer le nombre π sur différents processeurs et systèmes en utilisant un algorithme d'obturation, prétendant être la plus rapide de ses implémentations. <br><br><a name="habracut"></a><br><h2>  Intel 8080 et 8085 </h2><br>  Premier véritable processeur sur puce, réalisé au premier semestre 1974, il est toujours en cours de fabrication et trouve son utilité.  Clonée de nombreuses fois dans le monde, en URSS, elle portait la désignation KR580VM80A.  Les processeurs Intel modernes pour PC révèlent encore facilement leur affinité pour ce produit relique dans un sens.  Je n'ai pas moi-même écrit de code pour ce processeur, mais étant familier avec l'architecture de z80, j'oserais apporter certains de mes commentaires. <br><br>  Le système d'instruction 8080, comme les autres processeurs Intel pour PC, peut difficilement être qualifié d'idéal, mais il est universel, assez flexible et possède plusieurs fonctionnalités très attrayantes.  Motorola 6800 et MOS Technology 6502, 8080 différaient favorablement de leurs concurrents dans un grand nombre de registres, quoique quelque peu maladroits, fournissant à l'utilisateur une batterie 8 bits A, un semi-accumulateur 16 bits et un registre d'index HL rapide à temps partiel, un pointeur de pile SP 16 bits , ainsi que deux autres registres Sun et DE 16 bits.  Les registres BC, DE et HL peuvent être utilisés comme registres à 6 octets.  De plus, le 8080 prend en charge un ensemble presque complet d'indicateurs d'état: report, signe, zéro, et même parité et semi-transfert.  Certaines des instructions du jeu d'instructions 8080 sont depuis longtemps des champions de la vitesse.  Par exemple, la commande XCHG échange le contenu des registres DE et HL 16 bits en seulement 4 cycles d'horloge - c'était exceptionnellement rapide!  Un certain nombre d'autres équipes, bien qu'elles n'aient pas établi de records aussi vifs, ont également été parmi les meilleures pendant longtemps: <br><br><ul><li>  XTHL - échange du contenu du registre HL et des données en haut de la pile, 18 cycles d'horloge - cela semble beaucoup, même sur un vrai 8086 16 bits, une telle commande prend 22 cycles d'horloge, et pour un 6800 ou 6502, une telle commande est encore difficile à imaginer; </li><li>  DAD - ajoute au semi-accumulateur HL la valeur d'un autre registre 16 bits (BC, DE ou même SP), 10 cycles d'horloge.  Il s'agit d'un véritable ajout 16 bits avec la définition du drapeau de report.  Si vous ajoutez HL avec vous-même, vous obtiendrez un décalage gauche rapide de 16 bits ou une multiplication par 2, une opération clé pour la multiplication et la division complètes; </li><li>  PUSH et POP - mettez sur la pile et supprimez de la pile la valeur 16 bits, respectivement, du registre ou dans le registre.  Effectué en 11 et 10 cycles.  Ce sont les opérations les plus rapides du 8080 pour le travail avec la mémoire et à leurs performances, il y a une incrémentation ou une décrémentation automatique de SP.  PUSH peut être utilisé, par exemple, pour remplir rapidement une mémoire avec un motif avec des valeurs de 3 registres (BC, DE, HL).  Il n'y a aucune commande pour travailler avec des quantités 8 bits avec une pile; </li><li>  LXI - chargement d'une constante de 16 bits dans le registre (HL, DE, BC, SP) pendant 10 cycles d'horloge; </li><li>  RNZ, RZ, RNC, RC, RPO, RPE, RP, RM - les retours conditionnels du sous-programme, ont permis de rendre le code plus propre, éliminant le besoin d'écrire des branches conditionnelles supplémentaires.  Ces équipes ont été abandonnées dans l'architecture x86, il est possible qu'en vain, le code avec lui se révèle plus agréable. </li></ul><br>  Ce processeur a été utilisé dans le premier ordinateur personnel Altair 8800, qui est devenu très populaire après la publication du magazine au début de 1975. Soit dit en passant, une publication similaire en URSS n'a eu lieu qu'en 1980, et sa pertinence correspondante qu'en 1986. <br><br><img src="https://img.newatlas.com/altair-8800-clone-0.jpg?auto=format%2Ccompress&amp;fit=max&amp;h=670&amp;q=60&amp;w=1000&amp;s=a0b62f09568803467c43a40736f5f4df" align="left"><br>  <i>Premier presque PC</i> <i><br></i> <br>  L'Intel 8080 est devenu la base du développement du premier système d'exploitation professionnel CP / M de masse, qui a dominé les micro-ordinateurs pour le travail professionnel jusqu'au milieu des années 1980. <br><br>  Maintenant sur les lacunes.  8080 nécessitait trois tensions d'alimentation -5, 5 et 12 volts.  Travailler avec des interruptions est gênant et lent.  Et en général, le 8080 n'est pas pressé, si on le compare avec les concurrents qui sont rapidement apparus.  Le 6502 pourrait être jusqu'à 3 fois plus rapide lorsqu'il fonctionne à la même fréquence que le 8080. <br><br>  Mais dans l'architecture de 8080, il s'est avéré être une vision correcte de l'avenir, à savoir ce fait inconnu dans les années 70 que les processeurs seront plus rapides que la mémoire.  Les registres 8080 DE et BC ressemblent plus à un prototype de caches manuels modernes qu'à des registres à usage général.  Le 8080 a commencé avec une fréquence de 2 MHz et ses concurrents avec seulement 1, ce qui a atténué la différence de performances. <br><br>  Il est difficile d'appeler le 8080 un processeur 8 bits à 100%.  Bien sûr, il a une ALU 8 bits, mais il existe de nombreuses instructions 16 bits qui sont plus rapides que d'utiliser uniquement des analogiques 8 bits.  Et pour certaines équipes, il n'y a pas du tout d'analogues 8 bits.  L'équipe XCHG en substance et les horaires sont 100% 16 bits.  Il existe de vrais registres 16 bits.  Par conséquent, j'ose appeler 8080 partiellement 16 bits.  Il serait intéressant de calculer l'indice de capacité du processeur à partir de la totalité des signes, mais à la connaissance de l'auteur, personne n'a encore fait un tel travail. <br><br>  L'auteur ne connaît pas la raison pour laquelle Intel a refusé le support direct pour le développement de PC 8 bits avec ses processeurs.  Intel s'est toujours distingué par la complexité et l'ambiguïté de la politique.  Son lien avec la politique, en particulier, est illustré par le fait que pendant longtemps Intel a exploité des usines en Israël et jusqu'à la fin des années 90, c'était secret.  Intel n'a pratiquement pas essayé d'améliorer le 8080, la fréquence d'horloge n'a été portée à 3 qu'avec un petit MHz.  En fait, le marché 8 bits a été transféré à Zilog avec un processeur 8080 z80 associé, qui a réussi à affronter avec succès le principal concurrent, le «terminateur» 6502. <br><br>  En URSS et en Russie, le clone domestique 8080 est devenu la base de nombreux ordinateurs de masse qui sont restés populaires jusqu'au début des années 90.  Il s'agit bien sûr de Radio-86RK, Mikrosh, Orion-128 multicolore, Vector et Corvette.  Cependant, les clones bon marché et améliorés basés sur zX Spectrum z80 ont vaincu la guerre des clones. <br><br><img src="https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531/"><br>  <i>Ceci est un vrai PC.</i> <br><br>  Au début de 1976, Intel a présenté le processeur 8085, compatible avec le 8080, mais bien supérieur à son prédécesseur.  Cela rendait déjà inutile l'alimentation de -5 et 12 volts et le schéma de connexion était simplifié, le travail avec les interruptions a été amélioré, la fréquence d'horloge a été utilisée de 3 à 6 MHz très solide, le système de commande a été étendu avec plusieurs instructions utiles: soustraction de 16 bits, décalage de 16 bits vers la droite en seulement 7 cycles (c'est très rapide), rotation de 16 bits vers la gauche à travers le drapeau de transfert, chargement d'un registre de 16 bits avec un décalage de 8 bits (cette commande peut également être utilisée avec le pointeur de pile SP), écrivez le registre HL à l'adresse dans le registre DE similaire à h  HL circule à travers DE.  Toutes les instructions ci-dessus, à l'exception du décalage vers la droite, sont effectuées en 10 cycles - c'est parfois beaucoup plus rapide que leurs homologues ou l'émulation sur z80.  Quelques instructions supplémentaires ont été ajoutées, et même deux nouveaux drapeaux.  Parmi les nouveaux indicateurs, il convient de noter l'indicateur de débordement, bien que son utilisation n'ait pratiquement pas été prise en charge.  De plus, de nombreuses instructions pour travailler avec des données d'octets ont été accélérées au rythme.  C'était très important, car sur de nombreux systèmes avec 8080 ou z80, des ticks de retard ont été introduits, ce qui, en raison de la présence de ticks supplémentaires sur le 8080, pouvait allonger le temps d'exécution presque deux fois.  Par exemple, dans un ordinateur domestique, les instructions vectorielles du type registre-registre ont été exécutées pendant 8 cycles d'horloge, et s'il y avait 8085 ou z80, alors ces mêmes instructions seraient exécutées en seulement 4 cycles d'horloge.  L'instruction XTHL est même deux étapes plus rapide.  Avec les nouvelles instructions, vous pouvez écrire du code pour copier le bloc de mémoire, ce qui est plus rapide que les commandes LDI / LDD du processeur Z80!  Cependant, certaines instructions, par exemple, incrémentation et décrémentation sur 16 bits, PUSH et retours conditionnels sont devenues plus lentes par horloge. <br><br>  Le 8085 a une prise en charge intégrée pour travailler avec des interruptions, ce qui dans de nombreux cas vous permet de vous passer d'un contrôleur d'interruption séparé dans le système et d'un port d'entrée / sortie série.  Comme déjà noté, en 8085, ils n'ont pas ajouté un support complet pour l'indicateur de débordement, donc l'arithmétique des nombres avec un signe est restée quelque peu incomplète. <br><br>  Cependant, je peux à nouveau répéter la formule «pour des raisons inconnues de l'auteur» Intel a refusé de promouvoir le 8085 comme processeur principal.  Ce n'est que dans les années 80 que plusieurs systèmes basés sur 8085 ont fait leur apparition. Le premier en 1981 était le prédécesseur et presque rival du PC IBM - IBM System / 23 Datamaster.  Puis en 1982, un ordinateur très rapide avec d'excellents graphismes Zenith Z-100 est sorti, dans lequel 8085 fonctionnait à 5 MHz.  En 1983, la société japonaise Kyotronic a créé une genouillère KC-85 très réussie, dont des variantes ont également été produites par d'autres sociétés: Tandy a produit le TRS-80 modèle 100, NEC - PC-8201a, Olivetti - M-10.  Au total, plus de 10 millions d'exemplaires de ces ordinateurs ont été publiés!  En URSS / RF au début des années 90, sur la base du clone domestique IM1821VM85A, il y a eu des tentatives d'amélioration de certains systèmes, par exemple l'ordinateur Vector.  Étonnamment, le processeur principal du rover Sojourner, qui a atteint la surface de Mars en 1997, était 8085 avec une fréquence de 2 MHz! <br><br>  En fait, Intel a donné au z80 une couleur verte.  Quelques années plus tard, dans la bataille pour le marché des 16 bits, Intel s'est comporté de manière complètement différente, engageant une action en justice pour interdire la vente de processeurs v20 et v30 aux États-Unis.  Fait intéressant, les processeurs mentionnés de la société japonaise NEC pourraient passer au mode de compatibilité binaire complète avec le 8080, ce qui en fait les processeurs les plus rapides de l'architecture 8080. <br><br>  Un autre secret d'Intel est le refus de publier un système de commande étendu, incluant la prise en charge de nouveaux drapeaux.  Cependant, l'un des fabricants officiels de ces processeurs a publié l'ensemble du système d'équipes.  Quelles sont les raisons d'un rejet aussi étrange?  On ne peut que deviner.  Peut-être que Zilog a ensuite joué un rôle similaire à celui qu'AMD a peut-être joué autrefois, et a créé l'apparence de la concurrence, et 8085 pourrait faire tomber Zilog?  Peut-être que le point est dans le désir de garder le système de commande plus proche du 8086 alors conçu?  Ce dernier semble douteux.  Intel 8086 est sorti plus de 2 ans après la sortie de 8085 et il est difficile de croire qu'en 1975 son système de commande était déjà connu.  Et dans tous les cas, la compatibilité avec les deux 8080 et 8085 à 8086 n'est réalisable qu'en utilisant un processeur macro, remplaçant parfois une commande 8080/8085 par plusieurs propres.  De plus, les deux nouvelles instructions publiées 8085 à 8086 ne sont pas du tout réalisables.  Il est particulièrement difficile d'expliquer pourquoi Intel n'a pas publié d'informations sur les nouvelles équipes après la sortie de 8086. Nous pouvons seulement supposer que c'était probablement une question de marketing.  Aggravant artificiellement les spécifications du 8085, nous avons obtenu un 8086 plus spectaculaire dans ce contexte. <br><br><h2>  Motorola 6800 et proches parents </h2><br>  Les processeurs Motorola se sont toujours distingués par la présence de plusieurs «points forts» très attrayants tout en présence de certaines solutions architecturales absurdes dans l'abstrait et peu pratiques.  Le principal «point fort» de tous les processeurs en question est la deuxième batterie de registres pleine et très rapide. <br><br>  Le 6800 a été le premier processeur au monde à ne nécessiter qu'une seule source d'alimentation (5 volts) - c'était une innovation très utile.  En raison de l'unicité du registre d'index 16 bits, qui est encombrant pour une architecture 8 bits, le Ho 6800 s'est avéré peu pratique pour la programmation et l'utilisation par le produit.  Il a été publié en 1974, pas beaucoup plus tard que 8080, mais n'est jamais devenu la base d'un système informatique bien connu.  Fait intéressant, les développeurs de 6502, Chuck Peddle et Bill Mensch, ont qualifié le 6800 de mauvais, "trop ​​gros".  Cependant, lui et ses variantes ont été largement utilisés comme microcontrôleurs.  Il convient peut-être de noter qu'Intel fabrique des processeurs depuis 1971, ce qui place Motorola dans une position de capture, pour laquelle le 6800 était le tout premier processeur.  Et si vous comparez le 6800 non pas avec le 8080, mais avec son prédécesseur 8008, le 6800 sera beaucoup plus préférable.  Motorola a presque rattrapé Intel avec 68000/20/30/40.  Vous remarquerez peut-être également que dans les années 70, Motorola était une entreprise beaucoup plus grande qu'Intel. <br><br>  De nombreuses variantes 6800 ont également été produites: 6801, 6802, 6803, 6805, ... La plupart d'entre elles sont des microcontrôleurs avec mémoire intégrée et ports d'entrée / sortie.  Le 6803 est un 6801 simplifié et a été utilisé très tard (1983) pour son ordinateur de classe Tandy TRS-80 MC-10 et son clone français Matra Alice, qui étaient comparables au Commodore VIC-20 (1980) ou au Sinclair ZX81 (1981).  Le système d'instructions 6801/6803 a été considérablement amélioré, des instructions 16 bits, la multiplication, ont été ajoutées ... Une instruction de branchement inconditionnelle inhabituelle (BRN - branche jamais) est apparue, qui n'est jamais exécutée!  Certaines instructions sont devenues un peu plus rapides. <br><br>  680x prend entièrement en charge le travail avec des entiers signés, z80 et 6502 le supportent moins bien, tandis que les 8080 et 8085 ne disposent presque pas d'un tel support.  Cependant, dans les logiciels 8 bits, une telle prise en charge était rarement nécessaire. <br><br>  6809 est sorti en 1978, alors que l'ère 16 bits avait déjà commencé avec 8086, et dispose d'un système de commande très développé, comprenant la multiplication de batteries de deux octets pour obtenir un résultat 16 bits en 11 cycles (à titre de comparaison, 8086 nécessite 70 cycles pour une opération similaire) .  Deux batteries peuvent dans plusieurs cas être regroupées en une seule 16 bits, ce qui donne des instructions rapides sur 16 bits.  6809 a deux registres d'index et un nombre record de méthodes d'adressage parmi les processeurs 8 bits - 12. Parmi les méthodes d'adressage, il existe des puces 8 bits uniques, telles que l'index avec incrémentation ou décrémentation automatique, par rapport au compteur d'instructions, l'index avec décalage.  Le 6809 a une opportunité intéressante d'utiliser deux types d'interruptions: vous pouvez utiliser des interruptions rapides avec sauvegarde de registre automatique partielle et des interruptions avec sauvegarde de registre complète - le 6809 a trois entrées pour les signaux d'interruption FIRQ (masquage rapide), IRQ (masquable), NMI (non masquable).  Il est également parfois pratique d'utiliser des instructions rapides pour lire et définir tous les indicateurs en même temps. <br><br>  Cependant, les opérations de mémoire nécessitent plus de 6502 cycles d'horloge. Les registres d'index sont restés des dinosaures maladroits de 16 bits dans un monde de 8 bits, certaines opérations sont tout simplement choquantes en raison de leur lenteur, par exemple, le transfert d'une batterie d'octets à une autre prend 6 cycles, et l'échange leur contenu est de 8 cycles (à comparer avec 8080, où un échange 16 bits a lieu en 4 cycles)!  Pour une raison quelconque, deux pointeurs de pile sont offerts immédiatement, peut-être que c'était l'influence de l'architecture de blocage VAX-11 - dans une architecture 8 bits avec 64 Ko de mémoire, cela semble très gênant.  Et même la présence d'une instruction avec le nom intéressant SEX ne peut pas résoudre tous les problèmes du 6809.  En général, le 6809 est toujours un peu plus rapide que le 6502 à la même fréquence, mais il nécessite la même vitesse de mémoire.  J'ai réussi à faire la division pour 6809 avec un dividende 32 bits et un diviseur 16 bits (32/16 = 32,16) pour un peu plus de 520 cycles, pour 6502 je ne pouvais pas réaliser moins de 650 cycles.  La deuxième batterie est un gros avantage, mais d'autres caractéristiques du 6502, en particulier le transfert inversé, ne réduisent cet avantage qu'aux 25% indiqués.  Mais la multiplication par une constante de 16 bits s'est avérée plus lente que celle de la table pour 6502 avec une table pour 768 octets.  6809 vous permet d'écrire des codes assez compacts et rapides en utilisant l'adressage de la page installée (page directe), mais cet adressage rend les codes assez confus.  L'essence de cet adressage est de définir l'octet haut de l'adresse de données dans un registre spécial et de ne spécifier que l'octet bas de l'adresse dans les commandes.  Le même système avec seulement une valeur d'octet élevée fixe est utilisé dans 6502, où il est appelé adressage de page zéro.  L'adressage de la page installée est un analogue direct de l'utilisation du registre de segment DS en x86 non seulement pour des segments de 64 Ko, mais pour des segments de seulement 256 octets.  Une autre architecture farfelue de 6800 est l'utilisation de l'ordre des octets de haut en bas (Big Endian), ce qui ralentit les opérations d'addition et de soustraction sur 16 bits.  Le 6809 n'est pas entièrement compatible avec les codes d'instructions 6800. Le 6809 était le dernier processeur 8 bits de Motorola; dans d'autres développements, il a été décidé d'utiliser à la place le 68008. <br><br>  On peut supposer que Motorola a dépensé beaucoup d'argent pour promouvoir le 6809. Cela est toujours vrai à la mention de ce processeur.  Vers 6809, il existe de nombreuses critiques favorables, qui diffèrent par certaines nébuleuses, généralisations et imprécisions.  Le 6809 a été positionné comme un super processeur basé sur un microprocesseur 8 bits.  Presque les systèmes d'exploitation Unix, OS-9 et UniFlex étaient même faits pour lui.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il a hurlé en tant que processeur principal de l'Apple Macintosh et, comme il ressort des films sur Steve Jobs, seule son intervention émotionnelle a déterminé la transition vers le 68000 le plus prometteur. Bien sûr, le 6809 est un bon processeur, mais en général il n'est que légèrement meilleur que ses concurrents apparus bien avant 6502. (trois ans plus tôt) et z80 (deux). On ne peut que deviner ce qui se passerait si Motorola consacrait au moins la moitié de ses efforts au développement et à la promotion du 6809 pour le développement du 6502.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6809 a été utilisé dans plusieurs systèmes informatiques assez connus. Le plus célèbre d'entre eux est l'ordinateur américain Tandy Color ou Tandy Coco, ainsi que leur clone britannique ou plutôt gallois Dragon-32/64. Les marchés informatiques des années 80 étaient caractérisés par une transparence importante et Tandy Coco n'était distribué qu'aux États-Unis, et Dragons, en plus du Royaume-Uni lui-même, a gagné en popularité en Espagne. En France, le 6809 est devenu pour une raison quelconque la base des ordinateurs de masse des années 80 de la série Thomson, qui est resté presque inconnu ailleurs qu'en France. Le 6809 a également été utilisé comme deuxième processeur dans au moins deux systèmes: dans la série Commodore SuperPET 9000 et dans le boîtier décodeur de petite taille et maintenant presque oublié pour l'interface TUBE des ordinateurs BBC Micro.Ce processeur était également utilisé dans d'autres systèmes moins connus de l'auteur, notamment japonais. Il a également gagné une certaine distribution dans le monde des consoles de jeux. Il convient de mentionner l'une de ces consoles, Vectrex, qui utilise une technologie unique - un affichage vectoriel.</font></font><br><br><img src="https://i.imgur.com/DOVW3CM.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color CoCo 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 680x a une instruction non documentée intéressante avec le nom intéressant "Halt and Catch Fire" (HCF), qui est utilisé pour les tests au niveau électronique, par exemple, avec un oscilloscope. Son utilisation provoque le gel du processeur, dont il n'est possible de sortir qu'en le redémarrant (reset). Ces processeurs ont également d'autres instructions non documentées. En 6800, il y a, par exemple, des instructions symétriques au chargement direct de la constante de registre, c'est-à-dire instructions pour décharger directement le registre à l'adresse suivant cette instruction!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le 8080, 8085 ou z80 6809, il est très difficile d'appeler purement 8 bits. Et le 6309 est même formellement difficile à appeler 8 bits, il a été produit par la société japonaise Toshiba (je n'ai pas pu trouver l'année exacte de sa production, mais il y a des données indiquant 1982) en tant que processeur entièrement compatible avec le 6809. Cependant, ce processeur pourrait être commuté dans le nouveau mode, qui, tout en conservant une compatibilité presque totale avec le 6809, offrait presque un ordre de grandeur de grandes opportunités. Ces fonctionnalités étaient cachées dans la documentation officielle, mais ont été publiées en 1988 sur le réseau Usenet. Deux batteries supplémentaires ont été ajoutées, mais les instructions avec elles sont beaucoup plus lentes qu'avec les deux premières. Le temps d'exécution de la plupart des instructions a été considérablement réduit. Ajout d'un certain nombre d'équipes,parmi lesquels la division symbolique d'un dividende de 32 bits par un diviseur de 16 bits (32/16 = 16.16) pour 34 cycles est tout simplement fantastique pour les processeurs de cette classe, et le diviseur est pris en mémoire. Il y avait aussi une multiplication de 16 bits avec un résultat de 32 bits pour 28 cycles d'horloge. Des instructions très utiles ont également été ajoutées pour copier rapidement des blocs de mémoire avec un temps d'exécution de 6 + 3n, où n est le nombre d'octets à copier, vous pouvez copier avec des adresses décroissantes ou croissantes. Les mêmes instructions peuvent être utilisées pour remplir rapidement la mémoire avec un octet donné. Une fois exécuté, des interruptions peuvent survenir. Il y a encore de nouvelles opérations au niveau du bit, un registre nul, etc. Des interruptions ont été ajoutées lors de l'exécution d'une instruction inconnue et lors de la division par 0. Dans un sens,6309 est le summum des avancées technologiques parmi les processeurs 8 bits, ou plutôt les processeurs avec une taille de mémoire adressable de 64 Ko.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 6309 est entièrement compatible avec les terminaux 6809, ce qui en fait une mise à niveau populaire pour les couleurs Tandy ou Dragons. </font><font style="vertical-align: inherit;">Il existe des versions spéciales du système d'exploitation utilisant les nouvelles fonctionnalités de 6309.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technologie MOS 6502 et WDC 65816 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un processeur au destin très dramatique. </font><font style="vertical-align: inherit;">Aucun autre processeur ne peut le comparer. </font><font style="vertical-align: inherit;">Son apparition et sa mise en œuvre ont été accompagnées d'événements et de conséquences à très grande échelle. </font><font style="vertical-align: inherit;">J'en énumérerai quelques-uns:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'affaiblissement du géant Motorola, dont les capacités dépassent depuis quelque temps les capacités d'Intel; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la destruction de la technologie MOS; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'arrêt du développement du 6502 et sa sortie stagnante avec peu ou pas de modernisation. </font></font></li></ul><br>  Tout a commencé avec le fait que Motorola, pour des raisons totalement inconnues, a refusé de soutenir l'initiative de jeunes ingénieurs qui ont proposé d'améliorer le processeur 6800 généralement médiocre. Ils ont dû quitter l'entreprise et poursuivre leur travail dans la petite mais prometteuse entreprise MOS Technology, où ils ont rapidement préparé deux processeurs. 6501 et 6502 fabriqués à l'aide de la technologie NMOS.  Le premier était compatible avec le 6800, mais sinon ils étaient identiques.  L'équipe 6501/6502 a réussi à introduire avec succès une nouvelle technologie de fabrication de puces, ce qui a radicalement réduit le coût des nouveaux processeurs.  En 1975, la technologie MOS pouvait offrir 6502 $ pour 25 $, tandis que le prix de départ pour Intel 8080 et Motorola 6800 était en 1974 360 $.  En 1975, Motorola et Intel ont baissé les prix, mais ils étaient encore proches de 100 $.  Les experts de MOS Technology ont affirmé que leur processeur était jusqu'à 4 fois plus rapide que le 6800. Cela me semble douteux: le 6502 peut fonctionner avec la mémoire beaucoup plus rapidement, mais la deuxième batterie 6800 a considérablement accéléré de nombreux calculs.  Je peux estimer que 6502 était en moyenne plus rapide que pas plus de 2 fois.  Motorola a intenté une action en justice contre ses anciens employés - ils auraient utilisé de nombreux secrets technologiques de l'entreprise.  Au cours du processus, il a été possible d'établir que l'un des ingénieurs qui ont quitté Motorola a délivré des documents confidentiels sur le 6800, agissant contrairement aux paramètres de leurs collègues.  On ne sait toujours pas s'il s'agissait de son propre acte ou de certaines forces directrices derrière lui.  Pour cette raison et d'autres raisons pas tout à fait claires, Motorola a forcé MOS Technology, dont les capacités financières étaient très petites, à payer un montant significatif de 200 000 $ et à abandonner la production de 6501. Intel dans une situation similaire avec Zilog n'a pas agi du tout.  Bien qu'il faut admettre que la technologie MOS était parfois trop risquée lorsqu'elle tentait d'utiliser les gros fonds dépensés par Motorola pour promouvoir le 6800 à ses propres fins. <br><br>  Plus loin dans l'histoire, la légendaire société Commodore et son fondateur tout aussi légendaire Jack Tramiel apparaissent, dans l'ombre de la figure du principal financier de la société qui détermine sa politique - un homme nommé Irving Gould.  Jack a reçu un prêt d'Irving et avec cet argent, en utilisant plusieurs, pour le dire doucement, des tactiques sans scrupules, ont forcé MOS Tecchnology à faire partie du Commodore.  Après quoi, peut-être contrairement aux souhaits de Tramel, qui a dû céder à Hood, le développement du 6502 s'est pratiquement arrêté et cela malgré le fait qu'en 1976, il était possible de produire des prototypes 6502 avec des fréquences de fonctionnement jusqu'à 10 MHz, bien qu'un message à ce sujet ne soit apparu qu'après de nombreuses années d'une personne nommé Bill Mensch (il faisait partie de l'équipe qui a quitté Motorola), qui a fait à plusieurs reprises des déclarations bruyantes mais largement vides et a joué un rôle assez ambigu dans le sort de 6502.  Le développeur en chef 6502 Chuck Peddle a été définitivement retiré du développement des processeurs.  6502 a continué à être produit non seulement chez Commodore, mais aussi dans la société créée par Bill Mensch, Western Design Center (WDC).  Il est curieux qu'aucune des précédentes équipes 6502 n'ait travaillé avec lui à l'avenir. <br><br>  Le drame autour de 6502 ne s'arrête pas là.  En 1980, un court article anonyme est paru dans le magazine AIM65 Interactive de Rockwell déclarant que tous les 6502 portaient un bug dangereux appelé JMP (xxFF).  Le ton de l'article suggère quelque chose de complètement hors de l'ordinaire.  Par la suite, cette attitude s'est déplacée vers la position d'Apple sur cette question et est devenue une sorte de courant dominant.  Bien qu'à proprement parler, il n'y ait pas eu de «bug».  Bien sûr, l'une des fonctionnalités, tout à fait appropriée et même utile parmi les microprocesseurs, peut sembler un bug ennuyeux pour un spécialiste qui s'est habitué aux processeurs confortables des grands systèmes de ces années.  Mais en fait, ce comportement, qui a blessé les sentiments de quelqu'un, a été décrit dans la documentation officielle de 1976 et dans les manuels de programmation parus avant la parution de l'article mentionné.  Le «bogue» a été éliminé par Bill Mensch, qui a fait du 6502 (CMOS 6502) vraisemblablement en 1983, c'est-à-dire après la sortie de 65816. Alors qu'Intel, Motorola et d'autres ont fabriqué des processeurs 16 bits de nouvelles générations, le 6502 n'a été amélioré que microscopiquement et rendu artificiellement partiellement incompatible avec lui-même.  En plus d'éliminer le «bug», un certain nombre de changements ont été apportés, ce qui, en particulier, a entraîné un changement lors de l'exécution de plusieurs instructions, qui est devenu plus lent par battement, mais en même temps dans un sens académique farfelu, ils sont devenus plus corrects.  Mais je dois admettre que plusieurs nouvelles instructions étaient attendues et utiles.  D'un autre côté, la grande majorité des nouvelles instructions n'occupaient que l'espace de code, n'ajoutant presque rien aux capacités du 6502, ce qui laissait moins de nouveaux codes pour d'éventuelles mises à niveau supplémentaires.  Commodore et le japonais Ricoh (fabricant des consoles de jeux NES les plus populaires) n'ont pas accepté ces changements.  L'auteur de ce matériel a lui-même rencontré à plusieurs reprises le problème de ce «bug».  Ne sachant rien de lui, il a écrit des programmes pour Commodore.  Il a ensuite transféré l'un d'entre eux vers des systèmes où un ensemble de commandes 6502 a été utilisé.  Une incompatibilité est apparue, j'ai dû changer les codes, faire une compilation conditionnelle.  Le code pour 6502 s'est avéré plus volumineux et plus lent.  Il a ensuite soulevé cette question sur le forum 6502.org, où la plupart des participants viennent du monde Apple.  J'ai demandé si quelqu'un pouvait donner un exemple lorsque le «bug» indiqué plantait le programme.  Je n'ai reçu que des commentaires émotifs et généraux, aucun exemple concret n'a été proposé. <br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png">  Bug !!! <br><br>  65C02 a été concédé sous licence à de nombreuses entreprises, en particulier NCR, GTE, Rockwell, Synertek et Sanyo.  Utilisé dans Apple II, à commencer par les modèles IIe, bien que de nombreux IIe aient utilisé NMOS 6502. La variante 65C02 6512 a également été utilisée dans les modèles BBC Micro ultérieurs.  Atari a utilisé NMOS 6502. En plus de CMOS 6502, Synertek et Rockwell ont également produit NMOS 6502. Soit dit en passant, NMOS 6502 a son propre ensemble d'instructions non documentées, dont la nature est complètement différente des commandes «secrètes» 8085. En 6502, ces instructions sont apparues comme un effet secondaire de la technologie utilisée, donc la plupart d'entre eux sont plutôt inutiles, mais plusieurs, par exemple, le chargement ou le déchargement de deux registres avec une seule commande à la fois et d'autres peuvent rendre le code plus rapide et plus compact. <br><br>  Il y a eu d'autres tentatives de mise à niveau du 6502. Toujours en 1979, un article est apparu que les ordinateurs Atari se préparaient à produire le processeur 6509 (à ne pas confondre avec un processeur du même nom de la société Commodore qui est apparu plus tard), qui devait accélérer l'exécution des commandes de 25% et de nombreux nouveaux instructions.  Mais pour des raisons inconnues de précision, la production de ce processeur n'a pas eu lieu.  Commodore n'a effectué que des mises à niveau microscopiques.  Là, ils sont notamment passés à la technologie HMOS et à la production de cœurs statiques, ce qui a permis de ralentir les processeurs.  Du point de vue de la programmation, le plus intéressant est le processeur 6509 qui, quoique sous une forme très primitive, à l'aide de seulement deux instructions spécialement allouées à cet effet, permet d'adresser jusqu'à 1 Mo de mémoire.  Dans les très populaires Commodore 64 et 128, il y avait des processeurs 6510/8510 et dans la série 264 moins réussie - 7501/8501.  Ces processeurs n'avaient que 6 et 7 ports de bits d'E / S intégrés, respectivement, tandis que le 7501/8501 ne prenait pas en charge les interruptions non masquables.  Rockwell a produit la variante 65C02 avec son jeu d'instructions pour les opérations 32 bits étendues (similaires aux instructions z80 bits), cependant, à ma connaissance, ces processeurs n'étaient pas utilisés dans les ordinateurs et ces instructions bits elles-mêmes étaient plus susceptibles d'être utilisées uniquement dans les systèmes embarqués.  Cette extension a d'ailleurs été produite par Bill Mensch. <br><br>  La dernière scène du drame avec la participation de 6502 a été indiquée dans la prévention des ordinateurs basés sur 6502 avec une fréquence de 2 MHz sur le marché américain dans la première moitié des années 80.  Cela a affecté l'étranger-anglais BBC Micro, leur société de production Acorn a fabriqué un grand lot d'ordinateurs pour les États-Unis, mais, en fin de compte, en vain.  Une sorte de serrure fonctionnait et les ordinateurs devaient être refaits d'urgence aux normes européennes.  Les ordinateurs semi-américains, mais officiellement canadiens, le Commodore CBM II (1982), malgré certains problèmes (en particulier, conformément aux normes pour les équipements électriques), étaient toujours autorisés.  Peut-être en raison du fait qu'ils n'avaient pas de modes graphiques et même de texte en couleur - même le design élégant de Porsche ne pouvait pas compenser cela.  Le dernier de la liste des perdants était l'Apple III 100% américain (1980) - on sait que Steve Jobs, comme la direction d'Apple en général, a fait beaucoup pour empêcher cet ordinateur d'avoir lieu.  Les emplois exigeaient des spécifications et une gestion clairement impossibles - des délais irréalistes.  Trouverons-nous jamais leurs motivations?  L'Apple III Plus, sorti en 1983, a réussi à éliminer les défauts de l'Apple III, mais la direction d'Apple a discrètement fermé le projet en 1984 en raison de sa réticence à concurrencer l'ordinateur Macintosh.  Ce n'est qu'en 1985, lorsque l'ère de la technologie 8 bits a commencé à sortir, que le Commodore 128 est apparu, qui pouvait utiliser 6502 dans l'un de ses modes avec une vitesse d'horloge de 2 MHz.  Mais ici aussi, cela s'est avéré plus comme une blague, car ce mode n'était pratiquement pas pris en charge et il n'y avait pratiquement aucun programme pour cela.  Ce n'est que dans la seconde moitié des années 80 qu'aux États-Unis a commencé à produire des consoles-accélérateurs pour Apple II, et depuis 1988 le modèle Apple IIc + avec un processeur à 4 MHz.  Pourquoi est-ce arrivé?  Peut-être parce que 6502 à 2 ou 3 MHz (et ceux-ci étaient déjà produits au tout début des années 80) sur un certain nombre de tâches et en particulier avec les jeux pouvaient concurrencer avec succès les systèmes basés sur Intel 8088 ou Motorola 68000. En 1991, Commodore Corporation a fermé Un projet intéressant, quoique tardif, C65 basé sur un processeur 4510 avec une fréquence de 3,54 MHz.  4510 - c'est le 6502 le plus rapide, fabriqué seulement en 1988, il a été réalisé enfin mentionné précédemment l'optimisation des cycles, ce qui a donné une augmentation de 25% de la vitesse.  Ainsi, le processeur en C65 est proche de la vitesse des systèmes avec 6502 à 4,5 MHz.  Étonnamment, ce 6502 le plus rapide avec un ensemble d'instructions étendu (dans certains détails, cette extension s'est avérée plus efficace que dans le 65816) n'a jamais été utilisé depuis. <br><br>  C128 et Apple III Plus avaient une unité de gestion de la mémoire (MMU), qui permettait d'utiliser plusieurs piles et zéro page, adressant plus de 64 Ko de mémoire, etc. En C128, la MMU était artificiellement ajustée pour fonctionner avec seulement 128 Ko de mémoire.  Pour BBC Micro, des consoles avec 6502 à 3 MHz (1984) et 4 MHz (1986) ont été produites. <br><br><img src="http://www.starringthecomputer.com/snapshots/jewel_of_the_nile_cbm_ii.jpg"><br>  <i>Anti-publicité - plusieurs PET Porsche dans l'appartement du méchant de la Perle du Nil (1985) - l'ère Apple uniquement à Hollywood n'est pas encore arrivée</i> <br><br>  Maintenant, quelques mots sur le système d'instructions 6502. La principale caractéristique de ce processeur est qu'il a été rendu presque aussi rapide que possible, avec pratiquement aucun cycle d'horloge supplémentaire, qui sont particulièrement nombreux dans les processeurs 8080/8085 / z80 / 8088/68000.  En fait, c'est l'idéologie des processeurs d'architecture 6502 RISC qui est apparue plus tard et sous l'influence directe.  La même idéologie domine, à commencer par 80486, et parmi les processeurs Intel.  De plus, le 6502 a réagi le plus rapidement possible aux interruptions, ce qui l'a rendu très utile dans certains systèmes embarqués.  Le 6502 a une batterie et deux registres d'index, en outre, les 256 premiers octets de mémoire peuvent être utilisés dans des commandes spéciales soit comme mémoire plus rapide soit comme un ensemble de registres 16 bits (qui sont presque identiques dans leur fonctionnalité aux registres BC et DE en 8080 / z80) pour méthodes d'adressage assez puissantes.  Certaines instructions arithmétiques (décalages, rotation, incrémentation et décrémentation) peuvent être utilisées directement avec la mémoire, sans utiliser de registres.  Il n'y a pas d'instructions 16 bits - c'est un processeur 100% 8 bits.  Tous les principaux drapeaux sont pris en charge, à l'exception de l'architecture de drapeau de parité Intel caractéristique.  Il y a quelques drapeaux plus inhabituels du 10ème mode inutile.  Les processeurs Intel et Motorola utilisent des instructions correctives spéciales pour travailler avec des nombres décimaux, et le 6502 peut passer en mode 10e, ce qui rend son avantage de vitesse avec 10 nombres encore plus important qu'avec les nombres binaires.  Il est très impressionnant que pour 6502 multiplication de table d'opérandes 8 bits avec obtention d'un résultat 16 bits en moins de 30 cycles d'horloge, avec la taille de la table auxiliaire en 2048 octets.  Lentement, 6502 produit des opérations de copie de masse de la mémoire - à partir de 14 cycles d'horloge par octet. <br><br>  Le 6502 peut fonctionner en parallèle avec un autre appareil, par exemple un autre 6502. Pour autant que je sache, de tels systèmes à double processeur n'ont jamais été produits.  Au lieu du deuxième processeur, un contrôleur vidéo était généralement utilisé, qui partageait la mémoire avec 6502. <br><br>  65816 a été publié par WDC en 1983. Fait intéressant, Bill Mensch a reçu d'Apple les spécifications du nouveau processeur.  Bien sûr, ce fut un grand pas en avant, mais manifestement tardif et avec de grands défauts architecturaux.  Le 65816 n'était considéré par personne comme un concurrent pour les principaux processeurs Intel ou Motorola - il était déjà un outsider secondaire, qui avait déjà été programmé pour provoquer une nouvelle perte de position.  Le 65816 avait deux avantages importants - il était relativement bon marché et presque compatible avec le 6502 encore très populaire. Au cours des années suivantes, Bill Mensch n'a même pas essayé d'améliorer en quelque sorte son idée originale, d'optimiser la boucle, de remplacer l'adresse de la page zéro par l'adresse étendue en utilisant le registre Z ( cela a été fait en 4510), pour ajouter au moins la multiplication, ... WDC n'a augmenté que les fréquences d'horloge maximales, atteignant le milieu des années 90 à 14 MHz (un tel processeur a été utilisé dans l'accélérateur populaire pour C64 SuperCPU à une fréquence de 20 MHz).  Cependant, même maintenant (2019!) WDC propose 65816 pour une raison quelconque uniquement sur les mêmes 14 MHz.  Le 65816 peut utiliser jusqu'à 16 Mo de mémoire, mais les méthodes d'adressage utilisées pour cela semblent loin d'être optimales.  Par exemple, les registres d'index ne peuvent être que de 8 ou 16 bits, la pile ne peut être placée que dans les 64 premiers Ko de mémoire, uniquement là vous pouvez utiliser l'adressage court pratique de la page installée (page directe - généralisation de zéro page), travailler avec une mémoire supérieure à 64 Ko relativement maladroit, ... 65816 a une ALU 16 bits mais un bus de données 8 bits, donc dans les opérations arithmétiques, il est seulement environ 50% plus rapide que 6502. Néanmoins, 65816 a été publié pour un montant supérieur à un milliard.  Bien sûr, un certain nombre d'instructions 65816 complètent clairement les lacunes de l'architecture 6502, par exemple, des instructions pour la mémoire de copie de masse pour 7 cycles d'horloge par octet.  Vous pouvez également ajouter que 65816 utilise presque tous les codes d'instructions (255 sur 256).  Le dernier code inutilisé est destiné à de longues instructions futures qui ne sont jamais apparues. <br><br>  Apple IIx, dans le développement duquel Steve Wozniak a pris une part active, était censé utiliser le 65816, mais il n'a été possible d'établir la production de ce processeur qu'en 1984 et les premiers lots de 65816 étaient défectueux, ce qui a entraîné des retards excessifs et, par conséquent, clôturé l'ensemble du projet. <br><br>  Il existe également une option 65816 65802, qui utilise un bus d'adresse 16 bits et est compatible avec les connecteurs 6502. Des mises à niveau pour Apple II ont été proposées sur la base de ce processeur, mais une légère accélération avec une telle mise à niveau ne peut être obtenue que sur des programmes spécialement écrits pour lui. <br><br>  Le 6502 était utilisé dans un grand nombre de systèmes informatiques, dont les plus populaires sont Commodore 8 bits, Atari, Apple, NES.  Fait intéressant, le 6502 a été utilisé comme contrôleur de clavier dans l'ordinateur Commodore Amiga, et deux 6502 à 10 MHz ont été utilisés dans le Apple Macintosh IIfx haute performance.  Ici, on ne peut que mentionner les consoles de jeux Atari, fabriquées de 1977 à 1996, - elles ont été vendues à environ 35 millions!  Le 65816 a été utilisé dans l'ordinateur Apple IIgs plutôt populaire, dans la console de jeu Super NES, ainsi que dans le rare ordinateur anglais Acorn Communicator. <br><br>  En 1984, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> sur une mauvaise copie de l'ordinateur Apple] [réalisé en URSS] est apparu dans le magazine Byte sur fond d'images avec des bannières rouges, Lénine et des soldats en marche.  Cet article a cité un prix intéressant pour cet ordinateur - 17000 $ (c'est un chiffre absurde, le prix réel était d'environ 4000 roubles) et a ironiquement souligné que les fabricants soviétiques devraient baisser considérablement le prix s'ils voulaient vendre leur produit en Occident.  L'agate était principalement utilisée dans l'enseignement scolaire.  Les anciens modèles Agate étaient presque 100% compatibles avec Apple] [et avaient quelques extensions assez utiles. <br><br>  Vous ne pouvez qu'essayer de fantasmer sur ce qui se passerait si 6502 pouvait se développer au même rythme que ses concurrents.  Il me semble que le transfert progressif de la mémoire zéro page dans les registres et l'expansion progressive du système d'instruction avec l'optimisation simultanée des cycles permettraient au 6502 «terminator» de rester en tête en termes de vitesse jusqu'au début des années 90.  L'introduction du mode 16 puis 32 bits permettrait d'utiliser de grandes quantités de mémoire et des commandes plus rapides.  Ses concurrents pouvaient-ils s'opposer? <br><br>  Je voudrais terminer par quelques considérations philosophiques générales.  Pourquoi le 6502 a-t-il été freiné et dépourvu d'un avenir beaucoup plus radieux?  Peut-être en raison du fait qu'il pourrait vraiment faire pression sur les grandes entreprises et créer une réalité complètement nouvelle.  Mais l'équipe 6502 a-t-elle été mise en place pour cela?  Au contraire, ils voulaient juste faire un meilleur processeur. <br><br>  Déjà bien plus tard, au début du 21e siècle, à la suite de poursuites imposées par des raisons farfelues, la société Lexra, qui a produit divers processeurs innovants pendant 5 ans, a été vaincue.  Cette triste histoire rappelle quelque peu ce qui s'est passé avec la technologie MOS. <br><br><h2>  Zilog z80 </h2><br>  Ce processeur, avec 6502, est devenu le processeur principal des premiers ordinateurs personnels.  Il n'y a pas d'événements dramatiques dans l'histoire de son apparition et de son utilisation.  Il n'y a qu'une intrigue dans l'échec de Zilog à créer la prochaine génération de processeurs.  La Z80 a commencé à produire en 1976 et ses variantes sont toujours en cours de production.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois, même Bill Gates lui-même a annoncé la prise en charge des systèmes basés sur z80. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un certain nombre de coïncidences sont intéressantes. Comme dans le cas de 6502, le développeur principal de Z80, Federico Faggin (Federico Faggin), a quitté la grande entreprise, d'Intel. Après avoir travaillé sur le z80, Federico n'a presque pas travaillé avec le processeur de nouvelle génération Z8000 et au début des années 80, il a quitté son entreprise, de sorte qu'il ne traiterait plus jamais avec des processeurs à l'avenir. Il a ensuite créé plusieurs startups relativement prospères, créant des systèmes de communication, des pavés tactiles et des appareils photo numériques. Vous pouvez mentionner qu'en plus du z80, il a également développé dans Zilog le microcontrôleur Z8, qui a réussi et qui est toujours produit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Z80 est un processeur plus pratique à intégrer dans les systèmes informatiques que le 8080. Il ne nécessite qu'une seule tension d'alimentation et prend en charge la régénération dynamique de la mémoire. De plus, avec une compatibilité totale avec le 8080, il a pas mal de nouvelles commandes, un deuxième ensemble de registres principaux et plusieurs registres complètement nouveaux. Il est curieux que Zilog ait refusé d'utiliser les mnémoniques de l'assembleur 8080, et a commencé à utiliser leurs propres mnémoniques, qui conviennent mieux au système de commande étendu z80. Une histoire similaire s'est produite avec l'assembleur Intel x86 dans le monde des logiciels GNU, pour une raison quelconque, ils utilisent également leurs propres conventions pour écrire des programmes dans l'assembleur par défaut. Le Z80 a ajouté la prise en charge de l'indicateur de débordement, Intel n'a ajouté la prise en charge d'un tel indicateur qu'en 8086. Cependant,Ce drapeau dans z80 a été combiné avec le drapeau de parité, donc en même temps, comme dans 8086, les deux drapeaux ne peuvent pas être utilisés. En z80, comme en 6502, il n'y a qu'une vérification de base de la valeur d'un indicateur, c'est-à-dire il n'y a pas de contrôles de deux ou trois drapeaux à la fois, ce qui est nécessaire pour les comparaisons de «strictement supérieur», «inférieur ou égal à», ainsi que tous les plus importants - dans de tels cas, vous devez effectuer plusieurs contrôles, un sur 8086, 6800 ou PDP-11 est suffisant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les nouvelles instructions z80, les instructions pour la mémoire de copie de masse pour 21 cycles par octet, ainsi que la commande intéressante de recherche d'octets en mémoire, sont particulièrement impressionnantes. </font><font style="vertical-align: inherit;">Cependant, la plus intéressante est la commande EXX, qui échange le contenu de 48 octets de mémoire de registre, les registres BC, DE, HL avec leurs doubles, qui s'exécute en seulement 4 cycles! </font><font style="vertical-align: inherit;">Même un ARM 32 bits aura besoin d'au moins 6 cycles d'horloge pour la même opération. </font><font style="vertical-align: inherit;">Le reste des instructions supplémentaires ne sont pas aussi impressionnantes, bien qu'elles puissent parfois être utiles. </font><font style="vertical-align: inherit;">Plus ajouté:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Soustraction 16 bits avec prêt et addition 16 bits avec transfert sur 15 cycles; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> moins unaire pour la batterie pendant 8 ticks; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la capacité de lire et d'écrire à partir de la mémoire en utilisant les registres BC, DE, SP, IX, IY et pas seulement HL; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décalages, rotations et entrées-sorties pour tous les registres 8 bits; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opérations de vérification, de réglage et de réinitialisation d'un bit par son numéro; </font></font></li><li>    (JR); </li><li>  . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des nouvelles commandes sont plutôt lentes, mais leur utilisation correcte peut quand même rendre le code un peu plus rapide et nettement plus compact. Cela est particulièrement vrai pour l'utilisation des nouveaux registres 16 bits IX et IY, qui peuvent être utilisés pour de nouvelles méthodes d'adressage. Fait intéressant, les registres d'index IX et IY sont apparus dans le Z80 afin d'attirer 6800 utilisateurs vers la transition vers le Z80! Mais j'ose exprimer mon opinion, les opérations avec les registres d'index Z80 ont été faites en vain en raison de la présence d'un décalage d'octet presque inutile dans les commandes utilisant ces registres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup d'équipes 8080 dans le z80 ont obtenu un rythme plus rapide et c'est une accélération très perceptible. Mais la commande ADD, de base pour l'arithmétique 16 bits, est devenue plus lente par cycle, ce qui rend l'arithmétique en général, si elle est plus rapide, seulement un peu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système de travail avec les interruptions est devenu beaucoup plus intéressant que celui du 8080. Avec le z80, vous pouvez utiliser à la fois des interruptions non masquables et trois méthodes (l'une d'elles est compatible avec 8080) pour travailler avec celles masquées. Le mode le plus intéressant d'interruption masquée 2, qui vous permet de modifier avec souplesse l'adresse du code pour gérer l'interruption. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Z80 a beaucoup d'instructions non documentées, beaucoup de ces instructions ont disparu lors du passage à la technologie CMOS, mais celles qui ont survécu sont devenues pratiquement standard et ont été documentées par certaines entreprises. Des instructions particulièrement utiles vous permettent de travailler avec des octets individuels de registres IX et IY 16 bits maladroits. En plus des instructions non documentées, le Z80 possède d'autres propriétés non documentées, par exemple, deux drapeaux spéciaux dans le registre d'état.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, le z80 est encore plus que le 8080 a le droit d'être appelé légèrement 16 bits. L'indice de capacité numérique hypothétique pour z80 est clairement un peu plus élevé, mais il est paradoxal que l'ALU pour z80 soit en fait 4 bits! Au niveau électronique, les z80 et 8080 sont des puces complètement différentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup a été écrit sur la comparaison des performances des z80 et 6502, car ces processeurs étaient très largement utilisés dans les premiers ordinateurs de masse. Il y a plusieurs moments difficiles dans ce sujet, sans lesquels il est très difficile de maintenir l'objectivité. En raison de la présence d'un nombre assez important de registres z80, il est naturel d'utiliser à une fréquence plus élevée que la mémoire fonctionne. Par conséquent, le z80 à 4 MHz peut utiliser la même mémoire que le 6502 ou 6809 à 1,3 MHz. Selon de nombreux programmeurs expérimentés qui ont écrit des codes pour les deux processeurs, à la même fréquence 6502, en moyenne, de 2,4 à 2,6 fois plus rapide que z80. L'auteur de ce document est d'accord avec cela. Il vous suffit d'ajouter que l'écriture de bons codes rapides pour le z80 est très difficile, vous devez constamment optimiser l'utilisation des registres et utiliser la pile pour travailler avec la mémoire autant que possible.Si vous essayez fort, à mon avis, vous pouvez réduire la différence entre z80 et 6502 à environ 2,2 fois. Et si vous n'essayez pas d'ignorer les horaires, vous pouvez facilement obtenir la différence jusqu'à 4 fois. Dans certains cas individuels, le z80 peut afficher des performances très rapides. En ce qui concerne le remplissage de la mémoire, le z80, à l'aide de la commande PUSH, peut même être un peu plus rapide que 6502, mais cela se fait au prix d'interdire les interruptions. Lors de la copie de blocs de mémoire, le z80 n'est que 1,5 fois plus lent. Il est particulièrement impressionnant qu'en divisant un 32 bits divisible par un diviseur 16, le z80 n'est que 1,7 fois plus lent. Soit dit en passant, un tel super-partage a été mis en œuvre par un programmeur russe. Ainsi, nous obtenons que le ZX Spectrum avec z80 à 3,5 MHz est environ une fois et demie plus rapide que C64 à partir de 6502 à 1 MHz. Il faut notercette partie des cycles d'horloge dans la plupart des systèmes avec z80 ou 6502 est éloignée du processeur par des schémas de prise en charge du signal vidéo, par exemple, pour cette raison, pour les ordinateurs Amstrad CPC / PCW populaires, la fréquence réelle du processeur est de 3,2 MHz, et non pas la totalité 4. Dans les systèmes 6502, vous pouvez généralement désactiver l'écran pour des performances maximales du processeur. Si nous prenons la fréquence de la mémoire, plutôt que celle du processeur, comme base, il s'avère que le z80 est 25-40% plus rapide que 6502. Le dernier résultat peut être illustré par le fait qu'avec une mémoire avec une fréquence de 2 MHz, le z80 peut fonctionner à une fréquence allant jusqu'à 6 MHz, et 6502 uniquement jusqu'à 2 MHz.Si nous prenons la fréquence de la mémoire, plutôt que celle du processeur, comme base, il s'avère que le z80 est 25-40% plus rapide que 6502. Le dernier résultat peut être illustré par le fait qu'avec une mémoire avec une fréquence de 2 MHz le z80 peut fonctionner à une fréquence allant jusqu'à 6 MHz, et 6502 uniquement jusqu'à 2 MHz.Si nous prenons la fréquence de la mémoire, plutôt que celle du processeur, comme base, il s'avère que le z80 est 25-40% plus rapide que 6502. Le dernier résultat peut être illustré par le fait qu'avec une mémoire avec une fréquence de 2 MHz le z80 peut fonctionner à une fréquence allant jusqu'à 6 MHz, et 6502 uniquement jusqu'à 2 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Z80 était utilisé dans un très grand nombre de systèmes informatiques. Les Tandy TRS-80 étaient très populaires aux États-Unis, ZX Spectrum en Europe, puis Amstrad CPC et PCW. Il est curieux de constater que les ordinateurs Amstrad PCW sont restés pertinents jusqu'au milieu des années 90 et ont été massivement et activement utilisés conformément à leur destination jusqu'à la fin des années 90. Au Japon et dans d'autres pays, ils ont produit des ordinateurs MSX assez performants dans le monde entier. Le C128 plutôt populaire pourrait également utiliser le z80, mais ici les utilisateurs étaient plus susceptibles d'être gênés - cette version de 1985, un ordinateur z80 8 bits, officiellement cadencé à 2 MHz, ne fonctionne vraiment qu'à 1,6 MHz. C'est encore plus lent que les premiers systèmes des années 8080 du milieu des années 70. La gamme d'ordinateurs pour l'utilisation du système d'exploitation CP / M comprend au moins trois douzaines de systèmes assez connus.</font></font><br><br><img src="http://www.old-computers.com/museum/photos/Amstrad_9512_Running_s1.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tel PC avait l'air décent même au milieu des années 90, mais son z80 est plus lent que celui du spectre ZX.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le système informatique basé sur z80 le plus rapide connu de l'auteur est le BBC Micro avec un décodeur TUBE avec z80B à 6 MHz, fabriqué depuis 1984. Le processeur en Ce système fonctionne à pleine vitesse, comme on dit, «sans freins». Des consoles similaires ont été fabriquées pour Apple] [depuis 1979. Plus tard, certaines de ces consoles utilisaient le Z80H à 8 MHz et même plus. Fait intéressant, en 1980, Microsoft a tiré le plus gros profit de la vente de ces consoles. On peut également citer l'Amstrad PCW16, fabriqué depuis 1994, qui utilisait le CMOS Z80 à une fréquence de 16 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au Japon, le R800 compatible avec le z80 a été fabriqué pour les systèmes MSX TurboR (1990). Une multiplication matérielle 16 bits avec un résultat 32 bits a été ajoutée au R800. Bien que multipliée par une constante de 16 bits, la multiplication de table avec une table de 768 octets est obtenue par une horloge plus rapide. Il y a une opinion que le R800 est un Z800 très simplifié fonctionnant à une fréquence quatre fois supérieure à la fréquence du bus, qui est d'environ 7,16 MHz. Ainsi, la fréquence interne du R800 est d'environ 28,64 MHz!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zilog lui-même a travaillé pour améliorer le Z80 de manière très incohérente et extrêmement lente. Les premiers Z80 fonctionnaient à des fréquences allant jusqu'à 2,5 MHz, et le Z80A, qui est apparu peu de temps après, a augmenté la fréquence maximale à 4 MHz - ces processeurs sont devenus la base des ordinateurs les plus populaires utilisant le Z80. Le Z80B est apparu en 1980, mais a été utilisé relativement rarement, par exemple, dans la console BBC Micro mentionnée ou à la fin (1989) de l'ordinateur Sam Coupé. Le Z80H est apparu au milieu des années 80 et pouvait fonctionner à des fréquences allant jusqu'à 8 MHz - il n'était pas utilisé dans les ordinateurs bien connus. Il est intéressant de noter que les produits Zilog avaient des pièges spéciaux sur la puce pour ceux qui ont essayé d'en faire des copies, par exemple, la base Z80 avait 9 pièges et, selon les critiques de ceux qui l'ont fait, ils ont ralenti le processus de copie pendant près d'un an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mise à niveau plus approfondie du z80 a été entravée par le désir de Zilog de créer des processeurs qui rivalisent avec les processeurs 16 bits d'Intel. En 1978, un peu plus tard, 8086 sortait le Z8000, non compatible avec le z80. Ce processeur n'a pas pu résister aux concurrents d'Intel, et en particulier de Motorola - le 68000 a dépassé le Z8000 à presque tous les égards, bien que le Z8000 ait été utilisé dans une douzaine de systèmes différents et peu coûteux, généralement pour travailler avec des variantes Unix. Fait intéressant, IBM n'a même pas considéré le Z8000 comme un processeur possible pour le PC IBM, car Zilog était financé par Exxon, qui allait rivaliser avec IBM. Peut-être en raison de l'échec du Z8000, Zilog est devenu une division d'Exxon en 1980. Il y a également eu une tentative de création d'un processeur 32 bits compétitif. En 1986, le Z80000 est apparu, compatible avec le Z8000, qui n'est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulle part ailleurs.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et n'a pas trouvé d'application. Certaines circonstances, en particulier les plaintes très étranges de l’équipe Zilog concernant un financement excessif, suggèrent que Zilog, pour une raison peu claire, a peut-être plutôt saboté son travail dans le cadre d'Exxon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On ne peut que se demander pourquoi Zilog a abandonné son approche, qui a montré des résultats très réussis avec le Z80, à savoir, rendre les processeurs compatibles par programmation avec les processeurs Intel, mais leurs meilleurs et en même temps sont complètement différents au niveau matériel. Par la suite, cette approche a été utilisée avec succès par de nombreuses entreprises, en particulier AMD, Cyrix, VIA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La création d'un nouveau processeur basé sur le Z80 a été retardée jusqu'en 1985, date à laquelle le Z800 a été fabriqué. Cependant, les principaux efforts de Zilog visaient le Z80000 et très peu de Z800 ont été libérés. En 1986, après la panne du z80000, le Z280 est sorti, une version légèrement améliorée du Z800, qui, en particulier, pourrait fonctionner à une fréquence interne plusieurs fois supérieure à la fréquence du bus - une telle nouveauté a rencontré un grand succès dans les processeurs Intel 486DX2 et 486DX4. Le Z280 avait également d'autres fonctionnalités prometteuses qui ont ensuite été appliquées avec succès par d'autres sociétés. Mais, peut-être en raison des faibles performances - le Z280, malgré de nombreuses innovations technologiques, ne pouvait utiliser que des vitesses d'horloge relativement faibles, ce processeur n'est également </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulle part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application introuvable. On pense que le Z280 correspondait à peu près aux capacités de l'Intel 80286, mais était significativement, au moins 50% plus lent lors de l'utilisation de la même fréquence d'horloge avec le 80286. Peut-être que si le Z280 était apparu 5 ans plus tôt, alors il aurait pu devenir très réussi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le plus grand succès a été obtenu grâce à la collaboration avec la société japonaise Hitachi, qui a sorti en 1985 son super-Z80, HD64180, similaire en capacités à l'Intel 80186, qui permettait l'utilisation de 512 Ko de mémoire, a ajouté une douzaine de nouvelles instructions, mais certaines instructions non documentées presque standard Z80 non pris en charge. HD64180 a été utilisé dans certains systèmes informatiques. Zilog a obtenu une licence pour le HD64180 et a commencé à les fabriquer avec la marque Z64180. Zilog a réussi à améliorer légèrement ce processeur, en particulier, à ajouter le support pour travailler avec 1 Mo de mémoire et à le libérer fin 1986. Ce nouveau processeur a été appelé Z180 et est devenu la base d'une famille de processeurs et de contrôleurs, avec des fréquences d'horloge jusqu'à 33 MHz. Il a été utilisé sur certains ordinateurs MSX2 rares, mais plus comme un contrôleur. Curieuxque Z280 et Z180 sont apparus en un an, ainsi que leurs homologues approximatifs 80286 et 80 166 quatre ans auparavant. En 1994, un Z380 32 bits a été fabriqué sur la base du Z180, qui est resté compatible avec le z80 et à peu près équivalent dans ses capacités à Intel 80386 ou Motorola 68020 - Zilog a montré un écart de près de 10 ans par rapport à ses concurrents. Déjà au 21ème siècle, des processeurs-contrôleurs eZ80 très réussis avec des timings presque similaires à ceux du 6502 sont fabriqués à nouveau sur la base du Z180.Ils sont utilisés dans divers équipements, en particulier dans les cartes réseau, les lecteurs de DVD, les calculatrices, ...Déjà au 21ème siècle, des processeurs-contrôleurs eZ80 très réussis avec des timings presque similaires à ceux du 6502 sont fabriqués à nouveau sur la base du Z180.Ils sont utilisés dans divers équipements, en particulier dans les cartes réseau, les lecteurs de DVD, les calculatrices, ...Déjà au 21ème siècle, des processeurs-contrôleurs eZ80 très réussis avec des timings presque similaires à ceux du 6502 sont fabriqués à nouveau sur la base du Z180.Ils sont utilisés dans divers équipements, en particulier dans les cartes réseau, les lecteurs de DVD, les calculatrices, ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texas Instruments TMS9900 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce processeur de code très spécial, je n'ai jamais pu écrire. </font><font style="vertical-align: inherit;">Et c'est le premier processeur 16 bits disponible pour une utilisation dans les ordinateurs personnels. </font><font style="vertical-align: inherit;">Il est produit depuis 1976. </font><font style="vertical-align: inherit;">Utilise un ordre d'octets beaucoup moins courant de haut en bas (Big Endian). </font><font style="vertical-align: inherit;">Cette commande n'est toujours utilisée que dans les processeurs des gammes Motorola 6800 et 68000 et dans l'architecture du géant IBM / 370. </font><font style="vertical-align: inherit;">Tous les autres processeurs de cette revue utilisent l'ordre des octets inversés (Little Endian).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le TMS9900 n'a que trois registres 16 bits: un compteur de commandes, un registre d'état et un registre de base de pseudo-registre. Ce processeur utilise une mémoire allouée de 32 octets comme 16 registres à double octet. Cette utilisation de la mémoire rappelle quelque peu la page zéro de la mémoire dans l'architecture 6502. En utilisant le registre de base, le TMS9900 peut très rapidement changer de contexte. Cela ressemble au Z80, qui a deux contextes de registre. Le système de drapeaux se distingue par son originalité, ainsi que les drapeaux typiques de portage, zéro (égalité), débordement, parité, il existe deux autres drapeaux uniques de signes de moins logique et arithmétique. Travailler avec la pile et les routines ressemble aux processeurs RISC du futur. Il n'y a tout simplement pas de pile terminée, elle peut être faite en utilisant l'un des pseudo-registres.Lorsque le sous-programme est appelé, une nouvelle valeur est sélectionnée pour le compteur et la base, et les trois registres sont stockés dans les pseudo-registres du nouveau contexte. Ainsi, un appel de sous-programme ressemble plus à un appel d'interruption de programme. Le TMS9900 possède un contrôleur d'interruption intégré, conçu pour fonctionner avec des interruptions matérielles jusqu'à 16.</font></font><br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier ordinateur domestique 16 bits - il a même des sprites couleur.Le</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> système de commande est très impressionnant. Il y a même multiplication et division. L'instruction unique X vous permet d'exécuter une instruction à n'importe quelle adresse en mémoire et de passer à la suivante. L'exécution des commandes est assez lente, les instructions les plus rapides sont exécutées en seulement 8 cycles d'horloge, les instructions arithmétiques en 14, mais la multiplication (16 * 16 = 32) en 52 cycles d'horloge et surtout la division (32/16 = 16,16) en 124 périodes d'horloge étaient probablement un record le plus rapide parmi les processeurs des années 70.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le TMS9900 nécessite trois tensions d'alimentation de -5, 5 et 12 volts et quatre phases du signal d'horloge - ce sont des anti-enregistrements parmi les processeurs que je connais. En 1979, ce processeur a été présenté aux spécialistes IBM qui recherchaient alors un processeur pour le prototype IBM PC en cours de développement. Les lacunes évidentes du TMS9900 (adressabilité de seulement 64 Ko de mémoire, manque d'architecture des contrôleurs nécessaires, lenteur relative) ont fait une impression correspondante et Intel 8088 a été choisi comme futur leader parmi les PC. Pour résoudre le problème du manque de contrôleurs, Texas Instruments a également produit la version TMS9900 avec un bus 8 bits, TMS -9980, qui a fonctionné 33% plus lentement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le TMS9900 a été utilisé dans les ordinateurs TI99 / 4 et TI99 / 4A, qui étaient très populaires aux États-Unis, qui ont été "écrasés" par la guerre des prix par l'ordinateur Commodore VIC-20 en 1983. Il est curieux qu'à la suite de cette guerre, Texas Instruments ait été forcé de réduire les prix de son ordinateur à un niveau incroyable. pour 1983, 49 $ (en 1979, le prix était de 1150 $!) et les vendre avec une grosse perte pour vous-même. Par exemple, nous pouvons citer l'ordinateur relativement impopulaire Commodore + 4, qui a été abandonné en 1986, mais dont les prix ne sont tombés à ces 49 $ qu'en 1989. Le T99 / 4A a cessé de produire en 1984, lorsque, en raison des prix extrêmement bas, il a commencé à gagner en popularité. Cet ordinateur ne peut être appelé que 16 bits. Parce qu'il n'a que 256 octets (!) De mémoire RAM et toute la mémoire ROM adressée via un bus 16 bits.Le reste de la mémoire et les périphériques d'E / S fonctionnent via un bus lent 8 bits. Par conséquent, il est possible de considérer plus correctement le BK-0010 domestique comme le premier ordinateur domestique 16 bits. Curieusement, les TI99 / 4 et TI99 / 4A utilisent un processeur à 3 MHz - exactement le même que le BK-0010.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les TI-99/4 et TI99 / 4A, une puce TMS9918 plutôt réussie a été utilisée comme contrôleur vidéo, qui est devenue la base de la norme MSX très populaire dans le monde, ainsi que d'autres ordinateurs et consoles de jeux. </font><font style="vertical-align: inherit;">Chez la société japonaise Yamaha, cette puce vidéo a été considérablement améliorée et a ensuite été utilisée, notamment, pour mettre à niveau les TI-99/4 et TI99 / 4A elles-mêmes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La série TI99 / 4 est un exemple rare d'ordinateurs où le fabricant du processeur et l'ordinateur étaient les mêmes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processeurs DEC PDP-11 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis le début des années 70, l'ère de 10 ans de domination DEC a commencé dans le monde. Les ordinateurs DEC étaient nettement moins chers que ceux fabriqués par IBM et ont donc attiré l'attention des petites organisations pour lesquelles les systèmes IBM n'étaient pas disponibles. L'ère de la programmation professionnelle de masse commence également avec ces ordinateurs. La série d'ordinateurs PDP-11 a connu un grand succès. Divers modèles PDP-11 ont été fabriqués du début des années 70 au début des années 90. En URSS, ils ont été clonés avec succès et sont devenus les premiers systèmes informatiques populaires de masse. Parmi les clones se trouvent des ordinateurs portant le nom d'ordinateurs SM, Electronics-60/81/85, DVK-1/2/3, BK-0010/0011 (le BK0010 est le premier PC qui a pu être acheté en magasin).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, DEC a également promu les ordinateurs les plus chers et les plus sophistiqués de la famille VAX-11, dont la situation était quelque peu politisée. Et à partir de la seconde moitié des années 70, DEC a pratiquement stoppé le développement de la gamme PDP-11, en particulier, le support de 16 numéros pour l'assembleur n'a pas été introduit. Les performances des systèmes PDP-11 sont également restées pratiquement inchangées depuis le milieu des années 70.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 a utilisé différents processeurs compatibles avec le système de commande principal, par exemple, LSI-11, F-11, J-11. À la fin des années 70, DEC a fabriqué un processeur bon marché pour les micro-ordinateurs T-11. Cependant, pour des raisons peu claires, il n'a jamais été remarqué par les fabricants de systèmes informatiques, malgré le logiciel apparemment volumineux et de haute qualité qui pourrait être transféré au système en l'utilisant à l'avenir. La seule exception était le modèle de console de jeu Atari. Le T-11 n'a trouvé une utilisation répandue que dans le monde de l'équipement embarqué, bien qu'en termes de capacités, il était plutôt légèrement supérieur au z80. En URSS, des processeurs K1801BM1, K1801BM2, K1801BM3, ... proches des processeurs DEC, ainsi que des copies exactes des processeurs DEC ont été produits. Ces derniers étaient beaucoup plus chers et étaient produits en petites quantités.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système de commande des processeurs d'architecture PDP-11 se distingue par une orthogonalité presque complète, une qualité agréable, mais lorsqu'il est poussé à l'extrême, il peut créer des commandes ridicules. Le système d'instruction du processeur PDP-11 a influencé de nombreuses architectures, et en particulier le Motorola 68000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système de commande PDP-11 est strictement 16 bits. Les 8 registres à usage général (et le compteur d'instructions dans cette architecture est un registre R7 normal) sont de 16 bits, le registre d'état (contient des drapeaux typiques) est également de 16 bits, la taille des instructions est de 1 à 3 mots de 16 bits. Chaque opérande d'une commande peut être (bien qu'il existe des exceptions, par exemple, une instruction XOR) de n'importe quel type - c'est l'orthogonalité. Parmi les types figurent un registre ou une mémoire ordinaire. Les programmeurs des années 80 ne comprenaient parfois pas pourquoi il n'y avait pas d'instructions mémoire-mémoire dans le système d'instructions Intel x86. C'est l'influence de l'école PDP-11, où vous pouvez facilement écrire des adresses complètes pour chaque opérande. Ceci, bien sûr, est lent et particulièrement lent pour les systèmes à mémoire lente typiques du début des années 90. La mémoire est également accessible via un registre, un registre avec décalage, un registre avec auto-décrémentation ou incrémentation.Une caractéristique du système d'instructions PDP-11 est la possibilité d'un double accès indirect à la mémoire via un registre, par exemple,</font></font><br><br><pre><code class="plaintext">MOV @(R0)+,@-(R1)</code> </pre> <br>  signifie la même chose que l'opérateur de langage C / C ++ <br><br><pre> <code class="plaintext">**–r1 = **r1++;</code> </pre> <br>  , où r0 et r1 sont déclarés comme <br><br><pre> <code class="plaintext">signed short **r0, **r1;</code> </pre> <br>  Un autre exemple, une commande <br><br><pre> <code class="plaintext">MOVB @11(R2),@-20(R3)</code> </pre> <br>  correspond à <br><br><pre> <code class="plaintext">**(r3-20) = **(r2+11);</code> </pre> <br>  où r2 et r3 sont déclarés comme <br><br><pre> <code class="plaintext">char **r2, **r3;</code> </pre> <br>  Dans les architectures populaires d'aujourd'hui, une équipe ne peut pas se passer d'une telle équipe; au moins 10 équipes seront probablement nécessaires.  Vous pouvez également obtenir l'adresse relative à la valeur actuelle du compteur de commandes.  Je vais donner un autre exemple avec un adressage plus simple.  L'équipe <br><br><pre> <code class="plaintext">ADD #16,11(R4)</code> </pre> <br>  dans l'architecture Intel x86 peut être mappé <br><br><pre> <code class="plaintext">ADD [BX+11],16</code> </pre> <br>  Dans les assembleurs DEC, il est habituel d'écrire des opérandes de gauche à droite, contrairement à Intel, où ils écrivent de droite à gauche.  Il y a des raisons de croire que l'assembleur GNU pour x86 a été créé sous l'influence de l'assembleur PDP-11. <br><br>  Les commandes de multiplication et de division sont uniquement symboliques et ne sont pas disponibles sur tous les processeurs.  L'arithmétique des nombres décimaux est également facultative - il s'agit de l'arithmétique commerciale dite de terminologie DEC.  Par curiosité d'orthogonalité complète, je vais donner un exemple de commande <br><br><pre> <code class="plaintext">MOV #11,#22</code> </pre> <br>  qui après l'exécution se transforme en <br><br><pre> <code class="plaintext">MOV #11,#11</code> </pre> <br>  - Ceci est un exemple d'utilisation d'une constante immédiate comme opérande.  Une autre équipe curieuse est la commande unique MARK, dont le code doit être poussé sur la pile et ne peut jamais être utilisé explicitement.  L'appel de routines dans l'architecture PDP-11 est également quelque peu particulier.  La commande correspondante enregistre d'abord le registre alloué (peut être n'importe lequel) sur la pile, puis elle enregistre le compteur d'instructions dans ce registre et écrit ensuite la nouvelle valeur dans le compteur d'instructions.  La commande de retour du sous-programme doit faire le contraire et savoir quel registre a été utilisé lors de l'appel du sous-programme.  Des effets très étranges et imprévisibles peuvent être obtenus en utilisant le compteur de commandes comme registre normal. <br><br>  Il est intéressant de noter que parmi les programmeurs PDP-11, une culture de travail direct avec les codes machine s'est développée.  Les programmeurs pourraient, par exemple, fonctionner sans démonteur lors du débogage.  Ou même écrire de petits programmes directement en mémoire sans assemblage! <br><br>  Bien sûr, les horaires des équipes ne diffèrent pas par des caractéristiques de vitesse trop élevée.  Il était une fois surprenant de constater que sur l'ordinateur domestique du BK, la commande de transfert d'un registre à l'autre prend jusqu'à 12 cycles (10 cycles lors de l'utilisation du code de la ROM), et les commandes avec deux opérandes avec double adressage indirect sont exécutées pendant plus de 100 cycles.  Le Z80 effectue un transfert de registre 16 bits pour 8. Cependant, la lenteur du BC est causée non pas tant par le processeur que par la mauvaise qualité de la mémoire domestique, sous les caractéristiques de laquelle le BC a dû être adapté.  Si une mémoire suffisamment rapide était utilisée, le BC envoyait également 16 bits de registre pour 8 cycles d'horloge.  Une fois qu'il y a eu beaucoup de controverse, qui est plus rapide que BC ou Spectrum?  Il faut dire tout de suite que le Spectrum est l'un des ordinateurs personnels de masse 8 bits les plus rapides lors de l'utilisation des 32 Ko de mémoire supérieurs.  Par conséquent, il n'est pas surprenant que le spectre soit plus rapide que le BC, mais pas de beaucoup.  Et si le BC fonctionnait avec une mémoire sans freins, ce serait probablement un peu plus rapide. <br><br>  La densité de code est également plutôt un point faible de l'architecture PDP-11.  Les codes d'instructions doivent être un multiple de la longueur du mot machine - 2 octets, ce qui est particulièrement désagréable lorsque vous travaillez avec des arguments d'octet ou des commandes simples comme la définition ou la réinitialisation d'un indicateur. <br><br>  Les tentatives de fabrication d'un ordinateur personnel basé sur l'architecture PDP-11 sont intéressantes.  L'un des premiers PC au monde à être apparu un peu plus tard qu'Apple] [et Commodore PET, et un peu plus tôt que le Tandy TRS-80, était le Terak 8510 / a, qui avait des graphismes en noir et blanc et la possibilité de télécharger une version incomplète d'Unix.  Ce PC était assez cher et, pour autant que je sache, n'était utilisé que dans le système d'enseignement supérieur américain.  Depuis 1978, l'ordinateur a été produit sous la forme d'un kit pour assembler le Heathkit H11.  DEC lui-même a également essayé de créer son propre PC, mais de manière très incohérente.  DEC, par exemple, a sorti un PC basé sur les z80 et 8088, jouant visiblement plutôt contre ses principaux développements.  Le personnel basé sur l'architecture PDP-11 DEC PRO-325/350/380 avait des incompatibilités assez artificielles avec l'architecture sous-jacente, ce qui rendait difficile l'utilisation d'une partie du logiciel.  La meilleure personnalisation des technologies de mini-ordinateur a été en URSS, où BK, DVK, CC NT ont été fabriqués ... À propos, Electronics-85 est un clone assez précis du DEC PRO-350.  De plus, le processeur CP1600, semblable à l'architecture PDP-11, était utilisé dans les consoles de jeu Intellivision, qui étaient populaires au début des années 80. <br><br><img src="https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg"><br>  <i>Ordinateur domestique domestique 16 bits (1985) - presque compatible avec PDP-11</i> <br><br>  K1802BM2, qui était utilisé dans le DVK, est environ deux fois plus rapide que K1801BM1, K1801BM3 est encore plus rapide et proche de la vitesse d'Intel 8086. <br><br>  Dans les anciens modèles PDP-11 et les ordinateurs domestiques à proximité, le processeur peut traiter jusqu'à 4 Mo de mémoire, mais pas plus de 64 Ko peuvent être alloués à un programme.  En termes de vitesse, ces processeurs sont également proches de 8086 en termes de nombre d'opérations par mégahertz, bien qu'il soit encore plus lent que cela. <br><br><h2>  CPU pour DEC VAX-11 </h2><br>  Les systèmes VAX-11 étaient très populaires dans les années 80, en particulier dans l'enseignement supérieur.  Maintenant, il est difficile de comprendre certains des concepts décrits dans les livres de ces années sans connaître l'architecture de ces systèmes.  Les VAX-11 étaient plus chers que les PDP-11, mais ils étaient plus orientés vers la programmation universelle et toujours beaucoup moins chers que les systèmes IBM / 370.  Pour l'architecture VAX, un processeur V-11 a été fabriqué au milieu des années 80, et jusque-là, des assemblages de processeurs étaient utilisés. <br><br>  L'architecture VAX-11 est 32 bits, elle utilise 16 registres, parmi lesquels, comme sur le PDP-11, il y a un compteur de commandes.  Deux piles sont censées être utilisées, dont l'une est utilisée pour stocker les trames de sous-trames.  De plus, l'un des registres est affecté au travail avec les arguments des fonctions appelées.  Ainsi, 3 des 16 registres sont alloués pour les piles.  Le système de commande VAX-11 ne peut que surprendre par son énormité et la présence de commandes très rares et souvent uniques, par exemple, pour travailler avec des champs de bits ou plusieurs types de files d'attente, pour calculer le CRC, multiplier 10 lignes ... De nombreuses commandes sont en versions à trois adresses (les deux ARM) et à deux adresses (comme x86), mais il existe des commandes à quatre adresses, par exemple, la division étendue d'EDIV.  Bien sûr, il est possible de travailler avec des nombres réels. <br><br>  Mais le VAX-11 est un système très lent pour sa classe et son prix.  Même le très simple 6502 à 4 MHz pourrait dépasser le plus lent de la famille VAX-11/730, et les systèmes VAX-11 les plus rapides - d'énormes armoires et «ensembles de meubles entiers», sont au niveau des performances des premiers PC AT.  Lorsque le 80286 est apparu, il est devenu clair que les jours du VAX-11 étaient numérotés et même le freinage avec l'introduction de systèmes basés sur le 80286 ne pouvait plus rien changer fondamentalement.  Les Britanniques les plus simples d'Acorn, ayant fabriqué ARM en 1985 sans rien cacher, ont déclaré que ARM est beaucoup moins cher et sensiblement plus rapide.  VAX-11, cependant, est resté pertinent jusqu'au début des années 90, ayant toujours certains avantages par rapport à un PC, en particulier, des systèmes plus rapides pour travailler avec des disques. <br><br>  Le VAX-11 est probablement le dernier système de masse dans lequel la commodité de travailler en assembleur était considérée comme plus importante que la vitesse.  Dans un sens, cette approche s'est déplacée vers des langages de script modernes et populaires. <br><br><img src="https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg" align="left">  <i>La photo montre le VAX-11/785 - c'est aussi un ordinateur (1984) - le plus rapide des VAX-11, en termes de vitesse de processeur, il est comparable à IBM PC AT ou ARM Evaluation System</i> <br><br>  Étonnamment, il existe très peu de documentation sur les systèmes VAX-11.  Comme si une sorte de loi étrange sur l'oubli était en vigueur.  Plusieurs épisodes proches de la politique et corrélés à l'histoire de l'URSS sont liés à l'histoire de cette architecture.  Il est possible que le rejet réel du développement de l'architecture PDP-11 ait été causé par son bon marché et le succès de son clonage en Union soviétique.  Et le clonage de VAX-11 a coûté un ordre de grandeur de grandes ressources et a conduit à une impasse.  L'intérêt pour VAX-11 a été créé en utilisant, par exemple, des tirages tels que le célèbre Kremlin Vax du 1er avril 1984, dans lequel le chef de l'URSS de l'époque, Konstantin Chernenko, a offert de boire de la vodka à l'occasion de la connexion au réseau Usenet.  Une autre blague était que certaines puces VAX-11 portaient un message en russe cassé sur la qualité du VAX-11.  :) <br><br>  Certains modèles VAX-11 ont été clonés en URSS à la fin des années 80, mais très peu de ces clones ont été produits et ils n'ont presque jamais trouvé d'utilisation. <br><br>  Plusieurs systèmes VAX-11 sont disponibles pour une utilisation sur le réseau.  Et cela les compare favorablement aux systèmes IBM / 370 avec lesquels ils étaient en concurrence. <br><br><h2>  Intel: 8086 à 80486 </h2><br>  Certes, l'un des meilleurs processeurs fabriqués dans les années 70 est le 8086, ainsi que son 8088 presque analogique moins cher. L'architecture de ces processeurs se distingue agréablement par l'absence d'emprunt mécanique et le respect des théories abstraites, la réflexion et l'architecture équilibrée, l'équilibre et la concentration sur développement ultérieur.  Parmi les défauts de l'architecture x86, on peut parler de lourdeur et d'une tendance à une croissance importante du nombre d'instructions. <br><br>  L'une des solutions de conception ingénieuses du 8086 a été l'invention des registres de segments.  Cela, pour ainsi dire, atteignait simultanément deux objectifs: la portabilité «gratuite» des programmes jusqu'à 64 Ko (c'était une quantité très décente de mémoire informatique pour un programme jusqu'au milieu des années 80) et l'adressabilité jusqu'à 1 Mo d'espace d'adressage.  Vous pouvez également remarquer que le 8086, comme le 8080 ou le z80, possède également un espace d'adressage spécial pour les ports d'E / S de 64 Ko (y 8080 et 8085, ce volume est de 256 octets).  Il n'y a que quatre registres de segments: pour le code, pour la pile et deux pour les données.  Ainsi, 64 * 4 = 256 Ko de mémoire sont disponibles pour une utilisation rapide, mais c'était très bien même au milieu des années 80.  En fait, il n'y a pas de problème avec la taille du code, car vous pouvez utiliser les appels dits longs de sous-programmes avec le chargement et la sauvegarde de l'adresse complète à partir de deux registres.  Il n'y a qu'une limite de 64 Ko sur la taille d'un sous-programme - cela suffit pour de nombreuses applications modernes.  L'impossibilité d'adresser rapidement des baies de données supérieures à 64 Ko crée un certain problème - lorsque vous utilisez de telles baies, vous devez charger le registre de segment et l'adresse elle-même à chaque appel, ce qui réduit la vitesse de travail avec de si grandes baies de plusieurs fois. <br><br>  Les registres de segments sont mis en œuvre de telle manière que leur présence est presque imperceptible dans les codes machine, ce qui a facilité leur refus le moment venu. <br><br>  L'architecture 8086 a conservé sa proximité avec l'architecture 8080, ce qui a permis relativement peu d'efforts pour transférer des programmes de 8080 (ou même z80) vers 8086, et surtout si le code source des programmes était disponible. <br><br>  Les équipes 8086 ne diffèrent pas par leur vitesse d'exécution élevée, mais sont tout à fait comparables à leurs concurrents, par exemple le Motorola 68000, qui est apparu un an plus tard.  L'un des nouveaux produits, qui accélère légèrement le 8086 généralement peu pressé, a été le tour des équipes. <br><br>  Le 8086 utilise huit registres 16 bits, dont certains peuvent être utilisés comme registres à deux octets et d'autres comme index.  Ainsi, les registres 8086 sont quelque peu hétérogènes, mais ils sont bien équilibrés et les registres sont très pratiques à utiliser.  Cette hétérogénéité, soit dit en passant, vous permet d'avoir des codes plus denses.  Le 8086 utilise les mêmes drapeaux que le 8080, plus quelques nouveaux.  Par exemple, un indicateur est apparu, typique de l'architecture PDP-11 - exécution pas à pas. <br><br>  8086 vous permet d'utiliser des modes d'adressage très intéressants, par exemple, une adresse peut être constituée de la somme de deux registres et d'un mixage 16 bits constant, sur lequel la valeur de l'un des registres de segment est superposée.  Seuls deux ou même un terme peuvent être exclus de la somme de l'adresse.  Cela sur PDP-11 avec une seule commande ne fonctionnera pas.  La plupart des instructions 8086 n'autorisent pas les deux opérandes de type mémoire; l'un des opérandes doit être un registre.  Mais il existe des commandes de chaîne qui savent juste comment travailler avec de la mémoire en utilisant deux adresses.  Les commandes de chaîne vous permettent d'effectuer une copie de bloc rapide (17 mesures par octet ou mot), de rechercher, de remplir, de charger et de comparer.  De plus, les commandes de chaîne peuvent être utilisées lorsque vous travaillez avec des ports d'E / S.  L'idée de 8086 d'utiliser des préfixes de commande est très intéressante, permettant d'utiliser des fonctionnalités supplémentaires souvent très utiles sans complication significative des schémas de codage de commande. <br><br>  8086 possède l'un des meilleurs de tous les systèmes informatiques d'organisation du travail avec la pile.  En utilisant seulement deux registres (BP et SP), 8086 vous permet de résoudre tous les problèmes lors de l'organisation d'appels à des routines avec des paramètres. <br><br>  Parmi les équipes, il y a une multiplication et une division symboliques et non signées.  Il existe même des commandes d'ajustement décimal uniques pour les commandes de multiplication et de division.  Il est difficile de dire qu'il manque clairement quelque chose dans le système de commande 8086.  Au contraire, c'est le contraire.  La division d'un dividende de 32 bits en un diviseur de 16 bits pour obtenir un privé de 32 bits et un reste de 16 bits peut nécessiter jusqu'à 300 cycles d'horloge - pas particulièrement rapide, mais plusieurs fois plus rapide qu'une telle division sur n'importe quel processeur 8 bits (sauf 6309) et comparable en vitesse à 68000. La division par x86 a une caractéristique inattendue - elle change les drapeaux des signes de manière imprévisible ... <br><br>  Il convient d'ajouter que dans l'architecture x86, l'équipe XCHG héritée du 8080 est restée, ce qui a été amélioré.  De plus, les processeurs ultérieurs ont commencé à utiliser les instructions XADD, CMPXCHG et CMPXCHG8B, qui peuvent également effectuer un échange atomique d'arguments.  De telles instructions sont l'une des fonctionnalités de x86, il est difficile de les trouver sur des processeurs d'autres architectures. <br><br>  Nous pouvons résumer que le 8086 est un processeur très réussi, combinant à la fois la commodité de la programmation et l'attachement aux limitations de mémoire qui sont caractéristiques de leur temps.  Le 8086 a été utilisé relativement rarement, faisant place au 8088, moins cher, à l'honneur d'être le premier processeur de l'architecture PC principale de notre époque, l'architecture PC IBM.  Le 8088 utilisait un bus de données 8 bits, ce qui le rendait un peu plus lent, mais il permettait de construire des systèmes plus accessibles aux clients basés sur lui. <br><br>  Fait intéressant, Intel a fondamentalement refusé d'apporter des améliorations à ses processeurs, préférant plutôt développer leurs prochaines générations.  L'un des plus grands sous-traitants d'Intel (NEC), la société japonaise NEC, qui au début des années 80 était beaucoup plus grande qu'Intel, a décidé d'améliorer les 8088 et 8086, en libérant des processeurs V20 et V30, compatibles avec eux sur le socket et jusqu'à 30% plus rapidement.  NEC a même proposé à Intel de devenir son sous-traitant!  Intel a plutôt lancé un procès contre NEC, qui n'a cependant pas pu gagner.  Pour une raison quelconque, cette grande confrontation entre Intel et NEC a été complètement ignorée par Wikipedia. <br><br>  80186 et 80286 sont apparus en 1982. Ainsi, on peut supposer qu'Intel avait deux équipes de développement presque indépendantes.  Le 80186 est un 8086 amélioré par plusieurs commandes et temporisations raccourcies, ainsi que plusieurs circuits intégrés typiques de l'architecture x86: générateur d'horloge, temporisateurs, DMA / DAP, contrôleur d'interruption, générateur de retard, etc. Un tel processeur semble simplifier considérablement la production ordinateurs basés sur elle, mais parce que le contrôleur d'interruption intégré s'est avéré incompatible avec le PC IBM pour une raison quelconque, il n'a presque jamais été utilisé sur un PC.  L'auteur ne connaît que le système BBC Master 512 basé sur l'ordinateur BBC Micro, qui n'utilisait pas les circuits intégrés, même la minuterie, mais il y avait plusieurs autres systèmes utilisant 80186. La mémoire adressable de 80186 est restée de la même manière qu'en 8086 avec une taille de 1 Mo.  La société japonaise NEC a produit des analogues de 80186, qui étaient compatibles avec le PC IBM. <br><br>  80286 avait des temps encore meilleurs que 80.186, parmi lesquels une division juste fantastique (32/16 = 16,16) pour 22 mesures est particulièrement notable - depuis lors, la division n'a pas appris à faire plus vite!  80286 prend en charge le travail avec toutes les nouvelles équipes 80186, ainsi que de nombreuses équipes pour travailler dans un nouveau mode protégé.  Le 80286 a été le premier processeur à prendre en charge le mode protégé, ce qui a permis d'organiser la protection de la mémoire, l'utilisation correcte des instructions privilégiées et l'accès à la mémoire virtuelle.  Bien que le travail dans le nouveau mode ait créé de nombreux problèmes problématiques (le mode protégé a été rendu plutôt infructueux) et était relativement rarement utilisé, c'était une grande avancée.  Dans ce nouveau mode, les registres de segments ont acquis une nouvelle qualité, vous permettant d'utiliser jusqu'à 16 Mo de mémoire adressable et jusqu'à 1 Go de mémoire virtuelle par tâche.  Le gros problème avec 80286 était l'incapacité de passer du mode protégé au mode réel, dans lequel la plupart des programmes fonctionnaient alors.  En utilisant l'instruction LOADALL «secrète» non documentée, il était possible d'utiliser 16 Mo en mémoire et en mode réel. <br><br>  En 80286, le calcul des adresses en opérandes d'instructions a commencé à être effectué par des schémas séparés et a cessé de ralentir l'exécution des commandes.  Cela a ajouté des fonctionnalités intéressantes, par exemple, avec l'équipe <br><br><pre> <code class="plaintext">LEA AX,[BX+SI+4000]</code> </pre> <br>  en seulement 3 cycles, il est devenu possible d'effectuer deux ajouts et de transférer le résultat dans le registre AX! <br><br>  Les registres segmentés en mode protégé font désormais partie d'un système complet de gestion de la mémoire (MMU).  En mode réel, ces registres ne fournissaient que partiellement la fonctionnalité MMU. <br><br>  Le nombre de fabricants et de systèmes spécifiques utilisant 80286 est énorme, mais, bien sûr, les premiers étaient des ordinateurs IBM PC AT avec des indicateurs de performance presque fantastiques parmi les ordinateurs personnels.  À partir de ces ordinateurs, la mémoire a commencé à être à la traîne par rapport au processeur, il y avait des états de retard, mais cela semblait quelque chose d'autre temporaire. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 80286, comme en 8086/8088, le travail avec les interruptions n'était pas implémenté à 100% correctement, ce qui dans de très rares cas pouvait entraîner des conséquences très désagréables. Par exemple, la commande POPF de 80286 a toujours autorisé les interruptions pendant son exécution et lors de l'exécution d'une commande avec deux préfixes (par exemple, prenez REP ES: MOVSB) sur 8086/8088, après avoir appelé l'interruption, l'un des préfixes a été perdu. Un bogue dans POPF était uniquement dans les versions antérieures de 80286.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mode protégé 80286 était extrêmement gênant, divisait toute la mémoire en segments de 64 Ko maximum et nécessitait une prise en charge logicielle complexe pour travailler avec la mémoire virtuelle. Apparu en 1985, 80386 a rendu le travail en mode protégé assez confortable, a permis d'utiliser jusqu'à 4 Go de mémoire adressable et de basculer facilement entre les modes. De plus, pour prendre en charge le multitâche, un mode 8086 virtuel a été créé pour les programmes 8086. Pour la mémoire virtuelle, il est devenu possible d'utiliser un mode de page relativement facile à gérer. 80386, avec toutes ses innovations, a conservé une compatibilité totale avec les programmes écrits pour 80286. Parmi les innovations de 80386, on peut également mentionner l'extension des registres à 32 bits et l'ajout de deux nouveaux registres de segments. Les horaires ont changé, mais de manière ambiguë. Un sélecteur de bits rapide a été ajoutéce qui a permis de faire plusieurs décalages avec des timings d'un. Cependant, cette innovation, pour une raison quelconque, a considérablement ralenti l'exécution des instructions de changement cyclique. La multiplication est devenue un peu plus lente que celle de 80286. Le travail avec la mémoire est devenu, au contraire, un peu plus rapide, mais cela ne s'applique pas aux commandes de chaînes, qui sont restées plus rapides que 80286. L'auteur de ce matériel a souvent rencontré l'opinion qu'en mode réel, 16- le code bit 80286 à la fin est toujours un peu plus rapide que 80386 à la même fréquence.L’auteur de ce matériel a dû plus d’une fois penser qu’en mode réel avec un code 16 bits 80286, il est finalement un peu plus rapide que 80386 à la même fréquence.L’auteur de ce matériel a dû plus d’une fois penser qu’en mode réel avec un code 16 bits 80286, il est finalement un peu plus rapide que 80386 à la même fréquence.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 80386, de nouvelles commandes ont été ajoutées, dont la plupart ne donnaient que de nouvelles façons de travailler avec les données, dupliquant en fait celles disponibles dans certains cas avec optimisation. </font><font style="vertical-align: inherit;">Par exemple, les commandes suivantes ont été ajoutées:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour vérifier, régler et réinitialiser le bit par numéro, similaire à ceux qui ont été faits pour z80; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bit scan BSF et BSR; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copier les valeurs avec une extension signée ou nulle, MOVSX et MOVZX; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fixer des valeurs en fonction des valeurs des drapeaux des opérations SETxx; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> double décalage SHLD, SHRD. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant l'avènement du 80386, les processeurs x86 ne pouvaient utiliser que des sauts conditionnels de décalage courts d'un octet - ce qui était souvent très insuffisant. Avec 80386, il est devenu possible d'utiliser des décalages de deux (ou quatre en mode adresse 32 bits), et malgré le fait que le code des nouvelles transitions soit devenu deux (ou trois) fois plus long, son temps d'exécution est resté le même que les précédents, transitions courtes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prise en charge du débogage a été radicalement améliorée en introduisant 4 points d'arrêt matériels, en les utilisant, il est devenu possible d'arrêter des programmes même à des adresses en mémoire qui ne peuvent pas être modifiées.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mode protégé principal est devenu beaucoup plus facile à gérer qu'en 80286, ce qui rendait inutiles un certain nombre de commandes héritées. Dans le mode protégé principal, le mode dit plat utilise des segments jusqu'à 4 Go, ce qui transforme tous les registres de segments en une formalité subtile. Et le mode irréel semi-documenté a même permis d'utiliser toute la mémoire comme en mode plat, mais à partir du mode réel, facile à installer et à gérer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec 80386, Intel a refusé de partager ses technologies, devenant en fait un fabricant monopolistique de processeurs pour l'architecture PC IBM, et avec l'affaiblissement de Motorola, pour d'autres architectures d'ordinateurs personnels. </font><font style="vertical-align: inherit;">Les systèmes basés sur 80386 étaient très chers jusqu'au début des années 90, quand ils sont finalement devenus disponibles pour les consommateurs de masse à des fréquences de 25 à 40 MHz. </font><font style="vertical-align: inherit;">C 80386 IBM a commencé à perdre sa position de fabricant leader d'ordinateurs compatibles IBM PC. </font><font style="vertical-align: inherit;">Cela s'est manifesté, en particulier, par le fait que l'ordinateur Compaq a été le premier PC basé sur 80386 en 1986.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est difficile de ne pas restreindre l'admiration pour les volumes de travail qui ont été effectués par les créateurs de 80386 et ses résultats. </font><font style="vertical-align: inherit;">J'ose même suggérer que le 80386 contient plus de réalisations que toutes les réalisations technologiques de l'humanité avant 1970, et peut-être même avant 1980.</font></font><br><br></p><p>      80386.   .     ,               .       80386 ,    .     IBTS  XBTS.   80386DX/SX,   AMD,   Intel (     ),      ,       EAX,            POPAD  PUSHAD  ,     BX.       .      ,        .    . <br><br>  ARM      .   ,  ARM   .  Intel  80486.             Intel           –   . <br><br>  80486                ARM  .     -   .  ,           ,   8088!      ,  8 ,  -.    , , CMPXCHG –       IBTS  XBTS (,             80386).     –  ,             32-  BSWAP.           –     .      . <br><br>     80486   .  ,      80486,  VX FT,    Apricot –    1989   18  40  ,     –  60 !           Intel       ARM  Acorn. IBM      80486  1990,    PS/2 90  $17000. <br><br>     Intel  ,   .      ,     8086. ,        ,        AAD  AAM      ,   (      Pentium  15 !).      AND/OR/XOR    , , AND BX,7      (83 E3 07).  ,    ,       ,        80386. ,      8086  80286     ,       .      ADD/ADC/SBB/SUB,      . ,  ,   ,    (?)      .           –       .  , ,   SAL/SHL ( D0 E0, D0 F0  D1 E0, D1 F0)   . ,    ,     . ,     .   ,  Intel     ,     ?  SALC      1995  20 !    ICEBP    10   1985  1995.       LOADALL  LOADALLD –      ,                80286  80386 .        UD1 (0F B9),      .    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En URSS, la production de clones des processeurs 8088 et 8086 était maîtrisée, et il n'était pas possible de reproduire entièrement 80286. </font></font><br><br></p><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola: 68 000 à 68040 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola est la seule entreprise qui, pendant un certain temps, pourrait réussir à concurrencer Intel dans la production de processeurs pour ordinateurs personnels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 68000 est sorti en 1979 et à première vue, il semblait beaucoup plus impressionnant que le 8086. Il avait 16 registres 32 bits (plus précisément même 17), un compteur de commandes séparé et un registre d'état. Pourrait traiter directement 16 Mo de mémoire, ce qui n'a pas créé de restrictions, par exemple, pour les grands tableaux. Cependant, une analyse minutieuse des caractéristiques du 68000 montre que tout n'est pas aussi bon qu'il n'y paraît. Dans ces années, avoir une mémoire de plus de 1 Mo est un luxe inaccessible même pour les organisations de taille moyenne. La densité des codes dans 68000 est pire que dans 8086 - ce qui signifie que les codes avec la même fonctionnalité occupent 68000 plus d'espace. Ce dernier est également dû au fait que les codes 68k devraient être un multiple de 2 octets et x86 devrait avoir 1. Mais les informations sur la densité du code sont controversées, car il est prouvé que dans certains cas 68000 peut être meilleur que 8086 Sur les 16 registres, 8 sont adressables,à certains égards, ce sont des analogues légèrement plus avancés des registres de segments x86. ALU et le bus de données sont 16 bits, donc les opérations avec des données 32 bits sont plus lentes que vous ne le pensez. Le temps d'exécution des opérations de registre à registre est de 4 cycles et celui de 8086 n'est que de 2. Les ordinateurs basés sur 68000 jusqu'au milieu des années 80 se sont révélés beaucoup plus chers que les ordinateurs basés sur Intel 8088, mais 68000 ne pouvait pas fonctionner avec de la mémoire virtuelle et n'avait pas de matériel prise en charge de l'utilisation de nombres réels, ce qui le rendait impropre à une utilisation dans les systèmes les plus avancés.que basé sur Intel 8088, mais 68000 ne pouvait pas fonctionner avec de la mémoire virtuelle et n'avait pas de support matériel pour travailler avec des nombres réels, ce qui le rendait impropre à une utilisation dans les systèmes les plus avancés.que basé sur Intel 8088, mais 68000 ne pouvait pas fonctionner avec de la mémoire virtuelle et n'avait pas de support matériel pour travailler avec des nombres réels, ce qui le rendait impropre à une utilisation dans les systèmes les plus avancés.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme toujours, avec les produits de Motorola, l'architecture 68000 montre une maladresse et des bizarreries farfelues. Par exemple, deux piles ou deux portent des drapeaux (un pour les fonctionnalités et un pour les opérations). Cette bizarrerie avec les drapeaux ne s'arrête pas là. Pour une raison quelconque, de nombreuses équipes, y compris même MOVE, sont remplies de drapeaux pour les drapeaux de transport et de débordement. Une autre chose étrange est que la commande pour enregistrer l'état des drapeaux arithmétiques, qui fonctionnait bien en 68000, a été rendue privilégiée dans tous les processeurs à partir de 68010. Certaines opérations sont ennuyeuses avec leur non-optimisation, par exemple, l'opération d'écriture de zéro dans la mémoire CLR est plus lente que l'écriture du 0 constant en mémoire avec la commande MOVE ou un décalage vers la gauche est plus lent que l'ajout de l'opérande à lui-même. Il y a des commandes pratiquement inutiles, par exemple, il y a des décalages à gauche à la fois arithmétiques et logiques.Même les registres d'adresses avec des avantages apparemment supérieurs aux registres de segments 8086 présentent un certain nombre d'inconvénients gênants. Par exemple, en eux, il était nécessaire de charger jusqu'à 4 octets au lieu de deux en 8086 et l'un de ces quatre était superflu. Le système de commande 68000 révèle de nombreuses similitudes avec le système de commande PDP-11 développé dans les années 60.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les codes pour Motorola semblent en quelque sorte plus volumineux et maladroits par rapport à x86 ou ARM. En revanche, 68 000 est toujours plus rapide que 8086, selon mes estimations, d'environ 20 à 30%. Les codes 680x0, cependant, ont également leur propre beauté et élégance, moins la caractéristique de mécanicité de x86. En outre, comme l'a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montré la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> communication avec les experts de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">eab.abime.net</font></a><font style="vertical-align: inherit;"> , la densité de code de 68k est souvent meilleure que x86.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'ensemble, le 68000 est un bon processeur, avec un grand système d'instruction. Il a été utilisé dans de nombreux ordinateurs personnels légendaires: dans les premiers ordinateurs Apple Macintosh, qui ont été produits avant le début des années 90, dans les premiers ordinateurs multimédias Commodore Amiga, dans les ordinateurs Atari ST relativement bon marché et de haute qualité. Le 68 000 a également été utilisé dans des ordinateurs relativement peu coûteux qui fonctionnent avec des variantes Unix, en particulier dans le Tandy 16B plutôt populaire. Fait intéressant, IBM simultanément avec le développement du PC a dirigé le développement de l'ordinateur System 9000 basé sur 68000, qui a été publié moins d'un an après le PC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 68010 est apparu manifestement en retard, seulement en 1982, en même temps qu'Intel a sorti le 80286, qui a placé les ordinateurs personnels au niveau des mini-ordinateurs. Le 68010 est compatible avec le connecteur 68000, mais le système de ses commandes est légèrement différent, donc le remplacement du 68000 par le 68010 n'est pas devenu populaire. L'incompatibilité a été causée par une raison farfelue d'aligner 68 000 de plus sur la théorie idéale de l'organisation du support de la virtualisation. Le 68010 n'est que légèrement, pas plus de 10% plus rapide que le 68000. Il est évident que le 68010 a beaucoup perdu contre le 80286 et était encore plus faible que le 800186 qui est apparu la même année. Comme le 80186, le 68010 n'a presque jamais trouvé son utilisation dans les ordinateurs personnels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 68008 a également été publié en 1982, probablement dans l'espoir de répéter le succès du 8088. Il s'agit du 68000, mais avec un bus de données 8 bits, ce qui lui a permis d'être utilisé dans des systèmes moins chers. Mais le 68008, comme le 68000, n'a pas de ligne de commande, ce qui le rend environ 50% plus lent que le 68000. Ainsi, le 68008 peut même être un peu plus lent que le 8088, qui, en raison de la ligne de commande, n'est que d'environ 20% plus lent que 8086.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur cette base, Sir Clive Sinclair a fabriqué le Spectrum QL - un ordinateur très intéressant qui, en raison de son prix inférieur, pourrait rivaliser avec Atari ST et des ordinateurs similaires. Mais Clive a simultanément et manifestement prématurément commencé à investir beaucoup d'énergie dans le développement de véhicules électriques, laissant QL (Quantum leap - quantum leap) plutôt comme une tâche secondaire, qui, avec certaines solutions de conception infructueuses, a conduit l'ordinateur de Clive et l'ensemble de l'entreprise à fermer prématurément (la société est devenue une partie Amstrad, qui a refusé de produire QL). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il serait intéressant de calculer l'indice de bits pour 68000, il me semble qu'il est clairement supérieur à 16, bien que probablement pas supérieur à 24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apparu en 1984, le 68020 ramena à nouveau Motorola aux premières positions. Ce processeur a mis en œuvre de nombreux nouveaux produits très intéressants et prometteurs. L'effet le plus fort est certainement produit par le pipeline d'instructions, qui vous permet parfois d'exécuter jusqu'à trois instructions à la fois! Le bus d'adresse 32 bits semblait un peu prématuré au cours de ces années, et donc une version moins chère du processeur 68020EC avec un bus 24 bits a été produite. Mais le bus de données 32 bits semblait tout à fait approprié et permettait d'accélérer considérablement le travail. La nouveauté concernait également le cache intégré, bien que petit, 256 octets, en volume, ce qui permettait d'améliorer considérablement les performances, car la mémoire dynamique principale ne pouvait plus suivre le processeur. Des opérations assez rapides ont été ajoutées pour la division (64/32 = 32,32) et la multiplication (32 * 32 = 64), pour environ 80 et jusqu'à 45 mesures, respectivement.Les horaires d'instruction ont été généralement considérablement améliorés, par exemple, la division (32/16 = 16,16) a commencé à être effectuée en environ 45 cycles (plus de 140 cycles en 68000). Certaines instructions, dans les cas les plus favorables, peuvent être exécutées sans prendre de cycles du tout! De nouveaux modes d'adresse ont été ajoutés, en particulier avec la mise à l'échelle - pour x86, ce mode n'est apparu que l'année prochaine en 80386. D'autres nouveaux modes d'adresse permettent d'utiliser un double adressage indirect, en utilisant plusieurs décalages, PDP-11 a été largement dépassé ici.avec mise à l'échelle - pour x86, ce mode n'est apparu que l'année prochaine pour 80386. D'autres nouveaux modes d'adressage permettent d'utiliser un double adressage indirect, en utilisant plusieurs décalages en même temps - PDP-11 a été largement dépassé ici.avec mise à l'échelle - en x86, ce mode n'est apparu que l'année prochaine en 80386. D'autres nouveaux modes d'adressage permettent l'utilisation d'un double adressage indirect, en utilisant plusieurs décalages - PDP-11 a été largement dépassé ici.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais certaines nouvelles instructions, par exemple, des opérations lourdes avec des champs de bits ou de nouvelles opérations avec 10 nombres qui sont devenues inutiles pendant la division et la multiplication rapides, ressemblaient plus à une cinquième roue dans un chariot qu'à quelque chose d'essentiellement utile. Les modes d'adressage avec double adressage indirect semblent théoriquement intéressants, mais pratiquement rarement nécessaires et s'exécutent très lentement. Contrairement à 80286, 68020 prend du temps pour calculer l'adresse de l'opérande, la soi-disant adresse effective. La division à 68020 s'est avérée presque deux fois plus lente que la division miracle à 80286. La multiplication et certaines opérations sont également plus lentes. Le 68020 n'a pas de système de gestion de mémoire intégré (MMU) et la capacité exotique de connecter jusqu'à huit coprocesseurs n'a pas pu résoudre ce problème.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 68020 était largement utilisé sur les énormes ordinateurs Apple Macintosh II, Macintosh LC et Commodore Amiga 1200. Il a également été utilisé sur plusieurs systèmes Unix.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'apparition du 80386 avec ses MMU et bus et registres 32 bits intégrés et très solides a remis Motorola à la position numéro 2. 68030, apparu pour la dernière fois en 1987, a pu regagner le leadership de Motorola pendant une courte période. Le 68030 dispose d'un système de gestion de mémoire intégré et d'un cache doublé, divisé en un cache pour les instructions et les données - c'était un nouveau produit très prometteur. De plus, le 68030 pourrait utiliser une interface d'accès à la mémoire plus rapide, ce qui peut accélérer les opérations de mémoire de près d'un tiers. Mais, malgré toutes les innovations, le 68030 s'est avéré être légèrement plus lent que le 80386 aux mêmes fréquences. Cependant, le 68030 était disponible à des fréquences allant jusqu'à 50 MHz, et le 80386 seulement jusqu'à 40 MHz, ce qui a rendu les meilleurs systèmes basés sur le 68030 légèrement plus rapides.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 68030 a été utilisé dans les ordinateurs de la série Apple Macintosh II, le Commodore Amiga 3000, Atari TT, Atari Falcon et quelques autres.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le 68040, Motorola a de nouveau tenté de surpasser Intel. Ce processeur est apparu un an plus tard après 80486, mais en termes de combinaison de qualités utiles, il ne pouvait pas le dépasser. En fait, Motorola, ayant un système de commande plus surchargé, n'a pas pu le supporter et, dans un sens, a perdu la piste. En 68040, ils n'ont pu placer qu'un coprocesseur très tronqué pour travailler avec des nombres réels et la puce elle-même s'est réchauffée considérablement plus que 80486. Selon les résultats sur lowendmac.com/benchmarks 68040, elle n'est que 2,1 fois plus rapide que 68030, ce qui signifie que 68040 est légèrement plus lent que 80486 sur ce point. même fréquence. 68040 n'a pratiquement pas trouvé d'application dans les ordinateurs populaires. Seule son option moins chère, 68LC040, qui n'a pas de coprocesseur intégré, a trouvé une utilisation notable. CependantLes premières versions de cette puce présentaient un sérieux défaut matériel, qui ne permettait même pas l'utilisation de l'émulation logicielle d'un coprocesseur!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motorola a toujours eu des problèmes avec les coprocesseurs mathématiques. </font><font style="vertical-align: inherit;">Motorola, comme déjà mentionné, n'a pas publié un tel coprocesseur pour 68000/68010, tandis qu'Intel a sorti son très réussi 8087 depuis 1980. Pour les processeurs 68020/68030, deux coprocesseurs 68881 et sa version améliorée compatible avec broches 68882 ont été produits à la fois. Mais pour obtenir un gain de performances significatif, le code de 68882 doit être compilé différemment de 68881. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de dire que Intel x86 a toujours des problèmes avec le coprocesseur mathématique - la précision des calculs de certaines fonctions, par exemple, le sinus sur certains arguments, est très petite, </font><font style="vertical-align: inherit;">parfois pas plus de 4 caractères. </font><font style="vertical-align: inherit;">Par conséquent, les compilateurs modernes calculent souvent de telles fonctions sans recourir aux services d'un coprocesseur.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> National Semiconductor 32016 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit du premier véritable processeur 32 bits proposé pour une utilisation dans les ordinateurs en 1982. Ce processeur était initialement prévu comme VAX-11 sur une puce, mais en raison de l'impossibilité de négocier avec DEC, National Semiconductor (NS) a dû faire du processeur uniquement des pièces séparées similaires sur l'architecture VAX-11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de la mémoire virtuelle paginée commence avec ce processeur - c'est aujourd'hui la technologie dominante. Mais la prise en charge de la mémoire virtuelle n'est pas intégrée au processeur, mais nécessite un coprocesseur. Un coprocesseur séparé est également requis pour travailler avec des nombres réels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système d'instruction NS32016 est énorme et similaire au système d'instruction VAX-11, en particulier, avec une pile séparée pour les trames de sous-programme. Le bus d'adresse est de 24 bits, ce qui vous permet d'utiliser jusqu'à 16 Mo de mémoire. Une caractéristique de 32016 est le travail avec des drapeaux de signes. En plus des drapeaux de report standard (qui peuvent également être utilisés comme signe pour une transition conditionnelle), débordement, signe, égalité (ou zéro), il y a aussi le drapeau L (moins), ce qui signifie que moins est comme un report pour les comparaisons. La situation de transfert est similaire à celle des processeurs Motorola 680x0. Le drapeau de débordement est pour une raison quelconque appelé F. Il existe des drapeaux du mode pas à pas, du mode privilégié et du drapeau (unicité!) Pour sélectionner la pile actuelle. Lors de l'exécution d'instructions arithmétiques, les drapeaux du signe, zéro, minoritaire (L) ne sont pas définis, ils ne le sont que par des commandes de comparaison.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez utiliser huit registres à usage général 32 bits. De plus, il y a aussi un compteur de commandes, deux pointeurs de pile, un pointeur de pile de trames de sous-programme, un pointeur de base de programme (c'est quelque chose d'unique), un pointeur de base de module (aussi quelque chose de très rare), un pointeur vers la table vectorielle d'interruption, un registre de configuration et un registre condition. En termes de vitesse, le NS32016 était comparable à 68 000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour autant que je sache, le 32016 a été utilisé uniquement avec les ordinateurs personnels BBC Micro comme deuxième processeur. </font><font style="vertical-align: inherit;">C'était un préfixe très cher et prestigieux pour 1984. </font><font style="vertical-align: inherit;">Il a été possible de commander un processeur avec des fréquences de 6, 8 et 10 MHz. </font><font style="vertical-align: inherit;">Il y avait quelques problèmes techniques avec ce dernier et c'était très cher. </font><font style="vertical-align: inherit;">Il y avait très peu de logiciels pour 32016, uniquement fabriqués par Acorn, un système d'exploitation Unix de type Panos et Acorn BASIC. </font><font style="vertical-align: inherit;">BBC Micro n'a pas utilisé la puce MMU - bien qu'elle puisse être connectée, il n'y avait aucun programme pour l'utiliser. </font><font style="vertical-align: inherit;">Le coprocesseur arithmétique n'était même pas prévu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce processeur très complexe est connu pour avoir de graves erreurs matérielles qui ont été corrigées depuis des années.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bras gland </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'idéologie du 6502, à savoir, pour le rendre plus simple, moins cher et meilleur, s'est poursuivie dans le développement presque fantastique d'Acorn, le processeur ARM-1, sorti en 1985, en même temps que le miracle technologique d'Intel, le processeur 80386. ARM était composé d'un ordre de grandeur plus petit le nombre de transistors et donc consommé beaucoup moins d'énergie et était en moyenne beaucoup plus rapide. Bien sûr, ARM n'avait pas de MMU ni même d'opérations de division et de multiplication, donc dans certains calculs basés sur la division 80386, cela pourrait être plus rapide. Cependant, les avantages d'ARM étaient si grands qu'aujourd'hui c'est l'architecture de processeur la plus massive. Plus de 100 milliards de ces processeurs ont été libérés.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le développement d'ARM en 1983 a commencé après qu'Acorn a mené des recherches avec le processeur 32016, qui ont montré que, dans de nombreux calculs, 6502 pourrait être la moitié de la fréquence de fonctionnement plus rapide que cela, semble-t-il, un processeur beaucoup plus puissant. Le 80286 était alors déjà disponible, ce qui a montré de très bonnes performances, mais Intel, sentant peut-être le potentiel assez faible de la petite entreprise Acorn, a refusé de fournir son processeur pour les tests. Dans le même temps, la technologie 80286 n'a pas été fermée comme 80386 et a été transférée à de nombreuses entreprises, donc l'histoire attend toujours que les détails de cet échec quelque peu inhabituel soient révélés. Peut-être que si Intel permettait d'utiliser son processeur, Acorn l'utiliserait et ne commencerait pas à développer ARM.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM a été développé par seulement quelques personnes et a testé le système de commande à l'aide de BBC Micro BASIC. Le développement lui-même a eu lieu dans le bâtiment de l'ancienne buanderie, souvent appelée grange ou grange. Les débuts du processeur se sont révélés plutôt infructueux. En 1986, un décodeur BBC Micro avec le nom de système d'évaluation ARM a été publié, contenant en plus du processeur 4 Mo de mémoire (ce qui est beaucoup pour ces années), ce qui a fait de ce décodeur un produit très cher (son prix était supérieur à 4000 £, soit environ environ 6000 $). Bien sûr, si vous le comparez avec des ordinateurs de l'époque avec des capacités comparables en vitesse, le préfixe s'est avéré être un ordre de grandeur ou même presque deux moins cher. Mais il y avait très peu de programmes pour le nouveau système. Et c'est un peu étrangecomme il était tout à fait possible de porter Unix sur ce système - alors de nombreuses variantes Unix étaient disponibles qui ne nécessitaient pas de MMU, il y avait des variantes Unix pour PDP-11, 68000, 80186 et même 8088. Il est curieux que dans les années 90 Acorn Archimedes ait été porté Linux Peut-être que le retard avec l’introduction du vrai Unix pour ARM a été causé par la réticence d’Acorn à transférer la technologie ARM à d’autres entreprises.</font></font><br><br><img src="http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg"><br> <i>    ARM</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La politique de commercialisation quelque peu infructueuse d'Acorn a conduit l'entreprise à une situation financière très difficile en 1985. Acorn, outre ARM, a également tenté de mener un développement coûteux d'ordinateurs pour les entreprises, ce qui a échoué, en particulier, en raison des lacunes du processeur 32016 choisi pour eux. Acorn Communicator n'a pas non plus connu beaucoup de succès. Le développement d'un ordinateur Master 512 relativement réussi, mais pas tout à fait compatible IBM PC était très coûteux. En outre, de nombreuses ressources financières ont été dépensées dans une tentative infructueuse d'entrer sur le marché américain, que la société italienne Olivetti, avec ses ordinateurs plutôt performants basés sur Intel 8086 et 80286, a été autorisée à entrer dans le cadre d'un gros gibier hypothétique pour reprendre Acorn. Au fait, après la prise de contrôle d'Acorn,Le rôle d'Olivetti sur le marché américain a rapidement décliné.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déjà dans le cadre d'Olivetti Acorn a développé une puce ARM2 améliorée avec des commandes de multiplication intégrées, sur la base de laquelle un ordinateur personnel Archimède, qui était alors incroyable à sa vitesse, a été fabriqué, dont les premiers modèles sont devenus disponibles en 1987. Cependant, la direction d'Olivetti était orientée vers le travail avec des ordinateurs compatibles IBM PC et Il ne voulait pas utiliser ses ressources pour vendre des produits Acorn.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM fournit 16 registres 32 bits à utiliser (il y en a en fait plus si l'on prend en compte les registres pour les besoins du système). L'un des registres, R15, comme l'architecture PDP-11, est un compteur de commandes. Presque toutes les opérations sont effectuées en 1 cycle. Des mesures supplémentaires sont nécessaires, en particulier pour les transitions, les multiplications et les accès à la mémoire. En comparaison, avec les principaux processeurs de ces années, ARM se distinguait par l'absence d'une structure aussi typique que la pile. La pile est implémentée, si nécessaire, via l'un des registres. Lors de l'appel de sous-programmes, la pile n'est pas utilisée; à la place, l'adresse de retour est stockée dans un registre qui lui est alloué. Un tel schéma ne fonctionne évidemment pas pour les appels imbriqués, pour lesquels vous devez organiser une pile. Une caractéristique unique d'ARM est la combinaison d'un compteur de commandes, qui est de 26 bits, c'est-à-dire qu'il permet d'adresser jusqu'à 64 Mo avec un registre d'état.Huit bits sont alloués aux drapeaux dans ce registre combiné, deux autres bits supplémentaires dans ce registre sont obtenus en raison du fait que les deux bits inférieurs de l'adresse ne sont pas utilisés, car les codes doivent être alignés sur la bordure d'un mot de 4 octets. Le processeur peut accéder aux octets et aux mots de 4 octets, il ne peut pas accéder directement aux données 16 bits. Les instructions de données ARM sont à 3 adresses. Une caractéristique de l'architecture RISC est l'utilisation de commandes de type registre-mémoire uniquement pour charger et décharger des données. ARM a un sélecteur de bits rapide intégré (Barrel Shifter), qui vous permet de décaler la valeur de l'un des registres de la commande autant de fois que vous le souhaitez sans le coût des cycles d'horloge. Par exemple, multiplier la valeur du registre R0 par 65 en plaçant le résultat dans le registre R1 peut être écrit avec une commande d'addition à cycle uniquemultiplier la valeur du registre R0 par 65 en plaçant le résultat dans le registre R1 peut être écrit avec une seule commande d'addition à un cycle</font></font><br><br><pre> <code class="plaintext">ADD R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et en multipliant par 63 avec la commande</font></font><br><br><pre> <code class="plaintext">RSB R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système de commande a une soustraction en arrière, ce qui permet notamment d'avoir un moins unaire comme cas particulier de cette commande et d'accélérer la procédure de division. ARM a une autre caractéristique unique: toutes ses instructions sont conditionnelles. Il y a 16 cas (combinaisons d'indicateurs) qui se rattachent à chaque instruction. L'instruction n'est exécutée que si l'ensemble actuel de drapeaux correspond à l'ensemble de cette instruction. Dans les processeurs d'autres architectures, une telle exécution n'a lieu, en règle générale, que pour les transitions conditionnelles. Cette fonctionnalité d'ARM permet dans de nombreux cas d'éviter une opération de transition lente. Ce dernier contribue également au fait que lors de l'exécution d'opérations arithmétiques, vous pouvez refuser de définir les drapeaux d'état. Avec ARM, comme le processeur 6809, vous pouvez utiliser des interruptions rapides et régulières. Aussien mode interruption, les registres avec des nombres élevés sont remplacés par des registres système, ce qui rend les gestionnaires d'interruptions plus compacts et plus rapides.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système d'instructions ARM contient beaucoup moins d'instructions de base que le système d'instructions du processeur x86. Mais les instructions elles-mêmes chez ARM sont très flexibles et puissantes. Plusieurs instructions ARM très pratiques et puissantes n'ont pas d'analogues pour 80386, par exemple, RSB (soustraction inverse), BIC (ET avec inversion, PDP-11 a une telle commande), MLA à 4 adresses (multiplication avec sommation), LDM et STM ( chargement ou déchargement de plusieurs registres de la mémoire, similaire à la commande MOVEM pour les processeurs 68k). Presque toutes les instructions ARM sont à 3 adresses et presque toutes les instructions 80386 n'ont pas plus de 2 opérandes. Le système d'instruction ARM est plus orthogonal - tous les registres sont interchangeables, seuls les registres R14 et R15 font exception. La plupart des commandes ARM peuvent nécessiter 3-4 commandes 80386 pour leur émulation, et la plupart des commandes 80386 peuvent être émulées avec 2-3 commandes ARM. Intéressantque l'émulateur IBM PC XT sur le matériel informatique Acorn Archimedes avec un processeur 8 MHz est encore plus rapide qu'un véritable ordinateur PC XT. Sur un ordinateur Commodore Amiga avec un processeur 68000 à 7 MHz, l'émulateur ne peut fonctionner qu'à une vitesse ne dépassant pas 10 à 15% d'un véritable PC XT. Il est également très intéressant de noter que les premiers ordinateurs NeXT avec 25 MHz 68030 ont montré les performances des calculs entiers au même niveau ARM 8 MHz. Apple allait faire de l'ordinateur le successeur d'Apple dans le projet Möbius] [, mais quand il s'est avéré que le prototype de cet ordinateur en mode émulation dépasse non seulement Apple] [, mais aussi le Macintosh basé sur des processeurs 68k, le projet a été fermé!Sur un ordinateur Commodore Amiga avec un processeur 68000 à 7 MHz, l'émulateur ne peut fonctionner qu'à une vitesse ne dépassant pas 10 à 15% d'un véritable PC XT. Il est également très intéressant de noter que les premiers ordinateurs NeXT avec 25 MHz 68030 ont montré les performances des calculs entiers au même niveau ARM 8 MHz. Apple allait fabriquer l'ordinateur successeur d'Apple dans le projet Möbius] [, mais quand il s'est avéré que le prototype de cet ordinateur en mode émulation dépasse non seulement Apple] [, mais aussi le Macintosh basé sur des processeurs 68k, le projet a été fermé!Sur un ordinateur Commodore Amiga avec un processeur 68000 à 7 MHz, l'émulateur ne peut fonctionner qu'à une vitesse ne dépassant pas 10 à 15% d'un véritable PC XT. Il est également très intéressant de noter que les premiers ordinateurs NeXT avec 25 MHz 68030 ont montré les performances des calculs entiers au même niveau ARM 8 MHz. Apple allait faire de l'ordinateur le successeur d'Apple dans le projet Möbius] [, mais quand il s'est avéré que le prototype de cet ordinateur en mode émulation dépasse non seulement Apple] [, mais aussi le Macintosh basé sur des processeurs 68k, le projet a été fermé!que le prototype de cet ordinateur en mode émulation dépasse non seulement Apple] [, mais aussi Macintosh basé sur des processeurs 68k, le projet était clos!que le prototype de cet ordinateur en mode émulation dépasse non seulement Apple] [, mais aussi Macintosh basé sur des processeurs 68k, le projet était clos!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les inconvénients d'ARM, on peut distinguer le problème du chargement d'une constante dans un registre. Vous ne pouvez charger que 8 bits à la fois, bien que la constante puisse être inversée et décalée. Par conséquent, le chargement d'une constante 32 bits complète peut prendre jusqu'à 4 commandes. Vous pouvez bien sûr charger la constante depuis la mémoire avec une seule commande, mais il se pose le problème de spécifier l'adresse de cette quantité, car le décalage ne peut être que de 12 bits. Un autre inconvénient d'ARM est la densité relativement faible des codes, ce qui rend les programmes un peu plus volumineux et, surtout, réduit l'efficacité du cache du processeur. Cependant, c'était probablement plutôt une conséquence des compilateurs de faible qualité pour cette plate-forme. Pendant longtemps, un inconvénient important d'ARM était le manque de prise en charge intégrée de la gestion de la mémoire (MMU) - cette prise en charge, par exemple, était requise par Apple au début des années 90.Les coprocesseurs pour travailler avec des nombres réels pour l'architecture ARM ont également commencé à être utilisés avec un retard important. ARM ne disposait pas des outils de débogage avancés de x86. Il y a encore une certaine bizarrerie dans le langage assembleur standard pour ARM: il est habituel d'écrire des opérations de décalage de bits séparées par des virgules. Ainsi, au lieu d'un simple formulaire</font></font><pre> <code class="plaintext">R1 shl 7</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - décaler le contenu du registre R1 de 7 bits vers la gauche - vous devez écrire </font></font><pre> <code class="plaintext">R1, shl 7</code> </pre>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis 1989, ARM3 avec un cache intégré est devenu disponible. </font><font style="vertical-align: inherit;">En 1990, l'équipe de développement ARM s'est séparée d'Acorn et a créé ARM Holding en utilisant Apple et VLSI. </font><font style="vertical-align: inherit;">Selon la direction d'Acorn-Olivetti, l'une des raisons de la séparation était le coût trop élevé du développement de l'ARM. </font><font style="vertical-align: inherit;">Par la suite, Acorn a cessé son existence indépendante et ARM Holding est devenue une grande entreprise. </font><font style="vertical-align: inherit;">La séparation d'Acorn et d'ARM Holding a également été initiée par le désir d'Apple d'avoir un processeur ARM dans son ordinateur Newton et de ne pas dépendre d'un autre fabricant d'ordinateurs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM a montré des performances sur les données entières, dépassant 80486 à la même fréquence de 10 à 20%! </font><font style="vertical-align: inherit;">Intel a pu profiter des avantages de la technologie de multiplication d'horloge, puis la fixer fermement avec un processeur Pentium. </font><font style="vertical-align: inherit;">DEC StrongARM a pu reprendre le leadership pendant une courte période en 1996, après quoi cette technologie a été achetée par Intel, qui a depuis été un important fabricant de processeurs d'architecture ARM. </font><font style="vertical-align: inherit;">Ainsi, il existe deux centres pour le développement de cette architecture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le développement ultérieur de la technologie ARM est également très curieux, mais c'est une autre histoire. </font><font style="vertical-align: inherit;">Bien que l'on puisse mentionner que c'est grâce à une participation dans ARM Holding qu'Apple dans les années 90 a pu éviter la faillite.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques conclusions, hypothèses et questions. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est difficile de se débarrasser du sentiment que les processeurs 8 bits se sont avérés être juste un besoin indésirable pour les personnages principaux agissant dans les années 70 et 80 sur la scène de l'histoire de l'ordinateur. Le 8-batteur 6502 le plus performant a été gelé. Intel et Motorola ont plutôt ralenti leur propre développement de petits processeurs et restreint d'autres développeurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je suis presque sûr que l'Amiga ou l'Atari ST fonctionnerait mieux et plus rapidement sur un processeur 4 MHz avec une adresse 20 ou 24 bits compatible avec 6502 qu'avec 68000. Bill Mensch a récemment déclaré que 6502 à 10 GHz n'est pas difficile à faire aujourd'hui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la série Amstrad PCW, dont le succès pourrait être partagé par le Commodore CBM II, a commencé à utiliser le z80 optimisé à des fréquences plus élevées, il est fort possible que cette série soit pertinente il y a 10 ans.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À quoi ressemblerait le monde si ARM était fabriqué en 1982, ce qui était tout à fait possible? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À quoi ressembleraient les ordinateurs domestiques s'ils copiaient et développaient non pas les technologies les plus chères mais les plus prometteuses?</font></font><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr410591/">https://habr.com/ru/post/fr410591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr410581/index.html">L'abus d'alcool est le moyen le plus rapide de démence</a></li>
<li><a href="../fr410583/index.html">Samsung Gear VR: impressions après un mois d'utilisation</a></li>
<li><a href="../fr410585/index.html">Comment devenir magicien (partie 1)</a></li>
<li><a href="../fr410587/index.html">Apple a l'intention d'acheter du cobalt exclusivement auprès de sociétés minières</a></li>
<li><a href="../fr410589/index.html">Des écosystèmes marins capables de s'adapter au réchauffement climatique</a></li>
<li><a href="../fr410593/index.html">Telegram mène une nouvelle série d'ICO</a></li>
<li><a href="../fr410597/index.html">Un autre appareil domestique intelligent</a></li>
<li><a href="../fr410599/index.html">Une vague de vols d'équipement dans les exploitations minières a balayé l'Islande</a></li>
<li><a href="../fr410601/index.html">Qu'est-ce que la robotique éducative aujourd'hui</a></li>
<li><a href="../fr410603/index.html">Manifeste de bienséance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>