<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏾 🐵 🍅 在Unity中创建配色效果 ✌🏿 🐖 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这种效果的灵感来自飞天小女警 。 我想创建一个在黑白世界中传播颜色的效果，但要在世界空间的坐标中实现它 ，以观察颜色是如何绘制对象的 ，而不是像卡通一样在屏幕上平展地传播。 

 我在Unity引擎的新轻量级渲染管道中创建了效果，这是可脚本化渲染管道管道的内置示例。 所有概念都适用于其他管道，但是某...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中创建配色效果</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436456/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br> 这种效果的灵感来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">飞天小女警</a> 。 我想创建一个在黑白世界中传播颜色的效果，但要<strong>在世界空间的坐标中实现它</strong> ，以观察<strong>颜色是</strong>如何<strong>绘制对象的</strong> ，而不是像卡通一样在屏幕上平展地传播。 <br><br> 我在Unity引擎的新<strong>轻量级渲染管道中</strong>创建了效果，这是可脚本化渲染管道管道的内置示例。 所有概念都适用于其他管道，但是某些内置函数或矩阵可能具有不同的名称。 我也使用了新的后处理堆栈，但是在本教程中，我将省略其设置的详细说明，因为在其他手册中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对此视频</a>进行了很好的描述。 <br><a name="habracut"></a><br><hr><br><h1> 灰度后处理的效果 </h1><br> 仅供参考，这是没有后处理效果的场景。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br> 为此，我使用了新的Unity 2018 Post-Processing程序包，可以从程序包管理器中下载该程序包。 如果您不知道如何使用它，那么我推荐<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本教程</a> 。 <br><br> 我通过扩展用C＃编写的PostProcessingEffectSettings和PostProcessEffectRenderer类来编写自己的效果，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处查看</a>其源代码。 实际上，除了在Inspector中添加了一组常规属性外，我并没有对CPU端的这些效果进行任何特别有趣的操作（使用C＃代码），因此在本教程中不会解释如何执行此操作。 我希望我的代码能说明一切。 <br><br> 让我们继续着色器代码，并从灰度效果开始。 在本教程中，我们将不会修改shaderlab文件，输入结构和顶点着色器，因此您可以<a href="">在此处</a>查看其源代码。 相反，我们将处理片段着色器。 <br><br> 为了将颜色转换为灰度，我们<strong>将每个像素的值减小为</strong>描述其<strong>亮度</strong> <strong>的亮度值</strong> 。 这可以通过获取<strong>相机纹理的颜色值</strong>和<strong>加权矢量</strong>的标量积来完成，该标量积描述了每个颜色通道对总体颜色亮度的贡献。 <br><br>  <strong>为什么使用标量积？</strong> 不要忘记标量积的计算如下： <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br> 在这种情况下，我们将<strong>颜色值</strong>的每个通道乘以<strong>weight</strong> 。 然后，我们将这些乘积相加，以将它们减小到一个标量值。 当RGB颜色在R，G和B通道中具有相同的值时，该颜色变为灰色。 <br><br> 着色器代码如下所示： <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br> 如果基本着色器配置正确，则后处理效果应以灰度为整个屏幕着色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1> 在世界空间中渲染色彩效果 </h1><br> 由于这是后处理效果，因此在顶点着色器中<strong>我们没有有关</strong>场景<strong>几何的任何信息</strong> 。 在后期处理阶段，我们仅有的信息是<strong>相机渲染的图像</strong>以及用于对其进行采样<strong>的截断坐标</strong>的<strong>空间</strong> 。 但是，我们希望着色效果能够像在世界上一样发生在整个对象上，而不仅仅是在纯平屏幕上。 <br><br> 要在场景的几何图形中绘制此效果，我们需要每个像素<strong>的世界空间</strong>的<strong>坐标</strong> 。 要从<strong>截断坐标空间的坐标移动</strong>到<strong>世界空间</strong>的<strong>坐标</strong> ，我们需要对<strong>坐标空间</strong>进行<strong>转换</strong> 。 <br><br> 通常，要从一个坐标空间转到另一个坐标空间，需要一个矩阵来定义从坐标空间A到空间B的变换。要从A到B，我们将坐标空间A中的向量乘以此变换矩阵。 在我们的例子中，我们将执行以下转换： <strong>截断坐标</strong>的<strong>空间（剪辑空间）</strong> -&gt; <strong>视图空间（视图空间）</strong> -&gt; <strong>世界空间（世界空间）</strong> 。 也就是说，我们需要Unity提供的剪辑到视图空间矩阵和视图到世界空间矩阵。 <br><br> 但是， <strong>截断坐标空间</strong>的<strong>Unity坐标没有z值</strong> ， <strong>该z值</strong>确定像素的深度或到相机的距离。 我们需要此值从截断的坐标空间移动到物种空间。 让我们开始吧！ <br><br><h2> 获取深度缓冲区值 </h2><br> 如果启用了渲染管线，则它将在<strong>视口中</strong>绘制纹理，该纹理<strong>将z值</strong>存储<strong>在</strong>称为<strong>depth buffer</strong>的结构中。 我们可以对该缓冲区进行采样，以获得截断坐标的坐标空间的丢失<strong>z值</strong> ！ <br><br> 首先，通过在检查器中单击相机的“添加其他数据”部分，并选中“需要深度纹理”复选框，确保<strong>深度缓冲区已</strong>真正渲染。 还要确保为相机启用了“允许MSAA”选项。 我不知道为什么需要检查这种效果，但是确实如此。 如果绘制了深度缓冲区，则在<strong>帧调试器中，</strong>您应该看到<strong>“深度预通过”</strong>阶段。 <br><br> 在<strong>hlsl文件中</strong>创建_CameraDepthTexture采样器 <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br> 现在让我们编写GetWorldFromViewPosition函数，现在我们将使用它来检查<strong>depth buffer</strong> 。  （稍后我们将对其进行扩展以在世界上占有一席之地。） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br> 在片段着色器中，绘制深度纹理样本的值。 <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br> 当场景中只有一个丘陵平原时，这就是我的结果（我关闭了所有树木，以进一步简化对世界空间值的测试）。 您的结果应该看起来相似。 黑白值描述了从几何图形到相机的距离。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br> 如果遇到问题，可以采取以下步骤： <br><br><ul><li> 确保相机启用了深度渲染。 </li><li> 确保相机已启用MSAA。 </li><li> 尝试改变相机的近和远平面。 </li><li> 确保您希望在深度缓冲区中看到的对象使用具有深度传递的着色器。 这样可以确保对象绘制到深度缓冲区。  LWRP中的所有标准着色器都可以执行此操作。 </li></ul><br><h2> 在世界空间获取价值 </h2><br> 现在我们有了<strong>截断坐标空间</strong>所需的所有信息，让我们转换为<strong>物种空间</strong> ，然后转换为<strong>世界空间</strong> 。 <br><br> 请注意，这些操作所需的转换矩阵已经在SRP库中。 但是，它们包含在Unity引擎的C＃库中，因此我将它们插入<a href="">ColorSpreadRenderer</a>脚本的Render函数中的着色器中： <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br> 现在，让我们扩展GetWorldFromViewPosition函数。 <br><br> 首先，我们需要通过<strong>将截断坐标空间中的位置乘以InverseProjectionMatrix</strong>来获得视口中<strong>的位置</strong> 。 我们还需要使用屏幕位置来做更多的巫毒术，这与Unity如何在截断坐标的空间中存储其位置有关。 <br><br> 最后，我们可以<strong>将视口中的位置乘以ViewToWorldMatrix</strong>以获得<strong>世界空间中</strong>的位置。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; //      float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; //      float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br> 让我们进行检查以确保全局空间中的位置正确。 为此，我编写了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a>仅返回对象在<strong>世界空间中</strong>的位置； 这是基于常规着色器的相当简单的计算，其正确性可以信赖。 关闭后处理效果，并为<strong>世界空间</strong>拍摄此测试着色器的屏幕快照。 在将着色器应用于场景中的地球表面后，我的样子如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  （请注意，世界空间中的值远大于1.0，因此请不必担心这些颜色是否有意义；相反，只需确保“真”和“计算”答案的结果相同即可。）接下来，让我们返回测试该对象是普通材料（而不是世界空间的测试材料），然后再次启用后处理效果。 我的结果如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br> 这与我编写的测试着色器完全相似，也就是说，世界空间的计算很可能是正确的！ <br><br><h2> 在世界空间中画一个圆 </h2><br> 现在我们<strong>在世界空间中</strong>有了<strong>位置</strong> ，我们可以在场景中绘制一个颜色的圆圈！ 我们需要设置效果将在其中绘制颜色的<strong>半径</strong> 。 在外部，效果将以灰度渲染图片。 要进行设置，您需要调整效果<strong>半径</strong> （ <strong>_MaxSize</strong> ）和圆心（_Center）的值。 我在C＃ <a href="">ColorSpread</a>类中设置了这些值，以便它们在检查器中可见。 让我们通过强制其<strong>检查当前像素是否在圆半径内来</strong>扩展片段着色器： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// ,      .  //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; //   float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); //   float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // ,       float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br> 最后，我们可以根据颜色是否在<strong>世界空间</strong>的<strong>半径</strong>内绘制颜色。 这就是基本效果！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1> 添加特殊效果 </h1><br> 我将介绍几种用于使颜色分布在整个地面上的技术。 完整的效果还有很多，但是本教程已经变得太大了，因此我们将自己限制在最重要的位置。 <br><br><h2> 圆扩大动画 </h2><br> 我们希望这种影响扩散到整个世界，即好像在增长。 为此，您需要根据时间更改<strong>半径</strong> 。 <br><br>  _StartTime指示圆应开始增长的时间。 在我的项目中，我使用了一个额外的脚本，该脚本允许您单击屏幕上的任意位置以开始圈的增长。 在这种情况下，开始时间等于单击鼠标的时间。 <br><br>  _GrowthSpeed设置增加圆的速度。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); //  ,      effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br> 我们还需要更新距离检查，以将当前距离与<strong>效果</strong>增加的<strong>半径进行比较</strong> ，而不是与_MaxSize进行比较。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; //     ...</span></span></code> </pre> <br> 结果如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2> 增加了噪声的半径 </h2><br> 我希望效果更像是模糊的油漆，而不仅仅是一个不断扩大的圆圈。 为此，让我们<strong>在效果的半径中添加噪点，以</strong>使分布不均匀。 <br><br> 首先，我们需要对<strong>世界空间中</strong>的纹理进行采样。  i.screenPos的UV坐标位于<strong>屏幕空间中</strong> ，如果我们基于它们进行采样，效果的形状将随相机一起移动； 因此，让我们使用<strong>世界空间中</strong>的坐标。 我添加了<strong>_NoiseTexScale</strong>参数来控制<strong>噪声纹理样本</strong>的<strong>比例</strong> ，因为世界空间中的坐标非常大。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br> 现在，让我们对噪声纹理进行采样，并将此值添加到效果的半径。 我使用_NoiseSize缩放比例来更好地控制噪声大小。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br> 经过一些调整后，结果如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1> 总结 </h1><br> 您可以在我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter</a>上关注这些教程的更新，而在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitch</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上</a> ，我会花很多时间编写代码流！  （此外，我会不时播放游戏，因此，如果您看到我坐在睡衣上玩《王国之心3》，请不要感到惊讶。） <br><br> 致谢： <br><br><ul><li> 所有项目模型均从Unity商店的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LowPoly环境包中</a>获取。 </li><li>  <a href="">Unity引擎的ScreenSpaceReflections效果</a>确实帮助我了解了如何从屏幕空间的二维UV坐标获取视口中的三维位置。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436456/">https://habr.com/ru/post/zh-CN436456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436444/index.html">在AWS上的生产中无形部署整体应用程序。 个人经历</a></li>
<li><a href="../zh-CN436448/index.html">评测27英寸IPS显示器Acer HA270bid：自我完善</a></li>
<li><a href="../zh-CN436450/index.html">远程控制，自由与政府。 与Staply对话</a></li>
<li><a href="../zh-CN436452/index.html">2019年Linux开发的7个领域</a></li>
<li><a href="../zh-CN436454/index.html">JavaScript问答</a></li>
<li><a href="../zh-CN436458/index.html">AI研究的进展和炒作</a></li>
<li><a href="../zh-CN436460/index.html">在软件项目中选择技术，架构和设计-无需现金</a></li>
<li><a href="../zh-CN436464/index.html">2.检查点日志分析：SmartEvent</a></li>
<li><a href="../zh-CN436466/index.html">电子：使用HTML，CSS和JavaScript开发桌面应用程序</a></li>
<li><a href="../zh-CN436468/index.html">进行数字创新的立法实验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>