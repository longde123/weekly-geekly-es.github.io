<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•É üë©üèΩ‚Äçü§ù‚Äçüë®üèø üî° CSS-√úberlauf und Datenverlust ‚è∏Ô∏è ü§∑ üë®üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel beschreibt Rachel Andrew Situationen, in denen es zu √úberl√§ufen im Site-Layout kommen kann, und erl√§utert, wie sich CSS entwickelt h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS-√úberlauf und Datenverlust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466665/"><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br>  In diesem Artikel beschreibt Rachel Andrew Situationen, in denen es zu √úberl√§ufen im Site-Layout kommen kann, und erl√§utert, wie sich CSS entwickelt hat, um effizientere Layoutmethoden in Situationen zu erstellen, in denen das Inhaltsvolumen nicht im Voraus bekannt ist. <br><a name="habracut"></a><br><hr><br>  CSS wurde entwickelt, um den Inhalt lesbar zu machen.  Wenn Sie ein HTML-Dokument anzeigen, das mit √úberschriften und Abs√§tzen (ohne CSS) gekennzeichnet ist, wird es in einem Browser in einer leicht lesbaren Form angezeigt.  Die √úberschriften sind gro√ü und fett, und zwischen den Abs√§tzen verbleibt ein Leerzeichen, das durch im Browser integrierte Stylesheets gesteuert wird.  Sobald Sie jedoch das Layout der Seite √§ndern m√ºssen, √ºbernehmen Sie die Kontrolle √ºber das Design selbst.  In einigen Situationen bedeutet dies, dass Sie die Arbeit mit √ºberf√ºllten Elementen √ºbernehmen. <br><br>  In diesem Artikel werde ich verschiedene Situationen betrachten, in denen es im Web zu einem √úberlauf kommen kann.  Wir werden sehen, wie neue Markup-Methoden und neue CSS-Werte uns helfen k√∂nnen, mit √úberl√§ufen umzugehen und weniger fragile Designs zu erstellen.  Ich werde auch eines der grundlegenden Konzepte erl√§utern, die dem CSS-Design zugrunde liegen - die Verhinderung von Datenverlust. <br><br><h2>  Was verstehen wir unter √úberlauf? </h2><br>  Wenn Sie einige Jahre zur√ºckgehen (vor dem Aufkommen von Layoutmethoden wie Flexbox und Grid), √ºberlegen Sie, wie Sie das unten gezeigte Beispiel implementieren w√ºrden.  Ein sehr einfaches Layout aus drei Bl√∂cken mit unterschiedlichem Inhalt, dessen unterer Rand sich jedoch in derselben Zeile befinden sollte. <br><br><img src="https://habrastorage.org/webt/gt/vf/hg/gtvfhgx4qssj5ipb-epo-alqk-o.jpeg"><br><br>  Mit float war diese scheinbar einfache Aufgabe unm√∂glich.  Wenn ein Block rationalisiert wird (float), interagiert er nicht mit seinen Nachbarn.  Dies bedeutet, dass es keine M√∂glichkeit gibt, zu erkennen, was das n√§chste Element h√∂her ist, und den Strom auf die gleiche H√∂he zu erh√∂hen. <br><br><img src="https://habrastorage.org/webt/za/_y/i3/za_yi3eklarqeo31uherxd4i-fu.jpeg"><br><br>  Manchmal haben Entwickler beim Versuch, Elemente in einer einzigen Zeile anzuordnen, eine feste Blockh√∂he festgelegt und versucht, die Menge des m√∂glichen Inhalts vorherzusagen, um die H√∂he gleich zu machen.  Nat√ºrlich ist das Web nicht so einfach, und wenn die Menge des Inhalts unterschiedlich war oder die Textgr√∂√üe gr√∂√üer wurde, begann der Text √ºber den unteren Rand des Blocks hinauszugehen.  Dies war ein √úberlauf. <br><br><img src="https://habrastorage.org/webt/e3/6w/jq/e36wjqxw2vqxnfejadqygan3iuk.jpeg"><br><br>  Manchmal fragen die Leute, wie sie verhindern k√∂nnen, dass zu viel Inhalt auf die Website gelangt.  Der technische Support meines CMS wurde von Benutzern kontaktiert, die fragten, wie der Inhalt aus genau diesem Grund eingeschr√§nkt werden kann.  Sie sagten, dass dieser zus√§tzliche Inhalt ‚Äûdas Layout bricht‚Äú.  F√ºr diejenigen von uns, die verstanden haben, dass die Unf√§higkeit, die H√∂he der Elemente zu kennen, die grundlegende Natur des Layouts ist, waren wir gezwungen, Layouts zu erstellen, die das Fehlen von Bl√∂cken gleicher H√∂he verbergen.  Eine √ºbliche L√∂sung bestand darin, einen Farbverlauf hinzuzuf√ºgen, der dazu f√ºhrt, dass Inhalte verschwinden, die √ºber die Grenzen hinausgehen.  Wir w√ºrden die Verwendung von Hintergrundfarben und Blockrahmen vermeiden.  Oder wir w√ºrden k√ºnstliche S√§ulentechniken verwenden, um die H√∂he der Elemente gleich zu machen. <br><br>  Diese Unf√§higkeit, die H√∂he eines Elements im Verh√§ltnis zu anderen zu steuern, beeinflusste daher das Webdesign - eine technische Einschr√§nkung ver√§nderte die Art und Weise, wie Websites gestaltet wurden.  Ich bin froh, dass mit dem Aufkommen von Flexbox und Grid dieses Problem nicht nur verschwunden ist, sondern das Verhalten dieser neuen Layoutmethoden die Bl√∂cke standardm√§√üig auf dieselbe H√∂he streckt.  Der Anfangswert der Eigenschaft " <code>align-items - stretch</code> , wodurch die Bl√∂cke auf die H√∂he des Rasterbereichs oder des Flex-Containers gedehnt werden. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/VwZzxjV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dar√ºber hinaus bietet uns CSS Grid eine gute M√∂glichkeit, Elementen eine bestimmte Gr√∂√üe zuzuweisen, sie jedoch bei Bedarf wachsen zu lassen.  Wenn Sie die Gr√∂√üe der Spur (Spalte oder Linie) mit der Funktion minmax () festlegen, k√∂nnen Sie deren minimale und maximale Gr√∂√üe anzeigen.  Wenn Sie die Linien auf <code>minmax(200px, auto)</code> bedeutet dies, dass die Spur immer mindestens 200px gro√ü ist, auch wenn die <code>minmax(200px, auto)</code> leer sind.  Wenn der Inhalt des Rasterelements jedoch dank des Werts von <code>auto</code> mehr als 200 Pixel betr√§gt <code>auto</code> dieses Element wachsen.  Sie k√∂nnen es im folgenden Beispiel sehen.  Die erste Zeile ist 200px, da es keine Elemente gibt, um sie zu erh√∂hen.  Die zweite Zeile enth√§lt ein Rasterelement, dessen Inhalt nicht passt und dessen <code>auto</code> Wert zu funktionieren beginnt, wodurch die Zeile gr√∂√üer als 200 Pixel wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/zYOdjKP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mit der Funktion <code>minmax()</code> k√∂nnen Sie Schnittstellen so erstellen, als ob sie eine perfekte feste Gr√∂√üe h√§tten.  In einer idealen Welt (wenn die Menge an Inhalten den Erwartungen entspricht) erhalten Sie diese sch√∂nen, identischen Linien.  Wenn Sie jedoch zus√§tzlichen Inhalt hinzuf√ºgen, tritt kein √úberlauf auf, als ob Sie die feste Zeilenh√∂he auf 200 Pixel einstellen w√ºrden.  Die Zeichenfolge wird erweitert.  Es ist m√∂glicherweise nicht genau das, was Sie als Entwickler m√∂chten, aber es wird nicht unlesbar sein. <br><br><h2>  Leitungs√ºberlauf </h2><br>  Das Risiko eines √úberlaufs besteht immer dann, wenn wir die Gr√∂√üe der Elemente begrenzen.  Im obigen Beispiel beschreibe ich eine Einschr√§nkung in einer Blockdimension, die Benutzer mit horizontaler Sprache als H√∂he wahrnehmen.  Es kann jedoch auch zu einem √úberlauf kommen, wenn wir die Breite des Blocks begrenzen.  Dies ist, was wir im CSS is Awesome Meme sehen. <br><br><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br><br>  Der Autor dieses Memes kommentierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen CSS-Trick-Beitrag</a> dazu mit den Worten: <br><blockquote>  <i>Jetzt verstehe ich das Konzept des √úberlaufs ein wenig besser, aber zu dieser Zeit war mein Gehirn einfach √ºberw√§ltigt von dem Unverst√§ndnis, warum jemand dachte, dass das Standardverhalten den Text einfach nach rechts vom Block schieben sollte, anstatt den Block gr√∂√üer zu machen, wie es die Tabellen immer taten .</i> <br></blockquote>  Warum schiebt CSS Text √ºber den Rahmen hinaus, anstatt den Block selbst zu vergr√∂√üern? <br><br>  Es stellt sich heraus, dass das Mem in Zeilenrichtung √ºberl√§uft.  Das Wort ‚Äûfantastisch‚Äú ist gr√∂√üer als die Breite, die auf den Block angewendet wird, weshalb er √ºberl√§uft.  CSS geht vern√ºnftigerweise davon aus, dass Sie einen Block mit genau dieser Breite ben√∂tigen, wenn Sie einem Block eine bestimmte Breite geben.  Vielleicht sollte er ein Layout einf√ºgen, das kaputt geht, wenn die Bl√∂cke pl√∂tzlich gr√∂√üer werden als festgelegt. <br><br>  Dieses spezielle Problem (dh die Notwendigkeit, die Abmessungen f√ºr alle Layoutelemente festzulegen und sicherzustellen, dass sie den verf√ºgbaren Containerraum insgesamt nicht √ºberschreiten) ist das Problem, das moderne Layoutmethoden f√ºr uns l√∂sen.  Wenn wir uns vorstellen, dass unser Block eine so speziell ausgew√§hlte Gr√∂√üe hat, dass sie in eine Reihe mit anderen Bl√∂cken in einem Float-Raster passt, k√∂nnen Sie heute stattdessen Flexbox verwenden. <br><br>  Wenn Sie ein Float-Layout verwenden, sollten Sie die Gr√∂√üe jedes Elements festlegen - m√∂glicherweise bevor Sie wissen, wie sein Inhalt aussehen wird.  In diesem Fall stellen Sie m√∂glicherweise fest, dass sich gro√üe Inhalte in kleinen Containern befinden und kleine Inhalte zus√§tzlichen Platz haben. <br><br><img src="https://habrastorage.org/webt/dw/1k/um/dw1kumj10p4gf265pnrdc2htg9g.jpeg"><br><br>  Wenn wir jedoch Flexbox verwenden, kann der Browser berechnen, wie viel Speicherplatz jedem Element zugewiesen werden soll.  Flexbox bietet gr√∂√üeren Artikeln mehr Platz, w√§hrend kleinere weniger Platz erhalten.  Diese flexible Gr√∂√üenverteilung bedeutet, dass der Block, der das Wort "awesome" enth√§lt, vergr√∂√üert wird, um den gesamten Inhalt aufzunehmen, und der Text nicht dar√ºber hinausgeht.  √úberlaufproblem behoben;  F√ºr dieses Verhalten wurde Flexbox genau erstellt.  Flexbox leistet hervorragende Arbeit mit Elementen unterschiedlicher Gr√∂√üe und organisiert sie in dem f√ºr sie am besten geeigneten Layout. <br><br><img src="https://habrastorage.org/webt/j6/cg/vp/j6cgvpadsslenylgg_cew86amya.jpeg"><br><br>  Au√üerhalb von Flexbox k√∂nnen wir sagen, dass unser Block so gro√ü wie n√∂tig f√ºr den Inhalt sein sollte und nicht mehr.  Das Schl√ºsselwort min-content kann als Wert f√ºr die Eigenschaft width oder inline-size verwendet werden, wenn mit logischen Eigenschaften gearbeitet wird, die sich auf einen Stream beziehen.  Set width: min-content und der Block w√§chst genug, um das Wort "awesome" aufzunehmen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/LYPjmbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Verhinderung von Datenverlust </h2><br>  Der Grund f√ºr den Block√ºberlauf (wie im Beispiel mit einem Wort, das √ºber die Blockgrenze hinausgeht) liegt darin, dass die <code>overflow</code> Standardwert <code>visible</code> .  Sie k√∂nnen den √úberlauf (wenn Sie m√∂chten) auf andere Weise steuern.  Wenn Sie beispielsweise <code>overflow: auto</code> oder <code>overflow: scroll</code> verwenden, kann Ihr Block eine Bildlaufleiste erhalten.  Dies ist m√∂glicherweise nicht das, was Sie in dieser Situation m√∂chten, aber es kann Situationen geben, in denen ein Block mit einer Bildlaufleiste geeignet ist. <br><br>  Sie k√∂nnen auch davon ausgehen, dass Sie bereit sind, den √úberlauf mithilfe von <code>overflow: hidden</code> .  Sie haben vielleicht gedacht, dass das Ausblenden von √úberl√§ufen standardm√§√üig besser ist. Die Tatsache, dass CSS den √úberlauf standardm√§√üig sichtbar (und nicht ausgeblendet) gemacht hat, ist der Schl√ºssel zum Kernwert der CSS-Entwicklung.  In CSS (wie in vielen anderen Technologien) versuchen wir, Datenverlust zu vermeiden.  Wenn wir √ºber Datenverlust in CSS sprechen, sprechen wir normalerweise √ºber den Teil des Inhalts, der nicht sichtbar ist.  Im Fall von <code>overflow: hidden</code> der Inhalt, der den √ºbergeordneten Block √ºberl√§uft.  Dies bedeutet, dass wir keine M√∂glichkeit haben, dorthin zu gelangen und herauszufinden, welchen Teil wir verloren haben. <br><br>  In bestimmten Situationen kann dies ein ernstes Problem sein.  Wenn Sie es geschafft haben, das Layout so fragil zu gestalten, dass die Schaltfl√§che in Ihrem Formular √ºber den sichtbaren Bereich hinausgeht, k√∂nnen Ihre Benutzer das Formular nicht senden.  Wenn der letzte Absatz des Textes abgeschnitten wird, werden wir nie wissen, wie die Geschichte endete.  Das Problem beim Verschwinden von Elementen ist auch, dass es nicht immer offensichtlich ist, dass sie verschwunden sind.  Als Entwickler bemerken Sie das Problem m√∂glicherweise nicht, insbesondere wenn dies nur bei bestimmten Anzeigebereichsgr√∂√üen in einem ansprechenden Design auftritt.  Ihre Benutzer bemerken das Problem m√∂glicherweise nicht - sie sehen den Aufruf zum Handeln einfach nicht oder sie denken, dass das Problem, bei dem sie keine Bestellung aufgeben k√∂nnen, in ihrem Ger√§t liegt und sie gehen einfach.  Wenn die Elemente jedoch dort √ºberlaufen, wo sie nicht sollten, werden Sie dies h√∂chstwahrscheinlich bemerken.  Im schlimmsten Fall wird dies jemand bemerken, der die Website besucht, und Sie dar√ºber informieren. <br><br>  Deshalb sind in CSS Elemente √ºberf√ºllt schlampig und ziemlich auff√§llig.  Wenn Sie den √úberlauf explizit sehen, ist es wahrscheinlicher, dass Sie den Fehler korrigieren, als wenn der √ºbersch√ºssige Inhalt einfach ausgeblendet wird.  Mithilfe der √úberlaufeigenschaft erhalten Sie jedoch die M√∂glichkeit, Ihre eigenen Entscheidungen dar√ºber zu treffen, was passieren soll.  Wenn Sie m√∂chten, dass der √úberlauf abgeschnitten wird (was in bestimmten Situationen die richtige L√∂sung sein kann), verwenden Sie <code>overflow: hidden</code> . <br><br><h2>  Datenverlust und Ausrichtung </h2><br>  Die besten Leveling-Tools, die wir in den letzten Jahren erhalten haben, k√∂nnen auch zu Datenverlust f√ºhren.  Stellen Sie sich eine Spalte mit Flex-Elementen vor, die sich am Rand des Ansichtsfensters befinden und unterschiedliche Gr√∂√üen haben.  Bei Ausrichtung mit dem <code>flex-start</code> Wert ragen die Elemente nach rechts heraus.  Wenn es jedoch mit der <code>center</code> zentriert <code>center</code> , √ºberschreitet das breitere Element die Grenzen des Ansichtsfensters.  Daher kann die Ausrichtung zu Datenverlust f√ºhren. <br><br>  Um versehentlichen Datenverlust durch Ausrichtung zu vermeiden, verf√ºgt CSS jetzt √ºber mehrere neue Schl√ºsselw√∂rter, die in Verbindung mit Ausrichtungseigenschaften verwendet werden k√∂nnen.  Sie werden in Box Alignment definiert, einer Spezifikation, die sich mit der Ausrichtung in allen Entwurfsmethoden befasst, einschlie√ülich Grid und Flexbox.  Sie werden derzeit nur in Firefox unterst√ºtzt.  Wenn wir in unserem obigen Beispiel <code>align-items: safe center</code> festlegen <code>align-items: safe center</code> , wird das letzte Element linksb√ºndig und nicht zentriert.  Dadurch wird ein Datenverlust verhindert, der durch das Zentrieren des Elements verursacht wird, und daher aus dem Ansichtsfenster verschoben. <br><br>  Wenn Sie eine Ausrichtung ben√∂tigen (auch wenn dies zu einem √úberlauf f√ºhrt), k√∂nnen Sie ein <code>unsafe center</code> angeben.  In diesem Fall haben Sie den Browser aufgefordert, die Ausrichtung Ihrer Wahl durchzuf√ºhren, unabh√§ngig davon, was mit dem Inhalt geschieht.  Wenn Sie Firefox haben, sehen Sie zwei Beispiele: das erste mit sicherer Ausrichtung und das zweite mit unsicherer Ausrichtung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/QWLMrpE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> , auf dessen Grundlage ich diesen Artikel geschrieben habe, habe ich das Layout als <b>st√§ndigen Kampf gegen den √úberlauf beschrieben</b> .  Eine der Designwahrheiten f√ºr das Web ist, dass es sehr schwierig ist zu wissen, wie gro√ü das Element sein wird, das den Text enth√§lt.  Wie ich oben gezeigt habe, hatten wir jedoch noch nie so viele M√∂glichkeiten, √úberl√§ufe oder √úberl√§ufe zu kontrollieren.  Dies bedeutet, dass unser Layout viel nachhaltiger sein kann und wir Vorlagen erstellen k√∂nnen, die mit unterschiedlichen Mengen an Inhalten arbeiten.  Dies scheint nur eine kleine Ver√§nderung zu sein, aber ich denke, dass die M√∂glichkeiten, die sie uns er√∂ffnen, enorm sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466665/">https://habr.com/ru/post/de466665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466653/index.html">Debugging-Spiele f√ºr NES: wie es heute passiert</a></li>
<li><a href="../de466657/index.html">Dynamisches Detail: verdeckte Compiler-Spiele, Speicherverlust, Leistungsnuancen</a></li>
<li><a href="../de466659/index.html">Kubecost Bewertung, um Geld f√ºr Kubernetes in den Wolken zu sparen</a></li>
<li><a href="../de466661/index.html">Fernstudium im Ausland: Notizen vor der Arbeit</a></li>
<li><a href="../de466663/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
<li><a href="../de466667/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 379 (2. - 8. September 2019)</a></li>
<li><a href="../de466669/index.html">Tesla entwickelt Batterien, die 1,6 Millionen km ohne Ersatz laufen k√∂nnen</a></li>
<li><a href="../de466671/index.html">PHP Digest Nr. 164 (27. August - 9. September 2019)</a></li>
<li><a href="../de466673/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 46. OSPF-Leistungspr√ºfung</a></li>
<li><a href="../de466675/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 47. OSPF-Fehlerbehebung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>