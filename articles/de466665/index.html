<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 👩🏽‍🤝‍👨🏿 🔡 CSS-Überlauf und Datenverlust ⏸️ 🤷 👨🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel beschreibt Rachel Andrew Situationen, in denen es zu Überläufen im Site-Layout kommen kann, und erläutert, wie sich CSS entwickelt h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS-Überlauf und Datenverlust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466665/"><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br>  In diesem Artikel beschreibt Rachel Andrew Situationen, in denen es zu Überläufen im Site-Layout kommen kann, und erläutert, wie sich CSS entwickelt hat, um effizientere Layoutmethoden in Situationen zu erstellen, in denen das Inhaltsvolumen nicht im Voraus bekannt ist. <br><a name="habracut"></a><br><hr><br>  CSS wurde entwickelt, um den Inhalt lesbar zu machen.  Wenn Sie ein HTML-Dokument anzeigen, das mit Überschriften und Absätzen (ohne CSS) gekennzeichnet ist, wird es in einem Browser in einer leicht lesbaren Form angezeigt.  Die Überschriften sind groß und fett, und zwischen den Absätzen verbleibt ein Leerzeichen, das durch im Browser integrierte Stylesheets gesteuert wird.  Sobald Sie jedoch das Layout der Seite ändern müssen, übernehmen Sie die Kontrolle über das Design selbst.  In einigen Situationen bedeutet dies, dass Sie die Arbeit mit überfüllten Elementen übernehmen. <br><br>  In diesem Artikel werde ich verschiedene Situationen betrachten, in denen es im Web zu einem Überlauf kommen kann.  Wir werden sehen, wie neue Markup-Methoden und neue CSS-Werte uns helfen können, mit Überläufen umzugehen und weniger fragile Designs zu erstellen.  Ich werde auch eines der grundlegenden Konzepte erläutern, die dem CSS-Design zugrunde liegen - die Verhinderung von Datenverlust. <br><br><h2>  Was verstehen wir unter Überlauf? </h2><br>  Wenn Sie einige Jahre zurückgehen (vor dem Aufkommen von Layoutmethoden wie Flexbox und Grid), überlegen Sie, wie Sie das unten gezeigte Beispiel implementieren würden.  Ein sehr einfaches Layout aus drei Blöcken mit unterschiedlichem Inhalt, dessen unterer Rand sich jedoch in derselben Zeile befinden sollte. <br><br><img src="https://habrastorage.org/webt/gt/vf/hg/gtvfhgx4qssj5ipb-epo-alqk-o.jpeg"><br><br>  Mit float war diese scheinbar einfache Aufgabe unmöglich.  Wenn ein Block rationalisiert wird (float), interagiert er nicht mit seinen Nachbarn.  Dies bedeutet, dass es keine Möglichkeit gibt, zu erkennen, was das nächste Element höher ist, und den Strom auf die gleiche Höhe zu erhöhen. <br><br><img src="https://habrastorage.org/webt/za/_y/i3/za_yi3eklarqeo31uherxd4i-fu.jpeg"><br><br>  Manchmal haben Entwickler beim Versuch, Elemente in einer einzigen Zeile anzuordnen, eine feste Blockhöhe festgelegt und versucht, die Menge des möglichen Inhalts vorherzusagen, um die Höhe gleich zu machen.  Natürlich ist das Web nicht so einfach, und wenn die Menge des Inhalts unterschiedlich war oder die Textgröße größer wurde, begann der Text über den unteren Rand des Blocks hinauszugehen.  Dies war ein Überlauf. <br><br><img src="https://habrastorage.org/webt/e3/6w/jq/e36wjqxw2vqxnfejadqygan3iuk.jpeg"><br><br>  Manchmal fragen die Leute, wie sie verhindern können, dass zu viel Inhalt auf die Website gelangt.  Der technische Support meines CMS wurde von Benutzern kontaktiert, die fragten, wie der Inhalt aus genau diesem Grund eingeschränkt werden kann.  Sie sagten, dass dieser zusätzliche Inhalt „das Layout bricht“.  Für diejenigen von uns, die verstanden haben, dass die Unfähigkeit, die Höhe der Elemente zu kennen, die grundlegende Natur des Layouts ist, waren wir gezwungen, Layouts zu erstellen, die das Fehlen von Blöcken gleicher Höhe verbergen.  Eine übliche Lösung bestand darin, einen Farbverlauf hinzuzufügen, der dazu führt, dass Inhalte verschwinden, die über die Grenzen hinausgehen.  Wir würden die Verwendung von Hintergrundfarben und Blockrahmen vermeiden.  Oder wir würden künstliche Säulentechniken verwenden, um die Höhe der Elemente gleich zu machen. <br><br>  Diese Unfähigkeit, die Höhe eines Elements im Verhältnis zu anderen zu steuern, beeinflusste daher das Webdesign - eine technische Einschränkung veränderte die Art und Weise, wie Websites gestaltet wurden.  Ich bin froh, dass mit dem Aufkommen von Flexbox und Grid dieses Problem nicht nur verschwunden ist, sondern das Verhalten dieser neuen Layoutmethoden die Blöcke standardmäßig auf dieselbe Höhe streckt.  Der Anfangswert der Eigenschaft " <code>align-items - stretch</code> , wodurch die Blöcke auf die Höhe des Rasterbereichs oder des Flex-Containers gedehnt werden. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/VwZzxjV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Darüber hinaus bietet uns CSS Grid eine gute Möglichkeit, Elementen eine bestimmte Größe zuzuweisen, sie jedoch bei Bedarf wachsen zu lassen.  Wenn Sie die Größe der Spur (Spalte oder Linie) mit der Funktion minmax () festlegen, können Sie deren minimale und maximale Größe anzeigen.  Wenn Sie die Linien auf <code>minmax(200px, auto)</code> bedeutet dies, dass die Spur immer mindestens 200px groß ist, auch wenn die <code>minmax(200px, auto)</code> leer sind.  Wenn der Inhalt des Rasterelements jedoch dank des Werts von <code>auto</code> mehr als 200 Pixel beträgt <code>auto</code> dieses Element wachsen.  Sie können es im folgenden Beispiel sehen.  Die erste Zeile ist 200px, da es keine Elemente gibt, um sie zu erhöhen.  Die zweite Zeile enthält ein Rasterelement, dessen Inhalt nicht passt und dessen <code>auto</code> Wert zu funktionieren beginnt, wodurch die Zeile größer als 200 Pixel wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/zYOdjKP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mit der Funktion <code>minmax()</code> können Sie Schnittstellen so erstellen, als ob sie eine perfekte feste Größe hätten.  In einer idealen Welt (wenn die Menge an Inhalten den Erwartungen entspricht) erhalten Sie diese schönen, identischen Linien.  Wenn Sie jedoch zusätzlichen Inhalt hinzufügen, tritt kein Überlauf auf, als ob Sie die feste Zeilenhöhe auf 200 Pixel einstellen würden.  Die Zeichenfolge wird erweitert.  Es ist möglicherweise nicht genau das, was Sie als Entwickler möchten, aber es wird nicht unlesbar sein. <br><br><h2>  Leitungsüberlauf </h2><br>  Das Risiko eines Überlaufs besteht immer dann, wenn wir die Größe der Elemente begrenzen.  Im obigen Beispiel beschreibe ich eine Einschränkung in einer Blockdimension, die Benutzer mit horizontaler Sprache als Höhe wahrnehmen.  Es kann jedoch auch zu einem Überlauf kommen, wenn wir die Breite des Blocks begrenzen.  Dies ist, was wir im CSS is Awesome Meme sehen. <br><br><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br><br>  Der Autor dieses Memes kommentierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen CSS-Trick-Beitrag</a> dazu mit den Worten: <br><blockquote>  <i>Jetzt verstehe ich das Konzept des Überlaufs ein wenig besser, aber zu dieser Zeit war mein Gehirn einfach überwältigt von dem Unverständnis, warum jemand dachte, dass das Standardverhalten den Text einfach nach rechts vom Block schieben sollte, anstatt den Block größer zu machen, wie es die Tabellen immer taten .</i> <br></blockquote>  Warum schiebt CSS Text über den Rahmen hinaus, anstatt den Block selbst zu vergrößern? <br><br>  Es stellt sich heraus, dass das Mem in Zeilenrichtung überläuft.  Das Wort „fantastisch“ ist größer als die Breite, die auf den Block angewendet wird, weshalb er überläuft.  CSS geht vernünftigerweise davon aus, dass Sie einen Block mit genau dieser Breite benötigen, wenn Sie einem Block eine bestimmte Breite geben.  Vielleicht sollte er ein Layout einfügen, das kaputt geht, wenn die Blöcke plötzlich größer werden als festgelegt. <br><br>  Dieses spezielle Problem (dh die Notwendigkeit, die Abmessungen für alle Layoutelemente festzulegen und sicherzustellen, dass sie den verfügbaren Containerraum insgesamt nicht überschreiten) ist das Problem, das moderne Layoutmethoden für uns lösen.  Wenn wir uns vorstellen, dass unser Block eine so speziell ausgewählte Größe hat, dass sie in eine Reihe mit anderen Blöcken in einem Float-Raster passt, können Sie heute stattdessen Flexbox verwenden. <br><br>  Wenn Sie ein Float-Layout verwenden, sollten Sie die Größe jedes Elements festlegen - möglicherweise bevor Sie wissen, wie sein Inhalt aussehen wird.  In diesem Fall stellen Sie möglicherweise fest, dass sich große Inhalte in kleinen Containern befinden und kleine Inhalte zusätzlichen Platz haben. <br><br><img src="https://habrastorage.org/webt/dw/1k/um/dw1kumj10p4gf265pnrdc2htg9g.jpeg"><br><br>  Wenn wir jedoch Flexbox verwenden, kann der Browser berechnen, wie viel Speicherplatz jedem Element zugewiesen werden soll.  Flexbox bietet größeren Artikeln mehr Platz, während kleinere weniger Platz erhalten.  Diese flexible Größenverteilung bedeutet, dass der Block, der das Wort "awesome" enthält, vergrößert wird, um den gesamten Inhalt aufzunehmen, und der Text nicht darüber hinausgeht.  Überlaufproblem behoben;  Für dieses Verhalten wurde Flexbox genau erstellt.  Flexbox leistet hervorragende Arbeit mit Elementen unterschiedlicher Größe und organisiert sie in dem für sie am besten geeigneten Layout. <br><br><img src="https://habrastorage.org/webt/j6/cg/vp/j6cgvpadsslenylgg_cew86amya.jpeg"><br><br>  Außerhalb von Flexbox können wir sagen, dass unser Block so groß wie nötig für den Inhalt sein sollte und nicht mehr.  Das Schlüsselwort min-content kann als Wert für die Eigenschaft width oder inline-size verwendet werden, wenn mit logischen Eigenschaften gearbeitet wird, die sich auf einen Stream beziehen.  Set width: min-content und der Block wächst genug, um das Wort "awesome" aufzunehmen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/LYPjmbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Verhinderung von Datenverlust </h2><br>  Der Grund für den Blocküberlauf (wie im Beispiel mit einem Wort, das über die Blockgrenze hinausgeht) liegt darin, dass die <code>overflow</code> Standardwert <code>visible</code> .  Sie können den Überlauf (wenn Sie möchten) auf andere Weise steuern.  Wenn Sie beispielsweise <code>overflow: auto</code> oder <code>overflow: scroll</code> verwenden, kann Ihr Block eine Bildlaufleiste erhalten.  Dies ist möglicherweise nicht das, was Sie in dieser Situation möchten, aber es kann Situationen geben, in denen ein Block mit einer Bildlaufleiste geeignet ist. <br><br>  Sie können auch davon ausgehen, dass Sie bereit sind, den Überlauf mithilfe von <code>overflow: hidden</code> .  Sie haben vielleicht gedacht, dass das Ausblenden von Überläufen standardmäßig besser ist. Die Tatsache, dass CSS den Überlauf standardmäßig sichtbar (und nicht ausgeblendet) gemacht hat, ist der Schlüssel zum Kernwert der CSS-Entwicklung.  In CSS (wie in vielen anderen Technologien) versuchen wir, Datenverlust zu vermeiden.  Wenn wir über Datenverlust in CSS sprechen, sprechen wir normalerweise über den Teil des Inhalts, der nicht sichtbar ist.  Im Fall von <code>overflow: hidden</code> der Inhalt, der den übergeordneten Block überläuft.  Dies bedeutet, dass wir keine Möglichkeit haben, dorthin zu gelangen und herauszufinden, welchen Teil wir verloren haben. <br><br>  In bestimmten Situationen kann dies ein ernstes Problem sein.  Wenn Sie es geschafft haben, das Layout so fragil zu gestalten, dass die Schaltfläche in Ihrem Formular über den sichtbaren Bereich hinausgeht, können Ihre Benutzer das Formular nicht senden.  Wenn der letzte Absatz des Textes abgeschnitten wird, werden wir nie wissen, wie die Geschichte endete.  Das Problem beim Verschwinden von Elementen ist auch, dass es nicht immer offensichtlich ist, dass sie verschwunden sind.  Als Entwickler bemerken Sie das Problem möglicherweise nicht, insbesondere wenn dies nur bei bestimmten Anzeigebereichsgrößen in einem ansprechenden Design auftritt.  Ihre Benutzer bemerken das Problem möglicherweise nicht - sie sehen den Aufruf zum Handeln einfach nicht oder sie denken, dass das Problem, bei dem sie keine Bestellung aufgeben können, in ihrem Gerät liegt und sie gehen einfach.  Wenn die Elemente jedoch dort überlaufen, wo sie nicht sollten, werden Sie dies höchstwahrscheinlich bemerken.  Im schlimmsten Fall wird dies jemand bemerken, der die Website besucht, und Sie darüber informieren. <br><br>  Deshalb sind in CSS Elemente überfüllt schlampig und ziemlich auffällig.  Wenn Sie den Überlauf explizit sehen, ist es wahrscheinlicher, dass Sie den Fehler korrigieren, als wenn der überschüssige Inhalt einfach ausgeblendet wird.  Mithilfe der Überlaufeigenschaft erhalten Sie jedoch die Möglichkeit, Ihre eigenen Entscheidungen darüber zu treffen, was passieren soll.  Wenn Sie möchten, dass der Überlauf abgeschnitten wird (was in bestimmten Situationen die richtige Lösung sein kann), verwenden Sie <code>overflow: hidden</code> . <br><br><h2>  Datenverlust und Ausrichtung </h2><br>  Die besten Leveling-Tools, die wir in den letzten Jahren erhalten haben, können auch zu Datenverlust führen.  Stellen Sie sich eine Spalte mit Flex-Elementen vor, die sich am Rand des Ansichtsfensters befinden und unterschiedliche Größen haben.  Bei Ausrichtung mit dem <code>flex-start</code> Wert ragen die Elemente nach rechts heraus.  Wenn es jedoch mit der <code>center</code> zentriert <code>center</code> , überschreitet das breitere Element die Grenzen des Ansichtsfensters.  Daher kann die Ausrichtung zu Datenverlust führen. <br><br>  Um versehentlichen Datenverlust durch Ausrichtung zu vermeiden, verfügt CSS jetzt über mehrere neue Schlüsselwörter, die in Verbindung mit Ausrichtungseigenschaften verwendet werden können.  Sie werden in Box Alignment definiert, einer Spezifikation, die sich mit der Ausrichtung in allen Entwurfsmethoden befasst, einschließlich Grid und Flexbox.  Sie werden derzeit nur in Firefox unterstützt.  Wenn wir in unserem obigen Beispiel <code>align-items: safe center</code> festlegen <code>align-items: safe center</code> , wird das letzte Element linksbündig und nicht zentriert.  Dadurch wird ein Datenverlust verhindert, der durch das Zentrieren des Elements verursacht wird, und daher aus dem Ansichtsfenster verschoben. <br><br>  Wenn Sie eine Ausrichtung benötigen (auch wenn dies zu einem Überlauf führt), können Sie ein <code>unsafe center</code> angeben.  In diesem Fall haben Sie den Browser aufgefordert, die Ausrichtung Ihrer Wahl durchzuführen, unabhängig davon, was mit dem Inhalt geschieht.  Wenn Sie Firefox haben, sehen Sie zwei Beispiele: das erste mit sicherer Ausrichtung und das zweite mit unsicherer Ausrichtung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/rachelandrew/embed/preview/QWLMrpE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> , auf dessen Grundlage ich diesen Artikel geschrieben habe, habe ich das Layout als <b>ständigen Kampf gegen den Überlauf beschrieben</b> .  Eine der Designwahrheiten für das Web ist, dass es sehr schwierig ist zu wissen, wie groß das Element sein wird, das den Text enthält.  Wie ich oben gezeigt habe, hatten wir jedoch noch nie so viele Möglichkeiten, Überläufe oder Überläufe zu kontrollieren.  Dies bedeutet, dass unser Layout viel nachhaltiger sein kann und wir Vorlagen erstellen können, die mit unterschiedlichen Mengen an Inhalten arbeiten.  Dies scheint nur eine kleine Veränderung zu sein, aber ich denke, dass die Möglichkeiten, die sie uns eröffnen, enorm sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466665/">https://habr.com/ru/post/de466665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466653/index.html">Debugging-Spiele für NES: wie es heute passiert</a></li>
<li><a href="../de466657/index.html">Dynamisches Detail: verdeckte Compiler-Spiele, Speicherverlust, Leistungsnuancen</a></li>
<li><a href="../de466659/index.html">Kubecost Bewertung, um Geld für Kubernetes in den Wolken zu sparen</a></li>
<li><a href="../de466661/index.html">Fernstudium im Ausland: Notizen vor der Arbeit</a></li>
<li><a href="../de466663/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
<li><a href="../de466667/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 379 (2. - 8. September 2019)</a></li>
<li><a href="../de466669/index.html">Tesla entwickelt Batterien, die 1,6 Millionen km ohne Ersatz laufen können</a></li>
<li><a href="../de466671/index.html">PHP Digest Nr. 164 (27. August - 9. September 2019)</a></li>
<li><a href="../de466673/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 46. OSPF-Leistungsprüfung</a></li>
<li><a href="../de466675/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 47. OSPF-Fehlerbehebung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>