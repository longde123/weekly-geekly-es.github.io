<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏻 🖖🏼 🚃 So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher 💠 ☁️ 👩🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Ich präsentiere Ihnen den zweiten Teil meiner Übersetzung des Handbuchs zur Implementierung Ihrer JavaScript-Programmiersprache - PL Tutorial ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Hallo!  Ich präsentiere Ihnen den zweiten Teil meiner Übersetzung des Handbuchs zur Implementierung Ihrer JavaScript-Programmiersprache - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Vom Übersetzer </h1><br><p>  Wir werden unsere eigene Programmiersprache erstellen - <strong>λ-Sprache</strong> (im Original - λanguage).  Während des Erstellungsprozesses werden wir viele interessante Techniken verwenden, wie z. B. rekursiven Abstieg, Kontrollübertragungsstil und grundlegende Optimierungstechniken.  Es werden zwei Versionen des Interpreters erstellt - der reguläre und der CPS-Interpreter, der Transcompiler in JavaScript. </p><br><p>  Der Autor des Originals ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mihai Bazon</a> , der Autor der berühmten UglifyJS-Bibliothek (ein Tool zum Minimieren und Formatieren von JS-Code). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Dolmetscher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: CPS-Dolmetscher</a> </li><li>  So implementieren Sie eine Programmiersprache in JavaScript.  Teil 4: Trans-Kompilierung in JS </li></ol></div></div><br><p> PS Es gibt einen Fehler im Interpreter und Compiler: in Ausdrücken wie <code>a() &amp;&amp; b()</code> oder <code>a() || b()</code>  <code>a() || b()</code> beide Teile werden immer ausgeführt.  Dies ist natürlich falsch, da <code>a()</code> für den Operator <code>&amp;&amp;</code> falsch oder für <code>||</code> nicht falsch ist  dann spielt der Wert von <code>b()</code> keine Rolle.  Dies ist nicht schwer zu beheben. </p><br><h1 id="prostoy-interpretator">  Einfacher Dolmetscher </h1><br><p>  Im vorherigen Teil haben wir 3 Funktionen geschrieben: <code>InputStream</code> , <code>TokenStream</code> und <code>parse</code> .  Um den AST aus dem Code zu erhalten, verwenden wir den folgenden Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  Das Schreiben eines Interpreters ist einfacher als ein Parser: Wir durchlaufen den Baum nur rekursiv und führen die Ausdrücke in ihrer normalen Reihenfolge aus. </p><br><h2 id="kontekst-environment">  Kontext ( <code>Environment</code> ) </h2><br><p>  Für eine ordnungsgemäße Codeausführung benötigen wir einen Kontext - ein Objekt, das alle Variablen an einem bestimmten Ort enthält.  Es wird als Argument an die <code>evaluate</code> . </p><br><p>  Jedes Mal, wenn wir den <code>lambda</code> Knoten betreten, müssen wir den Kontextfunktionsargumenten neue Variablen hinzufügen.  Wenn das Argument die Variable aus dem externen Block überlappt, müssen wir den alten Wert der Variablen nach dem Beenden der Funktion wiederherstellen. </p><br><p>  Der einfachste Weg, dies zu tun, ist die Verwendung der JavaScript-Vererbung als Prototyp.  Wenn wir eine neue Funktion eingeben, erstellen wir einen neuen Kontext, legen den externen Kontext als Prototyp fest und rufen die Funktion im neuen Kontext auf.  Dank dessen haben wir nichts - im externen Kontext bleiben alle seine Variablen erhalten. </p><br><p>  Hier ist die Implementierung des <code>Environment</code> Objekts: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  Das <code>Environment</code> verfügt über ein <code>parent</code> Feld, das auf den externen Kontext verweist.  Für den globalen Kontext ist es <code>null</code> .  Es hat ein <code>vars</code> Feld, in dem sich alle Variablen befinden, die zu diesem Kontext gehören.  Für einen globalen Kontext entspricht es sofort einem leeren Objekt ( <code>Object.create(null)</code> ) und einer Kopie der Variablen des übergeordneten Kontexts ( <code>Object.create(parent.vars)</code> ) für ein nicht globales. </p><br><p>  Es gibt verschiedene Methoden: </p><br><ul><li>  <code>extend()</code> - Kopieren Sie den aktuellen Kontext. </li><li>  <code>lookup(name)</code> - Finden Sie den Kontext, in dem die Variable namens <code>name</code> definiert ist. </li><li>  <code>get(name)</code> - Ermittelt den Wert einer Variablen namens <code>name</code> .  Löst eine Ausnahme aus, wenn die Variable nicht definiert wurde. </li><li>  <code>set(name, value)</code> - Setzt den Wert einer Variablen.  Diese Methode sucht nach dem Kontext, in dem die Variable definiert ist.  Wenn es nicht definiert ist und wir uns nicht in einem globalen Kontext befinden, wird eine Ausnahme ausgelöst. </li><li>  <code>def(name, value)</code> - Erstellt (oder überlappt oder überschreibt) eine Variable im aktuellen Kontext. </li></ul><br><h2 id="funkciya-evaluate">  Funktion <code>evaluate</code> </h2><br><p>  Nachdem wir das <code>Environment</code> Objekt haben, können wir mit der Lösung des Hauptproblems fortfahren.  Diese Funktion ist ein großer <code>switch</code> Block, der abhängig vom Typ des übertragenen Knotens einige Aktionen ausführt: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Für Literale geben wir einfach ihren Wert zurück: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  Variablen werden aus dem Kontext entnommen (der Name der Variablen ist im Wertefeld enthalten): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Um zuzuweisen, müssen wir sicherstellen, dass wir auf der linken Seite den Namen der Variablen (Knoten <code>var</code> ) haben.  Wenn nicht, lösen wir einfach eine Ausnahme aus (wir unterstützen keine Zuordnung zu etwas anderem als Variablen).  Als nächstes setzen wir den Wert der Variablen mit <code>env.set</code> .  Beachten Sie, dass die rechte Seite des Ausdrucks mithilfe des rekursiven Aufrufs berechnet werden muss, um Folgendes zu <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  Für einen Knoten vom Typ <code>binary</code> wir den Operator für beide Operanden anwenden.  Wir werden die Funktion <code>apply_op</code> später schreiben.  Außerdem rufen wir <code>evaluate</code> für beide Teile des Ausdrucks auf: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Ein Knoten vom Typ <code>lambda</code> gibt einen normalen JavaScript-Abschluss zurück, sodass er auch aus JavaScript wie eine reguläre Funktion aufgerufen werden kann.  Ich habe die Funktion <code>make_lambda</code> hinzugefügt, die ich später zeigen werde: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  Die Ausführung des <code>if</code> Knotens <code>if</code> recht einfach: Zuerst finden wir den Wert der Bedingung.  Wenn es nicht falsch ist, geben Sie den Wert des <code>then</code> Zweigs zurück.  Andernfalls, wenn es einen <code>else</code> Zweig gibt, dann dessen Wert oder <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  Der <code>prog</code> Knoten ist eine Folge von Ausdrücken.  Wir führen einfach alle Ausdrücke der Reihe nach aus und nehmen den Wert des letzteren (der Wert der leeren Sequenz ist <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  Für einen Knoten vom Typ <code>call</code> wir eine Funktion aufrufen.  Vorher werden wir den Wert der Funktion selbst finden, die Werte aller Argumente finden und die Funktion mit <code>apply</code> aufrufen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  Wir werden nie hierher kommen, aber falls wir dem Parser einen neuen Knotentyp hinzufügen und vergessen, ihn dem Interpreter hinzuzufügen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Dies war der Hauptteil des Dolmetschers.  Oben haben wir zwei Funktionen verwendet, die wir noch nicht implementiert haben. Beginnen wir also: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Es empfängt den Operatortyp und die Argumente.  Einfacher und intuitiver <code>switch</code> .  Im Gegensatz zu JavaScript, das jeden Wert annehmen kann, wie Variablen, auch solche, die keinen Sinn ergeben.  Wir fordern, dass die Operanden von arithmetischen Operatoren Zahlen sind und keine Division durch Null zulassen.  Für Streicher werden wir uns später etwas einfallen lassen. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Wie Sie oben sehen können, wird eine reguläre JavaScript-Funktion zurückgegeben, die den übergebenen Kontext und die AST-Funktionen verwendet.  Alle Arbeiten werden nur ausgeführt, wenn die Funktion selbst aufgerufen wird: Ein Kontext wird erstellt, Argumente werden gesetzt (wenn sie nicht ausreichen, werden sie <code>false</code> ).  Dann wird der Funktionskörper einfach in einem neuen Kontext ausgeführt. </p><br><h4 id="nativnye-funkcii">  Native Funktionen </h4><br><p>  Wie Sie sehen, hatten wir keine Möglichkeit, mit JavaScript aus unserer Sprache zu interagieren.  Früher habe ich die Funktionen <code>print</code> und <code>println</code> verwendet, aber ich habe sie nirgendwo definiert.  Wir müssen sie in JavaScript schreiben und sie einfach dem globalen Kontext hinzufügen. </p><br><p>  Hier ist ein Beispiel für einen solchen Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  Ganzer Code </h4><br><p>  Sie können den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesamten Code herunterladen</a> , den wir die ganze Zeit geschrieben haben.  Es kann mit NodeJS gestartet werden.  Übergeben Sie einfach den Code an den Standard-Stream: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Codebeispiele </h1><br><p>  Obwohl unsere Programmiersprache einfach ist, kann sie (theoretisch) jedes Problem lösen, das von einem Computer überhaupt gelöst werden kann.  Dies liegt daran, dass einige Typen, die klüger sind als ich jemals sein werden - Alonzo Church und Alan Turing - einmal bewiesen haben, dass λ-Kalkül (Lambda-Kalkül) einer Turing-Maschine entspricht, und unsere λ-Sprache implementiert λ-Kalkül. </p><br><p>  Dies bedeutet, dass wir, auch wenn unsere Sprache keine Möglichkeiten hat, sie dennoch mit dem realisieren können, was wir bereits haben.  Oder wenn dies schwierig ist, können wir einen Dolmetscher für eine andere Sprache in dieser Sprache schreiben. </p><br><h4 id="cikly">  Zyklen </h4><br><p>  Schleifen sind kein Problem, wenn wir eine Rekursion haben.  Ich habe bereits ein Beispiel für eine Schleife gezeigt, die zusätzlich zur Rekursion implementiert wurde.  Versuchen wir es noch einmal. </p><br><pre> <code class="python hljs">print_range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Aber hier haben wir ein Problem: Wenn wir die Anzahl der Iterationen beispielsweise auf 1000 erhöhen, wird nach 600 der Fehler "Maximale Aufrufstapelgröße überschritten" angezeigt. Dies geschieht, weil der Interpreter rekursiv ist und die Rekursion die maximale Tiefe erreicht. </p><br><p>  Dies ist ein ernstes Problem, aber es gibt eine Lösung.  Ich möchte neue Konstrukte für die Iteration ( <code>for</code> oder <code>while</code> ) hinzufügen, aber versuchen wir, auf sie zu verzichten.  Die Rekursion sieht wunderschön aus, also lassen wir es.  Wir werden später sehen, wie wir diese Einschränkung umgehen können. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Datenstrukturen (deren Fehlen) </h4><br><p>  In unserer λ-Sprache gibt es drei Arten von Daten: Zahlen, Zeichenfolgen und Boolesche Typen.  Möglicherweise können Sie keine komplexen Typen wie Arrays oder Objekte erstellen.  Aber das ist keine Tat, wir haben noch einen Typ: Funktion.  Es stellt sich heraus, dass wir, wenn wir dem λ-Kalkül folgen, alle Datenstrukturen, einschließlich Objekte, auch mit Vererbung erstellen können. </p><br><p>  Ich werde es am Beispiel von Listen zeigen.  Stellen wir uns vor, wir haben eine <code>cons</code> Funktion, die ein Objekt mit zwei Werten erstellt.  Nennen wir dieses Objekt "Zelle" oder "Paar".  Wir nennen einen der Werte "Auto" und den anderen "CDR".  Nur weil sie in Lisp so genannt werden.  Wenn wir nun ein Objekt "Zelle" haben, können wir seine Werte mit den Funktionen <code>car</code> und <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Jetzt können wir einfach eine Liste definieren: </p><br><blockquote>  Eine Liste ist ein Paar, das das erste Element in "Auto" und die verbleibenden Elemente in "CDR" enthält.  Aber `cdr` kann nur einen Wert enthalten!  Dieser Wert ist eine Liste.  Eine Liste ist ein Paar, das das erste Element in "Auto" und die verbleibenden Elemente in "CDR" enthält.  Aber `cdr` kann nur einen Wert enthalten!  Dieser Wert ist eine Liste.  [...] <br></blockquote><p>  Dies ist ein rekursiver Datentyp.  Ein Problem bleibt jedoch: Wann müssen Sie aufhören?  Logischerweise sollten wir aufhören, wenn <code>cdr</code> eine leere Liste ist.  Aber was ist eine leere Liste?  Fügen Sie dazu ein neues Objekt mit dem Namen "NIL" hinzu.  Es kann als Paar verwendet werden (wir können <code>car</code> und <code>cdr</code> , aber das Ergebnis wird <code>NIL</code> selbst sein).  Erstellen wir nun eine Liste der Elemente 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Es sieht schrecklich aus, wenn es dafür keine spezielle Syntax gibt.  Aber ich wollte nur zeigen, dass dies mit den vorhandenen λ-Sprachfunktionen möglich ist.  Hier ist die Implementierung: </p><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL);</code> </pre> <br><p>  Als ich zum ersten Mal sah, dass <code>cons</code> / <code>car</code> / <code>cdr</code> auf diese Weise hergestellt wurden, war ich überrascht, dass sie kein einziges <code>if</code> brauchten (aber das ist seltsam, da es nicht im ursprünglichen λ-Kalkül enthalten ist).  Natürlich macht dies keine Programmiersprache so, weil es extrem ineffizient ist, aber es macht λ-Kalküle nicht weniger schön.  In einer klaren Sprache führt dieser Code Folgendes aus: </p><br><ul><li>  Die <code>cons</code> Funktion nimmt zwei Werte ( <code>a</code> und <code>b</code> ) an und gibt die Funktion zurück, die sie enthält.  Diese Funktion ist das eigentliche Objekt des Paares.  Sie nimmt ein Argument und nennt es für beide Werte des Paares. </li><li>  Die <code>car</code> Funktion ruft das übergebene Argument auf und übergibt eine Funktion, die das erste Argument zurückgibt. </li><li>  Die <code>cdr</code> Funktion macht dasselbe wie die <code>car</code> Funktion, mit dem einzigen Unterschied, dass die übergebene Funktion das zweite Argument zurückgibt. </li><li>  Die <code>NIL</code> Funktion funktioniert genauso wie die <code>cons</code> , gibt jedoch ein Paar mit zwei Werten zurück, die NIL entsprechen. </li></ul><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Es gibt viele Algorithmen in Listen, die rekursiv implementiert werden können und logisch aussehen.  Hier ist beispielsweise eine Funktion, die die übergebene Funktion für jedes Listenelement aufruft: </p><br><pre> <code class="python hljs">foreach = λ(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  Und hier ist eine andere, die eine Liste für eine Reihe von Zahlen erstellt: </p><br><pre> <code class="python hljs">range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), λ(x) println(x * x));</span></span></code> </pre> <br><p>  Die oben implementierten Listen sind unveränderlich (wir können das <code>car</code> oder die <code>cdr</code> nicht ändern <code>car</code> nachdem die Liste erstellt wurde).  Die meisten Lisp haben Funktionen zum Ändern eines Paares.  In Schema werden sie <code>set-car!</code>  / <code>set-cdr!</code>  .  In Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Diesmal verwenden wir die Namen aus Schema: </p><br><pre> <code class="python hljs">cons = λ(x, y) λ(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Dies zeigt, dass wir veränderbare Datenstrukturen implementieren können.  Ich werde nicht näher darauf eingehen, wie es funktioniert, das geht aus dem Code hervor. </p><br><p>  Wir können noch weiter gehen und die Objekte implementieren, aber ohne Änderungen in der Syntax wird es schwierig sein, dies zu tun.  Eine andere Möglichkeit besteht darin, eine neue Syntax im Tokenizer / Parser zu implementieren und deren Verarbeitung im Interpreter hinzuzufügen.  Alle wichtigen Programmiersprachen tun dies, und es ist notwendig, eine normale Leistung zu erzielen.  Wir werden im nächsten Teil des Artikels eine neue Syntax hinzufügen. </p><br><p>  [Vom Übersetzer: Wenn Sie sich für Lambda-Kalkül interessieren, gibt es einen coolen Artikel über Habré, der diesem Thema gewidmet ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Kalkül in JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Neue Syntaxkonstrukte </h1><br><p>  Unsere λ-Sprache hat einige syntaktische Konstruktionen.  Beispielsweise gibt es keine direkte Möglichkeit, neue Variablen hinzuzufügen.  Wie ich bereits sagte, müssen wir IIFE verwenden, also sieht es ungefähr so ​​aus: </p><br><pre> <code class="python hljs">(λ(x, y){ (λ(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Wir werden das Schlüsselwort <code>let</code> hinzufügen.  Dadurch können wir so etwas schreiben: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  Für jede Variable im <code>let</code> Block sollten vorherige Variablen auch aus demselben Block verfügbar sein.  Daher entspricht der obige Code dem folgenden: </p><br><pre> <code class="python hljs">(λ(x){ (λ(y){ (λ(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Diese Änderungen können direkt im Parser vorgenommen werden und erfordern dann keine Änderungen im Interpreter.  Anstatt einen neuen <code>let</code> Knoten hinzuzufügen, können wir ihn in <code>call</code> und <code>lambda</code> Knoten umwandeln.  Dies bedeutet, dass wir keine semantischen Änderungen in unserer Sprache vorgenommen haben - dies wird als „syntaktischer Zucker“ bezeichnet, und die Operation zum Konvertieren in zuvor existierende AST-Knoten wird als „zuckerfrei“ bezeichnet (Original: „Desugaring“). </p><br><p>  Wir müssen den Parser jedoch trotzdem ändern.  Fügen wir einen neuen "let" -Knoten hinzu, da dieser effizienter interpretiert werden kann (Sie müssen keine Abschlüsse erstellen und diese sofort aufrufen, sondern müssen nur den Kontext kopieren und ändern). </p><br><p>  Außerdem werden wir die Unterstützung für "let named" hinzufügen, die im Schema enthalten war.  Es erleichtert das Erstellen von Schleifen: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Dies ist eine "rekursive" Schleife, die die Summe von 10 + 9 + ... + 0 zählt. Zuvor mussten wir dies folgendermaßen tun: </p><br><pre> <code class="python hljs">print((λ(loop){ loop = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  Um dies zu vereinfachen, fügen wir die Syntax von "Funktionen mit einem Namen" hinzu.  Es wird so aussehen: </p><br><pre> <code class="python hljs">print((λ loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Hierfür müssen Änderungen vorgenommen werden: </p><br><ul><li>  Unterstützung für optionalen Namen nach <code>lambda</code> Schlüsselwort.  Wenn es vorhanden ist, müssen wir dem aktuellen Kontext eine Variable hinzufügen, die auf die Funktion selbst verweist.  Dies entspricht genau den Funktionen mit einem Namen in JavaScript. </li><li>  Unterstützung für das neue Schlüsselwort <code>let</code> .  Als nächstes folgen ein optionaler Name und eine Liste (möglicherweise leer) von Variablendefinitionen in dieser Form: <code>foo = EXPRESSION</code> , durch Kommas getrennt.  Der Körper des <code>let</code> Ausdrucks ist ein einzelner Ausdruck (der natürlich eine Folge von Ausdrücken sein kann). </li></ul><br><h4 id="izmeneniya-v-parsere">  Parser ändert sich </h4><br><p>  Fügen Sie zunächst bei einer kleinen Änderung im Tokenizer das Schlüsselwort <code>let</code> zur Liste der Schlüsselwörter hinzu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda λ true false "</span></span>;</code> </pre> <br><p>  Ändern Sie die Funktion <code>parse_lambda</code> dass sie einen optionalen Namen liest: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  Fügen Sie nun eine Funktion hinzu, die den <code>let</code> Ausdruck analysiert: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Dies behandelt zwei Fälle.  Wenn nach <code>let</code> ein Token vom Typ <code>var</code> , wird dieses mit einem Namen <code>let</code> .  Außerdem lesen wir die Liste der Definitionen mit der Funktion " <code>parse_vardef</code> , da sie in Klammern stehen und durch Kommas getrennt sind, und verwenden die Funktion " <code>parse_vardef</code> , die unten gezeigt wird.  Als nächstes geben wir einen Knoten vom Typ <code>call</code> , der sofort eine Funktion namens (IIFE) aufruft.  Die Argumente für die Funktion sind die durch <code>let</code> definierten Variablen, und der Aufrufknoten übergibt die Werte als Argumente.  Und natürlich wird der Hauptteil der Funktion mit <code>parse_expression()</code> gelesen. </p><br><p>  Wenn es sich um eine einfache <code>let</code> , geben wir einen Knoten vom Typ <code>let</code> mit den Feldern <code>vars</code> und <code>body</code> .  Das Feld <code>vars</code> enthält ein Array von Variablen im folgenden Format: <code>{ name: VARIABLE, def: AST }</code> , die von der folgenden Funktion analysiert werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  Außerdem müssen Sie in der Funktion <code>parse_atom</code> eine Prüfung auf einen neuen Ausdruckstyp <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Interpreter-Änderungen </h4><br><p>  Da wir beschlossen haben, die Struktur des AST zu ändern, anstatt ihn in die alten Knotentypen zu „knacken“, müssen wir dem Interpreter die Verarbeitung der neuen Logik hinzufügen. </p><br><p>  Um die Unterstützung für den optionalen Funktionsnamen hinzuzufügen, ändern wir die Funktion <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Wenn die Funktion einen Namen hat, erstellen wir beim Erstellen des Abschlusses eine Kopie des Kontexts und fügen die Funktion dem Kontext hinzu.  Der Rest bleibt gleich. </p><br><p>  Um einen Knoten vom Typ <code>let</code> , fügen wir dem Interpreter den folgenden Fall hinzu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Beachten Sie, dass für jede Variable ein neuer Kontext erstellt wird, in dem eine neue Variable hinzugefügt wird.  Danach führen wir den Body einfach im letzten Kontext aus. </p><br><h4 id="primery">  Beispiele </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   —  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> , ,           ,     .        JavaScript    λ. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( λ() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( λ() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  λ  ,  ,   JS   4 . , ,  . </p><br><p>       λ  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   — JavaScript. ,         JavaScript —     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp —   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: CPS-Dolmetscher</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443812/">https://habr.com/ru/post/de443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443794/index.html">Die Hauptrichtungen für IT-Startups im Bereich Immobilienverkäufe</a></li>
<li><a href="../de443798/index.html">Zotero-Hacks: unbegrenzter synchronisierter Speicher und reibungslose Verwendung mit rmarkdown</a></li>
<li><a href="../de443804/index.html">C # ist eine einfache Sprache?</a></li>
<li><a href="../de443808/index.html">Analyse von Mädchen mit geringer sozialer Verantwortung (mit Power BI, Qlik Sense, Tableau beauftragt)</a></li>
<li><a href="../de443810/index.html">Wie viel verdienen Entwickler unterschiedlicher Qualifikationen, 2018?</a></li>
<li><a href="../de443814/index.html">Geben ist mein "ehemaliges Geschäft"</a></li>
<li><a href="../de443816/index.html">Das Kommunikationsministerium besteht auf einem einzigen 5G-Betreiber</a></li>
<li><a href="../de443818/index.html">März IT Events Digest (Teil Zwei)</a></li>
<li><a href="../de443820/index.html">Wie der Flughafen Fukuoka herausfand, welche Maßnahmen zur Reduzierung der Warteschlangen wirksam sind</a></li>
<li><a href="../de443822/index.html">Performance Orchester</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>