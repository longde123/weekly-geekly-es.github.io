<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèª üññüèº üöÉ So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher üí† ‚òÅÔ∏è üë©üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Ich pr√§sentiere Ihnen den zweiten Teil meiner √úbersetzung des Handbuchs zur Implementierung Ihrer JavaScript-Programmiersprache - PL Tutorial ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Hallo!  Ich pr√§sentiere Ihnen den zweiten Teil meiner √úbersetzung des Handbuchs zur Implementierung Ihrer JavaScript-Programmiersprache - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Vom √úbersetzer </h1><br><p>  Wir werden unsere eigene Programmiersprache erstellen - <strong>Œª-Sprache</strong> (im Original - Œªanguage).  W√§hrend des Erstellungsprozesses werden wir viele interessante Techniken verwenden, wie z. B. rekursiven Abstieg, Kontroll√ºbertragungsstil und grundlegende Optimierungstechniken.  Es werden zwei Versionen des Interpreters erstellt - der regul√§re und der CPS-Interpreter, der Transcompiler in JavaScript. </p><br><p>  Der Autor des Originals ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mihai Bazon</a> , der Autor der ber√ºhmten UglifyJS-Bibliothek (ein Tool zum Minimieren und Formatieren von JS-Code). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Dolmetscher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: CPS-Dolmetscher</a> </li><li>  So implementieren Sie eine Programmiersprache in JavaScript.  Teil 4: Trans-Kompilierung in JS </li></ol></div></div><br><p> PS Es gibt einen Fehler im Interpreter und Compiler: in Ausdr√ºcken wie <code>a() &amp;&amp; b()</code> oder <code>a() || b()</code>  <code>a() || b()</code> beide Teile werden immer ausgef√ºhrt.  Dies ist nat√ºrlich falsch, da <code>a()</code> f√ºr den Operator <code>&amp;&amp;</code> falsch oder f√ºr <code>||</code> nicht falsch ist  dann spielt der Wert von <code>b()</code> keine Rolle.  Dies ist nicht schwer zu beheben. </p><br><h1 id="prostoy-interpretator">  Einfacher Dolmetscher </h1><br><p>  Im vorherigen Teil haben wir 3 Funktionen geschrieben: <code>InputStream</code> , <code>TokenStream</code> und <code>parse</code> .  Um den AST aus dem Code zu erhalten, verwenden wir den folgenden Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  Das Schreiben eines Interpreters ist einfacher als ein Parser: Wir durchlaufen den Baum nur rekursiv und f√ºhren die Ausdr√ºcke in ihrer normalen Reihenfolge aus. </p><br><h2 id="kontekst-environment">  Kontext ( <code>Environment</code> ) </h2><br><p>  F√ºr eine ordnungsgem√§√üe Codeausf√ºhrung ben√∂tigen wir einen Kontext - ein Objekt, das alle Variablen an einem bestimmten Ort enth√§lt.  Es wird als Argument an die <code>evaluate</code> . </p><br><p>  Jedes Mal, wenn wir den <code>lambda</code> Knoten betreten, m√ºssen wir den Kontextfunktionsargumenten neue Variablen hinzuf√ºgen.  Wenn das Argument die Variable aus dem externen Block √ºberlappt, m√ºssen wir den alten Wert der Variablen nach dem Beenden der Funktion wiederherstellen. </p><br><p>  Der einfachste Weg, dies zu tun, ist die Verwendung der JavaScript-Vererbung als Prototyp.  Wenn wir eine neue Funktion eingeben, erstellen wir einen neuen Kontext, legen den externen Kontext als Prototyp fest und rufen die Funktion im neuen Kontext auf.  Dank dessen haben wir nichts - im externen Kontext bleiben alle seine Variablen erhalten. </p><br><p>  Hier ist die Implementierung des <code>Environment</code> Objekts: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  Das <code>Environment</code> verf√ºgt √ºber ein <code>parent</code> Feld, das auf den externen Kontext verweist.  F√ºr den globalen Kontext ist es <code>null</code> .  Es hat ein <code>vars</code> Feld, in dem sich alle Variablen befinden, die zu diesem Kontext geh√∂ren.  F√ºr einen globalen Kontext entspricht es sofort einem leeren Objekt ( <code>Object.create(null)</code> ) und einer Kopie der Variablen des √ºbergeordneten Kontexts ( <code>Object.create(parent.vars)</code> ) f√ºr ein nicht globales. </p><br><p>  Es gibt verschiedene Methoden: </p><br><ul><li>  <code>extend()</code> - Kopieren Sie den aktuellen Kontext. </li><li>  <code>lookup(name)</code> - Finden Sie den Kontext, in dem die Variable namens <code>name</code> definiert ist. </li><li>  <code>get(name)</code> - Ermittelt den Wert einer Variablen namens <code>name</code> .  L√∂st eine Ausnahme aus, wenn die Variable nicht definiert wurde. </li><li>  <code>set(name, value)</code> - Setzt den Wert einer Variablen.  Diese Methode sucht nach dem Kontext, in dem die Variable definiert ist.  Wenn es nicht definiert ist und wir uns nicht in einem globalen Kontext befinden, wird eine Ausnahme ausgel√∂st. </li><li>  <code>def(name, value)</code> - Erstellt (oder √ºberlappt oder √ºberschreibt) eine Variable im aktuellen Kontext. </li></ul><br><h2 id="funkciya-evaluate">  Funktion <code>evaluate</code> </h2><br><p>  Nachdem wir das <code>Environment</code> Objekt haben, k√∂nnen wir mit der L√∂sung des Hauptproblems fortfahren.  Diese Funktion ist ein gro√üer <code>switch</code> Block, der abh√§ngig vom Typ des √ºbertragenen Knotens einige Aktionen ausf√ºhrt: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  F√ºr Literale geben wir einfach ihren Wert zur√ºck: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  Variablen werden aus dem Kontext entnommen (der Name der Variablen ist im Wertefeld enthalten): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Um zuzuweisen, m√ºssen wir sicherstellen, dass wir auf der linken Seite den Namen der Variablen (Knoten <code>var</code> ) haben.  Wenn nicht, l√∂sen wir einfach eine Ausnahme aus (wir unterst√ºtzen keine Zuordnung zu etwas anderem als Variablen).  Als n√§chstes setzen wir den Wert der Variablen mit <code>env.set</code> .  Beachten Sie, dass die rechte Seite des Ausdrucks mithilfe des rekursiven Aufrufs berechnet werden muss, um Folgendes zu <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  F√ºr einen Knoten vom Typ <code>binary</code> wir den Operator f√ºr beide Operanden anwenden.  Wir werden die Funktion <code>apply_op</code> sp√§ter schreiben.  Au√üerdem rufen wir <code>evaluate</code> f√ºr beide Teile des Ausdrucks auf: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Ein Knoten vom Typ <code>lambda</code> gibt einen normalen JavaScript-Abschluss zur√ºck, sodass er auch aus JavaScript wie eine regul√§re Funktion aufgerufen werden kann.  Ich habe die Funktion <code>make_lambda</code> hinzugef√ºgt, die ich sp√§ter zeigen werde: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  Die Ausf√ºhrung des <code>if</code> Knotens <code>if</code> recht einfach: Zuerst finden wir den Wert der Bedingung.  Wenn es nicht falsch ist, geben Sie den Wert des <code>then</code> Zweigs zur√ºck.  Andernfalls, wenn es einen <code>else</code> Zweig gibt, dann dessen Wert oder <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  Der <code>prog</code> Knoten ist eine Folge von Ausdr√ºcken.  Wir f√ºhren einfach alle Ausdr√ºcke der Reihe nach aus und nehmen den Wert des letzteren (der Wert der leeren Sequenz ist <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  F√ºr einen Knoten vom Typ <code>call</code> wir eine Funktion aufrufen.  Vorher werden wir den Wert der Funktion selbst finden, die Werte aller Argumente finden und die Funktion mit <code>apply</code> aufrufen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  Wir werden nie hierher kommen, aber falls wir dem Parser einen neuen Knotentyp hinzuf√ºgen und vergessen, ihn dem Interpreter hinzuzuf√ºgen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Dies war der Hauptteil des Dolmetschers.  Oben haben wir zwei Funktionen verwendet, die wir noch nicht implementiert haben. Beginnen wir also: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Es empf√§ngt den Operatortyp und die Argumente.  Einfacher und intuitiver <code>switch</code> .  Im Gegensatz zu JavaScript, das jeden Wert annehmen kann, wie Variablen, auch solche, die keinen Sinn ergeben.  Wir fordern, dass die Operanden von arithmetischen Operatoren Zahlen sind und keine Division durch Null zulassen.  F√ºr Streicher werden wir uns sp√§ter etwas einfallen lassen. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Wie Sie oben sehen k√∂nnen, wird eine regul√§re JavaScript-Funktion zur√ºckgegeben, die den √ºbergebenen Kontext und die AST-Funktionen verwendet.  Alle Arbeiten werden nur ausgef√ºhrt, wenn die Funktion selbst aufgerufen wird: Ein Kontext wird erstellt, Argumente werden gesetzt (wenn sie nicht ausreichen, werden sie <code>false</code> ).  Dann wird der Funktionsk√∂rper einfach in einem neuen Kontext ausgef√ºhrt. </p><br><h4 id="nativnye-funkcii">  Native Funktionen </h4><br><p>  Wie Sie sehen, hatten wir keine M√∂glichkeit, mit JavaScript aus unserer Sprache zu interagieren.  Fr√ºher habe ich die Funktionen <code>print</code> und <code>println</code> verwendet, aber ich habe sie nirgendwo definiert.  Wir m√ºssen sie in JavaScript schreiben und sie einfach dem globalen Kontext hinzuf√ºgen. </p><br><p>  Hier ist ein Beispiel f√ºr einen solchen Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  Ganzer Code </h4><br><p>  Sie k√∂nnen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesamten Code herunterladen</a> , den wir die ganze Zeit geschrieben haben.  Es kann mit NodeJS gestartet werden.  √úbergeben Sie einfach den Code an den Standard-Stream: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Codebeispiele </h1><br><p>  Obwohl unsere Programmiersprache einfach ist, kann sie (theoretisch) jedes Problem l√∂sen, das von einem Computer √ºberhaupt gel√∂st werden kann.  Dies liegt daran, dass einige Typen, die kl√ºger sind als ich jemals sein werden - Alonzo Church und Alan Turing - einmal bewiesen haben, dass Œª-Kalk√ºl (Lambda-Kalk√ºl) einer Turing-Maschine entspricht, und unsere Œª-Sprache implementiert Œª-Kalk√ºl. </p><br><p>  Dies bedeutet, dass wir, auch wenn unsere Sprache keine M√∂glichkeiten hat, sie dennoch mit dem realisieren k√∂nnen, was wir bereits haben.  Oder wenn dies schwierig ist, k√∂nnen wir einen Dolmetscher f√ºr eine andere Sprache in dieser Sprache schreiben. </p><br><h4 id="cikly">  Zyklen </h4><br><p>  Schleifen sind kein Problem, wenn wir eine Rekursion haben.  Ich habe bereits ein Beispiel f√ºr eine Schleife gezeigt, die zus√§tzlich zur Rekursion implementiert wurde.  Versuchen wir es noch einmal. </p><br><pre> <code class="python hljs">print_range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Aber hier haben wir ein Problem: Wenn wir die Anzahl der Iterationen beispielsweise auf 1000 erh√∂hen, wird nach 600 der Fehler "Maximale Aufrufstapelgr√∂√üe √ºberschritten" angezeigt. Dies geschieht, weil der Interpreter rekursiv ist und die Rekursion die maximale Tiefe erreicht. </p><br><p>  Dies ist ein ernstes Problem, aber es gibt eine L√∂sung.  Ich m√∂chte neue Konstrukte f√ºr die Iteration ( <code>for</code> oder <code>while</code> ) hinzuf√ºgen, aber versuchen wir, auf sie zu verzichten.  Die Rekursion sieht wundersch√∂n aus, also lassen wir es.  Wir werden sp√§ter sehen, wie wir diese Einschr√§nkung umgehen k√∂nnen. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Datenstrukturen (deren Fehlen) </h4><br><p>  In unserer Œª-Sprache gibt es drei Arten von Daten: Zahlen, Zeichenfolgen und Boolesche Typen.  M√∂glicherweise k√∂nnen Sie keine komplexen Typen wie Arrays oder Objekte erstellen.  Aber das ist keine Tat, wir haben noch einen Typ: Funktion.  Es stellt sich heraus, dass wir, wenn wir dem Œª-Kalk√ºl folgen, alle Datenstrukturen, einschlie√ülich Objekte, auch mit Vererbung erstellen k√∂nnen. </p><br><p>  Ich werde es am Beispiel von Listen zeigen.  Stellen wir uns vor, wir haben eine <code>cons</code> Funktion, die ein Objekt mit zwei Werten erstellt.  Nennen wir dieses Objekt "Zelle" oder "Paar".  Wir nennen einen der Werte "Auto" und den anderen "CDR".  Nur weil sie in Lisp so genannt werden.  Wenn wir nun ein Objekt "Zelle" haben, k√∂nnen wir seine Werte mit den Funktionen <code>car</code> und <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir einfach eine Liste definieren: </p><br><blockquote>  Eine Liste ist ein Paar, das das erste Element in "Auto" und die verbleibenden Elemente in "CDR" enth√§lt.  Aber `cdr` kann nur einen Wert enthalten!  Dieser Wert ist eine Liste.  Eine Liste ist ein Paar, das das erste Element in "Auto" und die verbleibenden Elemente in "CDR" enth√§lt.  Aber `cdr` kann nur einen Wert enthalten!  Dieser Wert ist eine Liste.  [...] <br></blockquote><p>  Dies ist ein rekursiver Datentyp.  Ein Problem bleibt jedoch: Wann m√ºssen Sie aufh√∂ren?  Logischerweise sollten wir aufh√∂ren, wenn <code>cdr</code> eine leere Liste ist.  Aber was ist eine leere Liste?  F√ºgen Sie dazu ein neues Objekt mit dem Namen "NIL" hinzu.  Es kann als Paar verwendet werden (wir k√∂nnen <code>car</code> und <code>cdr</code> , aber das Ergebnis wird <code>NIL</code> selbst sein).  Erstellen wir nun eine Liste der Elemente 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Es sieht schrecklich aus, wenn es daf√ºr keine spezielle Syntax gibt.  Aber ich wollte nur zeigen, dass dies mit den vorhandenen Œª-Sprachfunktionen m√∂glich ist.  Hier ist die Implementierung: </p><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL);</code> </pre> <br><p>  Als ich zum ersten Mal sah, dass <code>cons</code> / <code>car</code> / <code>cdr</code> auf diese Weise hergestellt wurden, war ich √ºberrascht, dass sie kein einziges <code>if</code> brauchten (aber das ist seltsam, da es nicht im urspr√ºnglichen Œª-Kalk√ºl enthalten ist).  Nat√ºrlich macht dies keine Programmiersprache so, weil es extrem ineffizient ist, aber es macht Œª-Kalk√ºle nicht weniger sch√∂n.  In einer klaren Sprache f√ºhrt dieser Code Folgendes aus: </p><br><ul><li>  Die <code>cons</code> Funktion nimmt zwei Werte ( <code>a</code> und <code>b</code> ) an und gibt die Funktion zur√ºck, die sie enth√§lt.  Diese Funktion ist das eigentliche Objekt des Paares.  Sie nimmt ein Argument und nennt es f√ºr beide Werte des Paares. </li><li>  Die <code>car</code> Funktion ruft das √ºbergebene Argument auf und √ºbergibt eine Funktion, die das erste Argument zur√ºckgibt. </li><li>  Die <code>cdr</code> Funktion macht dasselbe wie die <code>car</code> Funktion, mit dem einzigen Unterschied, dass die √ºbergebene Funktion das zweite Argument zur√ºckgibt. </li><li>  Die <code>NIL</code> Funktion funktioniert genauso wie die <code>cons</code> , gibt jedoch ein Paar mit zwei Werten zur√ºck, die NIL entsprechen. </li></ul><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Es gibt viele Algorithmen in Listen, die rekursiv implementiert werden k√∂nnen und logisch aussehen.  Hier ist beispielsweise eine Funktion, die die √ºbergebene Funktion f√ºr jedes Listenelement aufruft: </p><br><pre> <code class="python hljs">foreach = Œª(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  Und hier ist eine andere, die eine Liste f√ºr eine Reihe von Zahlen erstellt: </p><br><pre> <code class="python hljs">range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), Œª(x) println(x * x));</span></span></code> </pre> <br><p>  Die oben implementierten Listen sind unver√§nderlich (wir k√∂nnen das <code>car</code> oder die <code>cdr</code> nicht √§ndern <code>car</code> nachdem die Liste erstellt wurde).  Die meisten Lisp haben Funktionen zum √Ñndern eines Paares.  In Schema werden sie <code>set-car!</code>  / <code>set-cdr!</code>  .  In Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Diesmal verwenden wir die Namen aus Schema: </p><br><pre> <code class="python hljs">cons = Œª(x, y) Œª(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Dies zeigt, dass wir ver√§nderbare Datenstrukturen implementieren k√∂nnen.  Ich werde nicht n√§her darauf eingehen, wie es funktioniert, das geht aus dem Code hervor. </p><br><p>  Wir k√∂nnen noch weiter gehen und die Objekte implementieren, aber ohne √Ñnderungen in der Syntax wird es schwierig sein, dies zu tun.  Eine andere M√∂glichkeit besteht darin, eine neue Syntax im Tokenizer / Parser zu implementieren und deren Verarbeitung im Interpreter hinzuzuf√ºgen.  Alle wichtigen Programmiersprachen tun dies, und es ist notwendig, eine normale Leistung zu erzielen.  Wir werden im n√§chsten Teil des Artikels eine neue Syntax hinzuf√ºgen. </p><br><p>  [Vom √úbersetzer: Wenn Sie sich f√ºr Lambda-Kalk√ºl interessieren, gibt es einen coolen Artikel √ºber Habr√©, der diesem Thema gewidmet ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Kalk√ºl in JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Neue Syntaxkonstrukte </h1><br><p>  Unsere Œª-Sprache hat einige syntaktische Konstruktionen.  Beispielsweise gibt es keine direkte M√∂glichkeit, neue Variablen hinzuzuf√ºgen.  Wie ich bereits sagte, m√ºssen wir IIFE verwenden, also sieht es ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="python hljs">(Œª(x, y){ (Œª(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Wir werden das Schl√ºsselwort <code>let</code> hinzuf√ºgen.  Dadurch k√∂nnen wir so etwas schreiben: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  F√ºr jede Variable im <code>let</code> Block sollten vorherige Variablen auch aus demselben Block verf√ºgbar sein.  Daher entspricht der obige Code dem folgenden: </p><br><pre> <code class="python hljs">(Œª(x){ (Œª(y){ (Œª(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Diese √Ñnderungen k√∂nnen direkt im Parser vorgenommen werden und erfordern dann keine √Ñnderungen im Interpreter.  Anstatt einen neuen <code>let</code> Knoten hinzuzuf√ºgen, k√∂nnen wir ihn in <code>call</code> und <code>lambda</code> Knoten umwandeln.  Dies bedeutet, dass wir keine semantischen √Ñnderungen in unserer Sprache vorgenommen haben - dies wird als ‚Äûsyntaktischer Zucker‚Äú bezeichnet, und die Operation zum Konvertieren in zuvor existierende AST-Knoten wird als ‚Äûzuckerfrei‚Äú bezeichnet (Original: ‚ÄûDesugaring‚Äú). </p><br><p>  Wir m√ºssen den Parser jedoch trotzdem √§ndern.  F√ºgen wir einen neuen "let" -Knoten hinzu, da dieser effizienter interpretiert werden kann (Sie m√ºssen keine Abschl√ºsse erstellen und diese sofort aufrufen, sondern m√ºssen nur den Kontext kopieren und √§ndern). </p><br><p>  Au√üerdem werden wir die Unterst√ºtzung f√ºr "let named" hinzuf√ºgen, die im Schema enthalten war.  Es erleichtert das Erstellen von Schleifen: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Dies ist eine "rekursive" Schleife, die die Summe von 10 + 9 + ... + 0 z√§hlt. Zuvor mussten wir dies folgenderma√üen tun: </p><br><pre> <code class="python hljs">print((Œª(loop){ loop = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  Um dies zu vereinfachen, f√ºgen wir die Syntax von "Funktionen mit einem Namen" hinzu.  Es wird so aussehen: </p><br><pre> <code class="python hljs">print((Œª loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Hierf√ºr m√ºssen √Ñnderungen vorgenommen werden: </p><br><ul><li>  Unterst√ºtzung f√ºr optionalen Namen nach <code>lambda</code> Schl√ºsselwort.  Wenn es vorhanden ist, m√ºssen wir dem aktuellen Kontext eine Variable hinzuf√ºgen, die auf die Funktion selbst verweist.  Dies entspricht genau den Funktionen mit einem Namen in JavaScript. </li><li>  Unterst√ºtzung f√ºr das neue Schl√ºsselwort <code>let</code> .  Als n√§chstes folgen ein optionaler Name und eine Liste (m√∂glicherweise leer) von Variablendefinitionen in dieser Form: <code>foo = EXPRESSION</code> , durch Kommas getrennt.  Der K√∂rper des <code>let</code> Ausdrucks ist ein einzelner Ausdruck (der nat√ºrlich eine Folge von Ausdr√ºcken sein kann). </li></ul><br><h4 id="izmeneniya-v-parsere">  Parser √§ndert sich </h4><br><p>  F√ºgen Sie zun√§chst bei einer kleinen √Ñnderung im Tokenizer das Schl√ºsselwort <code>let</code> zur Liste der Schl√ºsselw√∂rter hinzu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda Œª true false "</span></span>;</code> </pre> <br><p>  √Ñndern Sie die Funktion <code>parse_lambda</code> dass sie einen optionalen Namen liest: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  F√ºgen Sie nun eine Funktion hinzu, die den <code>let</code> Ausdruck analysiert: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Dies behandelt zwei F√§lle.  Wenn nach <code>let</code> ein Token vom Typ <code>var</code> , wird dieses mit einem Namen <code>let</code> .  Au√üerdem lesen wir die Liste der Definitionen mit der Funktion " <code>parse_vardef</code> , da sie in Klammern stehen und durch Kommas getrennt sind, und verwenden die Funktion " <code>parse_vardef</code> , die unten gezeigt wird.  Als n√§chstes geben wir einen Knoten vom Typ <code>call</code> , der sofort eine Funktion namens (IIFE) aufruft.  Die Argumente f√ºr die Funktion sind die durch <code>let</code> definierten Variablen, und der Aufrufknoten √ºbergibt die Werte als Argumente.  Und nat√ºrlich wird der Hauptteil der Funktion mit <code>parse_expression()</code> gelesen. </p><br><p>  Wenn es sich um eine einfache <code>let</code> , geben wir einen Knoten vom Typ <code>let</code> mit den Feldern <code>vars</code> und <code>body</code> .  Das Feld <code>vars</code> enth√§lt ein Array von Variablen im folgenden Format: <code>{ name: VARIABLE, def: AST }</code> , die von der folgenden Funktion analysiert werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  Au√üerdem m√ºssen Sie in der Funktion <code>parse_atom</code> eine Pr√ºfung auf einen neuen Ausdruckstyp <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Interpreter-√Ñnderungen </h4><br><p>  Da wir beschlossen haben, die Struktur des AST zu √§ndern, anstatt ihn in die alten Knotentypen zu ‚Äûknacken‚Äú, m√ºssen wir dem Interpreter die Verarbeitung der neuen Logik hinzuf√ºgen. </p><br><p>  Um die Unterst√ºtzung f√ºr den optionalen Funktionsnamen hinzuzuf√ºgen, √§ndern wir die Funktion <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Wenn die Funktion einen Namen hat, erstellen wir beim Erstellen des Abschlusses eine Kopie des Kontexts und f√ºgen die Funktion dem Kontext hinzu.  Der Rest bleibt gleich. </p><br><p>  Um einen Knoten vom Typ <code>let</code> , f√ºgen wir dem Interpreter den folgenden Fall hinzu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Beachten Sie, dass f√ºr jede Variable ein neuer Kontext erstellt wird, in dem eine neue Variable hinzugef√ºgt wird.  Danach f√ºhren wir den Body einfach im letzten Kontext aus. </p><br><h4 id="primery">  Beispiele </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   ‚Äî  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> , ,           ,     .        JavaScript    Œª. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( Œª() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  Œª  ,  ,   JS   4 . , ,  . </p><br><p>       Œª  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   ‚Äî JavaScript. ,         JavaScript ‚Äî     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp ‚Äî   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: CPS-Dolmetscher</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443812/">https://habr.com/ru/post/de443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443794/index.html">Die Hauptrichtungen f√ºr IT-Startups im Bereich Immobilienverk√§ufe</a></li>
<li><a href="../de443798/index.html">Zotero-Hacks: unbegrenzter synchronisierter Speicher und reibungslose Verwendung mit rmarkdown</a></li>
<li><a href="../de443804/index.html">C # ist eine einfache Sprache?</a></li>
<li><a href="../de443808/index.html">Analyse von M√§dchen mit geringer sozialer Verantwortung (mit Power BI, Qlik Sense, Tableau beauftragt)</a></li>
<li><a href="../de443810/index.html">Wie viel verdienen Entwickler unterschiedlicher Qualifikationen, 2018?</a></li>
<li><a href="../de443814/index.html">Geben ist mein "ehemaliges Gesch√§ft"</a></li>
<li><a href="../de443816/index.html">Das Kommunikationsministerium besteht auf einem einzigen 5G-Betreiber</a></li>
<li><a href="../de443818/index.html">M√§rz IT Events Digest (Teil Zwei)</a></li>
<li><a href="../de443820/index.html">Wie der Flughafen Fukuoka herausfand, welche Ma√ünahmen zur Reduzierung der Warteschlangen wirksam sind</a></li>
<li><a href="../de443822/index.html">Performance Orchester</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>