<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò© üí™üèø ‚ÄºÔ∏è Fazendo da Defesa da Torre um Jogo de Unidade - Parte 1 üë©üèª‚Äçü§ù‚Äçüë®üèΩ ü§≥üèø üë®‚Äçüë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os jogos de defesa de torre est√£o ganhando popularidade, e isso n√£o √© surpreendente - pouco pode ser comparado com o prazer de observar suas pr√≥prias ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazendo da Defesa da Torre um Jogo de Unidade - Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="imagem"></div><br>  Os jogos de defesa de torre est√£o ganhando popularidade, e isso n√£o √© surpreendente - pouco pode ser comparado com o prazer de observar suas pr√≥prias linhas de defesa que destroem inimigos do mal!  Neste tutorial em duas partes, criaremos um jogo de defesa de torre no mecanismo <em>Unity</em> ! <br><br>  Voc√™ aprender√° como fazer o seguinte: <br><br><ul><li>  Crie ondas de inimigos </li><li>  Fa√ßa-os seguir pontos de rota </li><li>  Construa e atualize torres e tamb√©m ensine-os a quebrar inimigos em pequenos pixels </li></ul><br>  No final, obtemos o quadro do jogo, que pode ser desenvolvido ainda mais! <br><a name="habracut"></a><br><blockquote>  <em>Nota</em> : voc√™ precisa de conhecimentos b√°sicos do Unity (por exemplo, precisa saber como ativos e componentes s√£o adicionados, o que s√£o prefabs) e os conceitos b√°sicos de <em>C #</em> .  Para aprender tudo isso, recomendo que voc√™ siga os tutoriais sobre Unity de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sean Duffy</a> ou a s√©rie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Beginning C # with Unity</a> de Brian Mockley. </blockquote><br>  Vou trabalhar no Unity para OS X, mas este tutorial tamb√©m √© adequado para Windows. <br><br><h2>  Atrav√©s das janelas da torre de marfim </h2><br>  Neste tutorial, criaremos um jogo de defesa de torre no qual inimigos (pequenos bugs) rastejam para um cookie pertencente a voc√™ e a seus lacaios (√© claro, esses s√£o monstros!).  O jogador pode colocar monstros em pontos estrat√©gicos e atualiz√°-los em ouro. <br><br>  O jogador deve matar todos os bugs at√© chegar ao cookie.  Cada nova onda de inimigos est√° se tornando cada vez mais dif√≠cil de derrotar.  O jogo termina quando voc√™ sobrevive a todas as ondas (vit√≥ria!) Ou quando cinco inimigos rastejam at√© os biscoitos (perda!). <br><br>  Aqui est√° uma captura de tela do jogo finalizado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>Monstros, uni-vos!</i>  <i>Proteja o biscoito!</i> <br><br><h2>  Come√ßando a trabalhar </h2><br>  Fa√ßa o download deste <a href="">projeto em branco</a> , descompacte-o e abra o projeto <em>TowerDefense-Part1-Starter</em> no Unity. <br><br>  O projeto de rascunho possui recursos de gr√°ficos e sons, anima√ß√µes prontas e v√°rios scripts √∫teis.  Os scripts n√£o est√£o diretamente relacionados aos jogos de defesa, ent√£o n√£o vou falar sobre eles aqui.  No entanto, se voc√™ quiser saber mais sobre a cria√ß√£o de anima√ß√µes 2D no Unity, confira este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Tutorial do Unity 2D">tutorial do Unity 2D</a> . <br><br>  O projeto tamb√©m cont√©m prefabs, que adicionaremos posteriormente para criar caracteres.  Finalmente, h√° uma cena no projeto com um plano de fundo e uma interface de usu√°rio personalizada. <br><br>  Abra o <em>GameScene</em> localizado na pasta <em>Cenas</em> e defina o modo Jogo com uma propor√ß√£o de <em>4: 3</em> para que todos os r√≥tulos correspondam corretamente ao plano de fundo.  No modo de jogo, voc√™ ver√° o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Autoria:</em> <br><br><ul><li>  Os gr√°ficos do projeto foram retirados do pacote Wiki Wenderlich gr√°tis!  Outros trabalhos gr√°ficos podem ser encontrados em seu site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="gameartguppy">gameartguppy</a> . </li><li>  √ìtima m√∫sica tirada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Benound">BenSound</a> , que tem outras trilhas sonoras incr√≠veis! </li><li>  Agrade√ßo tamb√©m a Michael Jesper pela muito √∫til fun√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="trepida√ß√£o da c√¢mera">trepida√ß√£o da c√¢mera.</a> </li></ul>  . <br><h2>  O local est√° marcado com uma cruz: a localiza√ß√£o dos monstros </h2><br>  Monstros s√≥ podem ser colocados em pontos marcados com um <em>x</em> . <br><br>  Para adicion√°-los √† cena, arraste <em>Images \ Objects \ Openspot</em> do <em>Project Browser</em> para a janela <em>Scene</em> .  Enquanto a posi√ß√£o n√£o √© importante para n√≥s. <br><br>  Depois de selecionar o <em>Openspot</em> na hierarquia, clique em <em>Adicionar componente</em> no <em><em>Inspetor</em></em> e selecione <em>Box Collider 2D</em> .  Na janela Cena, o Unity exibir√° um colisor retangular com uma linha verde.  Usaremos esse colisor para reconhecer os cliques do mouse neste local. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  Adicione o componente <em>Audio \ Audio Source</em> ao <em>Openspot da</em> mesma maneira.  Para o par√¢metro <em>AudioClip</em> do componente Audio Source, selecione o arquivo <em>tower_place</em> localizado na pasta <em>Audio</em> e desative <em>Play On Awake</em> . <br><br>  Precisamos criar mais 11 pontos.  Embora exista uma tenta√ß√£o de repetir todas essas etapas, o Unity tem uma solu√ß√£o melhor: <em>Prefab</em> ! <br><br>  Arraste <em>Openspot</em> da <em>hierarquia</em> para a pasta <em>Prefabs</em> dentro do <em>Project Browser</em> .  Seu nome ficar√° azul na Hierarquia, o que significa que est√° anexado √† pr√©-fabricada.  Algo assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Agora que temos o espa√ßo em branco pr√©-fabricado, podemos criar quantas c√≥pias quisermos.  Basta arrastar e soltar o <em>Openspot da</em> pasta <em>Prefabs</em> dentro do <em>Project Browser</em> na janela <em>Scene</em> .  Repita isso 11 vezes e 12 objetos Openspot aparecer√£o na cena. <br><br>  Agora use o <em>Inspetor</em> para definir esses 12 objetos Openspot com as seguintes coordenadas: <br><br><ul><li>  (X: -5,2, Y: 3,5, Z: 0) </li><li>  (X: -2,2, Y: 3,5, Z: 0) </li><li>  (X: 0,8, Y: 3,5, Z: 0) </li><li>  (X: 3,8, Y: 3,5, Z: 0) </li><li>  (X: -3,8, Y: 0,4, Z: 0) </li><li>  (X: -0,8, Y: 0,4, Z: 0) </li><li>  (X: 2,2, Y: 0,4, Z: 0) </li><li>  (X: 5,2, Y: 0,4, Z: 0) </li><li>  (X: -5,2, Y: -3,0, Z: 0) </li><li>  (X: -2,2, Y: -3,0, Z: 0) </li><li>  (X: 0,8, Y: -3,0, Z: 0) </li><li>  (X: 3,8, Y: -3,0, Z: 0) </li></ul><br>  Quando voc√™ fizer isso, a cena ficar√° assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Colocamos monstros </h2><br>  Para simplificar o posicionamento, h√° uma pr√©-fabricada <em>Monster</em> na pasta <em>Pr√©</em> - <em>fabricada</em> do projeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab pronto para uso</i> <br><br>  No momento, ele consiste em um objeto de jogo vazio com tr√™s sprites diferentes e anima√ß√µes de tiro quando crian√ßas. <br><br>  Cada sprite √© um monstro com diferentes n√≠veis de poder.  A pr√©-fabricada tamb√©m cont√©m o componente <em>Fonte de √°udio</em> , que ser√° lan√ßado para reproduzir som quando um monstro disparar um laser. <br><br>  Agora vamos criar um script que <em>hospedar√° o</em> <em>Monster</em> no <em>Openspot</em> . <br><br>  No <em>Navegador de projeto,</em> selecione o objeto <em>Openspot</em> na pasta <em>Prefabs</em> .  No <em>Inspetor,</em> clique em <em>Adicionar componente</em> e selecione <em>Novo script</em> e nomeie o script como <em>PlaceMonster</em> .  Selecione <em>C Sharp</em> como o idioma e clique em <em>Criar e adicionar</em> .  Como adicionamos o script √† pr√©-fabricada <i>Openspot</i> , todos os objetos Openspot na cena agora ter√£o esse script.  √ìtimo! <br><br>  Clique duas vezes no script para abri-lo no IDE.  Em seguida, adicione duas vari√°veis: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Vamos criar uma inst√¢ncia do objeto armazenado no <code>monsterPrefab</code> para criar o monstro e armazen√°-lo no <code>monster</code> para que ele possa ser manipulado durante o jogo. <br><br><h3>  Um monstro por ponto </h3><br>  Para que apenas um monstro possa ser colocado em um ponto, adicione o seguinte m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Em <code>CanPlaceMonster()</code> podemos verificar se a vari√°vel <code>monster</code> ainda √© <code>null</code> .  Nesse caso, n√£o h√° monstro no momento, e podemos coloc√°-lo. <br><br>  Agora adicione o seguinte c√≥digo para colocar o monstro quando o jogador clicar neste GameObject: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Este c√≥digo localiza o monstro quando voc√™ clica no mouse ou toca na tela.  Como ele trabalha? <br><br><ol><li>  O Unity chama automaticamente o <code>OnMouseUp</code> quando um jogador toca no colisor f√≠sico GameObject. </li><li>  Quando chamado, esse m√©todo coloca um monstro se <code>CanPlaceMonster()</code> retornar <code>true</code> . </li><li>  Criamos um monstro usando o m√©todo <code>Instantiate</code> , que cria uma inst√¢ncia da pr√©-fabricada especificada com a posi√ß√£o e rota√ß√£o especificadas.  Nesse caso, <code>monsterPrefab</code> , fornecemos a posi√ß√£o atual do GameObject sem rota√ß√£o, transferimos o resultado para o <code>GameObject</code> e salvamos no <code>monster</code> </li><li>  No final, chamamos <code>PlayOneShot</code> para reproduzir o efeito sonoro anexado ao componente <code>AudioSource</code> do objeto. </li></ol><br>  Agora, nosso script do <code>PlaceMonster</code> pode ter um novo monstro, mas ainda precisamos especificar uma pr√©-fabricada. <br><br><h3>  Usando o Prefab certo </h3><br>  Salve o arquivo e retorne ao Unity. <br><br>  Para definir a vari√°vel <em>monsterPrefab</em> , primeiro selecione o objeto <em>Openspot</em> na pasta <em>Prefabs</em> no navegador do projeto. <br><br>  No <em><em>Inspetor,</em></em> clique no c√≠rculo √† direita do campo <em>Monster Prefab</em> do componente <em>PlaceMonster (Script)</em> e selecione <em>Monster</em> na caixa de di√°logo exibida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  Isso √© tudo.  Inicie a cena e crie monstros em lugares diferentes, clicando com o mouse ou tocando na tela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  √ìtimo!  Agora podemos criar monstros.  No entanto, eles parecem uma bagun√ßa estranha, porque todos os sprites infantis do monstro s√£o atra√≠dos.  Agora vamos consertar isso. <br><br><h2>  Aumentar o n√≠vel de monstros </h2><br>  A figura abaixo mostra que, com um aumento de n√≠vel, os monstros parecem cada vez mais assustadores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>Que gracinha!</i>  <i>Mas se voc√™ tentar roubar seus biscoitos, esse monstro se tornar√° um assassino.</i> <br><br>  O script √© usado como base para a implementa√ß√£o do sistema de n√≠veis de monstros.  Ele rastreia o poder do monstro em cada n√≠vel e, √© claro, o n√≠vel atual do monstro. <br><br>  Adicione este script. <br><br>  Selecione a pr√©-fabricada <em>/ Pr√©-</em> fabricada <em>/ Monster</em> no <em>Project Browser</em> .  Adicione um novo script <em>C #</em> chamado <em>MonsterData</em> .  Abra o script no IDE e adicione o seguinte c√≥digo <i>acima</i> da classe <code>MonsterData</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Ent√£o criamos o <code>MonsterLevel</code> .  Ele agrupa o pre√ßo (em ouro, que iremos apoiar abaixo) e uma representa√ß√£o visual do n√≠vel do monstro. <br><br>  Adicionamos em cima de <code>[System.Serializable]</code> para que inst√¢ncias de classe possam ser modificadas no inspetor.  Isso nos permite alterar rapidamente todos os valores da classe Level, mesmo quando o jogo est√° rodando.  Isso √© incrivelmente √∫til para equilibrar o jogo. <br><br><h3>  Definir n√≠veis de monstro </h3><br>  No nosso caso, armazenaremos o <code>MonsterLevel</code> especificado na <code>List&lt;T&gt;</code> . <br><br>  Por que n√£o usar o <code>MonsterLevel[]</code> ?  Vamos precisar do √≠ndice de um objeto <code>MonsterLevel</code> espec√≠fico v√°rias vezes.  Embora seja f√°cil escrever c√≥digo para isso, ainda precisamos usar <code>IndexOf()</code> , que implementa a funcionalidade <code>Lists</code> .  N√£o faz sentido reinventar a roda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Reinventar a bicicleta geralmente √© uma m√° id√©ia.</i> <br><br>  Na parte superior do <em>MonsterData.cs,</em> adicione o seguinte <code>using</code> constru√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Isso nos d√° acesso a estruturas de dados generalizadas para que possamos usar a classe <code>List&lt;T&gt;</code> no script. <br><br><blockquote>  <em>Nota</em> : generaliza√ß√µes s√£o um poderoso conceito de C #.  Eles permitem que voc√™ especifique estruturas de dados com seguran√ßa de tipo sem ter que aderir ao tipo.  Isso √© √∫til para classes de cont√™ineres, como listas e conjuntos.  Para saber mais sobre estruturas gen√©ricas, leia o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Introdu√ß√£o aos C # Gen√©ricos">Introdu√ß√£o aos C # Gen√©ricos</a> . </blockquote><br>  Agora adicione a seguinte vari√°vel ao <code>MonsterData</code> para manter a lista <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Gra√ßas a generaliza√ß√µes, podemos garantir que a <code>List</code> do <code>level</code> contenha apenas objetos <code>MonsterLevel</code> . <br><br>  Salve o arquivo e mude para o Unity para configurar cada n√≠vel. <br><br>  Selecione <em>Prefabs / Monster</em> no <em>Project Browser</em> .  O <em><em>Inspetor</em></em> agora exibe o campo <em>N√≠veis</em> do componente <em>MonsterData (Script)</em> .  Defina o <em>tamanho</em> como <em>3</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  Em seguida, defina o <em>custo</em> para cada n√≠vel: <br><br><ul><li>  <em>Elemento 0</em> : <em>200</em> </li><li>  <em>Elemento 1</em> : <em>110</em> </li><li>  <em>Elemento 2</em> : <em>120</em> </li></ul><br>  Agora, atribu√≠mos os valores dos campos de exibi√ß√£o visual. <br><br>  Expanda <em>Prefabs / Monster</em> no navegador do Projeto para ver seus filhos.  Arraste o filho <em>Monster0</em> para o campo de <em>elemento de</em> <em>visualiza√ß√£o</em> <em>0</em> . <br><br>  Em seguida, defina o <em>Elemento 1</em> como <em>Monster1</em> e o <em>Elemento 2</em> como <em>Monster2</em> .  O GIF mostra este processo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Quando voc√™ seleciona <em>Prefabs / Monster</em> , a pr√©-fabricada deve ficar assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Definir n√≠vel atual </h3><br>  Volte para <em>MonsterData.cs</em> no IDE e adicione outra vari√°vel ao <code>MonsterData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  Na vari√°vel privada <code>currentLevel</code> , armazenaremos o n√≠vel atual do monstro. <br><br>  Agora defina <code>currentLevel</code> e torne-o vis√≠vel para outros scripts.  Adicione as seguintes linhas ao <code>MonsterData</code> juntamente com a declara√ß√£o das vari√°veis ‚Äã‚Äãda inst√¢ncia: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Grande parte do c√≥digo C #, certo?  Vamos tom√°-lo em ordem: <br><br><ol><li>  Defina a <em>propriedade da</em> vari√°vel privada <code>currentLevel</code> .  Ao definir a propriedade, podemos cham√°-la como qualquer outra vari√°vel: como <code>CurrentLevel</code> (dentro da classe) ou como <code>monster.CurrentLevel</code> (fora).  Podemos definir qualquer comportamento no m√©todo getter ou setter de uma propriedade e, criando apenas um getter, setter ou ambos, voc√™ pode controlar as propriedades da propriedade: somente leitura, somente leitura e grava√ß√£o / leitura. </li><li>  No getter, retornamos o valor de <code>currentLevel</code> . </li><li>  No setter, atribu√≠mos a <code>currentLevel</code> novo valor.  Em seguida, obtemos o √≠ndice do n√≠vel atual.  Por fim, percorremos todos os <em>n√≠veis</em> e ativamos / desativamos a exibi√ß√£o visual, dependendo do <code>currentLevelIndex</code> .  Isso √© √≥timo porque, quando o <code>currentLevel</code> muda, o sprite √© atualizado automaticamente.  Propriedades s√£o uma coisa muito conveniente! </li></ol><br>  Adicione a seguinte implementa√ß√£o <code>OnEnable</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Aqui configuramos <code>CurrentLevel</code> ao colocar.  Isso garante que apenas o sprite desejado seja exibido. <br><br><blockquote>  <em>Nota</em> : √© importante inicializar a propriedade em <code>OnEnable</code> , e n√£o em <code>OnStart</code> , porque chamamos os m√©todos ordinais ao criar inst√¢ncias pr√©-fabricadas. <br><br>  <code>OnEnable</code> ser√° chamado imediatamente quando a pr√©-fabricada for criada (se a pr√©-fabricada tiver sido salva no estado ativado), mas o <code>OnStart</code> n√£o <code>OnStart</code> chamado at√© que o objeto comece a ser executado como parte da cena. <br><br>  Precisamos verificar esses dados antes de colocar o monstro, ent√£o inicializamos para <code>OnEnable</code> . </blockquote><br>  Salve o arquivo e retorne ao Unity.  Execute o projeto e coloque os monstros;  agora eles exibem os sprites corretos do n√≠vel mais baixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Monster Upgrade </h3><br>  Retorne ao IDE e adicione o seguinte m√©todo ao <code>MonsterData</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  Em <code>GetNextLevel</code> , obtemos o √≠ndice <code>currentLevel</code> e o √≠ndice de n√≠vel mais alto;  se o monstro n√£o atingiu o n√≠vel m√°ximo, o pr√≥ximo n√≠vel retornar√°.  Caso contr√°rio, <code>null</code> retornado. <br><br>  Voc√™ pode usar este m√©todo para descobrir se √© poss√≠vel uma atualiza√ß√£o de monstro. <br><br>  Para aumentar o n√≠vel do monstro, adicione o seguinte m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Aqui obtemos o √≠ndice do n√≠vel atual e, em seguida, certifique-se de que este n√£o seja o n√≠vel m√°ximo, verificando se √© menor que os <code>levels.Count - 1</code> .  <code>CurrentLevel</code> caso, <code>CurrentLevel</code> para o pr√≥ximo n√≠vel. <br><br><h3>  Verificando a funcionalidade de atualiza√ß√£o </h3><br>  Salve o arquivo e retorne para <em>PlaceMonster.cs</em> no IDE.  Adicione um novo m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Primeiro, verificamos se h√° um monstro que pode ser melhorado comparando a vari√°vel <code>monster</code> com <code>null</code> .  Se isso for verdade, obtemos o n√≠vel de monstro atual de seus <code>MonsterData</code> . <br><br>  Em seguida, verificamos se o pr√≥ximo n√≠vel est√° dispon√≠vel, ou seja, se <code>GetNextLevel()</code> n√£o retorna <code>null</code> .  Se um aumento de n√≠vel for poss√≠vel, retornamos <code>true</code> ;  caso contr√°rio, retorne <code>false</code> . <br><br><h3>  Implementamos melhorias para o ouro </h3><br>  Para habilitar a op√ß√£o de atualiza√ß√£o, adicione a ramifica√ß√£o <code>else if</code> ao <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Verificamos a possibilidade de uma atualiza√ß√£o usando <code>CanUpgradeMonster()</code> .  Se poss√≠vel, <code>MonsterData</code> componente <code>MonsterData</code> usando <code>GetComponent()</code> e chamamos <code>IncreaseLevel()</code> , o que aumenta o n√≠vel do monstro.  Finalmente, lan√ßamos o Monster <em>AudioSource</em> . <br><br>  Salve o arquivo e retorne ao Unity.  Execute o jogo, coloque e atualize <i>qualquer n√∫mero de</i> monstros (mas por enquanto). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Pagando Ouro - Game Manager </h2><br>  Embora possamos construir e melhorar imediatamente qualquer monstro, ser√° interessante no jogo? <br><br>  Vejamos a quest√£o do ouro.  O problema com o rastreamento √© que precisamos transferir informa√ß√µes entre diferentes objetos do jogo. <br><br>  A figura abaixo mostra todos os objetos que devem participar disso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Todos os objetos de jogo selecionados devem saber quanto ouro um jogador possui.</i> <br><br>  Para armazenar esses dados, usaremos um objeto comum que outros objetos podem acessar. <br><br>  Clique com o bot√£o direito do mouse na <em>Hierarquia</em> e selecione <em>Criar Vazio</em> .  Nomeie o novo objeto <em>GameManager</em> . <br><br>  Adicione um novo script <em>C #</em> chamado <em>GameManagerBehavior ao GameManager</em> e abra-o no IDE.  Vamos exibir a quantidade total de ouro do jogador no r√≥tulo, portanto, na parte superior do arquivo, adicione a seguinte linha: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Isso nos permitir√° acessar classes de interface do usu√°rio, como <code>Text</code> , que √© usado para r√≥tulos.  Agora adicione a seguinte vari√°vel √† classe: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Ele armazenar√° um link para o componente <code>Text</code> usado para exibir a quantidade de ouro que um jogador possui. <br><br>  Agora que o <code>GameManager</code> conhece o r√≥tulo, como sincronizamos a quantidade de ouro armazenada na vari√°vel e o valor exibido no r√≥tulo?  Vamos criar uma propriedade. <br><br>  Adicione o seguinte c√≥digo ao <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  Ele parece familiar?  O c√≥digo √© semelhante ao <code>CurrentLevel</code> , que definimos no <code>Monster</code> .  Primeiro, criamos uma vari√°vel privada <code>gold</code> para armazenar a quantidade atual de ouro.  Em seguida, definimos a propriedade <code>Gold</code> (inesperadamente, certo?) E implementamos o getter e o setter. <br><br>  O getter simplesmente retorna o valor do <code>gold</code> .  O levantador √© mais interessante.  Al√©m de definir o valor da vari√°vel, tamb√©m define o campo de <code>text</code> para <code>goldLabel</code> para exibir o novo valor de ouro. <br><br>  Qu√£o generosos seremos?  Adicione a seguinte linha ao <code>Start()</code> para dar ao jogador <em>1000</em> gold ou menos se voc√™ sentir pena do dinheiro: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Atribuindo um objeto de r√≥tulo a um script </h3><br>  Salve o arquivo e retorne ao Unity.  Na <em>Hierarquia,</em> selecione <em>GameManager</em> .  No <em><em>Inspetor,</em></em> clique no c√≠rculo √† direita do <em>r√≥tulo dourado</em> .  Na caixa de di√°logo <em>Selecionar texto</em> , selecione a guia <em>Cena</em> e selecione <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  Execute a cena e o r√≥tulo exibir√° <em>Ouro: 1000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  Verificando a "carteira" do jogador </h3><br>  Abra o script <em>PlaceMonster.cs</em> no IDE e adicione a seguinte vari√°vel de inst√¢ncia: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Usaremos o <code>gameManager</code> para acessar o componente <code>GameManagerBehavior</code> objeto <code>GameManagerBehavior</code> <em>na</em> cena.  Para especific√°-lo, adicione o seguinte a <code>Start()</code> : <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Obtemos um GameObject chamado GameManager usando a fun√ß√£o GameObject.Find <code>GameObject.Find()</code> , que retorna o primeiro objeto de jogo encontrado com esse nome.  Em seguida, obtemos seu componente <code>GameManagerBehavior</code> e o salvamos para o futuro. <br><br><blockquote>  <em>Nota</em> : voc√™ pode fazer isso definindo um campo no editor do Unity ou adicionando um m√©todo est√°tico ao <code>GameManager</code> que retorna uma inst√¢ncia do singleton a partir da qual podemos obter o <code>GameManagerBehavior</code> . <br><br>  No entanto, no bloco de c√≥digo mostrado acima, h√° uma confus√£o: o m√©todo <code>Find</code> , que funciona mais lentamente durante a execu√ß√£o do aplicativo;  mas √© conveniente e pode ser usado com modera√ß√£o. </blockquote><br><h3>  Pegue meu dinheiro! </h3><br>  Ainda n√£o <code>OnMouseUp()</code> ouro, portanto, adicionaremos essa linha <em>duas vezes</em> ao <code>OnMouseUp()</code> , substituindo cada um dos coment√°rios <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Salve o arquivo e volte para o Unity, atualize alguns monstros e veja a atualiza√ß√£o do valor Gold.  Agora deduzimos ouro, mas os jogadores podem construir monstros desde que tenham espa√ßo suficiente;  eles apenas pedem dinheiro emprestado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Cr√©dito infinito?</i>  <i>√ìtimo!</i>  <i>Mas n√£o podemos permitir.</i>  <i>O jogador deve poder apostar em monstros enquanto tiver ouro suficiente.</i> <br><br><h3>  Verifica√ß√£o de ouro para monstros </h3><br>  Alterne no IDE para <em>PlaceMonster.cs</em> e substitua o conte√∫do de <code>CanPlaceMonster()</code> seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  N√≥s <code>MonsterData</code> pre√ßo de coloca√ß√£o de monstros nos <code>levels</code> em seus <code>MonsterData</code> .  Depois, verificamos que o <code>monster</code> n√£o <code>monster</code> <code>null</code> e que <code>gameManager.Gold</code> mais do que esse pre√ßo. <br><br>  A tarefa para voc√™: adicione independentemente ao <code>CanUpgradeMonster()</code> verifica√ß√£o se o jogador possui ouro suficiente. <br><br><div class="spoiler">  <b class="spoiler_title">Solu√ß√£o dentro</b> <div class="spoiler_text">  Substitua a linha: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  sobre isso: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Ele verificar√° se o jogador tem mais <em>ouro do</em> que o pre√ßo de atualiza√ß√£o. </div></div><br>  Salve e execute a cena no Unity.  Agora tente aqueles como adicionar monstros ilimitadamente! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Agora s√≥ podemos construir um n√∫mero limitado de monstros.</i> <br><br><h2>  Pol√≠tica da torre: inimigos, ondas e pontos de refer√™ncia </h2><br>  √â hora de "abrir o caminho" para nossos inimigos.  Os inimigos aparecem no primeiro ponto da rota, passam para o pr√≥ximo e repetem o processo at√© atingirem o cookie. <br><br>  Voc√™ pode fazer os inimigos se moverem assim: <br><br><ol><li>  Defina o caminho que os inimigos seguir√£o </li><li>  Mova o inimigo pela estrada </li><li>  Vire o inimigo para que ele olhe para a frente </li></ol><br><h3>  Criando uma estrada a partir de waypoints </h3><br>  Clique com o bot√£o direito do mouse na <em>Hierarquia</em> e selecione <em>Criar Vazio</em> para criar um novo objeto de jogo vazio.  Nomeie-o como <em>Estrada</em> e posicione-o em <em>(0, 0, 0)</em> . <br><br>  Agora clique com o bot√£o direito do mouse em <em>Road</em> in the <em>Hierarchy</em> e crie outro objeto de jogo vazio como filho de Road.  Nomeie-o como <em>Waypoint0</em> e coloque-o no ponto <em>(-12, 2, 0)</em> - a partir daqui os inimigos come√ßar√£o seu movimento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  Da mesma forma, crie mais cinco pontos de rota com os seguintes nomes e posi√ß√µes: <br><br><ul><li>  Ponto de passagem1: (X: 7, Y: 2, Z: 0) </li><li>  Waypoint2: (X: 7, Y: -1, Z: 0) </li><li>  Ponto de refer√™ncia3: (X: -7.3, Y: -1, Z: 0) </li><li>  Ponto de refer√™ncia4: (X: -7.3, Y: -4.5, Z: 0) </li><li>  Ponto de refer√™ncia5: (X: 7, Y: -4,5, Z: 0) </li></ul><br>  A captura de tela abaixo mostra os pontos da rota e o caminho resultante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Fazendo inimigos </h2><br>  Agora crie alguns inimigos para que eles possam se mover pela estrada.  H√° uma pr√©- <em>fabrica√ß√£o</em> <em>inimiga</em> na pasta <em>Prefabs</em> .  Sua posi√ß√£o √© <em>(-20, 0, 0)</em> , portanto, novas inst√¢ncias ser√£o criadas fora da tela. <br><br>  Em todos os outros aspectos, ele √© configurado quase da mesma maneira que o pr√©-fabricado Monster, possui o <code>AudioSource</code> e uma subsidi√°ria da <code>Sprite</code> , e podemos rotacionar esse sprite no futuro sem virar a barra de integridade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Movemos inimigos ao longo da estrada </h3><br>  Adicione um novo script <em>C #</em> chamado <em>MoveEnemy</em> √† <em>prefab Prefabs \ Enemy</em> .  Abra o script no IDE e adicione as seguintes vari√°veis: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  Nos <code>waypoints</code> , uma c√≥pia dos pontos de rota √© armazenada na matriz, e a linha <code>[HideIn <em>inspector</em> ]</code> acima dos <code>waypoints</code> garante que n√£o possamos alterar acidentalmente esse campo no <em><em>Inspector</em></em> , mas ainda assim teremos acesso a partir de outros scripts. <br><br>  <code>currentWaypoint</code> rastreia a localiza√ß√£o da rota do inimigo no momento atual e <code>lastWaypointSwitchTime</code> armazena o tempo que o inimigo passou por ela.  Al√©m disso, armazenamos a <code>speed</code> inimigo. <br><br>  Adicione esta linha ao <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Portanto, inicializamos <code>lastWaypointSwitchTime</code> com o valor do hor√°rio atual. <br><br>  Para que o inimigo se mova ao longo da rota, adicione o seguinte c√≥digo a <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Vamos analisar o c√≥digo passo a passo: <br><br><ol><li>  A partir da matriz de pontos de rota, obtemos as posi√ß√µes inicial e final do segmento de rota atual. </li><li>  Calculamos o tempo necess√°rio para percorrer toda a dist√¢ncia usando a f√≥rmula <em>tempo = dist√¢ncia / velocidade</em> e, em seguida, determinamos a hora atual na rota.  Usando <code>Vector2.Lerp</code> , interpolamos a posi√ß√£o atual do inimigo entre o segmento exato inicial e final. </li><li>  Verifique se o inimigo atingiu <code>endPosition</code> .  Se sim, ent√£o processamos dois cen√°rios poss√≠veis: <br><ol><li>  O inimigo ainda n√£o atingiu o √∫ltimo ponto da rota, ent√£o aumente o valor do <code>currentWaypoint</code> e atualize <code>lastWaypointSwitchTime</code> .  Mais tarde, adicionaremos um c√≥digo para transformar o inimigo, para que ele olhe na dire√ß√£o de seu movimento. </li><li>  O inimigo atingiu o √∫ltimo ponto da rota, depois a destru√≠mos e iniciamos o efeito sonoro.  Mais tarde, adicionaremos um c√≥digo que reduz a <code>health</code> do jogador. </li></ol></li></ol><br>  Salve o arquivo e retorne ao Unity. <br><br><h3>  Informamos os inimigos da dire√ß√£o do movimento </h3><br>  No estado atual, os inimigos n√£o sabem a ordem dos pontos da rota. <br><br>  Selecione <em>Estrada</em> na <em>Hierarquia</em> e adicione um novo script <em>C #</em> chamado <em>SpawnEnemy</em> .  Abra-o no IDE e adicione a seguinte vari√°vel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Usaremos <code>waypoints</code> para armazenar refer√™ncias ao waypoint na cena na ordem desejada. <br><br>  Salve o arquivo e retorne ao Unity.  Selecione <em>Estrada</em> na <em>Hierarquia</em> e defina o <em>tamanho da</em> matriz de <em>Waypoints</em> como <em>6</em> . <br><br>  Arraste cada um dos filhos da Estrada para os campos colando <em>Waypoint0</em> no <em>Elemento 0</em> , <em>Waypoint1</em> no <em>Elemento 1</em> e assim por diante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Agora temos uma matriz que cont√©m os pontos de rota na ordem correta - lembre-se, os inimigos nunca recuam, eles persistentemente lutam por uma recompensa doce. <br><br><h3>  Veja como tudo funciona </h3><br>  Abra <em>SpawnEnemy</em> no IDE e adicione a seguinte vari√°vel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  Ele armazenar√° uma refer√™ncia √† <code>testEnemyPrefab</code> do <em>Inimigo</em> em <code>testEnemyPrefab</code> . <br><br>  Para criar um inimigo ao executar o script, adicione o seguinte c√≥digo ao <code>Start()</code> : <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Portanto, criaremos uma nova c√≥pia da pr√©-fabricada armazenada no <code>testEnemy</code> e atribuiremos uma rota a ela. <br><br>  Salve o arquivo e retorne ao Unity.  Selecione o objeto <em>Estrada</em> na <em>Hierarquia</em> e selecione a <em>predefini√ß√£o</em> do <em>Inimigo</em> para o par√¢metro <em>Test Enemy</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie o projeto e veja como o inimigo se move ao longo da estrada (no GIF, para maior clareza, a velocidade √© aumentada em 20 vezes). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percebeu que ele nem sempre olha para onde est√° indo? </font><font style="vertical-align: inherit;">√â engra√ßado, mas estamos tentando fazer um jogo profissional. </font><font style="vertical-align: inherit;">Portanto, na segunda parte do tutorial, ensinaremos os inimigos a olhar para frente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para onde ir a seguir? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° fizemos muito e estamos avan√ßando rapidamente para criar nosso pr√≥prio jogo de defesa de torre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os jogadores podem criar um n√∫mero limitado de monstros, e o inimigo corre ao longo da estrada, indo em dire√ß√£o ao nosso cookie. </font><font style="vertical-align: inherit;">Os jogadores t√™m ouro e podem atualizar monstros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fa√ßa o download do resultado final </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda parte,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consideraremos a cria√ß√£o de enormes ondas de inimigos e sua destrui√ß√£o. </font><font style="vertical-align: inherit;">At√© breve!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413837/">https://habr.com/ru/post/pt413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413817/index.html">Processamento de dados competitivo heterog√™neo em tempo real estritamente uma vez</a></li>
<li><a href="../pt413819/index.html">Honestamente sobre o mercado de TI na R√∫ssia</a></li>
<li><a href="../pt413823/index.html">O boom do emprego sem sentido</a></li>
<li><a href="../pt413827/index.html">Projeto Kubernetes faz 4 anos</a></li>
<li><a href="../pt413831/index.html">A nova vers√£o do Tesla Autopilot ser√° lan√ßada em agosto, pela primeira vez com "recursos de dire√ß√£o totalmente aut√¥nomos"</a></li>
<li><a href="../pt413839/index.html">AI, curso pr√°tico. Coleta e pesquisa de imagens</a></li>
<li><a href="../pt413841/index.html">Alternativas aos produtos do Google</a></li>
<li><a href="../pt413843/index.html">Waymo √† frente do resto: os robomobiles da empresa rodaram 11 milh√µes de quil√¥metros</a></li>
<li><a href="../pt413847/index.html">Monumento de gatilho "vivo"</a></li>
<li><a href="../pt413849/index.html">Hist√≥ria da marca Sennheiser: liberdade e vis√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>