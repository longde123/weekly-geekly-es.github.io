<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüé§ ü§≥üèª üßóüèª Mecanismos JavaScript: como eles funcionam? Da pilha de chamadas √†s promessas, (quase) tudo o que voc√™ precisa saber üò≥ üëäüèæ üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ j√° se perguntou como os navegadores leem e executam o c√≥digo JavaScript? Parece misterioso, mas neste post voc√™ pode ter uma id√©ia do que est√° ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mecanismos JavaScript: como eles funcionam? Da pilha de chamadas √†s promessas, (quase) tudo o que voc√™ precisa saber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Voc√™ j√° se perguntou como os navegadores leem e executam o c√≥digo JavaScript?  Parece misterioso, mas neste post voc√™ pode ter uma id√©ia do que est√° acontecendo sob o cap√¥. <br><br>  Come√ßamos nossa jornada para o idioma com uma excurs√£o ao maravilhoso mundo dos mecanismos JavaScript. <br><a name="habracut"></a><br>  Abra o console no Chrome e v√° para a guia Fontes.  Voc√™ ver√° v√°rias se√ß√µes, e uma das mais interessantes √© chamada <b>Pilha de chamadas</b> (no Firefox, voc√™ ver√° Pilha de chamadas quando colocar um ponto de interrup√ß√£o no c√≥digo): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  O que √© uma pilha de chamadas?  Parece haver muita coisa acontecendo, mesmo para executar algumas linhas de c√≥digo.  De fato, o JavaScript n√£o vem em uma caixa em todos os navegadores.  H√° um grande componente que compila e interpreta nosso c√≥digo JavaScript - √© um mecanismo JavaScript.  Os mais populares s√£o o V8, usado no Google Chrome e Node.js, SpiderMonkey no Firefox, JavaScriptCore no Safari / WebKit. <br><br>  Atualmente, os mecanismos JavaScript s√£o √≥timos exemplos de engenharia de software e ser√° quase imposs√≠vel falar sobre todos os aspectos.  No entanto, o principal trabalho de execu√ß√£o de c√≥digo √© realizado para n√≥s por apenas alguns componentes dos mecanismos: pilha de chamadas (pilha de chamadas), mem√≥ria global (mem√≥ria global) e contexto de execu√ß√£o (contexto de execu√ß√£o).  Pronto para conhec√™-los? <br><br>  Conte√∫do: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos JavaScript e mem√≥ria global</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos JavaScript: como eles funcionam?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Contexto de execu√ß√£o global e pilha de chamadas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript √© single-threaded e outras hist√≥rias divertidas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript ass√≠ncrono, fila de retorno de chamada e loop de eventos</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inferno de retorno de chamada e promete ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando e trabalhando com promessas de JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tratamento de erros nas promessas do ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Combinadores do ES6 Promise: Promise.all, Promise.allSettled, Promise.any e outros</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Promessas do ES6 e fila de microtask</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos JavaScript: como eles funcionam?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evolu√ß√£o ass√≠ncrona: das promessas ao ass√≠ncrono / aguardar</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos JavaScript: como eles funcionam?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> <br></li></ol><br><a name="1"></a><h2>  1. Mecanismos JavaScript e mem√≥ria global </h2><br>  Eu disse que o JavaScript √© uma linguagem compilada e interpretada.  Acredite ou n√£o, os mecanismos JavaScript realmente compilam seu microssegundo de c√≥digo antes de ser executado. <br><br>  Algum tipo de m√°gica, hein?  Essa m√°gica √© chamada JIT (compila√ß√£o Just in time).  Por si s√≥, √© um grande t√≥pico de discuss√£o, mesmo os livros n√£o ser√£o suficientes para descrever o trabalho do JIT.  Mas, por enquanto, vamos pular a teoria e focar na fase de execu√ß√£o, o que n√£o √© menos interessante. <br><br>  Para come√ßar, veja este c√≥digo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Suponha que eu pergunte como esse c√≥digo √© processado em um navegador.  O que voc√™ vai responder?  Voc√™ pode dizer: ‚Äúo navegador l√™ o c√≥digo‚Äù ou ‚Äúo navegador executa o c√≥digo‚Äù.  Na realidade, nem tudo √© t√£o simples.  Primeiro, o c√≥digo √© lido n√£o pelo navegador, mas pelo mecanismo.  <b>O mecanismo JavaScript l√™ o c√≥digo</b> e, assim que define a primeira linha, coloca alguns links na <b>mem√≥ria global</b> . <br><br>  Mem√≥ria global (tamb√©m chamada heap) √© a √°rea na qual o mecanismo JavaScript armazena vari√°veis ‚Äã‚Äãe declara√ß√µes de fun√ß√£o.  E quando ele ler o c√≥digo acima, dois fich√°rios aparecer√£o na mem√≥ria global: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Mesmo que o exemplo contenha apenas uma vari√°vel e uma fun√ß√£o, imagine que seu c√≥digo JavaScript seja executado em um ambiente maior: em um navegador ou em Node.js.  Em tais ambientes, existem muitas fun√ß√µes e vari√°veis ‚Äã‚Äãpredefinidas que s√£o chamadas globais.  Portanto, a mem√≥ria global conter√° muito mais dados do que apenas <code>num</code> e <code>pow</code> , lembre-se. <br><br>  Nada est√° funcionando no momento.  Vamos agora tentar executar nossa fun√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  O que vai acontecer?  E algo interessante vai acontecer.  Ao chamar a fun√ß√£o, o mecanismo JavaScript destacar√° duas se√ß√µes: <br><br><ul><li>  Contexto de execu√ß√£o global <br></li><li>  Pilha de chamadas <br></li></ul><br>  O que eles s√£o? <br><br><a name="2"></a><h2>  2. Mecanismos JavaScript: como eles funcionam?  Contexto de execu√ß√£o global e pilha de chamadas </h2><br>  Voc√™ aprendeu como o mecanismo JavaScript l√™ vari√°veis ‚Äã‚Äãe declara√ß√µes de fun√ß√£o.  Eles caem na mem√≥ria global (heap). <br><br>  Mas agora estamos executando uma fun√ß√£o JavaScript, e o mecanismo deve cuidar disso.  Como  Cada mecanismo JavaScript possui um <b>componente-chave chamado pilha de chamadas</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Essa √© uma estrutura de dados empilhados</a> : os elementos podem ser adicionados a partir de cima, mas eles n√£o podem ser exclu√≠dos da estrutura enquanto houver outros elementos acima deles.  √â assim que as fun√ß√µes JavaScript funcionam.  Na execu√ß√£o, eles n√£o podem sair da pilha de chamadas se outra fun√ß√£o estiver presente nela.  Observe isso, pois esse conceito ajuda a entender a declara√ß√£o "JavaScript √© de thread √∫nico". <br><br>  Mas voltando ao nosso exemplo.  <b>Quando uma fun√ß√£o √© chamada, o mecanismo a envia para a pilha de chamadas</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  Eu gosto de apresentar a pilha de chamadas como uma pilha de chips Pringles.  N√£o podemos comer batatas fritas do fundo da pilha at√© comermos as que est√£o em cima.  Felizmente, nossa fun√ß√£o √© s√≠ncrona: √© apenas uma multiplica√ß√£o que √© calculada rapidamente. <br><br>  Ao mesmo tempo, o mecanismo coloca o <b>contexto de execu√ß√£o global</b> na mem√≥ria, este √© o ambiente global no qual o c√≥digo JavaScript √© executado.  Aqui est√° o que parece: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Imagine um contexto de execu√ß√£o global na forma de um mar no qual as fun√ß√µes globais do JavaScript flutuam como peixes.  Que doce!  Mas isso √© apenas metade da hist√≥ria.  E se nossa fun√ß√£o tiver vari√°veis ‚Äã‚Äãaninhadas ou fun√ß√µes internas? <br><br>  Mesmo no caso simples, como mostrado abaixo, o mecanismo JavaScript cria um <b>contexto de execu√ß√£o local</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Observe que eu adicionei a vari√°vel <code>fixed</code> √† fun√ß√£o <code>pow</code> .  Nesse caso, o contexto de execu√ß√£o local conter√° uma se√ß√£o para <code>fixed</code> .  N√£o sou muito bom em desenhar pequenos ret√¢ngulos dentro de outros pequenos ret√¢ngulos, ent√£o use sua imagina√ß√£o. <br><br>  Um contexto de execu√ß√£o local aparecer√° pr√≥ximo a <code>pow</code> , dentro da se√ß√£o retangular verde localizada dentro do contexto de execu√ß√£o global.  Imagine tamb√©m como, para cada fun√ß√£o aninhada dentro da fun√ß√£o aninhada, o mecanismo cria outros contextos de execu√ß√£o local.  Todas essas se√ß√µes retangulares aparecem muito rapidamente!  Como uma boneca de ninho! <br><br>  Vamos voltar √† hist√≥ria single-threaded.  O que isso significa? <br><br><a name="3"></a><h2>  3. JavaScript √© single-threaded e outras hist√≥rias divertidas </h2><br>  Dizemos que o <b>JavaScript √© de thread √∫nico porque apenas uma pilha de chamadas lida com nossas fun√ß√µes</b> .  Deixe-me lembr√°-lo de que as fun√ß√µes n√£o podem sair da pilha de chamadas se outras fun√ß√µes esperarem execu√ß√£o. <br><br>  Isso n√£o √© um problema se trabalharmos com c√≥digo s√≠ncrono.  Por exemplo, a adi√ß√£o de dois n√∫meros √© s√≠ncrona e √© calculada em microssegundos.  E as chamadas de rede e outras intera√ß√µes com o mundo exterior? <br><br>  Felizmente, os <b>mecanismos JavaScript s√£o projetados para funcionar de forma ass√≠ncrona por padr√£o</b> .  Mesmo que eles possam executar apenas uma fun√ß√£o por vez, fun√ß√µes mais lentas podem ser executadas por uma entidade externa - no nosso caso, √© um navegador.  Falaremos sobre isso abaixo. <br><br>  Ao mesmo tempo, voc√™ sabe que quando o navegador carrega algum tipo de c√≥digo JavaScript, o mecanismo l√™ esse c√≥digo linha por linha e executa as seguintes etapas: <br><br><ul><li>  Coloca vari√°veis ‚Äã‚Äãe declara√ß√µes de fun√ß√£o na mem√≥ria global (heap). <br></li><li>  Envia uma chamada para cada fun√ß√£o na pilha de chamadas. <br></li><li>  Cria um contexto de execu√ß√£o global no qual as fun√ß√µes globais s√£o executadas. <br></li><li>  Cria muitos pequenos contextos de execu√ß√£o local (se houver vari√°veis ‚Äã‚Äãinternas ou fun√ß√µes aninhadas). <br></li></ul><br>  Agora voc√™ tem um entendimento b√°sico da mec√¢nica de sincroniza√ß√£o subjacente a todos os mecanismos JavaScript.  No pr√≥ximo cap√≠tulo, falaremos sobre como o c√≥digo ass√≠ncrono funciona em JavaScript e por que funciona dessa maneira. <br><br><a name="4"></a><h2>  4. JavaScript ass√≠ncrono, fila de retorno de chamada e loop de eventos </h2><br>  Gra√ßas √† mem√≥ria global, ao contexto de execu√ß√£o e √† pilha de chamadas, o c√≥digo JavaScript s√≠ncrono √© executado em nossos navegadores.  Mas esquecemos algo.  O que acontece se voc√™ precisar executar algum tipo de fun√ß√£o ass√≠ncrona? <br><br>  Por fun√ß√£o ass√≠ncrona, quero dizer todas as intera√ß√µes com o mundo exterior, o que pode levar algum tempo para ser conclu√≠do.  Chamar a API REST ou o timer √© ass√≠ncrono, porque pode levar alguns segundos para execut√°-los.  Gra√ßas aos elementos dispon√≠veis no mecanismo, podemos processar essas fun√ß√µes sem bloquear a pilha de chamadas e o navegador.  N√£o se esque√ßa, a pilha de chamadas pode executar apenas uma fun√ß√£o de cada vez, e <b>mesmo uma fun√ß√£o de bloqueio pode literalmente parar o navegador</b> .  Felizmente, os mecanismos JavaScript s√£o inteligentes e, com uma pequena ajuda do navegador, podem resolver as coisas. <br><br>  Quando executamos uma fun√ß√£o ass√≠ncrona, o navegador pega e executa para n√≥s.  Tome um cron√¥metro como este: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Tenho certeza de que, embora voc√™ j√° tenha visto <code>setTimeout</code> centenas de vezes, talvez n√£o saiba que <b>essa fun√ß√£o n√£o est√° embutida no JavaScript</b> .  Portanto, quando o JavaScript apareceu, n√£o havia nenhuma fun√ß√£o <code>setTimeout</code> .  De fato, faz parte das chamadas APIs do navegador, uma cole√ß√£o de ferramentas convenientes que o navegador nos fornece.  Maravilhoso!  Mas o que isso significa na pr√°tica?  Como <code>setTimeout</code> pertence √† API do navegador, essa fun√ß√£o √© executada pelo pr√≥prio navegador (por um momento, aparece na pilha de chamadas, mas √© imediatamente exclu√≠da a partir da√≠). <br><br>  Ap√≥s 10 segundos, o navegador pega a fun√ß√£o de retorno de chamada que passamos para ele e a coloca na <b>fila de retorno de chamada</b> .  No momento, mais duas se√ß√µes de ret√¢ngulo apareceram no mecanismo JavaScript.  D√™ uma olhada neste c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Agora, nosso esquema fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> √© executado dentro do contexto do navegador.  Ap√≥s 10 segundos, o timer inicia e a fun√ß√£o de retorno de chamada est√° pronta para execu√ß√£o.  Mas primeiro, ele deve passar pela fila de retorno de chamada.  Essa √© uma estrutura de dados na forma de uma fila e, como o nome indica, √© uma fila de fun√ß√µes ordenada. <br><br>  Cada fun√ß√£o ass√≠ncrona deve passar por uma fila de retorno de chamada antes de entrar na pilha de chamadas.  Mas quem envia as fun√ß√µes a seguir?  Isso cria um componente chamado <b>loop de evento</b> . <br><br>  At√© agora, o loop de eventos lida com apenas uma coisa: verifica se a pilha de chamadas est√° vazia.  Se houver alguma fun√ß√£o na fila de retorno de chamada e se a pilha de chamadas estiver livre, √© hora de enviar uma chamada de retorno para a pilha de chamadas. <br><br>  Depois disso, a fun√ß√£o √© considerada executada.  Este √© o esquema geral para processar c√≥digo ass√≠ncrono e s√≠ncrono com o mecanismo JavaScript: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Digamos que <code>callback()</code> esteja pronto para execu√ß√£o.  Quando <code>pow()</code> <b>a pilha de chamadas √© liberada e o loop de eventos envia</b> <code>callback()</code> .  E √© isso a√≠!  Embora tenha simplificado um pouco as coisas, se voc√™ entender o diagrama acima, poder√° entender todo o JavaScript. <br><br>  Lembre-se: <b>APIs baseadas em navegador, filas de retorno de chamada e loops de eventos s√£o os pilares do JavaScript ass√≠ncrono</b> . <br><br>  E se voc√™ estiver interessado, assista ao curioso v√≠deo ‚ÄúO que diabos √© o loop de eventos de qualquer maneira‚Äù, de Philip Roberts.  Essa √© uma das melhores explica√ß√µes para o loop de eventos. <br><br>  Mas ainda n√£o terminamos o tema JavaScript ass√≠ncrono.  Nos pr√≥ximos cap√≠tulos, consideraremos as promessas do ES6. <br><br><a name="5"></a><h2>  5. Inferno de retorno de chamada e ES6 promete </h2><br>  As fun√ß√µes de retorno de chamada s√£o usadas em JavaScript em qualquer lugar, tanto no c√≥digo s√≠ncrono quanto no ass√≠ncrono.  Considere este m√©todo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> √© uma fun√ß√£o de retorno de chamada que √© passada dentro do <code>map</code> .  O c√≥digo acima √© s√≠ncrono.  Agora considere este intervalo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Esse c√≥digo √© ass√≠ncrono, porque dentro de <code>setInterval</code> passamos o retorno de chamada runMeEvery.  Os retornos de chamada s√£o usados ‚Äã‚Äãem todo o JavaScript; portanto, h√° anos temos um problema chamado "inferno de retorno de chamada" - "inferno de retorno de chamada". <br><br>  O termo <b>inferno de retorno de</b> chamada em JavaScript √© aplicado ao "estilo" de programa√ß√£o no qual os retornos de chamada s√£o incorporados em outros retornos de chamada incorporados em outros retornos de chamada ... Devido √† natureza ass√≠ncrona, os programadores de JavaScript h√° muito tempo caem nessa armadilha. <br><br>  Para ser sincero, nunca criei grandes pir√¢mides de retorno de chamada.  Talvez porque eu valorize um c√≥digo leg√≠vel e sempre tente manter seus princ√≠pios.  Se voc√™ atingir o inferno de retorno de chamada, significa que sua fun√ß√£o faz muito. <br><br>  N√£o falarei em detalhes sobre o inferno de retorno de chamada, se voc√™ estiver interessado, v√° para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">callbackhell.com</a> , onde esse problema foi investigado em detalhes e v√°rias solu√ß√µes foram propostas.  E falaremos sobre as <b>promessas do ES6</b> .  Este √© um complemento do JavaScript desenvolvido para resolver o problema de retorno de chamada do inferno.  Mas quais s√£o as promessas? <br><br>  <b>Uma promessa de JavaScript √© uma representa√ß√£o de um evento futuro</b> .  Uma promessa pode terminar com √™xito ou, no jarg√£o dos programadores, uma promessa ser√° "resolvida" (resolvida).  Mas se a promessa termina com um erro, dizemos que est√° no estado rejeitado.  As promessas tamb√©m t√™m um estado padr√£o: cada nova promessa come√ßa em um estado pendente.  Posso criar minha pr√≥pria promessa?  Sim  Falaremos sobre isso no pr√≥ximo cap√≠tulo. <br><br><a name="6"></a><h2>  6. Criando e trabalhando com promessas de JavaScript </h2><br>  Para criar uma nova promessa, voc√™ precisa chamar o construtor passando uma fun√ß√£o de retorno de chamada para ele.  Pode levar apenas dois par√¢metros: <code>resolve</code> e <code>reject</code> .  Vamos criar uma nova promessa que ser√° resolvida em 5 segundos (voc√™ pode testar os exemplos no console do navegador): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Como voc√™ pode ver, <code>resolve</code> √© uma fun√ß√£o que chamamos para que a promessa termine com sucesso.  E <code>reject</code> criar√° uma promessa rejeitada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Observe que voc√™ pode ignorar a <code>reject</code> porque este √© o segundo par√¢metro.  Mas se voc√™ pretende usar <code>reject</code> , n√£o <b>pode ignorar a <code>resolve</code></b> .  Ou seja, o c√≥digo a seguir n√£o funcionar√° e terminar√° com uma promessa permitida: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Promessas n√£o parecem t√£o √∫teis agora, certo?  Esses exemplos n√£o exibem nada para o usu√°rio.  Vamos adicionar algo.  E permitidas, promessas rejeitadas podem retornar dados.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Mas ainda n√£o vemos nada.  <b>Para extrair dados de uma promessa, voc√™ precisa associ√°-la ao m√©todo <code>then</code></b> .  Ele recebe um retorno de chamada (que ironia!), Que recebe os dados atuais: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Como desenvolvedor de JavaScript e consumidor de c√≥digo de outras pessoas, voc√™ interage principalmente com promessas externas.  Os criadores de bibliotecas geralmente envolvem c√≥digo legado em um construtor Promise, assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  E, se necess√°rio, tamb√©m podemos criar e resolver uma promessa chamando <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Ent√£o, deixe-me lembr√°-lo: as promessas de JavaScript s√£o um favorito para um evento que acontecer√° no futuro.  Um evento come√ßa no estado "aguardando uma decis√£o" e pode ser bem-sucedido (permitido, executado) ou malsucedido (rejeitado).  Uma promessa pode retornar dados que podem ser recuperados anexando <code>then</code> .  No pr√≥ximo cap√≠tulo, discutiremos como lidar com erros provenientes de promessas. <br><br><a name="7"></a><h2>  7. Tratamento de erros nas promessas do ES6 </h2><br>  Lidar com erros no JavaScript sempre foi f√°cil, pelo menos no c√≥digo s√≠ncrono.  Veja um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  O resultado ser√°: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Como esperado, o erro caiu no <code>catch</code> .  Agora tente a fun√ß√£o ass√≠ncrona: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Este c√≥digo √© ass√≠ncrono devido ao <code>setTimeout</code> .  O que acontecer√° se o executarmos? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Agora o resultado √© diferente.  O erro n√£o foi detectado pelo <code>catch</code> , mas aumentou livremente a pilha.  O motivo √© que o <code>try/catch</code> funciona apenas com c√≥digo s√≠ncrono.  Se voc√™ quiser saber mais, esse problema √© discutido em detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Felizmente, com promessas, podemos lidar com erros ass√≠ncronos como se fossem s√≠ncronos.  No √∫ltimo cap√≠tulo, eu disse que chamar <code>reject</code> leva a uma rejei√ß√£o da promessa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  Nesse caso, podemos lidar com erros usando o manipulador de <code>catch</code> puxando (novamente) um retorno de chamada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Al√©m disso, para criar e rejeitar uma promessa no lugar certo, voc√™ pode chamar <code>Promise.reject()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Deixe-me lembr√°-lo: o manipulador <code>then</code> √© executado quando a promessa √© executada e o manipulador <code>catch</code> √© executado para promessas rejeitadas.  Mas este n√£o √© o fim da hist√≥ria.  Abaixo, veremos como o <code>async/await</code> funciona muito bem com o <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinadores das promessas do ES6: Promise.all, Promise.allSettled, Promise.any e outros </h2><br>  As promessas n√£o foram projetadas para funcionar sozinhas.  A API Promise oferece v√°rios m√©todos para <b>combinar promessas</b> .  Um dos mais √∫teis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√© o Promise.all</a> , ele pega uma matriz de promessas e retorna uma promessa.  O √∫nico problema √© que Promise.all √© rejeitado se pelo menos uma promessa na matriz for rejeitada. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Promise.race</a> permite ou rejeita assim que uma das promessas da matriz recebe o status correspondente. <br><br>  Nas vers√µes mais recentes do V8, dois novos combinadores tamb√©m ser√£o introduzidos: <code>Promise.allSettled</code> e <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Promise.any</a> ainda est√° em um est√°gio inicial da funcionalidade proposta, no momento da reda√ß√£o deste artigo n√£o √© suportado.  No entanto, em teoria, ele ser√° capaz de sinalizar se alguma promessa foi executada.  A diferen√ßa do <code>Promise.race</code> √© que <b>Promise.any n√£o √© rejeitado, mesmo que uma das promessas seja rejeitada</b> . <br><br>  <code>Promise.allSettled</code> ainda mais interessante.  Ele tamb√©m aceita uma s√©rie de promessas, mas n√£o "encurta" se uma das promessas √© rejeitada.  √â √∫til quando voc√™ precisa verificar se todas as promessas em uma matriz foram aprovadas em algum est√°gio, independentemente da presen√ßa de promessas rejeitadas.  Pode ser considerado o oposto de <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. Promessas ES6 e a fila de microtask </h2><br>  Se voc√™ se lembra do cap√≠tulo anterior, cada fun√ß√£o de retorno de chamada ass√≠ncrona em JavaScript est√° na fila de retorno de chamada antes de atingir a pilha de chamadas.  Mas as fun√ß√µes de retorno de chamada transmitidas ao Promise t√™m um destino diferente: elas s√£o processadas pela fila de microtask, em vez da fila de tarefas. <br><br>  E aqui voc√™ precisa ter cuidado: a <b>fila de microtask precede a fila de chamadas</b> .  Os retornos de chamada da fila de microtask t√™m preced√™ncia quando o loop de eventos verifica se novos retornos de chamada est√£o prontos para entrar na pilha de chamadas. <br><br>  Essa mec√¢nica √© descrita mais detalhadamente por Jake Archibald em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, microtarefas, filas e agendas</a> , √≥tima leitura. <br><br><a name="10"></a><h2>  10. Mecanismos JavaScript: como eles funcionam?  Evolu√ß√£o ass√≠ncrona: das promessas ao ass√≠ncrono / aguardar </h2><br>  O JavaScript est√° evoluindo rapidamente e estamos constantemente recebendo melhorias a cada ano.  As promessas pareciam um final, mas <b>com o ECMAScript 2017 (ES8) uma nova sintaxe apareceu: <code>async/await</code></b> . <br><br>  <code>async/await</code> √© apenas uma melhoria estil√≠stica que chamamos de a√ß√∫car sint√°tico.  <code>async/await</code> n√£o altera o JavaScript de forma alguma (n√£o esque√ßa que o idioma deve ser compat√≠vel com os navegadores antigos e n√£o deve quebrar o c√≥digo existente).  Esta √© apenas uma nova maneira de escrever c√≥digo ass√≠ncrono com base em promessas.  Considere um exemplo.  Acima, j√° salvamos a promessa no correspondente <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Agora, <b>com <code>async/await</code> , podemos processar o c√≥digo ass√≠ncrono para que, para o leitor da nossa listagem, o c√≥digo pare√ßa s√≠ncrono</b> .  Em vez de us√° <code>then</code> podemos cumprir a promessa em uma fun√ß√£o denominada <code>async</code> e <code>await</code> resultado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Parece bom, certo?  √â engra√ßado que uma fun√ß√£o ass√≠ncrona sempre retorne uma promessa e ningu√©m pode impedi-lo de fazer isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  E os erros?  Uma das vantagens do <code>async/await</code> √© que essa constru√ß√£o pode nos permitir usar <code><b>try/catch</b></code> .  Leia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o ao tratamento de erros nas fun√ß√µes ass√≠ncronas e seus testes</a> . <br><br>  Vamos dar uma olhada na promessa novamente, na qual lidamos com erros com o manipulador de <code>catch</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Com fun√ß√µes ass√≠ncronas, podemos refatorar assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  No entanto, nem todo mundo mudou para esse estilo.  <code>try/catch</code> pode complicar seu c√≥digo.  H√° mais uma coisa a considerar.  Veja como ocorre um erro dentro deste bloco <code>try</code> neste c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  E as duas linhas exibidas no console?  Lembre-se de que <b><code>try/catch</code> √© uma constru√ß√£o s√≠ncrona e nossa fun√ß√£o ass√≠ncrona gera uma promessa</b> .  Eles seguem dois caminhos diferentes, como trens.     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     ¬´Catch me if you can¬ª,    ¬´I will run no matter what!¬ª. <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> ‚Äî   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript ‚Äî     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   ¬´¬ª :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  ‚Äî   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452906/">https://habr.com/ru/post/pt452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452892/index.html">Como um n√£o programador pode se mudar para os EUA: instru√ß√µes passo a passo</a></li>
<li><a href="../pt452894/index.html">Enfrente o Anti-Spoofing ou reconhe√ßa tecnologicamente um trapaceiro entre mil</a></li>
<li><a href="../pt452900/index.html">√çndices no PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../pt452902/index.html">Terminando 4 anos de treinamento como programador, entendo que estou longe de ser um programador</a></li>
<li><a href="../pt452904/index.html">Como as m√°quinas se comunicam - protocolo MQTT</a></li>
<li><a href="../pt452908/index.html">Selenium WebDriver - M√©trica de teste em tempo real usando Grafana e InfluxDB</a></li>
<li><a href="../pt452910/index.html">Ol√° Habr! Ol√° Tercon</a></li>
<li><a href="../pt452914/index.html">ML em Scala com um sorriso, para aqueles que n√£o t√™m medo de experimenta√ß√£o</a></li>
<li><a href="../pt452916/index.html">Levante-se e v√° embora. Cirurgia da coluna vertebral: quando fazer, o que √© perigoso</a></li>
<li><a href="../pt452922/index.html">Tabelas de grade CSS flex√≠veis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>