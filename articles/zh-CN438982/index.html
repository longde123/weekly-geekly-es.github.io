<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏻 🧑🏽‍🤝‍🧑🏼 👨🏿‍🚀 Kubernetes指南，第1部分：应用程序，微服务和容器 🤹 ⚛️ 🔰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="根据我们的要求，Habr创建了Kubernetes中心，我们很高兴在其中发布第一本出版物。 订阅！ 
 Kubernetes很容易。 为什么银行要为我在这方面的工作支付很多钱，而任何人都可以在几个小时内掌握这项技术？ 

  

 如果您怀疑Kubernetes可以这么快地学习，建议您自己尝试一下。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes指南，第1部分：应用程序，微服务和容器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438982/"><blockquote> 根据我们的要求，Habr创建了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes</a>中心，我们很高兴在其中发布第一本出版物。 订阅！ </blockquote><br>  Kubernetes很容易。 为什么银行要为我在这方面的工作支付很多钱，而任何人都可以在几个小时内掌握这项技术？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/d3/4l/ic/d34licaikjsxfxisetkc9arcpdi.jpeg"></a> <br><a name="habracut"></a><br> 如果您怀疑Kubernetes可以这么快地学习，建议您自己尝试一下。 也就是说，掌握了这些材料之后，您将能够在Kubernetes集群中基于微服务运行应用程序。 我可以保证，因为正是通过这里使用的方法，我训练Kubernetes与我们的客户一起工作。 该手册与其他手册有何区别？ 实际上-很多东西。 因此，大多数这些材料都是从对简单事物的解释开始的-Kubernetes的概念和kubectl团队的功能。 这些材料的作者认为，他们的读者熟悉应用程序开发，微服务和Docker容器。 我们将走另一条路。 首先，让我们讨论一下如何在计算机上运行基于微服务的应用程序。 然后考虑为每个微服务组装容器映像。 之后，我们将了解Kubernetes，并分析在Kubernetes管理的集群中基于微服务的应用程序的部署。 <br><br> 这种方法与Kubernetes的渐进方法相结合，将给普通人以深刻的理解，以便了解Kubernetes中所有事物的排列方式多么简单。 当然，Kubernetes是一种简单的技术，只要任何想学习它的人都知道在何处以及如何使用它。 <br><br> 现在，不用多说，让我们开始讨论我们将使用的应用程序。 <br><br><h2>  <font color="#3AC1EF">实验应用</font> </h2><br> 我们的应用程序将仅执行一项功能。 它接受一个句子作为输入，然后使用文本分析的方式对该句子进行情感分析，并接收该句子的作者对某个对象的情感态度的估计值。 <br><br> 这是该应用程序的主窗口。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/7e1/415/6747e14151585819867c880f52fa9d21.gif"></div><br>  <i><font color="#999999">Web应用程序用于文本情感分析</font></i> <br><br> 从技术角度来看，该应用程序包含三个微服务，每个微服务都可以解决一组特定的任务： <br><br><ul><li>  SA-Frontend是提供React静态文件的Nginx Web服务器。 </li><li>  SA-WebApp是基于Java的Web应用程序，可处理来自前端的请求。 </li><li>  SA-Logic是执行文本情感分析的Python应用程序。 </li></ul><br> 重要的是要注意，微服务不是孤立存在的。 它们实现了“职责分离”的思想，但是它们需要彼此交互。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/f93/0c0/94bf930c03220c1eec6957a0f7308046.gif"></div><br>  <i><font color="#999999">应用数据流</font></i> <br><br> 在上图中，您可以看到系统的编号阶段，说明了应用程序中的数据流。 让我们对其进行分析： <br><br><ol><li>浏览器从服务器请求<code>index.html</code>文件（服务器随后下载React应用程序包）。 </li><li> 用户与应用程序进行交互，这将导致对基于Spring的Web应用程序的调用。 </li><li> 该Web应用程序将文本分析请求重定向到Python应用程序。 </li><li>  Python应用程序分析文本的色调，并返回结果作为对请求的响应。 </li><li>  Spring应用程序将响应发送到React应用程序（然后，它向用户显示文本分析的结果）。 </li></ol><br> 所有这些应用程序的代码都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 我建议您现在将这个存储库复制到您自己，因为我们前面有许多有趣的实验。 <br><br><h2>  <font color="#3AC1EF">在本地计算机上启动基于微服务的应用程序</font> </h2><br> 为了使应用程序正常工作，我们需要运行所有三个微服务。 让我们从最有趣的内容开始-前端应用程序。 <br><br><h3>  <font color="#3AC1EF">React配置React进行本地开发</font> </h3><br> 为了运行React应用程序，您需要在计算机上安装Node.js和NPM平台。 安装完所有这些之后，通过终端进入<code>sa-frontend</code>项目文件夹并运行以下命令： <br><br><pre> <code class="plaintext hljs">npm install</code> </pre> <br> 由于执行了此命令，React-application的依赖项（有关其条目位于<code>package.json</code>文件中）将被加载到<code>node_modules</code>文件夹中。 将依赖项下载到同一文件夹后，运行以下命令： <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br> 仅此而已。 现在，React应用程序正在运行，可以通过浏览器中的<code>localhost:3000</code>地址来访问它。 您可以在他的代码中进行更改。 您将立即在浏览器中看到这些更改的效果。 这归功于所谓的“热”模块更换。 因此，前端开发变成了一个简单而有趣的任务。 <br><br><h3>  <font color="#3AC1EF">React准备React应用程序以输出到生产</font> </h3><br> 为了真正使用React应用程序，我们需要将其转换为一组静态文件，并使用Web服务器将其提供给客户端。 <br><br> 要再次构建React应用程序，请使用终端，进入<code>sa-frontend</code>文件夹并运行以下命令： <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> <br> 这将在项目文件夹中创建一个<code>build</code>目录。 它将包含React应用程序正常工作所需的所有静态文件。 <br><br><h3>  <font color="#3AC1EF">using使用Nginx工具提供静态文件</font> </h3><br> 首先，您需要安装并运行Nginx Web服务器。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>您可以下载它并找到安装和启动说明。 然后，您需要将<code>sa-frontend/build</code>文件夹的内容复制到<code>[your_nginx_installation_dir]/html</code>文件夹。 <br><br> 通过这种方法，可以在<code>[your_nginx_installation_dir]/html/index.html</code>获得在React应用程序构建期间生成的<code>index.html</code>文件。 默认情况下，这是Nginx服务器在访问文件时发出的文件。 服务器配置为侦听端口<code>80</code> ，但是您可以根据需要通过编辑文件<code>[your_nginx_installation_dir]/conf/nginx.conf</code> 。 <br><br> 现在打开浏览器并转到<code>localhost:80</code> 。 您将看到React应用程序页面。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a50/b83/f39/a50b83f390ff0434ef817f357a041941.png"></div><br>  <i><font color="#999999">Nginx服务器服务的React应用程序</font></i> <br><br> 如果您现在在“ <code>Type your sentence</code>字段中<code>Type your sentence</code> ，然后单击“ <code>Send</code>按钮，则不会发生任何事情。 但是，如果您查看控制台，则可以在其中看到错误消息。 为了准确了解这些错误发生的位置，让我们分析应用程序代码。 <br><br><h3>  <font color="#3AC1EF">▍分析前端应用程序代码</font> </h3><br> 查看了<code>App.js</code>文件的代码之后，我们可以看到单击“ <code>Send</code>按钮将调用<code>analyzeSentence()</code>方法。 下面给出了此方法的代码。 同时，请注意以下事实：对于每行都有<code># </code>形式的注释的代码，在代码下方给出了解释。 同样，我们将解析其他代码。 <br><br><pre> <code class="plaintext hljs">analyzeSentence() {   fetch('http://localhost:8080/sentiment', {  // #1       method: 'POST',       headers: {           'Content-Type': 'application/json'       },       body: JSON.stringify({                      sentence: this.textField.getValue()})// #2   })       .then(response =&gt; response.json())       .then(data =&gt; this.setState(data));  // #3 }</code> </pre> <br>  <b>1.</b>执行POST请求的URL。 可以理解，该地址包含一个正在等待此类请求的应用程序。 <br><br>  <b>2.</b>请求正文发送到应用程序。 这是一个示例请求正文： <br><br><pre> <code class="plaintext hljs">{   sentence: "I like yogobella!" }</code> </pre> <br>  <b>3.</b>收到对请求的响应后，组件状态将更新。 这将导致组件重新渲染。 如果我们接收到数据（即包含输入数据和计算出的文本分数的JSON对象），则将输出<code>Polarity</code>组件，因为将满足相应的条件。 这是我们描述组件的方式： <br><br><pre> <code class="plaintext hljs">const polarityComponent = this.state.polarity !== undefined ?   &lt;Polarity sentence={this.state.sentence}             polarity={this.state.polarity}/&gt; :   null;</code> </pre> <br> 该代码似乎运行良好。 毕竟这是怎么了？ 如果您假设在应用程序尝试发送POST请求的地址处，到目前为止没有任何东西可以接受和处理该请求，那么您将完全正确。 也就是说，要处理到达地址<code>http://localhost:8080/sentiment</code>请求，我们需要运行一个基于Spring的Web应用程序。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f16/5a3/848f165a308f9ae73ffd3f8186b23aee.png"></div><br>  <i><font color="#999999">我们需要一个可以接受POST请求的Spring应用程序。</font></i> <br><br><h3>  <font color="#3AC1EF">▍设置基于Spring的Web应用程序</font> </h3><br> 为了部署Spring应用程序，您将需要JDK8和Maven以及正确配置的环境变量。 安装完所有这些之后，您可以继续进行我们的项目。 <br><br><h3>  <font color="#3AC1EF">the将应用程序打包到jar文件中</font> </h3><br> 使用终端转到<code>sa-webapp</code>文件夹，然后输入以下命令： <br><br><pre> <code class="plaintext hljs">mvn install</code> </pre> <br> 执行此命令后，将在<code>sa-webapp</code>文件夹中创建<code>target</code>目录。 将有一个Java应用程序打包在一个由<code>sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code>表示的jar文件中。 <br><br><h3>  <font color="#3AC1EF">▍启动Java应用程序</font> </h3><br> 转到<code>target</code>文件夹并使用以下命令启动应用程序： <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> </pre> <br> 执行此命令期间将发生错误。 为了开始修复它，我们可以分析堆栈跟踪数据中的异常信息： <br><br><pre> <code class="plaintext hljs">Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value "${sa.logic.api.url}"</code> </pre> <br> 对于我们来说，最重要的是提到不可能确定<code>sa.logic.api.url</code>的含义。 让我们分析发生错误的代码。 <br><br><h3>  <font color="#3AC1EF">application Java应用程式程式码分析</font> </h3><br> 这是发生错误的代码段。 <br><br><pre> <code class="plaintext hljs">@CrossOrigin(origins = "*") @RestController public class SentimentController {   @Value("${sa.logic.api.url}")    // #1   private String saLogicApiUrl;   @PostMapping("/sentiment")   public SentimentDto sentimentAnalysis(       @RequestBody SentenceDto sentenceDto)   {       RestTemplate restTemplate = new RestTemplate();       return restTemplate.postForEntity(               saLogicApiUrl + "/analyse/sentiment",    // #2               sentenceDto, SentimentDto.class)               .getBody();   } }</code> </pre> <br><ol><li>  <code>entimentController</code>有一个<code>saLogicApiUrl</code>字段。 其值由<code>sa.logic.api.url</code>属性设置。 </li><li> 字符串<code>saLogicApiUrl</code>与值<code>/analyse/sentiment</code>连接在一起。 它们共同构成了访问执行文本分析的微服务的地址。 </li></ol><br><h3>  <font color="#3AC1EF">▍设置属性值</font> </h3><br> 在Spring中，属性值的标准来源是<code>application.properties</code>文件，该文件位于<code>sa-webapp/src/main/resources</code> 。 但是，它的使用不是设置属性值的唯一方法。 您可以使用以下命令来执行此操作： <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL</code> </pre> <br> 此属性的值应指向我们的Python应用程序的地址。 <br><br> 通过配置它，我们告诉Spring Web应用程序执行文本分析请求所需的位置。 <br><br> 为了不使我们的生活复杂化，我们决定将Python应用程序在<code>localhost:5000</code>上可用，并尽量不要忘记它。 结果，启动Spring应用程序的命令将如下所示： <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/445/815/30d44581533865907366e867c029124e.png"></div><br>  <i><font color="#999999">我们的系统缺少Python应用程序</font></i> <br><br> 现在我们只需要启动Python应用程序，系统就会按预期运行。 <br><br><h3>  <font color="#3AC1EF">▍配置Python应用程序</font> </h3><br> 为了运行Python应用程序，您必须安装Python 3和Pip，并且需要正确设置适当的环境变量。 <br><br><h3>  <font color="#3AC1EF">dependencies安装依赖项</font> </h3><br> 转到项目文件夹<code>sa-logic/sa</code>并运行以下命令： <br><br><pre> <code class="plaintext hljs">python -m pip install -r requirements.txt python -m textblob.download_corpora</code> </pre> <br><h3>  <font color="#3AC1EF">▍开始申请</font> </h3><br> 安装依赖项后，我们准备启动该应用程序： <br><br><pre> <code class="plaintext hljs">python sentiment_analysis.py</code> </pre> <br> 执行此命令后，我们将收到以下通知： <br><br><pre> <code class="plaintext hljs">* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</code> </pre> <br> 这意味着该应用程序正在运行，并且正在<code>localhost:5000/</code>等待请求<code>localhost:5000/</code> <br><br><h3>  <font color="#3AC1EF">▍代码研究</font> </h3><br> 考虑一下Python应用程序代码，以了解其如何响应请求： <br><br><pre> <code class="plaintext hljs">from textblob import TextBlob from flask import Flask, request, jsonify app = Flask(__name__)                                   #1 @app.route("/analyse/sentiment", methods=['POST'])      #2 def analyse_sentiment():   sentence = request.get_json()['sentence']           #3   polarity = TextBlob(sentence).sentences[0].polarity #4   return jsonify(                                     #5       sentence=sentence,       polarity=polarity   ) if __name__ == '__main__':   app.run(host='0.0.0.0', port=5000)                #6</code> </pre> <br><ol><li> 初始化<code>Flask</code>对象。 </li><li> 设置地址以对其执行POST请求。 </li><li> 从请求正文中检索<code>sentence</code>属性。 </li><li> 初始化匿名<code>TextBlob</code>对象，并获取请求正文中第一个句子的<code>polarity</code>值（在我们的示例中，这是传递给分析的唯一句子）。 </li><li> 响应的返回，其中包含建议的文本和为此计算的<code>polarity</code>索引。 </li><li> 启动Flask应用程序，该应用程序的地址为<code>0.0.0.0:5000</code> （您也可以使用<code>localhost:5000</code>的设计访问它）。 </li></ol><br> 现在组成应用程序的微服务正在运行。 它们被配置为彼此交互。 这是工作阶段的应用程序图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75a/fcc/135/75afcc1352ed237efaf0a2280c2df295.png"></div><br>  <i><font color="#999999">组成应用程序的所有微服务都处于正常状态。</font></i> <br><br> 现在，在继续之前，请在浏览器中打开React应用程序，并尝试使用它来分析一些建议。 如果一切正确，单击“ <code>Send</code>按钮后，您将在文本框下方看到分析结果。 <br><br> 在下一部分中，我们将讨论如何在Docker容器中运行我们的微服务。 为了准备在Kubernetes集群中启动应用程序，这是必需的。 <br><br><h2>  <font color="#3AC1EF">Docker容器</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes</a>是一个用于自动化容器化应用程序的部署，扩展和管理的系统。 它也被称为“容器协调器”。 如果Kubernetes使用容器，则在使用该系统之前，我们必须首先获取这些容器。 但是首先，让我们谈谈什么是容器。 也许可以在Docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>找到关于它是什么的最佳答案： <br><br>  <i>容器映像是一个轻量级的，独立的，可执行的程序包，其中包含一个应用程序，其中包括运行该映像所需的一切：应用程序代码，运行时，系统工具和库以及设置。</i>  <i>容器化程序可以在Linux和Windows环境中使用，并且无论基础结构如何，它们都将始终相同。</i> <br><br> 这意味着容器可以在包括生产服务器在内的任何计算机上运行，​​并且在任何环境中，包含在其中的应用程序将以相同的方式运行。 <br><br> 为了探索容器的功能并将它们与其他启动应用程序的方式进行比较，请考虑使用虚拟机和容器为React应用程序提供服务的示例。 <br><br><h3>  <font color="#3AC1EF">using使用虚拟机服务React应用程序静态文件</font> </h3><br> 尝试通过虚拟机组织对静态文件的维护，我们将遇到以下缺点： <br><br><ol><li> 资源利用率低下，因为每个虚拟机都是成熟的操作系统。 </li><li> 取决于平台。 在某些本地计算机上可以运行的内容在生产服务器上可能无法运行。 </li><li> 基于虚拟机的解决方案的缓慢且资源密集的扩展。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/927/523/c26927523b6072ce65bfaf8b01a1e330.png"></div><br>  <i><font color="#999999">在虚拟机上运行的Nginx静态服务器Web服务器</font></i> <br><br> 如果使用容器来解决类似的问题，那么与虚拟机相比，可以注意到它们的以下优势： <br><br><ol><li> 高效利用资源：使用Docker处理操作系统。 </li><li> 平台独立性。 开发人员可以在其计算机上运行的容器可以在任何地方使用。 </li><li> 通过使用图像层进行轻量级部署。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28b/593/b01/28b593b01ce003c246843d9c9f2bd05f.png"></div><br>  <i><font color="#999999">在容器中运行的Nginx静态服务器Web服务器</font></i> <br><br> 我们仅在几个方面对虚拟机和容器进行了比较，但这甚至足以感觉到容器的优势。 在此处了解有关Docker容器的更多信息。 <br><br><h3>  <font color="#3AC1EF">▍组装一个React应用程序的容器镜像</font> </h3><br>  Docker容器的主要构建模块是<code>Dockerfile</code> 。 在该文件的开头，记录容器的基本映像，然后包括一系列指令，这些指令指示将创建满足特定应用程序需求的容器的顺序。 <br><br> 在开始使用<code>Dockerfile</code> ，让我们回顾一下为准备React应用程序文件上载到Nginx服务器而做的事情： <br><br><ol><li> 构建一个React应用程序包（ <code>npm run build</code> ）。 </li><li> 启动Nginx服务器。 </li><li> 将<code>build</code>目录的内容从<code>sa-frontend</code>项目文件夹复制到<code>nginx/html</code>服务器文件夹。 </li></ol><br> 在下面，您可以看到创建容器与在本地计算机上执行的上述操作之间的相似之处。 <br><br><h3>  <font color="#3AC1EF">▍准备用于SA-Frontend的Dockerfile</font> </h3><br>  <code>SA-Frontend</code>应用程序的<code>Dockerfile</code>中将包含的指令仅包含两个命令。 事实是Nginx开发团队为Nginx准备了一个基本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">映像</a> ，我们将使用它来创建映像。 这是我们需要描述的两个步骤： <br><br><ol><li> 制作Nginx图像所需的图像基础。 </li><li> 必须将<code>sa-frontend/build</code>文件夹的内容复制到<code>nginx/html</code> image文件夹。 </li></ol><br> 如果我们从此描述移至<code>Dockerfile</code> ，它将看起来像这样： <br><br><pre> <code class="plaintext hljs">FROM nginx COPY build /usr/share/nginx/html</code> </pre> <br> 如您所见，这里的所有内容都非常简单，而文件的内容甚至具有很高的可读性和可理解性。 该文件告诉系统将已经拥有的所有内容都获取到<code>nginx</code>图像，并将<code>build</code>目录的内容复制到<code>nginx/html</code>目录。 <br><br> 在这里，您可能会遇到一个问题，即我在哪里知道确切需要从<code>build</code>文件夹复制文件的位置，即<code>/usr/share/nginx/html</code>的路径是哪里。 实际上，并没有什么复杂的。 事实是相关信息可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>图像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述中</a>找到。 <br><br><h3>  <font color="#3AC1EF">▍构建映像并将其上传到存储库</font> </h3><br> 在使用完成的图像之前，我们需要将其发送到图像存储库。 为此，我们将使用免费的云平台托管Docker Hub映像。 在工作的这个阶段，您需要执行以下操作： <br><br><ol><li> 安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker</a> 。 </li><li> 在Docker Hub网站上注册。 </li><li> 通过在终端中运行以下命令登录帐户： <br><br><pre> <code class="plaintext hljs">docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</code> </pre> </li></ol><br> 现在，您需要使用终端进入<code>sa-frontend</code>目录，并在其中运行以下命令： <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend .</code> </pre> <br> 此后，在类似命令中，需要在Docker Hub上用您的用户名替换<code>$DOCKER_USER_ID</code> 。 例如，命令的这一部分可能看起来像这样： <code>rinormaloku/sentiment-analysis-frontend</code> 。 <br><br> 同时，可以通过从其中删除<code>-f Dockerfile</code>来缩短此命令，因为该文件已经存在于执行该命令的文件夹中。 <br><br> 为了将完成的图像发送到存储库，我们需要以下命令： <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br> 执行完毕后，请检查Docker Hub上的存储库列表，以了解映像是否已成功发送到云。 <br><br><h3>  <font color="#3AC1EF">▍启动容器</font> </h3><br> 现在，任何人都可以下载并运行一个名为<code>$DOCKER_USER_ID/sentiment-analysis-frontend</code>的映像。 为此，您需要运行以下命令序列： <br><br><pre> <code class="plaintext hljs">docker pull $DOCKER_USER_ID/sentiment-analysis-frontend docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br> 现在启动了容器，我们可以继续工作，创建我们需要的其他图像。 但是，在继续之前，让我们<code>80:80</code>构造，该构造在映像启动命令中可以找到，并且似乎难以理解。 <br><br><ul><li> 第一个数字<code>80</code>是主机端口号（即本地计算机）。 </li><li> 第二个数字<code>80</code>是应将请求重定向到的容器的端口。 </li></ul><br> 请考虑以下插图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/394/6cd/7753946cde3287113b82f00921ced889.png"></div><br>  <i><font color="#999999">端口转发</font></i> <br><br> 系统将请求从<code>&lt;hostPort&gt;</code>端口重定向到<code>&lt;containerPort&gt;</code>端口。 也就是说， <code>80</code>计算机端口<code>80</code>访问将重定向到容器的端口<code>80</code> 。 <br><br> 由于端口<code>80</code>在本地计算机上打开的，因此您可以从此计算机在<code>localhost:80</code>访问应用程序。 如果您的系统不支持Docker，则可以在Docker虚拟机上运行该应用程序，其地址将类似于<code>&lt;docker-machine ip&gt;:80</code> 。 为了找出Docker虚拟机的IP地址，可以使用<code>docker-machine ip</code> 。 <br><br> 在此阶段，成功启动前端应用程序容器后，您应该能够在浏览器中打开其页面。 <br><br><h3>  <font color="#3AC1EF">▍.dockerignore文件</font> </h3><br> 收集<code>SA-Frontend</code>应用程序的映像，我们会注意到此过程非常缓慢。 发生这种情况的原因是必须将映像的构建上下文发送到Docker守护程序。 代表构建上下文的目录由<code>docker build</code>的最后一个参数指定。 在我们的情况下，此命令的末尾是一个句点。 这导致以下结构包含在程序集上下文中： <br><br><pre> <code class="plaintext hljs">sa-frontend: |   .dockerignore |   Dockerfile |   package.json |   README.md +---build +---node_modules +---public \---src</code> </pre> <br> 但是在这里存在的所有文件夹中，我们只需要<code>build</code>文件夹。 下载其他任何东西都是浪费时间。 可以通过告诉Docker忽略哪些目录来加快构建速度。 为了做到这一点，我们需要一个<code>.dockerignore</code>文件。 如果您熟悉<code>.gitignore</code>文件，那么此文件的结构肯定看起来很熟悉。 它列出了图像组合系统可能忽略的目录。 在我们的例子中，该文件的内容如下所示： <br><br><pre> <code class="plaintext hljs">node_modules src public</code> </pre> <br>  <code>.dockerignore</code>文件必须与<code>Dockerfile</code>位于同一文件夹中。 现在，组装图像将需要几秒钟的时间。 <br><br> 现在让我们看一下Java应用程序。 <br><br><h3> <font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍为Java应用程序构建容器映像</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您知道什么，但是您已经了解了创建容器映像所需的一切。</font><font style="vertical-align: inherit;">这就是为什么本节很短的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开</font></font><code>Dockerfile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目文件夹中的文件</font></font><code>sa-webapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您阅读此文件的文本，则在其中仅会遇到两个以关键字</font></font><code>ENV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">开头的新结构</font></font><code>EXPOSE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">ENV SA_LOGIC_API_URL http://localhost:5000 … EXPOSE 8080</code> </pre> <br>   <code>ENV</code>       Docker.  ,       URL    API ,   . <br><br>   <code>EXPOSE</code>   Docker  ,    .          .   ,   <code>Dockerfile</code>   <code>SA-Frontend</code>   .      ,  ,     ,    <code>Dockerfile</code> . <br><br>           ,    .           —       <code>README.md</code>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍    Python-</font> </h3><br>       <code>Dockerfile</code>   <code>sa-logic</code> ,         .               ,  ,        ,     <code>README.md</code>   <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍  </font> </h3><br>     - ,    ?    .   . <br><br><ol><li>    <code>sa-logic</code>       <code>5050</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 5050:5000 $DOCKER_USER_ID/sentiment-analysis-logic</code> </pre> </li><li>    <code>sa-webapp</code>       <code>8080</code> .  ,    ,   Python-     Java-,    <code>SA_LOGIC_API_URL</code> : <br><br><pre> <code class="plaintext hljs">$ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://&lt;container_ip or docker machine ip&gt;:5000' $DOCKER_USER_ID/sentiment-analysis-web-app</code> </pre> </li></ol><br>      ,   IP-     Docker —    <a href="">README</a> . <br><br>    <code>sa-frontend</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>     ,       <code>localhost:80</code>   . <br><br>    ,       <code>sa-webapp</code> ,        Docker,     <code>App.js</code>   <code>sa-frontend</code> ,  IP-      <code>analyzeSentence()</code> ,      .         . <br><br>       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/71e/87a/79671e87adea76c8873cac180e2fe8c0.png"></div><br> <i><font color="#999999">   </font></i> <br><br><h2> <font color="#3AC1EF">:    Kubernetes?</font> </h2><br>      <code>Dockerfile</code> ,   ,         Docker.  ,     ,   <code>.dockerignore</code> .         Docker.          ,   Kubernetes.          .      : <br> ,   -      .       .  ,   <code>sa-webapp</code>  <code>sa-logic</code>     .   ,    ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438982/">https://habr.com/ru/post/zh-CN438982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438972/index.html">从内部大脑（通过人工神经网络模型可视化模式的通过）</a></li>
<li><a href="../zh-CN438974/index.html">虚拟现实有助于应对精神疾病</a></li>
<li><a href="../zh-CN438976/index.html">《春天。 所有设计模式»</a></li>
<li><a href="../zh-CN438978/index.html">随时随地学习！ 面向开发人员的英语播客</a></li>
<li><a href="../zh-CN438980/index.html">Spring Boot 2：有什么新功能？</a></li>
<li><a href="../zh-CN438984/index.html">Kubernetes指南，第2部分：创建和使用集群</a></li>
<li><a href="../zh-CN438986/index.html">React教程第14部分：关于基于类的组件，组件状态的研讨会</a></li>
<li><a href="../zh-CN438988/index.html">React教程第15部分：组件状态研讨会</a></li>
<li><a href="../zh-CN438992/index.html">开发者日记或错误决定</a></li>
<li><a href="../zh-CN438994/index.html">鼓手鼓手Intel Xeon W-3175X。 测试中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>