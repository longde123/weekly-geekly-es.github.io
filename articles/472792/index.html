<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👡 💶 🎀 Computadora basada en válvulas NOR: dentro de la computadora de control a bordo Apollo 🏂🏾 🥂 🍭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, nos dedicamos a la restauración de la computadora de control a bordo Apollo, una computadora que era responsable de controlar, navegar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Computadora basada en válvulas NOR: dentro de la computadora de control a bordo Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recientemente, nos dedicamos a la restauración de la</a> computadora de control a bordo Apollo, una computadora que era responsable de controlar, navegar y monitorear a bordo de las misiones Apollo que volaban a la Luna.  Esta computadora histórica fue una de las primeras en usar circuitos integrados (IC), y su procesador se construyó completamente en válvulas NOR (el segundo tipo de IC, un amplificador de lectura, se usó en la memoria de la computadora).  En este artículo, describiré la arquitectura y el diseño de la CPU. <br><br><h2>  Apollo Control Computer Architecture </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Bandejas separadas de la computadora de control Apollo.</i>  <i>La bandeja izquierda contiene lógica basada en puertas NOR.</i>  <i>A la derecha - memoria y componentes auxiliares.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> Apollo Guidance Computer (AGC) se desarrolló en la década de 1960 para permitir que las misiones Apollo vuelen a la luna.  En un momento en que la mayoría de las computadoras ocupaban espacio desde un refrigerador de tamaño completo hasta una habitación completa, el AGC era algo único: era lo suficientemente pequeño como para caber a bordo de la nave espacial Apollo, pesaba 32 kg y no pesaba más de 0.03 m <sup>3</sup> (30 litros). <br><a name="habracut"></a><br>  La computadora AGC es de 15 bits.  Es extraño encontrar un tamaño de palabra que no sea una potencia de dos, pero en la década de 1960, incluso antes de que los bytes se hicieran populares, las computadoras usaban una variedad de tamaños de palabra.  15 bits proporcionaron suficiente precisión para aterrizar en la luna (y utilizaron datos con doble y triple precisión si fuera necesario), por lo que 16 bits simplemente aumentarían el tamaño y el peso de la computadora innecesariamente. <br><br>  La instrucción AGC estaba ubicada en una palabra de 15 bits y consistía en 3 bits, que indicaban el código de operación, y 12 bits, que indicaban la dirección en la memoria.  Desafortunadamente, estos volúmenes aún no eran suficientes, por lo que la computadora usó numerosos trucos y soluciones alternativas, y la arquitectura resultó ser bastante incómoda.  Una dirección de memoria de 12 bits solo puede acceder a palabras 4K.  Al mismo tiempo, AGC tenía 2K palabras en la RAM principal y 36K palabras en la memoria central.  Para acceder a toda la memoria, AGC utilizó un sofisticado sistema de conmutación de bancos de memoria y múltiples registros.  En otras palabras, solo se podía acceder a la memoria en partes de 256 palabras, y ROM - en partes de un tamaño ligeramente mayor. <br><br>  3 bits para el código de operación no fueron suficientes para indicar directamente 34 instrucciones posibles, por lo que el AGC utilizó trucos con la extensión del valor de las instrucciones y el hecho de que algunas instrucciones tenían sentido para ejecutarse solo con ciertas celdas de memoria.  Además, se utilizaron trucos como las direcciones "mágicas" en la memoria, por ejemplo, al escribir en la celda "registro de desplazamiento a la derecha" se realizó un desplazamiento a nivel de bits, eliminando así la necesidad de una instrucción separada de "desplazamiento a la derecha".  También había instrucciones que combinaban varias acciones a la vez. <br><br>  La arquitectura AGC era bastante simple, incluso para los estándares de la década de 1960.  Aunque se creó en una era de mainframes complejos y potentes, las capacidades de AGC eran muy limitadas;  En términos de potencia y arquitectura, es comparable a los primeros microprocesadores.  Sus puntos fuertes fueron su tamaño compacto y sus excelentes capacidades para proporcionar entrada y salida de datos en tiempo real. <br><br>  El siguiente diagrama arquitectónico muestra los componentes principales de la AGC.  Destaqué en color las partes en las que me detengo con más detalle.  AGC tenía un pequeño conjunto de registros y un módulo aritmético simple que solo se ocupaba de la suma.  Tenía solo 36K palabras ROM y 2K palabras RAM.  El "bus de escritura" era la principal forma de transferir datos entre componentes.  Las instrucciones de decodificación y un generador de secuencia generaron pulsos de control para el AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>Diagrama de bloques AGC</i> <br><br>  Alrededor de la mitad del diagrama está ocupado por la memoria, lo que refleja el hecho de que en muchos aspectos la arquitectura AGC se desarrolló alrededor de su memoria.  Al igual que la mayoría de las computadoras en la década de 1960, AGC usaba memoria central, almacenando cada bit en un pequeño anillo de ferrita (núcleo) encadenado en una malla de alambre.  Como cada bit requería un núcleo físico separado, la cantidad de dicha memoria era radicalmente menor que la de un semiconductor moderno.  Una característica distintiva de la memoria en los núcleos era que leer una palabra de la memoria la borraba, por lo que después de cada acceso, este valor tenía que reescribirse.  AGC también tenía memoria ROM fija, los famosos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">núcleos cosidos</a> : se usaban para almacenar programas y se cosían físicamente con cables (ver más abajo). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Memoria de primer plano en núcleos cosidos</i> <br><br><h2>  Válvulas NOR </h2><br>  AGC fue una de las primeras computadoras en usar IP.  Las posibilidades de estas primeras IP eran muy limitadas;  en los chips AGC (abajo) solo había seis transistores y ocho resistencias, y juntos implementaron una puerta NOR con tres entradas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>Doble válvula NOR con tres entradas de AGC.</i>  <i>Diez cables fuera del cristal están conectados a los contactos externos del IC.</i> <br><br>  La designación esquemática de la válvula NOR se muestra a continuación.  Esta es la puerta lógica más simple: si todas las entradas son iguales a cero, entonces la salida es igual a uno.  Puede sorprenderse, pero una puerta NOR es suficiente para crear una computadora.  NOR es una válvula universal: cualquier otra válvula lógica se puede hacer sobre la base.  Por ejemplo, al combinar todas las entradas NOR, obtenemos un inversor.  Después de colocar el inversor en la salida del NOR, obtenemos una válvula OR.  Al colocar los inversores en las entradas de la puerta NOR, obtenemos una puerta AND.  Y a partir de estas puertas puede construir una lógica más compleja: disparadores, sumadores y contadores. <br><br>  La válvula NAND tiene la misma versatilidad.  En los circuitos modernos, por razones técnicas, las NAND se usan con más frecuencia que las NOR.  En el popular curso " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">De NAND a Tetris</a> " se describe cómo crear una computadora a partir de válvulas NAND, hasta la implementación del juego "Tetris".  Primero, se construye un conjunto de compuertas lógicas a partir de NAND (NO, AND, OR, XOR, multiplexor, demultiplexor).  Luego, se crean bloques de construcción más grandes a partir de ellos (disparador, sumador, contador, ALU, registro) y, a partir de ellos, una computadora. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>La puerta NOR da 1, si tiene 0 en todas las entradas. Si al menos una de las entradas tiene 1, entonces la NOR da 0.</i> <br><br>  Muy a menudo en AGC se encuentra con un componente como RS-trigger (set-reset, set / reset).  Este circuito está hecho de dos puertas NOR y almacena un bit de datos.  El bit 1 se almacena en la entrada establecida, y el bit 0 se almacena en la entrada de reinicio. Es decir, el pulso 1, aplicado a la entrada establecida, cierra la válvula superior y enciende la inferior, por lo que la salida 1. resulta. El pulso 1, aplicado a la entrada de reinicio, hace lo contrario .  Si se aplica 0 a ambas entradas, el activador recuerda su estado anterior, desempeñando el papel de una unidad.  En la siguiente sección, mostraremos cómo se realizan los registros desde un disparador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>RS disparador de dos puertas NOR.</i>  <i>Una válvula, cuando se enciende, apaga la otra.</i>  <i>Una línea sobre una de las salidas indica que complementa la otra.</i> <br><br><h2>  Registros </h2><br>  AGC tiene un pequeño conjunto de registros para el almacenamiento temporal de valores fuera de la memoria principal.  El registro principal es la unidad (A) utilizada en muchas operaciones aritméticas.  También tiene un contador de registro Z, registros de bloques aritméticos X e Y, búfer B, dirección de retorno Q y algunos otros (en las computadoras modernas, la pila se usa para llamar rutinas y regresar de ellas, pero en esa era, los programadores necesitaban escribir la pila ellos mismos para la recursividad )  Para el acceso a la memoria, hay un registro de dirección de memoria S, y para los datos, un registro de memoria intermedia G. También, AGC tiene registros en la memoria principal, por ejemplo, contadores de entrada / salida. <br><br>  El siguiente diagrama muestra el esquema de registro AGC, simplificado para el caso con un bit y dos registros.  Cada bit de registro tiene un activador que utiliza el esquema descrito anteriormente (azul y morado).  Los datos se transfieren hacia y desde los registros a través del bus de escritura (rojo).  Para escribir en el registro, el disparador se restablece mediante una señal clara (CQG o CZG, verde).  Luego, la señal de "escritura" (WQG o WZG, naranja) permite que los datos que van a lo largo del bus de escritura establezcan el activador de registro correspondiente.  Para leer el registro, la señal de lectura (RQG o RZG, cian) pasa la salida del disparador a través del amplificador de grabación al bus de grabación, y se utiliza en otras partes del AGC.  El esquema de registro completo es más complejo, tiene varios registros de 16 bits, pero el esquema básico es el siguiente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Operación de registro AGC simplificada</i> <br><br>  El cuadro de registro ilustra tres puntos clave.  En primer lugar, el circuito de registro está construido a partir de puertas NOR.  En segundo lugar, el movimiento de datos se construye alrededor del bus de escritura.  Finalmente, las acciones de los registros dependen de ciertas señales de control que llegan en el momento adecuado. <br><br><h2>  Módulo aritmético </h2><br>  La mayoría de las computadoras tienen un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dispositivo de lógica aritmética</a> que realiza operaciones aritméticas y booleanas.  En comparación con las computadoras modernas, el módulo aritmético de AGC es muy limitado: solo realiza la suma de cantidades de 16 bits, por lo tanto, se llama módulo aritmético y no módulo aritmético lógico (el resto de las operaciones se realizan a través de varios trucos; por ejemplo, la resta se realiza mediante la suma, antes de lo cual para uno de los argumentos, los bits se invierten, etc.). <br><br>  El siguiente diagrama muestra un bit del módulo aritmético AGC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sumador completo</a> (rojo) calcula la suma de dos bits y acarrea.  La transferencia se transfiere al siguiente sumador, de esta manera se pueden combinar para agregar palabras más largas (para acelerar la transferencia de transferencias en casos como 111111111111111 + 1, AGC usa un sumador con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">salto de transferencia</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Los registros X e Y (morado y verde) proporcionan dos bits de entrada al sumador.  Se implementan utilizando los disparadores ya descritos en las válvulas NOR.  El bucle azul escribe los valores en los registros X e Y de acuerdo con las señales de control.  El esquema es bastante complicado, porque le permite almacenar constantes y valores con un cambio en los registros, pero no voy a entrar en este tema.  Preste atención a la señal de control A2X, que transfiere el valor del registro A al registro X;  Volveremos a él más tarde. <br><br>  La foto a continuación muestra la implementación física del circuito AGC.  Este módulo implementa cuatro bits para registros y un módulo aritmético.  Los rectángulos negros son IP planas;  cada módulo tiene dos tableros con 60 chips cada uno y un total de 240 puertas NOR.  El módulo aritmético y los registros se ensamblan a partir de cuatro módulos idénticos, cada uno de los cuales procesa cuatro bits;  Esto es similar a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sección del microprocesador</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>El módulo aritmético y los registros se ensamblan a partir de cuatro módulos idénticos.</i>  <i>Los módulos se instalan en ranuras de A8 a A11.</i> <br><br><h2>  Ejecución de la instrucción </h2><br>  Esta sección describe la secuencia de operaciones que realiza el AGC para ejecutar la instrucción.  En particular, mostraré cómo funciona la instrucción ADS (agregar al almacenamiento).  Esta instrucción lee el valor de la memoria, lo agrega a la unidad (registro A) y guarda la suma tanto en el sumador como en la memoria.  Esta es una sola instrucción, pero para su ejecución, AGC toma varios pasos y muchos valores se mueven aquí y allá. <br><br>  El temporizador de instrucciones se implementa debido al subsistema de memoria en núcleos magnéticos.  En particular, leer un valor de la memoria borra el valor almacenado, por lo que después de cada lectura, el valor debe escribirse de nuevo.  Además, al acceder a la memoria, hay un retraso entre la designación de la dirección y la recepción de datos.  Como resultado, cada ciclo de reloj gasta 12 pasos para la lectura y posterior grabación.  Cada intervalo de tiempo (de T1 a T12) dura un poco menos de microsegundos, y el ciclo completo dura 11.7 μs, y se denomina tiempo de ciclo de memoria (MCT). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>Módulo de memoria de núcleo magnético borrable de AGC.</i>  <i>Almacena 2 kilosheets, cada bit se almacena usando un pequeño anillo de ferrita separado.</i> <br><br>  MCT es la unidad básica de memoria para ejecutar instrucciones.  Una instrucción típica requiere dos ciclos de reloj: uno para extraer la instrucción de la memoria, el segundo para realizar la operación.  Por lo tanto, una instrucción típica toma dos MCT (23.4 μs), lo que nos da 43,000 instrucciones por segundo (en comparación con los procesadores modernos y sus miles de millones de instrucciones por segundo, esto es extremadamente lento). <br><br>  AGC procesa instrucciones, dividiéndolas en subcomandos, cada uno de los cuales toma un ciclo de reloj de memoria.  Por ejemplo, una instrucción ADS consta de dos subcomandos: ADS0 (además) y STD2 (llamando a la siguiente instrucción).  El siguiente diagrama muestra el movimiento de datos dentro del AGC para ejecutar la instrucción ADS0.  12 medidas van de izquierda a derecha. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Los pasos más importantes son los siguientes: <br>  T1: la dirección del operando se copia desde el registro de instrucciones B al registro de dirección de memoria S para comenzar a leer desde la memoria. <br>  T4: el operando se lee de la memoria al registro de datos de memoria G. <br>  T5: el operando se copia de G al sumador Y. El valor de la unidad A se copia al sumador X. <br>  T6: El sumador calcula la suma U y la copia en el registro de datos de la memoria G. <br>  T8: El contador de programa Z se copia en el registro de dirección de memoria S en preparación para recibir la siguiente instrucción de la memoria. <br>  T10: la suma del registro de datos de la memoria G se vuelve a escribir en la memoria. <br>  T11: la cantidad U se copia en la unidad A. <br><br>  Aunque esta es una simple instrucción de suma, una gran cantidad de datos se transmiten una y otra vez durante 12 intervalos de tiempo.  Y con cada una de estas acciones se asocia una señal de control específica;  por ejemplo, la señal A2X en el intervalo T5 copia el valor del variador A al registro X. Para copiar el registro G al registro Y, se requieren dos pulsos de control: RG (leer G) y WY (escribir Y).  En la siguiente sección, explicaré cómo el módulo de control AGC genera las señales de control necesarias para cada instrucción. <br><br><h2>  Módulo de control </h2><br>  Como la mayoría de las computadoras, el módulo de control AGC decodifica cada instrucción y genera señales de control que le indican al resto del procesador lo que debe hacer.  El AGC utiliza un módulo de control preprogramado que consta de válvulas NOR para generar señales.  AGC no utiliza microcódigo;  no tiene microinstrucciones ni memoria de control, ya que esto ocuparía demasiado espacio físico. <br><br>  El corazón del módulo de control AGC se llama generador de punto de cruce.  Toma un subcomando y uno de los períodos de tiempo y genera señales de control para esta combinación.  Se puede imaginar en forma de una red, en la que los subcomandos van en una dirección y los segmentos de tiempo en la otra, y cada uno de los puntos de intersección tiene su propia señal de control. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>El generador de intersección requiere muchos componentes y se divide en tres módulos;</i>  <i>Este es el módulo A6.</i>  <i>Presta atención a los cables agregados que cambian el circuito.</i>  <i>Esta es una versión temprana de un módulo para probar en el terreno;</i>  <i>los módulos de vuelo ya no tenían cables.</i> <br><br>  Para mayor eficiencia, el módulo de control final está altamente optimizado.  El generador de intersección combina y procesa las instrucciones con un comportamiento similar, lo que reduce el tamaño del circuito requerido.  Por ejemplo, AGC tiene una instrucción "agregar a una unidad con doble precisión" (DAS).  Como es aproximadamente equivalente a dos adiciones de palabras simples, los subcomandos DAS1 y ADS0 en el generador de intersección tienen una lógica común.  El siguiente diagrama muestra el circuito generador de intersección para el intervalo de tiempo T5, y se resalta la lógica del subcomando ADS0 (usando la señal DAS1).  Por ejemplo, se genera una señal de 5K a partir de una combinación de DAS1 y T5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Pero, ¿qué son las señales 5K y 5L?  Esta es otra optimización.  Muchos pulsos de control a menudo se alimentan juntos, por lo que en lugar de generarlos directamente, el generador de intersección genera señales intermedias para las intersecciones.  Por ejemplo, 5K genera pulsos de control A2X y RG, y 5L genera pulsos de control WY.  El siguiente diagrama muestra cómo se genera la señal A2X: cualquiera de las 8 señales diferentes (incluyendo 5K) genera A2X.  Circuitos similares generan otras señales de control.  Estas optimizaciones permitieron reducir el tamaño del generador de intersección, pero aún así se mantuvo grande y se convirtió en hasta tres módulos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  En resumen, podemos decir que el módulo de control es responsable de decirle a la CPU qué hacer para ejecutar la instrucción.  Primero, las instrucciones se desglosan en subcomandos.  El generador de intersección genera los pulsos de control necesarios para cada intervalo de tiempo y subcomando, indicando a los registros, el módulo aritmético y la memoria lo que deben hacer. <br><br>  Por lo general, las instrucciones constaban de dos subcomandos, pero había excepciones.  Algunas de las instrucciones, como la multiplicación o división, requerían el uso de muchos subcomandos, ya que consistían en muchos pasos.  Por el contrario, la instrucción de salto en TC utilizó un subcomando, ya que solo necesitaba llamar a la siguiente instrucción. <br><br>  Otros procesadores utilizaron diferentes enfoques para la generación de señales de control.  6502 y muchos otros primeros microprocesadores decodificaron las instrucciones utilizando una matriz lógica programable (PLA) que implementa la lógica AND / OR a través de la memoria de solo lectura. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br>  <i>Microprocesador 6502.</i> <br><br><h2>  Conclusión </h2><br>  Fue un recorrido emocionante por la computadora de control a bordo Apollo.  Para no estirarlo mucho, me concentré en las instrucciones de adición de ADS y algunos pulsos de control (A2X, RG y WY).  Espero que tenga una idea de cómo ensamblar una computadora a partir de elementos tan primitivos como las válvulas NOR. <br><br>  La parte más visible de la arquitectura es la ruta de datos: un módulo aritmético, registros y un bus de datos.  Los registros AGC se basan en disparadores simples de puertas NOR.  Y aunque el módulo aritmético AGC solo puede sumar, la computadora aún puede manejar todo el conjunto de operaciones, incluidas las operaciones de multiplicación, división y booleanas. <br><br>  Sin embargo, la ruta de datos es solo una parte de la computadora.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre otros componentes críticos, hay un módulo de control que les dice a los componentes lo que deben hacer. </font><font style="vertical-align: inherit;">El enfoque utilizado en AGC se basa en un generador de intersección que utiliza una lógica altamente optimizada y codificada para generar los pulsos de control correctos para subcomandos e intervalos de tiempo específicos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando estas capacidades, el AGC proporcionó orientación, navegación y control a bordo de las misiones Apolo, y permitió aterrizar en la luna. </font><font style="vertical-align: inherit;">También estimuló la industria de los circuitos integrados iniciales utilizando el 60% de los circuitos integrados de fabricación estadounidense en 1963. Por lo tanto, las computadoras modernas le deben mucho a AGC y sus componentes NOR simples. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGC trabaja en un laboratorio conectado a un osciloscopio Tektronix antiguo</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472792/">https://habr.com/ru/post/472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472776/index.html">Copia de seguridad Parte 7: Conclusiones</a></li>
<li><a href="../472778/index.html">5 maneras de usar la Raspberry Pi</a></li>
<li><a href="../472780/index.html">¿Por qué evitar amigos o cómo perdí todas mis ventajas?</a></li>
<li><a href="../472782/index.html">Por qué 3D Dolor de cabeza / Parte 8 Desenfoque y el futuro de 3D</a></li>
<li><a href="../472790/index.html">Antigüedades: i-Mate Jasjar, un comunicador para empresas</a></li>
<li><a href="../472796/index.html">YES retrocede FAANG * o [guía práctica] en la búsqueda de empleo en EE. UU. / Europa para un especialista en TI</a></li>
<li><a href="../472798/index.html">Mapas de Yandex para la aplicación de Taxi</a></li>
<li><a href="../472802/index.html">MIRO es una plataforma abierta de robot de interior. Parte 2 - Diseño de robot</a></li>
<li><a href="../472810/index.html">Para el administrador del sistema principiante: cómo hacer que el orden salga del caos</a></li>
<li><a href="../472812/index.html">¿Se "apaga" el servidor si la prueba de humo del centro de datos "se incendió"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>