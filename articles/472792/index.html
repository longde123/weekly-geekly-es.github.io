<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Computadora basada en v谩lvulas NOR: dentro de la computadora de control a bordo Apollo   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, nos dedicamos a la restauraci贸n de la computadora de control a bordo Apollo, una computadora que era responsable de controlar, navegar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Computadora basada en v谩lvulas NOR: dentro de la computadora de control a bordo Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recientemente, nos dedicamos a la restauraci贸n de la</a> computadora de control a bordo Apollo, una computadora que era responsable de controlar, navegar y monitorear a bordo de las misiones Apollo que volaban a la Luna.  Esta computadora hist贸rica fue una de las primeras en usar circuitos integrados (IC), y su procesador se construy贸 completamente en v谩lvulas NOR (el segundo tipo de IC, un amplificador de lectura, se us贸 en la memoria de la computadora).  En este art铆culo, describir茅 la arquitectura y el dise帽o de la CPU. <br><br><h2>  Apollo Control Computer Architecture </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Bandejas separadas de la computadora de control Apollo.</i>  <i>La bandeja izquierda contiene l贸gica basada en puertas NOR.</i>  <i>A la derecha - memoria y componentes auxiliares.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> Apollo Guidance Computer (AGC) se desarroll贸 en la d茅cada de 1960 para permitir que las misiones Apollo vuelen a la luna.  En un momento en que la mayor铆a de las computadoras ocupaban espacio desde un refrigerador de tama帽o completo hasta una habitaci贸n completa, el AGC era algo 煤nico: era lo suficientemente peque帽o como para caber a bordo de la nave espacial Apollo, pesaba 32 kg y no pesaba m谩s de 0.03 m <sup>3</sup> (30 litros). <br><a name="habracut"></a><br>  La computadora AGC es de 15 bits.  Es extra帽o encontrar un tama帽o de palabra que no sea una potencia de dos, pero en la d茅cada de 1960, incluso antes de que los bytes se hicieran populares, las computadoras usaban una variedad de tama帽os de palabra.  15 bits proporcionaron suficiente precisi贸n para aterrizar en la luna (y utilizaron datos con doble y triple precisi贸n si fuera necesario), por lo que 16 bits simplemente aumentar铆an el tama帽o y el peso de la computadora innecesariamente. <br><br>  La instrucci贸n AGC estaba ubicada en una palabra de 15 bits y consist铆a en 3 bits, que indicaban el c贸digo de operaci贸n, y 12 bits, que indicaban la direcci贸n en la memoria.  Desafortunadamente, estos vol煤menes a煤n no eran suficientes, por lo que la computadora us贸 numerosos trucos y soluciones alternativas, y la arquitectura result贸 ser bastante inc贸moda.  Una direcci贸n de memoria de 12 bits solo puede acceder a palabras 4K.  Al mismo tiempo, AGC ten铆a 2K palabras en la RAM principal y 36K palabras en la memoria central.  Para acceder a toda la memoria, AGC utiliz贸 un sofisticado sistema de conmutaci贸n de bancos de memoria y m煤ltiples registros.  En otras palabras, solo se pod铆a acceder a la memoria en partes de 256 palabras, y ROM - en partes de un tama帽o ligeramente mayor. <br><br>  3 bits para el c贸digo de operaci贸n no fueron suficientes para indicar directamente 34 instrucciones posibles, por lo que el AGC utiliz贸 trucos con la extensi贸n del valor de las instrucciones y el hecho de que algunas instrucciones ten铆an sentido para ejecutarse solo con ciertas celdas de memoria.  Adem谩s, se utilizaron trucos como las direcciones "m谩gicas" en la memoria, por ejemplo, al escribir en la celda "registro de desplazamiento a la derecha" se realiz贸 un desplazamiento a nivel de bits, eliminando as铆 la necesidad de una instrucci贸n separada de "desplazamiento a la derecha".  Tambi茅n hab铆a instrucciones que combinaban varias acciones a la vez. <br><br>  La arquitectura AGC era bastante simple, incluso para los est谩ndares de la d茅cada de 1960.  Aunque se cre贸 en una era de mainframes complejos y potentes, las capacidades de AGC eran muy limitadas;  En t茅rminos de potencia y arquitectura, es comparable a los primeros microprocesadores.  Sus puntos fuertes fueron su tama帽o compacto y sus excelentes capacidades para proporcionar entrada y salida de datos en tiempo real. <br><br>  El siguiente diagrama arquitect贸nico muestra los componentes principales de la AGC.  Destaqu茅 en color las partes en las que me detengo con m谩s detalle.  AGC ten铆a un peque帽o conjunto de registros y un m贸dulo aritm茅tico simple que solo se ocupaba de la suma.  Ten铆a solo 36K palabras ROM y 2K palabras RAM.  El "bus de escritura" era la principal forma de transferir datos entre componentes.  Las instrucciones de decodificaci贸n y un generador de secuencia generaron pulsos de control para el AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>Diagrama de bloques AGC</i> <br><br>  Alrededor de la mitad del diagrama est谩 ocupado por la memoria, lo que refleja el hecho de que en muchos aspectos la arquitectura AGC se desarroll贸 alrededor de su memoria.  Al igual que la mayor铆a de las computadoras en la d茅cada de 1960, AGC usaba memoria central, almacenando cada bit en un peque帽o anillo de ferrita (n煤cleo) encadenado en una malla de alambre.  Como cada bit requer铆a un n煤cleo f铆sico separado, la cantidad de dicha memoria era radicalmente menor que la de un semiconductor moderno.  Una caracter铆stica distintiva de la memoria en los n煤cleos era que leer una palabra de la memoria la borraba, por lo que despu茅s de cada acceso, este valor ten铆a que reescribirse.  AGC tambi茅n ten铆a memoria ROM fija, los famosos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n煤cleos cosidos</a> : se usaban para almacenar programas y se cos铆an f铆sicamente con cables (ver m谩s abajo). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Memoria de primer plano en n煤cleos cosidos</i> <br><br><h2>  V谩lvulas NOR </h2><br>  AGC fue una de las primeras computadoras en usar IP.  Las posibilidades de estas primeras IP eran muy limitadas;  en los chips AGC (abajo) solo hab铆a seis transistores y ocho resistencias, y juntos implementaron una puerta NOR con tres entradas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>Doble v谩lvula NOR con tres entradas de AGC.</i>  <i>Diez cables fuera del cristal est谩n conectados a los contactos externos del IC.</i> <br><br>  La designaci贸n esquem谩tica de la v谩lvula NOR se muestra a continuaci贸n.  Esta es la puerta l贸gica m谩s simple: si todas las entradas son iguales a cero, entonces la salida es igual a uno.  Puede sorprenderse, pero una puerta NOR es suficiente para crear una computadora.  NOR es una v谩lvula universal: cualquier otra v谩lvula l贸gica se puede hacer sobre la base.  Por ejemplo, al combinar todas las entradas NOR, obtenemos un inversor.  Despu茅s de colocar el inversor en la salida del NOR, obtenemos una v谩lvula OR.  Al colocar los inversores en las entradas de la puerta NOR, obtenemos una puerta AND.  Y a partir de estas puertas puede construir una l贸gica m谩s compleja: disparadores, sumadores y contadores. <br><br>  La v谩lvula NAND tiene la misma versatilidad.  En los circuitos modernos, por razones t茅cnicas, las NAND se usan con m谩s frecuencia que las NOR.  En el popular curso " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">De NAND a Tetris</a> " se describe c贸mo crear una computadora a partir de v谩lvulas NAND, hasta la implementaci贸n del juego "Tetris".  Primero, se construye un conjunto de compuertas l贸gicas a partir de NAND (NO, AND, OR, XOR, multiplexor, demultiplexor).  Luego, se crean bloques de construcci贸n m谩s grandes a partir de ellos (disparador, sumador, contador, ALU, registro) y, a partir de ellos, una computadora. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>La puerta NOR da 1, si tiene 0 en todas las entradas. Si al menos una de las entradas tiene 1, entonces la NOR da 0.</i> <br><br>  Muy a menudo en AGC se encuentra con un componente como RS-trigger (set-reset, set / reset).  Este circuito est谩 hecho de dos puertas NOR y almacena un bit de datos.  El bit 1 se almacena en la entrada establecida, y el bit 0 se almacena en la entrada de reinicio. Es decir, el pulso 1, aplicado a la entrada establecida, cierra la v谩lvula superior y enciende la inferior, por lo que la salida 1. resulta. El pulso 1, aplicado a la entrada de reinicio, hace lo contrario .  Si se aplica 0 a ambas entradas, el activador recuerda su estado anterior, desempe帽ando el papel de una unidad.  En la siguiente secci贸n, mostraremos c贸mo se realizan los registros desde un disparador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>RS disparador de dos puertas NOR.</i>  <i>Una v谩lvula, cuando se enciende, apaga la otra.</i>  <i>Una l铆nea sobre una de las salidas indica que complementa la otra.</i> <br><br><h2>  Registros </h2><br>  AGC tiene un peque帽o conjunto de registros para el almacenamiento temporal de valores fuera de la memoria principal.  El registro principal es la unidad (A) utilizada en muchas operaciones aritm茅ticas.  Tambi茅n tiene un contador de registro Z, registros de bloques aritm茅ticos X e Y, b煤fer B, direcci贸n de retorno Q y algunos otros (en las computadoras modernas, la pila se usa para llamar rutinas y regresar de ellas, pero en esa era, los programadores necesitaban escribir la pila ellos mismos para la recursividad )  Para el acceso a la memoria, hay un registro de direcci贸n de memoria S, y para los datos, un registro de memoria intermedia G. Tambi茅n, AGC tiene registros en la memoria principal, por ejemplo, contadores de entrada / salida. <br><br>  El siguiente diagrama muestra el esquema de registro AGC, simplificado para el caso con un bit y dos registros.  Cada bit de registro tiene un activador que utiliza el esquema descrito anteriormente (azul y morado).  Los datos se transfieren hacia y desde los registros a trav茅s del bus de escritura (rojo).  Para escribir en el registro, el disparador se restablece mediante una se帽al clara (CQG o CZG, verde).  Luego, la se帽al de "escritura" (WQG o WZG, naranja) permite que los datos que van a lo largo del bus de escritura establezcan el activador de registro correspondiente.  Para leer el registro, la se帽al de lectura (RQG o RZG, cian) pasa la salida del disparador a trav茅s del amplificador de grabaci贸n al bus de grabaci贸n, y se utiliza en otras partes del AGC.  El esquema de registro completo es m谩s complejo, tiene varios registros de 16 bits, pero el esquema b谩sico es el siguiente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Operaci贸n de registro AGC simplificada</i> <br><br>  El cuadro de registro ilustra tres puntos clave.  En primer lugar, el circuito de registro est谩 construido a partir de puertas NOR.  En segundo lugar, el movimiento de datos se construye alrededor del bus de escritura.  Finalmente, las acciones de los registros dependen de ciertas se帽ales de control que llegan en el momento adecuado. <br><br><h2>  M贸dulo aritm茅tico </h2><br>  La mayor铆a de las computadoras tienen un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dispositivo de l贸gica aritm茅tica</a> que realiza operaciones aritm茅ticas y booleanas.  En comparaci贸n con las computadoras modernas, el m贸dulo aritm茅tico de AGC es muy limitado: solo realiza la suma de cantidades de 16 bits, por lo tanto, se llama m贸dulo aritm茅tico y no m贸dulo aritm茅tico l贸gico (el resto de las operaciones se realizan a trav茅s de varios trucos; por ejemplo, la resta se realiza mediante la suma, antes de lo cual para uno de los argumentos, los bits se invierten, etc.). <br><br>  El siguiente diagrama muestra un bit del m贸dulo aritm茅tico AGC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sumador completo</a> (rojo) calcula la suma de dos bits y acarrea.  La transferencia se transfiere al siguiente sumador, de esta manera se pueden combinar para agregar palabras m谩s largas (para acelerar la transferencia de transferencias en casos como 111111111111111 + 1, AGC usa un sumador con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">salto de transferencia</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Los registros X e Y (morado y verde) proporcionan dos bits de entrada al sumador.  Se implementan utilizando los disparadores ya descritos en las v谩lvulas NOR.  El bucle azul escribe los valores en los registros X e Y de acuerdo con las se帽ales de control.  El esquema es bastante complicado, porque le permite almacenar constantes y valores con un cambio en los registros, pero no voy a entrar en este tema.  Preste atenci贸n a la se帽al de control A2X, que transfiere el valor del registro A al registro X;  Volveremos a 茅l m谩s tarde. <br><br>  La foto a continuaci贸n muestra la implementaci贸n f铆sica del circuito AGC.  Este m贸dulo implementa cuatro bits para registros y un m贸dulo aritm茅tico.  Los rect谩ngulos negros son IP planas;  cada m贸dulo tiene dos tableros con 60 chips cada uno y un total de 240 puertas NOR.  El m贸dulo aritm茅tico y los registros se ensamblan a partir de cuatro m贸dulos id茅nticos, cada uno de los cuales procesa cuatro bits;  Esto es similar a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secci贸n del microprocesador</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>El m贸dulo aritm茅tico y los registros se ensamblan a partir de cuatro m贸dulos id茅nticos.</i>  <i>Los m贸dulos se instalan en ranuras de A8 a A11.</i> <br><br><h2>  Ejecuci贸n de la instrucci贸n </h2><br>  Esta secci贸n describe la secuencia de operaciones que realiza el AGC para ejecutar la instrucci贸n.  En particular, mostrar茅 c贸mo funciona la instrucci贸n ADS (agregar al almacenamiento).  Esta instrucci贸n lee el valor de la memoria, lo agrega a la unidad (registro A) y guarda la suma tanto en el sumador como en la memoria.  Esta es una sola instrucci贸n, pero para su ejecuci贸n, AGC toma varios pasos y muchos valores se mueven aqu铆 y all谩. <br><br>  El temporizador de instrucciones se implementa debido al subsistema de memoria en n煤cleos magn茅ticos.  En particular, leer un valor de la memoria borra el valor almacenado, por lo que despu茅s de cada lectura, el valor debe escribirse de nuevo.  Adem谩s, al acceder a la memoria, hay un retraso entre la designaci贸n de la direcci贸n y la recepci贸n de datos.  Como resultado, cada ciclo de reloj gasta 12 pasos para la lectura y posterior grabaci贸n.  Cada intervalo de tiempo (de T1 a T12) dura un poco menos de microsegundos, y el ciclo completo dura 11.7 渭s, y se denomina tiempo de ciclo de memoria (MCT). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>M贸dulo de memoria de n煤cleo magn茅tico borrable de AGC.</i>  <i>Almacena 2 kilosheets, cada bit se almacena usando un peque帽o anillo de ferrita separado.</i> <br><br>  MCT es la unidad b谩sica de memoria para ejecutar instrucciones.  Una instrucci贸n t铆pica requiere dos ciclos de reloj: uno para extraer la instrucci贸n de la memoria, el segundo para realizar la operaci贸n.  Por lo tanto, una instrucci贸n t铆pica toma dos MCT (23.4 渭s), lo que nos da 43,000 instrucciones por segundo (en comparaci贸n con los procesadores modernos y sus miles de millones de instrucciones por segundo, esto es extremadamente lento). <br><br>  AGC procesa instrucciones, dividi茅ndolas en subcomandos, cada uno de los cuales toma un ciclo de reloj de memoria.  Por ejemplo, una instrucci贸n ADS consta de dos subcomandos: ADS0 (adem谩s) y STD2 (llamando a la siguiente instrucci贸n).  El siguiente diagrama muestra el movimiento de datos dentro del AGC para ejecutar la instrucci贸n ADS0.  12 medidas van de izquierda a derecha. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Los pasos m谩s importantes son los siguientes: <br>  T1: la direcci贸n del operando se copia desde el registro de instrucciones B al registro de direcci贸n de memoria S para comenzar a leer desde la memoria. <br>  T4: el operando se lee de la memoria al registro de datos de memoria G. <br>  T5: el operando se copia de G al sumador Y. El valor de la unidad A se copia al sumador X. <br>  T6: El sumador calcula la suma U y la copia en el registro de datos de la memoria G. <br>  T8: El contador de programa Z se copia en el registro de direcci贸n de memoria S en preparaci贸n para recibir la siguiente instrucci贸n de la memoria. <br>  T10: la suma del registro de datos de la memoria G se vuelve a escribir en la memoria. <br>  T11: la cantidad U se copia en la unidad A. <br><br>  Aunque esta es una simple instrucci贸n de suma, una gran cantidad de datos se transmiten una y otra vez durante 12 intervalos de tiempo.  Y con cada una de estas acciones se asocia una se帽al de control espec铆fica;  por ejemplo, la se帽al A2X en el intervalo T5 copia el valor del variador A al registro X. Para copiar el registro G al registro Y, se requieren dos pulsos de control: RG (leer G) y WY (escribir Y).  En la siguiente secci贸n, explicar茅 c贸mo el m贸dulo de control AGC genera las se帽ales de control necesarias para cada instrucci贸n. <br><br><h2>  M贸dulo de control </h2><br>  Como la mayor铆a de las computadoras, el m贸dulo de control AGC decodifica cada instrucci贸n y genera se帽ales de control que le indican al resto del procesador lo que debe hacer.  El AGC utiliza un m贸dulo de control preprogramado que consta de v谩lvulas NOR para generar se帽ales.  AGC no utiliza microc贸digo;  no tiene microinstrucciones ni memoria de control, ya que esto ocupar铆a demasiado espacio f铆sico. <br><br>  El coraz贸n del m贸dulo de control AGC se llama generador de punto de cruce.  Toma un subcomando y uno de los per铆odos de tiempo y genera se帽ales de control para esta combinaci贸n.  Se puede imaginar en forma de una red, en la que los subcomandos van en una direcci贸n y los segmentos de tiempo en la otra, y cada uno de los puntos de intersecci贸n tiene su propia se帽al de control. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>El generador de intersecci贸n requiere muchos componentes y se divide en tres m贸dulos;</i>  <i>Este es el m贸dulo A6.</i>  <i>Presta atenci贸n a los cables agregados que cambian el circuito.</i>  <i>Esta es una versi贸n temprana de un m贸dulo para probar en el terreno;</i>  <i>los m贸dulos de vuelo ya no ten铆an cables.</i> <br><br>  Para mayor eficiencia, el m贸dulo de control final est谩 altamente optimizado.  El generador de intersecci贸n combina y procesa las instrucciones con un comportamiento similar, lo que reduce el tama帽o del circuito requerido.  Por ejemplo, AGC tiene una instrucci贸n "agregar a una unidad con doble precisi贸n" (DAS).  Como es aproximadamente equivalente a dos adiciones de palabras simples, los subcomandos DAS1 y ADS0 en el generador de intersecci贸n tienen una l贸gica com煤n.  El siguiente diagrama muestra el circuito generador de intersecci贸n para el intervalo de tiempo T5, y se resalta la l贸gica del subcomando ADS0 (usando la se帽al DAS1).  Por ejemplo, se genera una se帽al de 5K a partir de una combinaci贸n de DAS1 y T5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Pero, 驴qu茅 son las se帽ales 5K y 5L?  Esta es otra optimizaci贸n.  Muchos pulsos de control a menudo se alimentan juntos, por lo que en lugar de generarlos directamente, el generador de intersecci贸n genera se帽ales intermedias para las intersecciones.  Por ejemplo, 5K genera pulsos de control A2X y RG, y 5L genera pulsos de control WY.  El siguiente diagrama muestra c贸mo se genera la se帽al A2X: cualquiera de las 8 se帽ales diferentes (incluyendo 5K) genera A2X.  Circuitos similares generan otras se帽ales de control.  Estas optimizaciones permitieron reducir el tama帽o del generador de intersecci贸n, pero a煤n as铆 se mantuvo grande y se convirti贸 en hasta tres m贸dulos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  En resumen, podemos decir que el m贸dulo de control es responsable de decirle a la CPU qu茅 hacer para ejecutar la instrucci贸n.  Primero, las instrucciones se desglosan en subcomandos.  El generador de intersecci贸n genera los pulsos de control necesarios para cada intervalo de tiempo y subcomando, indicando a los registros, el m贸dulo aritm茅tico y la memoria lo que deben hacer. <br><br>  Por lo general, las instrucciones constaban de dos subcomandos, pero hab铆a excepciones.  Algunas de las instrucciones, como la multiplicaci贸n o divisi贸n, requer铆an el uso de muchos subcomandos, ya que consist铆an en muchos pasos.  Por el contrario, la instrucci贸n de salto en TC utiliz贸 un subcomando, ya que solo necesitaba llamar a la siguiente instrucci贸n. <br><br>  Otros procesadores utilizaron diferentes enfoques para la generaci贸n de se帽ales de control.  6502 y muchos otros primeros microprocesadores decodificaron las instrucciones utilizando una matriz l贸gica programable (PLA) que implementa la l贸gica AND / OR a trav茅s de la memoria de solo lectura. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br>  <i>Microprocesador 6502.</i> <br><br><h2>  Conclusi贸n </h2><br>  Fue un recorrido emocionante por la computadora de control a bordo Apollo.  Para no estirarlo mucho, me concentr茅 en las instrucciones de adici贸n de ADS y algunos pulsos de control (A2X, RG y WY).  Espero que tenga una idea de c贸mo ensamblar una computadora a partir de elementos tan primitivos como las v谩lvulas NOR. <br><br>  La parte m谩s visible de la arquitectura es la ruta de datos: un m贸dulo aritm茅tico, registros y un bus de datos.  Los registros AGC se basan en disparadores simples de puertas NOR.  Y aunque el m贸dulo aritm茅tico AGC solo puede sumar, la computadora a煤n puede manejar todo el conjunto de operaciones, incluidas las operaciones de multiplicaci贸n, divisi贸n y booleanas. <br><br>  Sin embargo, la ruta de datos es solo una parte de la computadora.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre otros componentes cr铆ticos, hay un m贸dulo de control que les dice a los componentes lo que deben hacer. </font><font style="vertical-align: inherit;">El enfoque utilizado en AGC se basa en un generador de intersecci贸n que utiliza una l贸gica altamente optimizada y codificada para generar los pulsos de control correctos para subcomandos e intervalos de tiempo espec铆ficos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando estas capacidades, el AGC proporcion贸 orientaci贸n, navegaci贸n y control a bordo de las misiones Apolo, y permiti贸 aterrizar en la luna. </font><font style="vertical-align: inherit;">Tambi茅n estimul贸 la industria de los circuitos integrados iniciales utilizando el 60% de los circuitos integrados de fabricaci贸n estadounidense en 1963. Por lo tanto, las computadoras modernas le deben mucho a AGC y sus componentes NOR simples. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGC trabaja en un laboratorio conectado a un osciloscopio Tektronix antiguo</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472792/">https://habr.com/ru/post/472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472776/index.html">Copia de seguridad Parte 7: Conclusiones</a></li>
<li><a href="../472778/index.html">5 maneras de usar la Raspberry Pi</a></li>
<li><a href="../472780/index.html">驴Por qu茅 evitar amigos o c贸mo perd铆 todas mis ventajas?</a></li>
<li><a href="../472782/index.html">Por qu茅 3D Dolor de cabeza / Parte 8 Desenfoque y el futuro de 3D</a></li>
<li><a href="../472790/index.html">Antig眉edades: i-Mate Jasjar, un comunicador para empresas</a></li>
<li><a href="../472796/index.html">YES retrocede FAANG * o [gu铆a pr谩ctica] en la b煤squeda de empleo en EE. UU. / Europa para un especialista en TI</a></li>
<li><a href="../472798/index.html">Mapas de Yandex para la aplicaci贸n de Taxi</a></li>
<li><a href="../472802/index.html">MIRO es una plataforma abierta de robot de interior. Parte 2 - Dise帽o de robot</a></li>
<li><a href="../472810/index.html">Para el administrador del sistema principiante: c贸mo hacer que el orden salga del caos</a></li>
<li><a href="../472812/index.html">驴Se "apaga" el servidor si la prueba de humo del centro de datos "se incendi贸"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>