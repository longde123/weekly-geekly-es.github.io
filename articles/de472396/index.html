<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê© ü•• üåæ In 4 Sekunden um die Welt im Columnstore (Teil 1) üë∞üèΩ üé≤ üê†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich erw√§gen, die Geschwindigkeit von Berichten zu erh√∂hen. Mit einem Bericht meine ich jede Abfrage an eine Datenbank, die Agg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In 4 Sekunden um die Welt im Columnstore (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472396/">  In diesem Artikel werde ich erw√§gen, die Geschwindigkeit von Berichten zu erh√∂hen.  Mit einem Bericht meine ich jede Abfrage an eine Datenbank, die Aggregatfunktionen verwendet.  Au√üerdem werde ich auf Fragen eingehen, die sich auf die Ressourcen beziehen, die f√ºr die Erstellung und Unterst√ºtzung von Berichten sowohl von Menschen als auch von Maschinen aufgewendet werden. <br><br>  In den Beispielen werde ich einen Datensatz verwenden, der 52.608.000 Datens√§tze enth√§lt. <br><br>  Am Beispiel nicht schwieriger analytischer Reserven werde ich zeigen, dass selbst ein schwacher Computer ohne gro√üen Aufwand zu einem guten Werkzeug f√ºr die Analyse einer ‚Äûanst√§ndigen‚Äú Datenmenge werden kann. <br><br>  Nachdem wir keine komplizierten Experimente durchgef√ºhrt haben, werden wir feststellen, dass eine regul√§re Tabelle keine geeignete Quelle f√ºr analytische Abfragen ist. <br><br>  Wenn der Leser die Abk√ºrzungen OLTP und OLAP leicht entschl√ºsseln kann, kann es sinnvoll sein, direkt zum Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Columnstore</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wechseln</a> <br><br><h4>  Zwei Ans√§tze zum Arbeiten mit Daten </h4><br>  Hier werde ich mich kurz fassen, weil  Zu diesem Thema gibt es im Internet mehr als genug Informationen. <br><br>  Auf h√∂chster Ebene gibt es also nur zwei Ans√§tze f√ºr die Arbeit mit Daten: OLTP und OLAP. <br><br>  OLTP - kann als sofortige Transaktionsverarbeitung √ºbersetzt werden.  In der Tat sprechen wir √ºber die Online-Verarbeitung von kurzen Transaktionen, die mit einer kleinen Datenmenge arbeiten.  Zum Beispiel das Aufzeichnen, Aktualisieren oder L√∂schen einer Bestellung.  In den allermeisten F√§llen handelt es sich bei einer Bestellung um eine √§u√üerst kleine Datenmenge, bei deren Verarbeitung Sie keine Angst vor den langen Sperren haben m√ºssen, die das moderne RDBMS auferlegt. <br><br>  OLAP - kann als analytische Verarbeitung einer gro√üen Anzahl von Transaktionen gleichzeitig √ºbersetzt werden.  Jeder Bericht verwendet diesen speziellen Ansatz, da der Bericht in den allermeisten F√§llen zusammenfassende, aggregierte Zahlen f√ºr bestimmte Abschnitte erstellt. <br><a name="habracut"></a><br>  Jeder Ansatz hat seine eigene Technologie.  F√ºr OLTP ist es beispielsweise PostgreSQL und f√ºr OLAP Microsoft SQL Server Analysis Services.  W√§hrend PostgresSQL ein bekanntes Format zum Speichern von Daten in Tabellen verwendet, wurden f√ºr OLAP verschiedene Formate erfunden.  Dies sind mehrdimensionale Tabellen, ein mit Schl√ºssel-Wert-Paaren gef√ºllter Eimer und mein bevorzugter Spaltenspeicher.  √úber letzteres im Detail weiter unten. <br><br><h4>  Warum sind zwei Ans√§tze erforderlich? </h4><br>  Es wurde festgestellt, dass jedes Data Warehouse fr√ºher oder sp√§ter zwei Arten von Belastungen ausgesetzt ist: h√§ufiges Lesen (nat√ºrlich auch Schreiben und Aktualisieren) extrem kleiner Datenmengen und seltenes Lesen, aber sehr gro√üe Datenmengen.  In der Tat ist dies eine Aktivit√§t, zum Beispiel der Abendkasse und des Leiters.  Die Kasse, die den ganzen Tag arbeitet, f√ºllt den Speicher mit kleinen Datenbl√∂cken, w√§hrend am Ende des Tages das angesammelte Volumen, wenn das Gesch√§ft gut l√§uft, eine beeindruckende Gr√∂√üe erreicht.  Im Gegenzug m√∂chte der Manager am Ende des Tages wissen, wie viel Geld die Abendkasse pro Tag verdient hat. <br><br>  In OLTP gibt es also Tabellen und Indizes.  Diese beiden Tools eignen sich hervorragend zum Aufzeichnen von Kassenaktivit√§ten mit allen Details.  Indizes bieten eine schnelle Suche nach einer zuvor aufgezeichneten Bestellung, sodass das √Ñndern einer Bestellung einfach ist.  Um jedoch die Bed√ºrfnisse des Leiters zu befriedigen, m√ºssen wir die gesamte pro Tag gesammelte Datenmenge ber√ºcksichtigen.  Dar√ºber hinaus ben√∂tigt der Manager in der Regel nicht alle Details aller Bestellungen.  Was er wirklich wissen muss, ist, wie viel Geld die Abendkasse im Allgemeinen verdient hat.  Es spielt keine Rolle, wo sich das Ticketb√ºro befand, wann es eine Mittagspause gab, wer daf√ºr arbeitete usw.  OLAP existiert dann, so dass das System in kurzer Zeit die Frage beantworten kann, wie viel das Unternehmen insgesamt verdient hat, ohne jede Bestellung und alle Details nacheinander zu lesen.  Kann OLAP dieselben Tabellen und Indizes wie OLTP verwenden?  Die Antwort ist nein, zumindest sollte es nicht.  Erstens, weil OLAP nicht alle in den Tabellen aufgezeichneten Details ben√∂tigt.  Dieses Problem wird gel√∂st, indem Daten in anderen Formaten als zweidimensionalen Tabellen gespeichert werden.  Zweitens werden die analysierten Informationen h√§ufig √ºber verschiedene Tabellen verteilt, was zu mehreren Assoziationen f√ºhrt, einschlie√ülich Assoziationen vom Typ Self-Join.  Um dieses Problem zu l√∂sen, entwickeln sie in der Regel ein spezielles Datenbankschema.  Dieses Schema ist sowohl f√ºr das OLAP-Laden als auch f√ºr das normale normalisierte Schema f√ºr das OLTP-Laden optimiert. <br><br><h4>  Was passiert, wenn OLAP ein OLTP-Schema verwendet? </h4><br>  Tats√§chlich habe ich diesen Abschnitt eingef√ºhrt, damit dieser Artikel eindeutig meine eigenen Anforderungen an das Format eines solchen Materials erf√ºllt, d. H.  Problem, L√∂sung, Schlussfolgerung. <br><br>  Wir listen eine Reihe von Nachteilen bei der Verwendung von OLTP-Schemata f√ºr die Datenanalyse auf. <br><br><ul><li>  Zu viele Indizes. <br><br>  <i>Oft m√ºssen Sie spezielle Indizes erstellen, um Berichte zu unterst√ºtzen.</i>  <i>Diese Indizes implementieren ein OLAP-Datenspeicherschema.</i>  <i>Sie werden vom OLTP-Teil der Anwendung nicht verwendet, w√§hrend sie belastet werden, st√§ndige Unterst√ºtzung erfordern und Speicherplatz beanspruchen.</i> </li><li>  Die Menge der gelesenen Daten √ºberschreitet die erforderliche Menge. </li><li>  Fehlen eines klaren Datenschemas. <br><br>  <i>Tatsache ist, dass die von Berichten in einer einzigen Form √ºbermittelten Informationen h√§ufig in verschiedenen Tabellen verteilt sind.</i>  <i>Solche Informationen erfordern eine st√§ndige Transformation im laufenden Betrieb.</i>  <i>Das einfachste Beispiel ist die H√∂he der Einnahmen, die aus Bargeld und Sachgeld besteht.</i>  <i>Ein weiteres bemerkenswertes Beispiel sind Datenhierarchien.</i>  <i>Weil</i>  <i>Die Anwendungsentwicklung ist fortschrittlich und es ist nicht immer bekannt, was in Zukunft ben√∂tigt wird. Dieselbe Bedeutungshierarchie kann in verschiedenen Tabellen gespeichert werden.</i>  <i>W√§hrend die On-the-Fly-Erfassung in OLAP aktiv genutzt wird, sind dies etwas andere Dinge.</i> </li><li>  √úberm√§√üige Komplexit√§t der Abfragen. <br><br>  <i>Weil</i>  <i>Ein OLTP-Schema unterscheidet sich von einem OLAP. Es wird eine stark verwandte Softwareschicht ben√∂tigt, die das OLTP-Datenschema in die richtige Form bringt.</i> </li><li>  Komplexit√§t von Support, Debugging und Entwicklung. <br><br>  <i>Im Allgemeinen k√∂nnen wir sagen, dass es umso schwieriger ist, die Codebasis in einem gesunden Zustand zu halten, je komplexer sie ist.</i>  <i>Dies ist ein Axiom.</i> </li><li>  Die Komplexit√§t der Testabdeckung. <br><br>  <i>Viele Kopien sind aufgrund von Diskussionen dar√ºber, wie eine Datenbank mit allen Testskripten gef√ºllt werden kann, fehlerhaft. Es ist jedoch besser zu sagen, dass die Aufgabe, Tests durchzuf√ºhren, durch ein einfacheres Datenschema um ein Vielfaches vereinfacht wird.</i> </li><li>  Endloses Performance-Debugging. <br><br>  <i>Es besteht eine hohe Wahrscheinlichkeit, dass der Benutzer einen Bericht bestellt, der f√ºr den Datenbankserver ‚Äûschwer‚Äú ist.</i>  <i>Diese Wahrscheinlichkeit nimmt mit der Zeit zu.</i>  <i>Es sollte beachtet werden, dass OLAP ebenfalls f√ºr dieses Problem anf√§llig ist, aber im Gegensatz zu OLTP ist die OLAP-Ressource in dieser Angelegenheit viel h√∂her.</i> </li></ul><br> <b><a name="cs"></a></b>  <b>Columnstore</b> <br><br>  Dieser Artikel konzentriert sich auf das Columnstore-Speicherformat, jedoch ohne Details auf niedriger Ebene.  Andere oben erw√§hnte Formate verdienen ebenfalls Aufmerksamkeit, aber dies ist ein Thema f√ºr einen anderen Artikel. <br><br>  Tats√§chlich ist das Columnstore-Format seit 30 Jahren bekannt. Es wurde jedoch bis vor kurzem nicht im RDBMS implementiert.  Das Wesentliche beim Spaltenspeicher ist, dass Daten nicht in Zeilen, sondern in Spalten gespeichert werden.  Das hei√üt,  Auf einer Seite (alle bekannt 8 KB) zeichnet der Server nur Daten eines Feldes auf.  Und so mit jedem Feld in der Tabelle der Reihe nach.  Dies ist notwendig, damit Sie keine zus√§tzlichen Informationen lesen m√ºssen.  Stellen wir uns eine Tabelle mit 10 Feldern und einer Abfrage vor, in der nur ein Feld in der SELECT-Anweisung angegeben ist.  Wenn es sich um eine regul√§re Tabelle handelt, die in einem zeilenbasierten Format gespeichert ist, muss der Server alle 10 Felder lesen, gibt jedoch gleichzeitig nur eines zur√ºck.  Es stellte sich heraus, dass der Server neunmal mehr Informationen las als n√∂tig.  Columnstore l√∂st dieses Problem vollst√§ndig, weil  Im Speicherformat k√∂nnen Sie nur ein geordnetes Feld lesen.  All dies geschieht, weil die Speichereinheit in einem RDBMS eine Seite ist.  Das hei√üt,  Der Server schreibt und liest immer mindestens eine Seite.  Die Frage ist nur, wie viele Felder darauf vorhanden sind. <br><br><h4>  Wie Columnstore wirklich helfen kann </h4><br>  Um dies zu beantworten, muss man genaue Zahlen haben.  Lass sie uns holen.  Aber welche Zahlen k√∂nnen ein genaues Bild ergeben? <br><br><ol><li>  Die Menge an Speicherplatz. </li><li>  Abfrageleistung. </li><li>  Fehlertoleranz. </li><li>  Einfache Implementierung. </li><li>  Welche neuen F√§higkeiten sollte ein Entwickler haben, um mit neuen Strukturen zu arbeiten? </li></ol><br><h4>  Speicherplatz </h4><br>  Lassen Sie uns eine einfache Tabelle erstellen, sie mit Daten f√ºllen und √ºberpr√ºfen, wie viel Speicherplatz daf√ºr ben√∂tigt wird. <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cstore_table ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>);</code> </pre> <br>  Wie Sie bemerkt haben, habe ich eine externe Tabelle erstellt.  Tatsache ist, dass PostgreSQL keine integrierte Columnstore-Unterst√ºtzung bietet.  PostgreSQL verf√ºgt jedoch √ºber ein leistungsstarkes System f√ºr Erweiterungen.  Eine davon erm√∂glicht das Erstellen von Spaltenspeichertabellen.  Links am Ende des Artikels. <br><br><ul><li>  pglz - teilt der Erweiterung mit, dass die Daten mithilfe des in PostgreSQL integrierten Algorithmus komprimiert werden sollen; </li><li>  trd - Transaktionszeit; </li><li>  op, it, wh - analytische Schnitte oder Messungen; </li><li>  m1, m2, m3, m4, m5 - numerische Indikatoren oder Ma√üe; </li></ul><br>  F√ºgen wir eine ‚Äûanst√§ndige‚Äú Datenmenge ein und sehen, wie viel Speicherplatz auf der Festplatte ben√∂tigt wird.  Gleichzeitig √ºberpr√ºfen wir die Leistung des Einsatzes.  Weil  Ich habe meine Experimente auf einen Laptop zu Hause gestellt, ich bin ein bisschen organisch in der Datenmenge.  Au√üerdem, was sogar gut ist, werde ich die Festplatte verwenden, auf der das Gastbetriebssystem Fedora 30 ausgef√ºhrt wird. Betriebssystemhost - Windows 10 Home Edition.  Prozessor Intel Core 7. Das Gastbetriebssystem erhielt 4 GB RAM.  PostgreSQL-Version - PostgreSQL 10.10 auf x86_64-pc-linux-gnu, kompiliert von gcc (GCC) 9.1.1 20190503 (Red Hat 9.1.1-1), 64-Bit.  Ich werde mit einem Datensatz mit der Anzahl der Datens√§tze 52 608 000 experimentieren. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  In cstore_table einf√ºgen (Kosten = 0,01..24902714242540.01 Zeilen = 1000000000000000 Breite = 150) (tats√§chliche Zeit = 119560.456..119560.456 Zeilen = 0 Schleifen = 1) <br>  ----&gt; Verschachtelte Schleife (Kosten = 0,01..24902714242540.01 Zeilen = 1000000000000000 Breite = 150) (tats√§chliche Zeit = 1.823..22339.976 Zeilen = 52608000 Schleifen = 1) <br>  ----------&gt; Funktionsscan f√ºr generate_series d (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,151..2,198 Zeilen = 1096 Schleifen = 1) <br>  ----------&gt; Materialisieren (Kosten = 0,01..27284555030.01 Zeilen = 1000000000000 Breite = 16) (tats√§chliche Zeit = 0,002..3.196 Zeilen = 48000 Schleifen = 1096) <br>  ----------------&gt; Verschachtelte Schleife (Kosten = 0,01..17401742530.01 Zeilen = 1000000000000 Breite = 16) (tats√§chliche Zeit = 1.461..15.072 Zeilen = 48000 Schleifen = 1) <br>  ----------------------&gt; Funktionsscan auf generate_series it (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 1,159..2,007 Zeilen = 4000 Schleifen = 1) <br>  ----------------------&gt; Materialisieren (Kosten = 0,01..26312333.01 Zeilen = 1.000.000.000 Breite = 12) (tats√§chliche Zeit = 0.000..0.001 Zeilen = 12 Schleifen = 4000) <br>  ----------------------------&gt; Verschachtelte Schleife (Kosten = 0,01..16429520,01 Zeilen = 1.000.000.000 Breite = 12) (tats√§chliche Zeit = 0,257 ..0.485 Zeilen = 12 Schleifen = 1) <br>  ----------------------------------&gt; Funktionsscan auf generate_series wh (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,046..0,049 Zeilen = 3 Schleifen = 1) <br>  ----------------------------------&gt; Materialisieren (Kosten = 0,01..28917,01 Zeilen = 1.000.000 Breite = 8) (tats√§chliche Zeit = 0,070..0,139 Zeilen = 4 Schleifen = 3) <br>  ---------------------------------------&gt; Verschachtelte Schleife (Kosten = 0.01..20010.01 Zeilen = 1000000 Breite = 8) (tats√§chliche Zeit = 0,173..0,366 Zeilen = 4 Schleifen = 1) <br>  ---------------------------------------&gt; Funktionsscan auf generate_series op ( Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,076..0,079 Zeilen = 2 Schleifen = 1) <br>  -----------------------------------------&gt; Funktionsscan auf generate_series org (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,043..0,047 Zeilen = 2 Schleifen = 2) <br>  Planungszeit: 0,439 ms <br>  Ausf√ºhrungszeit: 119692.051 ms </blockquote>  Gesamtvorlaufzeit - 1.994867517 Minuten <br><br>  Erstellungszeit des Datensatzes - 22.339976 Sekunden <br><br>  Einf√ºgezeit - 1.620341333 Minuten <br><br>  Es ist mir nicht gelungen, den belegten Speicherplatz mithilfe von PostgreSQL-Funktionen zu bewerten.  Ich wei√ü nicht warum, aber ich zeige 0. Vielleicht ist dies das Standardverhalten f√ºr externe Tabellen.  Wird f√ºr diesen Dateimanager verwendet.  Das belegte Speicherplatzvolumen betr√§gt also 226,2 MB.  Um viel oder wenig zu bewerten, vergleichen wir es mit einer normalen Tabelle. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  Verschachtelte Schleife (Kosten = 0,01..22402714242540.01 Zeilen = 1000000000000000 Breite = 44) (tats√§chliche Zeit = 0,585..23781.942 Zeilen = 52608000 Schleifen = 1) <br>  ---&gt; Funktionsscan auf generate_series d (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,091..2,130 Zeilen = 1096 Schleifen = 1) <br>  ---&gt; Materialisieren (Kosten = 0,01..27284555030.01 Zeilen = 1000000000000 Breite = 16) (tats√§chliche Zeit = 0,001..3.574 Zeilen = 48000 Schleifen = 1096) <br>  ----------&gt; Verschachtelte Schleife (Kosten = 0,01..17401742530.01 Zeilen = 1000000000000 Breite = 16) (tats√§chliche Zeit = 0,489..14.044 Zeilen = 48000 Schleifen = 1) <br>  ----------------&gt; Funktionsscan auf generate_series it (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,477..1,352 Zeilen = 4000 Schleifen = 1 ) <br>  ----------------&gt; Materialisieren (Kosten = 0,01..26312333.01 Zeilen = 1000000000 Breite = 12) (tats√§chliche Zeit = 0.000..0.001 Zeilen = 12 Schleifen = 4000) <br>  ----------------------&gt; Verschachtelte Schleife (Kosten = 0,01..16429520.01 Zeilen = 1.000.000.000 Breite = 12) (tats√§chliche Zeit = 0.010..0.019 Zeilen = 12 Schleifen = 1) <br>  ----------------------------&gt; Funktionsscan auf generate_series wh (Kosten = 0,00..10,00 Zeilen = 1000 Breite = 4) (tats√§chlich Zeit = 0,003..0,003 Zeilen = 3 Schleifen = 1) <br>  ----------------------------&gt; Materialisieren (Kosten = 0,01..28917,01 Zeilen = 1.000.000 Breite = 8) (tats√§chliche Zeit = 0,002. 0,004 Zeilen = 4 Schleifen = 3) <br>  ----------------------------------&gt; Verschachtelte Schleife (Kosten = 0,01..20010,01 Zeilen = 1.000.000 Breite = 8 ) (tats√§chliche Zeit = 0,006..0,009 Zeilen = 4 Schleifen = 1) <br>  ----------------------------------------&gt; Funktionsscan bei generate_series op (Kosten = 0,00 ..10.00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0.002..0.002 Zeilen = 2 Schleifen = 1) <br>  ----------------------------------------&gt; Funktionsscan auf generate_series org (Kosten = 0,00 ..10.00 Zeilen = 1000 Breite = 4) (tats√§chliche Zeit = 0,001..0.001 Zeilen = 2 Schleifen = 2) <br>  Planungszeit: 0,569 ms <br>  Ausf√ºhrungszeit: 378883.989 ms </blockquote>  Die Zeit, die f√ºr die Umsetzung dieses Plans aufgewendet wird, interessiert uns nicht, weil  im wirklichen Leben werden solche Eins√§tze nicht angenommen.  Wir sind daran interessiert, wie viel Speicherplatz diese Tabelle belegt.  Nachdem ich die Anforderung f√ºr Systemfunktionen erf√ºllt hatte, erhielt ich 3,75 GB. <br><br>  Also, cstore_table - 226 MB, rbstore_table - 3,75 GB.  Der Unterschied von 16,99 ist auff√§llig, aber es ist unwahrscheinlich, dass der gleiche Unterschied in der Produktion erzielt werden kann, haupts√§chlich aufgrund der Verteilung von Daten.  In der Regel ist dieser Unterschied geringer und betr√§gt etwa das F√ºnffache. <br><br>  Aber warten Sie, niemand verwendet Rohdaten in einem zeilenbasierten Format f√ºr Analysezwecke.  Beispielsweise versuchen sie, indizierte Daten f√ºr die Berichterstellung zu verwenden.  Und weil  "Rohdaten" werden immer sein, Sie m√ºssen die Gr√∂√üen mit den Gr√∂√üen der Indizes vergleichen.  Lassen Sie uns mindestens einen Index erstellen.  Sei es ein Index f√ºr das Datumsfeld und die Art der Operation - trd + op. <br><br>  Also habe ich nur zwei Felder indiziert, und der Index hat 1583 MB ben√∂tigt, was viel mehr ist als die cstore_table.  In der Regel ist jedoch mehr als ein Index f√ºr das Laden von OLAP erforderlich.  Hierbei ist zu beachten, dass f√ºr die cstore_table keine zus√§tzliche Indizierung erforderlich ist.  Diese Tabelle dient als Index f√ºr alle Abfragen. <br><br>  Aus all dem kann eine einfache Schlussfolgerung gezogen werden: Mithilfe von Columnstore-Tabellen k√∂nnen Sie den verwendeten Speicherplatz reduzieren. <br><br><h4>  Abfrageleistung </h4><br>  F√ºhren Sie zur Bewertung der Leistung eine Abfrage aus, die Zusammenfassungsdaten f√ºr einen bestimmten Monat f√ºr einen bestimmten Operationstyp zur√ºckgibt. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  Aggregat (Kosten = 793602.69..793602.70 Zeilen = 1 Breite = 32) (tats√§chliche Zeit = 79.708..79.708 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 44226 <br>  ---&gt; Fremdscan auf cstore_table (Kosten = 0,00..793544.70 Zeilen = 23197 Breite = 5) (tats√§chliche Zeit = 23.209..76.628 Zeilen = 24000 Schleifen = 1) <br>  -------- Filter: ((trd = '2011-01-01' :: Datum) UND (op = 1)) <br>  -------- Vom Filter entfernte Zeilen: 26000 <br>  -------- CStore-Datei: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16417 <br>  -------- CStore-Dateigr√∂√üe: 120818897 <br>  -------- Puffer: geteilter Treffer = 44226 <br>  Planungszeit: 0,165 ms <br>  Ausf√ºhrungszeit: 79,887 ms </blockquote>  Und <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  Aggregat (Kosten = 40053,80..40053,81 Zeilen = 1 Breite = 8) (tats√§chliche Zeit = 389,183..389,183 Zeilen = 1 Schleifen = 1) <br>  - Puffer: Shared Read = 545 <br>  ---&gt; Index-Scan mit trd_op_ix auf rbstore_table (Kosten = 0,56..39996.70 Zeilen = 22841 Breite = 4) (tats√§chliche Zeit = 55.955..385.283 Zeilen = 24000 Schleifen = 1) <br>  -------- Index Cond: ((trd = '2011-01-01 00:00:00' :: Zeitstempel ohne Zeitzone) AND (op = 1)) <br>  -------- Puffer: Shared Read = 545 <br>  Planungszeit: 112,175 ms <br>  Ausf√ºhrungszeit: 389,219 ms </blockquote>  389,219 ms vs 79,887 ms.  Hier sehen wir, dass selbst bei einer relativ kleinen Menge von Spaltenspeicherdaten eine Tabelle erheblich schneller ist als ein Index f√ºr eine zeilenbasierte Tabelle. <br><br>  Lassen Sie uns die Anfrage √§ndern und versuchen, das Ger√§t f√ºr das gesamte Jahr 2011 zu erhalten. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  Aggregat (Kosten = 946625,58..946625.59 Zeilen = 1 Breite = 32) (tats√§chliche Zeit = 3123.604..3123.604 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 44226 <br>  ---&gt; Fremdscan in cstore_table (Kosten = 0,00..925064,70 Zeilen = 8624349 Breite = 5) (tats√§chliche Zeit = 21,728..2100,665 Zeilen = 8760000 Schleifen = 1) <br>  -------- Filter: ((trd&gt; = '2011-01-01' :: date) AND (trd &lt;= '2011-12-31' :: date) AND (op = 1)) <br>  -------- Vom Filter entfernte Zeilen: 8760000 <br>  -------- CStore-Datei: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16411 <br>  -------- CStore-Dateigr√∂√üe: 120818897 <br>  -------- Puffer: geteilter Treffer = 44226 <br>  Planungszeit: 0,212 ms <br>  Ausf√ºhrungszeit: 3123,960 ms </blockquote>  Und <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Der Umsetzungsplan sieht wie folgt aus <br><blockquote>  Aggregat finalisieren (Kosten = 885214.33..885214.34 Zeilen = 1 Breite = 8) (tats√§chliche Zeit = 98512.560..98512.560 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 2565 read = 489099 <br>  ---&gt; Sammeln (Kosten = 885214.12..885214.33 Zeilen = 2 Breite = 8) (tats√§chliche Zeit = 98427.034..98523.194 Zeilen = 3 Schleifen = 1) <br>  -------- Geplante Arbeitnehmer: 2 <br>  -------- Gestartete Arbeiter: 2 <br>  -------- Puffer: geteilter Treffer = 2565 gelesen = 489099 <br>  ---------&gt; Teilaggregat (Kosten = 884214.12..884214.13 Zeilen = 1 Breite = 8) (tats√§chliche Zeit = 97907.608..97907.608 Zeilen = 1 Schleifen = 3) <br>  -------------- Puffer: geteilter Treffer = 2565 read = 489099 <br>  ---------------&gt; Paralleler Seq-Scan in rbstore_table (Kosten = 0,00..875264.00 Zeilen = 3580047 Breite = 4) (tats√§chliche Zeit = 40820.004..97405.250 Zeilen = 2920000 Schleifen = 3) <br>  --------------------- Filter: ((trd&gt; = '2011-01-01 00:00:00' :: Zeitstempel ohne Zeitzone) UND (trd &lt;= '2011-12-31 00:00:00' :: Zeitstempel ohne Zeitzone) UND (op = 1)) <br>  -------------------- Vom Filter entfernte Zeilen: 14616000 <br>  -------------------- Puffer: geteilter Treffer = 2565 read = 489099 <br>  Planungszeit: 7.899 ms <br>  Ausf√ºhrungszeit: 98523.278 ms </blockquote>  98523,278 ms vs 3123,960 ms.  Vielleicht w√ºrde uns ein Teilindex helfen, aber es ist besser, ihn nicht zu riskieren und eine geeignete row_based-Struktur zu erstellen, in der vorgefertigte Werte gespeichert werden. <br><br><h4>  Manuelle Aggregate </h4><br>  Eine geeignete Struktur f√ºr manuelle Aggregate k√∂nnte eine regul√§re row_based-Tabelle sein, die vorberechnete Werte enth√§lt.  Beispielsweise kann es einen Datensatz f√ºr 2011 mit dem Operationstyp 1 enthalten, w√§hrend in den Feldern m1, m2, m3, m4 und m5 der aggregierte Wert genau f√ºr diese Analyseabschnitte gespeichert wird.  Mit einem ausreichenden Satz von Aggregaten und Indizes erzielen analytische Abfragen eine beispiellose Leistung.  Interessanterweise verf√ºgt Microsoft SQL Server Analysis Services √ºber einen speziellen Assistenten, mit dem Sie die Anzahl und Tiefe vorberechneter Werte konfigurieren k√∂nnen. <br><br>  Diese L√∂sung hat folgende Vorteile: <br><br><ul><li>  Echtzeitanalyse. <br><br>  <i>Bitte verwechseln Sie nicht den Begriff "Echtzeitanalyse".</i>  <i>Hier geht es um die Tatsache, dass das Inkrementieren der Einheit in den allermeisten F√§llen √ºber einen akzeptablen Zeitraum erfolgt.</i> <i><br><br></i>  <i>In der Tat ist dieses Plus umstritten, aber lassen Sie uns nicht dar√ºber sprechen.</i>  <i>Die Tatsache bleibt bestehen.</i>  <i>Die Architektur der L√∂sung ist so, dass die Einheiten fast immer ‚Äûfrisch‚Äú bleiben.</i> </li><li>  Vollst√§ndige Unabh√§ngigkeit vom Datenvolumen. <br><br>  <i>Dies ist ein sehr ernstes Plus.</i>  <i>Unabh√§ngig davon, wie viele Daten verarbeitet werden, werden sie fr√ºher oder sp√§ter verarbeitet und Aggregate empfangen.</i> </li><li>  Relative Komplexit√§t. <br><br>  <i>Um Echtzeitanalysen und Unabh√§ngigkeit vom Datenvolumen zu erhalten, muss die L√∂sung fortschrittliche Technologien wie Multithreading und manuelle Sperrverwaltung auf DBMS-Ebene verwenden.</i> </li><li>  Schwierigkeitspr√ºfung. <br><br>  <i>Hier geht es sowohl um Unit-Tests als auch um manuelle Tests.</i>  <i>Ich denke, der Leser sollte nicht erkl√§ren, dass das Erkennen von Multithreading-Fehlern keine leichte Aufgabe ist.</i> </li><li>  Erh√∂hter Speicherplatzbedarf. <br><br></li></ul><br><h4>  Die tats√§chliche Verwendung von Columnstore </h4><br>  Hier m√ºssen wir noch einmal in die Theorie eintauchen und die Frage, was analytische Daten sind, genauer analysieren. <br><br>  Nehmen Sie den durchschnittlichen Leiter des Unternehmens.  In der Regel ist er / sie besorgt √ºber zwei globale Fragen: ‚ÄûWie l√§uft es im Moment?‚Äú  und "Was hat sich in letzter Zeit ge√§ndert?". <br><br>  Um die Frage ‚ÄûWie l√§uft es im Moment?‚Äú Zu beantworten, ben√∂tigen wir absolut keine historischen Daten.  Das hei√üt,  egal wie es vor einem Monat lief. <br><br>  Um mit dem Puls Schritt zu halten, wird oft die Frage gestellt.  Diese Art der Datenanalyse wird als betriebsbereit bezeichnet. <br><br>  Um die Frage ‚ÄûWas hat sich in letzter Zeit ge√§ndert?‚Äú Zu beantworten, ben√∂tigen wir genau historische Daten.  Dar√ºber hinaus wird die Analyse in der Regel in den gleichen Zeitintervallen durchgef√ºhrt.  Zum Beispiel wird ein Monat mit einem Monat, Jahr zu Jahr usw. verglichen.  Nat√ºrlich sollte das System den Benutzer nicht daran hindern, beliebige Zeitr√§ume zu vergleichen, aber ein solcher Fall muss als selten erkannt werden, weil  Ein Vergleich eines geschlossenen Jahres mit einer nicht geschlossenen H√§lfte macht wenig Sinn.  Ein charakteristisches Merkmal der vergleichenden Analyse ist, dass sie nicht so oft wie betrieblich erforderlich ist.  Wir werden diese Art der Analyse als historisch bezeichnen. <br><br>  Offensichtlich sollte die Betriebsanalyse schnell erfolgen.  Dementsprechend stellt es hohe Anforderungen an die Leistung.  W√§hrend f√ºr die historische Analyse k√∂nnen solche Anforderungen nicht gestellt werden.  Obwohl die Leistung der historischen Analyse auf einem sehr hohen Niveau bleiben sollte.  Zumindest damit das Analysesystem selbst wettbewerbsf√§hig bleibt. <br><br>  Entsprechend zwei Arten von Analysen k√∂nnen wir zwei Arten von Analysedaten unterscheiden: Betriebsdaten und historische Daten.  Von Seiten des Benutzers sollte es nicht erkennbar sein, mit welchen bestimmten Daten er gerade arbeitet. <br><br>  Aufgrund dieser √úberlegungen hat sich auf Datenbankservern die M√∂glichkeit ergeben, Tabellen in separate Abschnitte aufzuteilen. <br><br>  In Bezug auf den Spaltenspeicher ist es m√∂glich, Abschnitte in zeilenbasierten und Spaltenspeicherformaten zu mischen.  Es ist bekannt, dass Betriebsanalysedaten h√§ufigen √Ñnderungen unterliegen, wodurch ihre Speicherung im Spaltenspeicherformat verhindert wird.  Und da Betriebsdaten nicht zu h√§ufig vorkommen, k√∂nnen sie im zeilenbasierten Format gespeichert werden. <br><br>  Historische Daten √§ndern sich nicht.  Es gibt viele dieser Daten, und daher passt das Columnstore-Format besser zu ihnen.  Denken Sie daran, dass die Leistung von fett gedruckten Abfragen in einer Columnstore-Quelle h√∂her ist als in einer zeilenbasierten Quelle. <br><br>  Schauen wir uns ein Beispiel f√ºr all das an. <br><br>  Im Folgenden erstelle ich die Hauptlagertabelle und f√ºge die Abschnitte der betrieblichen und historischen Analyse hinzu. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">partition by range</span></span>(trd); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> historycal_data ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-number"><span class="hljs-number">1095</span></span> - <span class="hljs-number"><span class="hljs-number">31</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> historycal_data; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d))::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> trd_op_ix <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> operational_data (trd, op); <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> operational_data; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2112-01-01'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>);</code> </pre> <br>  Alles ist fertig.  Versuchen wir, ein paar Berichte zu bestellen.  Beginnen wir mit der Bestellung von Daten f√ºr einen Tag des aktuellen Monats. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><blockquote>  Aggregat (Kosten = 15203.37..15203.38 Zeilen = 1 Breite = 32) (tats√§chliche Zeit = 17.320..17.320 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 3 gelesen = 515 <br>  ---&gt; Anh√§ngen (Kosten = 532,59..15140,89 Zeilen = 24991 Breite = 5) (tats√§chliche Zeit = 1,924..13,838 Zeilen = 24000 Schleifen = 1) <br>  ------- Puffer: geteilter Treffer = 3 gelesen = 515 <br>  ---------&gt; Bitmap-Heap-Scan f√ºr Betriebsdaten (Kosten = 532,59..15140,89 Zeilen = 24991 Breite = 5) (tats√§chliche Zeit = 1,924..11,992 Zeilen = 24000 Schleifen = 1) <br>  --------------- √úberpr√ºfen Sie erneut Cond: ((trd = '2012-12-01' :: date) AND (op = 1)) <br>  --------------- Heap-Bl√∂cke: genau = 449 <br>  --------------- Puffer: geteilter Treffer = 3 gelesen = 515 <br>  ----------------&gt; Bitmap-Index-Scan auf trd_op_ix (Kosten = 0,00..526,34 Zeilen = 24991 Breite = 0) (tats√§chliche Zeit = 1,877..1,877 Zeilen = 24000 Schleifen = 1 ) <br>  --------------------- Index Cond: ((trd = '2012-12-01' :: date) AND (op = 1)) <br>  --------------------- Puffer: geteilter Treffer = 2 gelesen = 67 <br>  Planungszeit: 0,388 ms <br>  Ausf√ºhrungszeit: 100.941 ms </blockquote>  Jetzt werden wir Daten f√ºr das gesamte Jahr 2012 bestellen, bei denen die Anzahl der Transaktionen 8.784.000 betr√§gt. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2012-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2012-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><blockquote>  Aggregat (Kosten = 960685.82..960685.83 Zeilen = 1 Breite = 32) (tats√§chliche Zeit = 4124.681..4124.681 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 45591 read = 11282 <br>  ---&gt; Anh√§ngen (Kosten = 0,00..938846.60 Zeilen = 8735687 Breite = 5) (tats√§chliche Zeit = 66.581..3036.394 Zeilen = 8784000 Schleifen = 1) <br>  --------- Puffer: geteilter Treffer = 45591 read = 11282 <br>  ----------&gt; Fremdscan f√ºr historycal_data (Kosten = 0,00..898899.60 Zeilen = 7994117 Breite = 5) (tats√§chliche Zeit = 66.579..2193.801 Zeilen = 8040000 Schleifen = 1) <br>  --------------- Filter: ((trd&gt; = '2012-01-01' :: date) AND (trd &lt;= '2012-12-31' :: date) AND (op = 1)) <br>  --------------- Vom Filter entfernte Zeilen: 8040000 <br>  --------------- CStore-Datei: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- CStore-Dateigr√∂√üe: 117401470 <br>  --------------- Puffer: geteilter Treffer = 42966 <br>  ----------&gt; Seq Scan on operational_data (Kosten = 0,00..39947,00 Zeilen = 741570 Breite = 5) (tats√§chliche Zeit = 0,019..284,824 Zeilen = 744000 Schleifen = 1) <br>  --------------- Filter: ((trd&gt; = '2012-01-01' :: date) AND (trd &lt;= '2012-12-31' :: date) AND (op = 1)) <br>  --------------- Vom Filter entfernte Zeilen: 744000 <br>  --------------- Puffer: geteilter Treffer = 2625 gelesen = 11282 <br>  Planungszeit: 0,256 ms <br>  Ausf√ºhrungszeit: 4125.239 ms </blockquote>  Lassen Sie uns am Ende sehen, was passiert, wenn der Benutzer beispielsweise ohne b√∂swillige Absicht einen Bericht √ºber alle Transaktionen im System bestellen m√∂chte, von denen es 52 608 000 gibt. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse</code> </pre> <br><blockquote>  Aggregat (Kosten = 672940.20..672940.21 Zeilen = 1 Breite = 32) (tats√§chliche Zeit = 15907.886..15907.886 Zeilen = 1 Schleifen = 1) <br>  - Puffer: geteilter Treffer = 17075 read = 11154 <br>  ---&gt; Anh√§ngen (Kosten = 0,00..541420,20 Zeilen = 52608000 Breite = 5) (tats√§chliche Zeit = 0,192..9115.144 Zeilen = 52608000 Schleifen = 1) <br>  --------- Puffer: geteilter Treffer = 17075 gelesen = 11154 <br>  ----------&gt; Fremdscan f√ºr historycal_data (Kosten = 0,00..512633.20 Zeilen = 51120000 Breite = 5) (tats√§chliche Zeit = 0.191..5376.449 Zeilen = 51120000 Schleifen = 1) <br>  --------------- CStore-Datei: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- CStore-Dateigr√∂√üe: 117401470 <br>  --------------- Puffer: geteilter Treffer = 14322 <br>  ----------&gt; Seq Scan on operational_data (Kosten = 0,00..28787,00 Zeilen = 1488000 Breite = 5) (tats√§chliche Zeit = 0,032..246,978 Zeilen = 1488000 Schleifen = 1) <br>  --------------- Puffer: geteilter Treffer = 2753 read = 11154 <br>  Planungszeit: 0,157 ms <br>  Ausf√ºhrungszeit: 15908.096 ms </blockquote>  Bitte beachten Sie, dass ich meinen Artikel immer noch schreibe, als w√§re nichts passiert.  Ich musste meinen nicht so leistungsstarken Laptop mit Festplatte und 4 GB RAM nicht einmal neu starten.  Obwohl das Problem des Ressourcenverbrauchs eine genauere Untersuchung erfordert. <br><br><h4>  Fehlertoleranz </h4><br>  Zum Teil wurde die Fehlertoleranz zum Zeitpunkt dieses Schreibens getestet.  Mein Laptop lebt, und im Allgemeinen habe ich au√üer den √ºblichen keine Verlangsamung in seiner Arbeit bemerkt. <br><br>  Lassen Sie den Leser mir verzeihen, dass ich keine Zeit hatte, das Problem der Fehlertoleranz im Detail zu erarbeiten, aber ich kann sagen, dass die betreffende Erweiterung Fehlertoleranz aufweist - eine Sicherung ist m√∂glich. <br><br><h4>  Einfache Implementierung </h4><br>  Wie sich herausstellte, gibt es beim Erstellen einer Tabelle, in der Daten in einem Spaltenspeicherformat gespeichert werden, keine anderen Optionen als einen Komprimierungsalgorithmus.  Die Komprimierung selbst ist unbedingt erforderlich. <br><br>  Das Format selbst hat eine bestimmte Struktur.  Durch Einstellen der entsprechenden Parameter k√∂nnen Sie eine bestimmte Beschleunigung der analytischen Abfragen erreichen oder den Grad der Komprimierung von Informationen anpassen. <br><br>  Wie oben gezeigt, ist das Erstellen einer Columnstore-Tabelle √ºberhaupt kein Problem.  Die Erweiterung kann mit 40 PostgreSQL-Datentypen arbeiten.  In Webinaren wurde √ºber alle von PostgreSQL unterst√ºtzten Typen gesprochen. <br><br><h4>  Welche neuen F√§higkeiten sollte ein Entwickler haben, um mit neuen Strukturen zu arbeiten? </h4><br>  Der SQL-Entwickler ben√∂tigt keine besonderen Kenntnisse zum Schreiben von Abfragen in Spaltenspeichertabellen.  Eine solche Tabelle ist in allen Abfragen sichtbar, wie eine regul√§re zeilenbasierte Tabelle.  Dies schlie√üt jedoch die Notwendigkeit einer Abfrageoptimierung nicht aus. <br><br><h4>  Fazit </h4><br>  In diesem Artikel habe ich gezeigt, wie n√ºtzlich eine Tabelle mit einem Spaltenspeicher-Speicherformat sein kann.  Dies spart Speicherplatz und leistungsstarke analytische Abfragen.  Die einfache Arbeit mit der Tabelle reduziert automatisch die Kosten f√ºr die Erstellung eines vollwertigen analytischen Data Warehouse  Seine Verwendung erfordert nicht die Entwicklung komplexer, schwer zu debuggender Algorithmen.  Das Testen wird vereinfacht. <br><br>  Trotz der Tatsache, dass die oben gestellten Experimente Optimismus hervorrufen, wurden viele Probleme nicht gel√∂st.  Beispiel: Welcher Abfrageplan wird generiert, wenn die Columnstore-Tabelle mit anderen Tabellen verkn√ºpft wird.  Ich hoffe, diese Arbeit im n√§chsten Teil fortzusetzen.  Wie viele Teile davon abh√§ngen, wie sich cstore_fdw bei mehr oder weniger realen Daten verh√§lt. <br><br><h4>  Links zu zus√§tzlichen Materialien </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurzer R√ºckblick cstore_fdw</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cstore_fdw auf github</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roadmap cstore_fdw</a> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472396/">https://habr.com/ru/post/de472396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472384/index.html">Ein Blick auf Android-Updates aus Entwicklersicht</a></li>
<li><a href="../de472386/index.html">ZIO & Cats Effect: eine erfolgreiche Allianz</a></li>
<li><a href="../de472388/index.html">Walmart erkl√§rt Amazon Preiskrieg</a></li>
<li><a href="../de472392/index.html">Aufstieg, Fall und m√∂gliche R√ºckkehr von Audiokassetten - wir besch√§ftigen uns mit Mythen und geben einen √úberblick √ºber die Situation</a></li>
<li><a href="../de472394/index.html">Bewertung der Auswirkungen k√ºnstlicher Intelligenz auf Offshore-√ñl und -Gas</a></li>
<li><a href="../de472402/index.html">RTMP-Videoanruf-Streaming</a></li>
<li><a href="../de472404/index.html">2D-Kollisionsberechnung: Gilbert-Johnson-Kirti-Algorithmus</a></li>
<li><a href="../de472406/index.html">Erweitern Sie das Rechenzentrum w√§hrend der Pizza-Lieferung</a></li>
<li><a href="../de472410/index.html">Entwerfen verf√ºgbarer Farbsysteme</a></li>
<li><a href="../de472412/index.html">Systemanalytiker und Produktmetriken - sch√ºtteln, aber nicht mischen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>