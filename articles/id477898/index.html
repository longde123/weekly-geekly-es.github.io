<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ’‡ğŸ½ ğŸ¤¯ Pengantar Pemrograman Berorientasi Konteks Kotlin ğŸ•— ğŸ¤˜ğŸ¼ ğŸ§–ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah terjemahan dari Pengantar pemrograman berorientasi konteks di Kotlin 

 Pada artikel ini saya akan mencoba untuk menggambarkan fenomena bar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Pemrograman Berorientasi Konteks Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/477898/">  <i>Ini adalah terjemahan dari <a href="https://proandroiddev.com/an-introduction-context-oriented-programming-in-kotlin-2e79d316b0a2">Pengantar pemrograman berorientasi konteks di Kotlin</a></i> <br><br>  Pada artikel ini saya akan mencoba untuk menggambarkan fenomena baru yang muncul sebagai produk sampingan dari perkembangan pesat bahasa Kotlin.  Ini adalah pendekatan baru untuk merancang arsitektur aplikasi dan perpustakaan, yang saya sebut pemrograman berorientasi konteks. <br><br><h2>  Beberapa kata tentang izin fungsi </h2><br>  Seperti diketahui, ada tiga paradigma pemrograman utama ( <i>catatan Pedant</i> : ada paradigma lain): <br><br><ul><li>  Pemrograman Prosedural </li><li>  Pemrograman berorientasi objek </li><li>  Pemrograman fungsional </li></ul><a name="habracut"></a><br>  Semua pendekatan ini berfungsi dengan satu atau lain cara.  Mari kita lihat ini dari sudut pandang resolusi fungsi, atau penjadwalan panggilan mereka (artinya pilihan fungsi yang harus digunakan di tempat ini).  Pemrograman prosedural ditandai dengan penggunaan fungsi global dan resolusi statisnya berdasarkan nama fungsi dan tipe argumen.  Tentu saja, jenis hanya dapat digunakan dalam kasus bahasa yang diketik secara statis.  Misalnya, dalam Python, fungsi dipanggil dengan nama, dan jika argumennya tidak benar, pengecualian dilempar ke dalam runtime selama eksekusi program.  Resolusi fungsi dalam bahasa dengan pendekatan prosedural hanya didasarkan pada nama prosedur / fungsi dan parameternya, dan dalam banyak kasus dilakukan secara statis. <br><br>  Gaya pemrograman berorientasi objek membatasi ruang lingkup fungsi.  Fungsinya bukan global, melainkan merupakan bagian dari kelas, dan hanya dapat dipanggil dengan instance kelas yang sesuai ( <i>Catatan Pedant</i> : beberapa bahasa prosedural klasik memiliki sistem modular dan, oleh karena itu, ruang lingkup; bahasa prosedural! = C). <br><br>  Tentu saja, kita selalu dapat mengganti fungsi anggota suatu kelas dengan fungsi global dengan argumen tambahan dari jenis objek yang dipanggil, tetapi dari sudut pandang sintaksis, perbedaannya cukup signifikan.  Misalnya, dalam kasus ini, metode dikelompokkan dalam kelas yang mereka rujuk, dan oleh karena itu lebih jelas terlihat perilaku seperti apa yang disediakan oleh objek jenis ini. <br><br>  Tentu saja, enkapsulasi adalah yang paling penting di sini, karena beberapa bidang dari kelas atau perilakunya dapat bersifat pribadi dan hanya dapat diakses oleh anggota kelas ini (Anda tidak dapat memberikan ini dalam pendekatan yang murni prosedural), dan polimorfisme, berkat metode yang sebenarnya digunakan ditentukan tidak hanya berdasarkan nama. metode, tetapi juga didasarkan pada jenis objek dari mana ia dipanggil.  Mengirim panggilan metode dalam pendekatan berorientasi objek tergantung pada jenis objek yang didefinisikan dalam runtime, nama metode, dan jenis argumen pada tahap kompilasi. <br><br>  Pendekatan fungsional tidak membawa sesuatu yang secara fundamental baru dalam hal resolusi fungsi.  Biasanya, bahasa berorientasi fungsi memiliki aturan yang lebih baik untuk membedakan antara area visibilitas ( <i>catatan pedant</i> : sekali lagi, C tidak semua bahasa prosedural, ada yang di mana area visibilitas dibatasi dengan baik) yang memungkinkan kontrol yang lebih ketat atas visibilitas fungsi berdasarkan sistem. modul, tetapi selain itu, resolusi dilakukan pada waktu kompilasi berdasarkan pada jenis argumen. <br><br><h2>  Apa ini </h2><br>  Dalam hal pendekatan objek, ketika memanggil metode pada objek, kami memiliki argumennya, tetapi selain itu kami memiliki eksplisit (dalam kasus Python) atau parameter implisit yang mewakili instance dari kelas yang dipanggil (selanjutnya semua contoh ditulis dalam Kotlin): <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br>  Kelas dan penutupan bersarang sedikit rumit: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: B{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${this@A}</span></span></span><span class="hljs-string">"</span></span>) } } b.doBSomething() } }</code> </pre> <br>  Dalam hal ini, ada dua implisit <i>ini</i> untuk fungsi <i>doBSomething</i> - satu sesuai dengan instance kelas <i>B</i> , dan yang lainnya muncul dari penutupan instance <i>A.</i>  Hal yang sama terjadi pada kasus penutupan lambda yang jauh lebih umum.  Penting untuk dicatat bahwa ini dalam kasus ini berfungsi tidak hanya sebagai parameter implisit, tetapi juga sebagai ruang lingkup atau konteks untuk semua fungsi dan objek yang disebut dalam lingkup leksikal.  Jadi metode doBSomething sebenarnya memiliki akses ke anggota kelas <i>A</i> , publik atau swasta, serta anggota <i>B</i> itu sendiri. <br><br><h2>  Dan ini Kotlin </h2><br>  Kotlin memberi kita "mainan" yang sama sekali baru - <a href="https://kotlinlang.org/docs/reference/extensions.html">fungsi ekstensi</a> .  ( <i>Catatan oleh Pedant</i> : Sebenarnya, mereka tidak begitu baru, mereka juga ada di C #).  Anda dapat mendefinisikan fungsi seperti <i>A.doASomething</i> () di mana saja dalam program, bukan hanya di dalam <i>A.</i>  Di dalam fungsi ini, kita memiliki parameter implisit <i>ini</i> , yang disebut penerima, menunjuk ke instance <i>A</i> di mana metode ini dipanggil: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">doASomthing</span></span></span></span>(){ println(<span class="hljs-string"><span class="hljs-string">" -   </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() a.doASomthing() }</code> </pre> <br>  Fungsi ekstensi tidak memiliki akses ke anggota pribadi penerima mereka, sehingga enkapsulasi tidak dilanggar. <br><br>  Hal penting berikutnya yang dimiliki Kotlin adalah blok kode dengan penerima.  Anda dapat menjalankan blok kode arbitrer menggunakan sesuatu sebagai penerima: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInternalSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> A.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomthing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() with(a){ doInternalSomething() doASomthing() } }</code> </pre> <br>  Dalam contoh ini, kedua fungsi dapat dipanggil tanpa " <i>a</i> " tambahan <i>.</i> Pada awalnya, karena fungsi with menempatkan semua kode dari blok selanjutnya di dalam konteks a.  Ini berarti bahwa semua fungsi dalam blok ini dipanggil seolah-olah mereka dipanggil pada objek (yang dilewati secara eksplisit) <i>a</i> . <br><br>  Langkah terakhir pada titik ini dalam pemrograman berorientasi konteks adalah kemampuan untuk mendeklarasikan ekstensi sebagai anggota kelas.  Dalam hal ini, fungsi ekstensi didefinisikan di dalam kelas lain, seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> B.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = B() with(a){ b.doBSomething() <span class="hljs-comment"><span class="hljs-comment">//   } b.doBSomething() //   }</span></span></code> </pre> <br>  Adalah penting bahwa di sini <i>B</i> mendapatkan beberapa perilaku baru, tetapi hanya ketika itu berada dalam konteks leksikal tertentu.  Fungsi ekstensi adalah anggota reguler kelas <i>A.</i>  Ini berarti bahwa resolusi fungsi dilakukan secara statis berdasarkan konteks di mana ia dipanggil, tetapi implementasi nyata ditentukan oleh instance <i>A</i> yang dilewatkan sebagai konteks.  Fungsi tersebut bahkan dapat berinteraksi dengan keadaan objek <i>a</i> . <br><br><h2>  Pengiriman Berorientasi Konteks </h2><br>  Pada awal artikel, kami membahas berbagai pendekatan untuk mengirim panggilan fungsi, dan ini dilakukan karena suatu alasan.  Faktanya adalah bahwa fungsi ekstensi di Kotlin memungkinkan Anda untuk bekerja dengan pengiriman dengan cara baru.  Sekarang keputusan tentang fungsi tertentu mana yang harus digunakan didasarkan tidak hanya pada jenis parameternya, tetapi juga pada konteks leksikal panggilannya.  Artinya, ungkapan yang sama dalam konteks yang berbeda dapat memiliki makna yang berbeda.  Tentu saja, tidak ada yang berubah dari sudut pandang implementasi, dan kami masih memiliki objek penerima eksplisit yang mendefinisikan pengiriman untuk metode dan ekstensi yang dijelaskan dalam tubuh kelas itu sendiri (ekstensi anggota) - tetapi dari sudut pandang sintaksis, ini adalah pendekatan yang berbeda . <br><br>  Mari kita lihat bagaimana pendekatan berorientasi konteks berbeda dari pendekatan berorientasi objek klasik, menggunakan masalah klasik operasi aritmatika pada angka di Jawa sebagai contoh.  Kelas <i>Number</i> di Java dan Kotlin adalah induk untuk semua angka, tetapi tidak seperti angka khusus seperti Double, ia tidak mendefinisikan operasi matematisnya.  Jadi Anda tidak bisa menulis, misalnya, seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> n + <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment">//  `plus`     `Number`</span></span></code> </pre><br>  Alasannya di sini adalah bahwa tidak mungkin untuk secara konsisten mendefinisikan operasi aritmatika untuk semua tipe numerik.  Misalnya, pembagian integer berbeda dari divisi floating point.  Dalam beberapa kasus khusus, pengguna tahu jenis operasi apa yang diperlukan, tetapi biasanya tidak masuk akal untuk mendefinisikan hal-hal seperti itu secara global.  Solusi berorientasi objek (dan, pada kenyataannya, fungsional) akan mendefinisikan tipe pewarisan baru dari kelas <i>Number</i> , operasi yang diperlukan di dalamnya, dan menggunakannya di mana diperlukan (di Kotlin 1.3 Anda dapat menggunakan kelas inline).  Sebagai gantinya, mari kita mendefinisikan konteks dengan operasi ini dan menerapkannya secara lokal: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumberOperations</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> DoubleOperations: NumberOperations{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() + other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() - other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() * other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() / other.toDouble() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n1: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n2: Number = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = with(DoubleOperations){ (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> } println(res) }</code> </pre><br>  Dalam contoh ini, perhitungan <i>res</i> dilakukan di dalam konteks yang mendefinisikan operasi tambahan.  Konteks tidak harus didefinisikan secara lokal, melainkan dapat diteruskan secara implisit sebagai penerima fungsi.  Misalnya, Anda dapat melakukan ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> NumberOperations.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = DoubleOperations.calculate(n1, n2)</code> </pre><br>  Ini berarti bahwa logika operasi dalam konteks sepenuhnya terpisah dari implementasi konteks ini, dan dapat ditulis di bagian lain dari program atau bahkan dalam modul lain.  Dalam contoh sederhana ini, suatu konteks adalah singleton tanpa kewarganegaraan, tetapi konteks negara juga dapat digunakan. <br><br>  Perlu juga diingat bahwa konteks dapat disarangkan: <br><br><pre> <code class="kotlin hljs">with(a){ with(b){ doSomething() } }</code> </pre><br>  Ini memberikan efek menggabungkan perilaku kedua kelas, namun, fitur ini sulit untuk dikontrol hari ini karena kurangnya ekstensi dengan beberapa penerima ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ). <br><br><h2>  Kekuatan Coroutines Eksplisit </h2><br>  Salah satu contoh terbaik dari pendekatan berorientasi konteks digunakan di perpustakaan Kotlinx-coroutines.  Penjelasan ide dapat ditemukan dalam sebuah <a href="https://medium.com/%40elizarov/explicit-concurrency-67a8e8fd9b25">artikel oleh</a> Roman Elizarov.  Di sini, saya hanya ingin menekankan bahwa <i>CoroutineScope</i> adalah kasus desain berorientasi konteks dengan konteks stateful.  CoroutineScope memainkan dua peran: <br><br><ul><li>  Ini berisi <i>CoroutineContext</i> , yang diperlukan untuk menjalankan coroutine dan diwariskan ketika coroutine baru diluncurkan. </li><li>  Ini berisi keadaan coroutine induk, yang memungkinkan Anda untuk membatalkannya jika coroutine yang dihasilkan melempar kesalahan. </li></ul><br>  Juga, konkurensi terstruktur memberikan contoh yang bagus dari arsitektur berorientasi konteks: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> CoroutineScope.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} GlobalScope.launch{ launch{ delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) doSomeWork() } }</code> </pre><br>  Di sini, <i>doSomeWork</i> adalah fungsi konteks, tetapi didefinisikan di luar konteksnya.  Metode <i>peluncuran</i> membuat dua konteks bersarang yang setara dengan area leksikal dari fungsi yang sesuai (dalam hal ini, kedua konteks memiliki tipe yang sama, sehingga konteks dalam mengaburkan yang luar).  Titik awal yang baik untuk mempelajari coroutine Kotlin adalah panduan resmi. <br><br><h2>  DSL </h2><br>  Ada kelas tugas yang luas untuk Kotlin, yang biasanya disebut sebagai tugas membangun DSL (Domain Specific Language).  Dalam hal ini, DSL dipahami sebagai beberapa kode yang menyediakan pembangun yang ramah pengguna dari beberapa jenis struktur yang kompleks.  Bahkan, penggunaan istilah DSL tidak sepenuhnya benar di sini, seperti  dalam kasus seperti itu, sintaksis dasar Kotlin hanya digunakan tanpa trik khusus - tetapi mari kita masih menggunakan istilah umum ini. <br><br>  Pembuat DSL berorientasi konteks dalam banyak kasus.  Misalnya, jika Anda ingin membuat elemen HTML, Anda harus terlebih dahulu memeriksa apakah elemen khusus ini dapat ditambahkan ke tempat ini.  Perpustakaan <a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html melakukan</a> ini dengan memberikan ekstensi kelas berbasis konteks yang mewakili tag tertentu.  Bahkan, seluruh pustaka terdiri dari ekstensi konteks untuk elemen DOM yang ada. <br><br>  Contoh lain adalah <a href="https://github.com/edvin/tornadofx">pembangun GUI TornadoFX</a> .  Seluruh pembangun grafik adegan diatur sebagai urutan pembangun konteks bersarang, di mana balok bagian dalam bertanggung jawab untuk membangun anak-anak untuk blok luar atau menyesuaikan parameter orang tua.  Ini adalah contoh dari dokumentasi resmi: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> root = gridPane{ tabpane { gridpaneConstraints { vhGrow = Priority.ALWAYS } tab(<span class="hljs-string"><span class="hljs-string">"Report"</span></span>, HBox()) { label(<span class="hljs-string"><span class="hljs-string">"Report goes here"</span></span>) } tab(<span class="hljs-string"><span class="hljs-string">"Data"</span></span>, GridPane()) { tableview&lt;Person&gt; { items = persons column(<span class="hljs-string"><span class="hljs-string">"ID"</span></span>, Person::idProperty) column(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, Person::nameProperty) column(<span class="hljs-string"><span class="hljs-string">"Birthday"</span></span>, Person::birthdayProperty) column(<span class="hljs-string"><span class="hljs-string">"Age"</span></span>, Person::ageProperty).cellFormat { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>) { style = <span class="hljs-string"><span class="hljs-string">"-fx-background-color:#8b0000; -fx-text-fill:white"</span></span> text = it.toString() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { text = it.toString() } } } } } }</code> </pre><br>  Dalam contoh ini, wilayah leksikal mendefinisikan konteksnya (yang logis, karena mewakili bagian GUI dan struktur internalnya), dan memiliki akses ke konteks induk. <br><br><h2>  Apa selanjutnya: banyak penerima </h2><br>  Pemrograman berorientasi konteks memberi pengembang Kotlin banyak alat dan membuka cara baru merancang arsitektur aplikasi.  Apakah kita membutuhkan yang lain?  Mungkin ya. <br><br>  Saat ini, pengembangan dalam pendekatan kontekstual dibatasi oleh fakta bahwa Anda perlu mendefinisikan ekstensi untuk mendapatkan semacam perilaku kelas yang terbatas konteks.  Ini bagus untuk kelas kustom, tetapi bagaimana jika kita menginginkan hal yang sama untuk kelas dari perpustakaan?  Atau jika kita ingin membuat ekstensi untuk perilaku yang sudah terbatas cakupannya (misalnya, tambahkan beberapa jenis ekstensi di dalam CoroutineScope)?  Kotlin saat ini tidak mengizinkan fungsi ekstensi memiliki lebih dari satu penerima.  Tetapi beberapa penerima dapat ditambahkan ke bahasa tanpa melanggar kompatibilitas ke belakang.  Kemungkinan menggunakan beberapa penerima saat ini sedang dibahas ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ) dan akan dikeluarkan sebagai permintaan <a href="https://github.com/Kotlin/KEEP">KEEP</a> (UPD: <a href="https://github.com/Kotlin/KEEP/pull/176">sudah dikeluarkan</a> ).  Masalahnya (atau mungkin sebuah chip) dari konteks bersarang adalah bahwa mereka memungkinkan Anda untuk menutupi sebagian besar, jika tidak semua, opsi untuk menggunakan kelas <a href="https://github.com/Kotlin/KEEP/pull/87">tipe</a> ( <a href="https://github.com/Kotlin/KEEP/pull/87">tipe-kelas</a> ), yang sangat diinginkan dari fitur yang diusulkan.  Agak tidak mungkin kedua fitur ini akan diimplementasikan dalam bahasa pada saat yang sama. <br><br><h2>  Selain itu </h2><br>  Kami ingin berterima kasih kepada Pedant dan kekasih Haskell penuh-waktu kami <a href="https://research.jetbrains.org/researchers/shimuuar">Alexei Khudyakov</a> atas komentarnya pada teks artikel dan amandemen penggunaan istilah yang agak bebas.  Saya juga berterima kasih kepada Ilya Ryzhenkov untuk komentar yang berharga dan mengoreksi artikel versi bahasa Inggris. <br><br>  Penulis artikel asli: <a href="https://research.jetbrains.org/researchers/altavir">Alexander Nozik</a> , Wakil Kepala <a href="https://research.jetbrains.org/groups/npm">Laboratorium Metode Eksperimen Fisika Nuklir</a> di <a href="https://research.jetbrains.org/">Penelitian JetBrains</a> . <br><br>  Diterjemahkan oleh: <a href="https://research.jetbrains.org/researchers/pklimai">Petr Klimay</a> , Peneliti <a href="https://research.jetbrains.org/groups/npm">di Laboratorium Metode Percobaan Fisika Nuklir</a> di <a href="https://research.jetbrains.org/">Penelitian JetBrains</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477898/">https://habr.com/ru/post/id477898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477876/index.html">CDN Dinamis untuk Streaming WebRTC Latensi Rendah dengan Transkoding</a></li>
<li><a href="../id477878/index.html">Bagaimana permainan kompetitif membantu Anda bekerja lebih baik</a></li>
<li><a href="../id477892/index.html">DevOps: Hasil 2019 dan Prediksi Selanjutnya dari Komunitas DevOps</a></li>
<li><a href="../id477894/index.html">kerja & dev menyenangkan (damentals) # 0. Apa yang diharapkan dan bagaimana membantu menumbuhkan pengembang peserta pelatihan menjadi junior yang percaya diri?</a></li>
<li><a href="../id477896/index.html">Pilih segmen anggaran headphone in-ear kabel</a></li>
<li><a href="../id477900/index.html">Bilangan prima - seberapa hebat ketidakberdayaan kita?</a></li>
<li><a href="../id477902/index.html">DSL Universal. Apakah ini mungkin?</a></li>
<li><a href="../id477904/index.html">Secara terprogram mencari kode umum dengan oEmbed</a></li>
<li><a href="../id477906/index.html">Slurm: diskon 50% untuk kursus online Black Friday</a></li>
<li><a href="../id477908/index.html">Puppetry 3: pengujian otomatis tanpa satu baris kode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>