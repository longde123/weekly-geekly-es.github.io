<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèΩ üò≤ üéª Buildbot: kisah dengan contoh-contoh sistem integrasi berkelanjutan lainnya ü§üüèΩ ü§µüèΩ üîü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(gambar dari situs resmi ) 

 Buildbot, seperti namanya, adalah sistem integrasi berkelanjutan (ci). Sudah ada beberapa artikel tentang dia di Habr√©, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildbot: kisah dengan contoh-contoh sistem integrasi berkelanjutan lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439096/"><img src="https://habrastorage.org/webt/so/qs/u1/soqsu1skae_0xuktzdemfv-n3yq.png"><br>  <i><font color="#aaaaaa">(gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs resmi</a> )</font></i> <br><br>  Buildbot, seperti namanya, adalah sistem integrasi berkelanjutan (ci).  Sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang dia di Habr√©, tetapi, dari sudut pandang saya, kelebihan alat ini tidak begitu jelas dari mereka.  Selain itu, mereka hampir tidak memiliki contoh, yang membuatnya sulit untuk melihat kekuatan penuh dari program ini.  Dalam artikel saya, saya akan mencoba untuk menebus kekurangan ini, berbicara tentang perangkat internal Buildbot'a dan memberikan contoh beberapa skrip non-standar. <br><a name="habracut"></a><br><h3>  Kata-kata umum </h3><br>  Saat ini, ada sejumlah besar sistem integrasi berkelanjutan, dan ketika datang ke salah satu dari mereka, pertanyaan yang cukup logis muncul dalam semangat "Mengapa ini diperlukan jika Anda sudah memiliki &lt;program_name&gt; dan semua orang menggunakannya?"  Saya akan mencoba menjawab pertanyaan seperti itu tentang Buildbot.  Beberapa informasi akan digandakan dengan artikel yang ada, beberapa dijelaskan dalam dokumentasi resmi, tetapi ini diperlukan untuk konsistensi narasi. <br><br>  Perbedaan utama dari sistem integrasi berkelanjutan lainnya adalah bahwa Buildbot adalah kerangka kerja Python untuk menulis ci, dan bukan solusi di luar kotak.  Ini berarti bahwa untuk menghubungkan proyek ke Buildbot, Anda harus terlebih dahulu menulis program python terpisah menggunakan kerangka kerja Buildbot yang mengimplementasikan fungsi integrasi berkelanjutan yang dibutuhkan proyek Anda.  Pendekatan ini memberikan fleksibilitas luar biasa, memungkinkan Anda untuk menerapkan skenario pengujian rumit yang tidak mungkin untuk solusi out-of-box karena keterbatasan arsitektur. <br><br>  Lebih jauh, Buildbot bukan layanan, dan karena itu Anda harus secara jujur ‚Äã‚Äãmenyebarkannya di infrastruktur Anda.  Di sini saya perhatikan bahwa kerangka kerjanya sangat loyal terhadap sumber daya sistem.  Ini tentu saja bukan C atau C ++, tetapi python menang melawan pesaing Java-nya.  Di sini, misalnya, membandingkan konsumsi memori dengan GoCD (dan ya, terlepas dari namanya, ini adalah sistem Java): <br><br>  Buildbot: <br><br><img src="https://habrastorage.org/webt/q1/tg/wu/q1tgwuy-ef8bl6au-s7lc07da-c.png"><br><br>  GoCD: <br><br><img src="https://habrastorage.org/webt/lg/ci/bk/lgcibk9si78bjzf_gfqrgktcgug.png"><br><br>  Menyebarkan dan menulis sendiri program uji terpisah dapat membuat Anda sedih karena memikirkan pengaturan awal.  Namun, skrip sangat disederhanakan oleh banyaknya kelas built-in.  Kelas-kelas ini mencakup banyak operasi standar, apakah itu mendapatkan perubahan dari repositori github atau membangun proyek dengan CMake.  Akibatnya, skrip standar untuk proyek kecil tidak akan lebih rumit daripada file YML untuk beberapa travis-ci.  Saya tidak akan menulis tentang penyebaran, ini dibahas secara rinci dalam artikel yang ada dan tidak ada yang rumit di sana. <br><br>  Fitur berikutnya dari Buildbot, saya perhatikan bahwa secara default logika pengujian diimplementasikan di sisi ci-server.  Ini bertentangan dengan pendekatan "pipeline as a code" yang sekarang populer, di mana logika pengujian dijelaskan dalam file (seperti .travis.yml) yang terletak di repositori bersama dengan kode sumber proyek, dan server ci hanya membaca file ini dan mengeksekusi apa yang dikatakannya.  Sekali lagi, ini hanya perilaku default.  Kemampuan kerangka Buildbot memungkinkan Anda untuk menerapkan pendekatan yang dijelaskan dengan menyimpan skrip uji di repositori.  Bahkan ada solusi siap pakai - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bb-travis</a> , yang mencoba mengambil yang terbaik dari Buildbot dan travis-ci.  Selain itu, nanti dalam artikel ini saya akan menjelaskan cara menerapkan sesuatu yang mirip dengan perilaku ini sendiri. <br><br>  Buildbot secara default mengumpulkan setiap komit saat mendorong.  Ini mungkin tampak seperti beberapa fitur kecil yang tidak perlu, tetapi bagi saya itu, sebaliknya, telah menjadi salah satu keunggulan utama.  Banyak solusi populer di luar kotak (travis-ci, gitlab-ci) tidak memberikan kesempatan seperti itu sama sekali, hanya bekerja dengan komit terakhir di cabang.  Bayangkan bahwa selama pengembangan Anda sering harus memilih komitmen.  Akan tidak menyenangkan untuk mengambil komit yang tidak berfungsi, yang tidak diperiksa oleh sistem build karena fakta bahwa diluncurkan bersama dengan banyak commit dari atas.  Tentu saja, di Buildbot Anda hanya dapat membangun komit terakhir, dan ini dilakukan dengan menetapkan hanya satu parameter. <br><br>  Kerangka kerja ini memiliki dokumentasi yang cukup baik, yang menjelaskan semuanya secara terperinci, mulai dari arsitektur umum hingga pedoman untuk memperluas kelas bawaan.  Namun, bahkan dengan dokumentasi semacam itu, Anda mungkin harus melihat beberapa hal dalam kode sumber.  Ini sepenuhnya terbuka di bawah lisensi GPL v2 dan mudah dibaca.  Dari minus - dokumentasi hanya tersedia dalam bahasa Inggris, dalam bahasa Rusia ada sangat sedikit informasi di jaringan.  Alat itu tidak muncul kemarin, dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wireshark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> proyek terkenal lainnya dirakit.  Pembaruan keluar, proyek ini didukung oleh banyak pengembang, sehingga kami dapat berbicara tentang keandalan dan stabilitas. <br><br><img src="https://habrastorage.org/webt/22/we/zg/22wezgyvqnccjmk2sl_ehs954bg.png"><br>  <i><font color="#aaaaaa">(Beranda Python Buildbot)</font></i> <br><br><h3>  Theormin </h3><br>  Bagian ini pada dasarnya adalah terjemahan bebas dari bab dokumentasi resmi tentang arsitektur kerangka kerja.  Ini menunjukkan rangkaian tindakan lengkap dari menerima perubahan oleh sistem-ci hingga mengirim pemberitahuan hasil kepada pengguna.  Jadi, Anda membuat perubahan pada kode sumber proyek dan mengirimkannya ke repositori jarak jauh.  Apa yang terjadi selanjutnya secara skematis ditunjukkan pada gambar: <br><br><img src="https://habrastorage.org/webt/hq/ue/na/hquenaedpe7hdlulfnmctiew2b8.png"><br>  <i><font color="#aaaaaa">(gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> )</font></i> <br><br>  Pertama-tama, Buildbot entah bagaimana harus mengetahui bahwa ada perubahan dalam repositori.  Ada dua cara utama - webhooks dan polling, meskipun tidak ada yang melarang datang dengan sesuatu yang lebih canggih.  Dalam kasus pertama, di Buildbot, kelas-kelas turunan BaseHookHandler bertanggung jawab untuk ini.  Ada banyak solusi siap pakai, misalnya, <i>GitHubHandler</i> atau <i>GitoriusHandler</i> .  Metode kunci di kelas-kelas ini adalah <b>getChanges ()</b> .  Logikanya sangat sederhana: harus mengubah permintaan HTTP menjadi daftar objek perubahan. <br><br>  Untuk kasus kedua, Anda memerlukan <i>kelas</i> turunan <i>PollingChangeSource</i> .  Sekali lagi, ada solusi siap pakai, seperti <i>GitPoller</i> atau <i>HgPoller</i> .  Metode kuncinya adalah <b>polling ()</b> .  Itu disebut dengan frekuensi tertentu dan entah bagaimana harus membuat daftar perubahan dalam repositori.  Dalam kasus git, ini bisa menjadi panggilan untuk mengambil git dan perbandingan dengan keadaan tersimpan sebelumnya.  Jika kemampuan bawaan tidak cukup, maka cukup buat kelas pewaris Anda sendiri dan kelebihan metode.  Contoh menggunakan polling: <br><br><pre><code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'change_source'</span></span>] = [changes.GitPoller( repourl = <span class="hljs-string"><span class="hljs-string">'git@git.example.com:project'</span></span>, project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>, branches = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-comment"><span class="hljs-comment">#      pollInterval = 60 )]</span></span></code> </pre> <br>  Webhook bahkan lebih mudah digunakan, yang utama adalah jangan lupa untuk mengkonfigurasinya di sisi server git.  Ini hanya satu baris dalam file konfigurasi: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'github'</span></span>: {} }</code> </pre> <br>  Langkah selanjutnya, objek perubahan adalah input ke objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scheduler</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjadwal</a> ).  Contoh penjadwal <i>bawaan</i> : <i>AnyBranchScheduler</i> , <i>NightlyScheduler</i> , <i>ForceScheduler</i> , dll.  Setiap penjadwal menerima semua objek perubahan sebagai input, tetapi hanya memilih yang lulus filter.  Filter dilewatkan ke penjadwal di konstruktor melalui argumen <i>change_filter</i> .  Pada output, perencana membuat permintaan build.  Penjadwal memilih pembangun berdasarkan argumen pembangun. <br><br>  Beberapa perencana memiliki argumen rumit yang disebut <i>treeStableTimer</i> .  Ini berfungsi sebagai berikut: ketika perubahan diterima, scheduler tidak segera membuat permintaan build baru, tetapi memulai timer.  Jika perubahan baru tiba dan timer belum kedaluwarsa, maka perubahan lama diganti dengan yang baru, dan timer diperbarui.  Saat penghitung waktu berakhir, penjadwal hanya membuat satu permintaan build dari perubahan yang disimpan terakhir. <br><br>  Dengan demikian, logika menyusun hanya komit terakhir ketika mendorong diterapkan.  Contoh konfigurasi penjadwal: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'My Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>] )]</code> </pre> <br>  Bangun permintaan, betapapun anehnya kedengarannya, pergi ke input pembangun.  Tugas pengumpul adalah menjalankan perakitan pada ‚Äúpekerja‚Äù yang dapat diakses.  Worker adalah lingkungan build, seperti stretch64 atau ubuntu1804x64.  Daftar pekerja dilewatkan melalui argumen <i>pekerja</i> .  Semua pekerja dalam daftar harus sama (mis. Nama-nama secara alami berbeda, tetapi lingkungan di dalamnya sama), karena pengumpul bebas memilih salah satu yang tersedia.  Menetapkan banyak nilai di sini berfungsi untuk menyeimbangkan beban, dan bukan untuk membangun di lingkungan yang berbeda.  Menggunakan argumen <i>faktor</i> y, kolektor menerima urutan langkah-langkah untuk membangun proyek.  Saya akan menulis tentang ini secara rinci di bawah ini. <br><br>  Contoh mengkonfigurasi kolektor: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = factory )]</code> </pre> <br>  Jadi, proyeknya sudah siap.  Langkah terakhir Buildbot adalah memberi tahu build.  Kelas reporter bertanggung jawab untuk ini.  Contoh klasik adalah kelas <i>MailNotifier</i> , yang mengirim email dengan hasil build.  <i>Contoh</i> Koneksi <i>MailNotifier</i> : <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'services'</span></span>] = [reporters.MailNotifier( fromaddr = <span class="hljs-string"><span class="hljs-string">'buildbot@example.com'</span></span>, relayhost = <span class="hljs-string"><span class="hljs-string">'mail.example.com'</span></span>, smtpPort = <span class="hljs-number"><span class="hljs-number">25</span></span>, extraRecipients = [<span class="hljs-string"><span class="hljs-string">'devel@example.com'</span></span>], sendToInterestedUsers = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> )]</code> </pre> <br>  Nah, sekarang saatnya untuk beralih ke contoh lengkap.  Saya perhatikan bahwa Buildbot sendiri ditulis menggunakan kerangka Twisted, dan oleh karena itu keakraban dengannya akan sangat memudahkan penulisan dan pemahaman skrip Buildbot.  Kami akan memiliki anak lelaki pencambuk untuk proyek yang disebut Proyek Pet.  Biarkan ditulis dalam C ++, dirakit menggunakan CMake, dan kode sumbernya terletak di repositori git.  Kami tidak terlalu malas dan menulis tes untuknya yang dijalankan oleh tim ctest.  Baru-baru ini, kami membaca artikel ini dan menyadari bahwa kami ingin menerapkan pengetahuan yang baru diperoleh untuk proyek kami. <br><br><h3>  Contoh satu: agar bisa berfungsi </h3><br>  Sebenarnya, file konfigurasi: <br><br><div class="spoiler">  <b class="spoiler_title">100 baris kode python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> buildbot.plugins <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># shortcut c = BuildmasterConfig = {} # create workers c['workers'] = [worker.Worker('stretch32', 'example_password')] # general settings c['title'] = 'Buildbot: test' c['titleURL'] = 'https://buildbot.example.com/' c['buildbotURL'] = 'https://buildbot.example.com/' # setup database c['db'] = { 'db_url': 'sqlite:///state.sqlite' } # port to communicate with workers c['protocols'] = { 'pb': { 'port': 9989 } } # make buildbot developers a little bit happier c['buildbotNetUsageData'] = 'basic' # webserver setup c['www'] = dict(plugins = dict(waterfall_view={}, console_view={}, grid_view={})) c['www']['authz'] = util.Authz( allowRules = [util.AnyEndpointMatcher(role = 'admins')], roleMatchers = [util.RolesFromUsername(roles = ['admins'], usernames = ['root'])] ) c['www']['auth'] = util.UserPasswordAuth([('root', 'root_password')]) # mail notification c['services'] = [reporters.MailNotifier( fromaddr = 'buildbot@example.com', relayhost = 'mail.example.com', smtpPort = 25, extraRecipients = ['devel@example.com'], sendToInterestedUsers = False )] c['change_source'] = [changes.GitPoller( repourl = 'git@git.example.com:pet-project', project = 'Pet Project', branches = True, pollInterval = 60 )] c['schedulers'] = [schedulers.AnyBranchScheduler( name = 'Pet Project Scheduler', treeStableTimer = None, change_filter = util.ChangeFilter(project = 'Pet Project'), builderNames = ['Pet Project Builder'] )] factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property('repository'), workdir = 'sources', haltOnFailure = True, submodules = True, progress = True) ) factory.addStep(steps.ShellSequence( name = 'create builddir', haltOnFailure = True, hideStepIf = lambda results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = ['rm', '-rf', 'build']), util.ShellArg(command = ['mkdir', 'build']) ]) ) factory.addStep(steps.CMake( workdir = 'build', path = '../sources', haltOnFailure = True) ) factory.addStep(steps.Compile( name = 'build project', workdir = 'build', haltOnFailure = True, warnOnWarnings = True, command = ['make']) ) factory.addStep(steps.ShellCommand( name = 'run tests', workdir = 'build', haltOnFailure = True, command = ['ctest']) ) c['builders'] = [util.BuilderConfig( name = 'Pet Project Builder', workernames = ['stretch32'], factory = factory )]</span></span></code> </pre> <br></div></div><br>  Dengan menulis baris-baris ini kita mendapatkan perakitan otomatis ketika mendorong ke repositori, wajah web yang indah, pemberitahuan email, dan atribut lain dari ci apa pun yang menghargai diri sendiri.  Sebagian besar harus jelas: pengaturan penjadwal, pengumpul, dan objek lain dibuat mirip dengan contoh yang diberikan sebelumnya, nilai sebagian besar parameter bersifat intuitif.  Secara terperinci, saya akan fokus hanya pada menciptakan pabrik, yang saya janjikan sebelumnya. <br><br>  Pabrik terdiri dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langkah</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langkah pembangunan</a> yang harus diselesaikan Buildbot untuk proyek tersebut.  Seperti halnya kelas-kelas lain, ada banyak solusi siap pakai.  Pabrik kami terdiri dari lima langkah.  Sebagai aturan, langkah pertama adalah mendapatkan kondisi repositori saat ini, dan di sini kita tidak akan membuat pengecualian.  Untuk melakukan ini, kami menggunakan kelas standar <i>Git</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Langkah pertama</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Selanjutnya, kita perlu membuat direktori tempat proyek akan dirakit - kita akan membuat penuh dari membangun sumber.  Sebelum ini, Anda harus ingat untuk menghapus direktori jika sudah ada.  Jadi, kita perlu menjalankan dua perintah.  Kelas <i>ShellSequence</i> akan membantu kami dalam hal ini: <br><br><div class="spoiler">  <b class="spoiler_title">Langkah kedua</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellSequence( name = <span class="hljs-string"><span class="hljs-string">'create builddir'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'rm'</span></span>, <span class="hljs-string"><span class="hljs-string">'-rf'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]), util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'mkdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]) ]) )</code> </pre> <br></div></div><br>  Sekarang Anda harus memulai CMake.  Untuk melakukan ini, logis untuk menggunakan salah satu dari dua kelas - <i>ShellCommand</i> atau <i>CMake</i> .  Kami akan menggunakan yang terakhir, tetapi perbedaannya minimal: ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembungkus sederhana di</a> atas kelas pertama, membuatnya sedikit lebih nyaman untuk menyampaikan argumen yang spesifik ke CMake. <br><br><div class="spoiler">  <b class="spoiler_title">Langkah ketiga</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.CMake( workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'../sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Saatnya menyusun proyek.  Seperti pada kasus sebelumnya, Anda dapat menggunakan <i>ShellCommand</i> .  Demikian pula, ada kelas <i>Kompilasi</i> , yang merupakan pembungkus di atas <i>ShellCommand</i> .  Namun demikian, ini adalah pembungkus yang lebih rumit: kelas <i>Compile</i> memonitor peringatan selama kompilasi dan secara akurat menampilkannya dalam log terpisah.  Itu sebabnya kita akan menggunakan kelas <i>Compile</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Langkah keempat</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.Compile( name = <span class="hljs-string"><span class="hljs-string">'build project'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'make'</span></span>]) )</code> </pre> <br></div></div><br>  Akhirnya, jalankan tes kami.  Di sini kita akan menggunakan kelas <i>ShellCommand yang</i> disebutkan sebelumnya: <br><br><div class="spoiler">  <b class="spoiler_title">Langkah kelima</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellCommand( name = <span class="hljs-string"><span class="hljs-string">'run tests'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'ctest'</span></span>]) )</code> </pre> <br></div></div><br><h3>  Contoh dua: pipeline sebagai kode </h3><br>  Di sini saya akan menunjukkan bagaimana menerapkan opsi anggaran untuk menyimpan logika pengujian bersama dengan kode sumber proyek, dan tidak dalam file konfigurasi ci-server.  Untuk melakukan ini, letakkan file <i>.buildbot</i> dalam repositori dengan kode, di mana setiap baris terdiri dari kata-kata, yang pertama ditafsirkan sebagai direktori untuk perintah yang akan dieksekusi, dan sisanya sebagai perintah dengan argumennya.  Untuk Proyek Kesayangan kami, file <i>.buildbot</i> akan terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">File .Buildbot dengan perintah</b> <div class="spoiler_text"> <code>. rm -rf build <br> . mkdir build <br> build cmake ../sources <br> build make <br> build ctest</code> <br> </div></div><br>  Sekarang kita perlu memodifikasi file konfigurasi Buildbot.  Untuk menganalisis file <i>.buildbot</i> , kita harus menulis kelas langkah kita sendiri.  Langkah ini akan membaca file <i>.buildbot</i> , setelah itu untuk setiap baris tambahkan langkah <i>ShellCommand</i> dengan argumen yang diperlukan.  Untuk menambahkan langkah-langkah secara dinamis, kita akan menggunakan metode <b>build.addStepsAfterCurrentStep ()</b> .  Sama sekali tidak menakutkan: <br><br><div class="spoiler">  <b class="spoiler_title">Analisis KelasLangkah</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.stdio_log = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.addLog(<span class="hljs-string"><span class="hljs-string">'stdio'</span></span>) cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue(util.FAILURE) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cmd.stdout.splitlines(): lst = row.split() dirname = lst.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>) results.append(steps.ShellCommand( name = lst[<span class="hljs-number"><span class="hljs-number">0</span></span>], command = lst, workdir = dirname ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</code> </pre> <br></div></div><br>  Berkat pendekatan ini, pabrik untuk pengumpul menjadi lebih sederhana dan lebih fleksibel: <br><br><div class="spoiler">  <b class="spoiler_title">Pabrik untuk menganalisis file .buildbot</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) )</code> </pre> <br></div></div><br><h3>  Contoh tiga: pekerja sebagai kode </h3><br>  Sekarang bayangkan di sebelah kode proyek, kita perlu menentukan bukan urutan perintah, tetapi lingkungan untuk perakitan.  Bahkan, kami mendefinisikan pekerja.  <i>File .buildbot</i> mungkin terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">File lingkungan .Buildbot</b> <div class="spoiler_text"> <code>{ <br> "workers": ["stretch32", "wheezy32"] <br> }</code> <br> </div></div><br>  File konfigurasi Buildbot dalam kasus ini akan menjadi lebih rumit, karena kami ingin rakitan pada lingkungan yang berbeda saling berhubungan (jika setidaknya satu lingkungan gagal, seluruh komit dianggap tidak beroperasi).  Dua tingkat membantu kami memecahkan masalah.  Kami akan memiliki pekerja lokal yang mem-parsing file <i>.buildbot</i> dan menjalankan build berdasarkan pekerja yang diinginkan.  Pertama, seperti pada contoh sebelumnya, kita akan menulis langkah kita untuk menganalisis file <i>.buildbot</i> .  Untuk memulai perakitan pada pekerja tertentu, satu bundel dari langkah <i>Trigger</i> dan jenis khusus dari penjadwal <i>TriggerableScheduler digunakan</i> .  Langkah kami menjadi sedikit lebih rumit, tetapi cukup mudah dipahami: <br><br><div class="spoiler">  <b class="spoiler_title">Analisis KelasLangkah</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getWorkerList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue([]) <span class="hljs-comment"><span class="hljs-comment"># parse JSON try: payload = json.loads(cmd.stdout) workers = payload.get('workers', []) except json.decoder.JSONDecodeError as e: raise ValueError('Error loading JSON from .buildbot file: {}' .format(str(e))) defer.returnValue(workers) @defer.inlineCallbacks def run(self): self.stdio_log = yield self.addLog('stdio') try: workers = yield self._getWorkerList() except ValueError as e: yield self.stdio_log.addStdout(str(e)) defer.returnValue(util.FAILURE) results = [] for worker in workers: results.append(steps.Trigger( name = 'check on worker "{}"'.format(worker), schedulerNames = ['Pet Project ({}) Scheduler'.format(worker)], waitForFinish = True, haltOnFailure = True, warnOnWarnings = True, updateSourceStamp = False, alwaysUseLatest = False ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</span></span></code> </pre> <br></div></div><br>  Kami akan menggunakan langkah ini pada pekerja lokal.  Harap perhatikan bahwa kami telah menyetel tag ke kolektor kami, "Pet Project Builder".  Dengan itu, kita dapat memfilter <i>MailNotifier</i> , dengan mengatakan bahwa surat harus dikirim hanya ke kolektor tertentu.  Jika pemfilteran ini tidak dilakukan, maka saat membangun komit di dua lingkungan, kami akan menerima tiga huruf. <br><br><div class="spoiler">  <b class="spoiler_title">Kolektor umum</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'generic_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = factory )]</code> </pre> <br></div></div><br>  Tetap bagi kami untuk menambah kolektor dan Penjadwal Terpicu yang sama untuk semua pekerja nyata kami: <br><br><div class="spoiler">  <b class="spoiler_title">Kolektor di lingkungan yang tepat</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allWorkers: c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Scheduler'</span></span>.format(worker), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker)]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker), workernames = [worker], factory = specific_factory) )</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/iq/_n/n4/iq_nn4nhvj07vcina32c2244o6a.png"><br>  <i><font color="#aaaaaa">(buat halaman proyek kami di dua lingkungan)</font></i> <br><br><h3>  Contoh Empat: satu huruf per beberapa komitmen </h3><br>  Jika Anda menggunakan salah satu contoh di atas, Anda dapat melihat satu fitur yang tidak menyenangkan.  Karena satu huruf dibuat untuk setiap komit, ketika kami mendorong cabang dengan 20 komit baru, kami akan menerima 20 surat.  Menghindari ini, seperti dalam contoh sebelumnya, kami akan membantu dua tingkat.  Kita juga perlu memodifikasi kelas untuk mendapatkan perubahan.  Alih-alih membuat banyak objek perubahan, kami hanya akan membuat satu objek seperti itu, di properti di mana daftar semua komit ditransmisikan.  Tergesa-gesa, ini bisa dilakukan seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Kelas MultiGitHubHandler</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiGitHubHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(GitHubHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> new_changes = GitHubHandler.getChanges(self, request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_changes: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) change = new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>] change[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] = <span class="hljs-string"><span class="hljs-string">'{}..{}'</span></span>.format( new_changes[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>], new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>]) commits = [c[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_changes] change[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>][<span class="hljs-string"><span class="hljs-string">'commits'</span></span>] = commits <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([change], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-string"><span class="hljs-string">'custom_class'</span></span>: MultiGitHubHandler } }</code> </pre> <br></div></div><br>  Untuk bekerja dengan objek perubahan yang tidak biasa, kita membutuhkan langkah khusus kita sendiri, yang secara dinamis membuat langkah-langkah yang mengumpulkan komit tertentu: <br><br><div class="spoiler">  <b class="spoiler_title">Kelas GenerateCommitSteps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateCommitSteps</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> commits = self.getProperty(<span class="hljs-string"><span class="hljs-string">'commits'</span></span>) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> commits: results.append(steps.Trigger( name = <span class="hljs-string"><span class="hljs-string">'Checking commit {}'</span></span>.format(commit), schedulerNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>], waitForFinish = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, sourceStamp = { <span class="hljs-string"><span class="hljs-string">'branch'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'branch'</span></span>), <span class="hljs-string"><span class="hljs-string">'revision'</span></span>: commit, <span class="hljs-string"><span class="hljs-string">'codebase'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'codebase'</span></span>), <span class="hljs-string"><span class="hljs-string">'repository'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), <span class="hljs-string"><span class="hljs-string">'project'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'project'</span></span>) } ) ) self.build.addStepsAfterCurrentStep(results) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> util.SUCCESS</code> </pre> <br></div></div><br>  Tambahkan kolektor umum kami, yang hanya terlibat dalam menjalankan rakitan komit individual.  Itu harus ditandai untuk kemudian memfilter pengiriman surat dengan tag ini sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Pengambil Surat Umum</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'Pet Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>] )] branches_factory = util.BuildFactory() branches_factory.addStep(GenerateCommitSteps( name = <span class="hljs-string"><span class="hljs-string">'Generate commit steps'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'branch_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = branches_factory )]</code> </pre> <br></div></div><br>  Tetap menambahkan hanya kolektor untuk komitmen individu.  Kami hanya tidak memberi tag pada kolektor ini dengan tag, dan karenanya surat tidak akan dibuat untuk itu. <br><br><div class="spoiler">  <b class="spoiler_title">Pengambil Surat Umum</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>, builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = specific_factory) )</code> </pre> <br></div></div><br><h3>  Kata-kata terakhir </h3><br>  Artikel ini sama sekali tidak menggantikan membaca dokumentasi resmi, jadi jika Anda tertarik pada Buildbot, maka langkah Anda selanjutnya adalah membacanya.  Versi lengkap dari file konfigurasi semua contoh tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Tautan terkait, dari mana sebagian besar bahan untuk artikel diambil: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber proyek</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439096/">https://habr.com/ru/post/id439096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439080/index.html">RabbitMQ yang tidak jelas di Yii2 atau mengapa RabbitMQ menulis ke semua antrian sekaligus</a></li>
<li><a href="../id439082/index.html">Wish Factory Walk</a></li>
<li><a href="../id439086/index.html">Penyebab PPA dan cara menghindarinya</a></li>
<li><a href="../id439090/index.html">IBM 5150. Di mana monopoli dimulai</a></li>
<li><a href="../id439094/index.html">Para ilmuwan telah menemukan vertebrata tertua yang masih hidup di Bumi</a></li>
<li><a href="../id439098/index.html">Sasha Memus, Chatfuel: Bagaimana membangun karier dalam produk setelah berkonsultasi, apakah berbahaya untuk bermeditasi dan bagaimana mengubah perilaku</a></li>
<li><a href="../id439100/index.html">Cara mengadaptasi UX / UI di bawah izin</a></li>
<li><a href="../id439102/index.html">Rusia 20% lebih mungkin mengalami penghinaan di Internet</a></li>
<li><a href="../id439104/index.html">Redux Sederhana seperti garu</a></li>
<li><a href="../id439108/index.html">Pengukuran radio amatir: ketika tidak ada pengukur frekuensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>