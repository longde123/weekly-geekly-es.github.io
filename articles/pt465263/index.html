<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥ üë©üèΩ‚Äçüîß üï¥üèª Bloqueios no PostgreSQL: 3. Bloqueia outros objetos üêÄ üëµüèΩ üç≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° falamos sobre alguns bloqueios no n√≠vel do objeto (em particular, sobre bloqueios nas rela√ß√µes), bem como sobre bloqueios no n√≠vel da linha , seu r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloqueios no PostgreSQL: 3. Bloqueia outros objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/">  J√° falamos sobre alguns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios no n√≠vel do objeto</a> (em particular, sobre bloqueios nas rela√ß√µes), bem como sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios no n√≠vel da linha</a> , seu relacionamento com bloqueios de objetos e a fila de espera, o que nem sempre √© honesto. <br><br>  Hoje temos uma mistura.  Vamos come√ßar com os <strong>impasses</strong> (na verdade, eu ia falar sobre eles da √∫ltima vez, mas esse artigo ficou indecentemente longo), depois examinaremos os <strong>bloqueios de objetos</strong> restantes e falaremos sobre <strong>bloqueios de predicados</strong> em conclus√£o. <br><br><h1>  Deadlocks </h1><br>  Ao usar bloqueios, √© poss√≠vel uma situa√ß√£o de <em>conflito</em> (ou <em>conflito</em> ).  Ocorre quando uma transa√ß√£o tenta capturar um recurso j√° capturado por outra transa√ß√£o, enquanto outra transa√ß√£o tenta capturar um recurso capturado pela primeira.  Isso √© ilustrado na figura √† esquerda abaixo: setas s√≥lidas mostram recursos capturados, setas tracejadas mostram tentativas de capturar um recurso j√° ocupado. <br><br>  √â conveniente visualizar um impasse construindo um gr√°fico de expectativas.  Para isso, removemos recursos espec√≠ficos e deixamos apenas transa√ß√µes, observando qual transa√ß√£o est√° aguardando.  Se o gr√°fico tiver um contorno (a partir do topo, voc√™ pode acess√°-lo pelas setas) - isso √© um impasse. <br><br><img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br><a name="habracut"></a><br>  Obviamente, o impasse √© poss√≠vel n√£o apenas para duas transa√ß√µes, mas tamb√©m para qualquer n√∫mero maior. <br><br>  Se ocorrer um impasse, as transa√ß√µes envolvidas n√£o poder√£o fazer nada a respeito - elas esperar√£o indefinidamente.  Portanto, todos os DBMSs e PostgreSQL tamb√©m rastreiam automaticamente os deadlocks. <br><br>  No entanto, a verifica√ß√£o exige alguns esfor√ßos, que eu n√£o quero fazer sempre que um novo bloqueio √© solicitado (afinal, os bloqueios s√£o bastante raros).  Portanto, quando o processo tenta capturar o bloqueio e n√£o pode, ele entra na fila e adormece, mas inicia o timer com o valor especificado no par√¢metro <em>deadlock_timeout</em> (por padr√£o - 1 segundo).  Se o recurso for liberado mais cedo, tudo bem, salvamos na verifica√ß√£o.  Mas se ap√≥s o <em>deadlock_timeout a</em> espera continuar, o processo de espera ser√° despertado e iniciar√° uma verifica√ß√£o. <br><br>  Se a verifica√ß√£o (que consiste na constru√ß√£o de um gr√°fico de expectativas e na busca de contornos) n√£o revelou impasses, o processo continua adormecido - agora j√° com um final amargo. <br><br><blockquote>  Nos coment√°rios anteriores, fui criticado com raz√£o por n√£o dizer nada sobre o par√¢metro <em>lock_timeout</em> , que atua em qualquer operador e evita uma espera indefinidamente longa: se o bloqueio n√£o puder ser obtido no tempo especificado, a instru√ß√£o termina com o erro lock_not_available.  Ele n√£o deve ser confundido com o par√¢metro <em>statement_timeout</em> , que limita o tempo total de execu√ß√£o da instru√ß√£o, independentemente de esperar um bloqueio ou apenas executar o trabalho. <br></blockquote><br>  Se um impasse for detectado, uma das transa√ß√µes (na maioria dos casos, a que iniciou a verifica√ß√£o) ser√° for√ßada a terminar.  Nesse caso, os bloqueios capturados por ele s√£o liberados e as transa√ß√µes restantes podem continuar funcionando. <br><br>  Os conflitos geralmente significam que o aplicativo n√£o foi projetado corretamente.  H√° duas maneiras de detectar tais situa√ß√µes: primeiro, as mensagens aparecer√£o no log do servidor e, segundo, o valor de pg_stat_database.deadlocks aumentar√°. <br><br><h2>  Exemplo de impasse </h2><br>  Uma causa comum de deadlocks √© a ordem diferente na qual as linhas nas tabelas s√£o bloqueadas. <br>  Um exemplo simples.  A primeira transa√ß√£o pretende transferir 100 rublos da primeira conta para a segunda.  Para fazer isso, ela primeiro reduz a primeira contagem: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Ao mesmo tempo, a segunda transa√ß√£o pretende transferir 10 rublos da segunda conta para a primeira.  Ela come√ßa reduzindo a segunda contagem: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br>  Agora a primeira transa√ß√£o est√° tentando aumentar a segunda conta, mas descobre que a linha est√° bloqueada. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Em seguida, a segunda transa√ß√£o tenta aumentar a primeira conta, mas tamb√©m √© bloqueada. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  H√° uma expectativa c√≠clica que nunca termina por si pr√≥pria.  Ap√≥s um segundo, a primeira transa√ß√£o, sem acesso ao recurso, inicia uma verifica√ß√£o de conflito e interrompe o servidor. <br><br><pre> <code class="plaintext hljs">ERROR: deadlock detected DETAIL: Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513. Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477. HINT: See server log for query details. CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Agora a segunda transa√ß√£o pode continuar. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  A maneira correta de executar essas opera√ß√µes √© bloquear recursos na mesma ordem.  Por exemplo, nesse caso, voc√™ pode bloquear contas em ordem crescente de seus n√∫meros. <br><br><h2>  Impasse para dois comandos UPDATE </h2><br>  √Äs vezes, voc√™ pode obter um impasse onde, ao que parece, n√£o deveria estar.  Por exemplo, √© conveniente e familiar perceber os comandos SQL como at√¥micos, mas use UPDATE - esse comando bloqueia as linhas √† medida que elas s√£o atualizadas.  Isso n√£o est√° acontecendo de uma s√≥ vez.  Portanto, se um comando atualizar as linhas em uma ordem e a outra em outra, elas poder√£o estar em um impasse. <br><br>  √â improv√°vel que haja uma situa√ß√£o dessas, mas, mesmo assim, pode se encontrar.  Para a reprodu√ß√£o, criaremos um √≠ndice na coluna da quantidade, constru√≠da em ordem decrescente da quantidade: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(amount <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre><br>  Para ter tempo de ver o que est√° acontecendo, escreveremos uma fun√ß√£o que aumenta o valor transmitido, mas lenta, lentamente, por um segundo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> inc_slow(n <span class="hljs-type"><span class="hljs-type">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> pg_sleep(</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> n + </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100.00</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Tamb√©m precisamos da extens√£o pgrowlocks. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks;</code> </pre><br>  O primeiro comando UPDATE atualizar√° a tabela inteira.  O plano de execu√ß√£o √© √≥bvio - uma varredura seq√ºencial: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------- | Update on accounts | -&gt; Seq Scan on accounts | (2 rows)</code> </pre><br>  Como as vers√µes das linhas na p√°gina da nossa tabela est√£o na ordem crescente da soma (exatamente como as adicionamos), elas ser√£o atualizadas na mesma ordem.  Come√ßamos a atualiza√ß√£o para funcionar. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><br>  Enquanto isso, em outra sess√£o, proibiremos o uso de varredura seq√ºencial: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  Nesse caso, o planejador decide usar a verifica√ß√£o de √≠ndice para a seguinte instru√ß√£o UPDATE: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| QUERY PLAN || -------------------------------------------------------- || Update on accounts || -&gt; Index Scan using accounts_amount_idx on accounts || Index Cond: (amount &gt; 100.00) || (3 rows)</code> </pre><br>  A segunda e terceira linhas se enquadram na condi√ß√£o e, como o √≠ndice √© constru√≠do em ordem decrescente, as linhas ser√£o atualizadas na ordem inversa. <br><br>  Lan√ßamos a pr√≥xima atualiza√ß√£o. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><br>  Uma r√°pida olhada na p√°gina tabular mostra que o primeiro operador j√° conseguiu atualizar a primeira linha (0,1) e o segundo - o √∫ltimo (0,3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Mais um segundo passa.  O primeiro operador atualizou a segunda linha e o segundo gostaria de fazer isso, mas n√£o pode. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,2) locker | 530699 &lt;-    multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 3 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Agora, a primeira instru√ß√£o gostaria de atualizar a √∫ltima linha da tabela, mas j√° est√° bloqueada pela segunda.  Aqui est√° o impasse. <br><br>  Uma das transa√ß√µes √© abortada: <br><br><pre> <code class="plaintext hljs">|| ERROR: deadlock detected || DETAIL: Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513. || Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549. || HINT: See server log for query details. || CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  E o outro completa a execu√ß√£o: <br><br><pre> <code class="plaintext hljs">| UPDATE 3</code> </pre><br><blockquote>  Detalhes interessantes sobre a detec√ß√£o e preven√ß√£o de conflitos podem ser encontrados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciador de bloqueios README</a> . <br></blockquote><br>  Isso √© tudo sobre deadlocks, e prosseguimos para os bloqueios de objetos restantes. <br><br><img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br><br><h1>  Fechaduras sem rela√ß√£o </h1><br>  Quando voc√™ deseja bloquear um recurso que n√£o √© uma <em>rela√ß√£o</em> no entendimento do PostgreSQL, bloqueios de objetos s√£o usados.  Esse recurso pode ser quase qualquer coisa: espa√ßos de tabela, assinaturas, esquemas, fun√ß√µes, tipos de dados enumerados ... Grosso modo, tudo o que pode ser encontrado no cat√°logo do sistema. <br><br>  Vejamos um exemplo simples.  Iniciamos a transa√ß√£o e criamos uma tabela nela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> example(n <span class="hljs-type"><span class="hljs-type">integer</span></span>);</code> </pre><br>  Agora vamos ver que tipo de objeto bloqueios apareceu em pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> datname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dbname, classid, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.classid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> classname, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> l.locktype = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> database | dbname | classid | classname | objid | mode | granted ----------+--------+---------+--------------+-------+-----------------+--------- 0 | | 1260 | pg_authid | 16384 | AccessShareLock | t 16386 | test | 2615 | pg_namespace | 2200 | AccessShareLock | t (2 rows)</code> </pre><br>  Para entender exatamente o que est√° bloqueado aqui, √© necess√°rio examinar tr√™s campos: banco de dados, classid e objid.  Vamos come√ßar com a primeira linha. <br><br>  Banco de dados √© o OID do banco de dados ao qual o recurso bloqueado pertence.  No nosso caso, h√° zero nesta coluna.  Isso significa que estamos lidando com um objeto global que n√£o pertence a nenhuma base espec√≠fica. <br><br>  Classid cont√©m o OID de pg_class, que corresponde ao nome da tabela de cat√°logos do sistema, que determina o tipo de recurso.  No nosso caso, pg_authid, ou seja, a fun√ß√£o √© o recurso (usu√°rio). <br><br>  Objid cont√©m o OID da tabela de cat√°logo do sistema que classid nos indicou. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rolname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_authid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">16384</span></span>;</code> </pre><pre> <code class="plaintext hljs"> rolname --------- student (1 row)</code> </pre><br>  Assim, o papel do aluno √© bloqueado, do qual estamos trabalhando. <br><br>  Agora vamos lidar com a segunda linha.  O banco de dados √© indicado e este √© o banco de dados de teste ao qual estamos conectados. <br><br>  Classid aponta para a tabela pg_namespace que cont√©m os esquemas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_namespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">2200</span></span>;</code> </pre><pre> <code class="plaintext hljs"> nspname --------- public (1 row)</code> </pre><br>  Assim, o esquema p√∫blico est√° bloqueado. <br><br>  Portanto, vimos que, ao criar um objeto, a fun√ß√£o de propriet√°rio e o esquema no qual o objeto √© criado s√£o bloqueados (no modo compartilhado).  O que √© l√≥gico: caso contr√°rio, algu√©m poder√° remover a fun√ß√£o ou o esquema enquanto a transa√ß√£o ainda n√£o estiver conclu√≠da. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Bloqueio de extens√£o de relacionamento </h1><br>  Quando o n√∫mero de linhas em uma rela√ß√£o (ou seja, em uma tabela, √≠ndice, visualiza√ß√£o materializada) aumenta, o PostgreSQL pode usar o espa√ßo livre nas p√°ginas existentes para inserir, mas, obviamente, em algum momento voc√™ precisa adicionar novas p√°ginas.  Fisicamente, eles s√£o adicionados ao final do arquivo correspondente.  Isso √© entendido como <em>expandir o relacionamento</em> . <br><br>  Para impedir que dois processos se apressem para adicionar p√°ginas ao mesmo tempo, esse processo √© protegido por um bloqueio especial do tipo extend.  O mesmo bloqueio √© usado ao limpar √≠ndices para que outros processos n√£o possam adicionar p√°ginas durante a digitaliza√ß√£o. <br><br>  Obviamente, esse bloqueio √© liberado sem aguardar o final da transa√ß√£o. <br><br><blockquote>  Anteriormente, as tabelas eram expandidas apenas uma p√°gina por vez.  Isso causou problemas quando v√°rios processos inseriram linhas simultaneamente; portanto, no PostgreSQL 9.6, v√°rias p√°ginas foram adicionadas √†s tabelas de uma s√≥ vez (na propor√ß√£o do n√∫mero de processos aguardando o bloqueio, mas n√£o mais que 512). <br></blockquote><br><h1>  Bloqueio de p√°gina </h1><br>  Um bloqueio no n√≠vel da p√°gina √© aplicado no √∫nico caso (exceto os bloqueios de predicado, que ser√£o discutidos posteriormente). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os √≠ndices GIN</a> permitem acelerar a pesquisa em valores compostos, por exemplo, palavras em documentos de texto (ou elementos em matrizes).  Para uma primeira aproxima√ß√£o, esses √≠ndices podem ser representados como uma √°rvore B comum, na qual n√£o s√£o armazenados os pr√≥prios documentos, mas palavras individuais desses documentos.  Portanto, ao adicionar um novo documento, o √≠ndice precisa ser reconstru√≠do com bastante for√ßa, introduzindo nele todas as palavras inclu√≠das no documento. <br><br>  Para melhorar o desempenho, os √≠ndices GIN t√™m um recurso de inser√ß√£o atrasada que √© ativado pela op√ß√£o de armazenamento fastupdate.  Novas palavras s√£o adicionadas rapidamente √† lista pendente n√£o ordenada e, ap√≥s algum tempo, tudo o que acumulou √© movido para a estrutura principal do √≠ndice.  A economia se deve ao fato de documentos diferentes provavelmente conterem palavras duplicadas. <br><br>  Para excluir v√°rios processos da passagem da lista de espera para o √≠ndice principal ao mesmo tempo, a meta p√°gina de √≠ndice √© bloqueada no modo exclusivo durante a transfer√™ncia.  Isso n√£o interfere no uso do √≠ndice no modo normal. <br><br><h1>  Bloqueios consultivos </h1><br>  Ao contr√°rio de outros bloqueios (como bloqueios de relacionamento), os bloqueios consultivos nunca s√£o definidos automaticamente, eles s√£o gerenciados pelo desenvolvedor do aplicativo.  Eles s√£o convenientes de usar, por exemplo, se um aplicativo precisar de l√≥gica de bloqueio para algum prop√≥sito que n√£o se encaixe na l√≥gica padr√£o de bloqueios comuns. <br><br>  Suponha que tenhamos um recurso condicional que n√£o corresponde a nenhum objeto de banco de dados (que poder√≠amos bloquear com comandos como SELECT FOR ou LOCK TABLE).  Voc√™ precisa criar um identificador num√©rico para ele.  Se o recurso tiver um nome exclusivo, uma op√ß√£o simples √© obter um c√≥digo de hash: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 243773337 (1 row)</code> </pre><br>  √â assim que capturamos o bloqueio: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Como sempre, as informa√ß√µes de bloqueio est√£o dispon√≠veis em pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Para que um bloqueio realmente funcione, outros processos tamb√©m devem obter um bloqueio antes de acessar o recurso.  Obviamente, o cumprimento desta regra deve ser garantido pelo aplicativo. <br><br>  No exemplo acima, o bloqueio √© v√°lido at√© o final da sess√£o, e n√£o a transa√ß√£o, como de costume. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Ele deve ser liberado explicitamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_unlock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  H√° um grande conjunto de fun√ß√µes para trabalhar com bloqueios consultivos para todas as ocasi√µes: <br><br><ul><li>  pg_advisory_lock_shared trata um bloqueio compartilhado, </li><li>  pg_advisory_xact_lock (e pg_advisory_xact_lock_shared) recebe um bloqueio at√© o final da transa√ß√£o, </li><li>  pg_try_advisory_lock (assim como pg_try_advisory_xact_lock e pg_try_advisory_xact_lock_shared) n√£o espera receber um bloqueio, mas retorna um valor falso se o bloqueio n√£o puder ser obtido imediatamente. </li></ul><br>  O conjunto de fun√ß√µes try fornece outra maneira de n√£o esperar um bloqueio, al√©m das listadas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um artigo anterior</a> . <br><br><h1>  Bloqueios de predicado </h1><br>  O termo <em>bloqueio de predicado</em> apareceu h√° muito tempo, nas primeiras tentativas de implementar o isolamento completo com base em bloqueios nos DBMSs anteriores (o n√≠vel √© serializ√°vel, embora o padr√£o SQL n√£o existisse naquele momento).  O problema que foi encontrado foi que mesmo o bloqueio de todas as linhas lidas e alteradas n√£o fornece isolamento completo: <em>novas</em> linhas podem aparecer na tabela que se enquadram nas mesmas condi√ß√µes de sele√ß√£o, o que leva a <em>fantasmas</em> (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre isolamento</a> ) . <br><br>  A id√©ia de bloqueios de predicado era bloquear predicados, n√£o linhas.  Se, ao executar uma consulta com a condi√ß√£o <em>a</em> &gt; 10, o predicado <em>a</em> &gt; 10 for bloqueado, isso n√£o adicionar√° novas linhas √† tabela que se enquadram na condi√ß√£o e evitar√° fantasmas.  O problema √© que, no caso geral, essa √© uma tarefa computacionalmente dif√≠cil;  na pr√°tica, ele pode ser resolvido apenas para predicados que tenham uma forma muito simples. <br><br>  No PostgreSQL, a camada Serializable √© implementada de maneira diferente, al√©m do isolamento existente baseado em snapshots.  O termo <em>bloqueio de predicado</em> permanece, mas seu significado mudou radicalmente.  De fato, esses "bloqueios" n√£o bloqueiam nada, mas s√£o usados ‚Äã‚Äãpara rastrear depend√™ncias de dados entre transa√ß√µes. <br><br>  Est√° provado que o isolamento baseado em imagens permite uma <em>anomalia de grava√ß√£o inconsistente</em> e uma <em>anomalia de apenas uma transa√ß√£o de leitura</em> , mas nenhuma outra anomalia √© poss√≠vel.  Para entender que estamos lidando com uma das duas anomalias listadas, podemos analisar as depend√™ncias entre transa√ß√µes e encontrar certos padr√µes nelas. <br><br>  Estamos interessados ‚Äã‚Äãem dois tipos de depend√™ncias: <br><br><ul><li>  uma transa√ß√£o l√™ uma linha, que √© alterada por outra transa√ß√£o (depend√™ncia de RW), </li><li>  uma transa√ß√£o modifica a linha que outra transa√ß√£o l√™ (depend√™ncia WR). </li></ul><br>  As depend√™ncias de WR podem ser rastreadas usando bloqueios convencionais existentes, mas as depend√™ncias de RW precisam apenas rastrear adicionalmente. <br><br>  Repito mais uma vez: apesar do nome, os bloqueios de predicado n√£o bloqueiam nada.  Em vez disso, quando uma transa√ß√£o √© confirmada, uma verifica√ß√£o √© executada e, se uma sequ√™ncia de depend√™ncia "ruim" for detectada e indicar uma anomalia, a transa√ß√£o ser√° interrompida. <br><br>  Vamos ver como ocorre a instala√ß√£o dos bloqueios de predicado.  Para fazer isso, crie uma tabela com um n√∫mero suficientemente grande de linhas e um √≠ndice nela. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pred(n <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> gn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> pred;</code> </pre><br>  Se a consulta for executada por varredura seq√ºencial de toda a tabela, o bloqueio de predicado ser√° definido em toda a tabela (mesmo que nem todas as linhas se enquadrem nas condi√ß√µes de filtragem). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 12763 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------------------------------------------- | Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1) | Filter: (n &gt; 100) | Rows Removed by Filter: 100 | Planning Time: 0.190 ms | Execution Time: 15.244 ms | (5 rows)</code> </pre><br>  Quaisquer bloqueios de predicado s√£o sempre capturados em um modo especial SIReadLock (leitura serializada de isolamento): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+----------+------+------- relation | pred | | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Mas se a consulta for executada usando a verifica√ß√£o de √≠ndice, a situa√ß√£o mudar√° para melhor.  Se falamos sobre a √°rvore B, basta definir o bloqueio nas linhas da tabela de leitura e nas p√°ginas frondosas do √≠ndice - assim, bloqueamos n√£o apenas valores espec√≠ficos, mas tamb√©m toda a faixa lida. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001)) | Heap Fetches: 2 | Planning Time: 0.096 ms | Execution Time: 0.153 ms | (5 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- tuple | pred | 3 | 236 tuple | pred | 3 | 235 page | pred_n_idx | 22 | (3 rows)</code> </pre><br>  Voc√™ pode perceber v√°rias dificuldades. <br><br>  Primeiramente, um bloqueio separado √© criado para cada vers√£o da linha lida, mas √© poss√≠vel que exista muitas dessas vers√µes.  O n√∫mero total de bloqueios de predicado no sistema √© limitado pelo produto dos valores do par√¢metro <em>max_pred_locks_per_transaction</em> √ó <em>max_connections</em> (os valores padr√£o s√£o 64 e 100, respectivamente).  A mem√≥ria para esses bloqueios √© alocada na inicializa√ß√£o do servidor;  tentar exceder esse n√∫mero resultar√° em erros. <br><br>  Portanto, para bloqueios de predicado (e apenas para eles!), <em>√â</em> usado um <em>aumento de n√≠vel</em> .  Antes do PostgreSQL 10, havia restri√ß√µes conectadas ao c√≥digo e, come√ßando com ele, voc√™ pode controlar os par√¢metros aumentando o n√≠vel.  Se o n√∫mero de bloqueios de vers√£o de linha <em>por linha for</em> maior que <em>max_pred_locks_per_page</em> , esses bloqueios ser√£o substitu√≠dos por um bloqueio no n√≠vel da p√°gina.  Aqui est√° um exemplo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> max_pred_locks_per_page;</code> </pre><pre> <code class="plaintext hljs"> max_pred_locks_per_page ------------------------- 2 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002)) | Heap Fetches: 3 | Planning Time: 0.069 ms | Execution Time: 0.057 ms | (5 rows)</code> </pre><br>  Em vez de tr√™s bloqueios de tupla, vemos um tipo de p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 22 | (2 rows)</code> </pre><br>  Da mesma forma, se o n√∫mero de bloqueios de p√°gina <em>associados</em> a um √∫nico relacionamento exceder <em>max_pred_locks_per_relation</em> , esses bloqueios ser√£o substitu√≠dos por um bloqueio no n√≠vel de relacionamento. <br><br>  N√£o h√° outros n√≠veis: os bloqueios de predicado s√£o capturados apenas para relacionamentos, p√°ginas ou vers√µes de linha e sempre com o modo SIReadLock. <br><br>  Obviamente, um aumento no n√≠vel de bloqueios inevitavelmente leva ao fato de que um n√∫mero maior de transa√ß√µes resultar√° falsamente em um erro de serializa√ß√£o e, como resultado, a taxa de transfer√™ncia do sistema diminuir√°.  Aqui voc√™ precisa procurar um equil√≠brio entre o consumo de mem√≥ria e o desempenho. <br><br>  A segunda dificuldade √© que, em v√°rias opera√ß√µes com o √≠ndice (por exemplo, devido √† divis√£o das p√°ginas de √≠ndice ao inserir novas linhas), o n√∫mero de p√°ginas de folha que cobrem o intervalo de leitura pode mudar.  Mas a implementa√ß√£o disso leva em considera√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 211 | page | pred_n_idx | 212 | page | pred_n_idx | 22 | (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  A prop√≥sito, os bloqueios de predicado nem sempre s√£o removidos imediatamente ap√≥s a conclus√£o da transa√ß√£o, porque s√£o necess√°rios para rastrear as depend√™ncias entre <em>v√°rias</em> transa√ß√µes.  Mas, em qualquer caso, eles s√£o gerenciados automaticamente. <br><br>  Nem todos os tipos de √≠ndice no PostgreSQL suportam bloqueios de predicado.  Anteriormente, apenas as √°rvores B podiam se gabar disso, mas no PostgreSQL 11 a situa√ß√£o melhorava: √≠ndices de hash, GiST e GIN foram adicionados √† lista.  Se o acesso ao √≠ndice for usado e o √≠ndice n√£o funcionar com bloqueios de predicado, o √≠ndice inteiro ser√° bloqueado.  Obviamente, isso tamb√©m aumenta o n√∫mero de quebras de transa√ß√µes falsas. <br><br>  Concluindo, observo que √© com o uso de bloqueios de predicado que h√° uma restri√ß√£o que, para garantir o isolamento completo, <em>todas as</em> transa√ß√µes devem funcionar no n√≠vel serializ√°vel.  Se uma transa√ß√£o usa um n√≠vel diferente, simplesmente n√£o define (e verifica) bloqueios de predicado. <br><br><blockquote>  Por tradi√ß√£o, deixarei um link para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README sobre bloqueios de predicado</a> , a partir do qual voc√™ pode come√ßar a estudar o c√≥digo-fonte. <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465263/">https://habr.com/ru/post/pt465263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465251/index.html">O ver√£o est√° quase no fim. Quase nenhum dado vazou</a></li>
<li><a href="../pt465255/index.html">Implementa√ß√£o do conjunto de conex√µes WCF para .Net Core usando HttpClientFactory</a></li>
<li><a href="../pt465257/index.html">‚ÄúCuidado, FAS!‚Äù: Truques do McDonald's, shawarma divino, Clooney falso e um pouco de magia das ruas</a></li>
<li><a href="../pt465259/index.html">ValueTask <TResult> - por que, por que e como?</a></li>
<li><a href="../pt465261/index.html">O poder m√°gico das macros ou como facilitar a vida de um programador de assembler AVR</a></li>
<li><a href="../pt465267/index.html">TypeScript Express√£o M√°gica</a></li>
<li><a href="../pt465269/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 26. DNS e DHCP</a></li>
<li><a href="../pt465271/index.html">Os hackers roubam e lavam dinheiro atrav√©s de servi√ßos de entrega de comida e reserva de hotel.</a></li>
<li><a href="../pt465273/index.html">Como os desenvolvedores de software da Microgaming protegem os usu√°rios de hackers</a></li>
<li><a href="../pt465275/index.html">Alice Obt√©m Habilidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>