<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖ üë©üèª‚Äçüéì üåï Qt: dibujo basado en gr√°ficos vectoriales üë®üèº‚Äçüöí ü•Ö üßôüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt proporciona al programador funciones muy ricas, pero el conjunto de widgets es limitado. Si ninguno de los disponibles es adecuado, debe dibujar al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: dibujo basado en gr√°ficos vectoriales</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt proporciona al programador funciones muy ricas, pero el conjunto de widgets es limitado.  Si ninguno de los disponibles es adecuado, debe dibujar algo propio.  La forma m√°s simple, usar im√°genes ya hechas, tiene serios inconvenientes: la necesidad de almacenar im√°genes en un archivo o recursos, problemas de escalabilidad y portabilidad de formatos de imagen.  A continuaci√≥n se describe el uso de los principios de los gr√°ficos vectoriales sin utilizar las im√°genes vectoriales reales. </p><a name="habracut"></a><br><h2 id="preambula">  Pre√°mbulo </h2><br><p>  Todo comenz√≥ con el hecho de que una vez se necesitaba una indicaci√≥n de signos de un bit.  Algunas aplicaciones reciben algunos datos en alg√∫n puerto, el paquete debe desarmarse y mostrarse en la pantalla.  Ser√≠a bueno al mismo tiempo imitar de alguna manera el tablero familiar.  Para mostrar datos digitales, Qt ofrece "fuera de la caja" la clase QLCDNumber, similar a los familiares indicadores de siete segmentos, pero algo no es visible en las l√°mparas individuales. </p><br><p>  Usar indicadores (son casillas de verificaci√≥n) e interruptores (son botones de radio) para estos fines es malo, y aqu√≠ hay una lista de razones: </p><br><ul><li>  Esto est√° mal sem√°nticamente.  Botones: son botones y est√°n destinados a la entrada del usuario y no para mostrarle nada. </li><li>  Esto implica lo segundo: el usuario se esfuerza por tocar esos botones.  Si al mismo tiempo la actualizaci√≥n de la informaci√≥n no es particularmente r√°pida, la indicaci√≥n mentir√°, y el usuario informar√° un mal funcionamiento del programa, riendo vilmente. </li><li>  Si bloquea el bot√≥n para presionar (setEnabled (false)), se vuelve gris feo.  Recuerdo que en Delphi, en la regi√≥n de la versi√≥n 6, hab√≠a una finta con orejas: se pod√≠a poner una bandera en el panel y desactivar la disponibilidad del panel, no la bandera, entonces la bandera no era gris ni activa.  Este truco no funciona aqu√≠. </li><li>  Los botones tienen foco de entrada.  En consecuencia, si hay elementos de entrada en la ventana, y el usuario los recorre usando la tecla Tab, tendr√° que caminar a lo largo de los elementos de salida, lo cual es inconveniente y feo. </li><li>  Al final, estos botones se ven sin est√©tica, especialmente al lado del segmento de siete. </li></ul><br><p>  Conclusi√≥n: debes dibujar una bombilla t√∫ mismo. </p><br><h2 id="muki-vybora">  Harina de elecci√≥n </h2><br><p>  Primero busqu√© soluciones ya hechas.  En ese tiempo lejano, cuando usaba Delphi, pod√≠a encontrar una cantidad gigantesca de componentes terminados, tanto de compa√±√≠as serias como de fabricantes aficionados.  Qt tiene muchos problemas con esto.  QWT tiene algunos elementos, pero no eso.  No vi el amateurismo en absoluto.  Probablemente, si cavas correctamente en Github, puedes encontrar algo, pero probablemente lo har√© m√°s r√°pido. </p><br><p>  Lo primero que se sugiri√≥ del casero fue usar dos archivos de imagen con im√°genes de la luz encendida y apagada.  Malo: </p><br><ul><li>  Es necesario encontrar buenas im√°genes (o dibujar, pero no soy artista); </li><li>  La cuesti√≥n de principio es: atar no es bueno, incluso im√°genes, incluso tumbarse bajo los pies; </li><li>  Deben almacenarse en alg√∫n lugar.  Los archivos son muy malos: borrados accidentalmente y no hay botones.  Los recursos son mejores, pero tampoco siento que pueda sobrevivir; </li><li>  Sin escalabilidad; </li><li>  La personalizaci√≥n (colores, por ejemplo) se logra solo agregando archivos.  Es decir, recursos intensivos e inflexibles. </li></ul><br><p>  La segunda cosa que se desprende de la primera es usar im√°genes vectoriales en lugar de im√°genes.  Adem√°s, Qt puede renderizar SVG.  Ya es un poco m√°s f√°cil buscar la imagen en s√≠: hay muchas lecciones sobre los gr√°ficos vectoriales en la red, puede encontrar algo m√°s o menos adecuado y adaptarlo a sus necesidades.  Pero la cuesti√≥n sigue siendo el almacenamiento y la personalizaci√≥n, y la representaci√≥n no es gratuita para los recursos.  Peniques, por supuesto, pero a√∫n as√≠ ... </p><br><p>  Y el tercero se deduce del segundo: ¬°puede usar los principios de los gr√°ficos vectoriales para im√°genes de auto-dibujo!  Un archivo de imagen vectorial en forma de texto indica qu√© y c√≥mo dibujar.  Puedo especificar el mismo c√≥digo usando tutoriales vectoriales.  Afortunadamente, el objeto QPainter tiene las herramientas necesarias: un bol√≠grafo, un pincel, un degradado y primitivas de dibujo, incluso un relleno de textura.  S√≠, las herramientas est√°n lejos de todo: no hay m√°scaras, modos de fusi√≥n, pero absolutamente no se requiere fotorrealismo. </p><br><p>  Busqu√© algunos ejemplos en la red.  Tom√≥ la primera lecci√≥n que surgi√≥: "Dibujamos un bot√≥n en el editor de gr√°ficos Inkscape" del sitio "Es f√°cil de dibujar".  El bot√≥n de esta lecci√≥n se parece mucho m√°s a una bombilla que a un bot√≥n, lo cual me conviene perfectamente.  Estoy haciendo un borrador: en lugar de Inkscape, un proyecto en Qt. </p><br><h2 id="proba-pera">  Prueba de plumas </h2><br><p>  Estoy creando un nuevo proyecto.  Elijo el nombre del proyecto rgbled (porque quiero hacer algo como un LED RGB) y la ruta a √©l.  Elijo la clase base QWidget y el nombre RgbLed, me niego a crear un archivo de formulario.  El proyecto por defecto despu√©s del lanzamiento hace una ventana vac√≠a, todav√≠a no es interesante. </p><br><h3 id="podgotovka-k-risovaniyu">  Preparaci√≥n para el dibujo </h3><br><p>  Hay un espacio en blanco.  Ahora necesita obtener los miembros privados de la clase, que determinar√°n la geometr√≠a de la imagen.  Una ventaja esencial de los gr√°ficos vectoriales es su escalabilidad, por lo que debe haber un m√≠nimo de n√∫meros constantes, y solo establecen las proporciones.  Las dimensiones se volver√°n a calcular en el evento resizeEvent (), que deber√° redefinirse. </p><br><p>  En el tutorial de dibujo utilizado, las dimensiones se especifican en p√≠xeles a medida que avanza.  Necesito determinar de antemano lo que usar√© y c√≥mo contarlo. </p><br><p>  Una imagen dibujada consta de los siguientes elementos: </p><br><ul><li>  anillo exterior (inclinado hacia afuera, parte del borde convexo) </li><li>  anillo interior (inclinado hacia adentro) </li><li>  Carcasa de l√°mpara LED, "vidrio" </li><li>  sombra en el borde del cristal </li><li>  punto culminante </li><li>  llamarada inferior </li></ul><br><p>  Los c√≠rculos conc√©ntricos, es decir, todo excepto el resplandor, est√°n determinados por la posici√≥n del centro y el radio.  El deslumbramiento est√° determinado por el centro, el ancho y la altura, y la posici√≥n de los centros de deslumbramiento X coincide con la posici√≥n del centro X de toda la imagen. </p><br><p>  Para calcular los elementos de la geometr√≠a, debe determinar cu√°l es mayor: el ancho o la altura, porque la bombilla es redonda y debe caber en un cuadrado con un lado igual a la menor de las dos dimensiones.  Entonces, agrego los miembros privados correspondientes al archivo de encabezado. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Luego redefin√≠ la funci√≥n protegida que se llama cuando se cambia el tama√±o del widget. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Aqu√≠, se calcula el lado del cuadrado en el que est√° inscrita la bombilla, el centro de este cuadrado, el radio del borde que ocupa el √°rea m√°xima posible, el ancho del borde, cuya parte externa debe ser 1/10 del di√°metro y el interior 1/14.  Luego, se calcula la posici√≥n del resplandor, que se encuentra en el medio de los radios superior e inferior, el ancho y la altura se seleccionan por ojo. </p><br><p>  Adem√°s, en los campos protegidos, agregar√© inmediatamente un conjunto de colores para usar. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  Por los nombres, es aproximadamente claro que estos son los colores de la bombilla, la parte clara de la sombra, la parte oscura de la sombra, los tres colores de la sombra anular alrededor de la bombilla y los colores de los gradientes de deslumbramiento. </p><br><p>  Los colores deben inicializarse, por lo que complementar√© la pieza de trabajo del dise√±ador. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  Adem√°s, no olvide insertar en el archivo de encabezado las inclusiones de clases que se necesitar√°n al dibujar. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Este c√≥digo se compila correctamente, pero nada ha cambiado en la ventana del widget.  Es hora de empezar a dibujar. </p><br><h3 id="risovanie">  Dibujo </h3><br><p>  Entro en una funci√≥n cerrada </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  y redefinir la funci√≥n protegida </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  El evento redibujado causar√° el dibujo real, al cual se pasa el color del "vidrio" como par√°metro. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  Hasta ahora  Y comenzamos a completar gradualmente la funci√≥n de dibujo. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Primero, se crea un objeto de artista, que se dedicar√° al dibujo.  Luego se crea un l√°piz que es necesario para que no haya l√°piz: en esta imagen, el trazo del contorno no solo no es necesario, sino que tampoco es necesario. </p><br><p>  Luego, el primer c√≠rculo se dibuja de manera aproximada de acuerdo con la lecci√≥n sobre gr√°ficos vectoriales: un c√≠rculo grande, lleno de un degradado radial.  El gradiente tiene un punto de anclaje claro en la parte superior, pero no en el borde mismo, y uno oscuro en la parte inferior, pero tampoco en el borde.  Se crea un pincel basado en el degradado, con este pincel el pintor pinta un c√≠rculo (es decir, una elipse inscrita en un cuadrado).  Resulta que tal c√≥digo </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  El entorno enfatiza el par√°metro de color de la funci√≥n drawLed porque no se usa.  D√©jelo tolerar, todav√≠a no lo necesitan, pero pronto lo necesitar√°.  El proyecto lanzado produce el siguiente resultado: </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Agregue otro lote de c√≥digo. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Casi el mismo c√≠rculo, solo que m√°s peque√±o y al rev√©s.  Obtenemos la siguiente imagen: </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Entonces finalmente necesitas el color del vidrio: </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Aqu√≠, usando la funci√≥n m√°s oscura del color transmitido, se obtiene el mismo color, pero m√°s oscuro, para organizar el gradiente.  Coeficiente 120 seleccionado por ojo.  Aqu√≠ est√° el resultado: </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Agregue una sombra anular alrededor del vidrio.  Esto se hace en la lecci√≥n sobre gr√°ficos vectoriales, y esto deber√≠a agregar volumen y realismo: </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Hay un gradiente de tres pasos, de modo que la sombra es m√°s gruesa hasta el borde y se vuelve p√°lida hacia el centro.  Resulta as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Agregue reflejos, ambos a la vez.  El resaltado superior, a diferencia del inferior (y todos los dem√°s elementos), se convierte en un degradado lineal.  Mi artista es regular, tomo mi palabra para el autor de la lecci√≥n.  Quiz√°s haya algo de verdad en esto, no experimentar√© con diferentes tipos de gradientes. </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  De hecho, eso es todo, una bombilla prefabricada, como en KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  La visibilidad del resplandor y el abultamiento del vidrio se ve afectada por el color, o m√°s bien, por lo oscuro que es.  Puede tener sentido agregar un ajuste para el brillo del resplandor y el coeficiente de atenuaci√≥n en la funci√≥n m√°s oscura dependiendo de la oscuridad, pero creo que esto es perfeccionismo. </p><br><p>  A continuaci√≥n se muestra un ejemplo de uso en una ventana del programa. </p><br><div class="spoiler">  <b class="spoiler_title">dibujo</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Mimos </h3><br><p>  Por diversi√≥n, puedes jugar con flores.  Por ejemplo, anular un evento de clic de mouse protegido </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  de esta manera: </p><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  sin olvidar agregar eventos del mouse al encabezado: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Ahora, al hacer clic con el mouse en el componente, cambiar√° el color de la bombilla: rojo, verde, azul, gris y algo de luz aleatoria de la l√°mpara. </p><br><h2 id="epilog">  Ep√≠logo </h2><br><p>  En cuanto al dibujo, eso es todo.  Y el widget deber√≠a agregar funcionalidad.  En mi caso, se agreg√≥ un campo booleano "use state", otro campo booleano que define el estado "On" u "Off" y los colores predeterminados para estos estados, as√≠ como getters y setters abiertos para todo esto. la funci√≥n paintEvent () para seleccionar el color pasado a drawLed () como par√°metro. Como resultado, puede desactivar el uso de estados y configurar la bombilla a cualquier color, o activar los estados y encender o apagar la bombilla de acuerdo con los eventos. Es especialmente conveniente hacer que el configurador de estado sea una ranura abierta y unidos  ya sea con la se√±al que debe ser monitoreada. </p><br><p>  El uso de mousePressEvent demuestra que un widget se puede convertir no solo en un indicador, sino tambi√©n en un bot√≥n, haciendo que se presione, suelte, doble, tuerza, coloree y lo que desee para los eventos de apuntar, hacer clic y soltar. </p><br><p>  Pero esto ya no es fundamental.  El objetivo era mostrar d√≥nde puede tomar modelos a seguir al dibujar sus propios widgets y c√≥mo este dibujo es f√°cil de implementar sin usar im√°genes r√°ster o vectoriales, en recursos o archivos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425547/">https://habr.com/ru/post/es425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425531/index.html">Refrigeraci√≥n l√≠quida de freno. Opciones de desarrollo del sistema</a></li>
<li><a href="../es425533/index.html">C√≥mo trabajar en la nube: desde verificar la confiabilidad de un centro de datos hasta administrar una infraestructura virtual</a></li>
<li><a href="../es425537/index.html">C√≥mo combinar Java, Js y gr√°ficos con arte, o la historia de c√≥mo se cre√≥ un teatro interactivo</a></li>
<li><a href="../es425541/index.html">C√≥mo evitar r√°pidamente y sin chips innecesarios la inmutabilidad de la direcci√≥n del sensor HTU21</a></li>
<li><a href="../es425545/index.html">Debes pensar en horas de pr√°ctica.</a></li>
<li><a href="../es425549/index.html">Supermicro se desploma en medio de una investigaci√≥n sobre el despliegue de chips esp√≠as chinos</a></li>
<li><a href="../es425551/index.html">¬øQui√©n deber√≠a recibir dinero de la venta de una obra de arte creada por AI?</a></li>
<li><a href="../es425553/index.html">Lo que el conde de Montecristo puede decirnos sobre la ciberseguridad</a></li>
<li><a href="../es425555/index.html">Charles Nutter sobre lenguajes din√°micos en la JVM en jug.msk.ru</a></li>
<li><a href="../es425557/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 10: Ejecuci√≥n simb√≥lica, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>