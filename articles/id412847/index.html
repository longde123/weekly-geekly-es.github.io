<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèæ ü§ú ‚û°Ô∏è graphql - mengoptimalkan permintaan basis data üê¢ üïØÔ∏è ü•É</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat bekerja dengan database, ada masalah yang disebut "SELECT N +1" - ketika aplikasi, alih-alih satu permintaan ke database, yang memilih semua data...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>graphql - mengoptimalkan permintaan basis data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412847/">  Saat bekerja dengan database, ada masalah yang disebut "SELECT N +1" - ketika aplikasi, alih-alih satu permintaan ke database, yang memilih semua data yang diperlukan dari beberapa tabel terkait, koleksi, membuat subquery tambahan untuk setiap baris hasil dari hasil query pertama, untuk mendapatkan data terkait.  Sebagai contoh, pertama kita mendapatkan daftar mahasiswa di mana spesialisasinya diidentifikasi oleh pengidentifikasi, dan kemudian untuk masing-masing siswa kita membuat subquery tambahan ke tabel atau kumpulan spesialisasi untuk mendapatkan nama spesialisasi dengan pengidentifikasi spesialisasi.  Karena setiap subkueri mungkin memerlukan subkueri lain, dan subkueri lain - jumlah kueri ke basis data mulai tumbuh secara eksponensial. <br><br>  Ketika bekerja dengan graphql, sangat mudah untuk menghasilkan masalah "SELECT N +1" jika Anda membuat subquery pada tabel tertaut dalam fungsi resolver.  Hal pertama yang terlintas dalam pikiran adalah membuat permintaan segera dengan mempertimbangkan semua data terkait, tetapi ini, Anda harus setuju, tidak rasional jika data terkait tidak diminta oleh klien. <br><br>  Salah satu solusi untuk masalah "SELECT N +1" untuk graphql akan dipertimbangkan dalam posting ini. <br><a name="habracut"></a><br>  Misalnya, ambil dua koleksi: "Penulis" (Penulis) dan "Buku" (Buku).  Hubungan itu, seperti yang orang duga, banyak-ke-banyak.  Satu Penulis dapat memiliki beberapa Buku, dan satu Buku dapat ditulis oleh beberapa Penulis.  Untuk menyimpan informasi, kami akan menggunakan database mongodb dan perpustakaan mongoose.js <br><br>  Kami menyadari hubungan antara banyak-ke-banyak koleksi menggunakan koleksi BookAuthor tambahan dan bidang virtual. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Author.js const mongoose = require('mongoose'); const Schema = mongoose.Schema; const schema = new Schema({ name: String }); schema.virtual('books', { ref: 'BookAuthor', localField: '_id', foreignField: 'author' }); module.exports = schema;</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Book.js const mongoose = require('mongoose'); const Schema = mongoose.Schema; const schema = new Schema({ title: String }); schema.virtual('authors', { ref: 'BookAuthor', localField: '_id', foreignField: 'book' }); module.exports = schema;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// BookAuthor.js const mongoose = require('mongoose'); const Schema = mongoose.Schema; const schema = new Schema({ author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' }, book: { type: mongoose.Schema.Types.ObjectId, ref: 'Book' } }); module.exports = schema;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// mongoSchema.js const mongoose = require('mongoose'); const Author = require('./Author'); const Book = require('./Book'); const BookAuthor = require('./BookAuthor'); mongoose.connect('mongodb://localhost:27017/books') mongoose.set('debug', true); exports.Author = mongoose.model('Author', Author); exports.Book = mongoose.model('Book', Book); exports.BookAuthor = mongoose.model('BookAuthor', BookAuthor);</span></span></code> </pre><br>  Sekarang tentukan jenis Penulis dan Buku di graphql.  Ada sedikit masalah dengan fakta bahwa jenis-jenis ini saling dirujuk.  Oleh karena itu, untuk akses bersama mereka, pengikatan tautan ke objek modul ekspor digunakan, dan bukan pengikatan objek baru ke modul.ekspor (yang menggantikan objek asli), dan bidang bidang diimplementasikan sebagai fungsi, yang memungkinkan Anda untuk "menunda" membaca tautan ke objek saat dibuat sampai semua referensi melingkar tersedia: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// graphqlType.js exports.Author = require('./Author'); exports.Book = require('./Book');</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Author.js const graphql = require('graphql') const graphqlType = require('./index') module.exports = new graphql.GraphQLObjectType({ name: 'author', description: '', fields: () =&gt; ({ _id: {type: graphql.GraphQLString}, name: { type: graphql.GraphQLString, }, books: { type: new graphql.GraphQLList(graphqlType.Book), resolve: obj =&gt; obj.books &amp;&amp; obj.books.map(book =&gt; book.book) } }) });</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Book.js const graphql = require('graphql') const graphqlType = require('./index') module.exports = new graphql.GraphQLObjectType({ name: 'book', description: '', fields: () =&gt; ({ _id: {type: graphql.GraphQLString}, title: { type: graphql.GraphQLString, }, authors: { type: new graphql.GraphQLList(graphqlType.Author), resolve: obj =&gt; obj.authors &amp;&amp; obj.authors.map(author =&gt; author.author) } }) });</span></span></code> </pre><br>  Sekarang kami mendefinisikan permintaan Penulis, mungkin dengan daftar buku-buku mereka, dan, mungkin, dengan daftar penulis (rekan penulis) dari buku-buku ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> graphql = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFieldNames = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql-list-fields'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> graphqlType = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../graphqlType'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mongoSchema = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../mongoSchema'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> graphql.GraphQLList(graphqlType.Author), <span class="hljs-attr"><span class="hljs-attr">args</span></span>: { <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: graphql.GraphQLString } }, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, {_id}, context, info</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fields = getFieldNames(info); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> where = _id ? {_id} : {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authors = mongoSchema.Author.find(where) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fields.indexOf(<span class="hljs-string"><span class="hljs-string">'books.authors.name'</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span> ) { authors.populate({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'books'</span></span>, <span class="hljs-attr"><span class="hljs-attr">populate</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'book'</span></span>, <span class="hljs-attr"><span class="hljs-attr">populate</span></span>: {<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'authors'</span></span>, <span class="hljs-attr"><span class="hljs-attr">populate</span></span>: {<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'author'</span></span>}} } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fields.indexOf(<span class="hljs-string"><span class="hljs-string">'books.title'</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span> ) { authors.populate({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'books'</span></span>, <span class="hljs-attr"><span class="hljs-attr">populate</span></span>: {<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'book'</span></span>}}) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> authors.exec(); } };</code> </pre><br>  Untuk menentukan permintaan bidang mana yang berasal dari klien, perpustakaan graphql-list-fields digunakan.  Dan jika permintaan datang dengan objek bersarang, maka metode populate () dari perpustakaan luwak dipanggil. <br><br>  Sekarang mari kita bereksperimen dengan kueri.  Permintaan maksimum yang mungkin untuk implementasi kami: <br><br><pre> <code class="javascript hljs">{ author { _id name books { _id title authors { _id name } } } }</code> </pre><br>  akan dilakukan oleh 5 panggilan ke database: <br><br><pre> <code class="javascript hljs">authors.find({}, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) bookauthors.find({ <span class="hljs-attr"><span class="hljs-attr">author</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcab305b15d38f672357d"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcabd05b15d38f672357e"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcac405b15d38f672357f"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcad705b15d38f6723580"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcae305b15d38f6723581"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fedb94ad5435896079cf1"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fedbd4ad5435896079cf2"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) books.find({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcb7105b15d38f6723582"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) bookauthors.find({ <span class="hljs-attr"><span class="hljs-attr">book</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcb7105b15d38f6723582"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) authors.find({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcab305b15d38f672357d"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcad705b15d38f6723580"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} })</code> di': [ObjectId ( "5b0fcab305b15d38f672357d"), ObjectId ( "5b0fcabd05b15d38f672357e"), ObjectId ( "5b0fcac405b15d38f672357f"), ObjectId ( "5b0fcad705b15d38f6723580"), ObjectId ( "5b0fcae305b15d38f6723581"), ObjectId <code class="javascript hljs">authors.find({}, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) bookauthors.find({ <span class="hljs-attr"><span class="hljs-attr">author</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcab305b15d38f672357d"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcabd05b15d38f672357e"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcac405b15d38f672357f"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcad705b15d38f6723580"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcae305b15d38f6723581"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fedb94ad5435896079cf1"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fedbd4ad5435896079cf2"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) books.find({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcb7105b15d38f6723582"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) bookauthors.find({ <span class="hljs-attr"><span class="hljs-attr">book</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcb7105b15d38f6723582"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} }) authors.find({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: { <span class="hljs-string"><span class="hljs-string">'$in'</span></span>: [ ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcab305b15d38f672357d"</span></span>), ObjectId(<span class="hljs-string"><span class="hljs-string">"5b0fcad705b15d38f6723580"</span></span>) ] } }, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} })</code> </pre><br>  Seperti yang Anda lihat, fungsi mongoose.js - populate () - tidak menggunakan fitur mongodb yang relatif baru - $ lookup, tetapi membuat permintaan tambahan.  Tapi ini bukan masalah "SELECT N +1" sejak itu  Kueri baru tidak dibuat untuk setiap baris, tetapi untuk seluruh koleksi.  (Keinginan untuk memeriksa bagaimana fungsi mongoose.js populate () benar-benar berfungsi - dengan satu permintaan atau beberapa - adalah salah satu motif untuk memilih database non-relasional untuk contoh ini). <br><br>  Jika kami menggunakan permintaan minimalis: <br><br><pre> <code class="javascript hljs">{ author { _id name } }</code> </pre><br>  maka itu hanya akan membentuk satu panggilan ke database: <br><br><pre> <code class="javascript hljs"> authors.find({}, { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: {} })</code> </pre><br>  Ini, sebenarnya, saya cari.  Sebagai kesimpulan, saya akan mengatakan bahwa ketika saya mulai mencari solusi untuk masalah ini, saya menemukan perpustakaan yang sangat nyaman dan canggih yang memecahkan masalah ini.  Salah satunya, misalnya, yang sangat saya sukai, berdasarkan pada struktur basis data relasional, membentuk skema graphql dengan semua operasi yang diperlukan.  Namun, pendekatan ini dapat diterima jika graphql digunakan di sisi belakang aplikasi.  Jika Anda membuka akses ke layanan tersebut dari front-end aplikasi (yang saya butuhkan), maka ini mirip dengan menempatkan panel admin ke server database dalam akses terbuka, seperti  semua tabel tersedia di luar kotak <br><br>  Untuk kenyamanan pembaca, contoh kerja terletak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> . <br><br>  Tambahan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar joniks</a> <br><br>  Pengguna joniks di umpan telah merujuk ke perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/facebook/dataloader</a> .  Mari kita lihat bagaimana perpustakaan ini memungkinkan Anda untuk mengatasi masalah "SELECT N +1" <br><br>  Dengan perpustakaan ini, definisi tipe graphql Penulis akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Autors.js const graphql = require('graphql') const DataLoader = require('dataloader') const graphqlType = require('./index') const mongoSchema = require('../mongoSchema'); const bookLoader = new DataLoader(async ids =&gt; { const data = await mongoSchema.Book.find({ _id: { $in: ids }}).populate('authors').exec(); const books = data.reduce((obj, item) =&gt; (obj[item._id] = item) &amp;&amp; obj, {}) const response = ids.map(id =&gt; books[id]); return response; }); module.exports = new graphql.GraphQLObjectType({ name: 'authors', description: '', fields: () =&gt; ({ _id: {type: graphql.GraphQLString}, name: { type: graphql.GraphQLString, }, books: { type: new graphql.GraphQLList(graphqlType.Books), resolve: obj =&gt; obj.books &amp;&amp; obj.books.map(book =&gt; bookLoader.load(book.book)) } }) });</span></span></code> </pre><br><br>  Apa gunanya menggunakan pustaka ini: permintaan single bookLoader.load (id) diakumulasikan dan dikirim untuk diproses dengan array pengidentifikasi const bookLoader = DataLoader baru (id async = = {... <br>  Pada output, kita harus mengembalikan janji array atau array janji yang terletak dalam urutan yang sama dengan array input id. <br><br>  Sekarang kami dapat menulis ulang permintaan kami untuk Penulis sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// authors.js const graphql = require('graphql'); const getFieldNames = require('graphql-list-fields'); const graphqlType = require('../graphqlType'); const mongoSchema = require('../mongoSchema'); module.exports = { type: new graphql.GraphQLList(graphqlType.Authors), args: { _id: { type: graphql.GraphQLString } }, resolve: (_, {_id}, context, info) =&gt; { const fields = getFieldNames(info); const where = _id ? {_id} : {}; const authors = mongoSchema.Author.find(where).populate('books') return authors.exec(); } };</span></span></code> </pre><br><br>  Sebagai hasilnya, kami dapat meminta objek terkait dari tingkat bersarang yang sewenang-wenang tanpa khawatir tentang masalah SELECT N + 1 (meskipun dengan biaya panggilan tak bersyarat untuk mengisi () meskipun tidak diperlukan): <br><br><pre> <code class="javascript hljs">{ authors { _id name books { _id title authors { _id name books { _id title authors { _id name } } } } } }</code> </pre><br><br>  Tapi di sini Anda harus benar-benar mengerti bahwa jika kita beralih ke bekerja dengan server SQL, maka pada setiap tingkat objek bersarang akan ada satu permintaan agregat.  Pada saat yang sama, kadang-kadang diperlukan bahwa ini masih persis satu permintaan.  Tetapi Anda tidak dapat mencapai ini secara langsung menggunakan pustaka dataloader.  Contoh perubahan tersedia di cabang repositori data-loader. <br><br>  apapacy@gmail.com <br>  31 Mei 2018 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412847/">https://habr.com/ru/post/id412847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412835/index.html">Pengenalan Nano ke Internet dari Nano-Things. Bagian 1</a></li>
<li><a href="../id412837/index.html">ASUS memperkenalkan motherboard baru untuk penambangan GPU</a></li>
<li><a href="../id412839/index.html">Android-meetup SuperJob</a></li>
<li><a href="../id412843/index.html">Kesalahpahaman tentang pertempuran ruang angkasa</a></li>
<li><a href="../id412845/index.html">Klasifikasi emosi: di jantung komputasi emosional</a></li>
<li><a href="../id412849/index.html">TOP 8 buku yang layak dibaca musim panas ini</a></li>
<li><a href="../id412851/index.html">OutOfMemory dan GDI + terkadang tidak OutOfMemory sama sekali</a></li>
<li><a href="../id412853/index.html">Video dari Badoo Techleads Meetup # 3: Tentang Delegasi, Onboarding, Bisnis, dan Wawancara TI</a></li>
<li><a href="../id412855/index.html">Kerentanan CSRF masih relevan</a></li>
<li><a href="../id412859/index.html">Otentikasi dua faktor di Windows dan enkripsi data tanpa otoritas dan domain sertifikat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>