<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔕 🎬 🤝 Cómo Yandex creó la realidad aumentada en Maps para iOS. Experiencia usando ARKit 🎋 🙅🏻 ♣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quedan menos personas que puedan sorprenderse con la Realidad Aumentada (RA). Para algunos, esta tecnología está asociada con un juguete durante un pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo Yandex creó la realidad aumentada en Maps para iOS. Experiencia usando ARKit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421957/"><p>  Quedan menos personas que puedan sorprenderse con la Realidad Aumentada (RA).  Para algunos, esta tecnología está asociada con un juguete durante un par de horas.  Otros lo encuentran más práctico. </p><br><p>  Mi nombre es Dmitry, y estoy desarrollando Yandex.Maps para iOS.  Hoy les diré a los lectores de Habr cómo creamos el enrutamiento utilizando la realidad aumentada.  También aprenderá sobre las características del uso del marco ARKit, gracias a lo cual la introducción de la realidad aumentada ya no es una preocupación de solo especialistas en el campo de la visión por computadora. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  En 2009, la revista Esquire fue la primera de los medios en agregar soporte de realidad aumentada a su producto.  En la portada de la revista se publicó un código con el que se podía ver a Robert Downey Jr. "en vivo". </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  El uso de AR en la industria del entretenimiento no se limitó a esto.  Un vívido ejemplo fue el juego Pokemon Go, lanzado en 2016.  Para julio de ese año, se descargó más de 16 millones de veces.  El éxito del juego llevó a la aparición de numerosos clones con AR. </p><br><p>  Los eventos importantes en la industria de AR en los últimos años pueden considerarse los anuncios de Google Glass y Microsoft Hololens.  La aparición de tales dispositivos muestra el vector en el que se mueven las grandes empresas. </p><br><p>  Apple no fue la excepción.  En 2017, la compañía presentó el marco ARKit, cuya importancia para la industria difícilmente se puede sobreestimar.  Y hablaremos de ello con más detalle. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Características de ARKit, lo que facilita el uso de AR: </p><br><ul><li>  falta de necesidad de etiquetas especiales (marcadores), </li><li>  integración con marcos de gráficos 2D / 3D de Apple existentes: SceneKit, SpriteKit, Metal, </li><li>  alta precisión para determinar la posición y orientación del dispositivo en el espacio, </li><li>  No es necesario calibrar la cámara o los sensores. </li></ul><br><p>  Bajo el capó de ARKit hay un sistema de odometría visual inercial que combina datos con los subsistemas visual (cámara) e inercial (acelerómetro, giroscopio) del dispositivo para determinar la posición y el desplazamiento en el escenario.  El elemento de conexión de este sistema es el filtro de Kalman, un algoritmo que en cada momento selecciona la mejor de las lecturas de los dos subsistemas y nos la proporciona en forma de nuestra posición y orientación en el escenario.  ARKit también tiene una "comprensión" de la escena: podemos definir superficies horizontales y verticales, así como las condiciones de iluminación de la escena.  Por lo tanto, al agregar un objeto a la escena, podemos agregarle iluminación predeterminada, gracias a lo cual el objeto se verá más realista. </p><br><div class="spoiler">  <b class="spoiler_title">Por cierto</b> <div class="spoiler_text"><p>  Pronto, se lanzará la versión 2.0 del marco, en la que se agregarán nuevas características y se mejorará significativamente la precisión de posicionamiento. </p></div></div><br><p>  ARKit permitió a los desarrolladores integrar la realidad aumentada de alta calidad en sus aplicaciones mientras gastaban mucho menos esfuerzo.  Lo demostraremos usando el ejemplo de Yandex.Maps. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Enrutamiento con AR en Yandex.Maps </h2><br><p>  Por lo general, después del anuncio de la nueva versión de iOS, muchos equipos de Yandex se reúnen para discutir la posibilidad de introducir nuevas funciones en sus aplicaciones.  El equipo Yandex.Mart hizo lo mismo.  Dentro de un mes desde el momento del anuncio de ARKit, a menudo discutimos cómo implementarlo en Maps.  ¡Qué tipo de ideas no escuchamos el uno del otro!  Rápidamente, llegamos a la conclusión de que una de las soluciones más útiles y superficiales es el uso de la realidad aumentada en el enrutamiento. </p><br><p>  La elección de esta idea se debió al hecho de que muchos usuarios de tarjetas a menudo se encuentran con una situación en la que te encuentras en un área desconocida y necesitas decidir rápidamente a dónde ir.  El enfoque estándar para el usuario promedio del mapa es abrir la aplicación, construir una ruta peatonal y, girando en su lugar, determinar dónde moverse.  La idea de introducir la realidad aumentada en el enrutamiento de peatones es salvar al usuario de acciones innecesarias, mostrando de inmediato dónde debe moverse directamente sobre la imagen de la cámara. </p><br><p>  Primero, quiero decir algunas palabras sobre el enrutamiento.  ¿Qué pongo en este concepto?  Desde el punto de vista de la implementación en una aplicación móvil, este es un conjunto bastante estándar de pasos que permiten al usuario ir del punto A al punto B: </p><br><ul><li>  selección de puntos de partida y llegada, </li><li>  recibir una ruta en forma de un conjunto de puntos en coordenadas geográficas (latitud, longitud), </li><li>  mostrar en el mapa de la línea de ruta, </li><li>  acompañando al usuario con información adicional mientras se mueve a lo largo de la ruta. </li></ul><br><p>  No nos detendremos en los dos primeros puntos.  Solo puedo decir que obtenemos la ruta a través de nuestra biblioteca multiplataforma Yandex.Mapkit, que también está disponible para usted en forma de pod.  ¿Cómo difiere el enrutamiento de realidad aumentada del enrutamiento estándar en los mapas?  En primer lugar, la principal diferencia es un mapa casi completamente oculto.  El énfasis principal se pone en el área de la pantalla con la imagen de la transmisión de video de la cámara, en la que se superponen elementos visuales adicionales (marca de finalización, marca auxiliar e imagen de línea de ruta).  Cada uno de estos elementos visuales tiene su propia carga semántica y su propia lógica (cuándo y cómo debe mostrarse).  Consideraremos el papel de cada uno de estos elementos con más detalle más adelante, pero por ahora propongo considerar las tareas que teníamos antes: </p><br><ul><li>  aprender a colocar objetos en la escena ARKit, conociendo sus coordenadas geográficas, </li><li>  aprenda a dibujar la interfaz de usuario necesaria en una escena 3D con un rendimiento suficiente. </li></ul><br><p>  Necesitábamos convertir las coordenadas de los puntos de geográficas a las coordenadas en el escenario, seleccionar qué puntos mostrar y mostrar toda la IU necesaria en la parte superior de la imagen de la cámara en la posición correcta.  Pero todo resultó ser un poco más complicado de lo que parecía a primera vista. </p><br><p>  Antes de comenzar a implementar las funciones directamente, uno de mis colegas recibió la tarea de hacer un prototipo que mostrara la posibilidad (o imposibilidad) de implementar una funcionalidad similar con un conjunto accesible de herramientas.  Durante dos semanas, vimos a San Sanych arando los espacios abiertos del espacio abierto y los alrededores cercanos de nuestra oficina con un teléfono en la mano y mirando el mundo que nos rodea a través del prisma de la cámara.  Como resultado, obtuvimos un prototipo funcional que mostraba cada punto de la ruta como una marca en el escenario con una distancia a la misma.  Con la ayuda de este prototipo, fue posible, bajo una combinación exitosa de circunstancias, ir del trabajo al metro y casi nunca perderse.  Pero en serio, confirmó la posibilidad de implementar la funcionalidad prevista.  Pero quedaba una serie de tareas que nuestro equipo aún tenía que resolver. </p><br><p>  Todo comenzó con el estudio de las herramientas.  En ese momento, solo una persona en el equipo tenía experiencia trabajando con gráficos 3D.  Echemos un vistazo rápido a las herramientas con las que tendrá que lidiar cualquiera que piense en implementar tales ideas con ARKit. </p><br><h2 id="instrumenty-i-api">  Herramientas y API </h2><br><p>  El trabajo principal de renderizar objetos es crear y administrar objetos de escena del framework SceneKit.  Con el advenimiento de ARKit, la clase ARSCNView (el descendiente de la clase SCNView, la clase base para trabajar con la escena en SceneKit) se puso a disposición del desarrollador, que resuelve la mayoría de las tareas de integración de ARKit y SceneKit que requieren mucho tiempo, a saber: </p><br><ul><li>  sincronización de la posición del teléfono en el espacio con la posición de la cámara en el escenario, </li><li>  el sistema de coordenadas de la escena coincide con el sistema de coordenadas ARKit, </li><li>  Como fondo de la escena, se utiliza la transmisión de video de la cámara del dispositivo. </li></ul><br><p>  El objeto ARSCNView también proporciona al desarrollador un objeto de sesión de realidad aumentada que puede iniciarse con la configuración necesaria, detenerse o suscribirse a varios eventos utilizando el objeto delegado. </p><br><p>  Para agregar objetos a la escena, se utilizan herederos o directamente objetos SCNNode.  Esta clase representa una posición (vector tridimensional) en el sistema de coordenadas de su padre.  Por lo tanto, obtenemos un árbol de objetos en la escena con una raíz en un objeto especial: el nodo raíz de nuestra escena.  Todo aquí es muy similar a la jerarquía de objetos UIView en UIKit.  Los objetos SCNNode se pueden mostrar en el escenario cuando agregan material e iluminación. </p><br><p>  Para agregar realidad aumentada a una aplicación móvil, también debe conocer los objetos principales de la API de ARKit.  El principal es el objeto de la sesión de realidad aumentada: ARSession.  Este objeto lleva a cabo el procesamiento de datos y es responsable del ciclo de vida de la sesión de realidad aumentada.  El propósito de este artículo no es volver a contar la documentación de ARKit y SceneKit, por lo que no escribiré sobre todos los parámetros de configuración disponibles de la sesión de realidad aumentada, sino que me centraré en uno de los parámetros más importantes de la configuración de la sesión de realidad aumentada para aplicaciones de navegación: worldAlignment.  Este parámetro determina la dirección de los ejes de la escena en el momento de la inicialización de la sesión.  En general, al inicializar una sesión de realidad aumentada, ARKit crea un sistema de coordenadas con un comienzo en un punto que coincide con la posición actual del teléfono en el espacio, y dirige el eje de este sistema según el valor de la propiedad woldAlignment.  En nuestra implementación, se utiliza el valor gravityAndHeading, lo que implica que los ejes se direccionarán de la siguiente manera: el eje Y, en la dirección opuesta a la gravedad, el eje Z, hacia el sur, y el eje X, hacia el este. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="alineación-mundo-gravedad-y-rumbo"></p><br><p>  Con una buena combinación de circunstancias, los ejes X / Z se alinearán con las direcciones hacia el sur / este, pero, debido a errores en las lecturas de la brújula, los ejes se pueden dirigir en un cierto ángulo a la dirección descrita en la documentación.  Este es uno de los problemas con los que tuvimos que lidiar, pero más sobre eso más adelante. </p><br><p>  Ahora que hemos examinado las herramientas básicas, resumamos: mapear una ruta usando SceneKit es agregar objetos SCNNode a la escena en las posiciones obtenidas mediante la conversión de coordenadas geográficas a coordenadas de escena.  Antes de hablar sobre la conversión de coordenadas y, en general, sobre la colocación de objetos en la escena, hablemos sobre los problemas de renderizar elementos de la interfaz de usuario, suponiendo que sepamos la posición de los objetos en el escenario. </p><br><h1 id="metka-finisha">  Marca final </h1><br><p>  El principal elemento visual del enrutamiento peatonal con realidad aumentada es la marca de llegada, que muestra el punto final de la ruta.  También sobre la marca, le mostramos al usuario la distancia hasta el punto final de la ruta. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="acabado-placemark-resumen"></p><br><h2 id="razmer">  Tamaño </h2><br><p>  Cuando se nos mostró por primera vez el diseño de esta etiqueta, primero prestamos atención a los requisitos para el tamaño de esta etiqueta.  No obedecieron las reglas de proyección en perspectiva.  Explicaré que en los motores tridimensionales que se utilizan para crear, por ejemplo, juegos de computadora, el "aspecto" se modela utilizando la proyección en perspectiva.  De acuerdo con las reglas de proyección en perspectiva, los objetos distantes se representan en una escala menor, y las líneas paralelas generalmente no son paralelas.  Por lo tanto, el tamaño de proyección del objeto en el plano de la pantalla cambia linealmente (disminuye) a medida que la cámara se aleja del objeto en la escena.  De la descripción de los diseños se deduce que el tamaño de la marca en la pantalla tiene un tamaño fijo (máximo) cuando se elimina menos de 50 m, luego disminuye linealmente de 50 ma 2 km, después de lo cual el tamaño mínimo permanece sin cambios.  Tales requisitos obviamente se deben a la conveniencia del usuario.  Permiten al usuario nunca perder el punto final de la ruta de la vista, por lo que el usuario siempre tendrá una idea de dónde moverse. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="acabado-placemark-tamaño-demandas"></p><br><p>  Teníamos que entender cómo podríamos meternos en el mecanismo de proyección SceneKit que funcionaba de acuerdo con ciertas reglas.  Quiero señalar de inmediato que teníamos alrededor de dos semanas para hacer todo sobre todo, por lo que simplemente no había tiempo para llevar a cabo un análisis en profundidad de varios enfoques para resolver los problemas planteados.  Ahora, analizar nuestras decisiones, evaluarlas es mucho más simple, y podemos concluir que la mayoría de las decisiones tomadas fueron correctas.  El requisito de tamaño, de hecho, fue el primer escollo.  Todos los problemas descritos a continuación se pueden resolver utilizando SceneKit y UIKit.  Traté de explicar en detalle cómo resolver cada uno de los problemas usando ambos enfoques.  Qué enfoque usar depende de usted. </p><br><p>  Imaginemos que decidimos implementar una etiqueta de acabado usando SceneKit.  Si tenemos en cuenta que la etiqueta de acuerdo con los diseños debería haber parecido un círculo en la pantalla, entonces resulta obvio que en SceneKit el objeto de la etiqueta debería ser una esfera (ya que la proyección de la esfera en cualquier plano es un círculo).  Para que la proyección tenga un cierto radio en la pantalla, definido en los requisitos de los diseñadores, es necesario conocer el radio de la esfera en cada momento del tiempo.  Por lo tanto, al colocar una esfera de cierto radio en la escena en un determinado punto y actualizar constantemente su radio al acercarse o alejarse, obtendremos una proyección en la pantalla del tamaño requerido en cualquier momento.  El algoritmo para determinar el radio de la esfera en un punto arbitrario en el tiempo es el siguiente: </p><br><ol><li>  definir la posición del objeto en el escenario: el centro de la esfera, </li><li>  encuentre la proyección de este punto en el plano de la pantalla (usando la API de SceneKit), </li><li>  Para determinar el tamaño requerido de la marca en la pantalla, encontramos la distancia desde la cámara hasta el centro de la esfera en el escenario, </li><li>  determinamos el tamaño requerido en la pantalla por la distancia al objeto usando las reglas descritas en el diseño, </li><li>  sabiendo el tamaño de la marca en la pantalla (diámetro del círculo), elegimos cualquier punto en este círculo, </li><li>  hacer la proyección inversa (unprojectPoint) del punto seleccionado, </li><li>  Encontramos la longitud del vector desde el punto recibido en el escenario hasta el centro de la esfera. </li></ol><br><p>  El valor obtenido de la longitud del vector será el radio deseado de la esfera. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="acabado-placemark-size-solution-scenekit"></p><br><p>  En el momento de la implementación, no pudimos encontrar una manera de determinar el tamaño del objeto en la escena, y decidimos dibujar la marca de meta usando UIKit.  En este caso, el algoritmo repite los pasos 1-5, después de lo cual se dibuja un círculo del tamaño deseado en la pantalla con el centro en el punto obtenido en el paso 2 utilizando las herramientas UIKit.  Un ejemplo de implementación de una etiqueta usando UIKit se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Algunas palabras sobre el código</b> <div class="spoiler_text"><p>  Al final del artículo, proporcioné varios enlaces a materiales útiles y simplemente interesantes, incluidos ejemplos, en los que puede ver en detalle el código real que resuelve los problemas presentados en el artículo e implementa los algoritmos presentados.  El principal interés en mi opinión es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prototipo de enrutamiento peatonal</a> , que reúne toda la funcionalidad, con la excepción del mecanismo de ajuste del eje, que se describe en detalle a continuación. </p><br><p>  El código anterior no pretende ser óptimo, completo y de calidad de producción =) </p></div></div><br><p>  La diferencia entre usar SceneKit y UIKit en este caso también radica en el hecho de que al implementar en SceneKit, el objeto SCNNode para el punto final de la ruta (marca de finalización) se creará con material y geometría, ya que debe ser visible, mientras se usa UIKit necesitamos el objeto nodo exclusivamente para buscar la proyección en el plano de la pantalla (para determinar el centro de la marca en la pantalla).  En este caso, no es necesario agregar geometría y material.  Tenga en cuenta que la distancia desde la cámara al objeto SCNNode del punto final de la ruta se puede encontrar de dos maneras: utilizando las coordenadas geográficas de los puntos o como la longitud del vector entre los puntos en la escena.  Esto es posible porque el objeto de la cámara es una propiedad SCNNode.  Para obtener el nodo de la cámara, debe consultar la propiedad pointOfView de nuestra escena. </p><br><p>  Aprendimos a determinar el radio del nodo de la marca de finalización en un punto arbitrario en el tiempo cuando se implementa en SceneKit y la posición de la vista de la marca de finalización si se implementa en UIKit.  ¿Queda por entender cuándo es necesario actualizar estos valores?  Este lugar es el método de objeto SCNSceneRendererDelegate: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  Este método se llama después de cada cuadro de escena renderizado.  Al actualizar los valores de propiedad en el cuerpo de este método, obtenemos una etiqueta de finalización que se muestra correctamente. </p><br><h2 id="animaciya">  Animación </h2><br><p>  Después de que la marca de finalización apareciera en dev, procedimos a agregar animación ondulada a esta marca.  Creo que para la mayoría de los desarrolladores de iOS crear animaciones no es gran cosa.  Pero al pensar en el método de implementación, nos encontramos con el problema de actualizar constantemente el marco de nuestra vista.  Tenga en cuenta que en la mayoría de los casos, las animaciones se agregan a los objetos estáticos de UIView.  Un problema similar: una actualización constante del radio de la geometría del nodo surge cuando se implementa usando SceneKit.  El hecho es que la animación pulsante se reduce a la animación del tamaño del círculo (para UIKit) y el radio de la esfera (para SceneKit).  Sí, sí, sabemos que en UIKit este tipo de animación se puede hacer usando CALayer, pero para simplificar la narración, decidí considerar este tema simétricamente para los dos marcos.  Considere una implementación en UIKit.  Si agrega código que anima el mismo cuadro al código existente que actualiza el cuadro de vista, la animación se interrumpirá al establecer explícitamente el cuadro.  Por lo tanto, como solución a este problema, decidimos usar la animación de la propiedad transform.scale.xy del objeto UIView.  Al implementar usando SceneKit, tendrá que agregar animación de la propiedad de escala al objeto SCNNode.  Lo bueno de usar SceneKit en este caso es el hecho de que es totalmente compatible con CoreAnimation, por lo que no es necesario aprender una nueva API.  El código que implementa una animación similar a la animación de etiquetas en Yandex.Maps se parece a esto: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Cartelera </h2><br><p>  Al comienzo del artículo, mencioné una valla publicitaria con una distancia al punto final de la ruta, que, en esencia, es una etiqueta con texto siempre ubicado sobre la marca de meta.  Por tradición, describiré los problemas inherentes a las implementaciones en UIKit y SceneKit, explicando las posibles soluciones para cada uno de los marcos. </p><br><p>  Comencemos con UIKit.  En este caso, la cartelera es un UILabel normal, en el que el texto se actualiza constantemente y muestra la distancia hasta el punto final de la ruta.  Veamos el problema al que nos enfrentamos. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="acabado-placemark-billboard-problem-uikit"></p><br><p>  Si configura una etiqueta en un marco y luego gira el teléfono, veremos que el marco no cambia (sería extraño si no fuera así).  Al mismo tiempo, nos gustaría que la etiqueta permanezca paralela al plano de la tierra. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="acabado-placemark-billboard-deseado-uikit"></p><br><p>  Creo que todos entienden que al cambiar la orientación del dispositivo, debemos girar la etiqueta, pero ¿en qué ángulo?  Si enciende la imaginación e imagina mentalmente todos los ejes de los sistemas de coordenadas y los vectores involucrados en este proceso, podemos concluir que el ángulo de rotación es igual al ángulo entre el eje x del sistema de coordenadas UIKit y la proyección del eje X del sistema de coordenadas SceneKit en el plano de la pantalla. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="acabado-placemark-billboard-solution-uikit"></p><br><p>  Una tarea simple que una vez más demostró la utilidad del curso de geometría escolar. </p><br><p>  Cuando implemente la marca de acabado con SceneKit, lo más probable es que necesite renderizar la cartelera con distancia usando las herramientas de SceneKit, lo que significa que definitivamente tendrá la tarea de hacer que el objeto SCNNode esté siempre orientado hacia la cámara.  Creo que el problema se volverá más claro si miras la imagen: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="acabado-placemark-billboard-problem-scenekit"></p><br><p>  Este problema se resuelve utilizando la API SCNBillboardConstraint.  Al agregar una constante con un eje Y libre a la colección de restricciones de nuestro nodo, obtenemos un nodo que gira alrededor del eje Y de su sistema de coordenadas, para estar siempre orientado hacia la cámara.  La única tarea del desarrollador es colocar este nodo a la altura correcta para que la cartelera con la distancia sea siempre visible para el usuario. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Asistente de etiqueta </h1><br><p>  Una de las características principales del enrutamiento peatonal con realidad aumentada, dentro del equipo, consideramos una etiqueta auxiliar: un elemento visual especial que aparece en la pantalla en el momento en que el punto final de la ruta abandona la zona de visibilidad y muestra al usuario dónde girar el teléfono para que la etiqueta aparezca en la pantalla línea de meta </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="finish-placemark-hint-overview"></p><br><p>  Estoy seguro de que muchos de los lectores han encontrado funcionalidades similares en algunos juegos, la mayoría de las veces tiradores.  Qué sorpresa fue nuestro equipo cuando vimos este elemento de interfaz de usuario en los diseños.  Debo decir de inmediato que la implementación correcta de una función de este tipo puede requerir más de una hora de experimentación por parte de usted, pero el resultado final vale la pena.  Comenzamos definiendo requisitos, a saber: </p><br><ul><li>  para cualquier orientación del dispositivo, la etiqueta se mueve a lo largo de los bordes de la pantalla, </li><li>  Si el usuario ha girado 180 grados hasta el punto final de la ruta, la etiqueta se muestra en la parte inferior de la pantalla, </li><li>  en cada momento, girar hacia la marca debería ser el giro más corto hasta el punto final de la ruta. </li></ul><br><p>  Después de describir los requisitos, comenzamos la implementación.  Casi de inmediato, llegamos a la conclusión de que el renderizado se haría con UIKit.  El principal problema con la implementación fue la determinación del centro de esta etiqueta en cada punto de tiempo.  Después de considerar la marca final, dicha tarea no debería causar dificultades, por lo que no me detendré en su solución en detalle.  En el artículo solo daré una descripción del algoritmo para elegir el centro de la etiqueta auxiliar, y el código fuente se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Algoritmo del centro de búsqueda Algoritmo de búsqueda: </p><br><ol><li>  cree un objeto SCNNode para el punto final de la ruta con una posición en la escena obtenida de la coordenada geográfica del punto, </li><li>  encuentra la proyección de un punto en el plano de la pantalla, </li><li>  encuentre la intersección del segmento desde el centro de la pantalla hasta el punto de la proyección encontrada con los segmentos de los límites de la pantalla en el sistema de coordenadas de la pantalla. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="acabado-placemark-sugerencia-solución"></p><br><p>  El punto de intersección encontrado es el centro deseado de la marca auxiliar.  Por analogía con el código que actualiza los parámetros de la etiqueta de finalización, colocamos el código que representa la etiqueta auxiliar en el método delegado que ya se mencionó anteriormente. </p><br><h1 id="poliliniya-marshruta">  Polilínea de ruta </h1><br><p>  Después de haber construido una ruta y haber visto la marca de llegada en la pantalla, el usuario puede alcanzarla orientando solo en la dirección de la marca, pero la ruta se llama así porque muestra la ruta al usuario.  Pensamos que sería muy extraño reducir la funcionalidad del enrutamiento peatonal, excluyendo la visualización de ruta de la versión AR.  Para visualizar la línea de ruta, se decidió mostrar un conjunto de flechas moviéndose a lo largo de ella.  En este caso, los diseñadores estaban satisfechos de que las flechas prácticamente desaparecerían al alejarse (el tamaño estaría determinado por las reglas de proyección en perspectiva), y se decidió usar SceneKit para la implementación. </p><br><p>  Antes de proceder a describir la implementación, es importante tener en cuenta que, por diseño, las flechas deberían haber estado a una distancia de 3 m entre sí.  Si estima el número de objetos (flechas) que deben representarse con una ruta de aproximadamente 1 km de largo, entonces serán aproximadamente 330 piezas.  Al mismo tiempo, a cada objeto se le agrega una animación de movimiento a lo largo de su parte de la ruta.  Tenga en cuenta que las flechas alejadas de la posición de la cámara en el escenario a una distancia de aproximadamente 100-150 metros son prácticamente invisibles debido a su pequeño tamaño.  Habiendo considerado estos factores, se decidió no mostrar todos los objetos, sino mostrar solo aquellos que se eliminan del usuario a no más de 100 metros a lo largo de la línea de ruta, actualizando periódicamente el conjunto de objetos visualizados.  Mostramos una cantidad suficiente de información visual, eliminando cálculos innecesarios de SceneKit y ahorrando la batería del usuario. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="ruta-polilínea-resumen"></p><br><p>  Veamos los pasos principales que tuvimos que realizar para obtener el resultado final: </p><br><ul><li>  selección de la sección de ruta para la que mostraremos las primitivas, </li><li>  creación de modelos 3D, </li><li>  creación de animación </li><li>  actualizar al conducir por una ruta. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Seleccionar una parcela para mostrar </h2><br><p>  Como señalé anteriormente, no mostramos flechas para toda la ruta, sino que seleccionamos la sección óptima para mostrar.  La elección de un segmento en un punto arbitrario en el tiempo consiste en encontrar el segmento de ruta más cercano (la ruta es una secuencia de segmentos / segmentos) a la posición actual del usuario y seleccionar segmentos desde el punto más cercano al punto final de la ruta hasta que su longitud total exceda los 100 metros. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="ruta-polilínea-ruta-selección-parte"></p><br><h2 id="sozdanie-3d-modeli">  Creación de modelos 3D </h2><br><p>  Consideremos con más detalle el proceso de creación de un modelo 3D.  En la mayoría de los casos, todo lo que necesita hacer para crear un modelo 3D simple (como nuestra flecha) es abrir cualquier editor 3D, dedicar un tiempo a dominarlo y crear este modelo en él.  En caso de que los muchachos de su equipo tengan experiencia en modelado 3D, o tengan tiempo para aprender, por ejemplo, 3DMax (y debe comprarse), entonces es increíblemente afortunado.  Desafortunadamente, en el momento de la implementación de esta función, ninguno de nosotros tenía experiencia especial, no había tiempo libre para la capacitación, por lo que tuvimos que hacer un modelo, por así decirlo, con medios improvisados.  Me refiero a la descripción del modelo en el código.  Todo comenzó con la presentación de un modelo 3D en forma de triángulos.  Luego tuvimos que encontrar manualmente las coordenadas de los vértices de estos triángulos en el sistema de coordenadas del modelo, y luego crear una matriz de índices de los vértices de los triángulos.  Con estos datos a nuestra disposición, podemos crear la geometría necesaria directamente en SceneKit.  Puede crear un modelo similar al nuestro, por ejemplo, así: </p><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SCNGeometry</span></span></span></span> { convenience init(material: SCNMaterial) { let vertices: [<span class="hljs-type"><span class="hljs-type">SCNVector3</span></span>] = [ <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">11</span></span> ] let sources: [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>] = [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>(<span class="hljs-type"><span class="hljs-type">vertices</span></span>: <span class="hljs-type"><span class="hljs-type">vertices</span></span>)] let indices: [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span><span class="hljs-number"><span class="hljs-number">32</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] let geometryElements = [<span class="hljs-type"><span class="hljs-type">SCNGeometryElement</span></span>(<span class="hljs-type"><span class="hljs-type">indices</span></span>: <span class="hljs-type"><span class="hljs-type">indices</span></span>, <span class="hljs-type"><span class="hljs-type">primitiveType</span></span>: <span class="hljs-type"><span class="hljs-type">.triangles</span></span>)] self.init(sources: sources, elements: geometryElements) self.materials = [<span class="hljs-type"><span class="hljs-type">material</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func arrowBlue() -&gt; SCNGeometry { let material = SCNMaterial() material.diffuse.contents = UIColor.blue material.lightingModel = .constant <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ARSCNArrowGeometry(material: material) }</code> </pre> <br><p>  El resultado final se ve así: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="ruta-polilínea-flecha-modelo"></p><br><h2 id="animaciya-linii-marshruta">  Animación de línea de ruta </h2><br><p>  El siguiente paso en el camino para mostrar una línea animada de la ruta fue la etapa de creación de la animación en sí.  Pero, ¿cuál es la forma de realizar la animación, que en la forma final parece que la flecha comienza su movimiento en el punto inicial de la sección seleccionada de la ruta y "flota" a lo largo de la ruta hasta el final de esta sección? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  No describiré todas las formas posibles de crear tal animación, sino que me detendré en más detalles sobre el método que hemos elegido.  Después de seleccionar una sección de la ruta, la dividimos en secciones de la misma longitud: secciones de la animación de una flecha.  Cada sección de este tipo está resaltada en color y tiene una longitud igual a la distancia entre las flechas. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="ruta-polilínea-ruta-partición-partición"></p><br><p>  Al comienzo de cada sección, creamos el objeto SCNNode de la flecha, cuya animación consiste en moverse a lo largo de su sección. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="ruta-polilínea-flechas-posición-inicial"></p><br><p>  Como puede ver, la sección de animación a veces consta de un segmento, a veces de dos o más.  Todo depende del paso (en nuestro caso, 3 metros) entre las flechas y las coordenadas de los puntos que componen la ruta. </p><br><p>  Una animación de flecha es una secuencia de dos pasos: </p><br><ul><li>  Apariencia en la posición inicial con el ángulo de rotación inicial, </li><li>  Una secuencia de desplazamientos a lo largo de segmentos con rotaciones en los puntos de conexión de los segmentos. </li></ul><br><p>  Esquemáticamente, se ve así: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="ruta-polilínea-flecha-anitaion-pasos"></p><br><p>  Nos pareció la forma más fácil de implementar una animación de este tipo utilizando la API SCNAction, una API declarativa que le permite crear convenientemente animaciones secuenciales, grupales y repetitivas.  Puede ver la implementación con más detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Debido al hecho de que cada flecha termina su animación en el punto de inicio de la sección de animación de la siguiente flecha, se crea la impresión de movimiento continuo de la flecha a lo largo de toda la sección seleccionada de la ruta. </p><br><p>  Sobre esto, propongo completar la consideración de varios aspectos de la representación y pasar a la parte principal: determinar las posiciones de los objetos en el escenario mediante las coordenadas geográficas de los objetos. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Determinar la posición de un objeto en la escena. </h1><br><p>  Comenzamos la conversación sobre la determinación de la posición de un objeto en la escena considerando los sistemas de coordenadas, cuya conversión debe llevarse a cabo.  Solo hay 2 de ellos: </p><br><ul><li>  coordenadas geodésicas (o geográficas para simplificar): la posición de los objetos (puntos de ruta) en el mundo real, </li><li>  Coordenadas cartesianas: la posición de los objetos en la escena (en ARKit).  Recuerde que el sistema de coordenadas de la escena coincide con el sistema de coordenadas ARKit (en el caso de utilizar ARSCNView). </li></ul><br><p>  La traducción de un sistema de coordenadas a otro y viceversa es posible debido al hecho de que las coordenadas en ARKit se miden en metros, y el desplazamiento entre dos coordenadas geodésicas se puede traducir con gran precisión en el desplazamiento en metros a lo largo de los ejes X y Z del sistema de coordenadas ARKit en pequeñas compensaciones.  Permítame recordarle que las coordenadas geodésicas son puntos con cierta longitud y latitud. </p><br><p>  Recordemos conceptos tan importantes del curso de la geografía como paralelos y meridianos, y sus propiedades básicas: </p><br><ul><li>  <strong>Paralelo</strong> es una línea con un valor de grado de latitud.  Las longitudes de los diversos paralelos son diferentes. </li><li>  <strong>Meridiano</strong> : una línea con un valor de grado de longitud.  Las longitudes de todos los meridianos son iguales. </li></ul><br><p>  Ahora veamos cómo puedes calcular el desplazamiento en metros, entre dos coordenadas geodésicas con coordenadas. <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en línea (lat_1, lon_1)">  y <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en línea (lat_2, lon_2)">  : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta lon \ times metersInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ times metersInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="metersInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {lands} \ cos \ left (\ alpha \ right)} {360 ^ {°}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="metersInLatDegree = \ frac {2 \ pi R_ \ text {lands}} {360 ^ {°}}"></p><br><div class="spoiler">  <b class="spoiler_title">Explicación</b> <div class="spoiler_text"><p>  El desplazamiento en coordenadas geodésicas se asigna linealmente a metros solo en pequeños desplazamientos.  En grandes desplazamientos, es necesario tomar honestamente la integral. </p></div></div><br><p>  Ahora que somos capaces de traducir el desplazamiento de un sistema de coordenadas a otro, necesitamos decidir sobre un punto de referencia, un punto para el cual las coordenadas geográficas y las coordenadas en ARKit (coordenadas en el escenario) son conocidas al mismo tiempo.  Una vez encontrado ese punto, podemos determinar la coordenada de cualquier objeto en el escenario, conociendo su coordenada geográfica y utilizando las fórmulas anteriores. </p><br><p>  Para mayor claridad, considere un ejemplo: <br>  Al comienzo de la sesión de realidad aumentada, le pedimos a CoreLocation nuestra coordenada geográfica y la recibimos al instante: <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ en línea (lat_0, lon_0)">  .  Recordando el hecho de que el origen del sistema de coordenadas ARKit está al comienzo de la sesión en el punto donde se encuentra el dispositivo, obtuvimos el punto de referencia, ya que conocemos la coordenada geográfica y la coordenada en el escenario <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ inline (x_0, y_0, z_0) = (0,0,0)">  .  Necesitamos encontrar la coordenada en la escena del objeto con una coordenada geográfica <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en línea (lat_1, lon_1)">  .  Para hacer esto, encuentre el desplazamiento en metros entre la coordenada geográfica del objeto y la coordenada geográfica de nuestro punto de referencia, y luego agregue el desplazamiento encontrado a la coordenada en la escena del punto de referencia.  La coordenada resultante en la escena será la deseada. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="coordenadas-conversión-objeto-posición-en-escena"></p><br><p>  Observo que la posición en la escena encontrada de esta manera corresponderá a la posición del objeto en el mundo real solo si el eje X / Z del sistema de coordenadas de la escena está alineado con las direcciones hacia el Sur / Este.  La alineación del eje, en teoría, debe lograrse configurando el indicador worldAlignment en gravitiAndHeading.  Pero como dije al comienzo de la publicación, esto está lejos de ser siempre el caso. </p><br><p>  Consideremos con más detalle el método para determinar el punto de referencia.  Para hacer esto, presentamos el concepto de <strong>estimación</strong> : un conjunto de coordenadas geográficas y coordenadas en el escenario. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="coordenadas-conversión-estadísticas-definición"></p><br><p>  El método propuesto anteriormente para determinar el punto de referencia no siempre se puede utilizar.  En el momento del inicio de una sesión de realidad aumentada, una solicitud de CLLocation de un usuario puede no ejecutarse inmediatamente, además, la precisión de la coordenada obtenida puede tener un gran error.  Sería más correcto pedirle a SceneKit una posición en el escenario en el momento en que obtengamos el valor de CoreLocation.  En este caso, los componentes de la estimación resultante se obtienen al mismo tiempo, y tenemos la oportunidad de utilizar cualquiera de las estimaciones como punto de referencia.  Cuando se trabaja con ARKit, el error de compensación se acumula con el tiempo, por lo que Apple no recomienda usar ARKit como herramienta de navegación. </p><br><p>  Cuando decidimos implementar el enrutamiento peatonal con realidad aumentada, investigamos un poco las soluciones que existían en ese momento, utilizando ARKit para tareas similares, y encontramos el marco ARKit + CoreLocation.  La idea de este marco era que gracias a ARKit podemos determinar con mayor precisión la ubicación del usuario que cuando se usa exclusivamente CoreLocation. </p><br><p>  Concepto ARKit + CoreLocation: </p><br><ul><li>  al recibir CLLocation de CLLocationManager <br><ul><li>  solicitar una posición en la escena usando scene.pointOfView.worldPosition </li><li>  guarde este par de coordenadas (estimación) en el búfer </li></ul></li><li>  obtener la ubicación exacta si es necesario <br><ul><li>  elige la mejor estimación </li><li>  calcular el desplazamiento entre la posición actual en el escenario y la posición en el escenario de la mejor estimación </li><li>         </li></ul></li></ul><br><p>          ,   ,   CoreLocation,       . </p><br><p>   ,   « ».   ,      . </p><br><p>     (,    ): </p><br><ul><li>    (  horizontalAccuracy), </li><li>       , </li><li>        100    . </li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Por qué</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit –        ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\ en línea t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en línea (lat_1, lon_1)">      — <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\ en línea (x_1, z_1)"> .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ en línea t_2">      CLLocationManager — <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en línea (lat_2, lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\ en línea (x_2, z_2)">  en consecuencia </p><br><p>      ARKit — <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\ en línea (\ Delta x, \ Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ en línea t_2"> .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en línea (lat_2, lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\ inline (lat_ {2calc}, lon_ {2calc})"> .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="coordenadas-conversión-corrección-ángulo-problema"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\ inline initialBearing (1,2)">  y <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\ inline initialBearing (1,2_ {calc})"> ,  <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\ en línea 2_ {calc}"> –    2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\ inline initialBearing (a, b)">   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="coordenadas-conversión-corrección-ángulo-cálculo-por-par"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="coordenadas-conversión-corrección-ángulo-error-cálculo"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  Por ejemplo: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Prueba </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="corrección-ángulo-cálculo-alg-testing-street-before-corrección"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="corrección-ángulo-cálculo-alg-testing-street-after-corrección"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="corrección-ángulo-cálculo-alg-testing-street-after-last-correct"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="corrección-ángulo-cálculo-alg-testing-tracks"></p><br><p>              —     gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  En lugar de una conclusión </h1><br><p>      Slack, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  Enlaces utiles </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> </li><li> ARKit+CoreLocation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   ARKit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> AR   </a> </li></ul><br><p>      ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> .</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421957/">https://habr.com/ru/post/es421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421945/index.html">Google y Mastercard concluyen un acuerdo secreto para rastrear compras en tiendas</a></li>
<li><a href="../es421947/index.html">Bienvenido a Android Devs Meetup 8 de septiembre</a></li>
<li><a href="../es421949/index.html">Escuadrón Suicida Cómo reclutamos a los desarrolladores junior más feroces</a></li>
<li><a href="../es421953/index.html">Summ3r 0f h4ck: prácticas de verano en Digital Security</a></li>
<li><a href="../es421955/index.html">El Senado no quiere robots distraídos por la cerveza. ¿Y sobre qué más escribir el viernes?</a></li>
<li><a href="../es421959/index.html">Qué hacer cuando "esto" pierde el enlace de contexto</a></li>
<li><a href="../es421961/index.html">Crear una demostración para un teléfono antiguo - AONDEMO</a></li>
<li><a href="../es421963/index.html">Contabilidad y contabilidad: su papel en la organización</a></li>
<li><a href="../es421965/index.html">"Además del trabajo, sigo trabajando" - 10 preguntas para el programador, tercera edición</a></li>
<li><a href="../es421967/index.html">Juguete infantil sobre elementos lógicos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>