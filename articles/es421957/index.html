<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游댓 游꿟 游뱋 C칩mo Yandex cre칩 la realidad aumentada en Maps para iOS. Experiencia usando ARKit 游꿂 游뗸游낕 鮫勇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quedan menos personas que puedan sorprenderse con la Realidad Aumentada (RA). Para algunos, esta tecnolog칤a est치 asociada con un juguete durante un pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C칩mo Yandex cre칩 la realidad aumentada en Maps para iOS. Experiencia usando ARKit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421957/"><p>  Quedan menos personas que puedan sorprenderse con la Realidad Aumentada (RA).  Para algunos, esta tecnolog칤a est치 asociada con un juguete durante un par de horas.  Otros lo encuentran m치s pr치ctico. </p><br><p>  Mi nombre es Dmitry, y estoy desarrollando Yandex.Maps para iOS.  Hoy les dir칠 a los lectores de Habr c칩mo creamos el enrutamiento utilizando la realidad aumentada.  Tambi칠n aprender치 sobre las caracter칤sticas del uso del marco ARKit, gracias a lo cual la introducci칩n de la realidad aumentada ya no es una preocupaci칩n de solo especialistas en el campo de la visi칩n por computadora. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  En 2009, la revista Esquire fue la primera de los medios en agregar soporte de realidad aumentada a su producto.  En la portada de la revista se public칩 un c칩digo con el que se pod칤a ver a Robert Downey Jr. "en vivo". </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  El uso de AR en la industria del entretenimiento no se limit칩 a esto.  Un v칤vido ejemplo fue el juego Pokemon Go, lanzado en 2016.  Para julio de ese a침o, se descarg칩 m치s de 16 millones de veces.  El 칠xito del juego llev칩 a la aparici칩n de numerosos clones con AR. </p><br><p>  Los eventos importantes en la industria de AR en los 칰ltimos a침os pueden considerarse los anuncios de Google Glass y Microsoft Hololens.  La aparici칩n de tales dispositivos muestra el vector en el que se mueven las grandes empresas. </p><br><p>  Apple no fue la excepci칩n.  En 2017, la compa침칤a present칩 el marco ARKit, cuya importancia para la industria dif칤cilmente se puede sobreestimar.  Y hablaremos de ello con m치s detalle. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Caracter칤sticas de ARKit, lo que facilita el uso de AR: </p><br><ul><li>  falta de necesidad de etiquetas especiales (marcadores), </li><li>  integraci칩n con marcos de gr치ficos 2D / 3D de Apple existentes: SceneKit, SpriteKit, Metal, </li><li>  alta precisi칩n para determinar la posici칩n y orientaci칩n del dispositivo en el espacio, </li><li>  No es necesario calibrar la c치mara o los sensores. </li></ul><br><p>  Bajo el cap칩 de ARKit hay un sistema de odometr칤a visual inercial que combina datos con los subsistemas visual (c치mara) e inercial (aceler칩metro, giroscopio) del dispositivo para determinar la posici칩n y el desplazamiento en el escenario.  El elemento de conexi칩n de este sistema es el filtro de Kalman, un algoritmo que en cada momento selecciona la mejor de las lecturas de los dos subsistemas y nos la proporciona en forma de nuestra posici칩n y orientaci칩n en el escenario.  ARKit tambi칠n tiene una "comprensi칩n" de la escena: podemos definir superficies horizontales y verticales, as칤 como las condiciones de iluminaci칩n de la escena.  Por lo tanto, al agregar un objeto a la escena, podemos agregarle iluminaci칩n predeterminada, gracias a lo cual el objeto se ver치 m치s realista. </p><br><div class="spoiler">  <b class="spoiler_title">Por cierto</b> <div class="spoiler_text"><p>  Pronto, se lanzar치 la versi칩n 2.0 del marco, en la que se agregar치n nuevas caracter칤sticas y se mejorar치 significativamente la precisi칩n de posicionamiento. </p></div></div><br><p>  ARKit permiti칩 a los desarrolladores integrar la realidad aumentada de alta calidad en sus aplicaciones mientras gastaban mucho menos esfuerzo.  Lo demostraremos usando el ejemplo de Yandex.Maps. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Enrutamiento con AR en Yandex.Maps </h2><br><p>  Por lo general, despu칠s del anuncio de la nueva versi칩n de iOS, muchos equipos de Yandex se re칰nen para discutir la posibilidad de introducir nuevas funciones en sus aplicaciones.  El equipo Yandex.Mart hizo lo mismo.  Dentro de un mes desde el momento del anuncio de ARKit, a menudo discutimos c칩mo implementarlo en Maps.  춰Qu칠 tipo de ideas no escuchamos el uno del otro!  R치pidamente, llegamos a la conclusi칩n de que una de las soluciones m치s 칰tiles y superficiales es el uso de la realidad aumentada en el enrutamiento. </p><br><p>  La elecci칩n de esta idea se debi칩 al hecho de que muchos usuarios de tarjetas a menudo se encuentran con una situaci칩n en la que te encuentras en un 치rea desconocida y necesitas decidir r치pidamente a d칩nde ir.  El enfoque est치ndar para el usuario promedio del mapa es abrir la aplicaci칩n, construir una ruta peatonal y, girando en su lugar, determinar d칩nde moverse.  La idea de introducir la realidad aumentada en el enrutamiento de peatones es salvar al usuario de acciones innecesarias, mostrando de inmediato d칩nde debe moverse directamente sobre la imagen de la c치mara. </p><br><p>  Primero, quiero decir algunas palabras sobre el enrutamiento.  쯈u칠 pongo en este concepto?  Desde el punto de vista de la implementaci칩n en una aplicaci칩n m칩vil, este es un conjunto bastante est치ndar de pasos que permiten al usuario ir del punto A al punto B: </p><br><ul><li>  selecci칩n de puntos de partida y llegada, </li><li>  recibir una ruta en forma de un conjunto de puntos en coordenadas geogr치ficas (latitud, longitud), </li><li>  mostrar en el mapa de la l칤nea de ruta, </li><li>  acompa침ando al usuario con informaci칩n adicional mientras se mueve a lo largo de la ruta. </li></ul><br><p>  No nos detendremos en los dos primeros puntos.  Solo puedo decir que obtenemos la ruta a trav칠s de nuestra biblioteca multiplataforma Yandex.Mapkit, que tambi칠n est치 disponible para usted en forma de pod.  쮺칩mo difiere el enrutamiento de realidad aumentada del enrutamiento est치ndar en los mapas?  En primer lugar, la principal diferencia es un mapa casi completamente oculto.  El 칠nfasis principal se pone en el 치rea de la pantalla con la imagen de la transmisi칩n de video de la c치mara, en la que se superponen elementos visuales adicionales (marca de finalizaci칩n, marca auxiliar e imagen de l칤nea de ruta).  Cada uno de estos elementos visuales tiene su propia carga sem치ntica y su propia l칩gica (cu치ndo y c칩mo debe mostrarse).  Consideraremos el papel de cada uno de estos elementos con m치s detalle m치s adelante, pero por ahora propongo considerar las tareas que ten칤amos antes: </p><br><ul><li>  aprender a colocar objetos en la escena ARKit, conociendo sus coordenadas geogr치ficas, </li><li>  aprenda a dibujar la interfaz de usuario necesaria en una escena 3D con un rendimiento suficiente. </li></ul><br><p>  Necesit치bamos convertir las coordenadas de los puntos de geogr치ficas a las coordenadas en el escenario, seleccionar qu칠 puntos mostrar y mostrar toda la IU necesaria en la parte superior de la imagen de la c치mara en la posici칩n correcta.  Pero todo result칩 ser un poco m치s complicado de lo que parec칤a a primera vista. </p><br><p>  Antes de comenzar a implementar las funciones directamente, uno de mis colegas recibi칩 la tarea de hacer un prototipo que mostrara la posibilidad (o imposibilidad) de implementar una funcionalidad similar con un conjunto accesible de herramientas.  Durante dos semanas, vimos a San Sanych arando los espacios abiertos del espacio abierto y los alrededores cercanos de nuestra oficina con un tel칠fono en la mano y mirando el mundo que nos rodea a trav칠s del prisma de la c치mara.  Como resultado, obtuvimos un prototipo funcional que mostraba cada punto de la ruta como una marca en el escenario con una distancia a la misma.  Con la ayuda de este prototipo, fue posible, bajo una combinaci칩n exitosa de circunstancias, ir del trabajo al metro y casi nunca perderse.  Pero en serio, confirm칩 la posibilidad de implementar la funcionalidad prevista.  Pero quedaba una serie de tareas que nuestro equipo a칰n ten칤a que resolver. </p><br><p>  Todo comenz칩 con el estudio de las herramientas.  En ese momento, solo una persona en el equipo ten칤a experiencia trabajando con gr치ficos 3D.  Echemos un vistazo r치pido a las herramientas con las que tendr치 que lidiar cualquiera que piense en implementar tales ideas con ARKit. </p><br><h2 id="instrumenty-i-api">  Herramientas y API </h2><br><p>  El trabajo principal de renderizar objetos es crear y administrar objetos de escena del framework SceneKit.  Con el advenimiento de ARKit, la clase ARSCNView (el descendiente de la clase SCNView, la clase base para trabajar con la escena en SceneKit) se puso a disposici칩n del desarrollador, que resuelve la mayor칤a de las tareas de integraci칩n de ARKit y SceneKit que requieren mucho tiempo, a saber: </p><br><ul><li>  sincronizaci칩n de la posici칩n del tel칠fono en el espacio con la posici칩n de la c치mara en el escenario, </li><li>  el sistema de coordenadas de la escena coincide con el sistema de coordenadas ARKit, </li><li>  Como fondo de la escena, se utiliza la transmisi칩n de video de la c치mara del dispositivo. </li></ul><br><p>  El objeto ARSCNView tambi칠n proporciona al desarrollador un objeto de sesi칩n de realidad aumentada que puede iniciarse con la configuraci칩n necesaria, detenerse o suscribirse a varios eventos utilizando el objeto delegado. </p><br><p>  Para agregar objetos a la escena, se utilizan herederos o directamente objetos SCNNode.  Esta clase representa una posici칩n (vector tridimensional) en el sistema de coordenadas de su padre.  Por lo tanto, obtenemos un 치rbol de objetos en la escena con una ra칤z en un objeto especial: el nodo ra칤z de nuestra escena.  Todo aqu칤 es muy similar a la jerarqu칤a de objetos UIView en UIKit.  Los objetos SCNNode se pueden mostrar en el escenario cuando agregan material e iluminaci칩n. </p><br><p>  Para agregar realidad aumentada a una aplicaci칩n m칩vil, tambi칠n debe conocer los objetos principales de la API de ARKit.  El principal es el objeto de la sesi칩n de realidad aumentada: ARSession.  Este objeto lleva a cabo el procesamiento de datos y es responsable del ciclo de vida de la sesi칩n de realidad aumentada.  El prop칩sito de este art칤culo no es volver a contar la documentaci칩n de ARKit y SceneKit, por lo que no escribir칠 sobre todos los par치metros de configuraci칩n disponibles de la sesi칩n de realidad aumentada, sino que me centrar칠 en uno de los par치metros m치s importantes de la configuraci칩n de la sesi칩n de realidad aumentada para aplicaciones de navegaci칩n: worldAlignment.  Este par치metro determina la direcci칩n de los ejes de la escena en el momento de la inicializaci칩n de la sesi칩n.  En general, al inicializar una sesi칩n de realidad aumentada, ARKit crea un sistema de coordenadas con un comienzo en un punto que coincide con la posici칩n actual del tel칠fono en el espacio, y dirige el eje de este sistema seg칰n el valor de la propiedad woldAlignment.  En nuestra implementaci칩n, se utiliza el valor gravityAndHeading, lo que implica que los ejes se direccionar치n de la siguiente manera: el eje Y, en la direcci칩n opuesta a la gravedad, el eje Z, hacia el sur, y el eje X, hacia el este. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="alineaci칩n-mundo-gravedad-y-rumbo"></p><br><p>  Con una buena combinaci칩n de circunstancias, los ejes X / Z se alinear치n con las direcciones hacia el sur / este, pero, debido a errores en las lecturas de la br칰jula, los ejes se pueden dirigir en un cierto 치ngulo a la direcci칩n descrita en la documentaci칩n.  Este es uno de los problemas con los que tuvimos que lidiar, pero m치s sobre eso m치s adelante. </p><br><p>  Ahora que hemos examinado las herramientas b치sicas, resumamos: mapear una ruta usando SceneKit es agregar objetos SCNNode a la escena en las posiciones obtenidas mediante la conversi칩n de coordenadas geogr치ficas a coordenadas de escena.  Antes de hablar sobre la conversi칩n de coordenadas y, en general, sobre la colocaci칩n de objetos en la escena, hablemos sobre los problemas de renderizar elementos de la interfaz de usuario, suponiendo que sepamos la posici칩n de los objetos en el escenario. </p><br><h1 id="metka-finisha">  Marca final </h1><br><p>  El principal elemento visual del enrutamiento peatonal con realidad aumentada es la marca de llegada, que muestra el punto final de la ruta.  Tambi칠n sobre la marca, le mostramos al usuario la distancia hasta el punto final de la ruta. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="acabado-placemark-resumen"></p><br><h2 id="razmer">  Tama침o </h2><br><p>  Cuando se nos mostr칩 por primera vez el dise침o de esta etiqueta, primero prestamos atenci칩n a los requisitos para el tama침o de esta etiqueta.  No obedecieron las reglas de proyecci칩n en perspectiva.  Explicar칠 que en los motores tridimensionales que se utilizan para crear, por ejemplo, juegos de computadora, el "aspecto" se modela utilizando la proyecci칩n en perspectiva.  De acuerdo con las reglas de proyecci칩n en perspectiva, los objetos distantes se representan en una escala menor, y las l칤neas paralelas generalmente no son paralelas.  Por lo tanto, el tama침o de proyecci칩n del objeto en el plano de la pantalla cambia linealmente (disminuye) a medida que la c치mara se aleja del objeto en la escena.  De la descripci칩n de los dise침os se deduce que el tama침o de la marca en la pantalla tiene un tama침o fijo (m치ximo) cuando se elimina menos de 50 m, luego disminuye linealmente de 50 ma 2 km, despu칠s de lo cual el tama침o m칤nimo permanece sin cambios.  Tales requisitos obviamente se deben a la conveniencia del usuario.  Permiten al usuario nunca perder el punto final de la ruta de la vista, por lo que el usuario siempre tendr치 una idea de d칩nde moverse. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="acabado-placemark-tama침o-demandas"></p><br><p>  Ten칤amos que entender c칩mo podr칤amos meternos en el mecanismo de proyecci칩n SceneKit que funcionaba de acuerdo con ciertas reglas.  Quiero se침alar de inmediato que ten칤amos alrededor de dos semanas para hacer todo sobre todo, por lo que simplemente no hab칤a tiempo para llevar a cabo un an치lisis en profundidad de varios enfoques para resolver los problemas planteados.  Ahora, analizar nuestras decisiones, evaluarlas es mucho m치s simple, y podemos concluir que la mayor칤a de las decisiones tomadas fueron correctas.  El requisito de tama침o, de hecho, fue el primer escollo.  Todos los problemas descritos a continuaci칩n se pueden resolver utilizando SceneKit y UIKit.  Trat칠 de explicar en detalle c칩mo resolver cada uno de los problemas usando ambos enfoques.  Qu칠 enfoque usar depende de usted. </p><br><p>  Imaginemos que decidimos implementar una etiqueta de acabado usando SceneKit.  Si tenemos en cuenta que la etiqueta de acuerdo con los dise침os deber칤a haber parecido un c칤rculo en la pantalla, entonces resulta obvio que en SceneKit el objeto de la etiqueta deber칤a ser una esfera (ya que la proyecci칩n de la esfera en cualquier plano es un c칤rculo).  Para que la proyecci칩n tenga un cierto radio en la pantalla, definido en los requisitos de los dise침adores, es necesario conocer el radio de la esfera en cada momento del tiempo.  Por lo tanto, al colocar una esfera de cierto radio en la escena en un determinado punto y actualizar constantemente su radio al acercarse o alejarse, obtendremos una proyecci칩n en la pantalla del tama침o requerido en cualquier momento.  El algoritmo para determinar el radio de la esfera en un punto arbitrario en el tiempo es el siguiente: </p><br><ol><li>  definir la posici칩n del objeto en el escenario: el centro de la esfera, </li><li>  encuentre la proyecci칩n de este punto en el plano de la pantalla (usando la API de SceneKit), </li><li>  Para determinar el tama침o requerido de la marca en la pantalla, encontramos la distancia desde la c치mara hasta el centro de la esfera en el escenario, </li><li>  determinamos el tama침o requerido en la pantalla por la distancia al objeto usando las reglas descritas en el dise침o, </li><li>  sabiendo el tama침o de la marca en la pantalla (di치metro del c칤rculo), elegimos cualquier punto en este c칤rculo, </li><li>  hacer la proyecci칩n inversa (unprojectPoint) del punto seleccionado, </li><li>  Encontramos la longitud del vector desde el punto recibido en el escenario hasta el centro de la esfera. </li></ol><br><p>  El valor obtenido de la longitud del vector ser치 el radio deseado de la esfera. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="acabado-placemark-size-solution-scenekit"></p><br><p>  En el momento de la implementaci칩n, no pudimos encontrar una manera de determinar el tama침o del objeto en la escena, y decidimos dibujar la marca de meta usando UIKit.  En este caso, el algoritmo repite los pasos 1-5, despu칠s de lo cual se dibuja un c칤rculo del tama침o deseado en la pantalla con el centro en el punto obtenido en el paso 2 utilizando las herramientas UIKit.  Un ejemplo de implementaci칩n de una etiqueta usando UIKit se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Algunas palabras sobre el c칩digo</b> <div class="spoiler_text"><p>  Al final del art칤culo, proporcion칠 varios enlaces a materiales 칰tiles y simplemente interesantes, incluidos ejemplos, en los que puede ver en detalle el c칩digo real que resuelve los problemas presentados en el art칤culo e implementa los algoritmos presentados.  El principal inter칠s en mi opini칩n es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prototipo de enrutamiento peatonal</a> , que re칰ne toda la funcionalidad, con la excepci칩n del mecanismo de ajuste del eje, que se describe en detalle a continuaci칩n. </p><br><p>  El c칩digo anterior no pretende ser 칩ptimo, completo y de calidad de producci칩n =) </p></div></div><br><p>  La diferencia entre usar SceneKit y UIKit en este caso tambi칠n radica en el hecho de que al implementar en SceneKit, el objeto SCNNode para el punto final de la ruta (marca de finalizaci칩n) se crear치 con material y geometr칤a, ya que debe ser visible, mientras se usa UIKit necesitamos el objeto nodo exclusivamente para buscar la proyecci칩n en el plano de la pantalla (para determinar el centro de la marca en la pantalla).  En este caso, no es necesario agregar geometr칤a y material.  Tenga en cuenta que la distancia desde la c치mara al objeto SCNNode del punto final de la ruta se puede encontrar de dos maneras: utilizando las coordenadas geogr치ficas de los puntos o como la longitud del vector entre los puntos en la escena.  Esto es posible porque el objeto de la c치mara es una propiedad SCNNode.  Para obtener el nodo de la c치mara, debe consultar la propiedad pointOfView de nuestra escena. </p><br><p>  Aprendimos a determinar el radio del nodo de la marca de finalizaci칩n en un punto arbitrario en el tiempo cuando se implementa en SceneKit y la posici칩n de la vista de la marca de finalizaci칩n si se implementa en UIKit.  쯈ueda por entender cu치ndo es necesario actualizar estos valores?  Este lugar es el m칠todo de objeto SCNSceneRendererDelegate: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  Este m칠todo se llama despu칠s de cada cuadro de escena renderizado.  Al actualizar los valores de propiedad en el cuerpo de este m칠todo, obtenemos una etiqueta de finalizaci칩n que se muestra correctamente. </p><br><h2 id="animaciya">  Animaci칩n </h2><br><p>  Despu칠s de que la marca de finalizaci칩n apareciera en dev, procedimos a agregar animaci칩n ondulada a esta marca.  Creo que para la mayor칤a de los desarrolladores de iOS crear animaciones no es gran cosa.  Pero al pensar en el m칠todo de implementaci칩n, nos encontramos con el problema de actualizar constantemente el marco de nuestra vista.  Tenga en cuenta que en la mayor칤a de los casos, las animaciones se agregan a los objetos est치ticos de UIView.  Un problema similar: una actualizaci칩n constante del radio de la geometr칤a del nodo surge cuando se implementa usando SceneKit.  El hecho es que la animaci칩n pulsante se reduce a la animaci칩n del tama침o del c칤rculo (para UIKit) y el radio de la esfera (para SceneKit).  S칤, s칤, sabemos que en UIKit este tipo de animaci칩n se puede hacer usando CALayer, pero para simplificar la narraci칩n, decid칤 considerar este tema sim칠tricamente para los dos marcos.  Considere una implementaci칩n en UIKit.  Si agrega c칩digo que anima el mismo cuadro al c칩digo existente que actualiza el cuadro de vista, la animaci칩n se interrumpir치 al establecer expl칤citamente el cuadro.  Por lo tanto, como soluci칩n a este problema, decidimos usar la animaci칩n de la propiedad transform.scale.xy del objeto UIView.  Al implementar usando SceneKit, tendr치 que agregar animaci칩n de la propiedad de escala al objeto SCNNode.  Lo bueno de usar SceneKit en este caso es el hecho de que es totalmente compatible con CoreAnimation, por lo que no es necesario aprender una nueva API.  El c칩digo que implementa una animaci칩n similar a la animaci칩n de etiquetas en Yandex.Maps se parece a esto: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Cartelera </h2><br><p>  Al comienzo del art칤culo, mencion칠 una valla publicitaria con una distancia al punto final de la ruta, que, en esencia, es una etiqueta con texto siempre ubicado sobre la marca de meta.  Por tradici칩n, describir칠 los problemas inherentes a las implementaciones en UIKit y SceneKit, explicando las posibles soluciones para cada uno de los marcos. </p><br><p>  Comencemos con UIKit.  En este caso, la cartelera es un UILabel normal, en el que el texto se actualiza constantemente y muestra la distancia hasta el punto final de la ruta.  Veamos el problema al que nos enfrentamos. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="acabado-placemark-billboard-problem-uikit"></p><br><p>  Si configura una etiqueta en un marco y luego gira el tel칠fono, veremos que el marco no cambia (ser칤a extra침o si no fuera as칤).  Al mismo tiempo, nos gustar칤a que la etiqueta permanezca paralela al plano de la tierra. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="acabado-placemark-billboard-deseado-uikit"></p><br><p>  Creo que todos entienden que al cambiar la orientaci칩n del dispositivo, debemos girar la etiqueta, pero 쯘n qu칠 치ngulo?  Si enciende la imaginaci칩n e imagina mentalmente todos los ejes de los sistemas de coordenadas y los vectores involucrados en este proceso, podemos concluir que el 치ngulo de rotaci칩n es igual al 치ngulo entre el eje x del sistema de coordenadas UIKit y la proyecci칩n del eje X del sistema de coordenadas SceneKit en el plano de la pantalla. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="acabado-placemark-billboard-solution-uikit"></p><br><p>  Una tarea simple que una vez m치s demostr칩 la utilidad del curso de geometr칤a escolar. </p><br><p>  Cuando implemente la marca de acabado con SceneKit, lo m치s probable es que necesite renderizar la cartelera con distancia usando las herramientas de SceneKit, lo que significa que definitivamente tendr치 la tarea de hacer que el objeto SCNNode est칠 siempre orientado hacia la c치mara.  Creo que el problema se volver치 m치s claro si miras la imagen: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="acabado-placemark-billboard-problem-scenekit"></p><br><p>  Este problema se resuelve utilizando la API SCNBillboardConstraint.  Al agregar una constante con un eje Y libre a la colecci칩n de restricciones de nuestro nodo, obtenemos un nodo que gira alrededor del eje Y de su sistema de coordenadas, para estar siempre orientado hacia la c치mara.  La 칰nica tarea del desarrollador es colocar este nodo a la altura correcta para que la cartelera con la distancia sea siempre visible para el usuario. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Asistente de etiqueta </h1><br><p>  Una de las caracter칤sticas principales del enrutamiento peatonal con realidad aumentada, dentro del equipo, consideramos una etiqueta auxiliar: un elemento visual especial que aparece en la pantalla en el momento en que el punto final de la ruta abandona la zona de visibilidad y muestra al usuario d칩nde girar el tel칠fono para que la etiqueta aparezca en la pantalla l칤nea de meta </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="finish-placemark-hint-overview"></p><br><p>  Estoy seguro de que muchos de los lectores han encontrado funcionalidades similares en algunos juegos, la mayor칤a de las veces tiradores.  Qu칠 sorpresa fue nuestro equipo cuando vimos este elemento de interfaz de usuario en los dise침os.  Debo decir de inmediato que la implementaci칩n correcta de una funci칩n de este tipo puede requerir m치s de una hora de experimentaci칩n por parte de usted, pero el resultado final vale la pena.  Comenzamos definiendo requisitos, a saber: </p><br><ul><li>  para cualquier orientaci칩n del dispositivo, la etiqueta se mueve a lo largo de los bordes de la pantalla, </li><li>  Si el usuario ha girado 180 grados hasta el punto final de la ruta, la etiqueta se muestra en la parte inferior de la pantalla, </li><li>  en cada momento, girar hacia la marca deber칤a ser el giro m치s corto hasta el punto final de la ruta. </li></ul><br><p>  Despu칠s de describir los requisitos, comenzamos la implementaci칩n.  Casi de inmediato, llegamos a la conclusi칩n de que el renderizado se har칤a con UIKit.  El principal problema con la implementaci칩n fue la determinaci칩n del centro de esta etiqueta en cada punto de tiempo.  Despu칠s de considerar la marca final, dicha tarea no deber칤a causar dificultades, por lo que no me detendr칠 en su soluci칩n en detalle.  En el art칤culo solo dar칠 una descripci칩n del algoritmo para elegir el centro de la etiqueta auxiliar, y el c칩digo fuente se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . </p><br><p>  Algoritmo del centro de b칰squeda Algoritmo de b칰squeda: </p><br><ol><li>  cree un objeto SCNNode para el punto final de la ruta con una posici칩n en la escena obtenida de la coordenada geogr치fica del punto, </li><li>  encuentra la proyecci칩n de un punto en el plano de la pantalla, </li><li>  encuentre la intersecci칩n del segmento desde el centro de la pantalla hasta el punto de la proyecci칩n encontrada con los segmentos de los l칤mites de la pantalla en el sistema de coordenadas de la pantalla. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="acabado-placemark-sugerencia-soluci칩n"></p><br><p>  El punto de intersecci칩n encontrado es el centro deseado de la marca auxiliar.  Por analog칤a con el c칩digo que actualiza los par치metros de la etiqueta de finalizaci칩n, colocamos el c칩digo que representa la etiqueta auxiliar en el m칠todo delegado que ya se mencion칩 anteriormente. </p><br><h1 id="poliliniya-marshruta">  Polil칤nea de ruta </h1><br><p>  Despu칠s de haber construido una ruta y haber visto la marca de llegada en la pantalla, el usuario puede alcanzarla orientando solo en la direcci칩n de la marca, pero la ruta se llama as칤 porque muestra la ruta al usuario.  Pensamos que ser칤a muy extra침o reducir la funcionalidad del enrutamiento peatonal, excluyendo la visualizaci칩n de ruta de la versi칩n AR.  Para visualizar la l칤nea de ruta, se decidi칩 mostrar un conjunto de flechas movi칠ndose a lo largo de ella.  En este caso, los dise침adores estaban satisfechos de que las flechas pr치cticamente desaparecer칤an al alejarse (el tama침o estar칤a determinado por las reglas de proyecci칩n en perspectiva), y se decidi칩 usar SceneKit para la implementaci칩n. </p><br><p>  Antes de proceder a describir la implementaci칩n, es importante tener en cuenta que, por dise침o, las flechas deber칤an haber estado a una distancia de 3 m entre s칤.  Si estima el n칰mero de objetos (flechas) que deben representarse con una ruta de aproximadamente 1 km de largo, entonces ser치n aproximadamente 330 piezas.  Al mismo tiempo, a cada objeto se le agrega una animaci칩n de movimiento a lo largo de su parte de la ruta.  Tenga en cuenta que las flechas alejadas de la posici칩n de la c치mara en el escenario a una distancia de aproximadamente 100-150 metros son pr치cticamente invisibles debido a su peque침o tama침o.  Habiendo considerado estos factores, se decidi칩 no mostrar todos los objetos, sino mostrar solo aquellos que se eliminan del usuario a no m치s de 100 metros a lo largo de la l칤nea de ruta, actualizando peri칩dicamente el conjunto de objetos visualizados.  Mostramos una cantidad suficiente de informaci칩n visual, eliminando c치lculos innecesarios de SceneKit y ahorrando la bater칤a del usuario. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="ruta-polil칤nea-resumen"></p><br><p>  Veamos los pasos principales que tuvimos que realizar para obtener el resultado final: </p><br><ul><li>  selecci칩n de la secci칩n de ruta para la que mostraremos las primitivas, </li><li>  creaci칩n de modelos 3D, </li><li>  creaci칩n de animaci칩n </li><li>  actualizar al conducir por una ruta. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Seleccionar una parcela para mostrar </h2><br><p>  Como se침al칠 anteriormente, no mostramos flechas para toda la ruta, sino que seleccionamos la secci칩n 칩ptima para mostrar.  La elecci칩n de un segmento en un punto arbitrario en el tiempo consiste en encontrar el segmento de ruta m치s cercano (la ruta es una secuencia de segmentos / segmentos) a la posici칩n actual del usuario y seleccionar segmentos desde el punto m치s cercano al punto final de la ruta hasta que su longitud total exceda los 100 metros. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="ruta-polil칤nea-ruta-selecci칩n-parte"></p><br><h2 id="sozdanie-3d-modeli">  Creaci칩n de modelos 3D </h2><br><p>  Consideremos con m치s detalle el proceso de creaci칩n de un modelo 3D.  En la mayor칤a de los casos, todo lo que necesita hacer para crear un modelo 3D simple (como nuestra flecha) es abrir cualquier editor 3D, dedicar un tiempo a dominarlo y crear este modelo en 칠l.  En caso de que los muchachos de su equipo tengan experiencia en modelado 3D, o tengan tiempo para aprender, por ejemplo, 3DMax (y debe comprarse), entonces es incre칤blemente afortunado.  Desafortunadamente, en el momento de la implementaci칩n de esta funci칩n, ninguno de nosotros ten칤a experiencia especial, no hab칤a tiempo libre para la capacitaci칩n, por lo que tuvimos que hacer un modelo, por as칤 decirlo, con medios improvisados.  Me refiero a la descripci칩n del modelo en el c칩digo.  Todo comenz칩 con la presentaci칩n de un modelo 3D en forma de tri치ngulos.  Luego tuvimos que encontrar manualmente las coordenadas de los v칠rtices de estos tri치ngulos en el sistema de coordenadas del modelo, y luego crear una matriz de 칤ndices de los v칠rtices de los tri치ngulos.  Con estos datos a nuestra disposici칩n, podemos crear la geometr칤a necesaria directamente en SceneKit.  Puede crear un modelo similar al nuestro, por ejemplo, as칤: </p><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SCNGeometry</span></span></span></span> { convenience init(material: SCNMaterial) { let vertices: [<span class="hljs-type"><span class="hljs-type">SCNVector3</span></span>] = [ <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">11</span></span> ] let sources: [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>] = [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>(<span class="hljs-type"><span class="hljs-type">vertices</span></span>: <span class="hljs-type"><span class="hljs-type">vertices</span></span>)] let indices: [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span><span class="hljs-number"><span class="hljs-number">32</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] let geometryElements = [<span class="hljs-type"><span class="hljs-type">SCNGeometryElement</span></span>(<span class="hljs-type"><span class="hljs-type">indices</span></span>: <span class="hljs-type"><span class="hljs-type">indices</span></span>, <span class="hljs-type"><span class="hljs-type">primitiveType</span></span>: <span class="hljs-type"><span class="hljs-type">.triangles</span></span>)] self.init(sources: sources, elements: geometryElements) self.materials = [<span class="hljs-type"><span class="hljs-type">material</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func arrowBlue() -&gt; SCNGeometry { let material = SCNMaterial() material.diffuse.contents = UIColor.blue material.lightingModel = .constant <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ARSCNArrowGeometry(material: material) }</code> </pre> <br><p>  El resultado final se ve as칤: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="ruta-polil칤nea-flecha-modelo"></p><br><h2 id="animaciya-linii-marshruta">  Animaci칩n de l칤nea de ruta </h2><br><p>  El siguiente paso en el camino para mostrar una l칤nea animada de la ruta fue la etapa de creaci칩n de la animaci칩n en s칤.  Pero, 쯖u치l es la forma de realizar la animaci칩n, que en la forma final parece que la flecha comienza su movimiento en el punto inicial de la secci칩n seleccionada de la ruta y "flota" a lo largo de la ruta hasta el final de esta secci칩n? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  No describir칠 todas las formas posibles de crear tal animaci칩n, sino que me detendr칠 en m치s detalles sobre el m칠todo que hemos elegido.  Despu칠s de seleccionar una secci칩n de la ruta, la dividimos en secciones de la misma longitud: secciones de la animaci칩n de una flecha.  Cada secci칩n de este tipo est치 resaltada en color y tiene una longitud igual a la distancia entre las flechas. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="ruta-polil칤nea-ruta-partici칩n-partici칩n"></p><br><p>  Al comienzo de cada secci칩n, creamos el objeto SCNNode de la flecha, cuya animaci칩n consiste en moverse a lo largo de su secci칩n. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="ruta-polil칤nea-flechas-posici칩n-inicial"></p><br><p>  Como puede ver, la secci칩n de animaci칩n a veces consta de un segmento, a veces de dos o m치s.  Todo depende del paso (en nuestro caso, 3 metros) entre las flechas y las coordenadas de los puntos que componen la ruta. </p><br><p>  Una animaci칩n de flecha es una secuencia de dos pasos: </p><br><ul><li>  Apariencia en la posici칩n inicial con el 치ngulo de rotaci칩n inicial, </li><li>  Una secuencia de desplazamientos a lo largo de segmentos con rotaciones en los puntos de conexi칩n de los segmentos. </li></ul><br><p>  Esquem치ticamente, se ve as칤: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="ruta-polil칤nea-flecha-anitaion-pasos"></p><br><p>  Nos pareci칩 la forma m치s f치cil de implementar una animaci칩n de este tipo utilizando la API SCNAction, una API declarativa que le permite crear convenientemente animaciones secuenciales, grupales y repetitivas.  Puede ver la implementaci칩n con m치s detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> .  Debido al hecho de que cada flecha termina su animaci칩n en el punto de inicio de la secci칩n de animaci칩n de la siguiente flecha, se crea la impresi칩n de movimiento continuo de la flecha a lo largo de toda la secci칩n seleccionada de la ruta. </p><br><p>  Sobre esto, propongo completar la consideraci칩n de varios aspectos de la representaci칩n y pasar a la parte principal: determinar las posiciones de los objetos en el escenario mediante las coordenadas geogr치ficas de los objetos. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Determinar la posici칩n de un objeto en la escena. </h1><br><p>  Comenzamos la conversaci칩n sobre la determinaci칩n de la posici칩n de un objeto en la escena considerando los sistemas de coordenadas, cuya conversi칩n debe llevarse a cabo.  Solo hay 2 de ellos: </p><br><ul><li>  coordenadas geod칠sicas (o geogr치ficas para simplificar): la posici칩n de los objetos (puntos de ruta) en el mundo real, </li><li>  Coordenadas cartesianas: la posici칩n de los objetos en la escena (en ARKit).  Recuerde que el sistema de coordenadas de la escena coincide con el sistema de coordenadas ARKit (en el caso de utilizar ARSCNView). </li></ul><br><p>  La traducci칩n de un sistema de coordenadas a otro y viceversa es posible debido al hecho de que las coordenadas en ARKit se miden en metros, y el desplazamiento entre dos coordenadas geod칠sicas se puede traducir con gran precisi칩n en el desplazamiento en metros a lo largo de los ejes X y Z del sistema de coordenadas ARKit en peque침as compensaciones.  Perm칤tame recordarle que las coordenadas geod칠sicas son puntos con cierta longitud y latitud. </p><br><p>  Recordemos conceptos tan importantes del curso de la geograf칤a como paralelos y meridianos, y sus propiedades b치sicas: </p><br><ul><li>  <strong>Paralelo</strong> es una l칤nea con un valor de grado de latitud.  Las longitudes de los diversos paralelos son diferentes. </li><li>  <strong>Meridiano</strong> : una l칤nea con un valor de grado de longitud.  Las longitudes de todos los meridianos son iguales. </li></ul><br><p>  Ahora veamos c칩mo puedes calcular el desplazamiento en metros, entre dos coordenadas geod칠sicas con coordenadas. <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en l칤nea (lat_1, lon_1)">  y <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en l칤nea (lat_2, lon_2)">  : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta lon \ times metersInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ times metersInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="metersInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {lands} \ cos \ left (\ alpha \ right)} {360 ^ {춿}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="metersInLatDegree = \ frac {2 \ pi R_ \ text {lands}} {360 ^ {춿}}"></p><br><div class="spoiler">  <b class="spoiler_title">Explicaci칩n</b> <div class="spoiler_text"><p>  El desplazamiento en coordenadas geod칠sicas se asigna linealmente a metros solo en peque침os desplazamientos.  En grandes desplazamientos, es necesario tomar honestamente la integral. </p></div></div><br><p>  Ahora que somos capaces de traducir el desplazamiento de un sistema de coordenadas a otro, necesitamos decidir sobre un punto de referencia, un punto para el cual las coordenadas geogr치ficas y las coordenadas en ARKit (coordenadas en el escenario) son conocidas al mismo tiempo.  Una vez encontrado ese punto, podemos determinar la coordenada de cualquier objeto en el escenario, conociendo su coordenada geogr치fica y utilizando las f칩rmulas anteriores. </p><br><p>  Para mayor claridad, considere un ejemplo: <br>  Al comienzo de la sesi칩n de realidad aumentada, le pedimos a CoreLocation nuestra coordenada geogr치fica y la recibimos al instante: <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ en l칤nea (lat_0, lon_0)">  .  Recordando el hecho de que el origen del sistema de coordenadas ARKit est치 al comienzo de la sesi칩n en el punto donde se encuentra el dispositivo, obtuvimos el punto de referencia, ya que conocemos la coordenada geogr치fica y la coordenada en el escenario <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ inline (x_0, y_0, z_0) = (0,0,0)">  .  Necesitamos encontrar la coordenada en la escena del objeto con una coordenada geogr치fica <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en l칤nea (lat_1, lon_1)">  .  Para hacer esto, encuentre el desplazamiento en metros entre la coordenada geogr치fica del objeto y la coordenada geogr치fica de nuestro punto de referencia, y luego agregue el desplazamiento encontrado a la coordenada en la escena del punto de referencia.  La coordenada resultante en la escena ser치 la deseada. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="coordenadas-conversi칩n-objeto-posici칩n-en-escena"></p><br><p>  Observo que la posici칩n en la escena encontrada de esta manera corresponder치 a la posici칩n del objeto en el mundo real solo si el eje X / Z del sistema de coordenadas de la escena est치 alineado con las direcciones hacia el Sur / Este.  La alineaci칩n del eje, en teor칤a, debe lograrse configurando el indicador worldAlignment en gravitiAndHeading.  Pero como dije al comienzo de la publicaci칩n, esto est치 lejos de ser siempre el caso. </p><br><p>  Consideremos con m치s detalle el m칠todo para determinar el punto de referencia.  Para hacer esto, presentamos el concepto de <strong>estimaci칩n</strong> : un conjunto de coordenadas geogr치ficas y coordenadas en el escenario. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="coordenadas-conversi칩n-estad칤sticas-definici칩n"></p><br><p>  El m칠todo propuesto anteriormente para determinar el punto de referencia no siempre se puede utilizar.  En el momento del inicio de una sesi칩n de realidad aumentada, una solicitud de CLLocation de un usuario puede no ejecutarse inmediatamente, adem치s, la precisi칩n de la coordenada obtenida puede tener un gran error.  Ser칤a m치s correcto pedirle a SceneKit una posici칩n en el escenario en el momento en que obtengamos el valor de CoreLocation.  En este caso, los componentes de la estimaci칩n resultante se obtienen al mismo tiempo, y tenemos la oportunidad de utilizar cualquiera de las estimaciones como punto de referencia.  Cuando se trabaja con ARKit, el error de compensaci칩n se acumula con el tiempo, por lo que Apple no recomienda usar ARKit como herramienta de navegaci칩n. </p><br><p>  Cuando decidimos implementar el enrutamiento peatonal con realidad aumentada, investigamos un poco las soluciones que exist칤an en ese momento, utilizando ARKit para tareas similares, y encontramos el marco ARKit + CoreLocation.  La idea de este marco era que gracias a ARKit podemos determinar con mayor precisi칩n la ubicaci칩n del usuario que cuando se usa exclusivamente CoreLocation. </p><br><p>  Concepto ARKit + CoreLocation: </p><br><ul><li>  al recibir CLLocation de CLLocationManager <br><ul><li>  solicitar una posici칩n en la escena usando scene.pointOfView.worldPosition </li><li>  guarde este par de coordenadas (estimaci칩n) en el b칰fer </li></ul></li><li>  obtener la ubicaci칩n exacta si es necesario <br><ul><li>  elige la mejor estimaci칩n </li><li>  calcular el desplazamiento entre la posici칩n actual en el escenario y la posici칩n en el escenario de la mejor estimaci칩n </li><li>         </li></ul></li></ul><br><p>          ,   ,   CoreLocation,       . </p><br><p>   ,   춺 췉.   ,      . </p><br><p>     (,    ): </p><br><ul><li>    (  horizontalAccuracy), </li><li>       , </li><li>        100    . </li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Por qu칠</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit         ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\ en l칤nea t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ en l칤nea (lat_1, lon_1)">       <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\ en l칤nea (x_1, z_1)"> .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ en l칤nea t_2">      CLLocationManager  <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en l칤nea (lat_2, lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\ en l칤nea (x_2, z_2)">  en consecuencia </p><br><p>      ARKit  <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\ en l칤nea (\ Delta x, \ Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ en l칤nea t_2"> .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ en l칤nea (lat_2, lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\ inline (lat_ {2calc}, lon_ {2calc})"> .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="coordenadas-conversi칩n-correcci칩n-치ngulo-problema"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\ inline initialBearing (1,2)">  y <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\ inline initialBearing (1,2_ {calc})"> ,  <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\ en l칤nea 2_ {calc}">     2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\ inline initialBearing (a, b)">   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="coordenadas-conversi칩n-correcci칩n-치ngulo-c치lculo-por-par"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="coordenadas-conversi칩n-correcci칩n-치ngulo-error-c치lculo"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  Por ejemplo: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Prueba </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="correcci칩n-치ngulo-c치lculo-alg-testing-street-before-correcci칩n"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="correcci칩n-치ngulo-c치lculo-alg-testing-street-after-correcci칩n"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="correcci칩n-치ngulo-c치lculo-alg-testing-street-after-last-correct"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="correcci칩n-치ngulo-c치lculo-alg-testing-tracks"></p><br><p>                   gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  En lugar de una conclusi칩n </h1><br><p>      Slack, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  Enlaces utiles </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> </li><li> ARKit+CoreLocation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   ARKit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> AR   </a> </li></ul><br><p>      ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> .</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421957/">https://habr.com/ru/post/es421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421945/index.html">Google y Mastercard concluyen un acuerdo secreto para rastrear compras en tiendas</a></li>
<li><a href="../es421947/index.html">Bienvenido a Android Devs Meetup 8 de septiembre</a></li>
<li><a href="../es421949/index.html">Escuadr칩n Suicida C칩mo reclutamos a los desarrolladores junior m치s feroces</a></li>
<li><a href="../es421953/index.html">Summ3r 0f h4ck: pr치cticas de verano en Digital Security</a></li>
<li><a href="../es421955/index.html">El Senado no quiere robots distra칤dos por la cerveza. 쯏 sobre qu칠 m치s escribir el viernes?</a></li>
<li><a href="../es421959/index.html">Qu칠 hacer cuando "esto" pierde el enlace de contexto</a></li>
<li><a href="../es421961/index.html">Crear una demostraci칩n para un tel칠fono antiguo - AONDEMO</a></li>
<li><a href="../es421963/index.html">Contabilidad y contabilidad: su papel en la organizaci칩n</a></li>
<li><a href="../es421965/index.html">"Adem치s del trabajo, sigo trabajando" - 10 preguntas para el programador, tercera edici칩n</a></li>
<li><a href="../es421967/index.html">Juguete infantil sobre elementos l칩gicos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>