<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈸 🕦 👨🏾‍🎓 学习OpenGL。 课程5.10-屏幕空间环境光遮挡 🧦 ♒️ 👒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SSAO 
 背景照明的主题是我们在照明基础知识课程中提出的，但只是通过了。 让我提醒您：照明的背景成分本质上是一个恒定值，将其添加到场景照明的所有计算中以模拟光散射的过程。 在现实世界中，光会经历许多强度不同程度的反射，这会导致场景的间接照明部分的照明不均。 显然，强度恒定的耀斑不太合理。 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学习OpenGL。 课程5.10-屏幕空间环境光遮挡</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421385/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  SSAO </h2><br> 背景照明的主题是我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">照明基础知识</a>课程中提出的，但只是通过了。 让我提醒您：照明的背景成分本质上是一个恒定值，将其添加到场景照明的所有计算中以模拟<i>光散射</i>的过程。 在现实世界中，光会经历许多强度不同程度的反射，这会导致场景的间接照明部分的照明不均。 显然，强度恒定的耀斑不太合理。 <br><br> 一种间接照明阴影近似计算的类型是<i>环境光遮挡（AO</i> ）算法，该算法模拟在拐角，皱纹和其他表面不规则区域附近间接照明的衰减。 通常，这样的元件被相邻的几何形状显着地重叠，因此留下更少的光线逃逸到外面，使这些区域模糊。 <br><br> 下面是不使用和使用AO算法的渲染的比较。 请注意墙角附近的背景照明强度如何降低以及表面上的其他尖锐断裂： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/8z/kv/6s8zkvpob8nbgaails8mtfutgw8.png"></div><br> 尽管效果不是很明显，但是由于自阴影效果的小细节所造成的深度错觉，整个场景中效果的存在增加了真实感。 <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">目录内容</b> <div class="spoiler_text"> 第1部分。入门 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">窗口创建</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好窗口</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好三角形</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转变</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">坐标系</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摄影机</a> </li></ol><br> 第2部分。基本照明 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">色彩</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">照明基础</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用料</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纹理贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多种光源</a> </li></ol><br> 第3部分。下载3D模型 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阿辛普图书馆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网格多边形类</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3D模型类</a> </li></ol><br> 第4部分。高级OpenGL功能 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混色</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">裁剪面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帧缓冲</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">立方卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的数据处理</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实例化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平滑处理</a> </li></ol><br> 第5部分。高级照明 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的照明。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Blinn-Fong模型。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伽玛校正</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">影子卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全向阴影贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">法线贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视差映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高动态范围</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布卢姆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟渲染</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSAO</a> </li></ol><br> 第6部分。PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理论</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漫反射。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">镜面曝光。</a> </li></ol><br></div></div><br> 值得注意的是，用于计算AO的算法需要大量资源，因为它们需要分析周围的几何形状。 在幼稚的实现中，可以简单地在表面的每个点发射很多射线并确定其阴影程度，但是这种方法很快达到了交互式应用程序可接受的资源密集型限制。 幸运的是，在2007年，Crytek发表了一篇论文，描述了自己的方法，该方法实现了Crysis发行版中使用的<i>屏幕空间环境光遮蔽（SSAO</i> ）算法。 该方法仅使用当前深度缓冲区而不是有关周围几何图形的实际数据来计算屏幕空间中的阴影程度。 与参考实现相比，这种优化从根本上加速了算法，并且同时给出了最合理的结果，这使这种近似背景阴影的计算方法成为事实上的标准行业。 <br><br> 该算法所基于的原理非常简单：对于全屏四边形的每个片段， <i>都会</i>根据周围片段的深度值<i>来</i>计算<i>遮挡因子</i> 。 然后，将计算出的阴影系数用于降低背景照明的强度（直至完全排除）。 获得系数需要从围绕所讨论的片段的球形区域的多个样本收集深度数据，并将这些深度值与所讨论的片段的深度进行比较。 深度大于当前片段的样本数直接确定阴影系数。 看一下这个图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y5/yh/8o/y5yh8oeqvguchqopeu7nz0g-tsy.png"></div><br> 在此，每个灰点位于某个几何对象内部，因此对阴影系数的值有所贡献。 周围物体的几何形状内的样本越多，该区域中背景阴影的残留强度就越小。 <br><br> 显然，效果的质量和真实性直接取决于所采样的数量。 对于少量样本，由于阴影系数非常不同的区域之间的突然过渡，导致算法的准确性降低并导致出现<i>条带</i>或“ <i>条带</i> ”伪像。 大量样本只会破坏性能。 样本核心的随机化允许有些相似的结果，以稍微减少所需样本的数量。 暗示通过旋转到一组样本矢量的随机角度来重新定向。 但是，引入随机性会立即以明显的噪声模式的形式带来新的问题，这就需要使用模糊滤波器来平滑结果。 下面是该算法的一个示例（作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-John Chapman</a> ）及其典型问题：条带和噪声模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r_/ay/l3/r_ayl3jjozsa6fyuni69ejkwpei.jpeg"></div><br> 可以看出，通过引入样本方向的随机化，可以很好地消除由于样本数量少而引起的明显条带。 <br><br>  Crytek的特定SSAO实施具有可识别的视觉样式。 由于Crytek专家使用的是样品的球形核，因此这甚至会影响平坦的表面（如墙），使其成为阴影-因为样品核的一半体积被淹没在几何形状下。 下面是基于阴影因子值以灰色显示的《孤岛危机》场景的屏幕截图。 在这里，“灰色”的效果清晰可见： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/zr/r8/j9zrr81dluj-5eobuqcgst48om8.jpeg"></div><br> 为了避免这种影响，我们将从样品的球芯移动到沿表面法线方向的半球： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br> 当从这样一个<i>法向定向的半球半球</i>采样时，在计算阴影系数时<i>，</i>我们不必考虑位于相邻表面下的碎片。 通常，这种方法可以消除不必要的阴影，从而获得更真实的结果。 本课将使用半球方法和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">John Chapman</a>出色的SSAO课程中的一些更精致的代码。 <br><br><h2> 原始数据缓冲区 </h2><br> 计算每个片段中的阴影因子的过程需要有关周围几何图形的数据可用性。 具体来说，我们需要以下数据： <br><br><ul><li> 每个片段的位置向量； </li><li> 每个片段的法线向量； </li><li> 每个片段的颜色漫反射； </li><li> 样本的核心 </li><li> 用于重新定向样本核心的每个片段的随机旋转向量。 </li></ul><br> 使用有关物种空间中片段坐标的数据，我们可以将样本核心的半球沿着当前空间的物种空间中指定的法向矢量定向。 然后，将所得的核用于从具有存储片段坐标坐标数据的纹理偏移各种偏移的样本中进行采样。 我们在每个片段中制作许多样本，对于我们制作的每个样本，我们将其深度值与片段坐标缓冲区中的深度值进行比较，以估计阴影量。 然后，将所得值用于限制最终照明计算中背景成分的贡献。 使用分段随机旋转向量，我们可以显着减少所需的样本数量以获得不错的结果，然后将对此进行演示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xo/aj/wvxoajroexwvjgq77n81-fjhats.png"></div><br> 由于SSAO是在屏幕空间中实现的效果，因此可以通过渲染全屏四边形来执行直接计算。 但是，那时我们将没有场景几何数据。 为了解决此限制，我们将在纹理中渲染所有必要的信息，稍后将在SSAO着色器中使用这些信息来访问有关场景的几何信息和其他信息。 如果您认真地学习了这些课程，那么您应该已经在描述的方法中知道了延迟着色算法的外观。 这很大程度上是为什么SSAO效果作为本机效果出现在带有延迟阴影的渲染中的原因-毕竟，存储坐标和法线的纹理在G缓冲区中已经可用。 <br><br><blockquote> 在本课程中，将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟照明</a>的课程的代码的稍微简化后的版本上实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">效果</a> 。 如果您还不熟悉延迟照明的原理，强烈建议您阅读本课。 <br></blockquote><br> 由于有了G缓冲区，可以访问有关坐标和法线的片段信息，因此几何处理阶段的片段着色器非常简单： <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 gPosition; layout (location = 1) out vec3 gNormal; layout (location = 2) out vec4 gAlbedoSpec; in vec2 TexCoords; in vec3 FragPos; in vec3 Normal; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        gPosition = FragPos; //       gNormal = normalize(Normal); //    -   gAlbedoSpec.rgb = vec3(0.95); }</span></span></span></span></code> </pre> <br> 由于SSAO算法在屏幕空间中起作用，并且阴影因子是根据场景的可见区域计算的，因此在视图空间中进行计算是有意义的。 在这种情况下，从顶点着色器获得的<i>FragPos</i>变量将位置精确存储在视口中。 值得确保将坐标和法线存储在视图空间的G缓冲区中，因为将在其中进行所有进一步的计算。 <br><br><blockquote> 有可能仅基于已知的片段深度和一定数量的数学魔术来恢复位置矢量，例如，在Matt Pettineo的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客中</a>对此进行了描述。 当然，这需要大量的计算成本，但是它消除了将位置数据存储在G缓冲区中的需要，而G缓冲区占用了大量的视频内存。 但是，为了简化示例代码，我们将把这种方法留给个人研究。 </blockquote><br>  <i>gPosition</i>颜色缓冲区纹理配置如下： <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</code> </pre> <br> 该纹理存储片段的坐标，并可用于从样本核心获取每个点的深度数据。 我注意到纹理使用浮点数据格式-这将使片段的坐标不会减少到间隔[0.，1.]。 还请注意重复模式-设置了<i>GL_CLAMP_TO_EDGE</i> 。 这对于消除故意不对屏幕空间进行过度采样的可能性是必要的。 超出纹理坐标的主要间隔会给我们错误的位置和深度数据。 <br><br> 接下来，我们将参与样品半球核心的形成以及随机定向方法的创建。 <br><br><h2> 创建法线导向的半球 </h2><br> 因此，任务是在沿表面法线定向的半球内创建一组采样点。 由于无法在法线的所有可能方向上创建样本核，因此我们使用了到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切线空间</a>的过渡，在该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切线空间中</a> ，法线始终表示为正半轴<i>Z</i>方向上的向量<i>。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br> 假设半球半径是一个单一的过程，则由64个点组成的样本核心的形成如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0.0 - 1.0 std::uniform_real_distribution&lt;float&gt; randomFloats(0.0, 1.0); std::default_random_engine generator; std::vector&lt;glm::vec3&gt; ssaoKernel; for (unsigned int i = 0; i &lt; 64; ++i) { glm::vec3 sample( randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) ); sample = glm::normalize(sample); sample *= randomFloats(generator); float scale = (float)i / 64.0; ssaoKernel.push_back(sample); }</span></span></code> </pre> <br> 在这里，我们随机选择间隔[-1。，1.]中的<i>x</i>和<i>y</i>坐标，以及间隔[0.，1.]中的<i>z</i>坐标（如果间隔与<i>x</i>和<i>y</i>相同，则将得到球心采样）。 最终的样本矢量将限于半球，因为样本的核心最终将沿着表面的法线定向。 <br><br> 目前，所有采样点都随机分布在核心内部，但是出于效果的考虑，更靠近内核原点的采样应该对阴影系数的计算做出更大的贡献。 这可以通过增加形成的采样点在原点附近的密度来改变其分布来实现。 使用加速度插值功能可以轻松完成此任务： <br><br><pre> <code class="cpp hljs">scale = lerp(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, scale * scale); sample *= scale; ssaoKernel.push_back(sample); }</code> </pre> <br>  <i>lerp（）</i>函数定义为： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + f * (b - a); }</code> </pre> <br> 这种技巧为我们提供了一种修改后的分布，其中大多数采样点位于内核原点附近。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h7/dy/xm/h7dyxm-1zerxg1krzbxszp7kzqi.png"></div><br> 每个获得的样本矢量将用于在物种空间中移动片段的坐标，以获得有关周围几何体的数据。 为了在视口中工作时获得良好的结果，您可能需要大量的样本，这必然会影响性能。 但是，在每个经过处理的片段中引入伪随机噪声或样本矢量旋转都会显着减少具有可比质量的所需样本数量。 <br><br><h2> 样品芯随机旋转 </h2><br> 因此，在样本核心中的点分布中引入随机性可以显着降低对这些点的数量的要求，以获得良好的质量效果。 可以为场景的每个片段创建一个随机的旋转矢量，但是从内存上来说太昂贵了。 创建包含一组随机旋转矢量的小纹理，然后将其与<i>GL_REPEAT</i>重复模式<i>集</i>一起使用， <i>效率更高</i> 。 <br><br> 创建一个4x4数组，并用切线空间中沿法向矢量定向的随机旋转矢量填充它： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::vec3&gt; ssaoNoise; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ssaoNoise.push_back(noise); }</code> </pre> <br> 由于核心在切线空间中沿着正半轴<i>Z</i>对齐，因此我们使<i>z</i>分量等于零-这将确保仅绕<i>Z</i>轴旋转。 <br><br> 接下来，创建一个4x4纹理，并用我们的旋转矢量数组填充它。 确保使用<i>GL_REPEAT</i>重播<i>模式</i>来纹理平铺： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noiseTexture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;noiseTexture); glBindTexture(GL_TEXTURE_2D, noiseTexture); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number"><span class="hljs-number">0</span></span>]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br> 好了，现在我们有了直接实现SSAO算法所需的所有数据！ <br><br><h2>  Shader SSAO </h2><br> 将为全屏四边形的每个片段执行一个效果着色器，计算每个片段的阴影系数。 由于结果将在创建最终照明的另一个渲染阶段中使用，因此我们将需要创建另一个framebuffer对象来存储着色器的结果： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoColorBuffer; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBuffer); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br> 由于算法的结果是[0.，1.]中的唯一实数，因此对于存储来说，使用唯一可用的分量创建纹理就足够了。 这就是为什么将<i>GL_RED</i>设置为颜色缓冲区的内部格式的原因。 <br><br> 通常，SSAO阶段渲染过程如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :  G- glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); [...] glBindFramebuffer(GL_FRAMEBUFFER, 0); //  G-      SSAO glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); glClear(GL_COLOR_BUFFER_BIT); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, gPosition); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, gNormal); glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, noiseTexture); shaderSSAO.use(); SendKernelSamplesToShader(); shaderSSAO.setMat4("projection", projection); RenderQuad(); glBindFramebuffer(GL_FRAMEBUFFER, 0); //  :    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shaderLightingPass.use(); [...] glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); [...] RenderQuad();</span></span></code> </pre> <br>  <i>shaderSSAO</i>着色器接受所需的G缓冲区纹理作为输入，以及噪波纹理和样本核心： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D texNoise; uniform vec3 samples[64]; uniform mat4 projection; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//             //      1280x720 const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); void main() { [...] }</span></span></span></span></code> </pre> <br> 注意变量<i>noiseScale</i> 。 我们带有噪点的小纹理应该平铺在屏幕的整个表面上，但是由于<i>TexCoords的</i>纹理坐标在[0.，1.]范围内，因此如果没有我们的干预就不会发生。 为此，我们计算纹理坐标的因数，该因数是屏幕尺寸与噪声纹理尺寸的比值： <br><br><pre> <code class="cpp hljs">vec3 fragPos = texture(gPosition, TexCoords).xyz; vec3 normal = texture(gNormal, TexCoords).rgb; vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;</code> </pre> <br> 由于创建<i>texNoise</i>噪声纹理时，我们将重复模式设置为<i>GL_REPEAT</i> ，现在它将在屏幕表面重复很多次。 有了<i>randomVec</i> ， <i>fragPos</i>和<i>法线</i>值，我们可以创建从切线到物种空间的TBN转换矩阵： <br><br><pre> <code class="cpp hljs">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal)); vec3 bitangent = cross(normal, tangent); mat3 TBN = mat3(tangent, bitangent, normal);</code> </pre> <br> 使用Gram-Schmidt过程，我们基于随机值<i>randomVec</i>创建在每个片段中随机倾斜的正交基础。 重要的一点是：因为在这种情况下，TBN矩阵沿三角形的表面精确定向（对于视差映射而言，大约为1/3）对我们来说并不重要。 <br><br> 接下来，我们遍历样本核的数组，将每个样本向量从切线空间转换为物种空间，并获得其与当前片段位置的和。 然后，我们将结果量的深度值与通过从相应的G缓冲区纹理采样获得的深度值进行比较。 <br><br> 虽然听起来令人困惑，但让我们逐步执行以下步骤： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> occlusion = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kernelSize; ++i) { <span class="hljs-comment"><span class="hljs-comment">//     vec3 sample = TBN * samples[i]; //      - sample = fragPos + sample * radius; [...] }</span></span></code> </pre> <br> 在此， <i>kernelSize</i>和<i>radius</i>是控制效果特征的变量。 在这种情况下，它们分别是64和0.5。 在每次迭代中，我们将样本核心向量转换到物种空间中。 接下来，我们将获得的样本在物种空间中的位移值加上片段在物种空间中的位置值。 在这种情况下，偏移值将乘以半径变量，该变量控制SSAO效果样本的核心半径。 <br><br> 完成这些步骤之后，我们应该将所得的<i>样本</i>矢量转换为屏幕空间，以便我们可以使用获得的投影值从G缓冲区纹理中进行选择，该纹理存储片段的位置和深度。 由于<i>样本</i>在视口中，因此我们需要投影<i>投影</i>矩阵： <br><br><pre> <code class="cpp hljs">vec4 offset = vec4(sample, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); offset = projection * offset; <span class="hljs-comment"><span class="hljs-comment">//     offset.xyz /= offset.w; //   offset.xyz = offset.xyz * 0.5 + 0.5; //    [0., 1.]</span></span></code> </pre> <br> 转换为剪辑空间后，我们通过将<i>xyz</i>分量除以<i>w</i>分量来手动执行透视划分。 归一化的设备坐标（ <i>NDC</i> ）中的结果矢量被转换为值[0.，1.]的间隔，因此可以将其用作纹理坐标： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleDepth = texture(gPosition, offset.xy).z;</code> </pre> <br> 我们使用<i>样本</i>向量的<i>xy</i>分量从纹理中选择G缓冲区的位置。 从观察者的位置（这是第一个未屏蔽的可见片段）观察时，我们获得与样本矢量对应的深度值（ <i>z</i>分量）。 如果同时获得的采样深度大于存储的深度，则我们增加阴影系数： <br><br><pre> <code class="cpp hljs">occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre> <br> 注意<i>偏置</i>偏移，它已添加到原始片段深度（在示例中设置为0.025）。 并非总是需要此偏移量，但是变量的存在使您可以控制SSAO效果的外观，并且在某些情况下还可以消除阴影区域中的波纹问题。 <br><br> 但这还不是全部，因为这样的实现会导致明显的工件。 当考虑到某个表面边缘附近的碎片时，它就会显现出来。 在这种情况下，当比较深度时，该算法将不可避免地捕获表面的深度，该深度可能远远超出所考虑的深度。 在这些地方，该算法将错误地大大增加阴影的程度，这将在对象的边缘产生明显的暗晕。 通过引入额外的距离检查来处理工件（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">John Chapman</a>的示例）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/yv/eq/zvyveqh3zc_rjcy6fo-z8d76eme.png"></div><br> 该检查将仅对位于样本半径内的深度值限制对阴影系数的贡献： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rangeCheck = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, radius / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(fragPos.z - sampleDepth)); occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * rangeCheck;</code> </pre> <br> 我们还使用GLSL <i>smoothstep（）</i>函数，该函数在第一个和第二个之间实现了第三个参数的平滑插值。 同时，如果第三个参数小于或等于第一个，则返回0；如果第三个参数大于或等于第二个，则返回1。 如果深度差在<i>radius</i>内，则将按照以下曲线在[0.，1.]区间内平滑其值： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/9h/p4/jq9hp4-yun_sc277m6pslbjyin0.png"></div><br> 如果在检查深度的条件下使用清晰的边界，则会在深度差值超出<i>radius</i>限制的那些地方以尖锐边界的形式添加伪影。 <br><br> 最后，我们使用样本核心的大小对阴影系数的值进行归一化，并记录结果。 我们还通过从单位减去最终值来反转最终值，以便您可以直接使用最终值来调制照明的背景成分，而无需执行其他步骤： <br><br><pre> <code class="cpp hljs">} occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = occlusion;</code> </pre> <br> 对于我们熟悉的具有躺着的纳米套装的场景，执行SSAO着色器将产生以下纹理： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-z/a4/fx/-za4fxhsbref6easc-cgxnsp94q.png"></div><br> 如您所见，背景阴影效果会产生良好的深度错觉。 仅着色器的输出图像已经允许您区分服装的细节，并确保服装确实位于地板上，并且不会与服装保持一定距离。 <br><br> 然而，由于随机旋转矢量的纹理引入的噪声模式很容易注意到，因此效果远非理想。 为了平滑SSAO计算的结果，我们应用了模糊滤镜。 <br><br><h2> 模糊背景底纹 </h2><br> 建立SSAO的结果之后，在最终混合照明之前，有必要对存储有关阴影系数数据的纹理进行模糊处理。 为此，我们将有另一个帧缓冲区： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoBlurFBO, ssaoColorBufferBlur; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoBlurFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBufferBlur); glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br> 在屏幕空间中平铺噪声纹理可提供定义良好的随机性特征，您可以在创建模糊滤镜时利用该特征： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D ssaoInput; void main() { vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0)); float result = 0.0; for (int x = -2; x &lt; 2; ++x) { for (int y = -2; y &lt; 2; ++y) { vec2 offset = vec2(float(x), float(y)) * texelSize; result += texture(ssaoInput, TexCoords + offset).r; } } FragColor = result / (4.0 * 4.0); }</span></span></code> </pre> <br> 着色器仅将SSAO纹理的纹理元素从-2偏移到+2，这与噪声纹理的实际大小相对应。 偏移量等于一个纹理元素的确切大小：textureSize <i>（）</i>函数用于计算，该函数返回带有指定纹理尺寸的<i>vec2</i> 。  T.O. 着色器仅对存储在纹理中的结果进行平均，即可提供快速有效的模糊效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/0g/i7/5p0gi7qn_v5w738uyindxexally.png"></div><br> 总的来说，我们在屏幕上的每个片段都有一个带有背景阴影数据的纹理-一切准备就绪，可以进行最终图像缩小！ <br><br><h2> 应用背景底纹 </h2><br> 在照明的最终计算中应用阴影系数的步骤非常简单：对于每个片段，只需将光源的背景成分的值乘以准备好的纹理的阴影系数就足够了。 您可以使用关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟着色</a>的课程中的Blinn-Fong模型获取现成的着色器，并进行一些校正： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D gAlbedo; uniform sampler2D ssao; struct Light { vec3 Position; vec3 Color; float Linear; float Quadratic; float Radius; }; uniform Light light; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    G- vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedo, TexCoords).rgb; float AmbientOcclusion = texture(ssao, TexCoords).r; //   -    //   :   -  vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion); vec3 lighting = ambient; //    (0, 0, 0)   - vec3 viewDir = normalize(-FragPos); //   vec3 lightDir = normalize(light.Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color; //   vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0); vec3 specular = light.Color * spec; //   float dist = length(light.Position - FragPos); float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br> 仅存在两个主要变化：在视口中过渡到计算，以及将背景照明分量乘以<i>AmbientOcclusion</i>的值。 带有单个蓝点灯的场景示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/8_/1i/bz8_1in-othscilg_udfyscghg0.png"></div><br> 完整的源代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br><br>  SSAO效果的表现在很大程度上取决于参数，例如<i>kernelSize</i> ， <i>radius</i>和<i>bias</i> ，经常对它们进行微调是艺术家确定特定位置/场景的理所当然的事情。 没有参数的“最佳”和通用组合：对于某些场景，样本核心的半径较小是好的，而另一些则受益于样本半径和数量增加。 该示例使用了64个采样点，坦率地说，这是多余的，但是您始终可以编辑代码，并查看使用较少数量的采样会发生的情况。 <br><br> 除了列出的负责设定效果的制服外，还可以明确控制背景阴影效果的严重性。 为此，将系数提高到另一个制服控制的程度就足够了： <br><br><pre> <code class="cpp hljs">occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(occlusion, power);</code> </pre> <br> 我建议您花一些时间在游戏上进行设置，因为这样可以更好地理解最终图片中更改的性质。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总而言之，值得一提的是，尽管使用SSAO的视觉效果相当微妙，但是在光线充足的场景中，无疑会增加明显的真实感。</font><font style="vertical-align: inherit;">在您的武器库中拥有这样的工具肯定是有价值的。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他资源 </font></font></h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAO教程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：John Chapman的精彩课程文章，在此基础上构建了该课程的代码。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解您的SSAO工件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一篇非常有价值的文章，清楚地介绍了SSAO质量最紧迫的问题，以及解决这些问题的方法。</font><font style="vertical-align: inherit;">推荐阅读。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有深度重建</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的SSAO：OGLDev在SSAO主要课程的附录中，介绍了一种基于深度恢复片段坐标的常用技术。</font><font style="vertical-align: inherit;">这种方法的重要性是由于无需在G缓冲区中存储位置而节省了大量内存。</font><font style="vertical-align: inherit;">该方法是如此普遍，就其而言，它适用于SSAO。</font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我们有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电报会议，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以协调转账。</font><font style="vertical-align: inherit;">如果您有强烈的帮助翻译的愿望，欢迎您！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421385/">https://habr.com/ru/post/zh-CN421385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421375/index.html">不确定性如何杀死商业</a></li>
<li><a href="../zh-CN421377/index.html">Gamedev中新手项目经理的7个误解</a></li>
<li><a href="../zh-CN421379/index.html">英特尔有毒文化</a></li>
<li><a href="../zh-CN421381/index.html">思科ASA管理员免费课程</a></li>
<li><a href="../zh-CN421383/index.html">Epic Growth Conference Autumn 2018-莫斯科产品营销会议</a></li>
<li><a href="../zh-CN421387/index.html">采访Linux Piter上的Lennart Pottering，了解Linux的变化，systemd以及参加会议的原因</a></li>
<li><a href="../zh-CN421389/index.html">津布拉行政权分立</a></li>
<li><a href="../zh-CN421391/index.html">HackThings-9月7日至9日在Skoltech举行的大型物联网马拉松</a></li>
<li><a href="../zh-CN421393/index.html">被遗弃的Mailchimp篮：懒惰指南</a></li>
<li><a href="../zh-CN421395/index.html">2018年罗马俱乐部的报告，第3.7章：“气候：好消息，但大问题”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>