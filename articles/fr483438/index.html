<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌬️ 🤜🏻 💇🏽 Jouez "osu!", N'oubliez pas les erreurs 😹 💘 🛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous accueillons tous les amateurs d'exotisme et de peu d'erreurs dans le code. Aujourd'hui sur le banc d'essai PVS-Studio est un invité assez rare - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jouez "osu!", N'oubliez pas les erreurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483438/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="Image 1" align="left"></p>  Nous accueillons tous les amateurs d'exotisme et de peu d'erreurs dans le code.  Aujourd'hui sur le banc d'essai PVS-Studio est un invité assez rare - un jeu en C #.  À savoir, osu!  Comme d'habitude: recherchez les erreurs, réfléchissez, jouez. <br><a name="habracut"></a><br><h2>  Le jeu </h2><br>  Osu!  - Un jeu de rythme musical open source.  À en juger par les informations du <a href="https://osu.ppy.sh/home">site Web du jeu</a> , il est assez populaire, car plus de 15 millions de joueurs inscrits sont déclarés.  Le projet se caractérise par un gameplay gratuit, un design coloré avec la possibilité de personnaliser les cartes, des fonctionnalités avancées pour compiler un classement en ligne des joueurs, la présence du multijoueur, un large éventail de compositions musicales.  Je ne décrirai pas le jeu en détail, les intéressés trouveront facilement toutes les informations sur le réseau.  Par exemple, <a href="https://en.wikipedia.org/wiki/Osu!">ici</a> . <br><br>  Je suis plus intéressé par le code source du projet, qui peut être téléchargé depuis <a href="https://github.com/ppy/osu">GitHub</a> .  Un nombre important de validations (plus de 24 mille) dans le référentiel attire immédiatement l'attention, ce qui indique le développement actif du projet, qui se poursuit à ce jour (le jeu est sorti en 2007, mais le travail a probablement commencé plus tôt).  Dans le même temps, il n'y a pas beaucoup de code source - 1813 fichiers .cs qui contiennent 135 000 lignes de code, à l'exclusion de celles vides.  Ce code contient des tests que je ne prends généralement pas en compte dans les contrôles.  Le code de test est contenu dans 306 fichiers .cs et, par conséquent, 25 000 lignes de code, à l'exclusion des lignes vides.  Il s'agit d'un petit projet: à titre de comparaison, le cœur C # de l'analyseur PVS-Studio contient environ 300 000 lignes de code. <br><br>  Au total, pour vérifier le jeu pour les erreurs, j'ai utilisé des projets non-test contenant 1507 fichiers de code source et 110 mille lignes.  Cependant, le résultat m'a partiellement plu, car il y a eu plusieurs erreurs intéressantes dont je m'empresse de vous parler. <br><br><h2>  Erreurs </h2><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a> Il existe des sous-expressions identiques 'result == HitResult.Perfect' à gauche et à droite de '||'  opérateur.  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br>  Un bon exemple de programmation orientée copier-coller.  Un terme comique que mon collègue Valery Komarov a récemment utilisé (introduit) dans son article " <a href="https://www.viva64.com/ru/b/0699/">Top 10 des erreurs dans les projets Java pour 2019</a> ". <br><br>  Ainsi, deux contrôles identiques se succèdent.  L'une des vérifications devrait très probablement contenir une autre <i>constante d'</i> énumération <i>HitResult</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br>  Quelle constante particulière devait être utilisée, ou la deuxième vérification n'est-elle pas nécessaire du tout?  Questions auxquelles seul le développeur peut répondre.  Dans tous les cas, une erreur a été commise qui fausse la logique du programme. <br><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a> Il existe des sous-expressions identiques «famille! = GetFamilyString (TournamentTypeface.Aquatico)» à gauche et à droite de l'opérateur «&amp;&amp;».  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br>  Et encore une fois copier-coller.  J'ai formaté le code, donc l'erreur est facilement perceptible.  Dans la version originale, la condition entière était écrite sur une seule ligne.  Il est également difficile de dire comment le code peut être corrigé.  L'énumération <i>TournamentTypeface</i> contient une seule constante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br>  La condition peut avoir utilisé la variable <i>familiale</i> deux fois par erreur, mais ce n'est pas exact. <br><br>  <a href="https://www.viva64.com/ru/w/v3009/">V3009</a> [CWE-393] Il est étrange que cette méthode renvoie toujours une seule et même valeur de 'false'.  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  La méthode retournera toujours <i>false</i> .  Pour de telles erreurs, je vérifie généralement le code appelant, car ils n'utilisent souvent la valeur de retour nulle part, il n'y a pas d'erreur (sauf pour le style de programmation laid).  Dans ce cas, je suis tombé sur le code suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Comme vous pouvez le voir, le résultat renvoyé par la méthode <i>OnPressed</i> est utilisé.  Et comme il est toujours <i>faux</i> , le résultat de l'appel <i>OnPressed</i> sera également toujours <i>faux</i> .  Je pense que vous devriez vérifier à nouveau ce code, car il y a une forte probabilité d'erreur. <br><br>  Une autre erreur similaire: <br><br><ul><li>  V3009 [CWE-393] Il est étrange que cette méthode renvoie toujours une seule et même valeur de 'false'.  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3042/">V3042</a> [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'val.NewValue' TournamentTeam.cs 41 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br>  Dans la condition de l'opérateur <i>?:</i> , La variable <i>val.NewValue</i> n'est pas sûre.  L'analyseur a fait une telle conclusion, car dans la branche alors, une option sûre est utilisée pour accéder à la variable via l' <i>instruction d'</i> accès conditionnel <i>val.NewValue? .Substring (....)</i> . <br><br>  Une autre erreur similaire: <br><br><ul><li>  V3042 [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'val.NewValue' TournamentTeam.cs 48 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3042/">V3042</a> [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'api' SetupScreen.cs 77 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br>  Ce code est moins clair, mais je pense que l'erreur est toujours là.  Créez un objet de type <i>ActionableInfo</i> .  Le champ <i>Action</i> est initialisé avec un lambda, dans le corps duquel il n'est pas sûr de travailler avec une <i>API de</i> référence potentiellement nulle.  L'analyseur a considéré ce modèle comme une erreur, car lors de l'initialisation du paramètre <i>Value</i> , la variable <i>api</i> fonctionne en toute sécurité.  J'ai appelé l'erreur ambiguë, car le code lambda suppose une exécution retardée et, peut-être, le développeur garantit en quelque sorte une valeur non nulle du lien <i>api</i> .  Mais ce n'est qu'une hypothèse, car le corps lambda ne contient aucun signe de travail sûr avec le lien (contrôles préliminaires, par exemple). <br><br>  <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> [CWE-683] Ordre incorrect possible des arguments passés à la méthode 'Atan2': 'diff.X' et 'diff.Y'.  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br>  L'analyseur soupçonnait qu'en travaillant avec la méthode <i>Atan2</i> de la classe <i>Math</i> , le développeur mélangeait l'ordre des arguments.  <i>Annonce Atan2</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br>  Comme vous pouvez le voir, les valeurs ont été transférées dans l'ordre inverse.  Je ne peux pas juger si c'est une erreur, car la méthode <i>UpdateProgress</i> contient beaucoup de calculs non triviaux.  Je note juste le fait d'un problème possible dans le code. <br><br>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> [CWE-476] <a href="https://www.viva64.com/ru/w/v3080/">Déréférence</a> nulle possible.  Pensez à inspecter «Beatmap».  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br>  L'analyseur a souligné le danger d'accès via le lien nul <i>Beatmap</i> .  Voici ce que c'est: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br>  Eh bien, l'analyseur a raison. <br><br>  Pour plus d'informations sur la façon dont PVS-Studio détecte ces erreurs, ainsi que sur les innovations C # 8.0 liées à des sujets similaires (travail avec des références potentiellement nulles), consultez l'article " <a href="https://www.viva64.com/ru/b/0631/">Types de référence nullables en C # 8.0 et analyse statique</a> ". <br><br>  <a href="https://www.viva64.com/ru/w/v3083/">V3083</a> [CWE-367] L'appel non sécurisé de l'événement 'ObjectConverted', NullReferenceException est possible.  Pensez à affecter un événement à une variable locale avant de l'invoquer.  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br>  Erreur non critique et assez courante.  Entre la vérification de la <i>nullité de</i> l'événement et son invocation, ils peuvent se désinscrire de l'événement, ce qui entraînera le plantage du programme. <br>  L'un des correctifs: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3095/">V3095</a> [CWE-476] L'objet 'colonnes' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 141, 142. SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br>  Il n'est pas sûr de contourner la collection de <i>colonnes</i> dans une boucle.  Dans le même temps, le développeur a supposé que le lien des <i>colonnes</i> pouvait être nul, car plus tard dans le code, un opérateur d'accès conditionnel était utilisé pour accéder à la collection. <br><br>  <a href="https://www.viva64.com/ru/w/v3119/">V3119 L'</a> appel de l'événement ignoré 'OnNewResult' peut entraîner un comportement imprévisible.  Envisagez d'implémenter explicitement les accesseurs d'événements ou utilisez un mot clé «scellé».  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br>  L'analyseur avertit des dangers liés à l'utilisation d'un événement ignoré ou virtuel.  Quel est exactement le danger - je suggère de lire la <a href="https://www.viva64.com/ru/w/v3119/">description</a> du diagnostic.  Aussi, à un moment donné, j'ai écrit un article sur ce sujet, « <a href="https://www.viva64.com/ru/b/0453/">Événements virtuels en C #: quelque chose s'est mal passé</a> ». <br><br>  Une autre construction dangereuse similaire dans le code: <br><br><ul><li>  V3119 L'appel d'un événement ignoré peut entraîner un comportement imprévisible.  Envisagez d'implémenter explicitement les accesseurs d'événements ou utilisez un mot clé «scellé».  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3123/">V3123</a> [CWE-783] Peut-être le '??'  L'opérateur fonctionne d'une manière différente de celle attendue.  Sa priorité est inférieure à la priorité des autres opérateurs dans sa partie gauche.  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br>  Pour une meilleure compréhension du problème - je vais donner un exemple synthétique de la façon dont le code fonctionne maintenant: <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br>  L'erreur a été commise du fait que l'opérateur * a une priorité plus élevée que l'opérateur ??.  Version corrigée du code (crochets ajoutés): <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br>  Une autre erreur similaire dans le code: <br><br>  <a href="https://www.viva64.com/ru/w/v3123/">V3123</a> [CWE-783] Peut-être le '??'  L'opérateur fonctionne d'une manière différente de celle attendue.  Sa priorité est inférieure à la priorité des autres opérateurs dans sa partie gauche.  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  Ici, comme dans le fragment de code précédent, la priorité des opérateurs n'a pas été prise en compte.  Maintenant, l'expression passée à la méthode <i>Math.Abs</i> est évaluée comme suit: <br><br><pre> <code class="cs hljs">(a – b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Code corrigé: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime – (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3142/">V3142</a> [CWE-561] Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br>  L'analyseur prétend que le <i>code du</i> gestionnaire <i>OnPressed</i> , en commençant par la deuxième <i>instruction if</i> , est inaccessible.  Cela découle de l'hypothèse que la première condition est toujours vraie, c'est-à-dire que la méthode <i>base.OnPressed</i> retournera toujours <i>false</i> .  <i>Jetez un</i> œil à la méthode <i>base.OnPressed</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Nous passons à la méthode <i>UpdateResult</i> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br>  Notez que l'implémentation de la propriété <i>Judged</i> n'est pas importante ici, car la logique de la méthode <i>UpdateResult</i> implique que la dernière <i>instruction de retour est</i> équivalente à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Ainsi, la méthode <i>UpdateResult</i> retournera toujours <i>false</i> , ce qui entraînera une erreur avec du code inaccessible dans le code au-dessus de la pile. <br><br>  <a href="https://www.viva64.com/ru/w/v3146/">V3146</a> [CWE-476] <a href="https://www.viva64.com/ru/w/v3146/">Déréférence</a> nulle possible de 'jeu de règles'.  Le 'FirstOrDefault' peut renvoyer la valeur nulle par défaut.  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br>  L'analyseur considère que l'appel de <i>ruleset.CreateInstance () n'est</i> pas sûr.  La variable d'ensemble de <i>règles</i> obtient précédemment la valeur suite à l'appel de <i>GetRuleset</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br>  Comme vous pouvez le voir, l'avertissement de l'analyseur est justifié, car la chaîne d'appel contient <i>FirstOrDefault</i> , qui peut retourner <i>null</i> . <br><br><h2>  Conclusion </h2><br>  En général, le projet de jeu "osu!" Satisfait d'un petit nombre d'erreurs.  Néanmoins, je recommande aux développeurs de faire attention aux problèmes détectés.  Et laissez le jeu continuer de plaire à ses fans. <br><br>  Et pour ceux qui aiment approfondir le code, je vous rappelle que l'analyseur PVS-Studio, qui est facile à <a href="https://www.viva64.com/ru/pvs-studio-download/">télécharger</a> sur le site officiel, sera d'une bonne aide.  Je note également que les vérifications de projet ponctuelles, telles que celles décrites ci-dessus, n'ont rien à voir avec l'utilisation d'un analyseur statique dans le travail réel.  Une efficacité maximale dans la lutte contre les erreurs ne peut être atteinte qu'avec une utilisation régulière de l'outil à la fois sur le serveur de build et directement sur l'ordinateur du développeur (analyse incrémentale).  L'objectif maximum est d'empêcher les erreurs de pénétrer dans le système de contrôle de version, en corrigeant les défauts déjà au stade de l'écriture du code. <br><br>  Bonne chance et succès! <br><br><h2>  Les références </h2><br>  Il s'agit de la première publication en 2020.  Profitant de cette opportunité, je fournirai des liens vers des articles sur la vérification des projets C # l'année dernière: <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0605/">Recherche de bogues dans le code source Amazon Web Services SDK for .NET</a> </li><li>  <a href="https://www.viva64.com/ru/b/0622/">Vérification du code source de Roslyn</a> </li><li>  <a href="https://www.viva64.com/ru/b/0631/">Types de référence nullables dans C # 8.0 et analyse statique</a> </li><li>  <a href="https://www.viva64.com/ru/b/0653/">WinForms: erreurs, Holmes</a> </li><li>  <a href="https://www.viva64.com/ru/b/0654/">L'histoire de la façon dont PVS-Studio a trouvé une erreur dans la bibliothèque utilisée dans ... PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0656/">Vérification du code source des bibliothèques .NET Core par l'analyseur statique PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0664/">Vérification des analyseurs Roslyn</a> </li><li>  <a href="https://www.viva64.com/ru/b/0677/">Vérifiez l'interface utilisateur Telerik pour UWP pour vous familiariser avec PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0678/">Azure PowerShell: «principalement inoffensif»</a> </li><li>  <a href="https://www.viva64.com/ru/b/0681/">Nous recherchons et analysons les erreurs dans le code CMS Orchard</a> </li><li>  <a href="https://www.viva64.com/ru/b/0683/">Vérification de l'encapsuleur OpenCvSharp sur OpenCV avec PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0692/">SDK Azure pour .NET: L'histoire d'une recherche de bogue difficile</a> </li><li>  <a href="https://www.viva64.com/ru/b/0694/">SDK SARIF et ses erreurs</a> </li><li>  <a href="https://www.viva64.com/ru/b/0698/">Top 10 des bugs dans les projets C # pour 2019</a> </li></ul><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/483436/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov.  <a href="https://habr.com/en/company/pvs-studio/blog/483436/">Jouez "osu!", Mais attention aux bugs</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483438/">https://habr.com/ru/post/fr483438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483418/index.html">Systèmes de billetterie: comment avez-vous payé trois OTRS gratuits?</a></li>
<li><a href="../fr483424/index.html">DBA: transfert de valeurs SEQUENCE entre des bases de données PostgreSQL</a></li>
<li><a href="../fr483426/index.html">Enquête sur l'onglet du vendredi</a></li>
<li><a href="../fr483428/index.html">Quelle sera la gestion électronique des documents après l'entrée en vigueur des amendements à la loi sur la signature électronique?</a></li>
<li><a href="../fr483436/index.html">Jouez "osu!", Mais attention aux bugs</a></li>
<li><a href="../fr483440/index.html">Derniers compilateurs D</a></li>
<li><a href="../fr483444/index.html">Rapport DORA 2019: comment améliorer les performances de DevOps</a></li>
<li><a href="../fr483446/index.html">Les scientifiques ont trouvé une nouvelle façon de réduire les niveaux de fer dans l'eau potable</a></li>
<li><a href="../fr483448/index.html">Disney - Le plus grand double sens de l'histoire de l'humanité</a></li>
<li><a href="../fr483454/index.html">Passer de Mercurial à GIT dans Atlassian Bitbucket avec enregistrer des fichiers en cyrillique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>