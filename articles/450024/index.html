<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔠 🌕 👱 Acerca de las implementaciones de código abierto de la función hash GOST R 34.11-2012 y su impacto en la firma electrónica de GOST R 34.10-2012 📧 💅🏿 ⚓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un momento, la implementación de algoritmos criptográficos domésticos en la biblioteca libgcrypt me inspiró mucho. Se hizo posible usar estos algor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acerca de las implementaciones de código abierto de la función hash GOST R 34.11-2012 y su impacto en la firma electrónica de GOST R 34.10-2012</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450024/"><img src="https://habrastorage.org/webt/_f/ce/y_/_fcey_1t2afkou2xu5zql3xuzbk.png" align="left">  En un momento, la implementación de algoritmos criptográficos domésticos en la biblioteca libgcrypt me inspiró mucho.  Se hizo posible usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estos algoritmos</a> en Kleopatra y en Kmail y GnuPg en general, para considerar la biblioteca libgcrypt como una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alternativa a openssl</a> con el motor GOST.  Y todo estuvo genial hasta el viernes pasado. <br><a name="habracut"></a><br>  Me pidieron que verificara la firma electrónica de GOST R 34.10-2012-256 para un documento creado en Microsoft Office en MS Windows.  Y decidí comprobarlo en Kleopatra (tengo Linux).  Y qué piensas, la firma resultó ser incorrecta.  Las dudas surgieron.  Decidí comprobar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSSL con el</a> motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GOST</a> .  La firma ha sido verificada con éxito.  Re-firmó urgentemente el archivo en Kleopatra y no pasó la verificación en MS Windows.  Intentamos firmar y verificar otros archivos, todo estaba bien.  La pregunta era ¿cuál es el problema?  Dado que el hash del documento está involucrado en la firma, se decidió verificar el cálculo del hash por diferentes programas.  En primer lugar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estaban involucradas implementaciones de código abierto para stribog</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La famosa implementación de Degtyarev</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de Libgcrypt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libressl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motor Openssl</a> </li></ul><br>  Y luego hubo un shock!  El hash calculado por la "famosa implementación de Degtyarev" coincidió con el hash calculado en openssl con el GOST del endine, pero no coincidió con el valor de hash calculado usando libgcrypt y libressl. <br><br>  Cómo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ru_crypt</a> tenía razón cuando escribió al principio de su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> : <br><blockquote>  Inmediatamente le advierto que no verifiqué la corrección de las implementaciones. </blockquote><br>  Por cierto, el estándar en GOST R 34.10-2012 también dice que los ejemplos de control son solo de referencia.  Debe entenderse claramente que los casos de prueba no garantizan que diferentes implementaciones den el mismo resultado para todas las ocasiones. <br><br>  Para calcular los valores hash, se utilizaron las siguientes utilidades: <br><br>  1) openssl <br><br><pre><code class="bash hljs">$ openssl dgst [–md_gost12_256|-md_gost12_512] &lt;file&gt;</code> </pre> <br>  2) libressl <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$libressl</span></span> dgst [–streebog256|streebog512] &lt;file&gt;</code> </pre> <br>  3) libgcrypt <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$gchash</span></span> [stribog256|stribog512] &lt;file&gt;</code> </pre> <br>  4) La famosa implementación de Degtyarev <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$gost3411</span></span>-2012 [-2|-5] &lt;file&gt;</code> </pre> <br>  Aquí también hay algo interesante: en la transcripción latina, los stribogs escriben stribog o streebog.  Sería bueno llegar a la uniformidad.  Y entonces parece que estas son funciones diferentes.  Personalmente, prefiero la primera opción: stribog. <br><br>  Necesitaba un árbitro. <br><br>  Como árbitro, se decidió utilizar el token PKCS # 11 RUTOKEN EDS-2.0, que admite los estándares criptográficos rusos GOST R 34.10-2012, GOST R 34.11-2012, VKO GOST R 34.10-2012 (RFC 7836) con una longitud de clave de 256 y 512 bits y está certificado por el FSB de Rusia como un medio de protección de información criptográfica (CPSI) y un medio de firma electrónica. <br><br>  Además, el token RUTOKEN EDS-2.0 está ampliamente distribuido y muchos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">certificados de tienda</a> en él para acceder a los servicios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estatales</a> y otros portales. <br>  Para calcular el valor hash en el token, utilizaremos el script test_digest.tcl en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tcl</a> : <br><br><div class="spoiler">  <b class="spoiler_title">test_digest.tcl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" #set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\ndigest &lt;stribog256|stribog512&gt; &lt;file for digest&gt;\n" } } set countcert [llength $argv] if { $countcert != 2 } { usage 1 "Bad usage!" exit } set digest_algo [lindex $argv 0] if {$digest_algo != "stribog256" &amp;&amp; $digest_algo != "stribog512"} { usage 1 "Bad usage!" exit } set file [lindex $argv 1] if {![file exists $file]} { usage 1 "File $file not exist" exit } puts "Loading file for digest: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file: $file" exit } set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set digest_hex [pki::pkcs11::digest $digest_algo $cert_user $aa] puts "digest_hex=\n$digest_hex" exit</code> </pre> <br></div></div><br>  ¿Cuándo aparece esta discrepancia en la implementación?  Hasta ahora, ha sido posible determinar que esta discrepancia se produce al calcular el hash de los archivos doc creados en MS Office.  Además, el hash de los primeros 143 bytes se considera igual, y cuando se calcula el hash de 144 bytes, los valores son diferentes. <br><br>  Los primeros 143 bytes en hexadecimal se ven así: <br><br><pre> <code class="bash hljs">d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000002400000001000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code> </pre> <br>  Guárdelos en el archivo Doc1_143_hex.txt. <br><br>  Los primeros 144 bytes en hexadecimal se ven así: <br><br><pre> <code class="bash hljs">d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000002400000001000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code> </pre> <br>  Guárdelos en el archivo Doc1_144_hex.txt. <br><br>  Es conveniente usar el script hex2bin.tcl para traducir de hexadecimal a binario: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh proc usage {use error} { if {$use == 1} { puts $error puts "Usage:\nhex2bin &lt;file with hex&gt; &lt;file for bin&gt;\n" } } set countcert [llength $argv] if { $countcert != 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with hex: $file" exit } set cert_user [binary format H* $cert_user] set fd [open [lindex $argv 1] w] chan configure $fd -translation binary puts -nonewline $fd $cert_user close $fd</code> </pre> <br>  Convierta el código hexadecimal a binario: <br><pre> <code class="bash hljs">$./hex2bin Doc1_143_hex.txt Doc1_143.bin $./hex2bin Doc1_144_hex.txt Doc1_144.bin $</code> </pre> <br>  Ahora puede verificar cómo se calcula el hash mediante diversas implementaciones: <br>  Primero, considere el hash para el archivo Doc1_143, bin: <br><br><pre> <code class="bash hljs">$ ./openssl dgst -md_gost12_256 Doc1_143.bin md_gost12_256(Doc1_143.bin)= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $ ./libressl dgst -streebog256 Doc1_143.bin streebog256(Doc1_143.bin)= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $ ./gchash stribog256 Doc1_143.bin e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 Doc1_143.bin $ ./gost3411-2012 -2 Doc1_143.bin GOST R 34.11-2012 (Doc1_143.bin) = e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $</code> </pre> <br>  Ha llegado el momento más importante, el momento de la verificación en un sistema de protección de información criptográfica certificado: <br><br><pre> <code class="bash hljs">$ ./test_digest.tcl stribog256 Doc1_143.bin Connect the Token and press Enter Loading file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> digest: Doc1_143.bin digest_hex= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $</code> </pre> <br>  Como puede ver, todo terminó para siempre. <br><br>  Veamos qué sucede con el archivo Doc1_144.bin: <br><br><pre> <code class="bash hljs">$ ./openssl dgst -md_gost12_256 Doc1_144.bin md_gost12_256(Doc1_144.bin)= c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $ ./libressl dgst -streebog256 Doc1_144.bin streebog256(Doc1_144.bin)= 3965c99777eb1b64c783496fe950aa6540bc7baa399a3889995145afbdd76250 $</code> </pre> <br>  Eso es todo, los valores de los hashes no coinciden.  Para la pureza del experimento, verificamos las implementaciones restantes: <br><br><pre> <code class="bash hljs">$ ./gchash_1.7.10 stribog256 Doc1_144.bin 3965c99777eb1b64c783496fe950aa6540bc7baa399a3889995145afbdd76250 Doc1_144.bin $ ./gost3411-2012 -2 Doc1_144.bin GOST R 34.11-2012 (Doc1_144.bin) = c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $ ./test_digest.tcl stribog256 Doc1_144.bin Connect the Token and press Enter Loading file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> digest: Doc1_144.bin digest_hex= c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $</code> </pre> <br>  El hash calculado por la "famosa implementación de Degtyarev" coincide con el hash calculado en openssl con el motor GOST, pero no coincide con el valor de hash calculado usando libgcrypt y libressl. <br><br>  Obtenemos un resultado similar si consideramos el hash stribog512. <br><br>  Hay una conclusión  Si desea que la firma electrónica GOST R 34.10-2012 generada por libressl y libgcrypt (u otros) sea compatible con openssl y, lo más importante, con la protección de la información criptográfica certificada en el sistema de certificación FSB de Rusia, use verificado implementaciones para calcular hashes.  Espero que esta publicación evite muchos malentendidos, y los autores de la implementación de stribog en libressl, libgrypt y posiblemente otros ayudarán a eliminar estas discrepancias.  Hoy, debo admitir que, en los productos anteriores, en realidad no se implementa GOST R 34.10-2012, sino algo más.  Este es un algoritmo diferente.  El ejemplo de prueba dado probablemente sería bueno incluirlo como ejemplo de prueba para GOST R 34.10-2012.  Y voy a editar libgcrypt para Kleopatra y KMail.  La leyenda de Cleopart y la criptografía rusa estaba inacabada. <br><br>  PD: El artículo ya estaba listo cuando mi colega dijo que la discrepancia entre las implementaciones aparece cuando se encuentra una secuencia suficientemente larga de 0xFF.  Ella, esta secuencia, por cierto, está presente al comienzo de los archivos doc de MS Office.  Lo comprobé tal como está.  El archivo contenía 189 bytes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450024/">https://habr.com/ru/post/450024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450008/index.html">Encuentre errores en LLVM 8 utilizando el analizador PVS-Studio</a></li>
<li><a href="../450010/index.html">Almacenamiento, copia de seguridad y catalogación de fotografías.</a></li>
<li><a href="../450016/index.html">Creación de un sistema de verificación formal desde cero. Parte 1: máquina virtual de caracteres en PHP y Python</a></li>
<li><a href="../450018/index.html">Un dúo de matemáticas mapeó un territorio sin fin de superficies mínimas</a></li>
<li><a href="../450020/index.html">Silicon Valley llegó a los escolares de Kansas. Esto llevó a protestas.</a></li>
<li><a href="../450026/index.html">Cifrado de aceleración: estudiamos el acelerómetro de un dispositivo Android usando el ejemplo de la tarea NeoQUEST-2019</a></li>
<li><a href="../450028/index.html">Construyendo una Arquitectura Orientada a Servicios en Rails + Kafka</a></li>
<li><a href="../450030/index.html">No puedo usar Rift S y tampoco tendrás éxito</a></li>
<li><a href="../450032/index.html">Cómo crear un tema oscuro sin romper cosas: aprender con el equipo de Yandex Mail</a></li>
<li><a href="../450034/index.html">¿Por qué deberías participar en hackatones?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>