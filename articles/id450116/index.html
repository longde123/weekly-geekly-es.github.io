<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‡ğŸ¼ ğŸš¼ ğŸ‘£ Sistem Operasi: Tiga Potongan Mudah. Bagian 5: Perencanaan: Antrian Umpan Balik Multi-Tingkat (terjemahan) ğŸ‘©ğŸ¼â€ğŸ’» â›¹ğŸ¾ â™¨ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengantar Sistem Operasi 
 Halo, Habr! Saya ingin menarik perhatian Anda serangkaian artikel-terjemahan dari satu literatur yang menarik menurut saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem Operasi: Tiga Potongan Mudah. Bagian 5: Perencanaan: Antrian Umpan Balik Multi-Tingkat (terjemahan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450116/"><h1>  Pengantar Sistem Operasi </h1><br>  Halo, Habr!  Saya ingin menarik perhatian Anda serangkaian artikel-terjemahan dari satu literatur yang menarik menurut saya - OSTEP.  Artikel ini membahas lebih dalam karya sistem operasi mirip-unix, yaitu, bekerja dengan proses, berbagai penjadwal, memori, dan komponen serupa lainnya yang membentuk OS modern.  Asli semua bahan bisa Anda lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Harap dicatat bahwa terjemahannya dilakukan secara tidak profesional (cukup bebas), tetapi saya harap saya tetap memiliki makna umum. <br><br>  Pekerjaan laboratorium tentang hal ini dapat ditemukan di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adaptasi pribadi saya</a> </li></ul><br>  Bagian lain: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Abstraksi: proses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: Pengantar API Proses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: Pengantar Penjadwal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: Penjadwal MLFQ</a> </li></ul><br>  Dan Anda dapat melihat saluran saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram</a> =) <br><a name="habracut"></a><br><h2>  Perencanaan: Antrian Umpan Balik Multi-Tingkat </h2><br>  Dalam kuliah ini kita akan berbicara tentang masalah mengembangkan salah satu pendekatan yang paling terkenal <br>  Perencanaan yang disebut <b>Multi-Level Feedback Queue</b> (MLFQ).  Penjadwal MLFQ pertama kali dijelaskan pada tahun 1962 oleh Fernando J. CorbatÃ³ dalam suatu sistem yang disebut Sistem Berbagi-Waktu Kompatibel (CTSS).  Karya-karya ini (termasuk karya Multics nanti) kemudian diserahkan ke Turing Award.  Penjadwal kemudian diperbaiki dan memperoleh tampilan yang sudah dapat ditemukan di beberapa sistem modern. <br><br>  Algoritma MLFQ berupaya memecahkan 2 masalah lintas sektoral yang mendasar. <br>  <b>Pertama</b> , dia mencoba untuk mengoptimalkan waktu penyelesaian, yang, seperti yang kita bahas dalam kuliah sebelumnya, dioptimalkan dengan mulai dari awal antrian tugas terpendek.  Namun, OS tidak tahu berapa lama proses ini atau itu akan bekerja, dan ini adalah pengetahuan yang diperlukan untuk pengoperasian algoritma SJF, STCF.  <b>Kedua</b> , MLFQ mencoba membuat sistem responsif terhadap pengguna (misalnya, mereka yang duduk dan menatap layar sambil menunggu tugas selesai) dan dengan demikian meminimalkan waktu respons.  Sayangnya, algoritma seperti RR mengurangi waktu respons, tetapi mereka memiliki efek yang sangat buruk pada metrik waktu penyelesaian.  Oleh karena itu masalah kita: Bagaimana merancang penjadwal yang akan memenuhi persyaratan kita dan pada saat yang sama tidak tahu apa-apa tentang sifat proses, secara umum?  Bagaimana cara penjadwal mempelajari karakteristik tugas yang ia luncurkan dan dengan demikian membuat keputusan perencanaan yang lebih baik? <br><br>  <u>Inti dari masalah: Bagaimana merencanakan perumusan tugas tanpa pengetahuan yang sempurna?</u>  <u>Bagaimana mengembangkan penjadwal yang secara simultan meminimalkan waktu respons untuk tugas-tugas interaktif dan pada saat yang sama meminimalkan waktu penyelesaian tanpa mengetahui waktu untuk menyelesaikan tugas?</u> <br><br>  Catatan: belajar dari acara sebelumnya <br><br>  Lineup MLFQ adalah contoh yang bagus dari sistem yang belajar dari peristiwa masa lalu untuk memprediksi masa depan.  Pendekatan serupa sering ditemukan di OS (dan banyak cabang lain dalam ilmu komputer, termasuk cabang prediksi perangkat keras dan algoritma caching).  Perjalanan serupa bekerja ketika tugas memiliki fase perilaku dan karenanya dapat diprediksi. <br><br>  Namun, orang harus berhati-hati dengan teknik seperti itu, karena prediksi dapat dengan mudah berubah menjadi salah dan memimpin sistem untuk membuat keputusan yang lebih buruk daripada tanpa pengetahuan sama sekali. <br><br><h3>  MLFQ: Aturan Dasar </h3><br>  Pertimbangkan aturan dasar algoritma MLFQ.  Meskipun ada beberapa implementasi dari algoritma ini, pendekatan dasarnya serupa. <br><br>  Dalam implementasi yang akan kami pertimbangkan, dalam MLFQ akan ada beberapa antrian terpisah, yang masing-masing akan memiliki prioritas yang berbeda.  Kapan saja, tugas yang siap dieksekusi dalam satu antrian.  MLFQ menggunakan prioritas untuk memutuskan tugas mana yang akan dijalankan, mis.  tugas dengan prioritas lebih tinggi (tugas dari antrian dengan prioritas lebih tinggi) akan diluncurkan terlebih dahulu. <br><br>  Tidak diragukan lagi, lebih dari satu tugas dapat berada dalam antrian tertentu, sehingga mereka akan memiliki prioritas yang sama.  Dalam hal ini, mesin RR akan digunakan untuk menjadwalkan peluncuran di antara tugas-tugas ini. <br><br>  Jadi kita sampai pada dua aturan dasar untuk MLFQ: <br><br><ul><li>  Aturan1: Jika prioritas (A)&gt; Prioritas (B), tugas A akan mulai (B tidak akan) </li><li>  Aturan2: Jika prioritas (A) = Prioritas (B), A&amp;B mulai menggunakan RR </li></ul><br>  Berdasarkan hal di atas, elemen kunci perencanaan MLFQ adalah prioritas.  Alih-alih menetapkan prioritas tetap untuk setiap tugas, MLFQ mengubah prioritasnya tergantung pada perilaku yang diamati. <br><br>  Sebagai contoh, jika suatu tugas secara konstan berhenti bekerja pada CPU sambil menunggu input keyboard, MLFQ akan mempertahankan prioritas proses pada level tinggi, karena ini adalah bagaimana proses interaktif seharusnya bekerja.  Jika, sebaliknya, tugas tersebut secara konstan dan intensif menggunakan CPU untuk waktu yang lama, MLFQ akan menurunkan prioritasnya.  Dengan demikian, MLFQ akan mempelajari perilaku proses pada saat operasi mereka dan menggunakan perilaku tersebut. <br><br>  Mari kita ambil contoh bagaimana antrian terlihat pada suatu titik waktu dan kemudian kita mendapatkan sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/4x/ad/rr/4xadrrwfmrtn3mg-se6wgith9gm.png" alt="gambar"><br><br>  Dalam skema ini, 2 proses A dan B berada dalam antrian dengan prioritas tertinggi.  Proses C ada di suatu tempat di tengah, dan proses D di akhir antrian.  Menurut uraian algoritma MLFQ di atas, penjadwal akan menjalankan tugas hanya dengan prioritas tertinggi menurut RR, dan tugas C, D akan keluar dari pekerjaan. <br><br>  Secara alami, snapshot statis tidak akan memberikan gambaran lengkap tentang bagaimana MLFQ bekerja. <br>  Penting untuk memahami dengan tepat bagaimana gambar berubah seiring waktu. <br><br><h4>  Percobaan 1: Cara mengubah prioritas </h4><br>  Pada titik ini, Anda perlu memutuskan bagaimana MLFQ akan mengubah tingkat prioritas tugas (dan dengan demikian posisi tugas dalam antrian) selama siklus hidupnya.  Untuk melakukan ini, Anda perlu mengingat alur kerja: sejumlah tugas interaktif dengan waktu kerja yang singkat (dan dengan demikian sering melepaskan CPU) dan beberapa tugas panjang yang menggunakan CPU sepanjang waktu kerjanya, sedangkan waktu respons untuk tugas-tugas tersebut tidak penting.  Dan dengan demikian, Anda dapat melakukan upaya pertama untuk mengimplementasikan algoritma MLFQ dengan aturan berikut: <br><br><ul><li>  Aturan3: Ketika sebuah tugas memasuki sistem, ia diurutkan dengan yang tertinggi </li><li>  prioritas. </li><li>  Rule4a: Jika tugas menggunakan seluruh jendela waktu yang diberikan untuknya, maka tugasnya </li><li>  prioritas turun. </li><li>  Rule4b: Jika Task membebaskan CPU sebelum berakhirnya window waktunya, maka itu </li><li>  tetap dengan prioritas yang sama. </li></ul><br>  <b>Contoh 1: Satu tugas jangka panjang</b> <br><br>  Seperti yang dapat Anda lihat dalam contoh ini, tugas penerimaan diajukan dengan prioritas tertinggi.  Setelah jendela waktu 10 ms, proses diturunkan dalam prioritas oleh penjadwal.  Setelah jendela waktu berikutnya, tugas akhirnya turun ke prioritas terendah dalam sistem, di mana ia tetap. <br><br><img src="https://habrastorage.org/webt/jl/wi/fg/jlwifg8osgxds9bpyftx2aoa9pa.png"><br><br>  <b>Contoh 2: Mereka membawa tugas pendek</b> <br><br>  Sekarang mari kita lihat contoh bagaimana MLFQ akan mencoba untuk lebih dekat dengan SJF.  Ada dua tugas dalam contoh ini: A, yang merupakan tugas lama yang terus-menerus memakan CPU, dan B, yang merupakan tugas interaktif singkat.  Misalkan A sudah bekerja beberapa saat pada saat tugas B tiba. <br><br><img src="https://habrastorage.org/webt/hq/dp/ou/hqdpouigzrlqbjbhwnvgv9e8mxc.png"><br><br>  Dalam grafik ini, hasil skrip terlihat.  Tugas A, seperti tugas apa pun yang menggunakan CPU, ada di bagian paling bawah.  Tugas B akan tiba di T = 100 dan akan ditempatkan dalam antrian dengan prioritas tertinggi.  Karena waktu kerjanya pendek, itu akan berakhir sebelum mencapai tahap terakhir. <br><br>  Dari contoh ini, kita harus memahami tujuan utama dari algoritma: karena algoritma tidak mengetahui tugas yang panjang atau pendek, pertama-tama diasumsikan bahwa tugas itu singkat dan memberikan prioritas tertinggi.  Jika ini adalah tugas yang sangat singkat, maka itu akan diselesaikan dengan cepat, jika tidak, jika itu adalah tugas yang panjang, maka perlahan akan bergerak ke bawah dalam prioritas dan akan segera membuktikan bahwa itu adalah tugas yang sangat panjang yang tidak memerlukan respons. <br><br>  <b>Contoh 3: Bagaimana dengan I / O?</b> <br><br>  Sekarang lihat contoh I / O.  Sebagaimana dinyatakan dalam aturan 4b, jika suatu proses membebaskan prosesor tanpa sepenuhnya memanfaatkan waktu prosesornya, maka ia tetap pada tingkat prioritas yang sama.  Maksud aturan ini cukup sederhana - jika tugas interaktif melakukan banyak operasi I / O, misalnya, menunggu pengguna menekan tombol atau mouse, tugas seperti itu akan membebaskan prosesor sebelum jendela yang diberikan.  Kami tidak ingin mengabaikan tugas seperti itu dengan prioritas, dan dengan demikian akan tetap pada tingkat yang sama. <br><br><img src="https://habrastorage.org/webt/md/oa/f_/mdoaf_yf81n7xvy-j_bdo6hvbmm.png"><br><br>  Contoh ini menunjukkan bagaimana algoritma akan bekerja dengan proses tersebut - tugas interaktif B, yang membutuhkan CPU hanya 1 ms sebelum melakukan proses I / O, dan tugas panjang A, yang menggunakan CPU sepanjang waktu. <br><br>  MLFQ memegang proses B dengan prioritas tertinggi karena terus berlanjut sepanjang waktu. <br>  bebaskan CPU.  Jika B adalah tugas interaktif, maka algoritma kemudian mencapai tujuannya meluncurkan tugas-tugas interaktif dengan cepat. <br><br>  <b>Masalah dengan algoritma MLFQ saat ini</b> <br><br>  Dalam contoh sebelumnya, kami membangun versi dasar MLFQ.  Dan sepertinya dia melakukan pekerjaannya dengan baik dan jujur, mendistribusikan waktu prosesor secara jujur â€‹â€‹antara tugas yang panjang dan memungkinkan tugas pendek atau tugas secara intensif mengakses I / O untuk bekerja dengan cepat.  Sayangnya, pendekatan ini mengandung beberapa masalah serius. <br><br>  <b>Pertama</b> , masalah kelaparan: jika sistem memiliki banyak tugas interaktif, mereka akan menghabiskan semua waktu prosesor dan dengan demikian tidak satu pun tugas panjang akan mendapatkan kesempatan untuk dieksekusi (mereka kelaparan). <br><br>  <b>Kedua</b> , pengguna pintar bisa menulis program mereka sehingga <br>  menipu perencana.  Triknya adalah melakukan sesuatu untuk membuatnya <br>  scheduler memberi proses lebih banyak waktu prosesor.  Algoritma itu <br>  dijelaskan di atas cukup rentan terhadap serangan seperti itu: sebelum jendela waktu praktis <br>  berakhir Anda harus melakukan operasi I / O (untuk beberapa orang, tidak peduli file mana) <br>  dan dengan demikian membebaskan CPU.  Perilaku ini akan memungkinkan Anda untuk tetap sama <br>  antrian itu sendiri dan sekali lagi mendapatkan persentase waktu CPU yang lebih besar.  Jika dilakukan <br>  ini benar (misalnya, 99% dari waktu jendela sebelum membebaskan CPU) <br>  tugas seperti itu dapat memonopoli prosesor. <br><br>  Akhirnya, suatu program dapat mengubah perilakunya dari waktu ke waktu.  Tugas-tugas itu <br>  yang menggunakan CPU bisa menjadi interaktif.  Dalam contoh kita, mirip <br>  tugas tidak akan menerima perlakuan yang tepat dari penjadwal, seperti yang akan diterima orang lain <br>  (awal) tugas interaktif. <br><br>  <u>Pertanyaan kepada hadirin: serangan apa yang bisa dilakukan perencana di dunia modern?</u> <u><br></u> <br><h4>  Percobaan 2: Mengangkat Prioritas </h4><br><br>  Mari kita coba mengubah aturan dan melihat apakah kita dapat menghindari masalah dengan <br>  puasa.  Apa yang bisa kami lakukan untuk memastikan hal itu terkait <br>  Tugas CPU akan mendapatkan waktu mereka (bahkan jika tidak lama). <br>  Sebagai solusi sederhana untuk masalah ini, Anda dapat menawarkannya secara berkala <br>  tingkatkan prioritas semua tugas tersebut dalam sistem.  Ada banyak cara. <br>  untuk mencapai ini, mari kita coba menerapkan sebagai contoh sesuatu yang sederhana: terjemahkan <br>  semua tugas sekaligus dalam prioritas tertinggi, maka aturan baru: <br><ul><li>  <b>Aturan5</b> : Setelah periode S tertentu, transfer semua tugas dalam sistem ke prioritas tertinggi. </li></ul><br>  Aturan baru kami menyelesaikan dua masalah sekaligus.  Pertama, prosesnya <br>  dijamin tidak kelaparan: tugas dalam prioritas tertinggi akan dibagikan <br>  waktu prosesor sesuai dengan algoritma RR dan dengan demikian semua proses akan menerima <br>  waktu prosesor.  Kedua, jika ada beberapa proses yang sebelumnya digunakan <br>  hanya prosesor yang menjadi interaktif, maka akan tetap sejalan dengan yang lebih tinggi <br>  prioritas setelah satu kali akan menerima peningkatan prioritas ke tertinggi. <br>  Pertimbangkan sebuah contoh.  Dalam skenario ini, pertimbangkan satu proses menggunakan <br><img src="https://habrastorage.org/webt/cx/te/ll/cxtellydeep0hkgrqfiypt-zqq4.png"><br><br>  CPU dan dua proses pendek interaktif.  Di sebelah kiri dalam gambar, gambar menunjukkan perilaku tanpa meningkatkan prioritas, dan dengan demikian tugas panjang mulai kelaparan setelah dua tugas interaktif tiba di sistem.  Pada gambar di sebelah kanan, setiap 50 ms prioritas ditingkatkan dan dengan demikian semua proses dijamin untuk menerima waktu prosesor dan akan dimulai secara berkala.  50ms dalam hal ini diambil sebagai contoh, dalam kenyataannya jumlah ini agak lebih besar. <br>  Jelas, penambahan waktu untuk peningkatan S secara berkala mengarah ke <br>  pertanyaan logis: nilai apa yang harus ditetapkan?  Salah satu yang terhormat <br>  insinyur sistem John Ousterhout menyebut jumlah yang serupa dalam sistem seperti voo-doo <br>  konstan, karena mereka dalam beberapa cara menuntut ilmu hitam untuk benar <br>  pameran.  Dan, sayangnya, S memiliki aroma seperti itu.  Jika Anda mengatur nilainya juga <br>  tugas besar-panjang akan mulai kelaparan.  Dan jika Anda menetapkan nilainya terlalu rendah, <br>  Tugas interaktif tidak akan menerima waktu prosesor yang tepat. <br><br><h4>  Percobaan 3: Akuntansi Terbaik </h4><br><br>  Sekarang kita memiliki satu masalah lagi yang perlu dipecahkan: bagaimana tidak <br>  biarkan menipu perencana kami?  Bersalah atas kesempatan ini <br>  aturan 4a, 4b, yang memungkinkan tugas mempertahankan prioritas, membebaskan prosesor <br>  sebelum berakhirnya waktu yang diberikan.  Bagaimana cara mengatasinya? <br>  Solusi dalam hal ini dapat dianggap sebagai penghitungan waktu CPU terbaik untuk masing-masing <br>  Tingkat MLFQ.  Alih-alih lupa waktu program digunakan <br>  prosesor untuk periode yang ditentukan, Anda harus mempertimbangkan dan menyimpannya.  Setelah <br>  proses telah menghabiskan waktu yang dialokasikan untuk itu harus dikurangi ke yang berikutnya <br>  tingkat prioritas.  Sekarang tidak peduli bagaimana prosesnya menggunakan waktu - caranya <br>  terus-menerus menghitung pada prosesor atau banyak panggilan.  Dengan cara ini <br>  Aturan 4 harus ditulis ulang sebagai berikut: <br><br><ul><li>  <b>Aturan4</b> : Setelah tugas menghabiskan waktu yang dialokasikan untuknya dalam antrian saat ini (terlepas dari berapa kali itu membebaskan CPU), prioritas tugas tersebut berkurang (bergerak ke bawah antrian). </li></ul><br>  Mari kita lihat sebuah contoh: <br><img src="https://habrastorage.org/webt/je/rs/kw/jerskwy36cewrg6auapm-dal7iu.png">  " <br><br>  Angka tersebut menunjukkan apa yang terjadi jika Anda mencoba mengelabui penjadwal, caranya <br>  jika dengan aturan sebelumnya 4a, 4b, kita mendapatkan hasil di sebelah kiri.  Selamat baru <br>  aturannya adalah hasil di sebelah kanan.  Sebelum perlindungan, proses apa pun dapat meminta I / O sampai selesai dan <br>  dengan demikian mendominasi CPU, setelah mengaktifkan perlindungan, terlepas dari perilaku <br>  I / O, itu masih akan drop down line dan dengan demikian tidak akan tidak jujur <br>  menguasai sumber daya CPU. <br><br><h4>  Meningkatkan MLFQ dan masalah lainnya </h4><br>  Dengan peningkatan di atas, muncul masalah baru: salah satu yang utama <br>  pertanyaan - bagaimana membuat parameter penjadwal seperti itu?  Yaitu  Berapa banyak seharusnya <br>  semburan?  Berapa ukuran jendela program dalam antrian?  Bagaimana <br>  prioritas program harus sering ditingkatkan untuk menghindari kelaparan dan <br>  memperhitungkan perubahan akun dalam perilaku program?  Untuk pertanyaan-pertanyaan ini, tidak ada yang mudah <br>  respon dan hanya eksperimen dengan banyak dan konfigurasi selanjutnya <br>  perencana dapat menyebabkan keseimbangan yang memuaskan. <br><br>  Sebagai contoh, sebagian besar implementasi MLFQ memungkinkan Anda untuk menetapkan yang berbeda <br>  interval waktu untuk antrian yang berbeda.  Antrian prioritas tinggi biasanya <br>  interval pendek ditugaskan.  Antrian ini terdiri dari tugas interaktif, <br>  beralih di antara yang cukup sensitif dan harus memakan waktu 10 atau kurang <br>  ms  Sebaliknya, antrian prioritas rendah terdiri dari tugas-tugas panjang yang digunakan <br>  CPU  Dan dalam hal ini, interval waktu yang lama sangat cocok (100 ms). <br><img src="https://habrastorage.org/webt/p4/1j/-d/p41j-d9spzwfok9w7xmkcewqgrq.png"><br><br>  Dalam contoh ini, ada 2 tugas yang berfungsi dalam antrian prioritas tinggi 20 <br>  ms, rusak oleh windows selama 10 ms.  40ms dalam antrian sedang (jendela pada 20ms) dan dalam prioritas rendah <br>  Jendela waktu antrian menjadi 40ms, di mana tugas menyelesaikan pekerjaan mereka. <br><br>  Implementasi Solaris OS MLFQ adalah kelas penjadwal berbagi waktu. <br>  Penjadwal menyediakan satu set tabel yang menentukan dengan tepat bagaimana seharusnya <br>  mengubah prioritas proses selama hidupnya, berapa ukurannya <br>  jendela yang dipilih dan seberapa sering Anda perlu meningkatkan prioritas tugas.  Admin <br>  sistem dapat berinteraksi dengan tabel ini dan membuat penjadwal berperilaku <br>  dengan cara yang berbeda.  Secara default, ada 60 antrian tambahan dalam tabel ini. <br>  ukuran jendela dari 20 ms (prioritas tinggi) hingga beberapa ratus ms (prioritas terendah), dan <br>  juga dengan dorongan semua tugas sekali per detik. <br><br>  Perencana MLFQ lainnya tidak menggunakan tabel atau spesifik apa pun <br>  aturan yang dijelaskan dalam kuliah ini, sebaliknya mereka menghitung prioritas menggunakan <br>  rumus matematika.  Jadi, misalnya, scheduler di FreeBSD menggunakan rumus untuk <br>  menghitung prioritas tugas saat ini berdasarkan pada seberapa banyak prosesnya <br>  CPU yang digunakan.  Selain itu, penggunaan CPU meluruh dari waktu ke waktu, dan sebagainya <br>  Dengan demikian, peningkatan prioritas terjadi agak berbeda dari yang dijelaskan di atas.  Begitu ya <br>  disebut algoritma peluruhan.  Sejak versi 7.1, FreeBSD menggunakan penjadwal ULE. <br><br>  Akhirnya, banyak perencana memiliki fitur lain.  Sebagai contoh, beberapa <br>  perencana memiliki level tertinggi untuk sistem operasi dan sebagainya <br>  dengan cara ini, tidak ada proses pengguna yang bisa mendapatkan prioritas tertinggi di <br>  sistem.  Beberapa sistem memungkinkan Anda memberikan tip untuk membantu. <br>  scheduler untuk mengatur prioritas dengan benar.  Misalnya, menggunakan perintah yang <b>bagus</b> <br>  Anda dapat menambah atau mengurangi prioritas tugas dan karenanya menambah atau <br>  mengurangi peluang program untuk waktu prosesor. <br><h3>  MLFQ: Ringkasan </h3><br>  Kami menggambarkan pendekatan perencanaan yang disebut MLFQ.  Namanya <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disimpulkan dalam prinsip kerja - ia memiliki beberapa antrian dan menggunakan umpan balik </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menentukan prioritas tugas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bentuk akhir aturan adalah sebagai berikut:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Jika prioritas (A)&gt; Prioritas (B), tugas A akan dimulai (B tidak akan)</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Jika prioritas (A) = Prioritas (B), A&amp;B mulai menggunakan RR</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ketika sebuah tugas memasuki sistem, itu diurutkan dengan prioritas tertinggi.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Setelah tugas tersebut menghabiskan waktu yang dialokasikan untuknya dalam antrian saat ini (terlepas dari berapa kali itu membebaskan CPU), prioritas tugas tersebut menurun (bergerak ke bawah antrian).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Setelah periode S tertentu, transfer semua tugas dalam sistem ke prioritas tertinggi.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MLFQ menarik karena alasan berikut - alih-alih menuntut pengetahuan tentang </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sifat tugas terlebih dahulu, algoritma memeriksa perilaku masa lalu dari tugas dan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memprioritaskannya. </font><font style="vertical-align: inherit;">Karena itu, ia mencoba duduk di dua kursi sekaligus - untuk mencapai produktivitas untuk tugas-tugas kecil (SJF, STCF) dan jujur â€‹â€‹menjalankan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tugas yang </font><font style="vertical-align: inherit;">panjang, </font><font style="vertical-align: inherit;">memuat CPU. </font><font style="vertical-align: inherit;">Oleh karena itu, banyak sistem, termasuk BSD dan turunannya, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solaris, Windows, Mac, menggunakan beberapa bentuk algoritma </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MLFQ </font><font style="vertical-align: inherit;">sebagai </font><font style="vertical-align: inherit;">penjadwal sebagai basis.</font></font><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahan tambahan: </font></font></h4><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manpages.debian.org/stretch/manpages/sched.7.en.html</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Scheduling_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (komputasi)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pages.lip6.fr/Julia.Lawall/atc18-bouron.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.usenix.org/legacy/event/bsdcon03/tech/full_papers/roberson/roberson.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chebykin.org/freebsd-process-scheduling</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450116/">https://habr.com/ru/post/id450116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450104/index.html">Sangat sulit dan sangat menarik: Komunitas TI di TechTrain</a></li>
<li><a href="../id450106/index.html">Proyek organisasi konstruksi dan rekonstruksi dalam kondisi sempit di lokasi Konstruksi SPDS</a></li>
<li><a href="../id450110/index.html">Paten desain: bagian dua (contoh dari Microsoft, Snapchat, Samsung, Netflix, Airbnb, Tinder)</a></li>
<li><a href="../id450112/index.html">Eh, apa yang terjadi dengan kopernya ?! Pada contoh skuter-koper anak-anak ZINC</a></li>
<li><a href="../id450114/index.html">Tentang apa yang telah kami terapkan dalam EWM berkat saran Anda</a></li>
<li><a href="../id450118/index.html">Streaming layar ke beberapa perangkat melalui jaringan</a></li>
<li><a href="../id450120/index.html">Cari gambar serupa, parsing satu algoritma</a></li>
<li><a href="../id450122/index.html">Intisari Awal: Genetika (Januari - Maret 2019)</a></li>
<li><a href="../id450124/index.html">Mengkonfigurasi peta OsmAnd dari lapisan peta panas Strava</a></li>
<li><a href="../id450126/index.html">Backdoor dan Buhtrap mengenkripsi didistribusikan menggunakan Yandex.Direct</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>