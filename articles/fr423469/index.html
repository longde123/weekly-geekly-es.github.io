<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛁 👩🏼‍🔬 🤷🏿 Numéros à virgule flottante Far West les plus rapides 🔈 👌🏿 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la mise en œuvre d'un «lecteur», un problème s'est posé avec une précision accrue des calculs. L'algorithme de calcul a fonctionné rapidement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Numéros à virgule flottante Far West les plus rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423469/"> Lors de la mise en œuvre d'un «lecteur», un problème s'est posé avec une précision accrue des calculs.  L'algorithme de calcul a fonctionné rapidement sur les nombres à virgule flottante standard, mais lorsque les bibliothèques pour les calculs précis ont été connectées, tout a commencé à ralentir sauvagement.  Dans cet article, nous considérerons les algorithmes d'expansion des nombres à virgule flottante en utilisant une approche multi-composants, grâce à laquelle il a été possible d'obtenir une accélération, car l'arithmétique flottante est implémentée sur une puce cp.  Cette approche sera utile pour un calcul plus précis de la dérivée numérique, de l'inversion matricielle, du découpage polygonal ou d'autres problèmes géométriques.  Il est donc possible d'émuler un flottant 64 bits sur des cartes vidéo qui ne les prennent pas en charge. <br><br><img src="https://habrastorage.org/webt/54/1e/jo/541ejotttsu8hl3swtihly-liro.png" alt="benchmark double.js"><br><br><a name="habracut"></a><br><br><h3>  Présentation </h3><br>  Comme Nikluas Wirth nous a légué de garder les chiffres 0 et 1, nous les stockons donc en eux.  Et est-ce que les humains vivent dans le système décimal, et les nombres apparemment ordinaires 0,1 et 0,3 ne sont pas représentables dans le système binaire par une fraction finie?  Nous subissons un choc culturel lorsque nous effectuons des calculs à leur sujet.  Bien sûr, des tentatives sont faites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour</a> créer des bibliothèques pour les processeurs basés sur le système décimal et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IEEE a</a> même des formats standardisés. <br><br>  Mais pour l'instant, nous prenons en compte le stockage binaire partout et effectuons tous les calculs d'argent avec des bibliothèques pour des calculs exacts, tels que bignumber, ce qui entraîne une perte de performances.  Les Asiks considèrent la crypto, et dans les processeurs, il y a si peu d'espace pour cette arithmétique décimale, selon les spécialistes du marketing.  Par conséquent, une approche à plusieurs composants, lorsqu'un nombre est stocké sous la forme d'une somme de nombres non transformée, est une astuce pratique et une sphère en développement actif dans le domaine de l'informatique théorique.  Bien que Decker ait encore appris à se multiplier correctement, sans perte de précision, en 1971, des bibliothèques prêtes à l'emploi sont apparues beaucoup plus tard (MPFR, QD) et pas dans toutes les langues, apparemment car toutes ne prenaient pas en charge les normes IEEE, mais des preuves rigoureuses d'erreur de calcul encore plus tard, par exemple en 2017 pour l'arithmétique des mots doubles. <br><br><h3>  Arithmétique à deux mots </h3><br>  À quoi ça sert?  Dans les temps barbus, quand il n'y avait pas de normes pour les nombres flottants, pour éviter des problèmes avec la mise en œuvre de l'arrondi, Møller est venu avec, et Knuth a prouvé plus tard qu'il y avait une sommation sans erreur.  Courir de cette façon <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickTwoSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = a + b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = s - a; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = b - z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s, e]; }</code> </pre> <br>  Dans cet algorithme, on a supposé que si <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mo>&amp;gt;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>b</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.913ex" height="2.66ex" viewBox="0 -832 3407.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-61" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-3E" x="1364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="2420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-62" x="2699" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mo>&gt;</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-1"> | a | > | b | </script>  , alors leur somme exacte peut être représentée comme la somme de deux nombres <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi><mo>+</mo><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.014ex" height="1.937ex" viewBox="0 -676.4 2158.9 834" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-73" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-2B" x="691" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-65" x="1692" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo>+</mo><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> s + e </script>  et vous pouvez les stocker par paires pour les calculs ultérieurs, et la soustraction est réduite à l'addition avec un nombre négatif. <br><br><img src="https://habrastorage.org/webt/6o/5b/h3/6o5bh3at9xelrvk2yslo4qk0jl0.png" alt="arrondi à la banque la plus proche"><br><br>  Par la suite, Dekker a montré que si des nombres à virgule flottante sont utilisés qui utilisent l'arrondi au nombre pair le plus proche (liens arrondis au plus proche à pair, ce qui est généralement une procédure correcte qui ne conduit pas à de grandes erreurs dans le processus de longs calculs et la norme IEEE), puis il y a un algorithme de multiplication sans erreur. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoMult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = split(a); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> B = split(b); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r1 = a * b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t1 = -r1 + A[<span class="hljs-number"><span class="hljs-number">0</span></span>] * B[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t2 = t1 + A[<span class="hljs-number"><span class="hljs-number">0</span></span>] * B[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t3 = t2 + A[<span class="hljs-number"><span class="hljs-number">1</span></span>] * B[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [r1, t3 + A[<span class="hljs-number"><span class="hljs-number">1</span></span>] * B[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; }</code> </pre><br>  où split () est l'algorithme de M. Weltkamp pour diviser un nombre <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> splitter = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t = splitter * a; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = a - t; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xh = t + d; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xl = a - xh; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [xh, xl]; }</code> </pre><br>  en utilisant constante <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.033ex" height="2.178ex" viewBox="0 -780.1 4750.5 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-3D" x="1038" y="0"></use><g transform="translate(2094,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-73" x="707" y="557"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-2B" x="3249" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-31" x="4249" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> C = 2 ^ s + 1 </script>  ce qui équivaut à un peu plus de la moitié de la longueur de la mantisse, ce qui ne conduit pas à un débordement de nombres en cours de multiplication et divise la mantisse en deux moitiés.  Par exemple, avec une longueur de mot de 64 bits, la longueur de la mantisse est 53 puis s = 27. <br><br><img src="https://habrastorage.org/webt/ut/k-/rl/utk-rlv912w0uw44uvm4cce4uts.gif" alt="flotteur double"><br><br>  De cette façon, Dekker a fourni l'ensemble presque complet nécessaire au calcul en arithmétique des mots doubles.  Depuis, il a également été indiqué comment multiplier, diviser et mettre au carré deux nombres de deux mots. <br><br>  Son algorithme quickTwoSum pour additionner deux mots doubles était partout «en ligne», et la vérification a été utilisée <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mo>&amp;gt;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>b</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.913ex" height="2.66ex" viewBox="0 -832 3407.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-61" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-3E" x="1364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="2420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMATHI-62" x="2699" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/423469/&amp;usg=ALkJrhgbTf6IGtrrZfE9EZdzRZBtFEBgPw#MJMAIN-7C" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mo>&gt;</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4"> | a | > | b | </script>  .  Sur les processeurs modernes, comme décrit dans [4], il est moins coûteux d'utiliser des opérations supplémentaires avec des nombres que de ramifier l'algorithme.  Par conséquent, l'algorithme suivant est maintenant plus approprié pour ajouter deux nombres d'un seul mot <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = a + b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a1 = s - b; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b1 = s - a1; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> da = a - a1; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = b - b1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s, da + db]; }</code> </pre><br>  Et c'est donc la somme et la multiplication des nombres à double mot. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add22</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">X, Y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> S = twoSum(X[<span class="hljs-number"><span class="hljs-number">0</span></span>], Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> E = twoSum(X[<span class="hljs-number"><span class="hljs-number">1</span></span>], Y[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = S[<span class="hljs-number"><span class="hljs-number">1</span></span>] + E[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> V = quickTwoSum(S[<span class="hljs-number"><span class="hljs-number">0</span></span>], c); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w = V[<span class="hljs-number"><span class="hljs-number">1</span></span>] + E[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quickTwoSum(V[<span class="hljs-number"><span class="hljs-number">0</span></span>], w); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul22</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">X, Y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> S = twoMult(X[<span class="hljs-number"><span class="hljs-number">0</span></span>], Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]); S[<span class="hljs-number"><span class="hljs-number">1</span></span>] += X[<span class="hljs-number"><span class="hljs-number">0</span></span>] * Y[<span class="hljs-number"><span class="hljs-number">1</span></span>] + X[<span class="hljs-number"><span class="hljs-number">1</span></span>] * Y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quickTwoSum(S[<span class="hljs-number"><span class="hljs-number">0</span></span>], S[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br>  De manière générale, la liste la plus complète et la plus précise des algorithmes pour l'arithmétique des mots doubles, les limites d'erreur théorique et la mise en œuvre pratique sont décrits dans le lien [3] de 2017.  Par conséquent, si vous êtes intéressé, je vous recommande fortement d'y aller directement.  En général, un algorithme pour quadruple mot est donné dans [6] et dans [5] pour une extension multicomposant de longueur arbitraire.  Seulement là, après chaque opération, le processus de renormalisation est utilisé, ce qui n'est pas toujours optimal pour les petites tailles, et la précision des calculs dans QD n'est pas strictement définie.  En général, il convient bien sûr de réfléchir aux limites d'applicabilité de ces approches. <br><br><h3>  Histoires d'horreur javascript-a.  Comparaison de decimal.js vs bignumber.js vs big.js. </h3><br>  Il se trouve que presque toutes les bibliothèques pour les calculs exacts en js ont été écrites par une seule personne.  L'illusion du choix est créée, bien qu'elles soient presque toutes les mêmes.  De plus, la documentation n'indique pas explicitement que si vous n'arrondissez pas les nombres après chaque opération de multiplication / division, la taille de votre nombre doublera tout le temps et la complexité de l'algorithme peut devenir facile en x3500.  Par exemple, une comparaison de leur temps de calcul pourrait ressembler à ceci si vous n'avez pas arrondi les nombres. <br><br><img src="https://habrastorage.org/webt/lj/6r/pk/lj6rpkl_lenvq7vabfyqqhdwh8y.png"><br><br>  Autrement dit, vous définissez la précision à 32 décimales et ... Oups, vous avez déjà 64 chiffres, 128. Nous pensons très précisément!  256, 512 ... Mais j'en ai réglé 32! .. 1024, 2048 ... Quelque chose comme ça apparaît au dessus de 3500 fois.  La documentation indique que si vous avez des calculs scientifiques, alors probablement decimal.js est mieux pour vous.  Bien qu'en fait, si vous arrondissez périodiquement, Bignumber.js fonctionne un peu plus rapidement pour les calculs scientifiques (voir Fig. 1).  Qui doit compter les centièmes de centime s'ils ne peuvent pas être donnés en monnaie?  Y a-t-il un cas où j'ai besoin de stocker plus de numéros indiqués et que je ne peux pas sortir avec quelques caractères supplémentaires?  Comment faut-il prendre le sinus d'un tel nombre de monstres, alors que personne ne connaît la stricte précision de la convergence de la série de Taylor pour des nombres arbitraires?  En général, il n'y a pas de soupçons non fondés qu'il soit possible d'augmenter la vitesse de calcul là-bas, en utilisant des algorithmes de multiplication de Schoenhage-Strassen et en trouvant le sinus avec des calculs Cordic, par exemple. <br><br><h3>  Double.js </h3><br>  <s>Je voudrais dire, bien sûr, que Double.js compte rapidement et avec précision.</s>  <s>Mais ce n'est pas tout à fait vrai, c'est-à-dire qu'il est 10 fois plus rapide qu'il le considère, mais ce n'est pas toujours exact.</s>  <s>Par exemple, 0.3-0.1, il peut le traiter, passant en double stockage et vice versa.</s>  <s>Mais le nombre Pi peut être résolu avec une double précision de près de 32 chiffres et cela ne fonctionne pas en arrière.</s>  <s>Une erreur est générée le 16, comme si un débordement se produisait.</s>  <s>En général, j'exhorte la communauté js à travailler ensemble pour essayer de résoudre le problème de l'analyse, car je suis coincé.</s>  <s>J'ai essayé d'analyser numériquement et de diviser en double précision, comme dans QD, de diviser en lots de 16 chiffres et de diviser en double précision, de diviser la mantisse en utilisant Big.js comme dans l'une des bibliothèques Julia.</s>  <s>Maintenant, je pèche sur un bogue dans .parseFloat (), car les normes IEEE avec arrondi à l'entier le plus proche sont prises en charge même avec ECMAScript 1. Bien que vous puissiez bien sûr essayer de lier le tampon binaire et regarder tous les 0 et 1. En général, si vous pouvez résoudre ce problème, alors il sera alors possible de faire des calculs avec une précision arbitraire avec une accélération en x10-x20 à partir de bignumber.js.</s>  <s>Cependant, de nombreux Mandelbrot rendent déjà la qualité et vous pouvez l'utiliser pour des tâches géométriques.</s> <br><br>  Un an plus tard, je suis revenu ici et j'ai toujours résolu un problème d'analyse.  Le problème n'était que d'une précision insuffisante, lorsqu'il était multiplié par 10 ^ (- n).  Tous les algorithmes ont été révisés à partir de zéro et fonctionnent désormais avec une précision et une vitesse effrayantes. <br><br><img src="https://habrastorage.org/webt/ax/gx/mb/axgxmb_wfffxczzejqaxa9mqdpy.png" alt="double.js vs nombre"><br><br>  Voici un lien vers la <a href="">lib</a> , il y a un benchmark interactif et un bac à sable où vous pouvez jouer avec. <br><br><h3>  Sources utilisées </h3><br><ol><li>  O. Møller.  <i>Quasi double précision en arithmétique à virgule flottante.</i>  , 1965. </li><li>  Theodorus Dekker.  <i>Une technique à virgule flottante pour étendre la précision disponible</i> , 1971. [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visionneuse</a> ] </li><li>  Mioara Joldes, Jean-Michel Muller, Valentina Popescu.  <i>Limites d'erreur strictes et rigoureuses pour les blocs de construction de base de l'arithmétique des mots doubles</i> , 2017. [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> ] </li><li>  Muller, J.-M.  Brisebarre, N. de Dinechin, etc.  Manuel d'arithmétique à virgule flottante, chapitre 14, 2010. </li><li>  Jonathan Shewchuk.  <i>Prédicats géométriques adaptatifs à virgule flottante robustes</i> , 1964. [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> ] </li><li>  Yozo Hida, Xiaoye Li, David Bailey.  <i>Bibliothèque d'arithmétique double-double et quad-double</i> , 2000. [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF</a> ] </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423469/">https://habr.com/ru/post/fr423469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423459/index.html">Différences entre Phoenix et Rails à travers les yeux d'un converti</a></li>
<li><a href="../fr423461/index.html">Automne suborbital</a></li>
<li><a href="../fr423463/index.html">Comme nous avons écrit un autre algorithme d'analyse RFM</a></li>
<li><a href="../fr423465/index.html">Que lire sur l'ITSM: livres, blogs et derniers articles</a></li>
<li><a href="../fr423467/index.html">Les développeurs russes publieront un catalogue de compatibilité des produits</a></li>
<li><a href="../fr423475/index.html">Pirater le code du vieillissement: une nouvelle science sur le vieillissement et ce que signifie rester jeune</a></li>
<li><a href="../fr423477/index.html">Soyez un ninja de la sécurité: commencez votre chemin vers les hauteurs de l'IB</a></li>
<li><a href="../fr423479/index.html">"First": s'il faut voler vers Mars</a></li>
<li><a href="../fr423481/index.html">Je dois augmenter le cluster Kubernetes, mais je ne suis qu'un programmeur de code. Il y a un moyen de sortir</a></li>
<li><a href="../fr423483/index.html">Trouver la bonne façon de séparer le contenu d'un site Web à l'aide de Webpack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>