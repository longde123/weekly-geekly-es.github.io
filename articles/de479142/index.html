<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 👧🏿 🈴 Wie kann man ein Element aus einem Binärbaum über einen Index in angemessener Zeit erhalten? 🏳️‍🌈 👇🏻 🎴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Vor sechs Monaten habe ich darüber nachgedacht, wie man ein Element aus einem Binärbaum in O (log (N)) erhält. Die Antwort kam ziemlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie kann man ein Element aus einem Binärbaum über einen Index in angemessener Zeit erhalten?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479142/">  Hallo habr <br><br>  Vor sechs Monaten habe ich darüber nachgedacht, wie man ein Element aus einem Binärbaum in O (log (N)) erhält.  Die Antwort kam ziemlich schnell - Lazy Propagation.  Aber ich war zu faul, um dies in den Code zu implementieren.  Jetzt müssen wir das Abschlussprojekt an der Universität machen, also mache ich alles andere als das.  So habe ich es umgesetzt. <br><a name="habracut"></a><br>  <b>Einige Anmerkungen:</b> <br><br><ul><li>  Der Baum ist nicht ausgeglichen (da das Diplomprojekt noch geschrieben werden muss), wodurch die Schätzung O (log (N)) für zufällige Eingabedaten überall amortisiert wird. </li><li>  Ich habe keine ähnliche Datenstruktur gefunden, Kollegen und Freunde, die ich gefragt habe, haben auch nichts Ähnliches angeboten.  Wenn Sie die Umsetzung einer solchen Idee kennen, lassen Sie es mich bitte wissen. </li><li>  In der Vertex-Klasse kann auf das übergeordnete Feld verzichtet werden, indem das übergeordnete Feld an die Methoden übergeben wird. </li></ul><br>  <b>Beschreibung der Idee</b> <br><br>  Speichern wir für jeden Eckpunkt die Anzahl der Eckpunkte links davon und rufen wir dieses Feld beim Eckpunkt countLefter auf.  Wenn wir jedoch das am weitesten links stehende Element zum Baum hinzufügen, müssen wir countLefter für alle anderen Scheitelpunkte ändern, die schmerzhaft lang sein können und an der Wurzel (oh, dieses Wortspiel) nicht den Prinzipien eines binären Baums entsprechen.  Um dies zu vermeiden, geben Sie für jeden Scheitelpunkt ein Feld zum Hinzufügen ein, in dem gespeichert wird, wie viel zum countLefter-Feld für jeden Scheitelpunkt seines Unterbaums hinzugefügt werden muss, einschließlich des Scheitelpunkts selbst.  Wenn Sie also das am weitesten links stehende Element zum Baum hinzufügen, müssen Sie nur Folgendes tun: <br><br><ul><li>  Erhöhen Sie countLefter auf dem gesamten Pfad, der zum Einfügepunkt des neuen Scheitelpunkts führt </li><li>  Erhöhen Sie add um 1 für alle Scheitelpunkte, die sich rechts oben befinden </li></ul><br>  Jetzt ist es logisch, die push () -Methode einzuführen, die add zum countLefter des Scheitelpunkts selbst und seiner beiden Nachkommen hinzufügt. <br><br><div class="spoiler">  <b class="spoiler_title">So ist die Vertex-Klasse entstanden:</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNode</span></span></span><span class="hljs-class"> </span></span>{ UNode parent; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countLefter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add; UNode left; UNode right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countLefter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> add, UNode left, UNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.countLefter = countLefter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add = add; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ countLefter += add; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) left.add += add; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) right.add += add; add = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Node{"</span></span> + <span class="hljs-string"><span class="hljs-string">"key="</span></span> + key + <span class="hljs-string"><span class="hljs-string">", countLefter="</span></span> + countLefter + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } }</code> </pre> <br></div></div><br>  Toll, jetzt kannst du anfangen <b>, einen Baum zu bauen!</b> <br><br>  Als erstes gehen wir nach oben - wir nennen die push () -Methode. <br><br>  Wir löschen das Element durch Löschen von links (wir nehmen den rechten Eckpunkt links vom gelöschten Eckpunkt). <br><br>  Um ein Element nach Index zu erhalten, verfahren wir ganz offensichtlich: Wenn index &lt;countLefter des aktuellen Scheitelpunkts ist, gehen Sie nach links.  Wenn die Werte gleich sind, haben wir einen Scheitelpunkt mit einem bestimmten Index gefunden.  Ansonsten gehen wir nach rechts. <br><br>  Das Löschen und Hinzufügen eines Elements unterscheidet sich im Prinzip nicht wesentlich von einem regulären Binärbaum, mit Ausnahme des Änderns des countLefter und des Hinzufügens von Feldern.  Wenn wir nach erfolgreicher Hinzufügung / Entfernung nach links oben zurückkehren, müssen diese Felder geändert werden.  Wenn rechts, nein. <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist der Baumcode:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.LinkedList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UNode root; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, key, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); size++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = add(key, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root.key) { root.push(); removeRoot(); size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = remove(key, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root.left); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == root.key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &lt; root.key) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = add(key, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.left = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(root, key, root.countLefter, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); root.countLefter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(key, root.right); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.right = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(root, key, root.countLefter + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeByIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root.countLefter) { removeRoot(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = removeByIndex(index, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeByIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeNode(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; root.countLefter) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = removeByIndex(index, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeByIndex(index, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == root.right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) root.parent.left = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> root.parent.right = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) { root.parent.left = root.right; root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.parent.right = root.right; root.right.add--; } root.right.parent = root.parent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) root.parent.left = root.left; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> root.parent.right = root.left; root.left.parent = root.parent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } UNode right = getRight(root.left); cut(right); root.key = right.key; root.countLefter--; root.right.add--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == root.key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeNode(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &lt; root.key) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = remove(key, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remove(key, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == root.right) { root = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = root.right; root.add--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = root.left; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } UNode right = getRight(root.left); cut(right); root.key = right.key; root.countLefter--; root.right.add--; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.parent.left == node) node.parent.left = node.left; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.parent.right = node.left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) node.left.parent = node.parent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> UNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRight(root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ printTree(root); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; root.push(); printTree(root.left); System.out.println(root); printTree(root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LinkedList&lt;UNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ LinkedList&lt;UNode&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;&gt;(); getAll(root, res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root, LinkedList&lt;UNode&gt; res)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; root.push(); getAll(root.left, res); res.add(root); getAll(root.right, res); } }</code> </pre><br></div></div><br>  → <a href="https://github.com/AlexanderUsatov/UTree" rel="nofollow">Hier finden Sie den</a> Code auf dem Github. <br><br>  Ich werde einige Ergebnisse der Arbeitsgeschwindigkeit geben.  Die Tests wurden durchgeführt an: <br><br><img src="https://habrastorage.org/webt/ym/h3/i4/ymh3i4awvgvvgxntnc8pa9n2tlo.png"><br><br>  <b>Hinzufügen zum Baum:</b> <br><br>  Hinzufügen einer Million zufälliger Elemente im Bereich [0;  1_000): <br>  Über 100 ms.  TreeSet hat diese Aufgabe in ca. 130 ms erledigt. <br><br>  Hinzufügen einer Million zufälliger Elemente im Bereich [0;  10_000): <br>  Über 150 ms.  TreeSet erledigte diese Aufgabe in ca. 190 ms. <br><br>  Hinzufügen einer Million zufälliger Elemente im Bereich [0;  100_000): <br>  Über 320 ms.  TreeSet hat diese Aufgabe in ca. 415 ms erledigt. <br><br>  Hinzufügen einer Million zufälliger Elemente im Bereich [0;  1_000_000): <br>  Ungefähr 510 ms.  TreeSet erledigte diese Aufgabe in ca. 700 ms. <br><br>  Hinzufügen einer Million zufälliger Elemente im Bereich [0;  10_000_000): <br>  Ungefähr 590 ms.  TreeSet hat diese Aufgabe in ca. 750 ms erledigt. <br><br>  <b>Entfernung jetzt</b> <br><br>  Fügen Sie dem Baum nach dem Zufallsprinzip eine Million Zahlen hinzu.  Dann versuchen wir, eine Zufallszahl millionenfach zu löschen.  Bei Tests wird nur die zum Entfernen benötigte Zeit berücksichtigt. <br><br>  Der Bereich zum Hinzufügen und Entfernen von [0;  10_000_000): <br>  Ungefähr 740 ms.  TreeSet hat diese Aufgabe in ca. 750 ms erledigt. <br><br>  Der Bereich zum Hinzufügen und Entfernen von [0;  1_000_000): <br>  Über 600 ms.  TreeSet hat diese Aufgabe in ca. 800 ms erledigt (mehr als im vorherigen Test). <br><br>  Der Bereich zum Hinzufügen und Entfernen von [0;  100_000): <br>  Über 130 ms.  TreeSet hat diese Aufgabe in ca. 160 ms erledigt. <br><br>  Der Bereich zum Hinzufügen und Entfernen von [0;  10_000): <br>  Über 45 ms.  TreeSet hat diese Aufgabe in ca. 50 ms erledigt. <br><br>  Der Bereich zum Hinzufügen und Entfernen von [0;  1_000): <br>  Ungefähr 30 ms.  TreeSet hat diese Aufgabe in ca. 37 ms erledigt. <br><br>  <b>Nun, und zu guter Letzt, um alles in Gang zu setzen, greifen Sie über den Index zu</b> <br><br>  TreeSet verfügt nicht über diese Funktionalität.  Also werde ich die Ergebnisse nur für UTree geben.  Wir addieren erneut eine Million Elemente und erhalten dann das Element mit einem zufälligen Index von 0 bis zur Anzahl der Elemente im Baum.  Die Zeit wird nur für den Zugriff per Index berücksichtigt. <br><br>  Additionsbereich [0;  1000): 85 ms <br><br>  Additionsbereich [0;  10_000): 140 ms <br><br>  Additionsbereich [0;  100_000): 300 ms <br><br>  Additionsbereich [0;  1_000_000): 655 ms <br><br>  Ich hoffe, jemand findet meine Idee nützlich, aber vielleicht ist dies für jemanden eine Gelegenheit, sich mit binären Bäumen zu befassen, wenn Sie dies nicht getan haben :) <br><br>  <b>PS</b> <br><br>  Ich habe vor, mich nach dem Neujahr mit dem Auswuchten des Baumes zu beschäftigen.  In diesem Fall wird der Link zum Fortfahren hier angezeigt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479142/">https://habr.com/ru/post/de479142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479126/index.html">Python in der mobilen Entwicklung</a></li>
<li><a href="../de479128/index.html">Wie funktioniert der medizinische Dienst am Flughafen?</a></li>
<li><a href="../de479132/index.html">Externe Komponente für 1C Mobile-Plattform (BroadcastReceiver)</a></li>
<li><a href="../de479136/index.html">Quantencomputer: das Ende der Blockchain?</a></li>
<li><a href="../de479140/index.html">Genießen Sie Flutter Interact Worldwide in Ozons Büro</a></li>
<li><a href="../de479144/index.html">Muss ich meine Marke registrieren lassen?</a></li>
<li><a href="../de479146/index.html">Vergleich der Bypass-Tools \ VPN</a></li>
<li><a href="../de479150/index.html">Agrarroboter schreiten voran</a></li>
<li><a href="../de479152/index.html">Reagiere und schaue ohne npm und baue</a></li>
<li><a href="../de479154/index.html">Noch ein Kampf oder genug?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>