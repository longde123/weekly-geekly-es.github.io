<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 🚵 👩🏾 Cataclysm Dark Days Ahead, statische Analyse und Bagels 🆎 👙 💽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aus dem Titel des Artikels haben Sie höchstwahrscheinlich bereits erraten, dass der Fokus auf Fehlern im Quellcode liegt. Dies ist jedoch nicht das ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cataclysm Dark Days Ahead, statische Analyse und Bagels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449472/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73b/65b/d13/73b65bd13915628ce2e414e1881f9ac3.png" alt="Bild 10"></div><br>  Aus dem Titel des Artikels haben Sie höchstwahrscheinlich bereits erraten, dass der Fokus auf Fehlern im Quellcode liegt.  Dies ist jedoch nicht das einzige, was in diesem Artikel behandelt wird.  Wenn Sie neben C ++ und Fehlern im Code eines anderen von ungewöhnlichen Spielen angezogen werden und interessiert sind, was diese „Bagels“ sind und was sie mit ihnen essen, willkommen bei cat! <br><a name="habracut"></a><br>  Auf meiner Suche nach ungewöhnlichen Spielen bin ich auf ein Cataclysm Dark Days Ahead-Spiel gestoßen, das sich von anderen ungewöhnlichen Grafiken unterscheidet: Es wird mit mehrfarbigen ASCII-Zeichen auf schwarzem Hintergrund implementiert. <br><br>  Was in diesem Spiel und seiner Art auffällt, ist, wie viel alles in ihnen implementiert ist.  Insbesondere in Cataclysm zum Beispiel, um einen Charakter zu erstellen, möchte ich nach Anleitungen suchen, da es Dutzende verschiedener Parameter, Funktionen und anfängliche Handlungen gibt, ganz zu schweigen von den Variationen der Ereignisse im Spiel selbst. <br><br>  Dies ist ein Open Source-Spiel, das auch in C ++ geschrieben wurde.  Es war also unmöglich, dieses Projekt über den statischen Analysator PVS-Studio zu passieren und nicht auszuführen, an dessen Entwicklung ich jetzt aktiv beteiligt bin.  Das Projekt selbst hat mich mit der hohen Qualität des Codes überrascht, es enthält jedoch immer noch einige Mängel, und ich werde in diesem Artikel einige davon diskutieren. <br><br>  Bisher wurden viele Spiele mit PVS-Studio getestet.  Sie können beispielsweise unseren anderen Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Analyse in der Videospielbranche: Top 10 Softwarefehler</a> “ lesen. <br><br><h2>  Logik </h2><br>  <b>Beispiel 1:</b> <br><br>  Das folgende Beispiel ist ein typischer Kopierfehler. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdrücke.  Operator: rng (2, 7) &lt;abs (z) ||  rng (2, 7) &lt;abs (z) overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br>  Hier wird der gleiche Zustand zweimal überprüft.  Höchstwahrscheinlich wurde der Ausdruck kopiert und vergessen, etwas daran zu ändern.  Es fällt mir schwer zu sagen, ob dieser Fehler signifikant ist, aber die Prüfung funktioniert nicht wie beabsichtigt. <br><br>  Eine ähnliche Warnung: <ul><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'one_in (100000 / to_turns &lt;int&gt; (dur))'.  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/16d/103/e8c16d1033a55f07c7754b604aae4807.png" alt="Bild 9"></div><br>  <b>Beispiel 2:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V728</a> Eine übermäßige Überprüfung kann vereinfacht werden.  Die '(A &amp;&amp; B) ||  (! A &amp;&amp;! B) 'Ausdruck entspricht dem Ausdruck' bool (A) == bool (B) '.  inventar_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br>  Es gibt keinen Fehler in der Bedingung, aber es ist unnötig kompliziert.  Es lohnt sich, Mitleid mit denen zu haben, die diese Bedingung zerlegen müssen, und es ist einfacher zu schreiben, <i>wenn (left_fav == right_fav)</i> . <br><br>  Eine ähnliche Warnung: <br><br><ul><li>  V728 Eine übermäßige Überprüfung kann vereinfacht werden.  Das '(A &amp;&amp;! B) ||  (! A &amp;&amp; B) 'Ausdruck entspricht dem Ausdruck' bool (A)! = Bool (B) '.  iuse_actor.cpp 2653 </li></ul><br><h2>  Rückzug ich </h2><br>  Es stellte sich für mich als Entdeckung heraus, dass die Spiele, die heute als „Bagels“ bezeichnet werden, nur ziemlich leichte Anhänger des alten Genres der schurkenhaften Spiele sind.  Alles begann mit dem Kult-Rogue-Spiel von 1980, das zum Vorbild wurde und viele Studenten und Programmierer dazu inspirierte, ihre eigenen Spiele zu entwickeln.  Ich denke, dass auch die DnD-Board-Rollenspiel-Community und ihre Variationen viel gebracht haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="Bild 8"></div><br><h2>  Mikrooptimierung </h2><br>  <b>Beispiel 3:</b> <br><br>  Die nächste Gruppe von Analysatorwarnungen zeigt keinen Fehler an, sondern die Möglichkeit einer Mikrooptimierung des Programmcodes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V801</a> Leistungsminderung.  Es ist besser, das zweite Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... type' durch 'const ... &amp; type'.  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Hier versteckt <i>itdpe_id</i> <i>std :: string</i> .  Da das Argument immer noch konstant übergeben wird, wodurch es nicht geändert werden kann, wäre es schneller, nur einen variablen Verweis auf die Funktion zu übergeben und keine Ressourcen beim Kopieren zu verschwenden.  Und obwohl die Zeile dort höchstwahrscheinlich sehr klein sein wird, ist ein ständiges Kopieren ohne ersichtlichen Grund nicht erforderlich.  Darüber hinaus wird diese Funktion von verschiedenen Stellen aus aufgerufen, von denen viele wiederum auch von außen typisiert und kopiert werden. <br><br>  Ähnliche Warnungen: <br><br><ul><li>  V801 Leistungsminderung.  Es ist besser, das dritte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... evt_filter' durch 'const ... &amp; evt_filter'.  input.cpp 691 </li><li>  V801 Leistungsminderung.  Es ist besser, das fünfte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... color' durch 'const ... &amp; color'.  output.h 207 </li><li>  Insgesamt erzeugte der Analysator 32 solcher Warnungen. </li></ul><br>  <b>Beispiel 4:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V813</a> Leistungsminderung.  Das Argument 'str' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br>  In diesem Fall ändert sich das Argument, obwohl es nicht konstant ist, nicht im Hauptteil der Funktion.  Zur Optimierung wäre es daher hilfreich, eine konstante Verknüpfung zu verwenden und den Compiler nicht zu zwingen, lokale Kopien zu erstellen. <br><br>  Diese Warnung war auch nicht einzeln, es gab insgesamt 26 solcher Fälle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="Bild 7"></div><br>  Ähnliche Warnungen: <br><br><ul><li>  V813 Leistungsminderung.  Das Argument 'message' sollte wahrscheinlich als konstante Referenz gerendert werden.  json.cpp 1452 </li><li>  V813 Leistungsminderung.  Das Argument 's' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 218 </li><li>  Usw... </li></ul><br><h2>  Rückzug II </h2><br>  Einige der klassischen Roguelike-Spiele werden noch entwickelt.  Wenn Sie zu den GitHub Cataclysm DDA- oder NetHack-Repositorys gehen, können Sie sehen, dass täglich Änderungen aktiv vorgenommen werden.  NetHack ist im Allgemeinen das älteste Spiel, das noch entwickelt wird: Es wurde im Juli 1987 veröffentlicht und die neueste Version stammt aus dem Jahr 2018. <br><br>  Eines der bekanntesten, jedoch späteren Spiele dieses Genres ist Dwarf Fortress, das seit 2002 entwickelt und erstmals 2006 veröffentlicht wurde.  "Verlieren macht Spaß" lautet das Motto des Spiels, das seine Essenz genau widerspiegelt, da es unmöglich ist, es zu gewinnen.  Dieses Spiel im Jahr 2007 wurde aufgrund der Abstimmung, die jährlich auf der ASCII GAMES-Website stattfindet, zum besten schurkenhaften Spiel des Jahres gekürt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="Bild 6"></div><br>  Übrigens könnten diejenigen, die an diesem Spiel interessiert sind, an den folgenden Neuigkeiten interessiert sein.  Dwarf Fortress wird auf Steam mit verbesserten 32-Bit-Grafiken veröffentlicht.  Mit einem aktualisierten Bild, an dem zwei erfahrene Spielmoderatoren arbeiten, erhält die Premium-Version von Dwarf Fortress zusätzliche Musiktitel und Unterstützung für Steam Workshop.  Wenn überhaupt, können die Besitzer der kostenpflichtigen Version von Dwarf Fortress die aktualisierten Grafiken auf das vorherige Formular in ASCII ändern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Details</a> . <br><br><h2>  Zuweisungsoperator überschreiben </h2><br>  <b>Beispiele 5, 6:</b> <br><br>  Es gab auch ein interessantes Paar ähnlicher Warnungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonObject' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gefährlich, eine solche Klasse zu benutzen.  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br>  Diese Klasse verfügt über einen Kopierkonstruktor und einen Destruktor, überlastet jedoch den Zuweisungsoperator nicht.  Das Problem hierbei ist, dass ein automatisch generierter Zuweisungsoperator nur einen Zeiger auf <i>JsonIn</i> zuweisen <i>kann</i> .  Infolgedessen verweisen beide Objekte der <i>JsonObject-</i> Klasse auf dasselbe <i>JsonIn</i> .  Es ist nicht bekannt, ob eine solche Situation jetzt irgendwo auftreten könnte, aber auf jeden Fall ist dies ein Rechen, auf den früher oder später jemand treten wird. <br><br>  Ein ähnliches Problem tritt in der folgenden Klasse auf. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonArray' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gefährlich, eine solche Klasse zu benutzen.  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br>  Weitere Informationen zur Gefahr einer fehlenden Überlastung eines Zuweisungsoperators für eine komplexe Klasse finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Gesetz der großen Zwei</a> " (oder in der Übersetzung dieses Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++: Das Gesetz der großen Zwei</a> "). <br><br>  <b>Beispiele 7, 8:</b> <br><br>  Ein weiteres Beispiel bezog sich auf den überladenen Zuweisungsoperator, aber dieses Mal sprechen wir über seine spezifische Implementierung. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; other' geschützt werden.  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Das Problem ist, dass diese Implementierung nicht davor geschützt ist, das Objekt sich selbst zuzuweisen, was eine unsichere Vorgehensweise ist.  Das heißt, wenn ein Verweis auf <i>* dies</i> an diesen Operator übergeben wird, kann ein Speicherverlust auftreten. <br><br>  Ein ähnliches Beispiel für eine fehlerhafte Überlastung des Zuweisungsoperators mit einem interessanten Nebeneffekt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; rhs' geschützt werden.  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  In diesem Fall wird die Zuordnung des Objekts zu sich selbst nicht überprüft.  Zusätzlich füllt sich der Vektor.  Wenn Sie versuchen, sich das Objekt durch eine solche Überladung zuzuweisen, erhalten wir im Zielfeld einen doppelten Vektor, dessen Elemente teilweise beschädigt sind.  Vor der <i>Transformation</i> ist jedoch <i>klar</i> <i>,</i> dass der Vektor des Objekts gelöscht wird und Daten verloren gehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92a/db9/a3a/92adb9a3ab8b30a4f8c02de2bc353a7a.png" alt="Bild 16"></div><br><h2>  Rückzug III </h2><br>  Im Jahr 2008 erhielten Bagels sogar eine formale Definition, die den epischen Namen „Berlin Interpretation“ erhielt.  Nach dieser Definition sind die Hauptmerkmale solcher Spiele: <br><br><ul><li>  Eine zufällig generierte Welt, die den Wiederholungswert erhöht. </li><li>  Permadeath: Wenn dein Charakter stirbt, stirbt er für immer und alle Gegenstände sind verloren. </li><li>  Schritt für Schritt: Änderungen erfolgen nur zusammen mit der Aktion des Spielers, bis die Aktion ausgeführt wird - die Zeit stoppt; </li><li>  Überleben: Die Ressourcen sind äußerst begrenzt. </li></ul><br>  Gut und vor allem: Bagels zielen in erster Linie darauf ab, die Welt zu erkunden und zu entdecken, nach neuen Wegen zu suchen, um Objekte zu benutzen und durch Dungeons zu gehen. <br><br>  Die übliche Situation in Cataclysm DDA: Gefroren und todhungrig, werden Sie von Durst gequält, und tatsächlich haben Sie sechs Tentakel anstelle von Beinen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="Bild 15"></div><br><h2>  Wichtige Details </h2><br>  <b>Beispiel 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> Möglicher Überlauf.  Ziehen Sie in Betracht, Operanden des Operators 'start + large' in den Typ 'size_t' umzuwandeln, nicht in das Ergebnis.  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br>  Es sieht so aus, als wollte der Programmierer einen Überlauf vermeiden.  In diesem Fall ist es jedoch sinnlos, das Ergebnis der Addition zu bringen, da beim Hinzufügen der Zahlen ein Überlauf auftritt und eine Typerweiterung für das bedeutungslose Ergebnis durchgeführt wird.  Um diese Situation zu vermeiden, müssen Sie nur eines der Argumente in einen größeren Typ <i>umwandeln</i> : <i>(static_cast &lt;Größe_t&gt; (Start) + größer)</i> . <br><br>  <b>Beispiel 10:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V530</a> Der Rückgabewert der Funktion 'Größe' muss verwendet werden.  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br>  Für solche Fälle gibt es einen kleinen Trick.  Wenn die Variable nicht verwendet wird, können Sie, anstatt zu versuchen, eine Methode aufzurufen, einfach <i>(void) world_name</i> schreiben, um die Compiler-Warnung zu unterdrücken. <br><br>  <b>Beispiel 11:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V812</a> Leistungsminderung.  Ineffektive Verwendung der Zählfunktion.  Es kann möglicherweise durch den Aufruf der Funktion 'find' ersetzt werden.  player.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br>  Gemessen an der Tatsache, dass das Ergebnis der <i>Zählung</i> mit Null verglichen wird, besteht die Idee darin zu verstehen, ob es mindestens ein erforderliches Element in der <i>Aktivität gibt</i> .  Die <i>Zählung</i> muss jedoch den gesamten Container durchlaufen, da alle Vorkommen des Elements gezählt werden.  In dieser Situation ist es schneller, <i>find</i> zu verwenden, das stoppt, nachdem das erste Match gefunden wurde. <br><br>  <b>Beispiel 12:</b> <br><br>  Der folgende Fehler wird leicht erkannt, wenn Sie eine Subtilität kennen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Das 'ch' sollte vom Typ 'int' sein.  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/976/f53/d2f/976f53d2fe83c567077c7eacb481d852.png" alt="Bild 3"></div><br>  Dies ist einer dieser Fehler, die schwer zu bemerken sein können, wenn Sie nicht wissen, dass <i>EOF</i> als -1 definiert ist.  Wenn Sie versuchen, es mit einer Variablen vom Typ <i>signiertes Zeichen</i> zu vergleichen, ist die Bedingung dementsprechend fast immer <i>falsch</i> .  Die einzige Ausnahme ist, wenn der Zeichencode 0xFF (255) ist.  Beim Vergleich wird ein solches Symbol zu -1 und die Bedingung ist wahr. <br><br>  <b>Beispiel 13:</b> <br><br>  Der nächste kleine Fehler könnte eines Tages kritisch werden.  Kein Wunder, dass es auf der CWE-Liste als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-834 steht</a> .  Und es waren übrigens fünf von ihnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist möglich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.  Fügen Sie dem bedingten Ausdruck möglicherweise den Funktionsaufruf 'cin.fail ()' hinzu.  action.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br>  Wie in der Warnung angegeben, reicht es nicht aus, beim Lesen zu prüfen, ob das Ende der Datei erreicht ist. Sie müssen auch nach <i>cin.fail () -Lesefehlern suchen</i> .  Ändern Sie den Code für ein sichereres Lesen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <i>keymap_txt.clear () wird</i> benötigt, um den Fehlerstatus (Flag) im Falle eines Lesefehlers aus der Datei aus dem Stream zu entfernen, andernfalls kann der Text nicht weiter gelesen werden.  <i>Mit keymap_txt.ignore</i> mit den <i>Parametern numeric_limits &lt;streamsize&gt; :: max ()</i> und einem Zeilenvorschubsteuerzeichen können Sie den Rest der Zeile überspringen. <br><br>  Es gibt einen viel einfacheren Weg, mit dem Lesen aufzuhören: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br>  Wenn es in einem logischen Kontext verwendet wird, konvertiert es sich in einen Wert, der <i>true</i> entspricht, bis <i>EOF</i> erreicht ist. <br><br><h2>  Rückzug IV </h2><br>  Jetzt sind die beliebtesten Spiele diejenigen, die die Zeichen von Roguelike-Spielen und anderen Genres kombinieren: Plattformer, Strategien usw. Solche Spiele werden inzwischen als Roguelike-like oder Roguelite bezeichnet.  Zu solchen Spielen gehören so berühmte Titel wie Don't Starve, Die Bindung von Isaac, FTL: Schneller als Licht, Darkest Dungeon und sogar Diablo. <br><br>  Obwohl der Unterschied zwischen Roguelike und Roguelite manchmal so gering ist, dass nicht klar ist, zu welchem ​​Genre das Spiel gehört.  Jemand glaubt, dass die Zwergenfestung nicht mehr wie ein Schurke ist, aber für jemanden ist Diablo ein klassischer Bagel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="Bild 1"></div><br><h2>  Fazit </h2><br>  Obwohl das gesamte Projekt ein Beispiel für hochwertigen Code ist und es nicht möglich war, viele schwerwiegende Fehler zu finden, bedeutet dies nicht, dass die Verwendung der statischen Analyse für ihn überflüssig ist.  Es geht nicht um einmalige Überprüfungen, die wir durchführen, um die Methodik der statischen Code-Analyse bekannt zu machen, sondern um die regelmäßige Verwendung des Analysators.  Dann können viele Fehler frühzeitig erkannt werden und reduzieren somit die Kosten für deren Korrektur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel für</a> Berechnungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="Bild 2"></div><br>  An dem betrachteten Spiel wird aktiv gearbeitet, und es gibt eine aktive Community von Moddern.  Darüber hinaus ist es auf viele Plattformen portiert, einschließlich iOS und Android.  Wenn Sie an diesem Spiel interessiert sind, empfehle ich Ihnen, es zu versuchen! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449472/">https://habr.com/ru/post/de449472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449460/index.html">Museum DataArt. Der Mausmanipulator für grafische Informationen</a></li>
<li><a href="../de449462/index.html">Verwenden von kryptografischen PKCS # 11-Token-Mechanismen in Skriptsprachen</a></li>
<li><a href="../de449464/index.html">Widget vk.com ohne Nachfrage setzt einen Zähler von mail.ru auf der Site</a></li>
<li><a href="../de449466/index.html">Pausen in HTML5-Spielen</a></li>
<li><a href="../de449468/index.html">Wie der "ethische Hack" des Herstellers von Glücksspielsoftware zu einem Albtraum wurde</a></li>
<li><a href="../de449476/index.html">Ein neuer SSD-Speichertyp reduziert den Stromverbrauch im Rechenzentrum - so funktioniert es</a></li>
<li><a href="../de449478/index.html">Hinzufügen von UICollectionViews zu einer benutzerdefinierten UITableViewCell, die über Xib erfolgt</a></li>
<li><a href="../de449480/index.html">Wählen Sie die entsprechende Fehlerverfolgung</a></li>
<li><a href="../de449484/index.html">Wir entwickeln einen Luftqualitätskontrollsensor für InfluxDB, Grafana, Docker und Raspberry Pi</a></li>
<li><a href="../de449486/index.html">Massenexodus von Browsergames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>