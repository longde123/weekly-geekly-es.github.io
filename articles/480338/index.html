<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèæ üçØ üòÉ C√≥mo funciona la renderizaci√≥n de juegos en 3D: rasterizaci√≥n y trazado de rayos üë©üèª‚Äçüåæ üßìüèæ üë¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1: procesamiento de v√©rtices 

 En este art√≠culo, veremos m√°s de cerca lo que le sucede al mundo 3D despu√©s de que se procesen todos sus v√©rtice...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona la renderizaci√≥n de juegos en 3D: rasterizaci√≥n y trazado de rayos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480338/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png" alt="imagen"></div><br>  <a href="https://habr.com/ru/post/472688/">Parte 1: procesamiento de v√©rtices</a> <br><br>  En este art√≠culo, veremos m√°s de cerca lo que le sucede al mundo 3D despu√©s de que se procesen todos sus v√©rtices.  Nuevamente tendremos que sacudir el polvo de los libros de texto de matem√°ticas, acostumbrarnos a la geometr√≠a de las pir√°mides de truncamiento y resolver el misterio de las perspectivas.  Tambi√©n nos sumergiremos brevemente en la f√≠sica del trazado de rayos, la iluminaci√≥n y los materiales. <br><br>  El tema principal de este art√≠culo es una importante etapa de representaci√≥n, en la que el mundo tridimensional de puntos, segmentos y tri√°ngulos se convierte en una cuadr√≠cula bidimensional de bloques multicolores.  Muy a menudo, este proceso parece invisible, porque la conversi√≥n de 3D a 2D es invisible, en contraste con el proceso descrito en el <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">art√≠culo anterior</a> , donde pudimos ver inmediatamente la influencia de los sombreadores de v√©rtices y la teselaci√≥n.  Si a√∫n no est√° listo para esto, puede comenzar con nuestro art√≠culo <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D Game Rendering 101</a> . <br><br><h2>  Preparaci√≥n para dos mediciones. </h2><br>  La gran mayor√≠a de los lectores leen este sitio web en un monitor completamente plano o en la pantalla de un tel√©fono inteligente;  pero incluso si tiene una t√©cnica moderna: un monitor curvo, la imagen que muestra tambi√©n consta de una cuadr√≠cula plana de p√≠xeles multicolores.  Sin embargo, cuando juegas al nuevo Call of Mario: Deathduty Battleyard, las im√°genes parecen tridimensionales.  Los objetos se mueven por la escena, se hacen m√°s grandes o m√°s peque√±os, se acercan y se alejan de la c√°mara. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/506/855/46b506855796dd802382dc4fde347751.jpg"></div><br>  Tomando Bethesda's <a href="https://www.techspot.com/review/1089-fallout-4-benchmarks/">Fallout 4</a> como ejemplo, lanzado en 2014, podemos ver f√°cilmente c√≥mo se procesan los picos, creando una sensaci√≥n de profundidad y distancia;  Esto es especialmente notable en el modo de estructura al√°mbrica (ver arriba). <br><br>  Si toma alg√∫n juego 3D en las √∫ltimas dos d√©cadas, casi cada uno de ellos realiza la misma secuencia de acciones para convertir el mundo 3D de v√©rtices en una matriz de p√≠xeles 2D.  Esta conversi√≥n a menudo se llama <em>rasterizaci√≥n</em> , pero este es solo uno de los muchos pasos en todo el proceso. <br><br>  Necesitamos analizar las diferentes etapas y estudiar las t√©cnicas y c√°lculos utilizados en ellas.  Como referencia, utilizaremos la secuencia utilizada en Direct3D.  La imagen a continuaci√≥n muestra lo que sucede con cada v√©rtice del mundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/621/43c/77462143c6d436fe0ad9145815956cf5.png"></div><br>  <i>Tuber√≠a de conversi√≥n de Direct3D</i> <br><br>  En el <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">primer art√≠culo</a> [ <a href="https://habr.com/ru/post/472688/">traducci√≥n</a> en Habr√©] vimos lo que est√° sucediendo en el espacio mundial (espacio mundial): aqu√≠, usando varios c√°lculos matriciales, los v√©rtices se transforman y colorean.  Omitiremos el siguiente paso, porque en el espacio de la c√°mara solo los v√©rtices se convierten y ajustan despu√©s de moverse, de modo que la c√°mara se convierte en un punto de referencia. <br><br>  Los siguientes pasos son demasiado complicados para omitirlos, ya que son absolutamente necesarios para la transici√≥n de 3D a 2D: si se implementa correctamente, nuestro cerebro mirar√° una pantalla plana, pero "ver√°" una escena con profundidad y escala.  Si todo se hace mal, ¬°la imagen ser√° muy extra√±a! <br><br><h2>  Se trata de perspectiva </h2><br>  El primer paso en esta secuencia es establecer el alcance desde el punto de vista de la c√°mara.  Para hacer esto, primero debe establecer los √°ngulos del campo de visi√≥n horizontal y vertical, el primero a menudo cambia en los juegos, porque las personas han desarrollado una visi√≥n perif√©rica horizontal mejor que la vertical. <br><br>  Podemos resolver esto mirando la imagen con el campo de visi√≥n de una persona: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/37e/69b/75437e69be055c93670bb139fc2e47d9.png"></div><br>  Las dos esquinas del campo de visi√≥n (campo de visi√≥n, fov) definen la forma de la pir√°mide de <em>frustum</em> : una pir√°mide 3D con una base cuadrada que emana de la c√°mara.  La primera esquina establece el campo <em>vertical</em> , la segunda <em>horizontal</em> ;  los denotamos con los s√≠mbolos <em>Œ±</em> y <em>Œ≤</em> .  De hecho, vemos que el mundo no es as√≠, pero desde el punto de vista de los c√°lculos es mucho m√°s f√°cil trabajar con la pir√°mide de truncamiento en lugar de tratar de generar una cantidad realista de visibilidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/62f/e5f/0cc62fe5fdb171e47cc3428fa5bdd427.png"></div><br>  Tambi√©n debe especificar dos par√°metros m√°s: la ubicaci√≥n de los <em>planos de recorte (planos de recorte)</em> cercanos (o frontales) y lejanos (posteriores <em>)</em> .  El primero corta la parte superior de la pir√°mide, pero esencialmente determina qu√© tan cerca de la posici√≥n de la c√°mara se dibuja todo;  este √∫ltimo hace lo mismo, pero determina qu√© tan lejos de la c√°mara se procesar√°n las primitivas. <br><br>  El tama√±o y la ubicaci√≥n del plano de truncamiento cercano es muy importante porque se convierte en lo que se llama <em>una ventana gr√°fica</em> .  De hecho, esto es lo que vemos en el monitor, es decir  marco renderizado, y en la mayor√≠a de las API de gr√°ficos, la ventana gr√°fica se dibuja desde la esquina superior izquierda.  En la imagen a continuaci√≥n, el punto (a1, b2) ser√° el origen del plano: el ancho y la altura del plano se miden en relaci√≥n con √©l. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/d66/f95/cf8d66f95ab085a290a35d996f94ed3d.png"></div><br>  <em>La relaci√≥n de aspecto de</em> la ventana gr√°fica es importante no solo para mostrar el mundo renderizado, sino tambi√©n para que coincida con la relaci√≥n de aspecto del monitor.  Durante muchos a√±os, el est√°ndar fue 4: 3 (o 1.3333 ... en decimal).  Sin embargo, hoy la mayor√≠a juega en una relaci√≥n de aspecto de 16: 9 o 21: 9, llamada pantalla panor√°mica y pantalla ultra panor√°mica. <br><br>  Las coordenadas de cada v√©rtice en el espacio de la c√°mara deben transformarse para que se ajusten en el plano de truncamiento cercano, como se muestra a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/73f/69c/ba373f69c98de8b0000785606d1d56df.png"></div><br>  <i>Recorte lateral y superior de la pir√°mide</i> <br><br>  La transformaci√≥n se realiza utilizando otra matriz llamada <em>matriz de proyecci√≥n en perspectiva</em> .  En el siguiente ejemplo, para realizar las transformaciones, utilizamos los √°ngulos del alcance y la posici√≥n de los planos de truncamiento;  sin embargo, puede usar el tama√±o de la ventana gr√°fica en su lugar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/32e/2e1/d7632e2e15dd515df9f624a62f8fdce9.png"></div><br>  El vector de posici√≥n del v√©rtice se multiplica por esta matriz, que nos da un nuevo conjunto de coordenadas transformadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/8d6/a1d/2678d6a1d623c710e22675d54d05eaa2.png"></div><br>  Voila!  Ahora todos los v√©rtices est√°n escritos de tal manera que el mundo fuente se presenta como una perspectiva 3D, y las primitivas cerca del plano de truncamiento frontal parecen m√°s grandes que las m√°s cercanas al plano lejano. <br><br>  Aunque el tama√±o de la ventana gr√°fica y los √°ngulos de √°ngulo de visi√≥n est√°n relacionados, pueden procesarse individualmente.  En otras palabras, puede establecer la pir√°mide de truncamiento de tal manera que obtenga un plano de truncamiento cercano que difiera en tama√±o y relaci√≥n de aspecto de la ventana gr√°fica.  Para hacer esto, se necesita un paso adicional en la cadena de operaciones, en el cual los v√©rtices en el plano de truncamiento cercano deben transformarse nuevamente para dar cuenta de esta diferencia. <br><br>  Sin embargo, esto puede conducir a una distorsi√≥n de la perspectiva visible.  Usando el <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">juego</a> Bethesda <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">Skyrim 2011 como</a> ejemplo <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">,</a> podemos ver c√≥mo cambiar el √°ngulo horizontal de la regi√≥n de visibilidad <em>Œ≤</em> mientras se mantiene la misma relaci√≥n de aspecto de la ventana gr√°fica afecta en gran medida la escena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/2b8/4f7/fe92b84f7381a559d307517a2d46258a.jpg"></div><br>  En esta primera imagen, establecemos <em>Œ≤</em> = 75 ¬∞, y la escena se ve completamente normal.  Intentemos ahora establecer <em>Œ≤</em> = 120 ¬∞: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/bf9/a3b/4e0bf9a3b44c400447fb73393a26916d.jpg"></div><br>  Dos diferencias se notan de inmediato: en primer lugar, ahora vemos mucho m√°s en los lados de nuestro "campo de visi√≥n";  En segundo lugar, los objetos ahora parecen mucho m√°s lejanos (especialmente los √°rboles).  Sin embargo, el efecto visual en la superficie del agua ahora se ve mal, porque el proceso no fue dise√±ado para tal √°rea de visibilidad. <br><br>  ¬°Ahora imaginemos que nuestro personaje tiene ojos extra√±os y establezca <em>Œ≤</em> = 180 ¬∞! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6e/548/b9f/a6e548b9faa9cba6e3fa80a33a95444d.jpg"></div><br>  Tal √°rea de visibilidad crea una escena casi panor√°mica, pero debe pagarla con una gran distorsi√≥n de los objetos renderizados en los bordes.  Esto nuevamente sucedi√≥ debido al hecho de que los dise√±adores del juego no previeron tal situaci√≥n y no crearon los recursos y efectos visuales del juego para tal √°ngulo de visi√≥n (el valor est√°ndar es aproximadamente 70 ¬∞). <br><br>  Puede parecer que en las im√°genes anteriores la c√°mara se ha movido, pero esto no es as√≠: el √∫nico cambio es modificar la pir√°mide de truncamiento, que a su vez cambi√≥ las dimensiones del plano de truncamiento cercano.  En cada imagen, la relaci√≥n de aspecto de la ventana gr√°fica sigue siendo la misma, por lo que la matriz de escala se aplica a los v√©rtices para que todo encaje en ella. <br><br><h2>  ¬øEntonces te quedas o te vas? </h2><br>  Despu√©s de realizar las transformaciones en la etapa de proyecci√≥n, pasamos a lo que se llama un <em>espacio de recorte</em> .  Aunque esto se hace <em>despu√©s de la</em> proyecci√≥n, es m√°s f√°cil mostrar lo que sucede si realizamos las operaciones por adelantado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/5aa/921/8d15aa92153b56847f0a3eaba62000a0.png"></div><br>  En la figura anterior, vemos que en el pato de goma, uno de los murci√©lagos y parte de los √°rboles, los tri√°ngulos est√°n dentro de la pir√°mide de truncamiento;  sin embargo, el otro murci√©lago y el √°rbol m√°s alejado est√°n fuera de los l√≠mites de la pir√°mide de truncamiento.  Aunque los v√©rtices que componen estos objetos ya se han procesado, no los veremos en la ventana gr√°fica.  Esto significa que <em>est√°n recortados</em> . <br><br>  Al <em>truncar a lo largo de la pir√°mide (recorte de frustum),</em> todas las primitivas fuera de la pir√°mide de truncamiento se eliminan por completo, y las que se encuentran en los bordes se convierten en nuevas primitivas.  El truncamiento no mejora en gran medida el rendimiento, porque todos estos v√©rtices invisibles ya se han procesado antes de esta etapa en sombreadores de v√©rtices, etc.  Si es necesario, se puede omitir por completo el paso de truncamiento completo, pero esta caracter√≠stica no es compatible con todas las API (por ejemplo, el OpenGL est√°ndar no permitir√° que se omita, pero esto se puede hacer usando la extensi√≥n API). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e07/57c/7a5e0757c7f8368a6d419c59468ec03e.png"></div><br>  Vale la pena se√±alar que la posici√≥n del plano de truncamiento lejano en los juegos no siempre es igual a la <em>distancia de sorteo</em> , ya que este √∫ltimo est√° controlado por el motor del juego.  El motor tambi√©n realiza un <em>recorte en la pir√°mide (eliminaci√≥n del tronco)</em> : ejecuta un c√≥digo que determina si el objeto se dibujar√° dentro de la pir√°mide de truncamiento y si afectar√° a los objetos visibles;  Si la respuesta es <em>no</em> , el objeto no se transfiere a la representaci√≥n.  Esto no es lo mismo que el recorte de frustrum porque tambi√©n descarta primitivas fuera de la pir√°mide, pero ya han pasado la etapa de procesamiento de v√©rtices.  Cuando se eliminan, no se procesan en absoluto, lo que ahorra muchos recursos. <br><br>  Hemos hecho todas las transformaciones y el truncamiento, y parece que los v√©rtices finalmente est√°n listos para el siguiente paso en la secuencia de representaci√≥n.  Pero, de hecho, esto no es as√≠, porque todos los c√°lculos realizados en la etapa de procesamiento de v√©rtices y en las operaciones de transformaci√≥n del espacio mundial al espacio de truncamiento deben realizarse en un sistema de coordenadas uniforme (es decir, cada v√©rtice tiene 4 componentes, no 3) .  Sin embargo, la ventana gr√°fica es completamente bidimensional, es decir, la API espera que la informaci√≥n del v√©rtice contenga solo los valores para <em>x, y</em> (aunque <em>se</em> guarda el valor de profundidad <em>z</em> ). <br><br>  Para deshacerse del cuarto componente, se realiza una <em>divisi√≥n en perspectiva</em> , en la que cada componente se divide por el valor de <em>w</em> .  Esta operaci√≥n restringe <em>xey al</em> intervalo de valores posibles [-1.1], <em>yz</em> al intervalo [0.1].  Estos se denominan <em>coordenadas de dispositivo normalizadas</em> (NDC). <br><br>  Si desea obtener m√°s informaci√≥n sobre lo que acabamos de explicar y le gustan las matem√°ticas, lea el <a href="http://www.songho.ca/opengl/gl_transform.html">excelente tutorial</a> sobre este tema Song Ho An.  ¬°Ahora vamos a convertir estos v√©rtices en p√≠xeles! <br><br><h2>  Dominamos la rasterizaci√≥n </h2><br>  Como en el caso de las transformaciones, veremos las reglas y los procesos utilizados para convertir una ventana gr√°fica en una cuadr√≠cula de p√≠xeles, utilizando Direct3D como ejemplo.  Esta tabla se asemeja a una hoja de c√°lculo Excel con filas y columnas, en la que cada celda contiene diferentes valores de datos (como color, valores de profundidad, coordenadas de textura, etc.).  Por lo general, esta cuadr√≠cula se denomina <em>imagen r√°ster</em> , y el proceso de su generaci√≥n se denomina <em>rasterizaci√≥n</em> .  En el art√≠culo <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D rendering 101,</a> simplificamos este procedimiento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/01f/0e7/3b601f0e71774ce64eeb0a8f75a83f67.png"></div><br>  La imagen de arriba da la impresi√≥n de que las primitivas simplemente se cortan en peque√±os bloques, pero en realidad hay muchas m√°s operaciones.  El primer paso es determinar si la primitiva est√° orientada hacia la c√°mara; por ejemplo, en la imagen de arriba con una pir√°mide de truncamiento, las primitivas que forman la parte posterior del conejo gris no ser√°n visibles.  Por lo tanto, aunque est√°n presentes en la ventana gr√°fica, no necesitan ser renderizados. <br><br>  Podemos imaginar aproximadamente c√≥mo se ve mirando el diagrama a continuaci√≥n.  El cubo experiment√≥ varias transformaciones para colocar el modelo 3D en el espacio 2D de la pantalla, y desde el punto de vista de la c√°mara, algunas de las caras del cubo no son visibles.  Si suponemos que todas las superficies son opacas, entonces algunas de estas primitivas pueden ignorarse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/60a/bf9/69360abf9888e28d60622cf189cbb6c3.png"></div><br>  <i>De izquierda a derecha: espacio mundial&gt; espacio de c√°mara&gt; espacio de proyecci√≥n&gt; espacio de pantalla</i> <br><br>  En Direct3D, esto se puede implementar dici√©ndole al sistema cu√°l ser√° el <em>estado de representaci√≥n</em> , y esta instrucci√≥n le har√° saber que es necesario quitar ( <em>cortar</em> ) los lados de cada primitivo mirando hacia adelante o hacia atr√°s (o no cortar completamente, por ejemplo, en modo de <em>estructura al√°mbrica</em> ) .  Pero, ¬øc√≥mo sabe qu√© lado mira hacia adelante o hacia atr√°s?  Cuando examinamos las <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">matem√°ticas del procesamiento de v√©rtices</a> , vimos que los tri√°ngulos (o m√°s bien los v√©rtices) tienen vectores normales que le indican al sistema en qu√© direcci√≥n est√° mirando.  Gracias a esta informaci√≥n, puede realizar una verificaci√≥n simple, y si la primitiva falla, entonces se elimina de la cadena de representaci√≥n. <br><br>  Ahora es el momento de aplicar la cuadr√≠cula de p√≠xeles.  Este es de nuevo un proceso inesperadamente complejo, porque el sistema debe comprender si el p√≠xel est√° dentro de la primitiva, completamente, parcialmente o nada.  Para hacer esto, se realiza el proceso de <em>prueba de cobertura</em> .  La siguiente figura muestra c√≥mo los tri√°ngulos se rasterizan en Direct3D 11: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/967/ee6/858967ee6e11144896c35c2c726ec606.png"></div><br>  La regla es bastante simple: se considera que un p√≠xel est√° dentro del tri√°ngulo si el centro del p√≠xel pasa un cheque, lo que Microsoft llama la <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">regla "superior izquierda"</a> .  "Arriba" se refiere a verificar la l√≠nea horizontal;  El centro del p√≠xel debe estar <em>en</em> esta l√≠nea.  "Izquierda" se refiere a l√≠neas no horizontales, y el centro del p√≠xel debe estar a la izquierda de dicha l√≠nea.  Existen otras reglas relacionadas con las no primitivas, por ejemplo, segmentos y puntos simples, y cuando se utilizan <em>m√∫ltiples muestras</em> , adicionales si aparecen condiciones en las reglas. <br><br>  Si observa detenidamente la documentaci√≥n de Microsoft, puede ver que las formas creadas por los p√≠xeles no son muy similares a las primitivas originales.  Esto se debe a que los p√≠xeles son demasiado grandes para crear un tri√°ngulo realista: la imagen de mapa de bits no contiene suficientes datos sobre los objetos originales, lo que provoca un fen√≥meno llamado <em>alias</em> . <br><br>  Veamos el alias con un ejemplo de <a href="https://benchmarks.ul.com/legacy-benchmarks">UL Benchmark 3DMark03</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/9d2/289/f119d2289c67082f66e4467385bc07be.jpg"></div><br>  <i>Rasterizaci√≥n de 720 x 480 p√≠xeles</i> <br><br>  En la primera imagen, la imagen de trama tiene una resoluci√≥n muy baja: 720 por 480 p√≠xeles.  El alias es claramente visible en la barandilla y la sombra proyectada por las armas del soldado superior.  Compare esto con el resultado obtenido durante la rasterizaci√≥n con un aumento de 24 veces en el n√∫mero de p√≠xeles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/eba/d3a/ea8ebad3a86c108326f069fc343baed7.jpg"></div><br>  <i>Rasterizaci√≥n 3840 x 2160 p√≠xeles</i> <br><br>  Aqu√≠ vemos que el alias en la barandilla y la sombra ha desaparecido por completo.  Parece que siempre debe usar un mapa de bits grande, pero el tama√±o de la cuadr√≠cula debe ser compatible con el monitor en el que se mostrar√° el marco.  Y teniendo en cuenta el hecho de que todos estos p√≠xeles deben procesarse, es obvio que habr√° una disminuci√≥n en el rendimiento. <br><br>  Multimuestreo puede ayudar aqu√≠.  As√≠ es como funciona en Direct3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/79e/62f/64b79e62fbcd12197ba9ff2c769045ae.png"></div><br>  En lugar de verificar si el centro del p√≠xel coincide con las reglas de rasterizaci√≥n, se <em>verifican</em> varios puntos dentro de cada p√≠xel (llamados muestras de subp√≠xeles o submuestras), y si algunos de ellos satisfacen los requisitos, forman parte de la figura.  Puede parecer que no hay ning√∫n beneficio y el alias incluso se mejora, pero cuando se usa el muestreo m√∫ltiple, la informaci√≥n sobre qu√© submuestras est√°n cubiertas por la primitiva y los resultados del procesamiento de p√≠xeles se almacenan en un b√∫fer en la memoria. <br><br>  Este b√∫fer se usa para mezclar estas submuestras y p√≠xeles para que los bordes de la primitiva est√©n menos desgarrados.  Analizaremos el alias en otro art√≠culo con m√°s detalle, pero por ahora esta informaci√≥n es suficiente para que comprendamos qu√© puede hacer el muestreo m√∫ltiple cuando se usa para rasterizar muy pocos p√≠xeles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/466/b61/703466b61fe655bfe9956003b707d9d5.jpg"></div><br>  Como puede ver, la cantidad de alias en los bordes de diferentes formas ha disminuido significativamente.  La rasterizaci√≥n de mayor resoluci√≥n es definitivamente mejor, pero la degradaci√≥n del rendimiento puede incitarlo a usar el muestreo m√∫ltiple. <br><br>  Tambi√©n durante la rasterizaci√≥n, se realiza una <em>prueba de oclusi√≥n</em> .  Es necesario porque la ventana gr√°fica se llenar√° de primitivas superpuestas entre s√≠; por ejemplo, en la figura anterior, los tri√°ngulos que miran hacia adelante que conforman al soldado en primer plano se superponen a los mismos tri√°ngulos de otro soldado.  Adem√°s de verificar si la primitiva cubre un p√≠xel, tambi√©n puede comparar las profundidades relativas, y si una superficie est√° detr√°s de otra, debe eliminarse del proceso de renderizaci√≥n restante. <br><br>  Sin embargo, si la primitiva cercana es transparente, la primitiva lejana permanecer√° visible, aunque no pasar√° la prueba de superposici√≥n.  Es por eso que casi todos los motores 3D realizan comprobaciones de superposici√≥n <em>antes de</em> enviar datos a la GPU y en su lugar crean algo llamado <em>z-buffer</em> , que es parte del proceso de renderizado.  Aqu√≠, el marco se crea de la manera habitual, pero en lugar de guardar los colores de p√≠xeles listos para usar en la memoria, la GPU guarda solo los valores de profundidad.  Posteriormente se pueden usar en sombreadores para verificar la visibilidad y con un gran control y precisi√≥n de los aspectos relacionados con la superposici√≥n de objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/2bc/c01/f532bcc017258005f427aaed4e3e482e.png"></div><br>  En la imagen que se muestra arriba, cuanto m√°s oscuro es el color del p√≠xel, m√°s cerca est√° el sujeto de la c√°mara.       z-,    ,          ,      z-.   ,         . <br><br>       <em>  </em> ‚Äî        ,   ,       ,    .     ,  ,        ,     <em></em> .    ,    ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de que la pantalla rasterizada se presenta en 2D, las estructuras en su interior representan una perspectiva 3D. </font><font style="vertical-align: inherit;">Si las l√≠neas realmente fueran bidimensionales, entonces podr√≠amos usar una </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ecuaci√≥n lineal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple para calcular colores y otras cosas </font><font style="vertical-align: inherit;">, porque nos movemos de un v√©rtice a otro. </font><font style="vertical-align: inherit;">Pero debido al aspecto 3D de la escena, la interpolaci√≥n debe tener en cuenta esta perspectiva; </font><font style="vertical-align: inherit;">Para obtener m√°s informaci√≥n sobre este proceso, lea el </font></font><a href="http://simonstechblog.blogspot.com/2012/04/software-rasterizer-part-2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente art√≠culo de Simon Young</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, la tarea se completa, por lo que el mundo 3D de v√©rtices se convierte en una cuadr√≠cula 2D de bloques coloridos. </font><font style="vertical-align: inherit;">Pero a√∫n no hemos terminado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De adelante hacia atr√°s (con algunas excepciones) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de que terminemos de considerar la rasterizaci√≥n, necesitamos hablar sobre el orden de la secuencia de representaci√≥n. No estamos hablando de la etapa en la que, por ejemplo, aparece la teselaci√≥n en la secuencia de procesamiento; nos referimos al orden en que se procesan las primitivas. Los objetos generalmente se procesan en el orden en que est√°n en el b√∫fer de √≠ndice (un bloque de memoria que le dice al sistema c√≥mo se agrupan los v√©rtices) y esto puede afectar significativamente la forma en que se procesan los objetos y efectos transparentes.</font></font><br><br>     ,       ,      ,        (       (occlusion culling))       (  ).     " <em> </em> ",           . <br><br>          ,        ,   .        ,        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/c02/6f7/3cac026f78b545088b8de84fcdd11ee4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De izquierda a derecha: el orden en la escena, renderizado de adelante hacia atr√°s, renderizado de atr√°s hacia adelante.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es decir, en todos los juegos modernos, ¬øel renderizado se realiza de atr√°s hacia adelante? Cualquiera que sea el caso, no olvide que renderizar cada primitivo individual conducir√° a una disminuci√≥n mucho mayor en el rendimiento en comparaci√≥n con renderizar solo lo que vemos. Existen otras formas de procesar objetos transparentes, pero en el caso general no existe una soluci√≥n ideal adecuada para cualquier sistema, y ‚Äã‚Äãcada situaci√≥n debe considerarse por separado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, esto nos permite comprender los principales pros y contras de la rasterizaci√≥n: en los equipos modernos es un proceso r√°pido y eficiente, pero sigue siendo un reflejo aproximado de lo que vemos. </font><font style="vertical-align: inherit;">En el mundo real, cada objeto puede absorber, reflejar y, a veces, refractar la luz, y todo esto afecta la apariencia final de la escena mostrada. </font><font style="vertical-align: inherit;">Dividiendo el mundo en primitivas y renderizando solo partes de ellas, nos hacemos r√°pidos. </font><font style="vertical-align: inherit;">Pero un resultado muy duro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, si hubiera otra forma ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otra forma es: ¬°trazado de rayos! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hace casi cincuenta a√±os, un inform√°tico llamado Arthur Eppel trabaj√≥ en un sistema para representar im√°genes en una computadora en la que se emit√≠a un haz de luz de la c√°mara en l√≠nea recta hasta que choc√≥ con un objeto. Despu√©s de la colisi√≥n, las propiedades del material (su color, reflectividad, etc.) cambiaron el brillo del haz de luz. Para cada p√≠xel en la imagen renderizada, hab√≠a un rayo emitido, y el algoritmo realiz√≥ una cadena de c√°lculos para determinar el color del p√≠xel. El proceso de Eppel se llama </font></font><a href="https://en.wikipedia.org/wiki/Ray_casting"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fundici√≥n de rayos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unos diez a√±os despu√©s, otro cient√≠fico llamado </font></font><a href="https://en.wikipedia.org/wiki/J._Turner_Whitted"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Whited</font></font></a>   ,   ,          ,    ,    .            ,           ;          ,     ,   .    <em>  (ray tracing)</em> ( ,  <em></em>  ,        ,    )             <a href="https://graphics.pixar.com/library/RayTracingCars/paper.pdf"></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/733/8a8/5f07338a8846abdebe390b99bd364ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la imagen de arriba, puedes entender c√≥mo funciona el algoritmo Whited. Por cada p√≠xel en el cuadro, se emite un haz desde la c√°mara y se mueve hasta que alcanza la superficie. En este ejemplo, la superficie es transl√∫cida, por lo que la luz puede reflejarse y refractarse a trav√©s de ella. En ambos casos, se generan rayos secundarios que viajan hasta que chocan con la superficie. Tambi√©n se generan nuevos rayos secundarios para tener en cuenta el color de las fuentes de luz y las sombras que crean.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La naturaleza recursiva del proceso es que se pueden generar rayos secundarios cada vez que un nuevo rayo emitido se cruza con la superficie. Esto puede salirse r√°pidamente de control, por lo que el n√∫mero de rayos secundarios generados siempre es limitado. Despu√©s de completar la trayectoria del haz, el color en cada punto final se calcula en funci√≥n de las propiedades del material de esta superficie. Este valor luego se transmite a lo largo del rayo anterior, cambiando el color de esta superficie, y as√≠ sucesivamente, hasta llegar al punto de inicio del rayo primario, es decir, el p√≠xel en el marco.</font></font><br><br>               .  ,  ,   ‚Äî -,   ,       ,  ,          (    ).     ‚Äî      ,    ,      ‚Äî      ,        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/3f8/dac/de43f8dac76ca9bda84700c168cde9ff.jpg"></div><br> <i>:        Nvidia RTX</i> <br><br>  ,                 (bounding volumes, BV) ‚Äî   ,  .          . <br><br> ,  BV    .      , , ,   ..;               ,   ..,           .        , ( <em>BV hierarchy</em>  BVH);          BV: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/319/454/3453194547f780d91a4231529f6f68b4.jpg"></div><br>   BVH,  ,     ,            ,             3D-. <br><br>   ,  <a href="https://www.blender.org/">Blender</a>  <a href="http://www.povray.org/">POV-ray</a>       (  photon tracing  radiosity)     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/b2c/bf6/cfab2cbf6216eaa3e007bdd38f867cd6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede surgir la pregunta obvia: si el trazado de rayos es tan bueno, ¬øpor qu√© no se usa en todas partes? La respuesta radica en dos √°reas: en primer lugar, incluso un simple trazado de rayos crea millones de rayos que deben calcularse una y otra vez. El sistema comienza con un solo haz por p√≠xel de pantalla, es decir, con una resoluci√≥n de 800 x 600, genera 480,000 rayos primarios, y luego cada uno de ellos genera muchos rayos secundarios. Este es un trabajo muy dif√≠cil, incluso para las PC de escritorio modernas. El segundo problema es que el trazado de rayos simple no es muy realista y para su correcta implementaci√≥n necesitas un mont√≥n de ecuaciones adicionales muy complejas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso con equipos modernos, la cantidad de trabajo en juegos 3D es inalcanzable para la implementaci√≥n en tiempo real. En </font></font><a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderizado 3D 101</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vimos que un punto de referencia de trazado de rayos tarda decenas de segundos en crear una sola imagen de baja resoluci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo realiz√≥ el primer </font></font><a href="https://www.techspot.com/downloads/5842-wolfenstein-3d.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfenstein 3D el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lanzamiento de rayos en 1992, y por qu√© los juegos como </font></font><a href="https://www.techspot.com/review/1759-ray-tracing-benchmarks-vol-2/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battlefield V</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lanzados en 2019, ofrecen capacidades de trazado de rayos? </font><font style="vertical-align: inherit;">¬øRealizan rasterizaci√≥n o trazado de rayos? </font><font style="vertical-align: inherit;">Poco a poco de ambos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un enfoque h√≠brido para el presente y el futuro. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En marzo de 2018, Microsoft anunci√≥ el lanzamiento de una nueva extensi√≥n API para Direct3D 12 llamada DXR (DirectX Raytracing). </font><font style="vertical-align: inherit;">Era una nueva tuber√≠a de gr√°ficos que complementa las tuber√≠as est√°ndar de rasterizaci√≥n y computaci√≥n. </font><font style="vertical-align: inherit;">Se agreg√≥ funcionalidad adicional mediante la adici√≥n de sombreadores, estructuras de datos, etc., pero no requiri√≥ soporte de hardware, excepto el que ya era necesario para Direct3D 12.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c9/b88/e83/7c9b88e83184b2412b431ff990e39f89.png"></div><br>  En la misma Conferencia de Desarrolladores de Juegos, en la que <a href="https://devblogs.microsoft.com/directx/wp-content/uploads/sites/42/2018/03/GDC_DXR_deck.pdf">Microsoft habl√≥ sobre DXR</a> , Electronic Arts habl√≥ sobre su <a href="https://www.ea.com/seed/news/seed-project-picapica">Proyecto Pica Pica</a> , un experimento con un motor 3D que usa DXR.  La compa√±√≠a ha demostrado que se puede usar el trazado de rayos, pero no para renderizar todo el marco.  La mayor parte del trabajo utiliza t√©cnicas tradicionales de rasterizaci√≥n y sombreadores computacionales, mientras que DXR se usa en √°reas espec√≠ficas.  Es decir, la cantidad de rayos generados es mucho menor de lo que ser√≠a para toda la escena. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png"></div><br>  Este enfoque h√≠brido se ha utilizado en el pasado, aunque en menor medida.  Por ejemplo, Wolfenstein 3D <a href="https://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/">utiliz√≥ la proyecci√≥n de rayos</a> para representar un cuadro, pero se realiz√≥ con una columna de haz por p√≠xel, no un p√≠xel.  Todav√≠a puede parecer impresionante, a menos que recuerdes que el juego funcion√≥ con una resoluci√≥n de 640 x 480 [aprox.  traducci√≥n: en realidad 320 x 200], es decir, al mismo tiempo no se emitieron m√°s de 640 rayos. <br><br>  A principios de 2018, las tarjetas gr√°ficas como la AMD Radeon RX 580 o la Nvidia GeForce 1080 Ti cumpl√≠an con los requisitos de DXR, pero incluso con sus capacidades inform√°ticas, exist√≠a la preocupaci√≥n de que no ser√≠an lo suficientemente potentes como para que DXR tuviera sentido. <br><br>  La situaci√≥n cambi√≥ en agosto de 2018 cuando Nvidia lanz√≥ su √∫ltima arquitectura de GPU <a href="http://www.techspot.com/news/75952-nvidia-turing-here-next-gen-architecture-first-real.html">, llamada Turing</a> .  La caracter√≠stica m√°s importante de este chip fue la aparici√≥n de los llamados n√∫cleos RT: bloques l√≥gicos separados para acelerar los c√°lculos de la intersecci√≥n tri√°ngulo-rayo y el paso de la jerarqu√≠a de vol√∫menes delimitadores (BVH).  Estos dos procesos son procedimientos que requieren mucho tiempo para determinar los puntos de interacci√≥n de la luz con los tri√°ngulos que forman los objetos de la escena.  Dado que los n√∫cleos RT eran unidades de procesador Turing √∫nicas, el acceso a ellos solo se pod√≠a hacer a trav√©s de la API propietaria de Nvidia. <br><br>  El primer juego que admiti√≥ esta caracter√≠stica fue Battlefield V de EA.  <a href="https://www.techspot.com/review/1749-battlefield-ray-tracing-benchmarks/">Cuando probamos DXR en √©l</a> , nos impresion√≥ la mejora en los reflejos en el agua, el c√©sped y los metales, as√≠ como la disminuci√≥n correspondiente en el rendimiento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/e3e/aa1/1cce3eaa1c5db3688910ec0a1c052ce4.png"></div><br>  Para ser honesto, los parches posteriores mejoraron la situaci√≥n, pero a√∫n hubo una disminuci√≥n en la velocidad de renderizado de cuadros (y todav√≠a lo es).  Para 2019, hab√≠a algunos otros juegos que admiten esta API y realizan el trazado de rayos para partes individuales del marco.  Probamos <a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/">Metro Exodus</a> y <a href="https://www.techspot.com/article/1814-sotr-ray-tracing/">Shadow of the Tomb Raider</a> , ante la misma situaci√≥n: el uso activo de DXR reduce significativamente la velocidad de fotogramas. <br><br>  Casi al mismo tiempo, UL Benchmarks <a href="https://benchmarks.ul.com/news/3dmark-port-royal-ray-tracing-benchmark-now-available">anunci√≥</a> la creaci√≥n de una prueba de funci√≥n DXR para <a href="https://www.techspot.com/downloads/5775-3dmark.html">3DMark</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/60a/a0d/61260aa0d10ef6ed6c69731a6a3038f2.jpg"></div><br>  <i>DXR se usa en la tarjeta gr√°fica Nvidia Titan X (Pascal) - s√≠, el resultado es 8 fps</i> <br><br>  Sin embargo, un estudio de juegos con soporte DXR y la prueba 3DMark mostraron que el trazado de rayos incluso en 2019 sigue siendo una tarea muy dif√≠cil para la GPU, incluso a un precio de m√°s de $ 1,000.  ¬øSignifica esto que no tenemos alternativas reales a la rasterizaci√≥n? <br><br>  Las caracter√≠sticas progresivas en las tecnolog√≠as de gr√°ficos 3D para consumidores a menudo son muy costosas, y su soporte inicial para las nuevas caracter√≠sticas API puede ser bastante fragmentado o lento (como descubrimos <a href="https://www.techspot.com/review/537-max-payne-3-performance/page6.html">cuando</a> probamos <a href="https://www.techspot.com/review/537-max-payne-3-performance/page6.html">Max Payne 3</a> en diferentes versiones de Direct3D en 2012).  El √∫ltimo problema generalmente surge porque los desarrolladores de juegos intentan incorporar tantas caracter√≠sticas modernas en sus productos como sea posible, a veces sin suficiente experiencia. <br><br>  Sin embargo, los sombreadores de v√©rtices y p√≠xeles, la teselaci√≥n, la representaci√≥n HDR y la oclusi√≥n ambiental del espacio de la pantalla tambi√©n fueron t√©cnicas costosas adecuadas solo para GPU potentes, y ahora son el est√°ndar para juegos y se admiten muchas tarjetas gr√°ficas.  Lo mismo suceder√° con el trazado de rayos;  con el tiempo, simplemente se convertir√° en otro par√°metro de detalle, habilitado por defecto para la mayor√≠a de los jugadores. <br><br><h2>  En conclusi√≥n </h2><br>  Entonces, hemos llegado al final de la segunda parte del an√°lisis, en la que hemos profundizado en el mundo de los gr√°ficos 3D.  Aprendimos c√≥mo la parte superior de los mundos y modelos se transfieren desde tres dimensiones y se convierten en una imagen 2D plana.  Vimos que debemos tener en cuenta el alcance y nos dimos cuenta del impacto que tiene.  Examinamos el proceso de convertir estos verines en p√≠xeles, y terminamos con un breve vistazo a las alternativas al proceso tradicional de rasterizaci√≥n. <br><br>  Como en el art√≠culo anterior, era poco probable que pudi√©ramos revelar todos los temas, y nos perdimos algunos detalles; al final, ¬°este no es un libro de texto!  Pero esperamos que haya aprendido algo nuevo y ahora respete el trabajo de los programadores e ingenieros que utilizaron la inform√°tica y la ciencia para implementar todo esto en sus juegos 3D favoritos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480338/">https://habr.com/ru/post/480338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480326/index.html">F5 Networks Corporation env√≠a cartas a sus clientes inform√°ndoles sobre la situaci√≥n actual con NGINX</a></li>
<li><a href="../480328/index.html">C√≥mo hacer amigos PyTorch y C ++. Usando TorchScript</a></li>
<li><a href="../480330/index.html">Herramienta ideal de evaluaci√≥n de empleados</a></li>
<li><a href="../480332/index.html">An√°lisis de los datos de la votaci√≥n de blockchain de 2019 en la Duma de la ciudad de Mosc√∫</a></li>
<li><a href="../480334/index.html">QtQML / Panel de correlaci√≥n r√°pida</a></li>
<li><a href="../480342/index.html">Paradigma de desarrollo a trav√©s de comentarios</a></li>
<li><a href="../480350/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 326 (del 9 al 15 de diciembre)</a></li>
<li><a href="../480352/index.html">El genetista de Harvard desarrolla la aplicaci√≥n de dataci√≥n de an√°lisis de ADN prototipo</a></li>
<li><a href="../480356/index.html">Consejos √∫tiles de Python que no has conocido</a></li>
<li><a href="../480358/index.html">El precio oculto de las bibliotecas CSS-in-JS en las aplicaciones React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>