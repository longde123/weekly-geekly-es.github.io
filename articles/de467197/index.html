<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔧 🔮 🕴🏽 Wie Polymorphismus in der JVM implementiert wird 💪🏿 🏿 🧙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine Übersetzung dieses Artikels wurde speziell für Studenten des Java Developer- Kurses erstellt . 




 In meinem vorherigen Artikel Alles über das ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Polymorphismus in der JVM implementiert wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467197/">  <i>Eine Übersetzung dieses Artikels wurde speziell für Studenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Java Developer-</a> Kurses erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a></i> <br><br><img src="https://habrastorage.org/webt/pv/d6/a7/pvd6a7xzq3zopckoatmhx0ohjn8.png"><br><br><hr><br>  In meinem vorherigen Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alles über das Überladen von Methoden im Vergleich zum Überschreiben von Methoden</a> haben wir uns mit den Regeln und Unterschieden beim Überladen und Überschreiben von Methoden befasst.  In diesem Artikel werden wir sehen, wie das Überladen und Überschreiben von Methoden in der JVM behandelt wird. <a name="habracut"></a><br><br>  Nehmen Sie zum Beispiel die Klassen aus dem vorherigen Artikel: das Eltern- <code>Mammal</code> (Säugetier) und das Kind <code>Human</code> (Mensch). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OverridingInternalExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mammal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"ohlllalalalalalaoaoaoa"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mammal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//   speak() public void speak(String language) { if (language.equals("Hindi")) System.out.println("Namaste"); else System.out.println("Hello"); } @Override public String toString() { return "Human Class"; } } //           public static void main(String[] args) { Mammal anyMammal = new Mammal(); anyMammal.speak(); // Output - ohlllalalalalalaoaoaoa // 10: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V Mammal humanMammal = new Human(); humanMammal.speak(); // Output - Hello // 23: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V Human human = new Human(); human.speak(); // Output - Hello // 36: invokevirtual #7 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:()V human.speak("Hindi"); // Output - Namaste // 42: invokevirtual #9 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:(Ljava/lang/String;)V } }</span></span></code> </pre> <br>  Wir können die Frage des Polymorphismus von zwei Seiten betrachten: von der „logischen“ und der „physischen“.  Schauen wir uns zunächst die logische Seite des Problems an. <br><br><h3>  Logische Sichtweise </h3><br>  Aus logischer Sicht wird die aufgerufene Methode in der Kompilierungsphase als mit der Art der Referenz verbunden angesehen.  Zur Laufzeit wird jedoch die Methode des referenzierten Objekts aufgerufen. <br><br>  Zum Beispiel in der Zeile <code>humanMammal.speak();</code>  Der Compiler glaubt, dass <code>Mammal.speak()</code> aufgerufen wird, da <code>humanMammal</code> als <code>Mammal</code> <code>humanMammal</code> .  <code>humanMammal</code> Laufzeit weiß die JVM jedoch, dass <code>humanMammal</code> ein <code>Human</code> Objekt enthält, und <code>Human.speak()</code> tatsächlich die <code>Human.speak()</code> -Methode auf. <br><br>  Es ist alles ziemlich einfach, solange wir auf einer konzeptionellen Ebene bleiben.  Aber wie geht die JVM intern damit um?  Wie berechnet die JVM, welche Methode aufgerufen werden soll? <br><br>  Wir wissen auch, dass überladene Methoden nicht als polymorph bezeichnet werden und zur Kompilierungszeit aufgelöst werden.  Obwohl manchmal das Überladen von Methoden als <b>Polymorphismus zur Kompilierungszeit oder frühe / statische Bindung bezeichnet wird</b> . <br><br>  Überschriebene Methoden (Überschreiben) werden zur Laufzeit aufgelöst, da der Compiler nicht weiß, ob das Objekt, das dem Link zugewiesen ist, überschriebene Methoden enthält. <br><br><h3>  Physikalische Sicht </h3><br>  In diesem Abschnitt werden wir versuchen, „physische“ Beweise für alle oben genannten Aussagen zu finden.  Schauen Sie sich dazu den Bytecode an, den Sie durch Ausführen von <code>javap -verbose OverridingInternalExample</code> .  Mit <code>-verbose</code> Parameter <code>-verbose</code> wir einen intuitiveren Bytecode, der unserem Java-Programm entspricht. <br><br>  Der obige Befehl zeigt zwei Abschnitte des Bytecodes. <br><br>  <b>1. Der Pool von Konstanten</b> .  Es enthält fast alles, was zum Ausführen des Programms erforderlich ist.  Zum Beispiel Methodenreferenzen ( <code>#Methodref</code> ), Klassen ( <code>#Class</code> ), String-Literale ( <code>#String</code> ). <br><br><img src="https://habrastorage.org/webt/k7/nf/x7/k7nfx7oupro69w7nazss_icos9o.png"><br><br>  <b>2. Der Bytecode des Programms.</b>  Ausführbare Bytecode-Anweisungen. <br><br><img src="https://habrastorage.org/webt/6c/1y/5g/6c1y5gzslpkiodz_w7b7zh10yzw.png"><br><br><h3>  Warum das Überladen von Methoden als statische Bindung bezeichnet wird </h3><br>  Im obigen Beispiel glaubt der Compiler, dass die Methode <code>humanMammal.speak()</code> von der <code>Mammal</code> Klasse aufgerufen wird, obwohl sie zur Laufzeit von dem Objekt aufgerufen wird, auf das in <code>humanMammal</code> - es wird ein Objekt der <code>Human</code> Klasse sein. <br><br>  Wenn wir unseren Code und das Ergebnis von <code>javap</code> , sehen wir, dass unterschiedliche Bytecodes verwendet werden, um die Methoden <code>humanMammal.speak()</code> , <code>human.speak()</code> und <code>human.speak("Hindi")</code> , da der Compiler sie anhand der Klassenreferenz unterscheiden kann . <br><br>  Somit kann der Compiler im Falle einer Methodenüberladung zur Kompilierungszeit Bytecode-Anweisungen und Methodenadressen identifizieren.  Aus diesem Grund wird dies als <b>statische Verknüpfung oder Polymorphismus zur Kompilierungszeit bezeichnet.</b> <br><br><h3>  Warum das Überschreiben von Methoden als dynamische Bindung bezeichnet wird </h3><br>  Um die <code>anyMammal.speak()</code> und <code>humanMammal.speak()</code> , ist der Bytecode derselbe, da aus Sicht des Compilers beide Methoden für die <code>Mammal</code> Klasse aufgerufen werden: <br><br><pre> <code class="plaintext hljs">invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V</code> </pre> <br>  Die Frage ist nun, ob beide Aufrufe denselben Bytecode haben. Woher weiß die JVM, welche Methode aufgerufen werden soll? <br><br>  Die Antwort ist im Bytecode selbst und in der Anweisung <code>invokevirtual</code> versteckt.  Gemäß der JVM-Spezifikation <i>(Anmerkung des Übersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verweis auf JVM-Spezifikation 2.11.8</a> )</i> : <br><blockquote>  Die Anweisung invokevirtual ruft die Instanzmethode durch Versenden des (virtuellen) Objekttyps auf.  Dies ist der normale Versand von Methoden in der Programmiersprache Java. </blockquote>  Die JVM verwendet die <code>invokevirtual</code> , um Java-Methoden aufzurufen, die den virtuellen C ++ - Methoden entsprechen.  In C ++ muss die Methode als virtuell deklariert werden, um eine Methode in einer anderen Klasse zu überschreiben.  In Java sind standardmäßig alle Methoden virtuell (mit Ausnahme der endgültigen und statischen Methoden), sodass wir in der untergeordneten Klasse jede Methode überschreiben können. <br><br>  Die Anweisung <code>invokevirtual</code> nimmt einen Zeiger auf die <code>invokevirtual</code> Methode (# 4 ist der Index im Konstantenpool). <br><br><pre> <code class="java hljs">invokevirtual #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">// Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V</span></span></code> </pre> <br>  Referenz Nr. 4 bezieht sich jedoch weiter auf eine andere Methode und Klasse. <br><br><pre> <code class="java hljs">#<span class="hljs-number"><span class="hljs-number">4</span></span> = Methodref #<span class="hljs-number"><span class="hljs-number">2</span></span>.#<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-comment"><span class="hljs-comment">// org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V #2 = Class #25 // org/programming/mitra/exercises/OverridingInternalExample$Mammal #25 = Utf8 org/programming/mitra/exercises/OverridingInternalExample$Mammal #27 = NameAndType #35:#17 // speak:()V #35 = Utf8 speak #17 = Utf8 ()V</span></span></code> </pre> <br>  Alle diese Links werden zusammen verwendet, um einen Verweis auf die Methode und die Klasse zu erhalten, in der sich die gewünschte Methode befindet.  Dies wird auch in der JVM-Spezifikation erwähnt ( <i>Anmerkung des Übersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verweis auf JVM-Spezifikation 2.7</a></i> ): <br><blockquote>  Die Java Virtual Machine erfordert keine spezifische interne Struktur von Objekten. </blockquote><blockquote>  In einigen Java Virtual Machine-Implementierungen von Oracle ist ein Verweis auf eine Instanz einer Klasse ein Verweis auf einen Handler, der selbst aus zwei Verknüpfungen besteht: Einer verweist auf eine Tabelle mit Objektmethoden und ein Zeiger auf ein Klassenobjekt, das den Typ des Objekts darstellt, und der andere auf den Bereich Daten auf dem Heap, die Objektdaten enthalten. </blockquote><br>  Dies bedeutet, dass jede Referenzvariable zwei versteckte Zeiger enthält: <br><br><ol><li>  Ein Zeiger auf eine Tabelle, die die Methoden des Objekts enthält, und ein Zeiger auf das <code>Class</code> Objekt, z. B. <code>[speak(), speak(String) Class object]</code> </li><li>  Ein Zeiger auf den Speicher auf dem Heap, der Objektdaten zugewiesen ist, z. B. Objektfeldwerte. </li></ol><br>  Aber wieder stellt sich die Frage: Wie funktioniert <code>invokevirtual</code> damit?  Leider kann niemand diese Frage beantworten, da alles von der Implementierung der JVM abhängt und von JVM zu JVM variiert. <br><br>  Aus den obigen Überlegungen können wir schließen, dass ein Verweis auf ein Objekt indirekt einen Link / Zeiger auf eine Tabelle enthält, die alle Verweise auf Methoden dieses Objekts enthält.  Java hat dieses Konzept von C ++ übernommen.  Diese Tabelle ist unter verschiedenen Namen bekannt, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VMT (Virtual Method Table), Virtual Function Table (vftable), Virtual Table (vtable) und Dispatch Table</a> . <br><br>  Wir können nicht sicher sein, wie vtable in Java implementiert ist, da dies von der spezifischen JVM abhängt.  Wir können jedoch erwarten, dass die Strategie ungefähr dieselbe ist wie in C ++, wo vtable eine Array-ähnliche Struktur ist, die Methodennamen und deren Referenzen enthält.  Immer wenn die JVM versucht, eine virtuelle Methode auszuführen, fordert sie ihre Adresse in der vtable an. <br><br>  Für jede Klasse gibt es nur eine vtable. Dies bedeutet, dass die Tabelle eindeutig und für alle Objekte der Klasse gleich ist, ähnlich wie das Class-Objekt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassenobjekte</a> werden in den Artikeln ausführlicher erläutert. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum eine äußere Java-Klasse nicht statisch sein kann</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">warum Java eine rein objektorientierte Sprache ist oder warum nicht</a> . <br><br>  Daher gibt es nur eine vtable für die <code>Object</code> Klasse, die alle 11 Methoden (sofern <code>registerNatives</code> nicht berücksichtigt werden) und Links enthält, die ihrer Implementierung entsprechen. <br><br><img src="https://habrastorage.org/webt/n1/ky/hy/n1kyhyiy2gta8yqfnkns5z_8swy.png"><br><br>  Wenn die JVM die Mammal-Klasse in den Speicher lädt, erstellt sie ein <code>Class</code> Objekt dafür und erstellt eine vtable, die alle Methoden aus der vtable der <code>Object</code> Klasse mit denselben Referenzen enthält (da <code>Mammal</code> die Methoden aus <code>Object</code> nicht überschreibt) und fügt einen neuen Eintrag für die <code>speak()</code> -Methode hinzu. <br><br><img src="https://habrastorage.org/webt/ab/wb/pg/abwbpgthcjjnzyjhzbpvi-kpzsw.png"><br><br>  Dann kommt die Klasse der <code>Human</code> Klasse herein, und die JVM kopiert alle Einträge aus der vtable der <code>Mammal</code> Klasse in die vtable der <code>Human</code> Klasse und fügt einen neuen Eintrag für die überladene Version von <code>speak(String)</code> . <br><br>  Die JVM weiß, dass die <code>Human</code> Klasse zwei Methoden überschrieben hat: <code>toString()</code> von <code>Object</code> und <code>speak()</code> von <code>Mammal</code> .  Anstatt für diese Methoden neue Datensätze mit aktualisierten Links zu erstellen, ändert die JVM die Links zu vorhandenen Methoden in demselben Index, in dem sie zuvor vorhanden waren, und behält dieselben Methodennamen bei. <br><br><img src="https://habrastorage.org/webt/qv/qj/zy/qvqjzyrkzsg26tvb3kxqfr56ooe.png"><br><br>  Die Anweisung <code>invokevirtual</code> veranlasst die JVM, den Wert im Verweis auf Methode 4 nicht als Adresse, sondern als Namen der Methode zu verarbeiten, nach der in der vtable für das aktuelle Objekt gesucht werden soll. <br>  Ich hoffe, es ist jetzt klarer, wie die JVM den konstanten Pool und die virtuelle Methodentabelle verwendet, um zu bestimmen, welche Methode aufgerufen werden soll. <br>  Sie finden den Beispielcode im <a href="">Github-</a> Repository. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467197/">https://habr.com/ru/post/de467197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467185/index.html">Gefälle bergab</a></li>
<li><a href="../de467187/index.html">Erstellen Sie die neueste Technologiebibliothek</a></li>
<li><a href="../de467189/index.html">Temperaturmessung</a></li>
<li><a href="../de467191/index.html">Wie wir Vivaldi für Android gemacht haben</a></li>
<li><a href="../de467193/index.html">Bergmannsvirus mit "Heaven's Gate"</a></li>
<li><a href="../de467199/index.html">Tom Hunter Tagebuch: Der Hund der Baskervilles</a></li>
<li><a href="../de467201/index.html">CacheBrowser-Experiment: Umgehen einer chinesischen Firewall ohne Proxy mithilfe von Content-Caching</a></li>
<li><a href="../de467203/index.html">Nur Teilung oder wie man eine mathematische Theorie erstellt und 400.000 Dollar damit verdient. Serie zwei, vorletzte</a></li>
<li><a href="../de467205/index.html">Wir entwickeln eine Anwendung, die Daten an andere Anwendungen sendet (Ökosystemanwendung)</a></li>
<li><a href="../de467207/index.html">Fünf vielversprechende Programmiersprachen mit einer glänzenden Zukunft (3 Jahre später)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>