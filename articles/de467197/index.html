<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüîß üîÆ üï¥üèΩ Wie Polymorphismus in der JVM implementiert wird üí™üèø üèø üßôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine √úbersetzung dieses Artikels wurde speziell f√ºr Studenten des Java Developer- Kurses erstellt . 




 In meinem vorherigen Artikel Alles √ºber das ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Polymorphismus in der JVM implementiert wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467197/">  <i>Eine √úbersetzung dieses Artikels wurde speziell f√ºr Studenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Java Developer-</a> Kurses erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a></i> <br><br><img src="https://habrastorage.org/webt/pv/d6/a7/pvd6a7xzq3zopckoatmhx0ohjn8.png"><br><br><hr><br>  In meinem vorherigen Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alles √ºber das √úberladen von Methoden im Vergleich zum √úberschreiben von Methoden</a> haben wir uns mit den Regeln und Unterschieden beim √úberladen und √úberschreiben von Methoden befasst.  In diesem Artikel werden wir sehen, wie das √úberladen und √úberschreiben von Methoden in der JVM behandelt wird. <a name="habracut"></a><br><br>  Nehmen Sie zum Beispiel die Klassen aus dem vorherigen Artikel: das Eltern- <code>Mammal</code> (S√§ugetier) und das Kind <code>Human</code> (Mensch). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OverridingInternalExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mammal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"ohlllalalalalalaoaoaoa"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mammal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//   speak() public void speak(String language) { if (language.equals("Hindi")) System.out.println("Namaste"); else System.out.println("Hello"); } @Override public String toString() { return "Human Class"; } } //           public static void main(String[] args) { Mammal anyMammal = new Mammal(); anyMammal.speak(); // Output - ohlllalalalalalaoaoaoa // 10: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V Mammal humanMammal = new Human(); humanMammal.speak(); // Output - Hello // 23: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V Human human = new Human(); human.speak(); // Output - Hello // 36: invokevirtual #7 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:()V human.speak("Hindi"); // Output - Namaste // 42: invokevirtual #9 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:(Ljava/lang/String;)V } }</span></span></code> </pre> <br>  Wir k√∂nnen die Frage des Polymorphismus von zwei Seiten betrachten: von der ‚Äûlogischen‚Äú und der ‚Äûphysischen‚Äú.  Schauen wir uns zun√§chst die logische Seite des Problems an. <br><br><h3>  Logische Sichtweise </h3><br>  Aus logischer Sicht wird die aufgerufene Methode in der Kompilierungsphase als mit der Art der Referenz verbunden angesehen.  Zur Laufzeit wird jedoch die Methode des referenzierten Objekts aufgerufen. <br><br>  Zum Beispiel in der Zeile <code>humanMammal.speak();</code>  Der Compiler glaubt, dass <code>Mammal.speak()</code> aufgerufen wird, da <code>humanMammal</code> als <code>Mammal</code> <code>humanMammal</code> .  <code>humanMammal</code> Laufzeit wei√ü die JVM jedoch, dass <code>humanMammal</code> ein <code>Human</code> Objekt enth√§lt, und <code>Human.speak()</code> tats√§chlich die <code>Human.speak()</code> -Methode auf. <br><br>  Es ist alles ziemlich einfach, solange wir auf einer konzeptionellen Ebene bleiben.  Aber wie geht die JVM intern damit um?  Wie berechnet die JVM, welche Methode aufgerufen werden soll? <br><br>  Wir wissen auch, dass √ºberladene Methoden nicht als polymorph bezeichnet werden und zur Kompilierungszeit aufgel√∂st werden.  Obwohl manchmal das √úberladen von Methoden als <b>Polymorphismus zur Kompilierungszeit oder fr√ºhe / statische Bindung bezeichnet wird</b> . <br><br>  √úberschriebene Methoden (√úberschreiben) werden zur Laufzeit aufgel√∂st, da der Compiler nicht wei√ü, ob das Objekt, das dem Link zugewiesen ist, √ºberschriebene Methoden enth√§lt. <br><br><h3>  Physikalische Sicht </h3><br>  In diesem Abschnitt werden wir versuchen, ‚Äûphysische‚Äú Beweise f√ºr alle oben genannten Aussagen zu finden.  Schauen Sie sich dazu den Bytecode an, den Sie durch Ausf√ºhren von <code>javap -verbose OverridingInternalExample</code> .  Mit <code>-verbose</code> Parameter <code>-verbose</code> wir einen intuitiveren Bytecode, der unserem Java-Programm entspricht. <br><br>  Der obige Befehl zeigt zwei Abschnitte des Bytecodes. <br><br>  <b>1. Der Pool von Konstanten</b> .  Es enth√§lt fast alles, was zum Ausf√ºhren des Programms erforderlich ist.  Zum Beispiel Methodenreferenzen ( <code>#Methodref</code> ), Klassen ( <code>#Class</code> ), String-Literale ( <code>#String</code> ). <br><br><img src="https://habrastorage.org/webt/k7/nf/x7/k7nfx7oupro69w7nazss_icos9o.png"><br><br>  <b>2. Der Bytecode des Programms.</b>  Ausf√ºhrbare Bytecode-Anweisungen. <br><br><img src="https://habrastorage.org/webt/6c/1y/5g/6c1y5gzslpkiodz_w7b7zh10yzw.png"><br><br><h3>  Warum das √úberladen von Methoden als statische Bindung bezeichnet wird </h3><br>  Im obigen Beispiel glaubt der Compiler, dass die Methode <code>humanMammal.speak()</code> von der <code>Mammal</code> Klasse aufgerufen wird, obwohl sie zur Laufzeit von dem Objekt aufgerufen wird, auf das in <code>humanMammal</code> - es wird ein Objekt der <code>Human</code> Klasse sein. <br><br>  Wenn wir unseren Code und das Ergebnis von <code>javap</code> , sehen wir, dass unterschiedliche Bytecodes verwendet werden, um die Methoden <code>humanMammal.speak()</code> , <code>human.speak()</code> und <code>human.speak("Hindi")</code> , da der Compiler sie anhand der Klassenreferenz unterscheiden kann . <br><br>  Somit kann der Compiler im Falle einer Methoden√ºberladung zur Kompilierungszeit Bytecode-Anweisungen und Methodenadressen identifizieren.  Aus diesem Grund wird dies als <b>statische Verkn√ºpfung oder Polymorphismus zur Kompilierungszeit bezeichnet.</b> <br><br><h3>  Warum das √úberschreiben von Methoden als dynamische Bindung bezeichnet wird </h3><br>  Um die <code>anyMammal.speak()</code> und <code>humanMammal.speak()</code> , ist der Bytecode derselbe, da aus Sicht des Compilers beide Methoden f√ºr die <code>Mammal</code> Klasse aufgerufen werden: <br><br><pre> <code class="plaintext hljs">invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V</code> </pre> <br>  Die Frage ist nun, ob beide Aufrufe denselben Bytecode haben. Woher wei√ü die JVM, welche Methode aufgerufen werden soll? <br><br>  Die Antwort ist im Bytecode selbst und in der Anweisung <code>invokevirtual</code> versteckt.  Gem√§√ü der JVM-Spezifikation <i>(Anmerkung des √úbersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verweis auf JVM-Spezifikation 2.11.8</a> )</i> : <br><blockquote>  Die Anweisung invokevirtual ruft die Instanzmethode durch Versenden des (virtuellen) Objekttyps auf.  Dies ist der normale Versand von Methoden in der Programmiersprache Java. </blockquote>  Die JVM verwendet die <code>invokevirtual</code> , um Java-Methoden aufzurufen, die den virtuellen C ++ - Methoden entsprechen.  In C ++ muss die Methode als virtuell deklariert werden, um eine Methode in einer anderen Klasse zu √ºberschreiben.  In Java sind standardm√§√üig alle Methoden virtuell (mit Ausnahme der endg√ºltigen und statischen Methoden), sodass wir in der untergeordneten Klasse jede Methode √ºberschreiben k√∂nnen. <br><br>  Die Anweisung <code>invokevirtual</code> nimmt einen Zeiger auf die <code>invokevirtual</code> Methode (# 4 ist der Index im Konstantenpool). <br><br><pre> <code class="java hljs">invokevirtual #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">// Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V</span></span></code> </pre> <br>  Referenz Nr. 4 bezieht sich jedoch weiter auf eine andere Methode und Klasse. <br><br><pre> <code class="java hljs">#<span class="hljs-number"><span class="hljs-number">4</span></span> = Methodref #<span class="hljs-number"><span class="hljs-number">2</span></span>.#<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-comment"><span class="hljs-comment">// org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V #2 = Class #25 // org/programming/mitra/exercises/OverridingInternalExample$Mammal #25 = Utf8 org/programming/mitra/exercises/OverridingInternalExample$Mammal #27 = NameAndType #35:#17 // speak:()V #35 = Utf8 speak #17 = Utf8 ()V</span></span></code> </pre> <br>  Alle diese Links werden zusammen verwendet, um einen Verweis auf die Methode und die Klasse zu erhalten, in der sich die gew√ºnschte Methode befindet.  Dies wird auch in der JVM-Spezifikation erw√§hnt ( <i>Anmerkung des √úbersetzers: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verweis auf JVM-Spezifikation 2.7</a></i> ): <br><blockquote>  Die Java Virtual Machine erfordert keine spezifische interne Struktur von Objekten. </blockquote><blockquote>  In einigen Java Virtual Machine-Implementierungen von Oracle ist ein Verweis auf eine Instanz einer Klasse ein Verweis auf einen Handler, der selbst aus zwei Verkn√ºpfungen besteht: Einer verweist auf eine Tabelle mit Objektmethoden und ein Zeiger auf ein Klassenobjekt, das den Typ des Objekts darstellt, und der andere auf den Bereich Daten auf dem Heap, die Objektdaten enthalten. </blockquote><br>  Dies bedeutet, dass jede Referenzvariable zwei versteckte Zeiger enth√§lt: <br><br><ol><li>  Ein Zeiger auf eine Tabelle, die die Methoden des Objekts enth√§lt, und ein Zeiger auf das <code>Class</code> Objekt, z. B. <code>[speak(), speak(String) Class object]</code> </li><li>  Ein Zeiger auf den Speicher auf dem Heap, der Objektdaten zugewiesen ist, z. B. Objektfeldwerte. </li></ol><br>  Aber wieder stellt sich die Frage: Wie funktioniert <code>invokevirtual</code> damit?  Leider kann niemand diese Frage beantworten, da alles von der Implementierung der JVM abh√§ngt und von JVM zu JVM variiert. <br><br>  Aus den obigen √úberlegungen k√∂nnen wir schlie√üen, dass ein Verweis auf ein Objekt indirekt einen Link / Zeiger auf eine Tabelle enth√§lt, die alle Verweise auf Methoden dieses Objekts enth√§lt.  Java hat dieses Konzept von C ++ √ºbernommen.  Diese Tabelle ist unter verschiedenen Namen bekannt, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VMT (Virtual Method Table), Virtual Function Table (vftable), Virtual Table (vtable) und Dispatch Table</a> . <br><br>  Wir k√∂nnen nicht sicher sein, wie vtable in Java implementiert ist, da dies von der spezifischen JVM abh√§ngt.  Wir k√∂nnen jedoch erwarten, dass die Strategie ungef√§hr dieselbe ist wie in C ++, wo vtable eine Array-√§hnliche Struktur ist, die Methodennamen und deren Referenzen enth√§lt.  Immer wenn die JVM versucht, eine virtuelle Methode auszuf√ºhren, fordert sie ihre Adresse in der vtable an. <br><br>  F√ºr jede Klasse gibt es nur eine vtable. Dies bedeutet, dass die Tabelle eindeutig und f√ºr alle Objekte der Klasse gleich ist, √§hnlich wie das Class-Objekt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassenobjekte</a> werden in den Artikeln ausf√ºhrlicher erl√§utert. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum eine √§u√üere Java-Klasse nicht statisch sein kann</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">warum Java eine rein objektorientierte Sprache ist oder warum nicht</a> . <br><br>  Daher gibt es nur eine vtable f√ºr die <code>Object</code> Klasse, die alle 11 Methoden (sofern <code>registerNatives</code> nicht ber√ºcksichtigt werden) und Links enth√§lt, die ihrer Implementierung entsprechen. <br><br><img src="https://habrastorage.org/webt/n1/ky/hy/n1kyhyiy2gta8yqfnkns5z_8swy.png"><br><br>  Wenn die JVM die Mammal-Klasse in den Speicher l√§dt, erstellt sie ein <code>Class</code> Objekt daf√ºr und erstellt eine vtable, die alle Methoden aus der vtable der <code>Object</code> Klasse mit denselben Referenzen enth√§lt (da <code>Mammal</code> die Methoden aus <code>Object</code> nicht √ºberschreibt) und f√ºgt einen neuen Eintrag f√ºr die <code>speak()</code> -Methode hinzu. <br><br><img src="https://habrastorage.org/webt/ab/wb/pg/abwbpgthcjjnzyjhzbpvi-kpzsw.png"><br><br>  Dann kommt die Klasse der <code>Human</code> Klasse herein, und die JVM kopiert alle Eintr√§ge aus der vtable der <code>Mammal</code> Klasse in die vtable der <code>Human</code> Klasse und f√ºgt einen neuen Eintrag f√ºr die √ºberladene Version von <code>speak(String)</code> . <br><br>  Die JVM wei√ü, dass die <code>Human</code> Klasse zwei Methoden √ºberschrieben hat: <code>toString()</code> von <code>Object</code> und <code>speak()</code> von <code>Mammal</code> .  Anstatt f√ºr diese Methoden neue Datens√§tze mit aktualisierten Links zu erstellen, √§ndert die JVM die Links zu vorhandenen Methoden in demselben Index, in dem sie zuvor vorhanden waren, und beh√§lt dieselben Methodennamen bei. <br><br><img src="https://habrastorage.org/webt/qv/qj/zy/qvqjzyrkzsg26tvb3kxqfr56ooe.png"><br><br>  Die Anweisung <code>invokevirtual</code> veranlasst die JVM, den Wert im Verweis auf Methode 4 nicht als Adresse, sondern als Namen der Methode zu verarbeiten, nach der in der vtable f√ºr das aktuelle Objekt gesucht werden soll. <br>  Ich hoffe, es ist jetzt klarer, wie die JVM den konstanten Pool und die virtuelle Methodentabelle verwendet, um zu bestimmen, welche Methode aufgerufen werden soll. <br>  Sie finden den Beispielcode im <a href="">Github-</a> Repository. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467197/">https://habr.com/ru/post/de467197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467185/index.html">Gef√§lle bergab</a></li>
<li><a href="../de467187/index.html">Erstellen Sie die neueste Technologiebibliothek</a></li>
<li><a href="../de467189/index.html">Temperaturmessung</a></li>
<li><a href="../de467191/index.html">Wie wir Vivaldi f√ºr Android gemacht haben</a></li>
<li><a href="../de467193/index.html">Bergmannsvirus mit "Heaven's Gate"</a></li>
<li><a href="../de467199/index.html">Tom Hunter Tagebuch: Der Hund der Baskervilles</a></li>
<li><a href="../de467201/index.html">CacheBrowser-Experiment: Umgehen einer chinesischen Firewall ohne Proxy mithilfe von Content-Caching</a></li>
<li><a href="../de467203/index.html">Nur Teilung oder wie man eine mathematische Theorie erstellt und 400.000 Dollar damit verdient. Serie zwei, vorletzte</a></li>
<li><a href="../de467205/index.html">Wir entwickeln eine Anwendung, die Daten an andere Anwendungen sendet (√ñkosystemanwendung)</a></li>
<li><a href="../de467207/index.html">F√ºnf vielversprechende Programmiersprachen mit einer gl√§nzenden Zukunft (3 Jahre sp√§ter)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>