<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔓 💃🏽 ✝️ Meine Lieblingsbeispiele für funktionale Programmierung in Kotlin 🏮 👈🏽 💛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der großartigen Eigenschaften von Kotlin ist, dass es funktionale Programmierung unterstützt. Lassen Sie uns einen Blick darauf werfen und einige...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine Lieblingsbeispiele für funktionale Programmierung in Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420299/"><p>  Eine der großartigen Eigenschaften von Kotlin ist, dass es funktionale Programmierung unterstützt.  Lassen Sie uns einen Blick darauf werfen und einige einfache, aber ausdrucksstarke Funktionen diskutieren, die in Kotlin geschrieben wurden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/8bd/347/1f28bd3472067f00fb324fb500176cb0.png" alt="Meine Lieblingsbeispiele für funktionale Programmierung in Kotlin"></p><a name="habracut"></a><br><h3 id="rabota-s-kollekciyami">  Arbeiten Sie mit Sammlungen </h3><br><p> Kotlin unterstützt die bequeme Arbeit mit Sammlungen.  Es gibt viele verschiedene Funktionen.  Angenommen, wir schaffen ein System für eine Universität.  Wir müssen die besten Studenten finden, die ein Stipendium verdienen.  Wir haben das folgende <code>Student</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surname: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> passing: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> averageGrade: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> )</code> </pre> <br><p>  Jetzt können wir die folgende Funktion aufrufen, um eine Liste der zehn besten Schüler zu erhalten, die alle Kriterien erfüllen: </p><br><pre> <code class="hljs pgsql">students.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { it.<span class="hljs-keyword"><span class="hljs-keyword">passing</span></span> &amp;&amp; it.averageGrade &gt; <span class="hljs-number"><span class="hljs-number">4.0</span></span> } // <span class="hljs-number"><span class="hljs-number">1</span></span> .sortedBy { it.averageGrade } // <span class="hljs-number"><span class="hljs-number">2</span></span> .take(<span class="hljs-number"><span class="hljs-number">10</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> .sortedWith(compareBy({ it.surname }, { it.name })) // <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><ul><li>  Wir lassen nur Studenten, die die Prüfung bestanden haben, deren durchschnittliche Punktzahl mehr als 4,0 beträgt. </li><li>  Sortieren Sie sie nach der durchschnittlichen Punktzahl. </li><li>  Wir verlassen die ersten zehn Schüler. </li><li>  Sortieren Sie sie alphabetisch.  Der Komparator vergleicht zuerst die Nachnamen, und wenn sie gleich sind, vergleicht er die Namen. </li></ul><br><p>  Was ist, wenn wir anstelle der alphabetischen Reihenfolge die ursprüngliche Reihenfolge der Schüler beibehalten müssen?  Wir können dies mithilfe von Indizes tun: </p><br><pre> <code class="hljs erlang-repl">students.filter { it.passing &amp;&amp; it.averageGrade &gt; <span class="hljs-number"><span class="hljs-number">4.0</span></span> } .withIndex() // <span class="hljs-number"><span class="hljs-number">1</span></span> .sortedBy { (i, s) -&gt; s.averageGrade } // <span class="hljs-number"><span class="hljs-number">2</span></span> .take(<span class="hljs-number"><span class="hljs-number">10</span></span>) .sortedBy { (i, s) -&gt; i } // <span class="hljs-number"><span class="hljs-number">3</span></span> .map { (i, s) -&gt; s } // <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><ul><li>  Binden Sie den aktuellen Iterationsindex an jedes Element. </li><li>  Sortieren Sie nach der durchschnittlichen Punktzahl und lassen Sie die ersten zehn Schüler. </li><li>  Nochmals sortieren, aber jetzt nach Index. </li><li>  Wir löschen Indizes und lassen nur Studenten. </li></ul><br><p>  Dieses Beispiel zeigt, wie einfach und intuitiv die Arbeit mit Sammlungen in Kotlin ist. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/288/6f3/3a6/2886f33a698851f73a1e3003367e5f56.jpg" alt="Arbeiten Sie mit Sammlungen in Kotlin"></p><br><h3 id="supermnozhestvo-buleanhttpsruwikipediaorgwikid091d183d0bbd0b5d0b0d0bd">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SuperSet (Boolean)</a> </h3><br><p>  Wenn Sie an einer Universität Algebra studiert haben, können Sie sich daran erinnern, was eine Obermenge ist.  Für jede Menge ist ihre Obermenge die Menge aller ihrer Teilmengen, einschließlich der ursprünglichen Menge selbst und der leeren Menge.  Zum Beispiel, wenn wir den folgenden Satz haben: </p><br><p>  {1,2,3} </p><br><p>  Das ist seine Obermenge: </p><br><p>  {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} </p><br><p>  In der Algebra ist eine solche Funktion sehr nützlich.  Wie setzen wir es um? </p><br><p>  Wenn Sie sich selbst herausfordern möchten, hören Sie sofort auf zu lesen und versuchen Sie, dieses Problem selbst zu lösen. </p><br><p>  Beginnen wir unsere Analyse mit einer einfachen Beobachtung.  Wenn wir ein Element der Menge nehmen (zum Beispiel 1), hat die Supermenge eine gleiche Anzahl von Mengen mit diesem Element ({1}, {1,2}, {1,3}, {1,2,3}) und ohne es ({}, {2}, {3}, {2,3}). </p><br><p>  Beachten Sie, dass die zweite Menge eine Supermenge ({2,3}) ist und die erste eine Supermenge ({2,3}) mit unserem hinzugefügten Element (1) zu jeder Menge.  Somit können wir die Obermenge berechnen, indem wir das erste Element nehmen, die Obermenge für alle anderen berechnen und die Summe des Ergebnisses und des Ergebnisses mit der Hinzufügung des ersten Elements zu jeder Menge zurückgeben: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powerset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">set</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Set&lt;Set&lt;T&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> powersetOfRest = powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.drop(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> powersetOfRest.map { it + first } + powersetOfRest }</code> </pre> <br><p>  Diese Methode funktioniert jedoch nicht.  Das Problem ist ein leerer Satz: <code>first</code> wird ein Fehler ausgegeben, wenn der Satz leer ist.  Hier kommt die Definition einer Obermenge zur Rettung - die Obermenge einer leeren Menge ist eine leere Menge: Powerset ({}) = {{}}.  So sieht der korrigierte Algorithmus aus: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val powersetOfRest = powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) powersetOfRest + powersetOfRest.map { it + <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() } }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/aea/150/ee3/aea150ee316f7800b56220e8dbd10b5f.png" alt="Rekursionsmem"></p><br><p>  Mal sehen, wie es funktioniert.  Angenommen, wir müssen das Powerset ({1,2,3}) berechnen.  Der Algorithmus funktioniert wie folgt: </p><br><p>  Powerset ({1,2,3}) = Powerset ({2,3}) + Powerset ({2,3}). map {it + 1} </p><br><p>  Powerset ({2,3}) = Powerset ({3}) + Powerset ({3}). map {it + 2} </p><br><p>  Powerset ({3}) = Powerset ({}) + Powerset ({}). map {it + 3} </p><br><p>  Powerset ({}) = {{}} </p><br><p>  Powerset ({3}) = {{}, {3}} </p><br><p>  Powerset ({2,3}) = {{}, {3}} + {{2}, {2, 3}} = {{}, {2}, {3}, {2, 3}} </p><br><p>  Powerset ({1,2,3}) = {{}, {2}, {3}, {2, 3}} + {{1}, {1, 2}, {1, 3}, {1, 2, 3}} = {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} </p><br><p>  Aber wir können unsere Funktion noch weiter verbessern.  Verwenden wir die let-Funktion, um die Notation kürzer und kompakter zu machen: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> powerset(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .let { it+ it.map { it + <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.first() }</code> </pre> <br><p>  Wir können diese Funktion auch als Erweiterungsfunktion für <code>Collection</code> , sodass wir diese Funktion so verwenden können, als wäre es die <code>Set</code> ( <code>setOf(1,2,3).powerset()</code> <code>powerset(setOf(1,2,3))</code> anstelle des <code>powerset(setOf(1,2,3))</code> ): </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; Collection&lt;T&gt;.powerset(): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) .powerset() .let { it+ it.map { it + first() }</code> </pre> <br><p>  Wir können auch die negativen Auswirkungen der erstellten Rekursion reduzieren.  In der obigen Implementierung wächst der Status der Obermenge mit jeder Iteration (mit jedem rekursiven Aufruf), da der Status der vorherigen Iteration im Speicher gespeichert werden muss. </p><br><p>  Stattdessen könnten wir einen regulären Loop- oder <code>tailrec</code> Funktionsmodifikator verwenden.  Wir werden die zweite Option verwenden, um die Lesbarkeit der Funktion zu gewährleisten.  Der Modifikator <code>tailrec</code> erlaubt nur einen rekursiven Aufruf in der zuletzt ausgeführten Funktionszeile.  So können wir unsere Funktion ändern, um sie effizienter zu nutzen: </p><br><pre> <code class="hljs pgsql">fun &lt;T&gt; Collection&lt;T&gt;.powerset(): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = powerset(this, <span class="hljs-keyword"><span class="hljs-keyword">setOf</span></span>(emptySet())) private tailrec fun &lt;T&gt; powerset(left: Collection&lt;T&gt;, acc: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt;): <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;T&gt;&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.isEmpty()) acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> powerset(left.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), acc + acc.map { it + left.first() })</code> </pre> <br><p>  Diese Implementierung ist Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KotlinDiscreteMathToolkit-</a> Bibliothek, die viele andere Funktionen definiert, die in der diskreten Mathematik verwendet werden. </p><br><h3 id="bystraya-sortirovka-quicksorthttpsruwikipediaorgwikid091d18bd181d182d180d0b0d18f_d181d0bed180d182d0b8d180d0bed0b2d0bad0b0">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quicksort</a> </h3><br><p>  Zeit für das interessanteste Beispiel.  Sie werden sehen, wie ein komplexes Problem mithilfe der Stil- und Funktionsprogrammierwerkzeuge vereinfacht und lesbar gemacht werden kann. </p><br><p>  Wir implementieren einen schnellen Sortieralgorithmus.  Der Algorithmus ist einfach: Wir wählen ein Element aus (Pivot (russischer <em>Balken</em> )) und verteilen alle anderen Elemente auf zwei Listen: eine Liste mit Elementen, die größer als der Balken und kleiner sind.  Dann sortieren wir diese Subarrays rekursiv.  Schließlich kombinieren wir eine sortierte Liste kleinerer Elemente, einen Balken und eine sortierte Liste größerer Elemente.  Nehmen Sie zur Vereinfachung das erste Element als Balken.  Hier ist die vollständige Implementierung: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span></span></span><span class="hljs-function">&gt; List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pivot = first() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (smaller, greater) = drop(<span class="hljs-number"><span class="hljs-number">1</span></span>).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } <span class="hljs-comment"><span class="hljs-comment">// Usage listOf(2,5,1).quickSort() // [1,2,5]</span></span></code> </pre> <br><p>  Sieht wunderschön aus, oder?  Das ist das Schöne an der funktionalen Programmierung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/272/390/e2b/272390e2bd0960c5c5c9bf1dd42fa5e9.jpg" alt="Funktionsprogrammierung"></p><br><p>  Das erste Problem bei einer solchen Funktion ist ihre Ausführungszeit.  Sie ist völlig unoptimiert.  Aber es ist kurz und leicht zu lesen. </p><br><p>  Wenn Sie eine optimierte Funktion benötigen, können Sie die Funktion aus der Standard-Java-Bibliothek verwenden.  Es basiert auf verschiedenen Algorithmen in Abhängigkeit von bestimmten Bedingungen und ist nativ geschrieben.  Dies sollte viel effizienter sein.  Aber wie viel genau?  Vergleichen wir diese beiden Funktionen.  Lassen Sie uns mehrere verschiedene Arrays mit zufälligen Elementen sortieren und die Laufzeit vergleichen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Random() listOf(<span class="hljs-number"><span class="hljs-number">100_000</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>, <span class="hljs-number"><span class="hljs-number">10_000_000</span></span>) .asSequence() .map { (<span class="hljs-number"><span class="hljs-number">1</span></span>..it).map { r.nextInt(<span class="hljs-number"><span class="hljs-number">1000000000</span></span>) } } .forEach { list: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; -&gt; println(<span class="hljs-string"><span class="hljs-string">"Java stdlib sorting of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${list.size}</span></span></span><span class="hljs-string"> elements took </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${measureTimeMillis { list.sorted() }</span></span></span><span class="hljs-string">}"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"quickSort sorting of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${list.size}</span></span></span><span class="hljs-string"> elements took </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${measureTimeMillis { list.quickSort() }</span></span></span><span class="hljs-string">}"</span></span>) }</code> </pre> <br><p>  Hier sind die Ergebnisse, die wir erhalten haben: </p><br><p>  Die Java-Stdlib-Sortierung von 100000 Elementen dauerte 83 <br>  Die QuickSort-Sortierung von 100000 Elementen dauerte 163 <br>  Die Java-Stdlib-Sortierung von 1.000.000 Elementen dauerte 558 <br>  Die QuickSort-Sortierung von 1.000.000 Elementen dauerte 859 <br>  Die Java-Stdlib-Sortierung von 10.000.000 Elementen dauerte 6182 <br>  Die QuickSort-Sortierung von 10.000.000 Elementen dauerte 12133 </p><br><p>  Wie Sie sehen können, ist die <code>quickSort</code> Funktion fast zweimal langsamer.  Auch für große Listen.  In normalen Fällen beträgt der Unterschied typischerweise 0,1 ms bis 0,2 ms.  Dies erklärt, warum wir in einigen Fällen eine Funktion verwenden können, die etwas weniger optimiert, aber gut lesbar und einfach ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420299/">https://habr.com/ru/post/de420299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420289/index.html">Wie wir die Tabellen in den Smartphone-Bildschirm einpassen und sie als Teil des Design-Systems vereinheitlichen</a></li>
<li><a href="../de420291/index.html">Spectre und Meltdown sind nicht mehr die gefährlichsten Angriffe auf Intel-CPUs. Forscher berichten über Anfälligkeit für Vorboten</a></li>
<li><a href="../de420293/index.html">33 Server mit zwei Einheiten, 13 TB RAM und 0,6 PT verteiltem Speicher - warum ist dies ein Minimum für proaktives UBA?</a></li>
<li><a href="../de420295/index.html">NeoQUEST-2018: der lang erwartete Cold Boot, wissenschaftliche Forschung und Gäste aus Nischni Nowgorod</a></li>
<li><a href="../de420297/index.html">Schritt-für-Schritt-Anleitung zum Wiederherstellen des Zugriffs auf Linux Amazon EC2-Instanzen beim Verlust einer PEM-Datei</a></li>
<li><a href="../de420301/index.html">Indischer Premierminister Narendra Modi: Wir werden die Flagge des Landes 2022 an Bord der Gaganyan ins All schicken</a></li>
<li><a href="../de420303/index.html">Lastausgleich beim Parsen von Sites und Verbinden zusätzlicher Cloud-Ressourcen</a></li>
<li><a href="../de420305/index.html">Wie schreibe ich Programme an der Schnittstelle von mobiler Entwicklung und Algorithmen? Yandex Wettbewerb und Geschichten</a></li>
<li><a href="../de420307/index.html">5 CSS-Tricks, die Sie kennen sollten</a></li>
<li><a href="../de420311/index.html">Wie unsere Intuition uns über die globale Erwärmung täuscht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>