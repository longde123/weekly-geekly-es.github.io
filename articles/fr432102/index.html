<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 ♨️ 🎯 Fonctionnalités JavaScript explicites 🏑 👈🏾 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quand je lis un autre article sur les fonctionnalités peu connues du langage JavaScript et que je fais pipi tranquillement des solutions folles dans l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnalités JavaScript explicites</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432102/"><p><img src="https://habrastorage.org/webt/f_/vy/_s/f_vy_sw3-w-pyxs4zrpqejzpkq4.jpeg" alt="Image"></p><br><p>  Quand je lis un autre article sur les fonctionnalités peu connues du langage <strong>JavaScript</strong> et que je fais pipi tranquillement des solutions folles dans la console du navigateur, je dis souvent dans ma tête que, bien, ce n’est certainement pas le cas sur la prod!?  Après tout, la langue a acquis depuis longtemps une énorme communauté et a une couverture étonnamment large du développement industriel.  Si oui, alors pourquoi oublions-nous souvent sa capacité à être compris par tout le monde et propagent-ils littéralement toutes ces constructions spécifiques et «mémorables»?  <em>Rendez-le évident!</em> </p><a name="habracut"></a><br><h2 id="rassuzhdeniya-na-temu">  Raisonnement sur le sujet </h2><br><p>  <em>Vous pouvez ignorer cette graphomanie.</em> </p><br><p> Si l'on parle de développement industriel, dans la grande majorité des cas, l'exigence de prise en charge d'un code est encore plus importante que la résolution d'une tâche posée par une entreprise.  Pour beaucoup, cela est évident, pour certains - en partie (bien sûr, on trouve également des D'Artagnans rares).  Plus notre code est clair, moins il y a de risque d'arriver sur l'étagère poussiéreuse, et pour nous et nos successeurs de gagner des problèmes avec le système nerveux. </p><br><p>  Ce n'est pas un secret que JavaScript est incroyable dans sa flexibilité, qui est à la fois sa plus grande vertu et une malédiction ennuyeuse.  Le chemin du développeur JavaScript est long et extrêmement intéressant: nous absorbons livre par livre, article par article, et acquérons une expérience unique, mais parfois il est vraiment spécifique à la langue.  La plus large diffusion de la langue et en même temps un nombre important de non-évidences accumulées et nourries contribuent à la formation de deux fronts: ceux qui idolâtrent presque cette langue, et ceux qui la considèrent comme un canard des droits maladroit et chancelant. </p><br><p>  Et tout irait bien, mais souvent les représentants des deux fronts travaillent sur le même projet.  Et l'habituel, toute pratique acceptée est un malentendu (réticence à comprendre et même à ignorer) le code de l'autre.  Et en fait, <em>"j'ai un développeur Java, et ce n'est pas le vôtre!"</em>  .  Les adeptes de Javascript eux-mêmes ajoutent de l'huile sur le feu, en disant <em>"personne ne connaît vraiment JavaScript!"</em>  oui <em>"je peux l'écrire en une seule ligne sur js!"</em>  .  J'avoue que j'abuse moi-même une programmation anormale à loisir ... </p><br><p>  Vous commencez à ressentir ce problème lorsque vous prenez la place d'un marginal et acquérez une certaine expérience de travail avec les gens et leur code des deux côtés des barricades.  La planification et les autres réunions sont plus productives lorsque tous les développeurs se comprennent, non seulement au niveau des secteurs d'activité, mais au moins un peu au niveau de leur mise en œuvre.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facteur de basse</a> notoire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a un</a> impact moindre sur le projet, quand en cas de maladie d'un seul front-end, le reste de l'équipe n'hésite pas à corriger une ligne du fichier <em>.js</em> .  Le processus de partage des connaissances au sein de l'équipe et au-delà devient plus transparent pour tout le monde lorsque tout le monde a une image plus détaillée.  Et bien dans la même veine. </p><br><p>  Je n’invite personne à «faire du plein verre» ou «en forme de T» (comment le dire maintenant?), Mais pourquoi ne levons-nous pas ce rideau un peu même de la communauté JavaScript?  Pour ce faire, il suffit d’apporter un peu de clarté à notre code, en utilisant la flexibilité du langage non pas pour montrer, mais pour être compris. </p><br><h2 id="vzroslenie-i-prinyatie-otvetstvennosti">  Grandir et prendre ses responsabilités </h2><br><p>  Pour sa part, JavaScript a depuis longtemps réalisé son rôle, non pas comme un langage pour l'interactivité des pages Internet et «collant» leurs ressources, mais comme un outil puissant et suffisant pour créer des applications multiplateformes complètes et souvent très évolutives. </p><br><p>  Conçu à l'origine pour les concepteurs de sites Web, ce «langage de programmation le plus mal compris» marche depuis longtemps, malgré sa popularité et sa pertinence croissantes.  Pendant les 13-14 ans précédant l'édition d'ECMAScript 5.1, il est difficile de rappeler des changements importants dans la norme ou de comprendre le vecteur de son développement.  À cette époque, sa communauté a grandement contribué à la formation de l'écosystème du langage: Prototype, jQuery, MooTools, etc.  Après avoir reçu ces commentaires des développeurs, JavaScript a fait un travail important sur les bugs: la version bruyante de 6 ans d'ES6 en 2015 et maintenant les versions annuelles d'ECMAScript, grâce au processus repensé du comité TC39 pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduire de nouvelles fonctionnalités</a> dans la spécification. </p><br><p>  Eh bien, lorsque nos applications sont devenues suffisamment volumineuses, le prototype de modèle OOP pour décrire les types d'utilisateurs n'était plus justifié en raison d'une approche inhabituelle.  Eh bien sérieusement, c'est quoi? </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Call me via new and I will be the constructor ;) */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} Rabbit.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Animal.prototype); Rabbit.prototype.constructor = Rabbit;</code> </pre> <br><p>  Les classes n'apparaissent pas dans la langue, mais leur syntaxe apparaît.  Et le code est devenu accessible aux adeptes du paradigme traditionnel axé sur les classes: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* Obviously, the constructor is here! */</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Maintenant, au stade du candidat à la libération sont les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">domaines privés de la</a> classe.  Il est difficile de croire que, tôt ou tard, nous arrêterons de nous moquer les uns des autres avec un accord sur la dénomination des propriétés privées par des traits de soulignement. </p><br><p>  Dans le même temps, dans un langage où une fonction est un objet de premier ordre et où un événement constant a lieu, c'est assez courant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  Et puis les explications sur <em>ces</em> contextes et la fermeture en JavaScript commencent, ce qui effraie chaque deuxième développeur externe.  Mais dans de nombreux cas, le langage évite les surprises inutiles en utilisant explicitement <em>Function.prototype.bind</em> ou même ainsi: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  Nous avons également des fonctions fléchées, et ce sont vraiment des fonctions, pas des interfaces fonctionnelles (oui, Java?).  Avec un ensemble étendu de méthodes pour travailler avec un tableau, ils aident également à écrire la ligne de paiement déclarative habituelle des calculs: </p><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, x)) .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, x</span></span></span><span class="hljs-function">) =&gt;</span></span> s + x, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  La langue se considère à juste titre comme multi-paradigmatique.  Mais voici un exemple simple sur la signature d'une fonction: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* send ping to host count times */</span></span> }</code> </pre> <br><p>  Tout d'abord, une personne de passage posera une question disant qu'une fonction ne peut probablement prendre que le premier argument, puis dira ce que l'enfer dans ce cas, le <em>compte</em> devient booléen!?  En effet, la fonction a deux utilisations: avec et sans compte.  Mais cela n'est pas du tout évident: vous devez regarder la mise en œuvre et comprendre.  L'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSDoc</a> peut aider, mais ce n'est pas une pratique courante.  Et ici, JavaScript est allé de l'avant, ajoutant la prise en charge non pas pour la surcharge, mais au moins pour les paramètres par défaut: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  En résumé, JavaScript a obtenu un grand nombre de choses familières: les générateurs, les itérateurs, les collections <em>Set</em> et les dictionnaires de <em>cartes</em> , les tableaux typés et même les expressions régulières ont commencé à ravir le support de <em>lookbehind</em> !  La langue fait tout pour convenir à beaucoup de choses et devenir conviviale pour tous. </p><br><h2 id="blagopriyatnyy-put-k-ochevidnomu">  Chemin favorable à l'évidence </h2><br><p>  Le langage lui-même est certainement bien fait, et il est difficile de contester cela!  Mais qu'est-ce qui ne va pas chez nous?  Pourquoi rappelons-nous constamment au monde entier que JavaScript est en quelque sorte différent?  Examinons des exemples de certaines techniques largement utilisées et posons des questions sur leur pertinence. </p><br><h3 id="privedenie-tipov">  Coulée de type </h3><br><p>  Oui, JavaScript a un système de type dynamique et faible et vous permet d'effectuer des opérations sur n'importe quoi, effectuant implicitement des transformations pour nous.  Mais souvent, un casting explicite est encore nécessaire pour nous, et les éléments suivants peuvent être observés: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = !!(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = +(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">''</span></span>+(expr);</code> </pre> <br><p>  Ces astuces sont connues de tous les développeurs JavaScript et sont motivées par le fait qu'ils disent que vous pouvez "rapidement" transformer quelque chose en quelque chose: par vitesse, on entend ici un bref enregistrement.  Peut-il également écrire immédiatement <em>false</em> comme <em>! 1</em> ?  Si le développeur est tellement préoccupé par les caractères imprimables, alors dans son IDE préféré, vous pouvez facilement configurer le <em>modèle en direct</em> nécessaire ou l'auto-complétion.  Et si - pour la taille du code publié, nous le faisons toujours passer par l'obfuscateur, qui sait mieux que le nôtre comment déshumaniser tout cela.  Pourquoi pas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(expr);</code> </pre> <br><p>  Le résultat est le même, clair pour tout le monde. </p><br><p>  Pour les conversions de chaînes, nous devons <em>toString</em> , mais pour les conversions numériques, il existe une valeur intéressante de <em>Of</em> , qui peut également être remplacée.  Un exemple classique qui introduit le "non initié" dans une stupeur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>;</code> </pre> <br><p>  Mais <em>Date</em> possède une méthode <em>getTime</em> connue, utilisons-la: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).getTime();</code> </pre> <br><p>  ou fonction prête à l'emploi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code> </pre> <br><p>  Il n'est absolument pas nécessaire d'exploiter la conversion de type implicite. </p><br><h3 id="logicheskie-operatory">  Opérateurs logiques </h3><br><p>  Une attention particulière est portée aux opérateurs logiques AND (&amp;&amp;) et OR (||), qui ne sont pas tout à fait logiques en JavaScript: ils acceptent et renvoient des valeurs de tout type.  Nous n'entrerons pas dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">détails du fonctionnement du calculateur d'</a> expressions logiques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> nous considérerons des exemples.  L'option présentée précédemment avec la fonction: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Cela pourrait bien ressembler à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// OR arguments.length? if (typeof count == 'undefined') { count = 5; } /* ... */ }</span></span></code> </pre> <br><p>  Cette vérification est plus familière et, dans certains cas, peut aider à éviter les erreurs. </p><br><p>  Au contraire, cela semble sauvage au développeur qui a initialement choisi le chemin JavaScript.  Mais pour la plupart des autres, ce code est vraiment sauvage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; self.self === self &amp;&amp; self) || (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; global.global === global &amp;&amp; global);</code> </pre> <br><p>  Oui, il est compact et oui, les bibliothèques populaires peuvent se le permettre.  Mais s'il vous plaît, n'en abusons pas, car notre code ne sera pas lu par les contributeurs en JavaScript, mais par les développeurs qui résolvent les problèmes commerciaux dans les délais. </p><br><p>  Un tel schéma peut se produire: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> opts == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; opts.count || <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  C'est certainement plus court que l'opérateur ternaire habituel, mais lors de la lecture d'un tel code, la première chose dont vous vous souvenez est les priorités des opérations utilisées. </p><br><p>  Si nous écrivons une fonction de prédicat, que nous transmettons au même <em>Array.prototype.filter</em> , l' <em>encapsulation de</em> la valeur de retour en <em>booléen</em> est un bon ton.  Le but de cette fonction devient immédiatement apparent et il n'y a pas de dissonance parmi les développeurs dont les langages ont les opérateurs logiques "corrects". </p><br><h3 id="pobitovye-operacii">  Opérations au niveau du bit </h3><br><p>  Un exemple courant de vérification de la présence d'un élément dans un tableau ou d'une sous-chaîne dans une chaîne à l'aide de NOT (NOT) au niveau du bit, qui est proposé même par certains didacticiels: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'yes'</span></span>); }</code> </pre> <br><p>  Quel problème cela résout-il?  nous n'avons pas à vérifier <em>! == -1</em> , puisque <em>indexOf</em> obtiendra l'index de l'élément ou -1, et le tilde ajoutera 1 et changera de signe.  Ainsi, l'expression se transformera en "faux" dans le cas de l'index -1. </p><br><p>  Mais la duplication de code peut être évitée d'une autre manière: placer une vérification dans une fonction distincte de certains objets utils, comme tout le monde, que d'utiliser des opérations au niveau du bit à d'autres fins.  Il y a une fonction <a href="">comprend</a> dans lodash pour cela, et cela ne fonctionne pas via <del>  enculer </del>  tilde.  Vous pouvez vous en réjouir, car dans ECMAScript 2016, la méthode <em>Array.prototype.includes</em> a été <em>corrigée</em> (les lignes en ont également une). </p><br><p>  Mais ça y était!  Un autre tilde (avec XOR) est utilisé pour arrondir les nombres, en éliminant la partie décimale: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(~~<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(2.72^0); // 2</span></span></code> </pre> <br><p>  Mais il y a <em>parseInt</em> ou <em>Math.floor</em> à ces fins.  Les opérations au niveau du bit ici sont pratiques pour taper rapidement du code dans la console, car elles ont également une faible priorité sur le reste de l'arithmétique.  Mais lors d'une révision de code, il vaut mieux ne pas le manquer. </p><br><h3 id="sintaksis-i-konstrukcii-yazyka">  Constructions de syntaxe et de langage </h3><br><p>  Certaines pratiques étranges sont difficiles à attribuer à une section particulière.  Par exemple, ils disent que les crochets sont facultatifs lors de l'appel du constructeur et que les deux expressions suivantes sont identiques: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit;</code> </pre> <br><p>  Et ça l'est vraiment!  mais pourquoi créer une question à partir de zéro?  Toutes les langues ne peuvent pas se vanter d'une telle «fonctionnalité».  Et si vous le souhaitez toujours, que ce soit un accord sur l'ensemble du projet.  Sinon, il y a un faux sentiment qu'il y a une différence. </p><br><p>  Une situation similaire avec la déclaration d'un ensemble de variables.  La syntaxe des directives <em>var</em> et <em>let</em> vous permet de déclarer (et de définir) plusieurs variables à la fois, séparées par des virgules: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>, host, retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Quelqu'un utilise des sauts de ligne pour plus de lisibilité, mais dans tous les cas, cette syntaxe n'est pas courante dans les langues populaires.  Personne ne donnera un coup de main et vous demandera si vous écrivez comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> host;</code> </pre> <br><p>  Encore une fois, s'il existe un accord sur le bon style au niveau du projet / de l'entreprise, il n'y a pas de questions.  C'est juste que vous n'avez pas à combiner trop de syntaxe pour votre humeur. </p><br><p>  Il existe des constructions spécifiques dans le langage, comme l'IIFE, qui vous permet d'appeler une fonction immédiatement à l'endroit de sa définition.  L'astuce consiste pour l'analyseur à reconnaître une expression fonctionnelle, pas une déclaration de fonction.  Et cela peut être fait de différentes manières: encapsulation classique entre crochets, via <em>void</em> ou tout autre opérateur unaire.  Et il n'y a rien de merveilleux là-dedans!  Il faut choisir la seule option et ne pas la laisser sans avoir besoin: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }());</code> </pre> <br><p>  Pas besoin d'utiliser des opérateurs pour pirater l'analyseur.  Quand un nouveau venu arrive sur le projet, je veux l'immerger dans la logique métier de l'application, et non le nourrir d'explications d'où tous ces points d'exclamation et vides ont été espionnés.  Il y a aussi une deuxième entrée entre crochets classique et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaire</a> intéressant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Crockford</a> à ce sujet. </p><br><p>  L'apparition de la syntaxe des classes dans ES6 n'était pas accompagnée des modificateurs d'accès habituels.  Et parfois, le développeur veut faire pipi sur les cours et respecter la confidentialité.  Ce qui conduit à ce code Frankenstein: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.getName()}</span></span></span><span class="hljs-string">`</span></span>; } }</code> </pre> <br><p>  En d'autres termes, les accesseurs sont créés pour l'instance dans le constructeur et la confidentialité est obtenue par leur accès aux variables de propriété locales via la fermeture.  Cet exemple ressemble assez à Lacconcino, mais il s'agit d'une approche totalement non évolutive, à moins que vous ne construisiez une solution de framework documentée autour d'elle.  Messieurs, utilisons soit les classes disponibles (et attendons la standardisation des champs privés), soit le module de pattern populaire.  Pour créer une sorte de solution de mixage intermédiaire, c'est une chose pour vous, car les classes cessent d'être des classes et le code est intelligible. </p><br><p>  Pour résumer, il partagera son bon sens avec le guide de style adopté dans le projet, la configuration pour le linter, ou simplement codera des fragments avec des collègues qui contribuent son composant non JavaScript au projet.  La langue offre plusieurs options pour littéralement chaque tâche typique, donc améliorer la compréhension les uns des autres et tomber sous un dénominateur commun n'est pas difficile (ou presque). </p><br><h2 id="zloklyuchenie">  Mésaventure </h2><br><p>  Ce sujet est certainement holistique et il y a beaucoup plus d'exemples, mais le message principal de l'article est que vous ne devez pas abuser de la non-évidence en JavaScript où cela peut être évité.  La nature de la langue est unique: elle vous permet d'écrire des solutions à la fois élégantes et expressives (modérément "pointues"), compréhensibles et accessibles à tous.  Je suis fondamentalement en désaccord avec la sagesse conventionnelle selon laquelle JavaScript "se punissait" ou "enfoui sous une pile de bonnes intentions et d'erreurs".  Parce que maintenant la plupart de l'étrangeté est démontrée non pas par le langage, mais par la culture des développeurs et (non) indifférents qui se forment autour de lui. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432102/">https://habr.com/ru/post/fr432102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432092/index.html">Erreurs désagréables lors de l'écriture des tests unitaires</a></li>
<li><a href="../fr432094/index.html">Hackathon en ligne conjoint d'OpenGift et de la plateforme Blockchain de crédits</a></li>
<li><a href="../fr432096/index.html">Guide CMake complet. Deuxième partie: Build System</a></li>
<li><a href="../fr432098/index.html">Pilotes automatiques dans le transport routier, comment interagir avec les spéciaux. en transport?</a></li>
<li><a href="../fr432100/index.html">Comment nous avons amélioré la conversion de facturation</a></li>
<li><a href="../fr432104/index.html">Récapitulatif des événements informatiques de décembre (première partie)</a></li>
<li><a href="../fr432106/index.html">Food Design Digest, novembre 2018</a></li>
<li><a href="../fr432108/index.html">L'inscription intensive est ouverte pour Kubernetes du 1er au 3 février à Saint-Pétersbourg</a></li>
<li><a href="../fr432110/index.html">Technologies Web pour les concepteurs - Rembourser la dette</a></li>
<li><a href="../fr432112/index.html">Intel XMM 8160 - un modem 5G multimode universel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>