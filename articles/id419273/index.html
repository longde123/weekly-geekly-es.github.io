<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐒 ⛹🏽 👦🏾 Menulis modul kernel Linux: GPIO dengan dukungan IRQ 👩🏻‍⚕️ 😔 🙌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, halo! 

 Artikel ini adalah tentang mengembangkan modul GPIO (General-Purpose Input / Output) dari kernel Linux. Seperti pada artikel sebelumnya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis modul kernel Linux: GPIO dengan dukungan IRQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419273/">  Habr, halo! <br><br>  Artikel ini adalah tentang mengembangkan modul GPIO (General-Purpose Input / Output) dari kernel Linux.  Seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kami menerapkan struktur dasar driver GPIO dengan dukungan interrupt (IRQ: Interrupt Request). <br><br><img src="https://habrastorage.org/webt/x-/ew/f1/x-ewf1v5oxdwgxosxzxreyzgjzc.jpeg"><br><a name="habracut"></a><br>  Data input mirip dengan artikel sebelumnya: blok GPIO dikembangkan untuk prosesor baru "kabel" ke FPGA dan menjalankan Linux versi 3.18.19. <br><br>  Untuk mengembangkan driver GPIO, kita perlu melakukan langkah-langkah berikut: <br><br><ol><li>  Memahami prinsip interaksi antara driver GPIO dan antarmuka ruang pengguna; </li><li>  Tambahkan modul kernel ke rakitan dan jelaskan perangkat keras di bagan perangkat; </li><li>  Menerapkan kerangka dasar pengemudi, serta titik masuk dan pengambilannya; </li><li>  Menerapkan bagian fungsional driver GPIO; </li><li>  Tambahkan dukungan IRQ ke implementasi driver. </li></ol><br>  Contoh driver GPIO dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <b>Langkah pertama</b> </h3><br>  Pertama, mari kita berkenalan dengan prinsip interaksi antara driver GPIO melalui konsol pengguna. <br><br>  Menggunakan skrip bash kecil, buat kontrol untuk setiap GPIO di / sysfs.  Untuk melakukan ini, tulis skrip berikut di baris perintah: <br><br><pre><code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {248..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Selanjutnya, mari kita lihat fitur apa yang disediakan / sysfs untuk mengkonfigurasi setiap GPIO: <br><br><pre> <code class="cpp hljs">root@zed-slave:/sys/<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio</span></span></span><span class="hljs-class"># </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ls</span></span></span><span class="hljs-class"> -</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio248</span></span></span><span class="hljs-class">/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">total</span></span></span><span class="hljs-class"> 0 -</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rw</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">--</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">-- 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> 4096 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jan</span></span></span><span class="hljs-class"> 7 20:</span></span><span class="hljs-number"><span class="hljs-number">50</span></span> active_low -rw-r--r-- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">4096</span></span> Jan <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> direction -rw-r--r-- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">4096</span></span> Jan <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> edge drwxr-xr-x <span class="hljs-number"><span class="hljs-number">2</span></span> root root <span class="hljs-number"><span class="hljs-number">0</span></span> Jan <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> power lrwxrwxrwx <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">0</span></span> Jan <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> subsystem -&gt; ../../../../<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio</span></span></span><span class="hljs-class"> -</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rw</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">--</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">-- 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> 4096 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jan</span></span></span><span class="hljs-class"> 7 20:</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> uevent -rw-r--r-- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">4096</span></span> Jan <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> value</code> </pre><br>  Saat ini kami tertarik pada bidang-bidang berikut: <br><br><ul><li>  <b>direction</b> - mengatur arah garis.  Dapat mengambil nilai "dalam" atau "keluar"; </li><li>  <b>nilai</b> - memungkinkan Anda untuk mengatur sinyal tinggi atau rendah pada saluran (jika arah diatur ke "keluar"), jika tidak (arah diatur ke "dalam") memungkinkan Anda untuk membaca status saluran; </li><li>  <b>edge</b> - memungkinkan Anda untuk mengkonfigurasi peristiwa yang menyebabkan interupsi terjadi.  Ini dapat mengambil nilai-nilai berikut: "tidak ada", "naik", "jatuh" atau "keduanya". </li></ul><br>  Setelah berkenalan dengan antarmuka driver melalui sysfs, Anda dapat mempertimbangkan bagaimana driver memproses perintah pengguna.  Kernel Linux memiliki struktur gpio_chip yang menjelaskan fungsi dari kontroler gpio.  Bidang-bidang berikut ada di dalamnya: <br><br><ul><li>  <b>direction_input</b> : mengatur baris ke input.  Dipanggil pada entri berikut: echo "in"&gt; / sys / class / gpio / gpio248 / direction; </li><li>  <b>direction_output</b> : mengatur garis untuk keluar.  Dipanggil pada entri berikut: echo "out"&gt; / sys / class / gpio / gpio248 / direction; </li><li>  <b>get</b> : membaca nilai yang ditetapkan di telepon.  Dipanggil pada entri berikut: cat / sys / class / gpio / gpio248 / value; </li><li>  <b>set</b> : mengatur nilai pada baris.  Dipanggil pada entri berikut: echo 1/0&gt; / sys / class / gpio / gpio248 / value; </li></ul><br>  Untuk menjelaskan konfigurasi IRQ di Linux, ada struktur irq_chip yang berisi bidang-bidang berikut: <br><br><ul><li>  <b>irq_set_type</b> : menyetel jenis peristiwa yang dengannya interupsi akan terjadi.  Dipanggil pada entri berikut: echo&gt; "naik" / "jatuh" / "keduanya"&gt; / sys / class / gpio / gpio248 / edge; </li><li>  <b>irq_mask</b> : melarang interupsi.  Dipanggil pada entri berikut: echo "none"&gt; / sys / class / gpio / gpio248 / edge; </li><li>  <b>irq_unmask</b> : Mengaktifkan interupsi pada acara yang diatur ke irq_set_type.  Disebut segera setelah irq_set_type dieksekusi. </li></ul><br><h3>  <b>Langkah kedua</b> </h3><br>  Sekarang Anda dapat menambahkan driver ke rakitan dan menjelaskan perangkat keras, mengikuti langkah-langkah standar.  Pertama, buat file sumber: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> drivers/gpio/ vim gpio-skel.c :wq</code> </pre><br>  Setelah kami menambahkan konfigurasi <i>driver</i> ke <i>driver / gpio / Kconfig</i> : <br><br><pre> <code class="bash hljs">config GPIO_SKEL tristate <span class="hljs-string"><span class="hljs-string">"SKEL GPIO"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Say yes here to support SKEL GPIO.</code> </pre><br>  Tambahkan driver ke rakitan di <i>driver / gpio / Makefile</i> : <br><br><pre> <code class="bash hljs">obj-$(CONFIG_GPIO_SKEL) += gpio-skel.o</code> </pre><br>  Dan akhirnya, tambahkan deskripsi blok GPIO ke devicetree (* .dts): <br><br><pre> <code class="bash hljs">gpio: gpio@f8f01d00 { compatible = <span class="hljs-string"><span class="hljs-string">"skel-gpio"</span></span>; rcm,ngpio = &lt;8&gt;; rcm,interrupt-type = &lt;IRQ_TYPE_EDGE_RISING&gt;; clocks = &lt;&amp;clkc 42&gt;; gpio-controller ; interrupt-parent = &lt;&amp;ps7_scugic_0&gt;; interrupts = &lt;0 29 4&gt;; reg = &lt;0x43c00000 0x100&gt;; } ;</code> </pre><br>  Anda dapat membaca lebih lanjut tentang devicetree di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <b>Langkah ketiga</b> </h3><br>  Mari kita beralih ke bagian yang paling menarik bagi kita! <br><br>  Kami memulai pengembangan driver dengan menghubungkan file header yang diperlukan dan menjelaskan kerangka lengkap driver tanpa dukungan IRQ.  Selanjutnya, kita akan secara berurutan mengisi setiap fungsi dengan kode dan menyertai penjelasan yang diperlukan. <br><br><div class="spoiler">  <b class="spoiler_title">Kerangka driver GPIO</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* gpio-skel.c: GPIO driver * * Name Surname &lt;email&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/of.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/irqdomain.h&gt; #include &lt;linux/bitops.h&gt; #include &lt;linux/irqchip/chained_irq.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/gpio/driver.h&gt; #include &lt;linux/platform_device.h&gt; #define SKEL_GPIO_VER 0x04 #define SKEL_GPIO_PAD_DIR 0x08 #define SKEL_GPIO_WR_DATA 0x0C #define SKEL_GPIO_RD_DATA 0x10 #define SKEL_GPIO_WR_DATA1 0x1C #define SKEL_GPIO_WR_DATA0 0x20 #define SKEL_GPIO_SRC 0x24 #define SKEL_GPIO_MAX_NGPIO 8 #define GPIO_OFFSET 4 struct skel_gpio_chip { struct gpio_chip gchip; spinlock_t lock; void __iomem *regs; u32 type; }; static inline void gpio_write(uint32_t value, void *base, uint32_t addr) { writel(value, base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "iowrite32(0x%x, base + 0x%x);\n", value, addr); #endif } static inline uint32_t gpio_read(void *base, uint32_t addr) { uint32_t reg = readl(base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "/* ioread32(base + 0x%x) == 0x%x */\n", addr, reg); #endif return reg; } static inline struct skel_gpio_chip *to_skel_gpio(struct gpio_chip *chip) { } /* * echo "in" &gt; /sys/class/gpio/gpioN/direction */ static int skel_gpio_direction_input(struct gpio_chip *chip, unsigned offset) { } /* * echo "out" &gt; /sys/class/gpio/gpioN/direction */ static int skel_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value) { } static int skel_gpio_get(struct gpio_chip *chip, unsigned offset) { } static void skel_gpio_set(struct gpio_chip *chip, unsigned offset, int value) { } static int skel_gpio_probe(struct platform_device *pdev) { } static int skel_gpio_remove(struct platform_device *pdev) { } static const struct of_device_id skel_gpio_of_match[] = { { .compatible = "skel-gpio" }, { }, }; MODULE_DEVICE_TABLE(of, skel_gpio_of_match); static struct platform_driver skel_gpio_driver = { .probe = skel_gpio_probe, .remove = skel_gpio_remove, .driver = { .name = "skel-gpio", .of_match_table = of_match_ptr(skel_gpio_of_match), }, }; module_platform_driver(skel_gpio_driver); MODULE_DESCRIPTION("GPIO driver"); MODULE_AUTHOR("Name Surname"); MODULE_LICENSE("GPL");</span></span></span></span></code> </pre><br></div></div><br>  Seperti yang dapat Anda lihat dari implementasi, kerangka pengemudi terlihat cukup sederhana dan tidak mengandung banyak fungsi dan struktur yang diperlukan. <br><br>  Untuk menggambarkan driver masa depan, kita membutuhkan elemen-elemen berikut: <br><br><ul><li>  platform_driver skel_gpio_driver - menjelaskan titik masuk skel_gpio_probe saat memuat driver dan skel_gpio_remove ketika diekstraksi dari kernel; </li><li>  struct of_device_id skel_gpio_of_match - berisi tabel yang menggambarkan perangkat keras dari blok GPIO; </li><li>  struct skel_gpio_chip - berisi bidang yang diperlukan untuk mengontrol driver blok GPIO. </li></ul><br>  Selanjutnya, untuk memuat / mengekstrak driver ke / dari Linux, perlu untuk mengimplementasikan metode <b>.probe</b> dan <b>.remove</b> yang ditentukan dalam struktur <b>skel_gpio_driver</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_probe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of_node</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ngpio, ret; skel_gc = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*skel_gc), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!skel_gc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; spin_lock_init(&amp;skel_gc-&gt;lock); res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to get MMIO resource for GPIO.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } skel_gc-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!skel_gc-&gt;regs) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!of_property_read_u32(node, <span class="hljs-string"><span class="hljs-string">"skel,ngpio"</span></span>, &amp;ngpio)) skel_gc-&gt;gchip.ngpio = ngpio; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> skel_gc-&gt;gchip.ngpio = SKEL_GPIO_MAX_NGPIO; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skel_gc-&gt;gchip.ngpio &gt; SKEL_GPIO_MAX_NGPIO) { dev_warn(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Number of gpio is greater than MAX!\n"</span></span>); skel_gc-&gt;gchip.ngpio = SKEL_GPIO_MAX_NGPIO; } skel_gc-&gt;gchip.direction_input = skel_gpio_direction_input; skel_gc-&gt;gchip.direction_output = skel_gpio_direction_output; skel_gc-&gt;gchip.get = skel_gpio_get; skel_gc-&gt;gchip.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> = skel_gpio_set; skel_gc-&gt;gchip.owner = THIS_MODULE; skel_gc-&gt;gchip.base = <span class="hljs-number"><span class="hljs-number">-1</span></span>; platform_set_drvdata(pdev, skel_gc); ret = gpiochip_add(&amp;skel_gc-&gt;gchip); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed adding memory mapped gpiochip\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } dev_info(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"SKEL GPIO probe complete: (%d .. %d)\n"</span></span>, skel_gc-&gt;gchip.base, skel_gc-&gt;gchip.base + skel_gc-&gt;gchip.ngpio); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_remove</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> gpiochip_remove(&amp;skel_gc-&gt;gchip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br>  Fungsi skel_gpio_remove hanya menghapus driver GPIO terdaftar dari kernel, jadi pertimbangkan poin utama dalam skel_gpio_probe: <br><br><ul><li>  <b>devm_kzalloc</b> - mengalokasikan memori untuk struktur skel_gpio_chip; </li><li>  <b>platform_get_resource</b> - membaca alamat awal kartu register GPIO dari devicetree; </li><li>  <b>devm_ioremap_resource</b> - melakukan pemetaan alamat fisik ke alamat virtual; </li><li>  <b>of_property_read_u32</b> - membaca jumlah GPIO yang tersedia dari devicetree; </li><li>  <b>skel_gc-&gt; gchip. *</b> - mengisi bidang struktur yang diperlukan; </li><li>  <b>gpiochip_add</b> - menambahkan pengendali GPIO ke driver; </li></ul><br>  Sejauh ini, belum dijelaskan mengapa angka ajaib seperti 248 ... 255 digunakan. Entri skel_gc-&gt; gchip.base = -1;  meminta kernel untuk secara dinamis mengalokasikan angka yang digunakan oleh GPIO.  Untuk mengetahui angka-angka ini di akhir driver, output ditambahkan: <br><br><pre> <code class="cpp hljs">dev_info(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"SKEL GPIO probe complete: (%d .. %d)\n"</span></span>, skel_gc-&gt;gchip.base, skel_gc-&gt;gchip.base + skel_gc-&gt;gchip.ngpio);</code> </pre><br>  Tentu saja, Linux menyediakan kemampuan untuk mengatur angka secara manual, tetapi mari kita lihat komentar dalam <a href="">kode</a> sumber: <br><br><pre> <code class="cpp hljs">@base: identifies the first GPIO number handled by <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> chip; * <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> negative during registration, requests dynamic ID allocation. * DEPRECATION: providing anything non-negative <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> nailing the base * offset of GPIO chips is deprecated. Please pass <span class="hljs-number"><span class="hljs-number">-1</span></span> as base to * let gpiolib select the chip base in all possible cases. We want to * get rid of the <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GPIO number space in the <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> run.</code> </pre><br><br><h3>  <b>Langkah keempat</b> </h3><br>  Pertimbangkan bagian fungsional driver, yaitu, kami menerapkan metode berikut: <br>  <b>.direction_output</b> , <b>.direction_input</b> , <b>.get</b> dan <b>.set</b> .  Selanjutnya, kode yang tergantung pada perangkat keras akan ditampilkan, yang dalam banyak kasus akan berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_direction_input</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * echo "in" &gt; /sys/class/gpio/gpioN/direction */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_direction_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct gpio_chip *chip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_skel_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag; u32 data_dir; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_dir = gpio_read(gc-&gt;regs, SKEL_GPIO_PAD_DIR); data_dir &amp;= ~BIT(offset); gpio_write(data_dir, gc-&gt;regs, SKEL_GPIO_PAD_DIR); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br>  Metode skel_gpio_direction_input melakukan tindakan berikut: <br><br><ul><li>  Dipanggil dengan perintah berikut echo "in"&gt; / sys / class / gpio / gpioN / direction; </li><li>  Membaca register SKEL_GPIO_PAD_DIR, yang bertanggung jawab untuk mengatur arah pin GPIO; </li><li>  Setel topeng yang dibutuhkan; </li><li>  Menulis nilai yang diterima kembali ke SKEL_GPIO_PAD_DIR. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_direction_output</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * echo "out" &gt; /sys/class/gpio/gpioN/direction */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_direction_output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct gpio_chip *chip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_skel_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag; u32 data_reg, data_dir; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_reg = gpio_read(gc-&gt;regs, SKEL_GPIO_WR_DATA); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) data_reg |= BIT(offset); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data_reg &amp;= ~BIT(offset); gpio_write(data_reg, gc-&gt;regs, SKEL_GPIO_WR_DATA); data_dir = gpio_read(gc-&gt;regs, SKEL_GPIO_PAD_DIR); data_dir |= BIT(offset); gpio_write(data_dir, gc-&gt;regs, SKEL_GPIO_PAD_DIR); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br>  Metode skel_gpio_direction_output melakukan tindakan yang mirip dengan skel_gpio_direction_inut kecuali ia dipanggil dengan perintah berikut: <br><br><ul><li>  echo "out"&gt; / sys / class / gpio / gpioN / direction; </li><li>  gema "tinggi"&gt; / sys / class / gpio / gpioN / direction, atur nilainya menjadi 1; </li><li>  gema "rendah"&gt; / sys / class / gpio / gpioN / direction, atur nilainya ke 0. </li></ul><br>  value - nilai yang menentukan level sinyal pada jalur output. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_set</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct gpio_chip *chip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_skel_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data_reg; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_reg = gpio_read(gc-&gt;regs, SKEL_GPIO_WR_DATA); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) data_reg |= BIT(offset); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data_reg &amp;= ~BIT(offset); gpio_write(data_reg, gc-&gt;regs, SKEL_GPIO_WR_DATA); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); }</code> </pre><br></div></div><br>  Metode skel_gpio_set melakukan tindakan berikut: <br><br><ul><li>  Dipanggil dengan perintah berikut echo 1/0&gt; / sys / class / gpio / gpioN / value; </li><li>  Membaca register SKEL_GPIO_WR_DATA, yang menunjukkan nilai sinyal saat ini di telepon; </li><li>  Set atau setel ulang bit yang diperlukan dengan offset; </li><li>  Menulis nilai yang diterima kembali ke SKEL_GPIO_WR_DATA. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_get</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct gpio_chip *chip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_skel_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!(gpio_read(gc-&gt;regs, SKEL_GPIO_RD_DATA) &amp; BIT(offset)); }</code> </pre><br></div></div><br>  Metode skel_gpio_get membaca nilai sinyal di telepon dengan membaca register SKEL_GPIO_RD_DATA. <br><br>  Setelah kami menjelaskan semua metode dan struktur yang diperlukan, Anda dapat menggabungkan semuanya dan melihat versi finalnya. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi driver GPIO</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* gpio-skel.c: GPIO driver * * Name Surname &lt;email&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/of.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/irqdomain.h&gt; #include &lt;linux/bitops.h&gt; #include &lt;linux/irqchip/chained_irq.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/gpio/driver.h&gt; #include &lt;linux/platform_device.h&gt; #define SKEL_GPIO_VER 0x04 #define SKEL_GPIO_PAD_DIR 0x08 #define SKEL_GPIO_WR_DATA 0x0C #define SKEL_GPIO_RD_DATA 0x10 #define SKEL_GPIO_WR_DATA1 0x1C #define SKEL_GPIO_WR_DATA0 0x20 #define SKEL_GPIO_SRC 0x24 #define SKEL_GPIO_MAX_NGPIO 8 #define GPIO_OFFSET 4 struct skel_gpio_chip { struct gpio_chip gchip; spinlock_t lock; void __iomem *regs; u32 type; }; static inline void gpio_write(uint32_t value, void *base, uint32_t addr) { writel(value, base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "iowrite32(0x%x, base + 0x%x);\n", value, addr); #endif } static inline uint32_t gpio_read(void *base, uint32_t addr) { uint32_t reg = readl(base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "/* ioread32(base + 0x%x) == 0x%x */\n", addr, reg); #endif return reg; } static inline struct skel_gpio_chip *to_skel_gpio(struct gpio_chip *chip) { return container_of(chip, struct skel_gpio_chip, gchip); } /* * echo &gt; "out" &gt; /sys/class/gpio/gpioN/direction */ static int skel_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value) { struct skel_gpio_chip *gc = to_skel_gpio(chip); unsigned long flag; u32 data_reg, data_dir; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_reg = gpio_read(gc-&gt;regs, SKEL_GPIO_WR_DATA); if (value) data_reg |= BIT(offset); else data_reg &amp;= ~BIT(offset); gpio_write(data_reg, gc-&gt;regs, SKEL_GPIO_WR_DATA); data_dir = gpio_read(gc-&gt;regs, SKEL_GPIO_PAD_DIR); data_dir |= BIT(offset); gpio_write(data_dir, gc-&gt;regs, SKEL_GPIO_PAD_DIR); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); return 0; } /* * echo &gt; "in" &gt; /sys/class/gpio/gpioN/direction */ static int skel_gpio_direction_input(struct gpio_chip *chip, unsigned offset) { struct skel_gpio_chip *gc = to_skel_gpio(chip); unsigned long flag; u32 data_dir; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_dir = gpio_read(gc-&gt;regs, SKEL_GPIO_PAD_DIR); data_dir &amp;= ~BIT(offset); gpio_write(data_dir, gc-&gt;regs, SKEL_GPIO_PAD_DIR); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); return 0; } static int skel_gpio_get(struct gpio_chip *chip, unsigned offset) { struct skel_gpio_chip *gc = to_skel_gpio(chip); return !!(gpio_read(gc-&gt;regs, SKEL_GPIO_RD_DATA) &amp; BIT(offset)); } static void skel_gpio_set(struct gpio_chip *chip, unsigned offset, int value) { struct skel_gpio_chip *gc = to_skel_gpio(chip); unsigned long flag; unsigned int data_reg; spin_lock_irqsave(&amp;gc-&gt;lock, flag); data_reg = gpio_read(gc-&gt;regs, SKEL_GPIO_WR_DATA); if (value) data_reg |= BIT(offset); else data_reg &amp;= ~BIT(offset); gpio_write(data_reg, gc-&gt;regs, SKEL_GPIO_WR_DATA); spin_unlock_irqrestore(&amp;gc-&gt;lock, flag); } static int skel_gpio_remove(struct platform_device *pdev) { struct skel_gpio_chip *skel_gc = platform_get_drvdata(pdev); gpiochip_remove(&amp;skel_gc-&gt;gchip); return 0; } static int skel_gpio_probe(struct platform_device *pdev) { struct device_node *node = pdev-&gt;dev.of_node; struct skel_gpio_chip *skel_gc; struct resource *res; int ngpio, ret; skel_gc = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*skel_gc), GFP_KERNEL); if (!skel_gc) return -ENOMEM; spin_lock_init(&amp;skel_gc-&gt;lock); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&amp;pdev-&gt;dev, "Failed to get MMIO resource for GPIO.\n"); return -EINVAL; } skel_gc-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (!skel_gc-&gt;regs) return -ENXIO; if (!of_property_read_u32(node, "skel,ngpio", &amp;ngpio)) skel_gc-&gt;gchip.ngpio = ngpio; else skel_gc-&gt;gchip.ngpio = SKEL_GPIO_MAX_NGPIO; if (skel_gc-&gt;gchip.ngpio &gt; SKEL_GPIO_MAX_NGPIO) { dev_warn(&amp;pdev-&gt;dev, "Number of gpio is greater than MAX!\n"); skel_gc-&gt;gchip.ngpio = SKEL_GPIO_MAX_NGPIO; } skel_gc-&gt;gchip.direction_input = skel_gpio_direction_input; skel_gc-&gt;gchip.direction_output = skel_gpio_direction_output; skel_gc-&gt;gchip.get = skel_gpio_get; skel_gc-&gt;gchip.set = skel_gpio_set; skel_gc-&gt;gchip.owner = THIS_MODULE; skel_gc-&gt;gchip.base = -1; platform_set_drvdata(pdev, skel_gc); ret = gpiochip_add(&amp;skel_gc-&gt;gchip); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed adding memory mapped gpiochip\n"); return ret; } dev_info(&amp;pdev-&gt;dev, "SKEL GPIO probe complete: (%d .. %d)\n", skel_gc-&gt;gchip.base, skel_gc-&gt;gchip.base + skel_gc-&gt;gchip.ngpio); return 0; } static const struct of_device_id skel_gpio_of_match[] = { { .compatible = "skel-gpio" }, { }, }; MODULE_DEVICE_TABLE(of, skel_gpio_of_match); static struct platform_driver skel_gpio_driver = { .probe = skel_gpio_probe, .remove = skel_gpio_remove, .driver = { .name = "skel-gpio", .of_match_table = of_match_ptr(skel_gpio_of_match), }, }; module_platform_driver(skel_gpio_driver); MODULE_DESCRIPTION("GPIO driver"); MODULE_AUTHOR("Name Surname"); MODULE_LICENSE("GPL");</span></span></span></span></code> </pre><br></div></div><br>  Driver yang diimplementasikan berisi fungsionalitas yang diperlukan untuk mengendalikan GPIO, tetapi saat ini driver tidak mendukung penanganan interupsi, sehingga Anda dapat pergi ke langkah berikutnya. <br><br><h3>  <b>Langkah kelima</b> </h3><br>  Menambahkan IRQ ke driver GPIO dapat dibagi menjadi tiga langkah: <br><br><ul><li>  Deskripsi metode yang didukung dalam struktur data kernel; </li><li>  Mengaktifkan dukungan IRQ pada saat driver dimuat ke dalam sistem; </li><li>  Implementasi metode yang didukung. </li></ul><br>  Awalnya, kami menggambarkan rangkaian operasi yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_chip</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_irq_chip</span></span></span><span class="hljs-class"> = {</span></span> .name = <span class="hljs-string"><span class="hljs-string">"skel-gpio"</span></span>, .irq_mask = skel_gpio_irq_mask, .irq_unmask = skel_gpio_irq_unmask, .irq_set_type = skel_gpio_irq_set_type, };</code> </pre><br>  Oleh karena itu, pengandar dapat mengaktifkan (skel_gpio_irq_unmask) / menonaktifkan (skel_gpio_irq_mask) gangguan dan menunjukkan jenis peristiwa yang akan dihasilkan (skel_gpio_irq_set_type). <br>  Selanjutnya, kami menjelaskan satu-satunya metode yang bertanggung jawab untuk memetakan nomor irq virtual ke perangkat keras. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_domain_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_irq_domain_ops</span></span></span><span class="hljs-class"> = {</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> = skel_gpio_irq_domain_map, };</code> </pre><br>  Kemudian kami akan memberi tahu kernel bahwa dukungan driver yang dimuat bekerja dengan IRQ.  Untuk melakukan ini, tambahkan kode berikut ke fungsi probe: <br><br><div class="spoiler">  <b class="spoiler_title">Menambahkan Dukungan IRQ</b> <div class="spoiler_text"><pre> <code class="cpp hljs">skel_gc-&gt;gchip.to_irq = skel_gpio_to_irq; skel_gc-&gt;domain = irq_domain_add_linear(pdev-&gt;dev.of_node, rcm_gc-&gt;gchip.ngpio, &amp;skel_gpio_irq_domain_ops, skel_gc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!skel_gc-&gt;domain) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENODEV; skel_gc-&gt;irq = platform_get_irq(pdev, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skel_gc-&gt;irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; skel_gc-&gt;gchip.ngpio; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq = rcm_gpio_to_irq(&amp;skel_gc-&gt;gchip, i); irq_set_chip_and_handler(irq, &amp;skel_irq_chip, handle_simple_irq); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_ARM set_irq_flags(irq, IRQF_VALID); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> irq_set_noprobe(irq); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } irq_set_chained_handler(skel_gc-&gt;irq, skel_irq_handler); irq_set_handler_data(skel_gc-&gt;irq, skel_gc);</span></span></code> </pre><br></div></div><br>  Dalam kode di atas terjadi: <br><br><ul><li>  Alokasi dan inisialisasi area di bawah irq_domain; </li><li>  Baca nomor interupsi dengan devicetree; </li><li>  pemetaan antara interupsi virtual dan perangkat keras; </li><li>  Mendaftarkan pawang interupsi dan mengatur data untuk pengiriman ke pawang; </li></ul><br>  Kami terus menerapkan beberapa metode yang dijelaskan di atas. <br>  skel_gpio_to_irq - Membuat pemetaan antara perangkat keras dan interupsi virtual.  Jika pemetaan ini telah dibuat, ia mengembalikan jumlah interupsi virtual yang dibuat. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi Skel_gpio_to_irq</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_gpio_to_irq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct gpio_chip *chip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gpio)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcm</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_skel_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq_create_mapping(rcm-&gt;domain, gpio); }</code> </pre><br></div></div><br>  skel_irq_handler adalah interrupt handler yang: <br><br><ul><li>  Membaca register status interupsi; </li><li>  Membaca register topeng interupsi; </li><li>  Lemparan menyela menunggu pemrosesan; </li><li>  Untuk setiap GPIO di mana terjadi gangguan, panggil generic_handle_irq. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementasi Interrupt Handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_irq_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq, struct irq_desc *desc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_get_handler_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_desc_get_chip</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desc</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iomem *base; u32 status, mask, gpio, pending; chained_irq_enter(chip, desc); base = skel_gc-&gt;regs; status = gpio_read(base, SKEL_GPIO_STATUS); mask = gpio_read(base, SKEL_GPIO_IRQ_MASK); pending = status &amp; mask; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pending) { gpio = __ffs(pending); pending &amp;= ~BIT(gpio); generic_handle_irq( irq_find_mapping(skel_gc-&gt;domain, gpio)); } chained_irq_exit(chip, desc); }</code> </pre><br></div></div><br>  Itu saja, dalam artikel ini kami mempelajari bagaimana driver GPIO berinteraksi dengan sistem file virtual sysfs, menerapkan struktur dasar driver GPIO, dan juga memeriksa metode yang diperlukan untuk mendukung IRQ. <br><br>  Artikel ini tidak menjelaskan implementasi metode skel_gpio_irq_unmask, skel_gpio_irq_mask, dan skel_gpio_irq_set_type karena dua alasan.  Pertama, metode ini mudah diterapkan.  Kedua, tergantung pada perangkat keras.  Mereka bertanggung jawab untuk mengizinkan atau menonaktifkan interupsi untuk peristiwa tertentu yang didukung oleh pengendali GPIO. <br><br>  Tolong, jika Anda menemukan kesalahan / ketidakakuratan, atau Anda memiliki sesuatu untuk ditambahkan, tulis di PM atau di komentar. <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419273/">https://habr.com/ru/post/id419273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419261/index.html">Tindakan di Google: menulis aplikasi sederhana untuk Google Assistant di Dialogflow dan Cloud Functions for Firebase</a></li>
<li><a href="../id419265/index.html">Menggunakan jaringan saraf multi-layer untuk menghindari rintangan dalam game</a></li>
<li><a href="../id419267/index.html">SOK Coworking Tour</a></li>
<li><a href="../id419269/index.html">Rebus dalam kode, dan cara mendekripsi mereka. Kekuatan Rahasia Pengidentifikasi</a></li>
<li><a href="../id419271/index.html">Analog dengan Python dan JavaScript. Bagian empat</a></li>
<li><a href="../id419277/index.html">Kaset termal dengan kelas perlindungan IP68. Cocok untuk penerangan di pemandian</a></li>
<li><a href="../id419279/index.html">Intisari materi menarik untuk pengembang seluler # 264 (30 Juli - 5 Agustus)</a></li>
<li><a href="../id419281/index.html">rcm - rc-file manager: tuning dan gunakan</a></li>
<li><a href="../id419283/index.html">Bezos melempar uang dan insinyur untuk mengembangkan roket sehubungan dengan percepatan perlombaan ruang angkasa</a></li>
<li><a href="../id419289/index.html">Dengar dan bicara: Pengumuman HolyJS 2018 Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>