<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 👼🏿 🛳️ Le livre «Algorithmes et structures de données. Récupération d'informations Java » ⬅️ 🐸 🐥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Apprenez à implémenter des algorithmes efficaces basés sur les structures de données les plus importantes du langage Java et à mesurer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre «Algorithmes et structures de données. Récupération d'informations Java »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/419503/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ul/ci/2m/ulci2miltdytubvrcl0sem1gltk.jpeg" align="left" alt="image"></a>  Bonjour, Habr!  Apprenez à implémenter des algorithmes efficaces basés sur les structures de données les plus importantes du langage Java et à mesurer les performances de ces algorithmes.  Chaque chapitre est accompagné d'exercices pour aider à consolider le matériel. <br><br><ul><li>  Apprenez à travailler avec des structures de données, par exemple, avec des listes et des dictionnaires, à comprendre comment elles fonctionnent. </li><li>  Écrivez une application qui lit les pages Wikipedia, analyse et fournit une navigation dans l'arborescence de données résultante. </li><li>  Analysez le code et apprenez à prédire à quelle vitesse il fonctionnera et combien de mémoire il consommera. </li><li>  Écrivez des classes qui implémentent l'interface Map et utilisez une table de hachage et un arbre de recherche binaire. </li><li>  Créez un moteur de recherche Web simple avec son propre moteur de recherche: il indexera les pages Web, enregistrera leur contenu et renverra les résultats souhaités. </li></ul><a name="habracut"></a><br><h3>  Extrait "Tree Walk" </h3><br>  Dans ce chapitre, nous examinerons une application de moteur de recherche que nous développerons dans le reste du livre.  Je (l'auteur) décris les éléments d'un moteur de recherche et présente la première application, un robot de recherche qui télécharge et analyse des pages de Wikipédia.  Ce chapitre présente également une implémentation de recherche approfondie récursive et une implémentation itérative utilisant Deque de Java pour implémenter une pile «dernier entré, premier sorti». <br><br><h3>  Moteurs de recherche </h3><br>  Un moteur de recherche tel que Google Search ou Bing accepte un ensemble de termes de recherche et renvoie une liste de pages Web pertinentes pour ces termes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous</a> pouvez en savoir plus sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com</a> , mais je vous expliquerai ce dont vous avez besoin au fur et à mesure. <br><br>  Considérez les principaux composants d'un moteur de recherche. <br><br><ul><li>  Collecte de données (exploration).  Vous aurez besoin d'un programme capable de charger une page Web, de l'analyser et d'extraire du texte et des liens vers d'autres pages. </li><li>  Indexation  Nous avons besoin d'un index qui nous permet de trouver une requête de recherche et les pages qui la contiennent. </li><li>  Recherche (récupération).  Vous avez besoin d'un moyen de collecter les résultats de l'index et de déterminer les pages les plus pertinentes pour les termes de recherche. </li></ul><br>  Commençons par le robot de recherche.  Son but est de détecter et de charger un ensemble de pages Web.  Pour les moteurs de recherche tels que Google et Bing, le défi est de trouver toutes les pages Web, mais souvent ces robots sont limités à un domaine plus petit.  Dans notre cas, nous ne lirons que les pages de Wikipédia. <br><br>  Dans un premier temps, nous allons créer un robot de recherche qui lit la page Wikipédia, trouve le premier lien, va sur une autre page et répète les étapes précédentes.  Nous utiliserons ce moteur de recherche pour tester l'hypothèse de la philosophie.  Il dit: <br><br><blockquote>  "En cliquant sur le premier lien en minuscules dans le texte principal de l'article Wikipédia, puis en répétant cette action pour les articles suivants, vous êtes le plus susceptible d'être redirigé vers une page avec un article sur la philosophie." <br></blockquote><br>  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consulter</a> cette hypothèse et son histoire sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/getphil</a> . <br>  Tester une hypothèse vous permettra de créer les principales parties d'un robot de recherche sans avoir à contourner tout Internet ou même Wikipédia.  Et je pense que cet exercice est assez intéressant! <br><br>  Dans plusieurs chapitres, nous allons travailler sur l'indexeur, puis passer au moteur de recherche. <br><br><h3>  Analyse HTML </h3><br>  Lorsque vous chargez une page Web, son contenu est écrit dans le langage HTML (HyperText Markup Language).  Par exemple, ce qui suit est un simple document HTML: <br><br><pre><code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>This is a title<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello world!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Phrases Ceci est un titre et Bonjour tout le monde!  ("Bonjour tout le monde!") - le texte qui apparaît vraiment sur la page;  d'autres éléments sont des balises indiquant comment le texte doit être affiché. <br><br>  Lors du chargement d'une page, notre robot doit analyser le code HTML pour extraire le texte et trouver des liens.  Pour ce faire, nous utiliserons jsoup, une bibliothèque Java open source conçue pour charger et analyser (analyser) du HTML. <br>  Le résultat de l'analyse HTML est une arborescence DOM (modèle d'objet document) contenant des éléments de document, y compris du texte et des balises. <br><br>  Un arbre est une structure de données associée composée de sommets qui représentent du texte, des balises et d'autres éléments d'un document. <br><br>  La relation entre les sommets est déterminée par la structure du document.  Dans l'exemple précédent, le premier nœud, appelé racine, est une balise qui inclut des liens vers les deux sommets qu'il contient et;  ces nœuds sont des enfants du nœud racine. <br><br>  Un nœud a un sommet enfant et un nœud a un sommet enfant <p>  (paragraphe, de l'anglais. paragraphe).  Dans la fig.  6.1 est une représentation graphique de cet arbre. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/r7/07/uu/r707uude4_ixfv0kd4laaafp9zu.png" alt="image"></div><br>  Chaque sommet comprend des liens vers ses nœuds enfants;  en outre, chaque nœud contient un lien vers son parent, vous pouvez donc vous déplacer vers le haut et vers le bas de l'arborescence depuis n'importe quel nœud.  L'arbre DOM pour les pages réelles est généralement plus complexe que l'exemple décrit. <br><br>  La plupart des navigateurs disposent d'outils pour vérifier le DOM de la page que vous consultez.  Dans Chrome, vous pouvez cliquer avec le bouton droit sur n'importe quelle partie de la page Web et sélectionner l'élément Afficher le code dans le menu qui apparaît.  Dans Firefox, vous pouvez cliquer avec le bouton droit et sélectionner Explorer l'élément dans le menu contextuel.  Safari fournit l'outil Web Inspector, qui se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/safari</a> .  Les instructions pour Internet Explorer peuvent être lues en cliquant sur le lien: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/explorer</a> . <br><br>  Dans la fig.  La figure 6.2 montre une capture d'écran de l'arborescence DOM pour la page Wikipedia sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> .  L'élément en surbrillance est le premier paragraphe du corps de l'article, qui est contenu dans l'élément &lt;div&gt; avec id = "mw-content-text".  Nous utiliserons cet identifiant d'élément pour déterminer le corps de chaque article que nous téléchargeons. <br><br><h3>  Application Jsoup </h3><br>  La bibliothèque jsoup facilite le chargement et l'analyse des pages Web et la navigation dans l'arborescence DOM.  Par exemple: <br><br><pre> <code class="hljs pgsql">String url = "http://en.wikipedia.org/wiki/Java_(programming_language)"; //     <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span> conn = Jsoup.<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(url); Document doc = conn.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); //         Element content = doc.getElementById("mw-content-text"); Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p");</code> </pre> <br>  L'élément Jsoup.connect accepte l'URL en tant que chaîne et établit une connexion au serveur Web;  La méthode get charge le code HTML, le paralyse et renvoie un objet Document, qui est un DOM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/ez/xu/gbezxuae9aggcurdydsoilnshpo.png" alt="image"></div><br>  Cet objet comprend des méthodes de navigation dans un arbre et de sélection de nœuds.  En fait, il fournit tellement de méthodes qu'il peut être déroutant.  L'exemple suivant montre deux façons de sélectionner des nœuds. <br><br><ul><li>  getElementByld prend un paramètre de type chaîne et recherche un arbre pour l'élément avec le champ id correspondant.  L'ayant trouvé, il sélectionne le nœud &lt;div id = "mw-content-text" lang = "en" dir = "ltr" class = "mw-content-ltr"&gt; qui apparaît sur chaque page Wikipédia pour identifier l'élément Un &lt;div&gt; contenant le corps de la page, contrairement à la barre de navigation latérale et aux autres éléments. </li><li>  select prend une chaîne, traverse l'arborescence et renvoie tous les éléments dont les balises correspondent à la chaîne.  Dans cet exemple, il renvoie toutes les balises de paragraphe qui apparaissent dans le contenu.  La valeur de retour est un objet de type Elements. </li></ul><br>  Avant de continuer, vous devez consulter la documentation de ces classes pour savoir quelles actions elles peuvent effectuer.  Les classes les plus importantes sont Element, Elements et Node, que vous pouvez consulter en cliquant sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liens thinkdast.com/jsoupelt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/jsoupelts</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/jsoupnode</a> . <br><br>  La classe Node est le sommet de l'arborescence DOM.  Il existe plusieurs sous-classes qui étendent Node, notamment Element, TextNode, DataNode et Comment.  La classe Elements est une collection d'objets de type Element. <br><br>  Dans la fig.  6.3 est un diagramme des classes UML montrant les relations entre elles.  Une ligne avec une flèche vide indique l'extension d'une classe à une autre.  Par exemple, ce graphique indique que Elements étend ArrayList.  Nous reviendrons sur les diagrammes de classes UML dans la section du même nom au chapitre 11. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/29/ys/p_/29ysp__8jqplpznbyty3y6mqmgi.png" alt="image"></div><br><h3>  Itérer sur une arborescence DOM </h3><br>  Pour vous faciliter la vie, je propose une classe WikiNodelterable qui vous permet de parcourir l'arborescence DOM.  Voici un exemple qui montre comment utiliser cette classe: <br><br><pre> <code class="hljs pgsql">Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p"); Element firstPara = paragraphs.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); Iterable&lt;Node&gt; iter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WikiNodeIterable(firstPara); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node node: iter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } }</code> </pre> <br>  Cet exemple commence par le moment où le précédent s'est arrêté.  Il sélectionne le premier paragraphe dans les paragraphes, puis crée une classe WikiNodeIterable qui implémente l'interface Iterable.  Cette classe recherche en profondeur, créant des nœuds dans l'ordre dans lequel ils apparaissent sur la page. <br><br>  Dans l'exemple actuel, nous affichons Node uniquement s'il s'agit d'un TextNode et ignorons ses autres types, en particulier les objets de type Element qui représentent des balises.  Le résultat est un texte de paragraphe HTML brut sans aucun balisage.  Sa conclusion: <br><br><blockquote>  Java est un langage de programmation informatique à usage général qui est simultané, basé sur une classe, orienté objet, [13] et spécialement conçu ... <br><br>  Java est un langage de programmation informatique universel, qui est un langage orienté objet basé sur des classes, avec la possibilité de programmation parallèle [13] et est spécialement conçu ... </blockquote><br><h3>  Recherche de profondeur </h3><br>  Il existe plusieurs façons de parcourir intelligemment un arbre.  Nous commençons par une recherche en profondeur (DFS).  La recherche commence par la racine de l'arborescence et sélectionne le premier nœud enfant.  Si ce dernier a des enfants, le premier nœud enfant est à nouveau sélectionné.  Lorsqu'un pic sans enfants apparaît, vous devez revenir en remontant l'arborescence jusqu'au nœud parent, où l'enfant suivant est sélectionné, le cas échéant.  Sinon, vous devez revenir.  Lorsque le dernier nœud racine enfant est examiné, la traversée est terminée. <br><br>  Il existe deux façons généralement acceptées de mettre en œuvre la recherche approfondie: récursive et itérative.  L'implémentation récursive est simple et élégante: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursiveDFS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Node node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: node.childNodes()) { recursiveDFS(child); } }</code> </pre> <br>  Cette méthode est appelée pour chaque nœud de l'arborescence, en commençant à la racine.  Si Node est un TextNode, son contenu est imprimé.  Si Node a des enfants, il appelle récursifDFS pour chacun d'eux dans l'ordre. <br><br>  Dans l'exemple actuel, nous imprimons le contenu de chaque TextNode avant de visiter ses nœuds enfants, c'est-à-dire qu'il s'agit d'un exemple de traversée directe (précommande).  Vous pouvez lire sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solutions de contournement</a> directes, inverses (post-commande) et symétriques (dans l'ordre) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en</a> allant sur le lien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/treetrav</a> .  Pour cette application, l'ordre d'exploration n'a pas d'importance. <br><br>  Lors des appels récursifs, recursiveDFS utilise la pile d'appels (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/callstack</a> ) pour suivre les sommets enfants et les traiter dans le bon ordre.  Vous pouvez également utiliser la structure de données de la pile pour suivre vous-même les nœuds;  cela évitera la récursivité et itérera sur l'arbre de manière itérative. <br><br><h3>  Piles en Java </h3><br>  Avant d'expliquer la version itérative de la recherche en profondeur, j'examinerai la structure des données de la pile.  Nous commençons par le concept général de la pile, puis parlons de deux interfaces Java qui définissent les méthodes de la pile: Stack et Deque. <br><br>  Une pile est une structure de données de type liste: c'est une collection qui maintient l'ordre des éléments.  La principale différence entre la pile et la liste est que la première inclut moins de méthodes.  Par convention, la pile fournit des méthodes: <br><br><ul><li>  pousser, en ajoutant un élément en haut de la pile; </li><li>  pop, qui effectue la suppression et renvoie la valeur de l'élément le plus haut de la pile; </li><li>  jeter un œil, renvoyant l'élément le plus haut de la pile sans changer la pile elle-même; </li><li>  isEmpty, qui indique si la pile est vide. </li></ul><br>  Étant donné que pop renvoie toujours l'élément le plus haut, la pile est également appelée LIFO, ce qui signifie «dernier entré, premier sorti».  Une alternative à la pile est une file d'attente qui renvoie les éléments dans le même ordre dans lequel ils ont été ajoutés, c'est-à-dire «premier entré, premier sorti» ou FIFO. <br><br>  À première vue, la raison pour laquelle les piles et les files d'attente sont utiles n'est pas claire: elles ne fournissent aucune fonctionnalité spéciale qui ne pourrait pas être obtenue à partir des listes;  en fait, ils ont encore moins de possibilités.  Alors pourquoi ne pas toujours appliquer des listes?  Il y a deux raisons pour justifier les piles et les files d'attente. <br><br>  1. Si vous vous limitez à un petit ensemble de méthodes (c'est-à-dire une petite API), votre code sera plus lisible et moins sujet aux erreurs.  Par exemple, lorsque vous utilisez une liste pour représenter une pile, vous pouvez accidentellement supprimer un élément dans le mauvais ordre.  Avec l'API de pile, une telle erreur est littéralement impossible.  Et la meilleure façon d'éviter les erreurs est de les rendre impossibles. <br><br>  2. Si la structure de données fournit une petite API, il est plus facile de l'implémenter efficacement.  Par exemple, un moyen simple d'implémenter une pile consiste à utiliser une seule liste.  En poussant un élément sur la pile, nous l'ajoutons en haut de la liste;  popping un élément, nous le supprimons dès le début.  Pour une liste chaînée, l'ajout et la suppression depuis le début est une opération à temps constant, donc cette implémentation est efficace.  Inversement, les grandes API sont plus difficiles à implémenter efficacement. <br><br>  Il existe trois façons d'implémenter la pile en Java. <br><br>  1. Appliquez ArrayList ou LinkedList.  Lorsque vous utilisez ArrayList, vous devez vous rappeler d'ajouter et de supprimer à la fin afin que ces opérations soient effectuées en temps constant.  Évitez d'ajouter des éléments au mauvais endroit ou de les supprimer dans le mauvais ordre. <br><br>  2. Java a une classe Stack qui fournit un ensemble standard de méthodes de pile.  Mais cette classe est une ancienne partie de Java: elle est incompatible avec le Java Collections Framework, qui est apparu plus tard. <br><br>  3. Le meilleur choix est probablement d'utiliser l'une des implémentations de l'interface Deque, par exemple ArrayDeque. <br><br>  Deque est formé à partir d'une file d'attente à double extrémité, ce qui signifie «file d'attente bidirectionnelle».  En Java, l'interface Deque fournit des méthodes push, pop, peek et isEmpty, de sorte qu'elle peut être utilisée comme une pile.  Il contient d'autres méthodes, dont les informations sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thinkdast.com/deque</a> , mais pour l'instant nous ne les utiliserons pas. <br><br><h3>  Recherche de profondeur itérative </h3><br>  Voici une version itérative de DFS qui utilise ArrayDeque pour représenter une pile d'objets de type Node: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterativeDFS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ Deque&lt;Node&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;Node&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(root); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.isEmpty()) { Node node = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.out.print(node); } List&lt;Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Node&gt;(node. chiidNodesQ); Collections.reverse(nodes); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: nodes) { <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(chiid); } } }</code> </pre> <br>  Le paramètre racine est la racine de l'arbre que nous voulons contourner, nous commençons donc par créer une pile et y ajouter ce paramètre. <br><br>  La boucle continue jusqu'à ce que la pile soit vide.  Chaque passe pousse Node hors de la pile.  Si un TextNode est reçu, son contenu est imprimé.  Ensuite, les sommets enfants sont ajoutés à la pile.  Pour traiter les descendants dans le bon ordre, vous devez les pousser sur la pile dans l'ordre inverse;  cela se fait en copiant les sommets enfants dans une ArrayList, en réorganisant les éléments en place, puis en itérant la ArrayList inversée. <br>  L'un des avantages de la version approfondie de la recherche approfondie est qu'elle est plus facile à implémenter en tant qu'itérateur en Java;  comment procéder est décrit dans le chapitre suivant. <br><br>  Mais d'abord, une dernière note sur l'interface Deque: outre ArrayDeque, Java fournit une autre implémentation de Deque, notre vieil ami LinkedList.  Ce dernier implémente les deux interfaces: List et Deque.  L'interface résultante dépend de son utilisation.  Par exemple, lors de l'attribution d'une LinkedList à une variable Deque: <br><br><pre> <code class="hljs xml">Deqeue<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  Vous pouvez appliquer des méthodes à partir de l'interface Deque, mais pas toutes les méthodes de l'interface List.  En l'affectant à la variable List: <br><br><pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  vous pouvez utiliser les méthodes List, mais pas toutes les méthodes Deque.  Et en les affectant comme suit: <br><br><pre> <code class="hljs xml">LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  toutes les méthodes peuvent être utilisées.  Mais lors de la combinaison de méthodes provenant de différentes interfaces, le code sera moins lisible et plus sujet aux erreurs. <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  20% de réduction sur le coupon pour <b>les</b> fermenteurs <b>Java</b> - <b>Java</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419503/">https://habr.com/ru/post/fr419503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419491/index.html">Fonctionnement de STP</a></li>
<li><a href="../fr419493/index.html">Pourquoi avez-vous besoin de Splunk? Analyse des événements de sécurité</a></li>
<li><a href="../fr419495/index.html">Qui a "inventé" la conduction osseuse, pourquoi est-elle utilisée et est-elle sûre pour l'audition</a></li>
<li><a href="../fr419497/index.html">Critique de la grande imprimante 3D Hercules Strong</a></li>
<li><a href="../fr419501/index.html">Deep Learning: reconnaître les scènes et les points de repère dans les images</a></li>
<li><a href="../fr419507/index.html">Présentation de l'imprimante 3D russe PICASO 3D Designer X de 3Dtool</a></li>
<li><a href="../fr419509/index.html">Réseau neuronal artificiel photonique</a></li>
<li><a href="../fr419511/index.html">typeof (T) vs. TypeOf⟨T⟩</a></li>
<li><a href="../fr419513/index.html">Configurer la politique de sécurité des mots de passe dans Zimbra</a></li>
<li><a href="../fr419515/index.html">Comment une startup «sans marque» a obtenu 240 millions de dollars pour vaincre Amazon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>