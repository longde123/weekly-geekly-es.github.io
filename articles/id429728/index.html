<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ· ğŸ‡ ãŠ™ï¸ Arsitektur MVI modern berdasarkan pada Kotlin ğŸŒ‰ ğŸ‘¨ğŸ»â€ğŸ³ ğŸƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama dua tahun terakhir, pengembang Android di Badoo telah menempuh jalan panjang dan sulit dari MVP ke pendekatan arsitektur aplikasi yang sama sek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur MVI modern berdasarkan pada Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/429728/"><img src="https://habrastorage.org/webt/xn/qq/rv/xnqqrv1mzljdp6cmqtxjpx66ciw.png"><br><br>  Selama dua tahun terakhir, pengembang Android di Badoo telah menempuh jalan panjang dan sulit dari MVP ke pendekatan arsitektur aplikasi yang sama sekali berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ANublo</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">saya</a> ingin membagikan terjemahan sebuah artikel oleh rekan kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zsolt Kocsi</a> , menjelaskan masalah yang kami temui dan solusinya. <br><br>  Ini adalah yang pertama dari beberapa artikel yang ditujukan untuk pengembangan arsitektur MVI modern di Kotlin. <br><a name="habracut"></a><br><h2>  Mari kita mulai dari awal: masalah negara </h2><br>  Setiap saat, aplikasi memiliki status tertentu yang menentukan perilakunya dan apa yang dilihat pengguna.  Jika Anda hanya fokus pada beberapa kelas, status ini mencakup semua nilai variabel - mulai dari flag sederhana hingga objek individual.  Masing-masing variabel hidup sendiri dan dikendalikan oleh bagian kode yang berbeda.  Anda dapat menentukan kondisi aplikasi saat ini hanya dengan memeriksa semuanya satu per satu. <br><br>  Bekerja pada kode, kami membuat model kerja sistem yang ada di kepala kami.  Kami dengan mudah menerapkan kasus-kasus yang ideal ketika semuanya berjalan sesuai rencana, tetapi sama sekali tidak dapat menghitung semua masalah dan kondisi aplikasi yang mungkin.  Dan cepat atau lambat, salah satu kondisi yang belum kita bayangkan akan menyusul kita, dan kita akan menemukan bug. <br><br>  Awalnya, kode ini ditulis sesuai dengan ide kami tentang bagaimana sistem seharusnya bekerja.  Tetapi di masa depan, melalui <a href="">lima tahap debugging</a> , Anda harus dengan susah payah mengulang semuanya, secara bersamaan mengubah model sistem yang sudah dibuat yang telah dikembangkan di kepala.  Diharapkan cepat atau lambat kita akan mengerti apa yang salah dan bug akan diperbaiki. <br><br>  Tapi ini jauh dari selalu beruntung.  Semakin kompleks sistemnya, semakin besar kemungkinannya untuk menghadapi beberapa kondisi yang tidak terduga, debugging yang akan menjadi impian untuk waktu yang lama dalam mimpi buruk. <br><br>  Di Badoo, semua aplikasi pada dasarnya tidak sinkron - tidak hanya karena fungsionalitas luas yang tersedia bagi pengguna melalui UI, tetapi juga karena kemungkinan pengiriman data satu arah oleh server.  Keadaan dan perilaku aplikasi dipengaruhi oleh banyak hal - dari mengubah status pembayaran menjadi kecocokan baru dan permintaan verifikasi. <br><br>  Akibatnya, dalam modul obrolan kami, kami menemukan beberapa bug aneh dan sulit untuk mereproduksi yang merusak banyak darah bagi semua orang.  Kadang-kadang penguji berhasil menuliskannya, tetapi mereka tidak diulang pada perangkat pengembang.  Karena kode asinkron, pengulangan yang penuh dengan rangkaian peristiwa sangat tidak mungkin.  Dan karena aplikasi tidak macet, kami bahkan tidak memiliki jejak tumpukan yang menunjukkan tempat untuk memulai pencarian. <br><br>  Arsitektur Bersih juga tidak dapat membantu kami.  Bahkan setelah kami menulis ulang modul obrolan, tes A / B menunjukkan perbedaan kecil namun signifikan dalam jumlah pesan dari pengguna yang menggunakan modul baru dan lama.  Kami memutuskan bahwa ini disebabkan oleh sulitnya reproduksi bug dan keadaan ras.  Perbedaan tetap ada setelah memeriksa semua faktor lainnya.  Kepentingan perusahaan menderita, sulit bagi pengembang untuk mempertahankan kode. <br><br>  Anda tidak dapat merilis komponen baru jika berfungsi lebih buruk dari yang sudah ada, tetapi Anda juga tidak bisa melepaskannya - karena butuh pembaruan, ada alasannya.  Jadi, Anda perlu memahami mengapa dalam sistem yang terlihat sangat normal dan tidak macet, jumlah pesan turun. <br><br>  Di mana memulai pencarian? <br><br>  Spoiler: ini bukan kesalahan Arsitektur Bersih - seperti biasa, faktor manusia yang harus disalahkan.  Pada akhirnya, tentu saja, kami memperbaiki bug ini, tetapi menghabiskan banyak waktu dan upaya untuk ini.  Kemudian kami berpikir: adakah cara yang lebih mudah untuk menghindari masalah ini? <br><br><h2>  Cahaya di ujung terowongan ... </h2><br>  Istilah modis seperti Model-View-Intent dan "aliran data searah" sudah tidak asing lagi bagi kami.  Jika ini tidak terjadi dalam kasus Anda, saya sarankan Anda untuk google mereka - ada banyak artikel tentang topik ini di Internet.  Pengembang Android terutama merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi delapan potong Hannes Dorfman</a> . <br><br>  Kami mulai bermain dengan ide-ide ini yang diambil dari pengembangan web pada awal 2017.  Pendekatan seperti Flux dan Redux ternyata sangat berguna - mereka membantu kami menangani banyak masalah. <br><br>  Pertama-tama, sangat berguna untuk memuat semua elemen state (variabel yang mempengaruhi UI dan memicu berbagai aksi) dalam satu objek - <b>State</b> .  Ketika semuanya disimpan di satu tempat, gambar keseluruhan terlihat lebih baik.  Misalnya, jika Anda ingin membayangkan memuat data menggunakan pendekatan ini, maka Anda memerlukan bidang <i>muatan</i> dan isian.  Melihat mereka, Anda akan melihat kapan data diterima ( <i>payload</i> ) dan apakah animasi ( <i>isLoading</i> ) ditampilkan kepada pengguna. <br><br>  Selanjutnya, jika kita beralih dari eksekusi kode paralel dengan panggilan balik dan menyatakan perubahan dalam status aplikasi sebagai serangkaian transaksi, kita akan mendapatkan satu titik masuk.  Kami hadir Anda <b>Reducer</b> , yang datang kepada kami dari pemrograman fungsional.  Dibutuhkan status saat ini dan data untuk tindakan lebih lanjut ( <b>Intent</b> ) dan membuat status baru dari mereka: <br><br> <code>Reducer = (State, Intent) -&gt; State</code> <br> <br>  Melanjutkan contoh sebelumnya dengan memuat data, kami mendapatkan tindakan berikut: <br><br><ul><li>  <b>MulaiMemuat</b> <br></li><li>  <b>Selesai dengan Sukses</b> <br></li></ul><br><br>  Kemudian Anda dapat membuat Reducer dengan aturan berikut: <br><br><ol><li>  Dalam kasus <b>StartingLoading,</b> buat objek <b>State</b> baru dengan menyalin yang lama dan atur nilainya <i>isLoading</i> ke true. <br></li><li>  Dalam kasus <b>FinishedWithSuccess,</b> buat objek <b>State</b> baru, salin yang lama, di mana nilai <i>isLoading</i> akan disetel ke false, dan nilai <i>payload</i> akan menjadi <br>  pertandingan diunggah. <br></li></ol><br>  Jika kami menampilkan seri <b>State yang</b> dihasilkan ke log, kami akan melihat yang berikut: <br><br><ol><li>  <i>Status</i> ( <i>payload</i> = null, <i>isLoading</i> = false) - status awal. <br></li><li>  <i>Status</i> ( <i>payload</i> = null, <i>isLoading</i> = true) - setelah StartingLoading. <br></li><li>  <i>Status</i> ( <i>payload</i> = data, <i>isLoading</i> = false) - setelah FinishedWithSuccess. <br></li></ol><br>  Dengan menghubungkan negara-negara ini ke UI, Anda akan melihat semua tahapan proses: pertama layar kosong, lalu layar pemuatan dan, akhirnya, data yang diperlukan. <br><br>  Pendekatan ini memiliki banyak keunggulan. <br><br><ul><li>  Pertama, dengan mengubah keadaan secara terpusat menggunakan serangkaian transaksi, kami tidak mengizinkan kondisi ras dan banyak bug yang mengganggu yang tidak terlihat. <br></li><li>  Kedua, setelah mempelajari serangkaian transaksi, kita dapat memahami apa yang terjadi, mengapa itu terjadi, dan bagaimana hal itu mempengaruhi keadaan aplikasi.  Selain itu, dengan Reducer, jauh lebih mudah untuk membayangkan semua perubahan status sebelum peluncuran pertama aplikasi pada perangkat. <br></li><li>  Akhirnya, kami dapat membuat antarmuka yang sederhana.  Karena semua status disimpan di satu tempat (Store), yang memperhitungkan niat akun (Intents), membuat perubahan menggunakan Reducer dan menunjukkan rantai status, maka Anda bisa meletakkan semua logika bisnis di Store dan menggunakan antarmuka untuk meluncurkan niat dan menampilkan status. <br></li></ul><br><br>  Atau tidak? <br><br><h2>  ... mungkin kereta bergegas ke arahmu </h2><br>  Peredam saja jelas tidak cukup.  Bagaimana dengan tugas yang tidak sinkron dengan hasil yang berbeda?  Bagaimana menanggapi push dari server?  Bagaimana dengan peluncuran tugas tambahan (misalnya, membersihkan cache atau memuat data dari database lokal) setelah perubahan status?  Ternyata kami tidak memasukkan semua logika ini dalam Reducer (yaitu, setengah dari logika bisnis tidak akan dibahas, dan itu harus diurus oleh mereka yang memutuskan untuk menggunakan komponen kami), atau kami memaksa Reducer untuk melakukan semuanya sekaligus. <br><br><h2>  Persyaratan Kerangka MVI </h2><br>  Tentu saja, kami ingin menyertakan seluruh logika bisnis dari fitur individual dalam komponen independen, yang dapat digunakan dengan mudah oleh pengembang dari tim lain dengan hanya membuat instance dan berlangganan ke kondisinya. <br><br>  Selain itu: <br><br><ul><li>  Seharusnya mudah berinteraksi dengan komponen lain dari sistem; <br></li><li>  dalam struktur internalnya harus ada pemisahan tugas yang jelas; <br></li><li>  semua bagian internal komponen harus sepenuhnya deterministik; <br></li><li>  implementasi dasar dari komponen semacam itu harus sederhana dan rumit hanya jika elemen tambahan diperlukan. <br></li></ul><br>  Kami tidak segera beralih dari Reducer ke solusi yang kami gunakan hari ini.  Setiap tim menghadapi masalah dengan menggunakan pendekatan yang berbeda, dan mengembangkan solusi universal yang cocok untuk semua orang tampaknya tidak mungkin. <br><br>  Namun, keadaan saat ini cocok untuk semua orang.  Kami senang memperkenalkan Anda MVICore!  Kode sumber perpustakaan terbuka dan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h2>  Apa yang baik MVICore </h2><br><ul><li>  Cara mudah untuk mengimplementasikan fitur bisnis pemrograman reaktif dengan aliran data searah. <br></li><li>  Penskalaan: implementasi dasar hanya mencakup Peredam, dan dalam kasus yang lebih kompleks, Anda dapat menggunakan komponen tambahan. <br></li><li>  Solusi untuk bekerja dengan acara yang tidak ingin Anda sertakan di negara bagian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah SingleLiveEvent</a> ). <br></li><li>  API sederhana untuk mengikat fitur (dan komponen reaktif lainnya dari sistem Anda) ke UI dan satu sama lain dengan dukungan untuk siklus hidup Android (dan tidak hanya). <br></li><li>  Dukungan Middleware (lihat di bawah) untuk setiap komponen sistem. <br></li><li>  Logger siap pakai dan kemampuan untuk melakukan debug perjalanan untuk setiap komponen. <br></li></ul><br><br><h2>  Pengantar Singkat untuk Fitur </h2><br>  Karena petunjuk langkah demi langkah telah diposting di GitHub, saya akan menghilangkan contoh terperinci dan fokus pada komponen utama kerangka kerja. <br><br>  <b>Fitur</b> - elemen utama dari kerangka kerja yang berisi semua logika bisnis komponen.  Fitur didefinisikan oleh tiga parameter: <i>Fitur antarmuka &lt;Wish, State, News&gt;</i> <br><br>  <b>Wish</b> sesuai dengan Intent dari Model-View-Intent - ini adalah perubahan yang ingin kita lihat dalam model (karena istilah Intent memiliki maknanya dalam lingkungan pengembang Android, kami harus menemukan nama yang berbeda).  Keinginan adalah titik masuk untuk Fitur. <br><br>  <b>Keadaan</b> adalah, seperti yang sudah Anda pahami, keadaan komponen.  Negara tidak dapat berubah: kita tidak dapat mengubah nilai-nilai internalnya, tetapi kita dapat menciptakan Negara baru.  Ini adalah output: setiap kali kita membuat negara baru, kita meneruskannya ke aliran Rx. <br><br>  <b>Berita</b> - komponen untuk memproses sinyal yang seharusnya tidak berada di Negara;  Berita digunakan sekali selama pembuatan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah SingleLiveEvent</a> ).  Menggunakan Berita adalah opsional (Anda dapat menggunakan Tidak Ada dari Kotlin di tanda tangan Fitur). <br><br>  Juga dalam Fitur harus ada <b>Reducer</b> . <br><br>  Fitur dapat mengandung komponen-komponen berikut: <br><br><ul><li>  Aktor - melakukan tugas asinkron dan / atau modifikasi kondisi bersyarat berdasarkan kondisi saat ini (misalnya, validasi formulir).  Aktor mengikat Wish ke nomor Efek tertentu, dan kemudian meneruskannya ke Reducer (tanpa adanya Aktor, Reducer menerima Wish secara langsung). <br></li><li>  NewsPublisher - Dipanggil ketika Wish menjadi Efek apa pun yang menghasilkan hasil sebagai Negara baru.  Berdasarkan data ini, ia memutuskan apakah akan membuat Berita. <br></li><li>  PostProcessor - juga dipanggil setelah membuat Negara baru dan juga tahu apa yang menyebabkan efek penciptaannya.  Ini meluncurkan tindakan tambahan tertentu (Tindakan).  Tindakan - ini adalah "Keinginan internal" (misalnya, membersihkan cache) yang tidak dapat dimulai dari luar.  Mereka dieksekusi di Aktor, yang mengarah ke rantai Efek dan Negara baru. <br></li><li>  Bootstrapper adalah komponen yang dapat menjalankan tindakan sendiri.  Fungsi utamanya adalah untuk menginisialisasi Fitur dan / atau menghubungkan sumber eksternal dengan Action.  Sumber eksternal ini dapat berupa Berita dari Fitur lain atau data server yang harus memodifikasi Status tanpa campur tangan pengguna. <br></li></ul><br><br>  Diagram ini mungkin terlihat sederhana: <br><img src="https://habrastorage.org/webt/mi/ed/e-/miede-fbfldwuqzgreeogizadww.png"><br><br>  atau sertakan semua komponen tambahan di atas: <br><img src="https://habrastorage.org/webt/0l/qy/my/0lqymyebiyer8saxybkbw_jzgdw.png"><br><br>  Fitur itu sendiri, yang berisi semua logika bisnis dan siap digunakan, terlihat lebih mudah: <br><br><img src="https://habrastorage.org/webt/gt/p2/ww/gtp2wwiqcxsrvavsrndirvt0_dg.png"><br><br><h2>  Apa lagi </h2><br>  Fitur, landasan kerangka kerja, bekerja pada tingkat konseptual.  Tetapi perpustakaan memiliki lebih banyak untuk ditawarkan. <br><br><ul><li>  Karena semua komponen Fitur bersifat deterministik (dengan pengecualian Aktor, yang tidak sepenuhnya deterministik karena berinteraksi dengan sumber data eksternal, tetapi bahkan dengan itu, cabang yang dijalankan ditentukan oleh data input, dan bukan oleh kondisi eksternal), masing-masing dapat dibungkus dalam Middleware.  Pada saat yang sama, perpustakaan sudah berisi solusi yang sudah jadi untuk logging dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">debugging perjalanan waktu</a> . </li><li>  Middleware berlaku tidak hanya untuk Fitur, tetapi juga untuk objek lain yang mengimplementasikan antarmuka &lt;T&gt; Konsumen, yang menjadikannya alat debugging yang sangat diperlukan. </li><li>  Saat menggunakan debugger untuk debugging sambil bergerak ke arah yang berlawanan, Anda dapat mengimplementasikan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DebugDrawer</a> . </li><li>  Pustaka menyertakan plugin IDEA yang dapat digunakan untuk menambahkan templat untuk implementasi Fitur yang paling umum, yang menghemat banyak waktu. </li><li>  Ada kelas pembantu untuk mendukung Android, tetapi perpustakaan itu sendiri tidak terikat dengan Android. </li><li>  Ada solusi yang sudah jadi untuk mengikat komponen ke UI dan satu sama lain melalui API dasar (ini akan dibahas dalam artikel berikutnya). </li></ul><br>  Kami harap Anda akan mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> kami dan penggunaannya akan membawa Anda sebanyak kesenangan seperti kami - pembuatannya! <br><br><blockquote>  Pada 24 dan 25 November, Anda dapat mencoba dan bergabung dengan kami!  Kami akan mengadakan acara perekrutan seluler: dalam satu hari akan memungkinkan untuk melalui semua tahap seleksi dan menerima penawaran.  Rekan-rekan saya dari tim iOS dan Android akan datang untuk berkomunikasi dengan para kandidat di Moskow.  Jika Anda berasal dari kota lain, Badoo dikenai biaya perjalanan.  Untuk mendapatkan undangan, ikuti tes penyaringan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di tautan</a> .  Semoga beruntung </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429728/">https://habr.com/ru/post/id429728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429716/index.html">5 game PC terbaik untuk belajar bahasa Inggris</a></li>
<li><a href="../id429718/index.html">Saya ingin semuanya sekaligus! Kami mempelajari RAM HyperX Predator DDR4 RGB, dengan frekuensi 4000 MHz</a></li>
<li><a href="../id429720/index.html">Bagaimana cara pengembang pemula untuk bertahan dalam sebuah wawancara dan tidak menjadi gila di tempat kerja</a></li>
<li><a href="../id429722/index.html">Bagaimana kami melakukan pembayaran melalui Google Pay di Yandex.Cash [diperbarui]</a></li>
<li><a href="../id429724/index.html">Ulasan yang bermanfaat. 28 buku yang memengaruhi pemikiran saya, mengilhami, atau menjadi lebih baik</a></li>
<li><a href="../id429732/index.html">Anda akan membenci ini atau dongeng tentang bagaimana kode yang baik seharusnya terlihat</a></li>
<li><a href="../id429734/index.html">Mimpi terbang dengan bias listrik</a></li>
<li><a href="../id429736/index.html">Hogweed dari Sosnowski. Di MO diperkenalkan denda untuk distribusi</a></li>
<li><a href="../id429738/index.html">Pengaturan Shard Optimal dalam Elasticsearch Petabyte Cluster: Linear Programming</a></li>
<li><a href="../id429744/index.html">Pelajari OpenGL. Pelajaran 6.4 - IBL. Paparan specular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>