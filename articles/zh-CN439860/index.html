<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👓 🌰 🔐 ZFS上的Ubuntu 18.04根目录 🙋🏾 🏚️ 🏨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="去年，我需要创建有关安装Ubuntu 18.04操作系统的说明。 顺便说一句，安装Ubuntu并不复杂，但有一个细微差别：我想使用ZFS文件系统作为基础。 一方面，Ubuntu在内核级别支持ZFS，但尚无安装程序，但有一条说明，可以： 


 https://github.com/zfsonlinu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZFS上的Ubuntu 18.04根目录</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439860/"><p> 去年，我需要创建有关安装Ubuntu 18.04操作系统的说明。 顺便说一句，安装Ubuntu并不复杂，但有一个细微差别：我想使用ZFS文件系统作为基础。 一方面，Ubuntu在内核级别支持ZFS，但尚无安装程序，但有一条说明，可以： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/zfsonlinux/zfs/wiki/Ubuntu-18.04-Root-on-ZFS</a> </p><br><p> 本手册中的操作顺序通常是正确的，但某些方面需要调整。 因此，以下内容不是对说明的直接翻译，而是免费的，并考虑到更正，我在ZFS方面的经验和其他方面。 我也不考虑磁盘加密问题，而是使用MBR引导加载程序。 我的安装说明可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>获得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </p><br><a name="habracut"></a><br><h2><blockquote>  0.服务器准备 </blockquote></h2><br><p>指令中缺少的第一件事是，无论如何都没有考虑到ZFS不能与硬件RAID阵列很好地配合，特别是它与Write cache连接在一起，这是可以理解的：ZFS文件系统已记录日记并且需要对写操作进行完全控制。 同样，当使用现成的硬件RAID阵列时，ZFS功能在缓存，备用等方面也会丢失。 因此，必须将所有磁盘都转移到HBA模式，如果不可能，则为每个磁盘创建单独的RAID并禁用写缓存控制器。 </p><br><p> 另外，在使用网络端口聚合时，可以在安装阶段将其禁用，以免使其复杂化（我将执行所有进一步的操作而无需绑定）。 </p><br><h2>  1.准备安装环境 </h2><br><h3>  1.1。 直播光盘 </h3><br><p> 如前所述，不幸的是，在ZFS上没有使用root的现成的Ubuntu安装程序，因此使用LiveCD光盘进行安装： </p><br><p> 从此处下载： <a href="">http</a> : <a href="">//releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</a> </p><br><blockquote> 同时，我与同事一起尝试使用各种磁盘映像，因为我确实不想使用图形化外壳，但这并没有带来什么好处。 </blockquote><br><p> 我们从LiveCD启动，选择Try Ubuntu，然后打开终端（Ctrl + Alt + T）。 </p><br><h3>  1.2。 更新和安装存储库 </h3>  '' <br><pre><code class="bash hljs">sudo apt-add-repository universe sudo apt update</code> </pre> <br><blockquote> 如果服务器的网络设置不是由DHCP确定的，则在这里等待第一个失败者。 更新存储库将不起作用，因此让我们设置网络。 </blockquote><br><p> 我们查看网络接口，并找到用于连接的接口： </p><br><pre> <code class="bash hljs">sudo ip a</code> </pre> <br><p> 配置网络接口： </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"auto {{ NAME }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"iface {{ NAME }} inet static"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" address {{ IP }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" netmask {{ NETMASK }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" gateway {{ GATEWAY }}"</span></span> &gt;&gt; /etc/network/interfaces sudo service networking restart</code> </pre><br><p> 和DNS解析器： </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'nameserver 8.8.8.8'</span></span> &gt;&gt; /etc/resolv.conf</code> </pre> <br><p> 更新存储库： </p><br><pre> <code class="bash hljs">sudo apt update</code> </pre> <br><h3>  1.3。  SSH服务器（可选） </h3><br><p> 为了便于安装，您可以提升OpenSSH服务器并通过SSH客户端执行所有进一步的操作 </p><br><p> 设置ubuntu用户的密码： </p><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote> 这很重要！ 否则，将通过不带sudo权限的密码进行ssh访问。 但是，您无法设置简单的密码。 </blockquote><br><p> 安装并运行OpenSSH： </p><br><pre> <code class="bash hljs">sudo apt install openssh-server sudo service ssh start</code> </pre> <br><p> 在工作站的终端中： </p><br><pre> <code class="bash hljs">ssh ubuntu@{{ ip server }}</code> </pre> <br><h3>  1.4。 成为根 </h3><br><pre> <code class="bash hljs">sudo -s</code> </pre> <br><h3>  1.5。 在LiveCD环境中安装ZFS支持 </h3><br><pre> <code class="bash hljs">apt install --yes debootstrap gdisk zfs-initramfs</code> </pre> <br><h2>  2.分区和格式化硬盘 </h2><br><h3><blockquote>  2.0。 定义磁盘阵列 </blockquote></h3><br><p> 主要说明不包含有关如何确定磁盘阵列的重点。 </p><br><p> 通常，服务器上的磁盘数为： </p><br><ul><li>  2个磁盘； </li><li>  4张碟片; </li><li> 许多磁盘； </li></ul><br><p> 我们不考虑1个磁盘，因为它通常是异常的。 </p><br><h4>  2.0.1。  2碟 </h4><br><p> 这里的一切都很简单，只有一个MIRROR阵列（RAID1）。 如果还有另一个驱动器，则可以将其放入热备用（SPARE）或组装RAIDZ阵列（RAID5）。 但是服务器中只有3个磁盘很少。 </p><br><h4>  2.0.2。  4碟 </h4><br><p> 如果所有驱动器都相同，则只有三个选项（我基本上不考虑第四个RAID0）： </p><br><ul><li>  MIRROR + MIRROR是RAID10（更确切地说是RAID01）的类似物，因为在ZFS中它是mirror + mirror。  50％的可用磁盘空间； </li><li>  RAIDZ是RAID5的类似物。  75％的可用磁盘空间； </li><li>  RAIDZ2是RAID6的类似物。  50％的可用磁盘空间； </li></ul><br><p> 在实践中，我使用MIRROR + MIRROR阵列，但很显然RAIDZ阵列最有利可图，因为它提供了更多的磁盘空间，但是有细微差别 </p><br><p> 在容错方面，阵列按以下顺序排列（从最佳到最差）： </p><br><ul><li>  RAIDZ2-两个磁盘可能会丢失而不会丢失数据； </li><li>  MIRROR + MIRROR-一个磁盘可能会丢失而不会丢失数据，而另一磁盘有66％的概率可能会丢失而不会丢失数据； </li><li>  RAIDZ-只有一个磁盘可以丢失而不会丢失数据； </li></ul><br><p> 在速度方面，数组按以下顺序排列： </p><br><ul><li>  MIRROR + MIRROR-在写作和阅读方面； </li><li>  RAIDZ-在记录方面较慢，因为除了记录外，还需要计算校验和； </li><li>  RAIDZ2 –就写入而言甚至更慢，因为它需要计算更复杂的校验和； </li></ul><br><p> 就一个磁盘降级期间的阵列速度而言： </p><br><ul><li>  MIRROR + MIRROR（镜像+镜像）-当一个驱动器掉线时，基本上只有一个镜像的并行读取丢失，第二个镜像正常工作而性能不会降低； </li><li>  RAIDZ2-性能下降的幅度更高，因为它需要从校验和中向后分配1/4的数据+块搜索； </li><li>  RAIDZ-降级要大得多，因为它需要从1/3的数据+块搜索的校验和中重新计算块； </li></ul><br><p> 比较特性是主观的，但足以反映出我作为中间立场的选择。 </p><br><p> 同时，您需要了解“慢”和“甚至慢”并非有时，但在最坏的情况下只有10％到20％，因此，如果未优化用于磁盘的数据库或应用程序，则会降低速度原则上，不要注意。 仅在真正需要时才考虑记录速度因数。 </p><br><h4>  2.0.2。 许多碟片 </h4><br><p> 主要问题是，如果我们有很多磁盘，并且想要为所有磁盘创建一个通用阵列，那么我们将需要在每个磁盘上标记引导扇区，或者对我们的耳朵做些伪装。 在实践中，对于多碟平台，我尝试构建此配置： </p><br><ul><li>  2个SSD磁盘-我们创建一个镜像，并作为第二引导磁盘阵列的操作系统和ZFS高速缓存的主引导阵列； </li><li> 其余的都被SATA或SAS磁盘阻塞，并且没有标记，我们收集了ZFS磁盘阵列。 </li></ul><br><p> 如果我们要获得一个相当通用的平台，则同样适用于4磁盘服务器。 </p><br><p> 如果磁盘都是相同的，并且没有必要为单独的阵列分配两个磁盘（例如，每个磁盘6个磁盘，每个磁盘8 Tb），则可以使阵列第一组的磁盘可引导。 也就是说，如果您要创建一个数组，例如：MIRROR + MIRROR + MIRROR或RAIDZ + RAIDZ，那么我们仅标记第一组的引导扇区。 原则上，即使对于MIRROR和RAIDZ，也可以只对一个驱动器进行分区，并以原始形式替换其余驱动器，ZFS会通过较小的元素本身来创建阵列，但是在这种情况下，如果第一个驱动器发生故障，则您将丢失唯一的启动磁盘，因此值得这样做。 </p><br><p> 重要的是要了解，在ZFS-条带文件系统中，这并非完全是RAID0，它的工作方式略有不同，并且不需要相同的磁盘大小，因此为天气的引导扇区分配较小的空间不会有太大作用，主要是在BIOS中指示从中引导的正确磁盘。 </p><br><h3>  2.1。 分区和磁盘清理 </h3><br><p>  mdadm软件包用于标记磁盘，将其放入： </p><br><pre> <code class="bash hljs">apt install --yes mdadm</code> </pre> <br><p> 我们看一下可用的光盘： </p><br><pre> <code class="bash hljs">lsblk</code> </pre> <br><p> 并清洁它们： </p><br><pre> <code class="bash hljs">sgdisk --zap-all /dev/{{ disk name }}</code> </pre> <br><h3>  2.2。 磁盘布局 </h3><br><p> 实际上，引导分区： </p><br><pre> <code class="bash hljs">sgdisk -a1 -n1:34:2047 -t1:EF02 /dev/{{ disk name }}</code> </pre> <br><p> 主要部分。 </p><br><blockquote> 这里可能会有变化：如果您需要分配额外的SSD磁盘分区（例如，用于ZFS Cache或Aerospike），则将主分区设为有限的卷： </blockquote><br><pre> <code class="bash hljs">sgdisk -n2:0:+100GB -t2:BF01 /dev/{{ disk name }} sgdisk -n3:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre><br><p> 如果我们使用了所有空间，那么只需为剩余空间创建一个部分： </p><br><pre> <code class="bash hljs">sgdisk -n2:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre> <br><p> 不要忘记检查结果： </p><br><pre> <code class="bash hljs">lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk ├─sda1 8:1 0 1007K 0 part └─sda2 8:2 0 1.8T 0 part sdb 8:16 0 1.8T 0 disk ├─sdb1 8:17 0 1007K 0 part └─sdb2 8:18 0 1.8T 0 part ...</code> </pre><br><h3>  2.3。 创建一个ZFS阵列 </h3><br><pre> <code class="bash hljs">zpool create \ -o ashift=12 \ -O atime=off \ -O canmount=off \ -O compression=lz4 \ -O checksum=fletcher4 \ -O normalization=formD \ -m legacy \ -R /mnt \ -f \ tank \ mirror \ /dev/{{ disk a part 2}} \ /dev/{{ disk b part 2}}</code> </pre> <br><blockquote> 我熟悉的管理员立即介入的第一个步骤是，在创建ZFS阵列时，如果不是专门为此创建磁盘，则需要指定磁盘而不是磁盘分区。 </blockquote><br><p> 接下来，依次： </p><br><ul><li>  ashift = 12-使用4K的块大小，原则上，我仍然不明白为什么在操作系统中实际上没有这样的磁盘时，默认的块大小通常为512字节； </li><li>  atime = off-禁止更新对文件的访问日期，我总是将其关闭，因为我从未真正需要此信息，并且不需要再次加载内核； </li><li>  canmount = off-禁用挂载根分区的功能； </li><li>  compression = lz4-使用LZ4算法启用数据压缩。 建议包含此参数，不仅可以节省磁盘空间，还可以减少I / O操作的数量。 同时，对于这种压缩算法，CPU利用率极低； </li><li>  checksum = fletcher4-默认的校验和算法，因此fletcher4值得再次检查； </li><li> 标准化= formD-用于改进UTF-8的工作，实际上限制了使用非UTF-8文件名的可能性。 在这里，每个人都可以自己决定，在我们的工作中，我们始终仅使用UTF-8编码； </li><li>  xattr = sa-使用扩展属性加速工作。 由于不使用此选项，因此禁用了与其他OpenZFS实现的兼容性（例如：FreeBSD），因此我不使用该选项。 与Windows兼容，顺便说一下，我需要。 此外，可以在最后一节中启用此选项。 </li><li>  -m legacy-挂载点到无处，无需挂载根分区； </li><li>  -R / mnt-用于安装内核的临时分区安装前缀； </li><li>  -f-强制创建数组。 如果ZFS阵列以前是在磁盘上收集的，那么create命令将无法工作，您永远不会知道，也许您犯了一个错误并且想要擦除重要数据； </li></ul><br><blockquote><p> 我习惯性地将根系统磁盘阵列的名称表示为tank，尽管目前他们更喜欢在Linux环境中使用名称rpool（根池）。 在我的实践中，我通常使用以下数组命名： </p><br><ul><li>  tank-主系统阵列； </li><li> 存储-具有大磁盘的另一个阵列，用于存储数据； </li><li> 缓存-主磁盘不在主分区上时，SSD磁盘的另一个阵列； </li></ul><br><p> 总的来说，我强烈建议立即开发一种命名方式，以免混淆。 </p></blockquote><br><h2>  3.系统安装 </h2><br><h3>  3.1。 和3.2。 创建一个根文件系统 </h3><br><blockquote> 我专门合并了第3.1款。 和3.2。 因为我认为在第三级指定根分区绝对是多余的。 没错，在使用ZFS的几年中，我从未需要对根分区进行任何操作。 此外，有些图片可用于控制点。 因此，我的根部分是tank / root： </blockquote><br><pre> <code class="bash hljs">zfs create -o mountpoint=/ tank/root</code> </pre> <br><blockquote> 同时，在原始指令中检测到第一个致命错误，即磁盘阵列缺少启动分区： </blockquote><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> bootfs=tank/root tank</code> </pre> <br><h3>  3.3。 创建其他分区 </h3><br><blockquote><p> 在这部分基本说明中，您可以丢掉一切而忘记。 伙计们显然在压榨和选择上超过了它，因此，在此过程中，我不得不解决一些问题。 没错，没什么用。 由于后来又出现了问题，最终证明这一切都不起作用，因此在第4.11段中。 再次纠正。 </p><br><p> 为/ var / games分开一个单独的部分看起来很史诗。 我不介意，但这显然太多了。 </p><br><p> 仅在ZFS中创建分区并支持层次结构的事实并不意味着应该放弃经典目录。 一个简单的例子：服务器组上曾经有多个4K ZFS分区，这是必要的，但是由于安装了这些分区，服务器重启速度降低了几分钟。 </p></blockquote><br><p> 让我们从一个干净的开始。 </p><br><p> 有静态和动态文件分区。 </p><br><p> 静态文件部分包括带有程序及其设置的部分，它们被填充一次，并且在操作期间不会更改。 同时，早期的静态分区被划分为系统分区和用户分区（/ usr），但目前它们混在Linux操作系统中，没有任何区分的余地，并且无法解决。 </p><br><p> 动态文件部分包括存储以下部分： </p><br><ul><li> 临时数据-eq.：tmp、swap； </li><li> 工作日志-eq。：var / log; </li><li> 用户数据-eq .: home; </li><li> 数据-eq .： var / db以及如何幸运； </li><li> 其他程序结果以文件形式出现； </li></ul><br><p> 在Linux家族中，动态分区包括/ tmp和/ var，但这并不准确，因为它们可以进入/ var / lib，程序和库，一般来说，所有内容都是混杂的，但是... </p><br><p> 首先，您需要确定是在磁盘上还是在内存中将/ tmp分区创建为tmpfs。 如果我们在磁盘上创建，则为其创建一个单独的分区： </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/tmp</code> </pre> <br><blockquote> 选项com.sun：自动快照=错误的setuid =很好，无论天气如何，都不会变得复杂。 但是，使用SWAP，我们将在后面的步骤7中进行操作。 </blockquote><br><p> 分别将var部分分开： </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/var</code> </pre> <br><p> 和用户部分： </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=/home tank/home zfs create -o mountpoint=legacy tank/home/root</code> </pre> <br><blockquote> 分配用户分区是很有意义的，因为实际上它们会定期被不同的工件阻塞，并且为了便于监视它们，最​​好为它们创建单独的分区以及根用户的主目录（尤其是对于那些以root身份工作的用户）。 在用户目录上使用配额不仅无助于阻塞磁盘空间，而且会造成干扰，因为在这种情况下，用户开始将工件留在任何地方，以后很难找到它们。 这没有得到处理，因此您只需要控制并击败双手。 </blockquote><br><p>  mount point tank / home / root被列为旧版，而不是/ root。 这是正确的，因为本节的安装在第4.11节中进行 </p><br><p> 现在我们需要在/ mnt中临时挂载动态分区： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /mnt/ mkdir var tmp root mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><h3>  3.4安装内核 </h3><br><blockquote> 在主要指令中，还有另外两个不必要的命令，我们没有注意，显然是实验工件： </blockquote><br><pre> <code class="bash hljs">debootstrap bionic /mnt</code> </pre> <br><p> 结果，您应该获得如下信息： </p><br><pre> <code class="bash hljs">zfs list NAME USED AVAIL REFER MOUNTPOINT tank 213M 1.76T 96K legacy tank/home 208K 1.76T 96K /mnt/home tank/home/root 112K 1.76T 112K legacy tank/root 147M 1.76T 147M /mnt tank/tmp 96K 1.76T 96K legacy tank/var 64.6M 1.76T 64.6M legacy</code> </pre><br><p> 空的96K分区的大小分别只有tank / tmp保持为空，其余的则在内核安装过程中记录下来，这意味着分区已正确安装。 </p><br><h2>  4.系统配置 </h2><br><h3>  4.1。 配置主机和主机名 </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> HOSTNAME &gt; /mnt/etc/hostname <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> “127.0.0.1 localhost” &gt; /mnt/etc/hosts <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> “127.0.0.1 HOSTNAME” &gt;&gt; /mnt/etc/hosts</code> </pre> <br><h3>  4.2。 配置网络接口 </h3><br><blockquote> 是的，我们已经在这里使用了netplan： </blockquote><br><pre> <code class="bash hljs">nano /mnt/etc/netplan/setup.yaml network: version: 2 renderer: networkd ethernets: eno2: dhcp4: no dhcp6: no addresses: [ {{ IP }}/{{ netmask }}, ] gateway4: {{ gateway IP }} nameservers: addresses: [8.8.8.8]</code> </pre> <br><h3>  4.3。 配置apt存储库 </h3><br><pre> <code class="bash hljs">nano /mnt/etc/apt/sources.list deb http://archive.ubuntu.com/ubuntu/ bionic main restricted universe deb http://security.ubuntu.com/ubuntu/ bionic-security main restricted universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe</code> </pre> <br><blockquote>  src-大多不需要 </blockquote><br><h3>  4.4。 我们将虚拟文件部分LiveCD装入并“转到”新系统 </h3><br><pre> <code class="bash hljs">mount --rbind /dev /mnt/dev mount --rbind /proc /mnt/proc mount --rbind /sys /mnt/sys chroot /mnt /bin/bash --login</code> </pre><br><blockquote> 需要使用-rbind，但不使用-绑定 </blockquote><br><p> 我们已经在新系统中... </p><br><h3>  4.5。 设置基础环境 </h3><br><pre> <code class="bash hljs">ln -s /proc/self/mounts /etc/mtab chmod 1777 /tmp apt update</code> </pre> <br><p> 地区和时间： </p><br><pre> <code class="bash hljs">dpkg-reconfigure locales * en_US.UTF-8 * ru_RU.UTF-8 dpkg-reconfigure tzdata</code> </pre> <br><p> 以及喜欢以下内容的其他编辑： </p><br><pre> <code class="bash hljs">apt install --yes vim nano</code> </pre> <br><h3>  4.6。 安装ZFS支持 </h3><br><pre> <code class="bash hljs">apt install --yes --no-install-recommends linux-image-generic apt install --yes zfs-initramfs</code> </pre> <br><h3>  4.8。 安装引导程序 </h3><br><p> 如前所述，我使用的是过时的MBR： </p><br><pre> <code class="bash hljs">apt install --yes grub-pc</code> </pre> <br><blockquote> 在安装引导加载程序的过程中，需要选择我们确定为可引导的所有磁盘，而安装程序会在除第一个磁盘以外的所有其他磁盘上发誓，我们同意并执行第5步（尚不清楚为什么其余磁盘留待以后使用）： </blockquote><br><h4>  4.8.1。  （5.1）检查是否已识别根文件系统： </h4><br><pre> <code class="bash hljs">grub-probe / zfs</code> </pre> <br><h4>  4.8.2。  （5.2）更新initrd </h4><br><pre> <code class="bash hljs">update-initramfs -u -k al</code> </pre> <br><h4>  4.8.3。  （5.3）简化GRUB调试 </h4><br><pre> <code class="bash hljs">vi /etc/default/grub ... GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string"><span class="hljs-string">""</span></span> GRUB_CMDLINE_LINUX=<span class="hljs-string"><span class="hljs-string">"console"</span></span> ...</code> </pre><br><h4>  4.8.4。  （5.4。）更新引导程序配置 </h4><br><pre> <code class="bash hljs">update-grub</code> </pre> <br><h4>  4.8.5。  （5.5。）在标记为可引导的每个磁盘上安装引导加载程序 </h4><br><pre> <code class="bash hljs">grub-install /dev/sda grub-install /dev/sdb ...</code> </pre><br><blockquote> 这些命令必须正常工作，这一点很重要。 老实说，我至少不会遇到相反的情况，所以我不知道该怎么做，但是最有可能的是，如果遇到错误，则标记磁盘时可能做错了什么（第2.2节）。 </blockquote><br><h4>  4.8.6。  （5.6。）检查是否已安装ZFS模块 </h4><br><pre> <code class="bash hljs">ls /boot/grub/*/zfs.mod /boot/grub/i386-pc/zfs.mod</code> </pre> <br><h3>  4.10。 设置根密码（很难！） </h3><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote> 是的，我们将立即安装openssh，否则，如果我们进行远程工作，则重启后会感到惊讶： </blockquote><br><pre> <code class="bash hljs">apt install --yes openssh-server</code> </pre> <br><p> 不要忘记更正sshd配置： </p><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin yes ... PasswordAuthentication yes ...</code> </pre> <br><h3>  4.11。 修复挂载文件系统 </h3><br><blockquote> 在这里，我们得到了最有趣的东西。 事实是，ZFS分区是在某些守护程序启动后挂载的（我们还在/ etc / default / zfs中摇摆了ZFS_INITRD_ADDITIONAL_DATASETS），这反过来又在/ var中自行创建了一些结构，从而开始填充系统日志。 挂载ZFS分区的时间到了，事实证明挂载点不是空的，没有挂载，数据分散了，一切都不好了。 因此，您需要在/ etc / fstab中指定安装点，因为systemd在访问文件夹时主要关注它们： </blockquote><br><pre> <code class="bash hljs">vi /etc/fstab tank/var /var zfs noatime,nodev 0 0 tank/tmp /tmp zfs noatime,nodev 0 0 tank/home/root /root zfs noatime,nodev 0 0</code> </pre> <br><blockquote> 其余的取决于第6条。 已经完成 </blockquote><br><h2>  6.第一次重启 </h2><br><h3>  6.1。 拍下根分区的照片 </h3><br><pre> <code class="bash hljs">zfs snapshot tank/root@setup</code> </pre> <br><blockquote> 他没有道理，在实践中我从未动摇过系统的根分区，也从未使用过该分区的快照，但是尽管如此，它可能会派上用场 </blockquote><br><h3>  6.2。 退出chroot </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br><h3>  6.3。 卸载LiveCD分区并导出ZFS阵列 </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> mount | grep -v zfs | tac | awk <span class="hljs-string"><span class="hljs-string">'/\/mnt/ {print $3}'</span></span> | xargs -i{} umount -lf {} umount /mnt/root umount /mnt/var umount /mnt/tmp zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> tank</code> </pre> <br><blockquote> 需要磁盘阵列导出以清除zfs缓存 </blockquote><br><h3>  6.4重启 </h3><br><blockquote> 重新启动最好在LiveCD终端中完成，因为如果通过ssh客户端进行工作，则通过它重新启动可能导致服务器“冻结”。 </blockquote><br><pre> <code class="bash hljs">reboot</code> </pre> <br><blockquote> 但是，如果出了什么问题并且服务器没有重新引导，则可以以任何方式重新引导，因为ZFS阵列已导出并且很难损坏它。 </blockquote><br><h3>  6.5。 我们正在等待重新启动并以root身份进入 </h3><br><h3>  6.6。 创建您的用户帐户 </h3><br><pre> <code class="bash hljs">zfs create tank/home/{{ LOGIN }} useradd -u {{ UID }} -G adm,sudo -d /home/{{ LOGIN }}/ -s /bin/bash {{ LOGIN }} cp -a /etc/skel/.[!.]* /home/{{ LOGIN }} chown -R {{ LOGIN }}:{{ LOGIN }} /home/{{ LOGIN }}</code> </pre> <br><p> 将公共ssh密钥添加到用户并为其设置密码： </p><br><pre> <code class="bash hljs">su - {{ LOGIN }} mkdir .ssh chmod 0700 .ssh vi .ssh/authorized_keys <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> passwd {{ LOGIN }}</code> </pre> <br><blockquote> 在OpenSSH中，我们删除了以root和密码身份验证登录的功能： </blockquote><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin no ... PubkeyAuthentication yes ... PasswordAuthentication no ... service ssh restart</code> </pre> <br><h3>  6.7。  6.8。 不再需要 </h3><br><h2>  7.配置交换 </h2><br><h3>  7.1。 创建一个ZFS分区 </h3><br><pre> <code class="bash hljs">zfs create \ -V 32G \ -b $(getconf PAGESIZE) \ -o compression=<span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> \ -o logbias=throughput \ -o sync=always \ -o primarycache=metadata \ -o secondarycache=none \ tank/swap</code> </pre> <br><ul><li>  -V 32G-我们SWAP的大小，您可以确定真正需要的那个； </li><li>  -b $（getconf PAGESIZE）-块大小（ashift = 12时为4K）; </li><li> 压缩= zle-选择在资源消耗方面最小的压缩算法，因为实际上块大小为4K，因此这样的压缩将不允许利用输入输出，但是有可能节省零块； </li><li>  logbias =吞吐量-设置带宽以优化同步操作； </li><li>  sync = always-始终同步记录。 这会稍微降低性能，但是会完全保证数据的可靠性。 </li><li>  primarycache =元数据-仅缓存元数据，因为交换不会多次读取同一块数据； </li><li>  secondarycache = none-由于上述原因，完全禁用辅助缓存； </li></ul><br><h3>  7.2。 设置交换分区 </h3><br><pre> <code class="bash hljs">mkswap -f /dev/zvol/tank/swap <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> /dev/zvol/tank/swap none swap defaults 0 0 &gt;&gt; /etc/fstab <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> RESUME=none &gt; /etc/initramfs-tools/conf.d/resume</code> </pre><br><h3>  7.3。 开启交换 </h3><br><pre> <code class="bash hljs">swapon -av</code> </pre> <br><blockquote><p> 进一步讲解并没有太多有趣的地方，因为它很大程度上取决于特定管理员的偏好以及整个服务器的任务，只有一点，即：“紧急启动” </p><p> 并且不要忘记放防火墙 </p></blockquote><br><h2>  R.紧急启动 </h2><br><p> 我们准备安装环境（项目1）。 </p><br><p> 在准备过程中，将导入ZFS阵列，因此您需要使用正确的安装点重新导入它： </p><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> -a zpool import -N -R /mnt tank zfs mount -a</code> </pre> <br><blockquote> , ,      ,        fstab,    : </blockquote><br><pre> <code class="bash hljs">mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><p> ,   ,   chroot   .4.4.,          . 6.3. </p><br><h2> D.   </h2><br><p>   3.3.             .      ,        : ,       /spool,      /data.       ZFS     . </p><br><h2> 总结 </h2><br><ul><li>       ZFS  ,     ,     ; </li><li>        ZFS,                 ,     .    ZFS —       ,   ; </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439860/">https://habr.com/ru/post/zh-CN439860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439850/index.html">使用神经网络的文本对话中的情境情感检测</a></li>
<li><a href="../zh-CN439852/index.html">远程控制应用程序版本：Aspia 1.1.0</a></li>
<li><a href="../zh-CN439854/index.html">嗯，又一次，一次：客户购买后如何处理CRM中的客户</a></li>
<li><a href="../zh-CN439856/index.html">Yandex！ 感谢Uber</a></li>
<li><a href="../zh-CN439858/index.html">Azure中的Prometheus + Grafana + Node Exporter + Docker和Telegram中的通知</a></li>
<li><a href="../zh-CN439862/index.html">2月11日至17日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN439864/index.html">知识管理，我们为什么以及如何做到</a></li>
<li><a href="../zh-CN439866/index.html">1C企业管理2（ERP 2.4.6）中设计目录的设计原则</a></li>
<li><a href="../zh-CN439868/index.html">没有Facebook的生活：不太激进的观点，良好的心情，更多的时间给亲人。 现在已经被科学证明</a></li>
<li><a href="../zh-CN439870/index.html">视频是进步的动力：监视系统的发展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>