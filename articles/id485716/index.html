<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üñãÔ∏è üöÖ Calico untuk berjejaring di Kubernetes: berkenalan dan sedikit pengalaman ‚úäüèª ‚òëÔ∏è üç¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tujuan artikel ini adalah untuk memperkenalkan pembaca pada dasar-dasar jaringan dan mengelola kebijakan jaringan di Kubernetes, serta plug-in Calico ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Calico untuk berjejaring di Kubernetes: berkenalan dan sedikit pengalaman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/485716/"><img src="https://habrastorage.org/webt/ij/rp/cx/ijrpcxvves8bmv7mgj1uc-ycrvs.png"><br><br>  Tujuan artikel ini adalah untuk memperkenalkan pembaca pada dasar-dasar jaringan dan mengelola kebijakan jaringan di Kubernetes, serta plug-in Calico pihak ketiga yang memperluas fitur standar.  Sepanjang jalan, kenyamanan konfigurasi dan beberapa fitur akan ditunjukkan pada contoh nyata dari pengalaman operasi kami. <a name="habracut"></a><br><br><h2>  Pengantar cepat ke perangkat jaringan Kubernetes </h2><br>  Cluster Kubernetes tidak dapat dibayangkan tanpa jaringan.  Kami telah menerbitkan materi tentang dasar-dasar mereka: " <a href="https://habr.com/ru/company/flant/blog/346304/">Sebuah Panduan Ilustrasi untuk Jaringan di Kubernetes</a> " dan " <a href="https://habr.com/ru/company/flant/blog/443190/">Pengantar Kebijakan Jaringan Kubernetes untuk Profesional Keamanan</a> ". <br><br>  Dalam konteks artikel ini, penting untuk dicatat bahwa K8 tidak bertanggung jawab atas konektivitas jaringan antara kontainer dan node: semua jenis <b>plugin CNI</b> (Container Networking Interface) digunakan untuk ini.  Kami <a href="https://habr.com/ru/company/flant/blog/329830/">juga berbicara</a> lebih banyak tentang konsep ini. <br><br>  Misalnya, yang paling umum dari plug-in ini - <a href="https://github.com/coreos/flannel">Flannel</a> - menyediakan konektivitas jaringan penuh antara semua node cluster dengan mengangkat jembatan pada setiap node, mengamankan subnet untuk itu.  Namun, ketersediaan penuh dan tidak diatur tidak selalu berguna.  Untuk memberikan beberapa isolasi minimal dalam cluster, perlu campur tangan dalam konfigurasi firewall.  Dalam kasus umum, ini diberikan kepada manajemen CNI, karena gangguan pihak ketiga dalam iptables dapat diartikan salah atau diabaikan sama sekali. <br><br>  Dan di luar kotak, <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/"><b>NetworkPolicy API</b></a> disediakan untuk mengatur manajemen kebijakan jaringan di kluster Kubernetes.  Sumber daya ini, yang meluas ke ruang nama yang dipilih, dapat berisi aturan untuk membatasi akses dari satu aplikasi ke aplikasi lainnya.  Ini juga memungkinkan Anda untuk mengkonfigurasi aksesibilitas antara pod, lingkungan (ruang nama) tertentu atau blok alamat IP: <br><br><pre><code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: role: db policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br>  Ini bukan contoh paling primitif dari <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">dokumentasi resmi yang</a> dapat sekali dan untuk semua mencegah keinginan untuk memahami logika kebijakan jaringan.  Namun, kami masih mencoba memahami prinsip dasar dan metode pemrosesan arus lalu lintas menggunakan kebijakan jaringan ... <br><br>  Adalah logis bahwa ada 2 jenis lalu lintas: masuk ke pod (Ingress) dan keluar darinya (Egress). <br><br><img src="https://habrastorage.org/webt/a7/zb/-5/a7zb-5tetbhwgbmagjou3liglyg.png"><br><br>  Sebenarnya, politik dibagi menjadi 2 kategori ini dalam arah gerakan. <br><br>  Atribut yang diperlukan berikutnya adalah pemilih;  orang yang aturannya berlaku.  Itu bisa berupa pod (atau grup pod) atau lingkungan (mis. Namespace).  Detail penting: kedua jenis objek ini harus mengandung label ( <i>label</i> dalam terminologi Kubernetes) - ini adalah kebijakan yang beroperasi. <br><br>  Selain jumlah pemilih terbatas yang disatukan oleh beberapa label, ada kemungkinan aturan penulisan seperti "Izinkan / Tolak Semua / Semua" dalam variasi yang berbeda.  Untuk ini, konstruksi bentuk digunakan: <br><br><pre> <code class="plaintext hljs"> podSelector: {} ingress: [] policyTypes: - Ingress</code> </pre> <br>  - dalam contoh ini, semua pod lingkungan menutup lalu lintas masuk.  Perilaku yang berlawanan dapat dicapai dengan konstruksi seperti itu: <br><br><pre> <code class="plaintext hljs"> podSelector: {} ingress: - {} policyTypes: - Ingress</code> </pre> <br>  Demikian pula untuk keluar: <br><br><pre> <code class="plaintext hljs"> podSelector: {} policyTypes: - Egress</code> </pre> <br>  - untuk menonaktifkannya.  Dan inilah yang termasuk: <br><br><pre> <code class="plaintext hljs"> podSelector: {} egress: - {} policyTypes: - Egress</code> </pre> <br>  Kembali ke pilihan plugin CNI untuk sebuah cluster, perlu dicatat bahwa <b>tidak setiap plugin jaringan mendukung bekerja dengan NetworkPolicy</b> .  Misalnya, Flannel yang sudah disebutkan tidak tahu cara mengkonfigurasi kebijakan jaringan, seperti yang <a href="https://github.com/coreos/flannel">secara eksplisit dinyatakan</a> dalam repositori resmi.  Alternatif juga disebutkan di sana - proyek Open Source <a href="https://www.projectcalico.org/">Calico</a> , yang secara signifikan memperluas API Kubernetes standar dalam hal kebijakan jaringan. <br><br><img src="https://habrastorage.org/webt/ut/_g/o1/ut_go1ror_jprp6n0bbwthgdkvs.png"><br><br><h2>  Temui Calico: Teori </h2><br>  Plugin Calico dapat digunakan dalam integrasi dengan Flannel (proyek <a href="https://github.com/projectcalico/canal">Canal</a> ) atau sendiri, yang mencakup konektivitas jaringan dan fitur manajemen ketersediaan. <br><br>  Fitur apa yang disediakan oleh solusi kotak K8 dan Calico API set? <br><br>  Inilah yang dibangun ke dalam NetworkPolicy: <br><br><ul><li>  politisi dibatasi oleh lingkungan; </li><li>  Kebijakan berlaku untuk pod yang ditandai dengan label. </li><li>  aturan dapat diterapkan ke pod, lingkungan atau subnet; </li><li>  aturan dapat berisi protokol, nama atau instruksi port simbolik. </li></ul><br>  Dan inilah cara Calico memperluas fitur-fitur ini: <br><br><ul><li>  kebijakan dapat diterapkan ke objek apa pun: pod, wadah, mesin virtual, atau antarmuka; </li><li>  aturan dapat berisi tindakan spesifik (larangan, izin, penebangan); </li><li>  target atau sumber aturan dapat berupa port, jangkauan port, protokol, atribut HTTP atau ICMP, IP atau subnet (generasi 4 atau 6), setiap penyeleksi (node, host, lingkungan); </li><li>  Selain itu, arus lalu lintas dapat dikontrol menggunakan pengaturan DNAT dan kebijakan penerusan lalu lintas. </li></ul><br>  GitHub pertama berkomitmen dalam repositori Calico kembali ke Juli 2016, dan setahun kemudian proyek mengambil posisi terdepan dalam organisasi konektivitas jaringan Kubernetes - ini ditunjukkan, misalnya, oleh hasil survei yang <a href="https://thenewstack.io/tigera-aims-ease-connectivity-pain-kubernetes/">dilakukan oleh The New Stack</a> : <br><br><img src="https://habrastorage.org/webt/0z/nq/8b/0znq8behc5xpv33ynlafbce9kr4.png"><br><br>  Banyak solusi besar yang dikelola dengan K8, seperti <a href="https://docs.aws.amazon.com/en_us/eks/latest/userguide/calico.html">Amazon EKS</a> , <a href="https://docs.microsoft.com/ru-ru/azure/aks/use-network-policies">Azure AKS</a> , <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/network-policy">Google GKE</a> dan lainnya, mulai merekomendasikannya untuk digunakan. <br><br>  Adapun kinerja, semuanya bagus di sini.  Saat menguji produknya, tim pengembang Calico mendemonstrasikan kinerja astronomi dengan meluncurkan lebih dari 50.000 kontainer pada 500 node fisik dengan kecepatan menciptakan 20 kontainer per detik.  Tidak ada masalah dengan penskalaan.  Hasil seperti <a href="https://www.projectcalico.org/announcing-calico-v1-0/">itu</a> sudah <a href="https://www.projectcalico.org/announcing-calico-v1-0/">diumumkan</a> pada pengumuman versi pertama.  Penelitian independen tentang bandwidth dan konsumsi sumber daya juga mengkonfirmasi kinerja Calico, yang hampir sama dengan Flannel.  <a href="https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-april-2019-4a9886efe9c4">Sebagai contoh</a> : <br><br><img src="https://habrastorage.org/webt/7j/k9/b7/7jk9b7obg2mb12rwmsddeyqiybq.png"><br><br>  Proyek ini berkembang sangat cepat, mendukung kerja dalam solusi populer yang dikelola K8s, OpenShift, OpenStack, dimungkinkan untuk menggunakan Calico ketika menggunakan sebuah cluster menggunakan <a href="">kops</a> , ada referensi untuk membangun jaringan Service Mesh (di <a href="https://docs.projectcalico.org/v3.10/security/enforce-policy-istio">sini adalah contoh</a> menggunakannya dengan Istio). <br><br><h2>  Berlatih dengan Calico </h2><br>  Dalam kasus umum menggunakan vanilla Kubernetes, menginstal CNI bermuara menggunakan file <code>calico.yaml</code> <a href="https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/calico">diunduh dari situs resmi</a> menggunakan <code>kubectl apply -f</code> . <br><br>  Sebagai aturan, versi plugin saat ini kompatibel dengan 2-3 versi Kubernetes terbaru: bekerja di versi yang lebih lama tidak diuji dan tidak menjamin.  Menurut pengembang, Calico berjalan pada kernel Linux di atas 3.10 di bawah CentOS 7, Ubuntu 16 atau Debian 8, di atas iptables atau IPVS. <br><br><h3>  Isolasi di dalam lingkungan </h3><br>  Untuk pemahaman umum, pertimbangkan kasus sederhana untuk memahami bagaimana kebijakan jaringan dalam notasi Calico berbeda dari yang standar dan bagaimana pendekatan untuk menyusun aturan menyederhanakan keterbacaan dan fleksibilitas konfigurasi: <br><br><img src="https://habrastorage.org/webt/ke/5n/ca/ke5ncaoa_gtjrzrckxd-yhw88sm.png"><br><br>  Ada 2 aplikasi web yang digunakan dalam cluster: Node.js dan PHP, salah satunya menggunakan Redis.  Untuk memblokir akses ke Redis dari PHP, sambil meninggalkan konektivitas dengan Node.js, cukup menerapkan kebijakan berikut: <br><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: allow-redis-nodejs spec: podSelector: matchLabels: service: redis ingress: - from: - podSelector: matchLabels: service: nodejs ports: - protocol: TCP port: 6379</code> </pre> <br>  Intinya, kami mengizinkan lalu lintas masuk ke port Redis dari Node.js.  Dan jelas mereka tidak melarang hal lain.  Segera setelah NetworkPolicy muncul, maka semua pemilih yang disebutkan di dalamnya mulai terisolasi, kecuali dinyatakan sebaliknya.  Selain itu, aturan isolasi tidak berlaku untuk objek lain yang tidak dicakup oleh pemilih. <br><br>  Contoh ini menggunakan <code>apiVersion</code> apiVersion "out of the box", tetapi tidak ada yang mencegah menggunakan <a href="https://docs.projectcalico.org/latest/reference/resources/networkpolicy">sumber daya dengan nama yang sama dari pengiriman Calico</a> .  Sintaksnya lebih luas di sana, jadi Anda perlu menulis ulang aturan untuk kasus di atas dalam bentuk berikut: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: NetworkPolicy metadata: name: allow-redis-nodejs spec: selector: service == 'redis' ingress: - action: Allow protocol: TCP source: selector: service == 'nodejs' destination: ports: - 6379</code> </pre> <br>  Konstruksi yang disebutkan di atas memungkinkan atau melarang semua lalu lintas melalui API NetworkPolicy yang biasa berisi struktur dengan tanda kurung yang sulit dipahami dan diingat.  Dalam kasus Calico, untuk mengubah logika aturan firewall ke arah sebaliknya, cukup ubah <code>action: Allow</code> untuk <code>action: Deny</code> . <br><br><h3>  Isolasi Lingkungan </h3><br>  Sekarang bayangkan sebuah situasi di mana aplikasi menghasilkan metrik bisnis untuk mengumpulkannya di Prometheus dan analisis lebih lanjut melalui Grafana.  Bongkar dapat berisi data sensitif, yang, secara default, tersedia untuk umum lagi.  Mari kita tutup data ini dari mengintip: <br><br><img src="https://habrastorage.org/webt/e-/u1/1m/e-u11mldmjhyjqhzal7ndgbcbwy.png"><br><br>  Prometheus, sebagai suatu peraturan, ditempatkan di lingkungan layanan yang terpisah - dalam contoh, ini akan menjadi namespace dari formulir berikut: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Namespace metadata: labels: module: prometheus name: kube-prometheus</code> </pre> <br>  Bidang <code>metadata.labels</code> sini tidak disengaja.  Seperti disebutkan di atas, <code>namespaceSelector</code> (seperti <code>podSelector</code> ) beroperasi pada label.  Karenanya, untuk mengizinkan pengambilan metrik dari semua pod pada port tertentu, Anda harus menambahkan beberapa label (atau mengambil dari yang ada), dan kemudian menerapkan konfigurasi seperti: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-metrics-prom spec: podSelector: {} ingress: - from: - namespaceSelector: matchLabels: module: prometheus ports: - protocol: TCP port: 9100</code> </pre> <br>  Dan jika Anda menggunakan kebijakan Calico, sintaksinya adalah: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: NetworkPolicy metadata: name: allow-metrics-prom spec: ingress: - action: Allow protocol: TCP source: namespaceSelector: module == 'prometheus' destination: ports: - 9100</code> </pre> <br>  Secara umum, dengan menambahkan kebijakan semacam ini untuk kebutuhan spesifik, Anda dapat melindungi terhadap gangguan berbahaya atau tidak sengaja dalam pengoperasian aplikasi di cluster. <br><br>  Praktik terbaik, menurut pencipta Calico, adalah pendekatan ‚ÄúLarangkan Segalanya dan Temukan yang Dibutuhkan‚Äù, sebagaimana dicatat dalam <a href="https://docs.projectcalico.org/v3.10/security/kubernetes-default-deny">dokumentasi resmi</a> (yang lain mengikuti pendekatan yang serupa, khususnya, dalam artikel yang <a href="https://habr.com/ru/company/flant/blog/443190/">telah disebutkan</a> ). <br><br><h3>  Menggunakan Calico Optional Objects </h3><br>  Biarkan saya mengingatkan Anda bahwa melalui serangkaian API Calico, Anda dapat mengontrol ketersediaan node, tidak terbatas pada pod.  Dalam contoh berikut, menggunakan <code>GlobalNetworkPolicy</code> menutup kemungkinan melewati permintaan ICMP di cluster (misalnya, ping dari pod ke node, antara pod atau dari node ke pod IP): <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: block-icmp spec: order: 200 selector: all() types: - Ingress - Egress ingress: - action: Deny protocol: ICMP egress: - action: Deny protocol: ICMP</code> </pre> <br>  Dalam kasus di atas, node cluster masih dapat "menjangkau" satu sama lain melalui ICMP.  Dan pertanyaan ini diselesaikan dengan menggunakan <code>GlobalNetworkPolicy</code> diterapkan pada entitas <code>HostEndpoint</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: deny-icmp-kube-02 spec: selector: "role == 'k8s-node'" order: 0 ingress: - action: Allow protocol: ICMP egress: - action: Allow protocol: ICMP --- apiVersion: crd.projectcalico.org/v1 kind: HostEndpoint metadata: name: kube-02-eth0 labels: role: k8s-node spec: interfaceName: eth0 node: kube-02 expectedIPs: ["192.168.2.2"]</code> </pre> <br><h3>  Kasing VPN </h3><br>  Akhirnya, saya akan memberikan contoh nyata tentang penggunaan fungsi Calico untuk kasus dengan interaksi dekat-kluster, ketika serangkaian kebijakan standar tidak cukup.  Terowongan VPN digunakan oleh klien untuk mengakses aplikasi web, dan akses ini dikontrol dengan ketat dan terbatas pada daftar layanan tertentu yang diizinkan: <br><br><img src="https://habrastorage.org/webt/ft/sy/zt/ftsyztco2pulpbcbrunwdlnhn1u.png"><br><br>  Klien terhubung ke VPN melalui port UDP standar 1194 dan, ketika terhubung, menerima rute ke sub kelompok subnet dari pod dan layanan.  Subnet push sepenuhnya agar tidak kehilangan layanan selama restart dan mengatasi perubahan. <br><br>  Port dalam konfigurasi adalah standar, yang memberikan beberapa nuansa pada proses mengkonfigurasi aplikasi dan transfernya ke cluster Kubernetes.  Sebagai contoh, dalam AWS yang sama, LoadBalancer untuk UDP muncul secara harfiah pada akhir tahun lalu dalam daftar terbatas daerah, dan NodePort tidak dapat digunakan karena penerusannya pada semua node cluster dan tidak mungkin untuk skala jumlah contoh server untuk toleransi kesalahan.  Plus, Anda harus mengubah kisaran port default ... <br><br>  Sebagai hasil dari pencarian solusi yang mungkin, yang berikut ini dipilih: <br><br><ol><li>  <code>hostNetwork</code> VPN dijadwalkan per host dalam mode <code>hostNetwork</code> , yaitu pada IP aktual. </li><li>  Layanan diposting melalui <code>ClusterIP</code> .  Port secara fisik naik pada host, yang dapat diakses dari luar dengan beberapa peringatan (ketersediaan bersyarat dari alamat IP nyata). </li><li>  Definisi simpul di mana pod naik berada di luar ruang lingkup cerita kita.  Saya hanya bisa mengatakan bahwa Anda dapat dengan kuat "memakukan" layanan ke host atau menulis layanan sespan kecil yang akan memantau alamat IP saat ini dari layanan VPN dan mengedit catatan DNS yang terdaftar dengan klien - yang memiliki imajinasi yang cukup. </li></ol><br>  Dari sudut pandang perutean, kami dapat secara unik mengidentifikasi klien untuk VPN dengan alamat IP-nya yang dikeluarkan oleh server VPN.  Di bawah ini adalah contoh primitif membatasi akses ke klien untuk layanan tersebut, sebuah ilustrasi tentang Redis yang disebutkan di atas: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: HostEndpoint metadata: name: vpnclient-eth0 labels: role: vpnclient environment: production spec: interfaceName: "*" node: kube-02 expectedIPs: ["172.176.176.2"] --- apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: vpn-rules spec: selector: "role == 'vpnclient'" order: 0 applyOnForward: true preDNAT: true ingress: - action: Deny protocol: TCP destination: ports: [6379] - action: Allow protocol: UDP destination: ports: [53, 67]</code> </pre> <br>  Di sini, sangat dilarang untuk terhubung ke port 6379, tetapi pada saat yang sama, layanan DNS dipertahankan, fungsi yang sering menderita ketika membuat aturan.  Karena, seperti yang disebutkan sebelumnya, ketika pemilih muncul, kebijakan standar penghalang diterapkan untuk itu, kecuali ditentukan lain. <br><br><h2>  Ringkasan </h2><br>  Dengan demikian, menggunakan Calico Advanced API, Anda dapat secara fleksibel mengkonfigurasi dan secara dinamis mengubah perutean di dan di sekitar cluster.  Secara umum, penggunaannya mungkin terlihat seperti suara tembakan pada burung pipit, dan pengenalan jaringan L3 dengan BGP dan terowongan IP-IP terlihat mengerikan dalam pemasangan sederhana Kubernetes pada jaringan datar ... Namun, alat lainnya terlihat cukup layak dan bermanfaat. <br><br>  Isolasi cluster untuk persyaratan keamanan mungkin tidak selalu layak, dan dalam kasus seperti itulah Calico (atau solusi serupa) datang untuk menyelamatkan.  Contoh-contoh dalam artikel ini (dengan sedikit perbaikan) digunakan dalam beberapa instalasi klien kami di AWS. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/443190/">Pengantar Kebijakan Jaringan Kubernet untuk Profesional Keamanan</a> "; </li><li>  ‚ÄúPanduan Ilustrasi untuk Jaringan di Kubernetes‚Äù: <a href="https://habr.com/ru/company/flant/blog/346304/">bagian 1 dan 2 (model jaringan, jaringan overlay)</a> , <a href="https://habr.com/ru/company/flant/blog/433382/">bagian 3 (layanan dan pemrosesan lalu lintas)</a> ; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/329830/">Container Networking Interface (CNI) adalah antarmuka jaringan dan standar untuk wadah Linux</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485716/">https://habr.com/ru/post/id485716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485704/index.html">Seni pixel untuk pemula: memperbaiki kesalahan umum</a></li>
<li><a href="../id485706/index.html">Kami mengundang Anda ke pertemuan "Transformasi Digital dan Peran Baru dalam Ilmu Data"</a></li>
<li><a href="../id485708/index.html">Blockchain Mengubah Cara Kerja Industri Rel</a></li>
<li><a href="../id485710/index.html">Solusi sederhana untuk pengujian regresi visual di Java + Selenium Webdriver + aShot</a></li>
<li><a href="../id485712/index.html">Manajemen bukan kalimat</a></li>
<li><a href="../id485718/index.html">Pac-Man: Kisah Tak Terungkap tentang Bagaimana Kami Sebenarnya Memainkan Game Ini</a></li>
<li><a href="../id485726/index.html">Retas Pesawat - 3</a></li>
<li><a href="../id485732/index.html">15 Februari Badoo PHP Meetup # 4. Warisan</a></li>
<li><a href="../id485738/index.html">Minggu Keamanan 05: kerentanan kritis perangkat medis</a></li>
<li><a href="../id485740/index.html">The Standoff at PHDays: Ikut serta dalam Anniversary Battle of Hacker and Defenders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>