<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèæ üï¢ üñï Tejo: marco front-end Rust & WebAssembly ‚ôçÔ∏è ‚ôíÔ∏è üöì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew es un an√°logo de React and Elm, escrito completamente en Rust y compilado en un WebAssembly honesto. En el art√≠culo, Denis Kolodin, desarrollador ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tejo: marco front-end Rust & WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422253/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yew</a> es un an√°logo de React and Elm, escrito completamente en Rust y compilado en un WebAssembly honesto.  En el art√≠culo, Denis Kolodin, desarrollador de Yew, habla sobre c√≥mo puede crear un marco sin un recolector de basura, garantizar de manera efectiva inmutable, sin la necesidad de copiar el estado debido a las reglas de propiedad de los datos de Rust, y cu√°les son las caracter√≠sticas al traducir Rust a WebAssembly. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>La publicaci√≥n se prepar√≥ sobre la base del informe de Denis en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS 2018 Piter</a> .</i>  <i>Debajo del corte: transcripci√≥n de video y texto del informe.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin trabaja para Bitfury Group, una compa√±√≠a que desarrolla varias soluciones de blockchain.</i>  <i>Durante m√°s de dos a√±os, ha estado codificando en Rust, un lenguaje de programaci√≥n de Mozilla Research.</i>  <i>Durante este tiempo, Denis logr√≥ estudiar a fondo este lenguaje y usarlo para desarrollar varias aplicaciones del sistema, un backend.</i>  <i>Ahora, en relaci√≥n con el advenimiento del est√°ndar WebAssembly, comenc√© a mirar hacia el front-end.</i> <br><br><h2>  Agenda </h2><br>  Hoy aprenderemos sobre qu√© es Yew (el nombre del marco se lee igual que la palabra inglesa "you" - you; "yew" es un √°rbol de tejo traducido del ingl√©s). <br><br>  Hablemos un poco sobre los aspectos arquitect√≥nicos, sobre las ideas sobre las que se construye el marco, sobre las posibilidades que se integran en √©l, as√≠ como sobre las caracter√≠sticas que Rust tambi√©n nos brinda en comparaci√≥n con otros lenguajes. <br><br>  Al final, le mostrar√© c√≥mo comenzar a usar Yew y WebAssembly hoy. <br><br><h2>  ¬øQu√© es el tejo? </h2><br>  En primer lugar, esto es WebAssembly, es decir  C√≥digo de bytes ejecutable que funciona en los navegadores.  Es necesario para ejecutar algoritmos complejos en el lado del usuario, por ejemplo, criptograf√≠a, codificaci√≥n / decodificaci√≥n.  Es m√°s f√°cil implementar esto en los lenguajes del sistema que atornillar muletas. <br><br>  WebAssembly es un est√°ndar que est√° claramente descrito, comprendido y respaldado por todos los navegadores modernos.  Le permite usar varios lenguajes de programaci√≥n.  Y esto es interesante principalmente porque puede reutilizar el c√≥digo creado por la comunidad en otros idiomas. <br><br>  Si lo desea, puede escribir completamente una aplicaci√≥n en WebAssembly, y Yew le permite hacer esto, pero es importante no olvidar que incluso en este caso, JavaScript permanece en el navegador.  Es necesario preparar WebAssembly: tome el m√≥dulo (WASM), agr√©guele el entorno y ejec√∫telo.  Es decir  JavaScript es indispensable.  Por lo tanto, vale la pena considerar WebAssembly como una extensi√≥n en lugar de una alternativa revolucionaria a JS. <br><br><h3>  C√≥mo se ve el desarrollo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  Tienes una fuente, hay un compilador.  Traduces todo esto a un formato binario y lo ejecutas en un navegador.  Si el navegador es antiguo, sin soporte de WebAssembly, se requiere emscripten.  Esto es, m√°s o menos, un emulador de WebAssembly para un navegador. <br><br><h3>  Tejo - listo para usar marco de wasm </h3><br>  Pasemos a Yew.  Desarroll√© este marco a fines del a√±o pasado.  Luego escrib√≠ alg√∫n tipo de aplicaci√≥n de criptomonedas en Elm y me enfrent√© al hecho de que debido a restricciones de idioma no puedo crear una estructura recursiva.  Y en ese momento pens√©: en Rust, mi problema se resolver√≠a muy f√°cilmente.  Y dado que el 99% del tiempo escribo en Rust y me encanta este lenguaje precisamente por sus caracter√≠sticas, decid√≠ experimentar: compilar la aplicaci√≥n con la misma funci√≥n de actualizaci√≥n en Rust. <br><br>  El primer boceto me llev√≥ varias horas, tuve que descubrir c√≥mo compilar WebAssembly.  Lo lanc√© y me di cuenta de que en solo unas pocas horas hab√≠a establecido el n√∫cleo, que es muy f√°cil de desarrollar.  Me llev√≥ solo unos d√≠as llevar todo al motor de marco m√≠nimo. <br><br>  Lo publiqu√© en c√≥digo abierto, pero no esperaba que fuera popular.  Sin embargo, hoy ha reunido m√°s de 4 mil estrellas en GitHub.  Puedes ver el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Hay muchos ejemplos <br><br>  El marco est√° completamente escrito en Rust.  Yew admite la compilaci√≥n directa a WebAssembly (objetivo wasm32-unknown-unknown) sin emscripten.  Si es necesario, puede trabajar con emscripten. <br><br><h2>  Arquitectura </h2><br>  Ahora unas pocas palabras sobre c√≥mo el marco difiere de los enfoques tradicionales que existen en el mundo de JavaScript. <br><br>  Primero, te mostrar√© las restricciones de idioma que encontr√© en Elm.  Tome el caso cuando hay un modelo y hay un mensaje que le permite transformar este modelo. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  En Elm, simplemente creamos un nuevo modelo y lo mostramos en la pantalla.  La versi√≥n anterior del modelo permanece sin cambios.  ¬øPor qu√© me estoy centrando en esto?  Porque en Yew, el modelo es mutable, y esta es una de las preguntas m√°s comunes.  A continuaci√≥n, explicar√© por qu√© se hace esto. <br><br>  Inicialmente, segu√≠ el camino cl√°sico cuando se recre√≥ el modelo.  Pero a medida que se desarroll√≥ el marco, vi que no tiene sentido almacenar la versi√≥n anterior del modelo.  Rust le permite rastrear la vida √∫til de todos los datos, ya sean modificados o no.  Y as√≠ puedo cambiar el modelo de manera segura, sabiendo que Rust controla la ausencia de conflicto. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  Este es el primer momento.  El segundo punto: ¬øpor qu√© necesitamos la versi√≥n anterior del modelo?  En el mismo olmo, apenas hay un problema de alg√∫n tipo de acceso competitivo.  El modelo anterior solo es necesario para entender cu√°ndo renderizar.  La conciencia de este momento me permiti√≥ deshacerme por completo de la inmutable y no mantener la versi√≥n anterior. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Mire la opci√≥n cuando tengamos la funci√≥n de <code>update</code> y dos campos: <code>value</code> y <code>name</code> .  Hay un valor que se guarda cuando ingresamos datos en el campo de <code>input</code> .  El modelo est√° cambiando. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  Es importante que el <code>value</code> no <code>value</code> involucrado en la representaci√≥n.  Y as√≠ podemos cambiarlo tanto como queramos.  Pero no necesitamos influir en el √°rbol DOM y no necesitamos iniciar estos cambios. <br><br>  Esto me llev√≥ a la idea de que solo el desarrollador puede conocer el momento correcto cuando realmente se necesita iniciar el renderizado.  Para iniciar, comenc√© a usar la bandera, solo un valor booleano, <code>ShouldRender</code> , que indica que el modelo ha cambiado y tenemos que comenzar a renderizar.  Al mismo tiempo, no hay gastos generales para las comparaciones constantes, no hay consumo de memoria: las aplicaciones escritas en Yew son m√°s efectivas. <br><br>  En el ejemplo anterior, no hab√≠a ninguna asignaci√≥n de memoria, excepto el mensaje que se gener√≥ y envi√≥.  El modelo retuvo su estado, y esto se reflej√≥ en el renderizado solo con la ayuda de una bandera. <br><br><h2>  Las posibilidades </h2><br>  Escribir un marco que funcione en WebAssembly no es tarea f√°cil.  Tenemos JavaScript, pero deber√≠a crear alg√∫n tipo de entorno con el que deba interactuar, y esto es una gran cantidad de trabajo.  La versi√≥n inicial de estos paquetes se parec√≠a a esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  Tom√© una demostraci√≥n de otro proyecto.  Hay muchos proyectos que van por este camino, pero r√°pidamente lleva a un callej√≥n sin salida.  Despu√©s de todo, el framework es un desarrollo bastante grande y tienes que escribir mucho c√≥digo de acoplamiento.  Comenc√© a usar bibliotecas en Rust que se llaman cajas, en particular, la <code>Stdweb</code> . <br><br><h3>  JS integrado </h3><br>  Con la ayuda de las macros Rust, puede expandir el idioma: podemos incrustar fragmentos de JavaScript en el c√≥digo Rust, esta es una caracter√≠stica muy √∫til del lenguaje. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  El uso de macros y Stdweb me permiti√≥ escribir r√°pida y eficientemente todos los enlaces necesarios. <br><br><h3>  Plantillas Jsx </h3><br>  Al principio, segu√≠ el camino de Elm y comenc√© a usar plantillas implementadas usando c√≥digo. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  Nunca he sido partidario de React.  Pero cuando comenc√© a escribir mi marco, me di cuenta de que JSX en React es algo genial.  Aqu√≠ hay una presentaci√≥n muy conveniente de plantillas de c√≥digo. <br><br>  Como resultado, tom√© una macro en Rust e implement√© directamente dentro de Rust la capacidad de escribir un marcado HTML que genera inmediatamente elementos de √°rbol virtuales. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  Podemos decir que las plantillas tipo JSX son plantillas de c√≥digo puro, pero con esteroides.  Se presentan en un formato conveniente.  Tambi√©n tenga en cuenta que aqu√≠ inserto una expresi√≥n de Rust directamente en el bot√≥n (la expresi√≥n de Rust se puede insertar dentro de estas plantillas).  Esto le permite integrarse muy de cerca. <br><br><h3>  Componentes bastante estructurados </h3><br>  Luego comenc√© a desarrollar plantillas y me di cuenta de la posibilidad de usar componentes.  Este es el primer problema que se ha realizado en el repositorio.  He implementado componentes que se pueden usar en el c√≥digo de plantilla.  Simplemente declara una estructura honesta en Rust y escribe algunas propiedades para ella.  Y estas propiedades se pueden configurar directamente desde la plantilla. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  Una vez m√°s, noto lo importante de que estas plantillas son c√≥digo Rust sinceramente generado.  Por lo tanto, cualquier error aqu√≠ ser√° notado por el compilador.  Es decir  no puede equivocarse, como suele ser el caso en el desarrollo de JavaScript. <br><br><h3>  √Åreas tipificadas </h3><br>  Otra caracter√≠stica interesante es que cuando un componente se coloca dentro de otro componente, puede ver el tipo de mensaje del padre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  El compilador une r√≠gidamente estos tipos y no le dar√° la oportunidad de cometer un error.  Al procesar eventos, los mensajes que el componente espera o puede enviar deben coincidir completamente con el padre. <br><br><h3>  Otras caracter√≠sticas </h3><br>  Transfer√≠ una implementaci√≥n de Rust directamente al marco que le permite usar convenientemente varios formatos de serializaci√≥n / deserializaci√≥n (proporcion√°ndole envoltorios adicionales).  A continuaci√≥n se muestra un ejemplo: vamos al almacenamiento local y, restaurando los datos, especificamos un determinado contenedor, lo que esperamos aqu√≠ es json. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  Puede tener cualquier formato, incluso binario.  En consecuencia, la serializaci√≥n y la deserializaci√≥n se vuelven transparentes y convenientes. <br><br>  La idea de otra oportunidad que implement√© provino de los usuarios del marco.  Pidieron hacer fragmentos.  Y aqu√≠ me encontr√© con algo interesante.  Al ver en JavaScript la capacidad de insertar fragmentos en el √°rbol DOM, primero decid√≠ que ser√≠a muy f√°cil implementar dicha funci√≥n en mi marco.  Pero prob√© esta opci√≥n, y result√≥ que no funciona.  Ten√≠a que resolverlo, caminar sobre este √°rbol, ver qu√© hab√≠a cambiado all√≠, etc. <br><br>  El marco Yew usa un √°rbol DOM virtual, todo existe inicialmente en √©l.  De hecho, cuando hay algunos cambios en la plantilla, se convierten en parches que ya cambian el √°rbol DOM representado. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Beneficios adicionales </h2><br>  Rust proporciona muchas m√°s funciones poderosas diferentes, solo hablar√© sobre las m√°s importantes. <br><br><h3>  Servicios: interacci√≥n con el mundo exterior. </h3><br>  La primera oportunidad de la que quiero hablar es de servicios.  Puede describir la funcionalidad necesaria en forma de alg√∫n servicio, publicarla como una caja y reutilizarla. <br><br>  En Rust, la capacidad de crear bibliotecas, su integraci√≥n, acoplamiento y pegado est√° muy bien implementada.  De hecho, puede crear varias API para interactuar con su servicio, incluidas las de JavaScript.  Al mismo tiempo, el marco puede interactuar con el mundo exterior, a pesar de que funciona dentro del tiempo de ejecuci√≥n de WebAssembly. <br><br>  Ejemplos de servicios: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Servicios personalizados ... <br></li></ul><br>  Servicios de √≥xido y cajas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crates.io</a> . <br><br><h3>  Contexto: requisitos estatales </h3><br>  Otra cosa que implement√© en el marco no es completamente tradicional, es el contexto.  React tiene una API de contexto, pero us√© Context en un sentido diferente.  El marco Yew consta de los componentes que usted hace, y el Contexto es un estado global.  Los componentes pueden no tener en cuenta este estado global, pero pueden hacer algunas demandas, de modo que la entidad global cumple con algunos criterios. <br><br>  Digamos que nuestro componente abstracto requiere la capacidad de cargar algo en S3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  Se puede ver a continuaci√≥n que usa esta carga, es decir,  env√≠a datos a S3.  Tal componente se puede colocar en forma de estante.  El usuario que descargue este componente y lo agregue dentro de la plantilla a su aplicaci√≥n encontrar√° un error: el compilador le preguntar√° d√≥nde est√° el soporte S3.  El usuario tendr√° que implementar este soporte.  Despu√©s de eso, el componente autom√°ticamente comienza a vivir una vida plena. <br><br>  ¬øD√≥nde se necesita?  Imag√≠nese: est√° creando un componente con criptograf√≠a inteligente.  Tiene requisitos para que el contexto que lo rodea le permita iniciar sesi√≥n en alg√∫n lugar.  Todo lo que necesita hacer es agregar un formulario de autorizaci√≥n en la plantilla y en su contexto implementar la conexi√≥n con su servicio.  Es decir  Ser√° literalmente tres l√≠neas de c√≥digo.  Despu√©s de eso, el componente comienza a funcionar. <br><br>  Imagine que tenemos docenas de componentes diferentes.  Y todos tienen el mismo requisito.  Esto le permite implementar alg√∫n tipo de funcionalidad una vez para revivir todos los componentes y extraer los datos que se necesitan.  Justo fuera de contexto.  Y el compilador no le permitir√° cometer un error: si no tiene una interfaz que requiera un componente, nada funcionar√°. <br><br>  Por lo tanto, puede crear f√°cilmente botones muy delicados que solicitar√°n algunas API u otras caracter√≠sticas.  Gracias a Rust y al sistema de estas interfaces (se denominan rasgos en Rust), es posible declarar los requisitos de los componentes. <br><br><h3>  El compilador no te permitir√° cometer un error. </h3><br>  Imagine que estamos creando un componente con algunas propiedades, una de las cuales es la capacidad de devolver la llamada.  Y, por ejemplo, configuramos la propiedad y omitimos una letra en su nombre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  Intentando compilar, Rust responde r√°pidamente.  √âl dice que nos equivocamos y que no existe tal propiedad: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  Como puede ver, Rust usa directamente esta plantilla y puede representar todos los errores dentro de la macro.  √âl le dice c√≥mo deber√≠a llamarse realmente la propiedad.  Si pas√≥ el compilador, no tendr√° errores tontos de tiempo de ejecuci√≥n como errores tipogr√°ficos. <br><br>  Ahora imagine que tenemos un bot√≥n que le pide a nuestro contexto global que pueda conectarse a S3.  Y cree un contexto que no implemente el soporte S3.  Veamos que pasa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  El compilador informa que hemos insertado un bot√≥n, pero esta interfaz no est√° implementada para el contexto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  Solo queda ir al editor, agregar un enlace a Amazon en el contexto, y todo comenzar√°.  Puede crear servicios listos para usar con alg√∫n tipo de API, luego simplemente agregar al contexto, sustituir un enlace y el componente cobra vida de inmediato.  Esto le permite hacer cosas muy interesantes: agregar componentes, crear un contexto, rellenarlo con servicios.  Y todo esto funciona de forma completamente autom√°tica; se necesitan esfuerzos m√≠nimos para unir todo. <br><br><h2>  ¬øC√≥mo comenzar a usar Yew? </h2><br>  ¬øD√≥nde comenzar si desea intentar compilar una aplicaci√≥n WebAssembly?  ¬øY c√≥mo se puede hacer esto usando el marco Yew? <br><br><h3>  Compilaci√≥n de √≥xido a desperdicio </h3><br>  Primero, necesitas instalar el compilador.  Hay una herramienta de oxidaci√≥n para esto: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  Adem√°s, es posible que necesite emscripten.  ¬øPara qu√© puede ser √∫til?  La mayor√≠a de las bibliotecas escritas para lenguajes de programaci√≥n del sistema, especialmente para Rust (originalmente un sistema), est√°n desarrolladas para Linux, Windows y otros sistemas operativos completos.  Obviamente, el navegador no tiene muchas caracter√≠sticas. <br><br>  Por ejemplo, la generaci√≥n de n√∫meros aleatorios en un navegador no se realiza de la misma manera que en Linux.  emscripten es √∫til si desea utilizar bibliotecas que requieren una API del sistema. <br><br>  Las bibliotecas y toda la infraestructura est√°n cambiando silenciosamente a WebAssembly honesto, y ya no se requiere emscripten (usa capacidades basadas en JavaScript para generar n√∫meros aleatorios y otras cosas), pero si necesita construir algo que no es compatible con el navegador, no puede hacerlo sin emscripten . <br><br>  Tambi√©n recomiendo usar cargo-web: <br><br> <code>cargo install cargo-web <br></code> <br>  Es posible compilar WebAssembly sin utilidades adicionales.  Pero Cargo-web es una herramienta genial que proporciona varias cosas que son √∫tiles para los desarrolladores de JavaScript.  En particular, supervisar√° los archivos: si realiza alg√∫n cambio, comenzar√° a compilarse inmediatamente (el compilador no proporciona tales funciones).  En este caso, Cargo-web le permitir√° acelerar el desarrollo.  Hay diferentes sistemas de construcci√≥n para Rust, pero la carga es el 99.9% de todos los proyectos. <br><br>  Se crea un nuevo proyecto de la siguiente manera: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Entonces solo comienza el proyecto: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  Di un ejemplo de WebAssembly honesto.  Si necesita compilar bajo emscripten (el compilador de √≥xido puede conectar emscripten), puede insertar la palabra <code>emscripten</code> en el √∫ltimo elemento <code>unknown</code> , lo que le permite usar m√°s cajas.  No olvide que emscripten es un kit adicional bastante grande para su archivo.  Por lo tanto, es mejor escribir c√≥digo honesto de WebAssembly. <br><br><h3>  Restricciones existentes </h3><br>  Cualquiera que tenga experiencia en codificaci√≥n en lenguajes de programaci√≥n del sistema puede sentirse frustrado por las limitaciones existentes en el marco.  No todas las bibliotecas se pueden usar en WebAssembly.  Por ejemplo, en un entorno JavaScript no hay hilos.  WebAssembly en principio no declara esto y, por supuesto, puede usarlo en un entorno multiproceso (esta es una pregunta abierta), pero JavaScript sigue siendo un entorno de subproceso √∫nico.  S√≠, hay trabajadores, pero esto es aislamiento, por lo que no habr√° flujos all√≠. <br><br>  Parece que puedes vivir sin flujos.  Pero si desea utilizar bibliotecas basadas en subprocesos, por ejemplo, desea agregar alg√∫n tipo de tiempo de ejecuci√≥n, esto podr√≠a no despegar. <br><br>  Adem√°s, no hay una API del sistema, excepto la que transferir√° de JavaScript a WebAssembly.  Por lo tanto, muchas bibliotecas no ser√°n portadas.  No puede escribir y leer archivos directamente, no se pueden abrir sockets y no puede escribir en la red.  Si desea crear un socket web, por ejemplo, debe arrastrarlo desde JavaScript. <br><br>  Otro inconveniente es que existe el depurador WASM, pero nadie lo ha visto.  Todav√≠a est√° en un estado tan crudo que es poco probable que sea √∫til para usted.  Entonces depurar WebAssembly es una pregunta dif√≠cil. <br><br>  Cuando se usa Rust, casi todos los problemas de tiempo de ejecuci√≥n estar√°n asociados con errores en la l√≥gica empresarial, ser√°n f√°ciles de solucionar.  Pero muy raramente aparecen errores de bajo nivel, por ejemplo, una de las bibliotecas hace el acoplamiento incorrecto, y esta ya es una pregunta dif√≠cil.  Por ejemplo, en este momento hay un problema: si compilo el marco con emscripten y hay una celda de memoria variable, cuya posesi√≥n se quita, se regala, emscripten se est√° desmoronando en alg√∫n lugar en el medio (y ni siquiera estoy seguro de si es emscripten).  Sepa, si se encuentra con un problema en alg√∫n lugar del middleware a un nivel bajo, solucionarlo ser√° dif√≠cil en este momento. <br><br><h2>  El futuro del marco </h2><br>  ¬øC√≥mo se desarrollar√° Yew m√°s?  Veo su prop√≥sito principal en la creaci√≥n de componentes monol√≠ticos.  Tendr√° un archivo compilado de WebAssembly y simplemente p√©guelo en la aplicaci√≥n.  Por ejemplo, puede proporcionar capacidades criptogr√°ficas, renderizaci√≥n o edici√≥n. <br><br><h3>  Integraci√≥n JS </h3><br>  La integraci√≥n con JavaScript se fortalecer√°.  JavaScript ha escrito una gran cantidad de geniales bibliotecas que son f√°ciles de usar.  Y hay ejemplos en el repositorio donde muestro c√≥mo puede usar la biblioteca JavaScript existente directamente desde el marco Yew. <br><br><h3>  CSS escrito </h3><br>  Como se usa Rust, es obvio que puede agregar CSS tipeado que se puede generar con la misma macro que en el ejemplo de un motor de plantillas similar a JSX.  En este caso, el compilador verificar√°, por ejemplo, si ha asignado alg√∫n otro atributo en lugar de color.  Esto te ahorrar√° toneladas de tiempo. <br><br><h3>  Componentes listos </h3><br>  Tambi√©n busco crear componentes listos para usar.  En el marco, puede crear grietas que proporcionar√°n, por ejemplo, un conjunto de algunos botones o elementos que se conectar√°n como una biblioteca, se agregar√°n a las plantillas y se usar√°n. <br><br><h3>  Mejora del rendimiento en casos privados. </h3><br>  El rendimiento es un tema muy delicado y complejo.  ¬øWebAssembly es m√°s r√°pido que JavaScript?  No tengo pruebas que confirmen una respuesta positiva o negativa.  Parece que y de acuerdo con algunas pruebas muy simples que realic√©, WebAssembly es muy r√°pido.  Y tengo plena confianza en que su rendimiento ser√° mayor que el de JavaScript, solo porque es un c√≥digo de bytes de bajo nivel donde no se requiere asignaci√≥n de memoria y hay muchos otros momentos que requieren recursos. <br><br><h3>  M√°s colaboradores </h3><br>  Me gustar√≠a atraer a m√°s contribuyentes.  Las puertas para participar en el marco siempre est√°n abiertas.  Todos los que quieran actualizar algo, comprender el n√∫cleo y transformar las herramientas con las que trabajan una gran cantidad de desarrolladores pueden conectarse f√°cilmente y ofrecer sus propias ediciones. <br><br>  Al proyecto ya han asistido muchos contribuyentes.  Pero no hay contribuyentes principales en este momento, porque para esto necesita comprender el vector de desarrollo del marco, pero a√∫n no se ha formulado claramente.  Pero hay una columna vertebral, muchachos muy versados ‚Äã‚Äãen Yew: unas 30 personas.  Si tambi√©n desea agregar algo al marco, siempre env√≠e una solicitud de extracci√≥n. <br><br><h3>  La documentaci√≥n </h3><br>  Un punto obligatorio en mis planes es la creaci√≥n de una gran cantidad de documentaci√≥n sobre c√≥mo escribir aplicaciones en Yew.  Obviamente, el enfoque de desarrollo en este caso es diferente de lo que vimos en React and Elm. <br><br>  A veces, los chicos me muestran casos interesantes de c√≥mo usar el marco.  A√∫n as√≠, crear un marco no es lo mismo que escribir profesionalmente en √©l.  Todav√≠a se est√°n formando pr√°cticas para usar el marco. <br><br>  Pru√©belo, instale Rust, ampl√≠e sus capacidades como desarrollador.  Dominar WebAssembly ser√° √∫til para cada uno de nosotros, porque la creaci√≥n de aplicaciones muy complejas es el momento que hemos estado esperando durante mucho tiempo.  En otras palabras, WebAssembly no se trata solo de un navegador web, sino que generalmente es un tiempo de ejecuci√≥n que definitivamente se est√° desarrollando y se desarrollar√° a√∫n m√°s activamente. <br><br><blockquote>  Si le gust√≥ el informe, preste atenci√≥n: del 24 al 25 de noviembre, se llevar√° a cabo un nuevo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS</a> en Mosc√∫, y tambi√©n habr√° muchas cosas interesantes all√≠.      ‚Äî  ,       ( <b>  </b>  ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422253/">https://habr.com/ru/post/es422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422239/index.html">C√≥mo lanzar la entrega para millones de usuarios</a></li>
<li><a href="../es422241/index.html">KPI - Tres letras de tropiezo</a></li>
<li><a href="../es422243/index.html">CRM para peque√±as empresas. Lo necesitas</a></li>
<li><a href="../es422247/index.html">OK Copa de juegos instant√°neos. Competencia para desarrolladores de juegos HTML5</a></li>
<li><a href="../es422251/index.html">"Un alto nivel de autodisciplina". Jeffrey Richter sobre c√≥mo codificar, escribir libros y crear sus propias empresas</a></li>
<li><a href="../es422255/index.html">Creaci√≥n de personajes en Blender y Unity</a></li>
<li><a href="../es422257/index.html">Revisi√≥n del lector PocketBook 627: clase media con luz de fondo, Wi-Fi y servicio en la nube</a></li>
<li><a href="../es422259/index.html">Estructuras de datos b√°sicos. Materiel Los fundamentos</a></li>
<li><a href="../es422261/index.html">Powerstore y sistemas de niveles Zextras</a></li>
<li><a href="../es422263/index.html">"Dormammu, llegu√© a un acuerdo": un algoritmo para la cooperaci√≥n mutuamente beneficiosa con una persona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>