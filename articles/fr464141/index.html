<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🔧 ☦️ 🥝 Fantasmes sur le thème des métaclasses en C # 🙅🏿 💪🏻 🦇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les programmeurs comme moi, qui sont venus en C # avec une vaste expérience de Delphi, manquent souvent de ce que Delphi est appelé référence de class...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantasmes sur le thème des métaclasses en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/"> Les programmeurs comme moi, qui sont venus en C # avec une vaste expérience de Delphi, manquent souvent de ce que Delphi est appelé référence de classe, et dans le travail théorique, de métaclasse.  Plusieurs fois dans divers forums, je suis tombé sur une discussion qui a eu lieu dans le même sens.  Il commence par une question d'un ancien dauphiste sur la façon de créer une métaclasse en C #.  Les Sharpistes ne comprennent tout simplement pas le problème, essayant de clarifier de quel genre de bête il s'agit - une métaclasse, les dauphins comme ils peuvent l'expliquer, mais les explications sont courtes et incomplètes, et en conséquence, les aiguiseurs sont complètement perdus pour savoir pourquoi tout cela est nécessaire.  Après tout, la même chose peut être faite avec l'aide des usines de réflexion et de classe. <br><br>  Dans cet article, je vais essayer de vous dire ce que sont les métaclasses pour ceux qui ne les ont jamais rencontrées.  De plus, laissez chacun décider par lui-même s'il serait bon d'avoir une telle chose dans la langue, ou si la réflexion est suffisante.  Tout ce que j'écris ici, c'est juste des fantasmes sur la façon dont cela aurait pu être si les métaclasses avaient vraiment existé en C #.  Tous les exemples de l'article sont écrits dans cette version hypothétique de C #, pas un seul compilateur existant pour le moment ne peut les compiler. <br><a name="habracut"></a><br><h2>  Qu'est-ce qu'une métaclasse? </h2><br>  Alors qu'est-ce qu'une métaclasse?  Il s'agit d'un type spécial qui sert à décrire d'autres types.  Il y a quelque chose de très similaire en C # - le type Type.  Mais seulement similaire.  Une valeur de type Type peut décrire n'importe quel type, une métaclasse ne peut décrire que les héritiers de la classe spécifiée lorsque la métaclasse est déclarée. <br><br>  Pour ce faire, notre version hypothétique de C # acquiert le type Type &lt;T&gt;, qui est le successeur de Type.  Mais Type &lt;T&gt; ne convient que pour décrire le type T ou ses descendants. <br>  Je vais expliquer cela avec un exemple: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   – Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   –    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  L'exemple ci-dessus est la première étape vers l'émergence de métaclasses.  Type Type &lt;T&gt; vous permet de restreindre les types pouvant être décrits par les valeurs correspondantes.  Cette fonctionnalité peut s'avérer utile en soi, mais les possibilités des métaclasses ne se limitent pas à cela. <br><br><h2>  Métaclasses et membres statiques de la classe </h2><br>  Si une classe X a des membres statiques, alors la métaclasse Type &lt;X&gt; obtient des membres similaires, non plus statiques, à travers lesquels vous pouvez accéder aux membres statiques de X. Expliquons cette phrase déroutante avec un exemple. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Ici, d'une manière générale, la question se pose: que se passe-t-il si dans la classe X une méthode statique est déclarée, dont le nom et le jeu de paramètres coïncident avec le nom et le jeu de paramètres de l'une des méthodes de la classe Type, dont l'héritier est Type &lt;X&gt;?</i>  <i>Il existe plusieurs options assez simples pour résoudre ce problème, mais je ne m'y attarderai pas - pour simplifier, nous pensons que dans notre langage fantasmatique des conflits, il n'y a pas de noms magiques.</i> <br><br>  Le code ci-dessus pour toute personne normale devrait être déroutant - pourquoi avons-nous besoin d'une variable pour appeler une méthode si nous pouvons appeler cette méthode directement?  En effet, sous cette forme, cette opportunité est inutile.  Mais l'avantage vient lorsque vous y ajoutez des méthodes de classe. <br><br><h2>  Méthodes de classe </h2><br>  Les méthodes de classe sont une autre construction de Delphi, mais manquent en C #.  Une fois déclarées, ces méthodes sont marquées avec le mot class et sont un croisement entre les méthodes statiques et les méthodes d'instance.  Comme les méthodes statiques, elles ne sont pas liées à une instance spécifique et peuvent être appelées via le nom de classe sans créer d'instance.  Mais, contrairement aux méthodes statiques, elles ont un paramètre implicite this.  Seulement, dans ce cas, ce n'est pas une instance de la classe, mais une métaclasse, c'est-à-dire  si la méthode de classe est décrite dans la classe X, alors ce paramètre sera de type Type &lt;X&gt;.  Et vous pouvez l'utiliser comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($”    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}”); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : «    X» Y.Report() // : «    Y» } }</span></span></code> </pre><br>  Cette fonctionnalité n'est pas très impressionnante jusqu'à présent.  Mais grâce à elle, les méthodes de classe, contrairement aux méthodes statiques, peuvent être virtuelles.  Plus précisément, les méthodes statiques pourraient également être rendues virtuelles, mais on ne sait pas quoi faire ensuite avec cette virtualité.  Mais avec les méthodes de classe, de tels problèmes ne se posent pas.  Considérez ceci avec un exemple. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“!”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : «!» Y.Report() // : ??? } }</span></span></code> </pre><br>  Par la logique des choses, lorsque vous appelez Y.Report, "Bye!" Doit être affiché.  Mais la méthode X.Report n'a aucune information sur la classe à partir de laquelle elle a été appelée, elle ne peut donc pas choisir dynamiquement entre X.DoReport et Y.DoReport.  Par conséquent, X.Report appellera toujours X.DoReport, même si Report a été appelé via Y. Cela n'a aucun sens de rendre la méthode DoReport virtuelle.  Par conséquent, C # ne permet pas de rendre les méthodes statiques virtuelles - il serait possible de les rendre virtuelles, mais vous ne pourrez pas bénéficier de leur virtualité. <br><br>  Une autre chose est les méthodes de classe.  Si Report dans l'exemple précédent n'était pas statique, mais classe, il «saurait» quand il était appelé via X et quand via Y. Par conséquent, le compilateur pouvait générer du code qui sélectionnerait le DoReport souhaité, et un appel à Y.Report résulterait à la conclusion "Bye!". <br><br>  Cette fonctionnalité est utile en soi, mais elle l'est encore plus si vous y ajoutez la possibilité d'appeler des variables de classe via des métaclasses.  Quelque chose comme ça: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : «!» tx = typeof(Y); tx.Report() // : «!» } }</span></span></code> </pre><br>  Pour obtenir un tel polymorphisme sans métaclasses ni méthodes de classe virtuelle, pour la classe X et chacun de ses descendants, il faudrait écrire une classe auxiliaire avec la méthode virtuelle habituelle.  Cela nécessite beaucoup plus d'efforts et le contrôle par le compilateur ne sera pas aussi complet, ce qui augmente la probabilité de faire une erreur quelque part.  Pendant ce temps, des situations où le polymorphisme est nécessaire au niveau du type, et non au niveau de l'instance, sont rencontrées régulièrement, et si le langage prend en charge un tel polymorphisme, c'est une propriété très utile. <br><br><h2>  Constructeurs virtuels </h2><br>  Si des métaclasses sont apparues dans le langage, alors des constructeurs virtuels doivent leur être ajoutés.  Si un constructeur virtuel est déclaré dans une classe, tous ses descendants doivent le chevaucher, c'est-à-dire  avoir votre propre constructeur avec le même ensemble de paramètres, par exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  Dans ce code, la classe C ne doit pas être compilée, car elle n'a pas de constructeur avec les paramètres int x, int y, mais la classe B est compilée sans erreur. <br><br>  <i>Une autre option est possible: si le constructeur virtuel de l'ancêtre n'est pas chevauché dans l'héritier, le compilateur le chevauche automatiquement, tout comme il crée maintenant automatiquement le constructeur par défaut.</i>  <i>Les deux approches ont des avantages et des inconvénients évidents, mais ce n'est pas important pour l'image globale.</i> <br><br>  Un constructeur virtuel peut être utilisé partout où un constructeur ordinaire peut être utilisé.  De plus, si la classe a un constructeur virtuel, sa métaclasse a une méthode CreateInstance avec le même ensemble de paramètres que le constructeur, et cette méthode instanciera la classe, comme illustré dans l'exemple ci-dessous. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  En d'autres termes, nous avons la possibilité de créer des objets dont le type est déterminé au moment de l'exécution.  Maintenant, cela peut également être fait en utilisant Activator.CreateInstance.  Mais cette méthode fonctionne par réflexion, donc l'exactitude de l'ensemble de paramètres n'est vérifiée qu'au stade de l'exécution.  Mais si nous avons des métaclasses, le code avec les mauvais paramètres ne sera tout simplement pas compilé.  De plus, lorsque vous utilisez la réflexion, la vitesse de travail laisse beaucoup à désirer et les métaclasses vous permettent de minimiser les coûts. <br><br><h2>  Conclusion </h2><br>  J'ai toujours été surpris que Halesberg, qui est le principal développeur de Delphi et de C #, n'ait pas fait de métaclasses en C #, même si elles ont si bien fait leurs preuves en Delphi.  Peut-être que le point ici est que dans Delphi (dans les versions que Halesberg a faites) il n'y a presque pas de réflexion, et il n'y a tout simplement pas d'alternative aux métaclasses, ce qui ne peut pas être dit à propos de C #.  En effet, tous les exemples de cet article ne sont pas si difficiles à refaire, en utilisant uniquement les outils qui sont déjà dans la langue.  Mais tout cela fonctionnera sensiblement plus lentement qu'avec les métaclasses, et l'exactitude des appels sera vérifiée au moment de l'exécution, pas lors de la compilation.  Donc, mon opinion personnelle est que C # bénéficierait grandement si des métaclasses y apparaissaient. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464141/">https://habr.com/ru/post/fr464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464127/index.html">Développement de favicons animés</a></li>
<li><a href="../fr464129/index.html">Innovations JavaScript: résultats de Google I / O 2019. Partie 1</a></li>
<li><a href="../fr464131/index.html">Innovations JavaScript: résultats de Google I / O 2019. Partie 2</a></li>
<li><a href="../fr464133/index.html">Les performances ne concernent pas uniquement le CPU: créer vos propres profileurs pour Python</a></li>
<li><a href="../fr464137/index.html">Support technique Miran: comment ça marche</a></li>
<li><a href="../fr464143/index.html">Guérison personnelle contre le cancer. Comment les gènes des patients affectent le succès du traitement</a></li>
<li><a href="../fr464145/index.html">CMake: le cas où la qualité du projet est impardonnable</a></li>
<li><a href="../fr464147/index.html">CMake: le cas où le projet est impardonnable la qualité de son code</a></li>
<li><a href="../fr464149/index.html">L'histoire d'un monolithe</a></li>
<li><a href="../fr464151/index.html">Victor Vyalichkin: «La liberté, l'égalité, la fraternité ne sont que dans OpenStreetMap, où tout est toujours en vue»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>