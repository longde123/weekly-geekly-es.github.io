<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📥 👩🏾‍🤝‍👨🏻 🙆 11 cara (tidak) untuk menjadi korban peretasan di Kubernetes ❎ ❤️ 🔄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Asli artikel ini diterbitkan di blog resmi Kubernetes dan ditulis oleh Andrew Martin, salah satu pendiri perusahaan muda Inggris Cont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>11 cara (tidak) untuk menjadi korban peretasan di Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/417905/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Asli artikel ini diterbitkan di blog resmi Kubernetes dan ditulis oleh Andrew Martin, salah satu pendiri perusahaan muda Inggris Control Plane, yang berspesialisasi dalam keamanan untuk aplikasi cloud asli yang berjalan di K8s.</i> <br><br><img src="https://habrastorage.org/webt/em/sv/dw/emsvdwgvf4ym5fydg8ob7jxomcq.jpeg"><br><br>  Keamanan di Kubernetes telah datang jauh sejak proyek tiba, tetapi perangkap masih terjadi.  Kami menawarkan daftar rekomendasi yang berguna tentang bagaimana melindungi cluster dan meningkatkan stabilitas mereka dalam kasus peretasan: kami akan mulai dengan pesawat kontrol, terus dengan beban kerja dan keamanan jaringan, dan diakhiri dengan penilaian keamanan masa depan. <a name="habracut"></a><br><br><h2>  Bagian 1: Kontrol Pesawat </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pesawat kendali</a> adalah otak Kubernetes.  Dia memiliki gagasan umum tentang setiap wadah dan pod yang berjalan di cluster, dapat merencanakan pod baru (yang dapat berisi kontainer dengan akses root ke node induknya), dan dapat membaca semua rahasia yang tersimpan di cluster.  Ini adalah komponen yang sangat penting yang membutuhkan perlindungan terus-menerus terhadap kebocoran data yang tidak disengaja dan tindakan jahat: baik ketika diakses, ketika tidak ada yang terjadi, dan ketika data ditransmisikan melalui jaringan. <br><br><h3>  1. TLS di mana-mana </h3><br>  <b>Untuk setiap komponen yang mendukung TLS, harus diaktifkan - untuk mencegah peredupan lalu lintas, verifikasi identitas server dan (dalam kasus Mutual TLS) verifikasi identitas klien.</b> <br><br><blockquote>  "Harap dicatat bahwa beberapa komponen dan metode pemasangan dapat mengaktifkan port lokal untuk HTTP, sehingga administrator perlu membiasakan diri dengan pengaturan setiap komponen untuk mengidentifikasi jalur yang mungkin untuk lalu lintas tidak aman." <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari dokumentasi Kubernetes</a></i> </blockquote><br>  Diagram jaringan di bawah ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lucas Käldström</a> menunjukkan di mana TLS sangat dibutuhkan: antara setiap komponen pada wizard, dan antara Kubelet dan server API.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelsey Hightower</a> <a href="">Kubernetes The Hard Way</a> klasik dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi keamanan di etcd</a> menawarkan instruksi terperinci untuk mencapai tujuan ini. <br><br><img src="https://habrastorage.org/webt/tl/z6/9p/tlz69p-_qgydpvdbkb8i0wkwjlm.png"><br><br>  Secara historis, penskalaan otomatis node Kubernetes tidak mudah, karena setiap node memerlukan kunci TLS untuk terhubung ke master, dan menyimpan rahasia dalam gambar dasar adalah praktik yang buruk.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bootstrap TLS Kubelet</a> memungkinkan Kubelet baru untuk membuat permintaan penandatanganan sertifikat sehingga sertifikat dihasilkan saat boot: <br><br><img src="https://habrastorage.org/webt/js/7x/bw/js7xbwddp6cgld-bgcp20r657qy.png"><br><br><h3>  2. Hak minimum dalam RBAC, menonaktifkan ABAC, memantau log </h3><br>  <b>Role Based Access Control (RBAC) menyediakan manajemen kebijakan berbutir halus di mana pengguna mengakses sumber daya seperti ruang nama.</b> <br><br><img src="https://habrastorage.org/webt/if/so/hz/ifsohz4fgeo5alqvpe4pbvimujq.png"><br><br>  Attribute Based Access Control (ABAC) di Kubernetes telah digantikan oleh RBAC sejak K8 1.6 dan tidak boleh diaktifkan di sisi server API.  Gunakan RBAC sebagai gantinya: <code>--authorization-mode=RBAC</code> (atau flag ini untuk GKE: <code>--no-enable-legacy-authorization</code> ). <br><br>  Ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang baik dari</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebijakan RBAC</a> untuk berbagai layanan dalam sebuah cluster, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Tapi jangan berhenti di situ: pengaturan yang kompeten untuk kebijakan RBAC dapat diperoleh dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">audit2rbac</a> dari log <code>audit</code> . <br><br>  Kebijakan RBAC yang salah atau terlalu permisif adalah risiko keamanan jika jantung dikompromikan.  Mempertahankan aturan RBAC dengan hak istimewa minimal, terus mengauditnya, dan memperbaikinya harus menjadi bagian dari “kebersihan teknis utang” yang diterapkan tim dalam siklus hidup pengembangan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencatatan audit</a> (beta dalam Kubernetes 1.10) menawarkan API pencatatan kustom untuk beban kerja (seperti permintaan dan respons) dan pada tingkat metadata.  Level logging dapat dikonfigurasikan sesuai dengan kebijakan keamanan organisasi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GKE</a> menerapkan nilai default yang wajar untuk mereka yang baru mulai bekerja dengannya. <br><br>  Untuk permintaan baca seperti <i>dapatkan</i> , <i>daftar,</i> dan <i>tonton</i> , hanya objek yang diminta disimpan dalam log audit, tanpa objek respons.  Untuk kueri yang melibatkan data sensitif seperti <i>Rahasia</i> atau <i>ConfigMap</i> , hanya metadata yang diekspor.  Untuk semua permintaan lainnya, kedua objek dicatat dalam log audit: baik permintaan maupun responsnya. <br><br>  Jangan lupa: menyimpan log ini di dalam cluster adalah risiko keamanan jika terjadi kompromi.  Log ini, seperti yang sensitif keamanan lainnya, harus ditempatkan di luar cluster untuk menghindari konsekuensi negatif jika terjadi kerentanan. <br><br><h3>  3. Gunakan otentikasi pihak ketiga untuk API Server </h3><br>  <b>Sentralisasi otentikasi dan otorisasi untuk seluruh organisasi (yaitu, Single Sign On) membantu dalam proses menerima dan meninggalkan karyawan baru, memastikan hak akses yang konsisten.</b> <br><br>  Integrasi Kubernetes dengan penyedia otentikasi pihak ketiga (seperti Google atau GitHub) memberikan jaminan identitas dari platform jarak jauh (dengan perlindungan seperti otentikasi dua faktor) dan menghilangkan kebutuhan administrator untuk mengkonfigurasi ulang server API di Kubernetes untuk menambah / menghapus pengguna. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dex</a> adalah penyedia OpenID Connect Identity (OIDC) dan OAuth 2.0 dengan plug-in.  Pusher melangkah lebih jauh dengan menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat yang dapat disesuaikan</a> , selain itu ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> pembantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain yang</a> berfokus pada aplikasi lain. <br><br><h3>  4. Pisahkan dan tempatkan cluster Anda, dll, di belakang firewall </h3><br>  <b>etcd menyimpan informasi tentang status dan rahasia Kubernetes, merupakan komponen penting dari K8 - ia harus dilindungi secara terpisah dari anggota cluster lainnya.</b> <br><br>  Akses tulis ke etcd di server API setara dengan mengeluarkan hak root ke seluruh cluster, dan bahkan akses baca dapat dengan mudah digunakan untuk meningkatkan hak istimewa. <br><br>  Penjadwal Kubernetes di etcd mencari definisi pod yang tidak memiliki node.  Lalu ia mengirim semua pod yang ditemukan ke Kubelet yang tersedia untuk perencanaan.  Validasi pod ini dilakukan oleh server API sebelum menulisnya ke etcd, sehingga penyerang yang langsung menulis ke etcd dapat mem-bypass banyak mekanisme keamanan - misalnya, <code>PodSecurityPolicies</code> . <br><br>  etcd harus dikonfigurasikan dengan <a href="">sertifikat TLS</a> ( <i>klien</i> dan <i>rekan</i> ) dan disebarkan ke node khusus.  Untuk mengurangi risiko pencurian dan penggunaan kunci pribadi dari node kerja, Anda juga dapat membatasi firewall cluster Server API. <br><br><h3>  5. Rotasi kunci enkripsi </h3><br>  <b>Rotasi kunci dan sertifikat keamanan yang teratur adalah praktik keamanan terbaik yang memungkinkan Anda membatasi "radius kehancuran" ketika kunci dikompromikan.</b> <br><br>  Kubernetes akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara otomatis merotasi</a> beberapa sertifikat (khususnya, klien Kubelet dan sertifikat server) dengan membuat CSR baru setelah yang saat ini berakhir. <br><br>  Namun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci simetris yang</a> digunakan oleh server API untuk mengenkripsi nilai-nilai etcd tidak diputar secara otomatis - ini harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilakukan secara manual</a> .  Operasi ini memerlukan akses master, sehingga layanan yang dikelola (seperti GKE dan AKS) menyembunyikan masalah dari pengguna. <br><br><h2>  Bagian 2: beban kerja </h2><br>  Dengan keamanan minimal di level control plane, cluster sudah dapat berfungsi dengan aman.  Namun, seperti halnya kapal dengan muatan yang berpotensi berbahaya, kontainer dari kapal semacam itu harus melindungi muatan jika terjadi kecelakaan atau kebocoran yang tidak terduga.  Hal yang sama berlaku untuk beban kerja di Kubernetes ( <i>Pods</i> , <i>Deployment</i> , <i>Jobs</i> , <i>Sets</i> , dll.) - mereka dapat dipercaya pada saat penyebaran, tetapi jika mereka dapat diakses dari luar, selalu ada risiko bahwa mereka akan digunakan nanti oleh [penyerang].  Risiko ini dapat dikurangi dengan menjalankan beban kerja dengan hak istimewa minimal dan konfigurasi amannya. <br><br><h3>  6. Gunakan fitur keamanan Linux dan Kebijakan PodSecurity </h3><br>  <b>Kernel Linux memiliki banyak ekstensi keamanan yang tumpang tindih sebagian (kapabilitas, SELinux, AppArmor, seccomp-bpf) yang dapat dikonfigurasi untuk memberikan aplikasi hak istimewa minimal.</b> <br><br>  Utilitas seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bane</a> akan membantu Anda menghasilkan profil untuk AppArmor, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docker-slim</a> akan membantu Anda menghasilkan profil seccomp, tetapi berhati-hatilah: untuk mengidentifikasi semua efek samping dari penerapan kebijakan ini, Anda memerlukan rangkaian uji komprehensif yang memeriksa seluruh kode aplikasi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PodSecurityPolicies</a> mengatur penggunaan ekstensi keamanan ini, serta arahan keamanan Kubernetes lainnya.  Mereka bertanggung jawab atas persyaratan minimum yang harus dipenuhi untuk bisa masuk ke server API, termasuk profil keamanan, bendera hak istimewa, jaringan host bersama, proses atau ruang nama untuk IPC. <br><br>  Arahan-arahan ini penting karena mereka membantu mencegah proses kemas dari melarikan diri dari batas-batas mereka yang terisolasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh PodSecurityPolicy dari Tim Allclair</a> sangat fleksibel - Anda dapat menjadikannya sebagai dasar dan menyesuaikannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk kasing</a> Anda. <br><br><h3>  7. Lakukan analisis statis YAML </h3><br>  <b>Jika PodSecurityPolicies membatasi akses ke server API, maka analisis statis juga dapat digunakan dalam proses pengembangan untuk memodelkan persyaratan peraturan organisasi dan selera risiko.</b> <br><br>  Informasi sensitif tidak boleh disimpan dalam sumber daya YAML seperti perapian ( <i>Pods</i> , <i>Deployment</i> , <i>Sets</i> , dll.), Dan <i>ConfigMaps</i> dan <i>Rahasia</i> sensitif harus dienkripsi dengan utilitas seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vault</a> (dengan operator dari CoreOS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">git-crypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rahasia tersegel</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awan KMS cloud penyedia</a> . <br><br>  Analisis statis dari konfigurasi YAML dapat digunakan sebagai dasar untuk keamanan selama startup.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubesec</a> menghasilkan penilaian risiko untuk sumber daya: <br><br><pre> <code class="plaintext hljs">{ "score": -30, "scoring": { "critical": [{ "selector": "containers[] .securityContext .privileged == true", "reason": "Privileged containers can allow almost completely unrestricted host access" }], "advise": [{ "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege" }, { "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "href": "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" }] } }</code> </pre> <br>  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubetest</a> adalah kerangka kerja untuk pengujian unit konfigurasi Kubernetes: <br><br><pre> <code class="go hljs">#<span class="hljs-comment"><span class="hljs-comment">// vim: set ft=python: def test_for_team_label(): if spec["kind"] == "Deployment": labels = spec["spec"]["template"]["metadata"]["labels"] assert_contains(labels, "team", "should indicate which team owns the deployment") test_for_team_label()</span></span></code> </pre> <br>  Utilitas ini menerapkan pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shift kiri</a> (yaitu, mereka memindahkan validasi dan verifikasi ke tahap awal siklus pengembangan).  Pengujian keamanan pada tahap pengembangan memberikan umpan balik cepat kepada pengguna tentang kode dan konfigurasi, yang nantinya dapat ditolak dengan verifikasi manual atau otomatis, dan juga dapat memfasilitasi pengenalan praktik keamanan tambahan. <br><br><h3>  8. Jalankan kontainer bukan root </h3><br>  <b>Kontainer yang berjalan sebagai root sering memiliki hak lebih banyak dari yang dibutuhkan oleh pekerjaan mereka, dan jika dikompromikan, mereka membantu penyerang mencapai kemampuan yang hebat.</b> <br><br>  Kontainer masih mengandalkan model keamanan tradisional UNIX (disebut DAC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontrol akses diskresioner</a> ) - semuanya adalah file, dan hak diberikan kepada pengguna dan grup. <br><br>  Ruang nama pengguna tidak berfungsi di Kubernetes.  Ini berarti bahwa tabel ID pengguna dalam wadah dipetakan ke tabel pengguna host, dan memulai proses dengan hak akses root di dalam wadah menyebabkannya berjalan dengan hak akses root pada host.  Meskipun mekanisme ditambahkan ke semua ini untuk mencegah keluar dari wadah, berjalan sebagai root di dalam wadah tidak dianjurkan. <br><br>  Banyak gambar wadah menggunakan pengguna root untuk menjalankan PID 1: jika proses ini dikompromikan, penyerang mendapatkan root di dalam wadah dan, dengan kesalahan konfigurasi apa pun, pengoperasian masalah menjadi lebih mudah. <br><br>  Bitnami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan pekerjaan yang sangat baik</a> untuk menerjemahkan gambar wadah mereka ke pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa (non-root)</a> (yang juga merupakan persyaratan OpenShift default), yang dapat menyederhanakan migrasi Anda ke gambar non-root juga. <br><br>  Fragmen PodSecurityPolicy ini mencegah proses root dari berjalan di wadah dan meningkat ke root: <br><br><pre> <code class="plaintext hljs"># Required to prevent escalations to root. allowPrivilegeEscalation: false runAsUser: # Require the container to run without root privileges. rule: 'MustRunAsNonRoot'</code> </pre> <br>  Kontainer yang tidak menggunakan root tidak dapat menempati port yang diistimewakan, yaitu  hingga 1024 (kemampuan yang sesuai di kernel Linux - <code>CAP_NET_BIND_SERVICE</code> bertanggung jawab untuk ini), namun, menggunakan <i>Layanan</i> membantu menghindari batasan ini.  Berikut adalah contoh untuk aplikasi MyApp, yang menempati port 8443 dalam wadah, tetapi <i>Layanan</i> membuatnya tersedia di port 443, <code>targetPort</code> proxy permintaan untuk <code>targetPort</code> : <br><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: my-service spec: selector: app: MyApp ports: - protocol: TCP port: 443 targetPort: 8443</code> </pre> <br>  Kebutuhan untuk menjalankan beban kerja tanpa menggunakan root akan tetap sampai ruang nama pengguna atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waktu operasi</a> untuk meluncurkan kontainer tanpa root termasuk dalam runtime kontainer. <br><br><h3>  9. Gunakan kebijakan jaringan </h3><br>  <b>Secara default, jaringan Kubernetes memungkinkan semua lalu lintas antar pod.</b>  <b>Pengaturan ini dapat dibatasi oleh kebijakan jaringan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>NetworkPolicy</i></a> .</b> <br><br><img src="https://habrastorage.org/webt/kd/cv/xu/kdcvxufrkq2dm0jw13vk8hvowae.png"><br><br>  Layanan tradisional terbatas pada firewall yang menggunakan alamat IP statis dan rentang port untuk setiap layanan.  Karena alamat IP ini berubah sangat jarang, mereka secara historis telah digunakan sebagai bentuk otentikasi.  Kontainer jarang memiliki IP statis - sifatnya menyiratkan kemungkinan penurunan cepat dan penciptaan kembali, bagi mereka penemuan layanan digunakan sebagai ganti alamat IP statis.  Fitur-fitur ini sangat menyulitkan konfigurasi dan verifikasi firewall. <br><br>  Karena Kubernetes menyimpan semua data tentang keadaan sistem di etcd, dimungkinkan untuk mengkonfigurasi firewall dinamis - jika ada dukungan yang diperlukan dalam plugin jaringan CNI.  Calico, Cilium, kube-router, Romana dan Weave Net - semua plugin ini mendukung kebijakan jaringan. <br><br>  Penting untuk dicatat bahwa kebijakan bekerja pada prinsip gagal-ditutup, yaitu, tidak adanya <code>podSelector</code> sini secara default sama dengan semua nilai yang mungkin (wildcard): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny spec: podSelector:</code> </pre> <br>  Berikut ini adalah contoh <i>NetworkPolicy</i> , yang melarang segala sesuatu dari jalan keluar kecuali UDP 53 (DNS), yang juga mencegah koneksi masuk ke aplikasi.  Kebijakan <i>Jaringan</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah</a> kebijakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stateful</a> , sehingga aplikasi akan tetap menerima tanggapan untuk koneksi keluar. <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: myapp-deny-external-egress spec: podSelector: matchLabels: app: myapp policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP - to: - namespaceSelector: {}</code> </pre> <br>  Kebijakan jaringan Kubernetes tidak dapat diterapkan ke nama DNS.  Alasannya adalah bahwa DNS mendukung round-robin ke beberapa alamat IP dan respons dinamis yang tergantung pada akses IP, sehingga kebijakan jaringan hanya berlaku untuk alamat IP atau <code>podSelector</code> (untuk alamat IP dinamis Kubernetes). <br><br>  Praktik terbaik adalah mulai dengan melarang semua lalu lintas untuk namespace dan langkah demi langkah menambahkan rute yang diperlukan oleh aplikasi untuk lulus pengujian penerimaan.  Prosesnya bisa sulit, sehingga ControlPlane mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netassert</a> , sebuah utilitas untuk menguji keamanan jaringan dalam skrip DevSecOps dengan nmap yang sangat paralel: <br><br><pre> <code class="plaintext hljs">k8s: # used for Kubernetes pods deployment: # only deployments currently supported test-frontend: # pod name, defaults to `default` namespace test-microservice: 80 # `test-microservice` is the DNS name of the target service test-database: -80 # `test-frontend` should not be able to access test-database's port 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API new-namespace:test-microservice: # `new-namespace` is the namespace name test-database.new-namespace: 80 # longer DNS names can be used for other namespaces test-frontend.default: 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API</code> </pre> <br>  API dengan metadata dari penyedia cloud adalah sumber eskalasi potensial yang konstan (diperlihatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh karunia bug</a> terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shopify</a> ), jadi pengujian khusus yang mengonfirmasi bahwa API diblokir pada jaringan kontainer akan membantu melindungi terhadap kesalahan konfigurasi. <br><br><h3>  10. Pindai gambar dan jalankan IDS </h3><br>  <b>Server web adalah batu loncatan untuk menyerang jaringan yang dilampirkan.</b>  <b>Memindai file yang dipasang dalam gambar memungkinkan Anda memverifikasi bahwa tidak ada kerentanan yang diketahui yang dapat digunakan penyerang untuk mendapatkan akses jarak jauh ke wadah.</b>  <b>Intrusion Detection Systems (IDS) merekam kejadian ini jika terjadi.</b> <br><br>  Kubernetes memungkinkan pengiriman ke kluster melalui serangkaian pemeriksaan kontrol (dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengontrol penerimaan</a> ), yang berlaku tidak hanya untuk pod, tetapi juga sumber daya lain seperti <i>Penyebaran</i> .  Di dalamnya, masing-masing sub dapat divalidasi untuk masuk atau isinya dapat diubah, selain yang webhook di sisi backend sekarang juga didukung. <br><br><img src="https://habrastorage.org/webt/0s/-h/fw/0s-hfwbv4xf-izil5ljtxjxdyjm.png"><br><br>  Webhooks ini dapat digunakan oleh wadah alat pemindaian gambar untuk memverifikasi gambar sebelum digunakan untuk cluster.  Gambar yang gagal validasi tidak akan menerima persetujuan pengontrol. <br><br>  Memindai gambar kontainer untuk mengetahui kerentanan membantu mengurangi waktu penyerang dapat memanfaatkan CVE terbuka.  Untuk mencegah peluncuran gambar dengan kerentanan kritis dalam pipa penyebaran, Anda dapat menggunakan utilitas gratis seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clair</a> dari CoreOS dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micro Scanner</a> dari Aqua. <br><br>  Alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafeas</a> memungkinkan Anda untuk menyimpan metadata gambar untuk pemeriksaan kepatuhan dan kerentanan yang sedang berlangsung menggunakan tanda tangan wadah unik (atau hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalamatan konten</a> khusus).  Memindai gambar kontainer menggunakan hash ini sama dengan memindai gambar yang digunakan dalam produksi dan dapat dilakukan terus menerus tanpa perlu memiliki akses ke lingkungan produksi. <br><br>  Kerentanan 0day yang tidak diketahui akan selalu ada, jadi Kubernetes harus menggunakan sistem deteksi intrusi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twistlock</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aqua,</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sysdig Secure</a> .  IDS mendeteksi perilaku yang tidak biasa dalam wadah dan menghentikan atau membunuhnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sysdig's Falco</a> adalah mesin aturan Open Source dan titik awal untuk ekosistem ini. <br><br><h2>  Bagian 3: Masa Depan </h2><br>  Tahap keamanan berikutnya dalam "evolusi awan asli" tampaknya adalah service mesh, meskipun penerapannya tidak akan segera terjadi: migrasi ini membutuhkan pengalihan kompleksitas aplikasi ke infrastruktur mesh, dan organisasi harus menyadari praktik terbaik ini. <br><br><img src="https://habrastorage.org/webt/rm/qu/_m/rmqu_mfve6uvnnlaidl_bkjutqm.png"><br><br><h3>  11. Luncurkan mesh layanan </h3><br>  <b>Service mesh adalah jaringan koneksi terenkripsi persisten yang dibuat antara "sisi-terhubung" <i>(mirip dengan "sespan")</i> , proksi berkinerja tinggi seperti Utusan dan Linkerd.</b>  <b>Ini membawa manajemen lalu lintas, pemantauan, dan kebijakan - semua tanpa perubahan dalam layanan microser.</b> <br><br>  Transfer keamanan dan kode terkait jaringan dari layanan microser ke perangkat perpustakaan yang dibagikan dan diuji pertempuran sudah dimungkinkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linkerd</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio</a> dari Google, IBM dan Lyft membawa alternatif ke ruang ini.  Dengan penambahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPIFFE</a> untuk identitas kriptografis dari setiap pod dan banyak fitur lainnya, Istio dapat menyederhanakan penyebaran keamanan jaringan generasi mendatang. <br><br>  Dalam jaringan "nol kepercayaan" mungkin tidak ada kebutuhan untuk firewall tradisional atau kebijakan jaringan Kubernet, karena setiap interaksi terjadi menggunakan mTLS (mutual TLS), yang tidak hanya menjamin keamanan interaksi, tetapi juga mengkonfirmasi identitas kedua layanan . <br><br>  Pergeseran dari pendekatan jaringan tradisional ini ke prinsip keamanan dunia Cloud Native tidak akan mudah bagi mereka yang memiliki pola pikir keamanan tradisional.  Sebagai pengantar dunia baru ini, kami sangat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku Zero Trust Networking</a> karya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evan Gilman</a> dari SPIFFE. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio 0,8 LTS</a> saat ini tersedia, dan proyek ini dengan cepat mendekati rilis 1.0-nya.  Versi proyek dalam hal stabilitas dilakukan mirip dengan model Kubernetes: kernel yang stabil dengan API terpisah yang status alpha atau beta mereka diindikasikan menggunakan ruang nama.  Harapkan untuk melihat Istio berkembang dalam beberapa bulan mendatang. <br><br><h2>  Kesimpulan </h2><br>  Aplikasi Cloud Native memiliki kumpulan primitif keamanan ringan yang lebih rinci yang membantu melindungi beban kerja dan infrastruktur.  Kekuatan dan fleksibilitas alat-alat semacam itu adalah berkah sekaligus kutukan: tanpa otomatisasi yang memadai [untuk penggunaannya], mengekspos aplikasi yang tidak aman untuk melampaui wadah atau model isolasi mereka menjadi lebih mudah. <br><br>  Utilitas untuk perlindungan lebih mudah diakses daripada sebelumnya, namun, untuk mengurangi potensi serangan dan potensi untuk konfigurasi yang salah, Anda harus menggunakannya dengan hati-hati. <br><br>  Jika keamanan memperlambat kecepatan organisasi dalam mengirimkan perubahan, itu tidak akan pernah menjadi prioritas.  Menggunakan prinsip-prinsip Pengiriman Berkelanjutan dalam kaitannya dengan rantai pasokan perangkat lunak memungkinkan organisasi untuk mencapai kepatuhan terhadap peraturan, audit berkelanjutan dan peningkatan manajemen tanpa memengaruhi kinerja bisnis. <br><br>  Peningkatan keamanan yang cepat dan bertahap adalah cara termudah dengan rangkaian uji komprehensif.    Continuous Security —          pipeline', ,    ,     . <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OPA  SPIFFE —     CNCF    </a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vulnerable Docker VM — -  Docker  pentesting</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  service mesh      [    ]?</a>  "; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conduit —  service mesh  Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">      Kubernetes</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Infrastruktur dengan Kubernet sebagai layanan yang terjangkau</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417905/">https://habr.com/ru/post/id417905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417895/index.html">Perbaikan printer 3D dan peralatan mesin: bagaimana layanan Toko 3D Top bekerja di Moskow dan St. Petersburg</a></li>
<li><a href="../id417897/index.html">PHP Digest No. 135 (9-23 Juli 2018)</a></li>
<li><a href="../id417899/index.html">Cari node varians kontrol (cara berhenti melakukan pekerjaan bodoh dan mentransfernya ke yang lain)</a></li>
<li><a href="../id417901/index.html">Bagaimana kami mulai membuat pertemuan panjang yang luar biasa, dan mengapa ini bukan lagi kejahatan universal</a></li>
<li><a href="../id417903/index.html">Kasus Peninjauan Kode 1</a></li>
<li><a href="../id417909/index.html">Mengapa Anda perlu Splunk? Analisis aplikasi</a></li>
<li><a href="../id417911/index.html">Desain berkelanjutan dalam pengembangan: metodologi dan prinsip</a></li>
<li><a href="../id417913/index.html">Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 3</a></li>
<li><a href="../id417915/index.html">Cara bermain teman sekamar</a></li>
<li><a href="../id417917/index.html">ASC'18: Kegigihan dan pelatihan reguler sebagai cara untuk mencapai tujuan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>