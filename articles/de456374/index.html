<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍑 🦑 💌 Plasma Cash Blockchain State Datenstrukturen 🔇 🖌️ 👥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo liebe Habrauser! In diesem Artikel geht es um Web 3.0, das Internet mit Dezentralisierung. Web 3.0 führt das Konzept der Dezentralisierung als G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plasma Cash Blockchain State Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456374/">  Hallo liebe Habrauser!  In diesem Artikel geht es um Web 3.0, das Internet mit Dezentralisierung.  Web 3.0 führt das Konzept der Dezentralisierung als Grundlage für das moderne Internet ein. Viele Computersysteme und Netzwerke benötigen für ihre Anforderungen Sicherheits- und Dezentralisierungseigenschaften.  Die Dezentralisierungslösung wird als verteilte Registrierungstechnologie oder Blockchain bezeichnet. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain ist eine verteilte Registrierung.  Es kann als eine riesige Datenbank betrachtet werden, die für immer lebt und sich in der Geschichte nicht ändert. Die Blockchain wird als Grundlage für dezentrale Webanwendungen oder -dienste verwendet. <br><br>  Im Wesentlichen ist Blockchain nicht nur eine Datenbank, sondern bietet auch die Möglichkeit, das Vertrauen zwischen Netzwerkteilnehmern zu stärken und Geschäftslogik im Netzwerk auszuführen. <br><br>  Byzantinischer Konsens erhöht die Netzwerkzuverlässigkeit und löst das Problem der Konsistenz <br>  Die Skalierbarkeit, die DLT bietet, verändert bestehende Geschäftsnetzwerke. <br><br>  Blockchain bietet neue sehr wichtige Vorteile: <br><br><ol><li>  Vermeidung kostspieliger Fehler. </li><li>  Transparente Transaktionen. </li><li>  Digitalisierung für echte Güter. </li><li>  Intelligente Verträge. </li><li>  Geschwindigkeit und Sicherheit der Zahlungen. </li></ol><br>  Opporty PoE ist ein Projekt, dessen Ziel es ist, kryptografische Protokolle zu untersuchen und vorhandene DLT- und Blockchain-Lösungen zu verbessern. <br><br>  Die meisten öffentlich verteilten Registrierungssysteme haben keine Skalierbarkeitseigenschaften - ihr Durchsatz ist eher gering.  Zum Beispiel verarbeitet das Ethereum nur ~ 20 tx / s. <br>  Viele Lösungen wurden entwickelt, um die Skalierbarkeitseigenschaft zu erhöhen und die Dezentralisierung nicht zu verlieren (wie Sie wissen, können nur 2 von 3 bekannt sein: Skalierbarkeit, Sicherheit, Dezentralisierung). <br><br>  Eine der effektivsten ist eine Lösung mit Seitenketten. <br><br><h2>  Plasmakonzept </h2><br>  Das Konzept besteht darin, dass die Wurzelkette eine kleine Anzahl von Commits von untergeordneten Ketten verarbeitet, sodass die Wurzelkette als sicherste und letzte Schicht zum Speichern aller Zwischenzustände fungiert.  Jede untergeordnete Kette fungiert als eigene Blockchain mit einem eigenen Konsensalgorithmus, es gibt jedoch einige wichtige Einschränkungen. <br><br><ul><li>  Intelligente Verträge werden in der Stammkette erstellt und fungieren als Prüfpunkt für die untergeordnete Kette in der Stammkette. </li><li>  Es wird eine untergeordnete Kette erstellt, die als eigene Blockchain mit eigenem Konsens fungiert.  Alle Zustände in der Kette der untergeordneten Prozesse sind durch Betrugsnachweise geschützt, die sicherstellen, dass alle Übergänge zwischen Zuständen gültig sind und ein Widerrufsprotokoll anwenden. </li><li>  Intelligente Verträge, die für dapp oder untergeordnete Kette (Anwendungslogik) spezifisch sind, können dann in untergeordneter Kette bereitgestellt werden. </li><li>  Die notwendigen Werkzeuge können von der Wurzelkette zur untergeordneten Kette übertragen werden. </li></ul><br>  Validatoren haben wirtschaftliche Anreize, ehrlich zu handeln und Kommentare an die Wurzelkette zu senden - die Ebene der endgültigen Abwicklung der Transaktion. <br><br>  Daher sollten dapp-Benutzer, die in der untergeordneten Kette arbeiten, überhaupt nicht mit der Stammkette interagieren.  Außerdem können sie ihr Geld jederzeit an die Wurzelkette abheben, selbst wenn die Kinderkette gehackt wird.  Diese Ausgänge aus der Kinderkette ermöglichen es Benutzern, ihre Gelder mithilfe von Merkle-Beweisen sicher aufzubewahren, was den Besitz eines bestimmten Geldbetrags bestätigt. <br><br>  Die Hauptvorteile von Plasma hängen mit seiner Fähigkeit zusammen, die Berechnungen, die derzeit die Hauptkette überlasten, erheblich zu vereinfachen.  Darüber hinaus kann die Ethereum-Blockchain umfangreichere und parallelere Datensätze verarbeiten.  Die aus der Wurzelkette entnommene Zeit wird auch an Ethereum-Knoten übertragen, die geringere Verarbeitungs- und Speicheranforderungen haben. <br><br>  Plasma Cash ist ein Design, das Netzwerk-Token eindeutige Seriennummern gibt, die sie in eindeutige Token verwandeln.  Zu den Vorteilen zählen das Fehlen von Bestätigungsbedürfnissen, eine einfachere Unterstützung für alle Arten von Token (einschließlich nicht fungibler Token) und die Abschwächung gegen Massenausgänge aus der Kinderkette. <br><br>  Das Plasmaproblem hängt mit dem Konzept der "Massenausgänge" aus der Kinderkette zusammen.  In diesem Szenario kann ein koordinierter gleichzeitiger Austritt aus der Tochterkette möglicherweise zu einem Mangel an Rechenleistung führen, um alle Gelder abzuheben.  Infolgedessen können Benutzer Geld verlieren. <br><br><h2>  Plasma-Implementierungsoptionen </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Das Basisplasma bietet viele Optionen für die Implementierung. <br><br>  Die Hauptunterschiede sind: <br><br><ul><li>  Speichern von Informationen über die Methode zum Speichern und Präsentieren des Zustands, </li><li>  Arten von Token (teilbar unteilbar), </li><li>  Transaktionssicherheit </li><li>  Art des Konsensalgorithmus usw. </li></ul><br>  Die Hauptvarianten von Plasma: <br><br><ul><li>  UTXO-basiert - Jede Transaktion besteht aus Ein- und Ausgaben: Eine Transaktion kann ausgeführt und ausgegeben werden. Die Liste der nicht ausgegebenen Transaktionen ist ein Status der untergeordneten Kette. </li><li>  Kontobasiert - enthält lediglich eine Darstellung jedes Kontos und seines Kontostands. Dieser Typ wird im Ethereum verwendet, da jedes Konto zwei Typen haben kann - ein Benutzerkonto und ein intelligentes Vertragskonto.  Der Vorteil dieser Art der Statusspeicherung ist ihre Einfachheit, und das Minus ist, dass diese Option nicht skalierbar ist (die spezielle Nonce-Eigenschaft wird verwendet, um zu verhindern, dass die Transaktion zweimal ausgeführt wird). </li></ul><br>  In diesem Artikel werden die Datenstrukturen erläutert, die in der Plasma Cash-Blockchain verwendet werden. <br><br>  Um genau zu verstehen, wie Engagement funktioniert, müssen Sie das Konzept des Merkle-Baums klären. <br><br><h2>  Merkle Bäume ihre Verwendung in Plasma </h2><br>  Merkle-Bäume sind eine äußerst wichtige Datenstruktur in der Blockchain-Welt.  Im Wesentlichen bieten Merkle-Bäume die Möglichkeit, einen Datensatz so zu erfassen, dass die Daten ausgeblendet werden. Benutzer können jedoch nachweisen, dass einige der Informationen im Satz enthalten waren.  Wenn ich beispielsweise zehn Zahlen habe, kann ich einen Beweis für diese Zahlen erstellen und dann beweisen, dass eine bestimmte Zahl in diesem Satz von Zahlen enthalten war.  Diese Proofs haben eine kleine konstante Größe, was die Veröffentlichung in Ethereum billig macht. <br><br>  Sie können dies für eine Reihe von Transaktionen verwenden.  Sie können auch nachweisen, dass sich eine bestimmte Transaktion in dieser Gruppe von Transaktionen befindet.  Genau das macht der Bediener.  Jeder Block besteht aus einer Reihe von Transaktionen, die sich in einen Merkle-Baum verwandeln.  Die Wurzel dieses Baumes ist der Beweis, der zusammen mit jedem Plasmablock im Ethereum veröffentlicht wird. <br><br>  Benutzer sollten in der Lage sein, ihr Geld aus der Plasmakette abzuheben. Wenn Benutzer die Plasmakette verlassen möchten, senden sie die Transaktion „Beenden“ an Ethereum. <br><br>  Plasma Cash verwendet einen speziellen Merkle-Baum, der es ermöglicht, nicht den gesamten Block, sondern nur die Zweige zu validieren, die dem Token des Benutzers entsprechen. <br><br>  Das heißt, um ein Token zu übertragen, müssen Sie den Verlauf durchgehen und nur die Token scannen, die ein bestimmter Benutzer benötigt. Beim Übertragen eines Tokens gibt der Benutzer einfach den gesamten Verlauf an einen anderen Benutzer weiter und kann die gesamte Geschichte bereits authentifizieren - und vor allem sehr schnell. <br><br><img src="https://habrastorage.org/webt/wx/is/3z/wxis3zgyhtyh-ruopuffedzcwsk.png"><br><br><h2>  Plasma Cash-Datenstrukturen zum Speichern von Status und Verlauf </h2><br>  Es ist jedoch erforderlich, nur einige Merkle-Bäume zu verwenden, da beispielsweise ein Nachweis über die Aufnahme und auch ein Nachweis über die Nichteinbeziehung der Transaktion in den Block erforderlich ist. <br><br><ul><li>  Spärlicher Merkle-Baum </li><li>  Patricia versucht </li></ul><br>  Opporty hat die Implementierung von Sparse Merkle Tree und Patricia Trie abgeschlossen <br><br>  Ein spärlicher Merkle-Baum ähnelt einem Standard-Merkle-Baum, außer dass die darin enthaltenen Daten indiziert werden und jeder Datenpunkt auf einem Blatt platziert wird, das dem Index dieses Datenpunkts entspricht <br><br>  Nehmen wir an, wir haben einen Merkle-Baum mit vier Blättern.  Wir werden diesen Baum zur Demonstration mit ein paar Buchstaben (A, D) füllen.  Der Buchstabe A ist der erste Buchstabe des Alphabets, daher müssen wir ihn auf das erste Blatt setzen.  Ebenso können wir D auf das vierte Blatt setzen. <br><br>  Was passiert also im zweiten und dritten Blatt?  Wir lassen sie einfach leer.  Genauer gesagt wird ein spezieller Wert (z. B. Null) anstelle des Buchstabens platziert. <br><br>  Der Baum sieht letztendlich so aus: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  Der Inklusionsnachweis funktioniert genau wie bei einem normalen Merkle-Baum. Was passiert, wenn wir beweisen wollen, dass C nicht Teil dieses Merkle-Baums ist?  Das ist einfach!  Wir wissen, dass wenn C Teil eines Baumes wäre, es auf dem dritten Blatt wäre.  Wenn C nicht Teil des Baumes ist, muss das dritte Blatt Null sein. <br><br>  Alles, was benötigt wird, ist der Standardnachweis für die Aufnahme von Merkle, der zeigt, dass das dritte Blatt Null ist. <br><br>  Das Beste an einem spärlichen Merkle-Baum ist, dass sie wirklich Schlüsselwertspeicher im Merkle-Baum darstellen! <br><br>  Hier ist ein Teil des PoE-Protokollcodes, der den Sparse Merkle Tree-Build implementiert. <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  Dieser Code ist ziemlich trivial.  Wir haben einen Schlüsselwertspeicher mit Nachweis der Einbeziehung / Nichteinbeziehung. <br><br>  In jeder Iteration wird eine bestimmte Ebene des endgültigen Baums gefüllt, beginnend mit der letzten.  Je nachdem, welcher Schlüssel des aktuellen Blattes gerade oder ungerade ist, nehmen wir zwei benachbarte Blätter und betrachten den Hash der aktuellen Ebene.  Wenn wir das Ende erreichen, schreiben wir einen einzelnen merkleRoot - einen gemeinsamen Hash. <br><br>  Sie müssen verstehen, dass dieser Baum bereits mit anfänglich leeren Werten gefüllt ist!  Und wenn wir eine große Menge an IDS-Token speichern.  Wir haben eine riesige Baumgröße und die Generierung dauert sehr lange! <br><br>  Es gibt viele Lösungen für diese Unoptimierung, aber Opporty hat beschlossen, diesen Baum in Patricia Trie zu ändern. <br><br>  Patricia Trie ist eine Mischung aus Radix Trie und Merkle Trie. <br><br>  Der Radix Trie-Datenschlüssel speichert den Datenpfad selbst!  Auf diese Weise können Sie eine optimierte Datenstruktur für den Speicher erstellen! <br><br><img src="https://habrastorage.org/webt/af/zc/ly/afzclyhgeydkylbnn5hrjj0gs-g.png"><br><br><h3>  Gelegenheitsumsetzung </h3><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre><br>  Das heißt, wir gehen rekursiv durch und erstellen getrennte linke und rechte untergeordnete Teilbäume.  Gleichzeitig ist das Erstellen des Schlüssels wie ein Pfad in diesem Baum! <br><br>  Diese Lösung ist noch trivialer und arbeitet schneller, während sie ziemlich optimiert ist!  Tatsächlich kann der Patricia-Baum weiter optimiert werden, indem neue Knotentypen eingeführt werden - Erweiterungsknoten, Verzweigungsknoten usw., wie im Ethereum-Protokoll, aber diese Implementierung erfüllt alle unsere Bedingungen - wir haben eine schnelle und speicheroptimierte Datenstruktur. <br><br>  Durch die Implementierung dieser Datenstrukturen ermöglichte Opporty die Skalierung von Plasma Cash, da es möglich ist, den Verlauf des Tokens zu überprüfen und die Nichteinbeziehung des Tokens in den Baum zu ermöglichen!  Auf diese Weise können Sie die Validierung von Blöcken und der untergeordneten Plasmakette selbst erheblich beschleunigen. <br><br><h3>  Nützliche Links: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weißbuchplasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsfälle und Architekturbeschreibung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning-Netzwerkpapier</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456374/">https://habr.com/ru/post/de456374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456362/index.html">Level 6 Designer: Wie wir Designer motivieren und entwickeln</a></li>
<li><a href="../de456366/index.html">Wie ich die LED HEART Box entworfen habe</a></li>
<li><a href="../de456368/index.html">Durchführen öffentlicher und privater Transaktionen in der JPMorgan Quorum-Blockchain mit Web3</a></li>
<li><a href="../de456370/index.html">Implementieren Sie QoS in Qsan Storage</a></li>
<li><a href="../de456372/index.html">SimbirSoft lädt IT-Experten zum Intensivsommer 2019 ein</a></li>
<li><a href="../de456376/index.html">Not One Spring Boot: Ein Überblick über Alternativen</a></li>
<li><a href="../de456380/index.html">Tag der offenen Tür der Fakultät für Programmierung in der Netologie</a></li>
<li><a href="../de456382/index.html">Zusammenarbeit und Automatisierung im Frontend. Was wir aus 13 Schulen gelernt haben</a></li>
<li><a href="../de456386/index.html">Öffnen Sie Bibliotheken zur Visualisierung von Audioinhalten</a></li>
<li><a href="../de456388/index.html">Diagnoseentwicklungsdiagramm in PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>