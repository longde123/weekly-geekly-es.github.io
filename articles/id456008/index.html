<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏼 👼🏻 👰🏻 Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA 🆙 🧕🏽 ▶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, saya mengatakan bahwa sudah saatnya bagi kita untuk beralih ke protokol streaming. Tetapi setelah mulai menyiapkan cerita te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456008/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya mengatakan bahwa sudah saatnya bagi kita untuk beralih ke protokol streaming.  Tetapi setelah mulai menyiapkan cerita tentang mereka, saya menyadari bahwa saya sendiri sedang berenang dalam satu topik yang sangat penting.  Seperti yang sudah disebutkan, hubungan saya dengan Linux cukup aneh.  Secara umum, saya menyadari bahwa saya sendiri tidak dapat membuat dari awal aplikasi C ++ yang akan memenuhi semua prinsip pemrograman untuk Redd.  Anda dapat meminta seseorang untuk melakukan ini, dan kemudian hanya menggunakan template yang sudah jadi, tetapi serangkaian artikel dirancang untuk mengajarkan semua orang bagaimana mengembangkan di bawah Redd dari awal.  Karena itu, saya bertanya kepada bos saya (spesialis Linux yang hebat), dan dia menjelaskan kepada saya apa yang harus diklik.  Kemudian saya sedikit memikirkan kembali kata-katanya dan sekarang saya menganggap perlu untuk memperbaiki semua pengetahuan secara tertulis.  Ini akan menyelamatkan orang-orang seperti saya dari pikiran yang menyakitkan: "Jadi ... Apa yang dia lakukan dapat dimengerti, tetapi bagaimana saya bisa mengulanginya?"  Secara umum, siapa pun yang bekerja di Linux dapat menjalankan dua bagian berikut secara diagonal.  Tidak mungkin Anda akan menemukan sesuatu yang baru di sana (Anda akan menemukan lebih lanjut).  Dan untuk sisanya, saya menawarkan pilihan dua metode pengembangan yang sesuai dengan prinsip kerja yang dinyatakan di bawah Redd: biaya tenaga kerja rendah untuk pengembangan dan debugging jarak jauh. <br><br><img src="https://habrastorage.org/webt/kb/sk/5c/kbsk5cbh98eftndkgneifjnzgao.jpeg"><br><a name="habracut"></a><br>  Semua artikel siklus: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</a> </li></ol><br><h2>  Bekerja dengan Alat Visual Studio </h2><br>  Ternyata Anda dapat melakukan pengembangan untuk Linux jarak jauh, tanpa memilikinya di mesin lokal Anda sama sekali, dan tanpa menginstal alat perangkat lunak non-Microsoft.  Di sini diperlihatkan bagaimana ia diletakkan di Visual Studio (saya menginstalnya di versi 2019, tetapi ternyata, itu muncul pada 2015) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.microsoft.com/ru-ru/cpp/linux/download-install-and-setup- the-linux-development-workload? view = vs-2019</a> <br><br>  Dan inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori kerjanya</a> . <br><br>  Nah, di sana Anda dapat berjalan di sekitar tab, banyak teori, dan semuanya dalam bahasa Rusia. <br><br>  Hebat!  Mari kita coba menggunakan pengetahuan yang didapat untuk mengakses chip FT2232H, di mana prosesor pusat Redd terhubung ke FPGA.  Saluran inilah di masa depan yang akan membentuk dasar dari pekerjaan streaming kami.  Buka Visual Studio, pilih "Buat Proyek."  Di filter, pilih "Bahasa - C ++", "Platform - Linux", "Jenis Proyek - Konsol".  Saya akan menunjukkan di mana ini sudah terletak untuk jenis proyek.  Dari apa yang telah kami filter, kami memilih "Aplikasi Konsol": <br><br><img src="https://habrastorage.org/webt/ao/5x/h4/ao5xh4h5fwoldpjdn_-rpx8ay2a.png"><br><br>  Sebut saja, katakanlah, SimpleConsole.  Kami telah membuat kode sumber Spartan seperti itu: <br><br><pre><code class="plaintext hljs">#include &lt;cstdio&gt; int main() { printf("hello from SimpleConsole!\n"); return 0; }</code> </pre> <br>  Ayo coba kumpulkan.  Dan kami ditanya pertanyaan yang sangat menarik tentang membangun koneksi.  Ini adalah fitur pengembangan di Visual Studio.  Lingkungan tidak mengandung cross-compiler dan perpustakaan apa pun.  Itu hanya membuat direktori sumber pada mesin remote, setelah itu untuk setiap kompilasi ia menyalin file yang diperbarui ke sana dan mulai kompilasi di sana.  Itu sebabnya koneksi dengan mesin jarak jauh tidak boleh dibuat untuk memulai, tetapi sudah untuk perakitan normal proyek. <br><br>  Kami mengisi parameter untuk pengguna Redd, atas nama siapa pekerjaan akan dilakukan pada proyek. <br><br><img src="https://habrastorage.org/webt/jd/sx/hk/jdsxhkvvklw29zjoecvrr1svvda.png"><br><br>  Jika ada - parameter dapat diubah di sini di tempat rahasia ini (jangan mencoba mengubah properti proyek, itu tidak akan menghasilkan sesuatu yang baik): <br><br><img src="https://habrastorage.org/webt/dn/xe/yd/dnxeydmzx11e50rtxzjayuleto0.png"><br><br><img src="https://habrastorage.org/webt/ow/k-/le/owk-leapmriognn1l-kk4tavvyc.png"><br><br>  Sebenarnya, Anda dapat meletakkan breakpoint pada satu baris dan memverifikasi bahwa proyek dimulai dan berfungsi.  Tapi ini sepele.  Oleh karena itu, kami beralih ke tugas yang lebih menarik - bekerja dengan FT2232.  Muncul pertanyaan: dari mana mendapatkan perpustakaan yang diperlukan?  Untuk Linux, semuanya sudah termasuk dalam paket driver.  Ada driver itu sendiri, dan perpustakaan, dan contoh aplikasi untuk bekerja dengannya, dan bahkan instruksi singkat.  Secara umum, kami berkendara ke mesin pencari: <br><br><pre> <code class="plaintext hljs">FTDI D2XX drivers</code> </pre> <br>  Dia akan menunjukkan di mana mereka dapat diunduh.  Benar, khususnya, semuanya buruk bagi saya.  Penyedia saya memblokir situs web FTDI (dan juga reprap, 7zip, dan bahkan osronline), merujuk pada RosKomNadzor.  ILV, dalam menanggapi pernyataan, mengirim berhenti berlangganan, mengatakan bahwa kami tidak memblokir apa pun, tetapi berurusan dengan penyedia sendiri.  Di mana hanya di langganan ini mereka tidak menawarkan saya untuk beralih, bahkan ke polisi.  Mereka sangat berhenti berlangganan.  Upaya untuk mengeluh tentang kelambanan ILV akhirnya diteruskan ke ILV, dari mana pelanggan yang berhenti berlangganan berikutnya.  Secara umum, mungkin penyedia Anda juga akan memblokir akses.  Jangan khawatir, cari saja cara lain untuk mengunduh, habiskan waktu untuk ini.  Dan kemudian mereka terkejut bahwa pengembangan rudal tertunda selama beberapa dekade ... Saya memulai korespondensi dengan ILV November lalu, sekarang Juni, kecuali untuk berhenti berlangganan - tidak ada tindakan ... Tapi saya terganggu. <br><br>  Cara menggunakan driver dapat ditemukan di file readme, dalam paket itu sendiri.  Anda juga dapat menemukan dokumen <b>AN_220 FTDI Drivers Installation Guide untuk Linux</b> .  Terakhir, Anda dapat menemukan video tentang <b>Panduan Instalasi Driver d2xx</b> di YouTube oleh Chips FTDI di YouTube.  Tautan ke sana juga ada di halaman pengunduhan driver.  Secara umum, FTDI tidak menjalankan opsi untuk memberi tahu pengguna.  Sebenarnya, jika Anda menerima paket Redd yang sudah jadi, maka driver itu sendiri sudah diinstal dan dikonfigurasi di dalamnya.  Dan kita akan tertarik pada file dan contoh header. <br><br>  Mari kita masukkan contoh slice <b>\ release \amples \ EEPROM \ baca</b> .  Bagian paling awal dari fungsi <b>utama</b> , tempat perangkat terbuka dan jenisnya diambil.  Ini akan cukup untuk memastikan semuanya bekerja.  Saya benci label, tetapi karena kami hanya dengan cepat menarik dan melepas kode yang hidup 10 menit, saya akan menyeret label yang ada dalam contoh asli untuk menghemat waktu.  Ternyata seperti ini: <br><br><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include "ftd2xx.h" int main(int argc, char* argv[]) { printf("hello from ConsoleApplication1!\n"); FT_STATUS ftStatus; FT_HANDLE ftHandle0; int iport; static FT_PROGRAM_DATA Data; static FT_DEVICE ftDevice; DWORD libraryVersion = 0; int retCode = 0; ftStatus = FT_GetLibraryVersion(&amp;libraryVersion); if (ftStatus == FT_OK) { printf("Library version = 0x%x\n", (unsigned int)libraryVersion); } else { printf("Error reading library version.\n"); return 1; } if (argc &gt; 1) { sscanf(argv[1], "%d", &amp;iport); } else { iport = 0; } printf("Opening port %d\n", iport); ftStatus = FT_Open(iport, &amp;ftHandle0); if (ftStatus != FT_OK) { /* This can fail if the ftdi_sio driver is loaded use lsmod to check this and rmmod ftdi_sio to remove also rmmod usbserial */ printf("FT_Open(%d) failed\n", iport); return 1; } printf("FT_Open succeeded. Handle is %p\n", ftHandle0); ftStatus = FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL); if (ftStatus != FT_OK) { printf("FT_GetDeviceType FAILED!\n"); retCode = 1; goto exit; } printf("FT_GetDeviceInfo succeeded. Device is type %d.\n", (int)ftDevice); exit: return 0; }</code> </pre><br>  Mencoba untuk mengumpulkan - tidak akan melakukannya.  File header tidak cukup. <br><br><pre> <code class="plaintext hljs">1&gt;main.cpp 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : ftd2xx.h:      1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : #include "ftd2xx.h" 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : ^ 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(5,20): error : compilation terminated.</code> </pre><br>  Tapi saya menempatkan mereka selanjutnya!  Semuanya sederhana.  Secara lokal, mereka berada di dekatnya, tetapi perakitan sedang dilakukan dari jarak jauh.  Agar Studio memindahkannya ke mesin jarak jauh, Anda perlu menambahkannya ke proyek.  Selain itu, dari file <b>main.cpp</b> saya menambahkan hanya <b>ftd2xx.h</b> , tetapi masih <b>menarik WinTypes.h dalam perjalanan</b> .  Anda harus menambahkan keduanya. <br><br><img src="https://habrastorage.org/webt/gy/-2/-j/gy-2-jt8ej_mbavcpupdsphb5g8.png"><br><br><img src="https://habrastorage.org/webt/kp/ye/l1/kpyel11pdcxgnd5ojt39rhkkslk.png"><br><br>  Sekarang penghubung bersumpah. <br><br><pre> <code class="plaintext hljs">1&gt;  1&gt;D:\Work\SimpleConsole\SimpleConsole\obj\x64\Debug\main.o : error : In function `main': 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(18): error : undefined reference to `FT_GetLibraryVersion' 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(37): error : undefined reference to `FT_Open' 1&gt;D:\Work\SimpleConsole\SimpleConsole\main.cpp(55): error : undefined reference to `FT_GetDeviceInfo' 1&gt;collect2 : error : ld returned 1 exit status</code> </pre><br>  Jelas bahwa perpustakaan tidak cukup.  Memeriksa contoh <b>makefile</b> , saya menyadari bahwa saya perlu menambahkan beberapa parameter ke pengaturan tautan: <br><br><img src="https://habrastorage.org/webt/xy/zm/2i/xyzm2igciaxlmevvppuug4vk2go.png"><br><br><img src="https://habrastorage.org/webt/xd/p2/f1/xdp2f1nxqd3bue69dqx8m-dgabc.png"><br><br>  Sekarang proyek ini berjalan dengan sukses.  Kami meletakkan breakpoint di baris terakhir, coba jalankan.  Kami melihat teks berikut: <br><br><pre> <code class="plaintext hljs">hello from ConsoleApplication1! Library version = 0x10408 Opening port 0 FT_Open succeeded. Handle is 0x555555768540 FT_GetDeviceInfo succeeded. Device is type 10.</code> </pre><br>  Secara keseluruhan - tidak buruk.  Sesuatu terbuka, bahkan beberapa perangkat ditemukan.  Apa itu tipe 10?  Dalam file header dari FTDI kami menemukan: <br><br><pre> <code class="plaintext hljs">enum { FT_DEVICE_BM, FT_DEVICE_AM, FT_DEVICE_100AX, FT_DEVICE_UNKNOWN, FT_DEVICE_2232C, FT_DEVICE_232R, FT_DEVICE_2232H, FT_DEVICE_4232H, FT_DEVICE_232H, FT_DEVICE_X_SERIES, FT_DEVICE_4222H_0, FT_DEVICE_4222H_1_2, FT_DEVICE_4222H_3, FT_DEVICE_4222_PROG, };</code> </pre><br>  Kami menghitung jari dari atas ke bawah - di depan kami adalah FT4222H.  Ya, Redd memiliki banyak perangkat FTDI.  Sekarang saya akan mengatakan secara singkat bahwa kita perlu memilah-milah jumlah perangkat yang diteruskan ke fungsi <b>FT_Open ()</b> , angka ini diteruskan ke fungsi <b>utama ()</b> sebagai argumen.  Itu dapat diatur dalam properti debugging proyek. <br><br>  Sangat berguna untuk menempatkan piring dengan masalah khas.  Secara umum, dikatakan "configure Redd" di mana-mana tanpa detail.  Faktanya adalah bahwa kompleks akan didistribusikan sesuai pesanan, sehingga semua pembaca tidak memerlukan aturan konfigurasi.  Jika terjadi masalah, administrator biasanya akan menangani konfigurasi.  Jadi ternyata Anda bisa, tentu saja, menjelaskan aturan konfigurasi, tetapi itu akan memakan banyak ruang.  Masuk akal untuk menghabiskan energi hanya jika seseorang benar-benar membutuhkannya.  Jadi di sini saya akan membatasi diri hanya untuk menunjukkan masalah, dan bagaimana cara memperbaikinya saya akan menjelaskan jika ada aplikasi dalam umpan balik. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Gejala </th><th>  Alasan </th></tr><tr><td>  Tidak ada satu perangkat pun yang terbuka. </td><td>  Secara default, Linux memerlukan hak administrator untuk membuka perangkat USB, tetapi pengguna yang masuk untuk debugging tidak memilikinya.  Anda harus mengkonfigurasi port agar dapat digunakan oleh pengguna normal. </td></tr><tr><td>  Hanya beberapa perangkat terbuka, keduanya FT4222H. </td><td>  Secara default, driver port COM virtual standar diinstal pada pengontrol FT2232H.  Anda harus memberi tahu OS untuk tidak melakukan ini. </td></tr><tr><td>  Tidak ada perpustakaan yang ditemukan. </td><td>  Driver D2XX tidak diinstal pada OS perangkat Redd. </td></tr></tbody></table></div><br>  Bagus  Kami siap untuk pencapaian menggunakan alat Microsoft secara eksklusif.  Secara umum, ini mungkin cukup, tetapi untuk berjaga-jaga, saya akan memberi tahu Anda tentang alternatif yang diajarkan bos saya kepada saya. <br><br><h2>  Bekerja dengan Linux yang berjalan di mesin virtual </h2><br>  Kerugian utama dari metode sebelumnya adalah perakitan jarak jauh.  Anda dapat memikirkan seribu satu alasan mengapa perakitan harus dilakukan secara lokal, dan hanya file biner yang selesai yang akan ditransfer ke mesin jarak jauh.  Ini semua jenis pembatasan paranoid (meskipun file ditransfer menggunakan protokol aman, dan Anda dapat memisahkan penyimpanannya dari pengguna lain dengan kebijakan keamanan), ini hanyalah kepedulian bahwa drive Redd tidak melimpah dari semua jenis perpustakaan, ini juga keengganan untuk mendaftarkan setiap file header, jika ada ribuan dari mereka ... Yah, dan masih banyak lagi.  Secara umum, teknik perakitan lokal mungkin berguna, jadi pertimbangkanlah. <br><br>  Pertama-tama, kami menempatkan program VirtualBox dari Oracle di mesin lokal.  Jika ada masalah lisensi (saya menggunakannya secara gratis, sebagai individu, tetapi saya tidak tahu persis apa yang terjadi dengan badan hukum), pilih mesin fisik yang terpisah dan letakkan Linux di sana.  Yang mana  Lebih mudah bagi saya, saya mengerti semuanya tentang hal yang sama.  Maksudku, aku hampir tidak mengerti satu pun.  Karena itu, bos mengatakan kepada saya bahwa Anda perlu menggunakan Debian, saya menginstal Debian.  Anda dapat pergi dengan cara yang sama (gunakan prinsip "Kenapa tidak?").  Setidaknya di masa depan saya akan mengandalkan bekerja dengannya. <br><br>  Saat bekerja dengan Linux, Anda harus mematuhi dua aturan yang sangat memudahkan kehidupan: <br><br><ol><li>  Jika, sebagai tanggapan terhadap perintah, mereka memberi tahu kami bahwa tidak ada hak yang cukup, perlu mengulanginya, menambahkan mantra sihir <b>sudo</b> ke awal. </li><li>  Jika sebagai tanggapan terhadap perintah kami diberitahu bahwa tidak ada yang seperti itu, ada baiknya mencoba menginstalnya dengan melemparkan mantra sihir <b>apt-get install &lt;missing thing&gt;</b> . </li></ol><br>  Jadi  Kami baru saja menginstal OS.  Segera tambahkan dukungan C ++ di sana dengan menginstal kompilator g ++, serta debugger gdb.  Bagaimana?  Jadi gunakan aturan 2: <br><br>  <b>apt-get install g ++</b> <b><br></b>  <b>apt-get install gdb</b> <br><br>  Tidak memberi?  Hebat!  Ulangi menggunakan aturan 1: <br><br>  <b>sudo apt-get install g ++</b> <b><br></b>  <b>sudo apt-get install gdb</b> <br><br>  Sekarang kita pergi ke Internet, di mesin pencari yang kita ketik: <br><br>  <b>Gerhana IDE</b> <br><br>  Kami menemukan tautan ke eclipse.org, di mana opsi pertama untuk Java, kami menemukan dan mengunduh opsi untuk C / C ++: <br><br><img src="https://habrastorage.org/webt/96/qw/qk/96qwqkb0litad1r1tujou2a9bae.png"><br><br>  Unduh dan buka kemasannya, misalnya, di rumah. <br><br>  Sebenarnya, tidak diperlukan instalasi.  Cukup buka direktori tempat semuanya baru saja dibongkar dan jalankan file gerhana: <br><br><img src="https://habrastorage.org/webt/ir/70/5r/ir705r0y6iwxnnixuxatl8ajg5m.png"><br><br>  Kami berada dalam lingkungan pengembangan.  Nah, jika Anda sudah bekerja dengan mikrokontroler dan bahkan inti prosesor untuk FPGA, maka Anda mungkin sudah tahu apa itu Eclipse.  Jadi hal-hal asing hampir lengkap.  Kita mulai melihat-lihat hal-hal yang kurang lebih akrab.  Kami membuat proyek C ++.  Saya harus mengatakan segera bahwa ada dua cara.  Seseorang akan menuju kesuksesan, yang kedua menuju jalan buntu.  Karena itu, ikuti dengan cermat jalan yang saya lalui: <br><br><img src="https://habrastorage.org/webt/pn/p2/am/pnp2amrhevvek40jz7nqsocol5g.png"><br><br><img src="https://habrastorage.org/webt/a_/ge/sx/a_gesxu9d6u_hhbocj0mqah5xik.png"><br><br><img src="https://habrastorage.org/webt/14/zg/b0/14zgb0day-st8r8cyejyvxahtsk.png"><br><br>  Kami telah membuat proyek yang berjalan dengan baik.  Untuk mengonfigurasi debuggingnya, buka properti GDB: <br><br><img src="https://habrastorage.org/webt/zd/zf/tz/zdzftzvpbfwkbs1mphkqdyrfv1a.png"><br><br>  Buat konfigurasi tipe C / C ++ Aplikasi Jarak Jauh, di grup Koneksi, klik Baru: <br><br><img src="https://habrastorage.org/webt/u1/dy/wb/u1dywbnrislxi82tujf7k3crbks.png"><br><br>  Pilih koneksi seperti SSH: <br><br><img src="https://habrastorage.org/webt/j8/nt/td/j8nttddgczes40njsbis01oamzi.png"><br><br>  Kami mengisi properti koneksi dengan mengganti tombol radio dari jenis otorisasi ke otorisasi kata sandi: <br><br><img src="https://habrastorage.org/webt/i_/we/l1/i_wel1jpfgrjiale5pgsh7un8mg.png"><br><br>  Sebenarnya, sistem siap untuk debugging.  Setelah memastikan bahwa teks sambutan benar-benar ditampilkan, kami mencoba mentransfer kode dari contoh sebelumnya (yang ada di Visual Studio) di sini.  Untuk mendaftarkan pustaka tambahan, pilih properti proyek: <br><br><img src="https://habrastorage.org/webt/9i/b0/7r/9ib07rvhf55tqf7hvkewqsqbqau.png"><br><br>  Selain itu, karena perakitan berlangsung secara lokal, perpustakaan juga harus berada di direktori usr / local / lib lokal.  Saya mengingatkan Anda bahwa perpustakaan diunduh dengan driver, dan cara menginstalnya adalah readme, serta video AN220 dan YouTube, untuk detailnya, lihat bagian pada Visual Studio. <br><br>  Setelah semua persiapan ini, kami mendapat garis akrab.  Artinya, kode yang benar-benar identik dengan yang dipertimbangkan pada bagian sebelumnya dijalankan tidak kurang identik. <br><br>  Itu saja.  Sekarang, tergantung pada situasinya, kita dapat menjalankan kode baik melalui Visual Studio dan melalui mesin virtual.  Seperti yang Anda lihat, murni dalam hal pengaturan, Visual Studio lebih sederhana, oleh karena itu, ceteris paribus, saya akan memilihnya.  Tetapi lebih baik memiliki kedua teknologi, karena bekerja melalui Studio memiliki kelemahan terkait dengan fakta bahwa tidak hanya debugging, tetapi juga perakitan jarak jauh di sana. <br><br><h2>  Pengukuran kecepatan menulis FPGA melalui FT2232H </h2><br>  Baiklah apa.  Mari kita perbaiki keterampilan yang diperoleh pada proyek yang kurang lebih nyata.  Tentu saja, memulai sesuatu yang sangat serius tidak mungkin lagi, semua orang sudah lelah.  Tetapi kami mendapatkan hasil yang lebih atau kurang praktis.  Misalnya, kami mengukur dengan kecepatan maksimum berapa kami dapat mentransfer data ke FPGA melalui chip FT2232H.  Protokol di sana bukan yang termudah, jadi kami tidak akan mentransmisikannya di kedua sisi, tetapi membatasi diri untuk mentransmisi dari kami ke saluran, di ujung lain tempat FPGA dipasang.  Dokumen <b>AN_130 FT2232H Digunakan dalam Mode Sinkronisasi FIFO Gaya FT245</b> akan membantu kami dalam hal ini, karena di kompleks pengontrol dihidupkan secara tepat dalam mode ini (FIFO sinkron).  Dokumen ini juga berisi deskripsi kesimpulan, dalam bentuk di mana mereka digunakan dalam mode ini, dan diagram waktu, dan bahkan contoh kode, dari mana kita akan menarik inspirasi. <br><br>  Jadi  Kami ingin merekam di FIFO menggunakan controller.  Apa yang akan terjadi pada kita?  Saya mencoba, saya tahu.  Dibutuhkan 1 kilobyte data, setelah itu controller akan hang.  Dia akan menolak untuk menerima data tambahan.  Masalahnya adalah bahwa satu kilobyte adalah ukuran buffer internal.  Meskipun dimungkinkan, data akan diambil dari USB dan disimpan di ruang ini.  Tetapi bagi mereka untuk pergi ke saluran sinkron, ia harus menginformasikan tentang kesiapan untuk menerima mereka.  Kami melihat darurat yang sesuai. <br><br><img src="https://habrastorage.org/webt/qq/9x/lj/qq9xljp4ma4jlpcprp5emofdraa.png"><br><br>  Jadi  Ketika pengontrol memiliki data dalam FIFO, ia menjatuhkan sinyal RXF.  Menanggapi hal ini, pertama-tama kita harus menjatuhkan sinyal OE dan menyimpannya pada nol untuk setidaknya satu siklus clock (ini mengikuti lebih banyak dari deskripsi ke diagram daripada dari diagram itu sendiri).  Kami akan diberikan data di bus, kami harus mengkonfirmasi penerimaan mereka dengan level sinyal RD rendah.  Dan - untuk seluruh bingkai.  Ketika pengontrol menaikkan garis RXF, kita harus menghapus OE dan RD.  Kami tidak akan menggunakan data hari ini.  Untuk mengukur kecepatan, simulasikan penerimaan data pada FPGA dari FT2232H.  Baiklah kalau begitu.  Untuk operasi sederhana seperti itu, tidak diperlukan sistem prosesor.  Cukup membuat otomat yang merosot, yang pengembangannya akan memakan waktu jauh lebih sedikit daripada hanya sibuk dengan persiapan prosesor dan program untuk itu.  Oleh karena itu, kami membuat proyek yang hanya berisi satu file SystemVerilog dengan konten berikut: <br><br><pre> <code class="plaintext hljs">module JustRead( input logic clk, input logic rxf_n, output logic oe_n, output logic rd_n ); enum {IDLE,TRANSFER} state = IDLE; always @ (posedge clk) begin oe_n &lt;= 1; rd_n &lt;= 1; case (state) IDLE: begin if (rxf_n == 0) begin oe_n &lt;= 0; state &lt;= TRANSFER; end end TRANSFER: begin if (rxf_n == 0) begin oe_n &lt;= 0; rd_n &lt;= 0; end else begin state &lt;= IDLE; end end endcase end endmodule</code> </pre><br>  Mesin memiliki dua status.  Dalam hal ini, durasi sinyal OE ditentukan oleh fakta bahwa sinyal tersebut dikokang segera setelah pulsa clock dan ditahan hingga berikutnya.  Ini dapat diverifikasi menggunakan model berikut: <br><br><pre> <code class="plaintext hljs">module JustReadTB( output logic clk, output logic rxf_n, input logic oe_n, input logic rd_n ); JustRead dut ( .clk, .rxf_n, .oe_n, .rd_n ); always begin clk = 1; #16; clk = 0; #16; end initial begin rxf_n = 1; #120; rxf_n = 0; #120; rxf_n = 1; end endmodule</code> </pre><br>  Waktu yang saya ambil adalah yang pertama tersedia, itu adalah urutan switching yang melekat pada sinyal clock yang penting.  Kami mendapatkan diagram waktu berikut: <br><br> <a href=""><img src="https://habrastorage.org/webt/ps/kw/jw/pskwjww-komvozbyogvdndsukq8.png"></a> <br><br>  Dalam perkiraan pertama, ini sesuai dengan apa yang dibutuhkan dokumen.  Namun kami tidak akan memproses data aktual. <br><br>  Penugasan kaki FPGA dalam proyek ini juga tidak menyebabkan kesulitan bahkan untuk mengedit melalui tabel (akan butuh waktu lebih lama untuk mentransfer tugas dari file * .QSF, dan saya terus-menerus menekankan bahwa ketika mengembangkan sistem satu hari di bawah Redd, menghemat waktu adalah hal yang diprioritaskan). <br><br><img src="https://habrastorage.org/webt/kp/8s/wq/kp8swq3ni8n0x02znmnexvjpfsk.png"><br><br>  Kami mengumpulkan, mengisinya, sebelum mematikan kekuatan kompleks, Anda dapat bekerja dengan program ini, itu tidak akan lagi hang setelah buffer overflow. <br><br>  Dalam program ini, saya membuat dua fungsi.  Yang pertama mencari dan membuka perangkat.  Saya mengambil sesuatu dari tes terakhir, saya meminjam sesuatu dari <b>AN130</b> : <br><br><pre> <code class="plaintext hljs">FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, maxBlockSize, maxBlockSize); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } }</code> </pre><br>  Sebagai penggemar Windows, saya harus menulis fungsi pengukuran kecepatan, terus-menerus memeriksa Internet, karena saya biasanya menggunakan timer klasik resolusi tinggi dari WIN32 API.  Mungkin Anda dapat menulis lebih efisien, tetapi ini adalah program satu hari. <br><br><pre> <code class="plaintext hljs">const int maxBlockSize = 0x100000; uint8_t buf[maxBlockSize]; … //   BlockSize ,  1 double TestSpeed(FT_HANDLE ftHandle0,int totalSize, int blockSize) { if (blockSize &gt; maxBlockSize) { return -1; } DWORD dwWrittenTotal = 0; timespec before; clock_gettime(CLOCK_REALTIME, &amp;before); for (int i = 0; i &lt; totalSize; i += blockSize) { DWORD dwWritten; FT_Write(ftHandle0, buf, blockSize, &amp;dwWritten); //     dwWrittenTotal += dwWritten; } timespec after; clock_gettime(CLOCK_REALTIME, &amp;after); if (dwWrittenTotal &lt; (DWORD)totalSize) { return -2; } //     uint64_t nsBefore = before.tv_nsec; uint64_t nsAfter = after.tv_nsec; //      nsAfter += (after.tv_sec - before.tv_sec) * 1000000000; //   nsAfter -= nsBefore; //      double res = ((double)nsAfter)/((double)1000000000); //   -    return ((double)dwWrittenTotal) / res; }</code> </pre><br>  Nah, kode yang melakukan fungsi dasar ternyata seperti ini: <br><br><pre> <code class="plaintext hljs">int main(int argc, char* argv[]) { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } const int totalSize = 0x100000; static const int blockSizes[] = { 0x10,0x20,0x40,0x80,0x100,0x200,0x400,0x800,0x1000,0x2000, 0x4000,0x8000,0x10000,0x20000,0x40000,0x80000,0 }; for (int i = 0; blockSizes[i] != 0; i++) { double speed = TestSpeed(ftHandle0, totalSize, blockSizes[i]); printf("%d,%d\n", blockSizes[i], (int)(speed/1000.)); int stop = 0; } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br>  Saya tahu bahwa di USB, kecepatannya sangat tergantung pada ukuran blok yang dikirim, jadi saya memeriksa kecepatan untuk berbagai opsi.  Pencacahan linear sangat dibutuhkan.  Saya hanya meletakkan daftar ukuran khas.  Saya output data dalam kilobyte per detik.  Bytes tidak nyaman untuk mata, megabyte memiliki resolusi rendah dengan ukuran blok kecil.  Kilobyte per detik adalah kompromi yang masuk akal.  Kami mendapatkan hasil sebagai berikut: <br><pre> <code class="plaintext hljs">16,59 32,110 64,237 128,490 256,932 512,1974 1024,3760 2048,5594 4096,10729 8192,16109 16384,20170 32768,24248 65536,26664 131072,28583 262144,29370 524288,29832</code> </pre><br>  Kami menyimpannya dalam file * .csv, memuatnya ke Excel, membuat grafik kecepatan versus ukuran blok. <br><br><img src="https://habrastorage.org/webt/_o/ep/xe/_oepxe_wz65g7otcfeo3qete8xa.png"><br><br>  Batasnya adalah 30 megabyte per detik.  Untuk maksimum teoritis 52 MB / s jauh.  Mungkin Anda bisa mempercepat, tetapi menyerahkannya kepada pembaca dalam bentuk kerja praktis.  Hal utama adalah bahwa kami telah menguasai semua langkah bekerja dengan saluran dan siap untuk menghubungkan FPGA dengan prosesor pusat ke dalam satu sistem. <br><br>  Sementara artikel sedang <b>dikompilasi</b> , dokumen <b>AN_165</b> ditemukan, yang mengatakan bahwa kecepatan maksimum dalam mode FIFO sinkron adalah 35 MB / s.  Artinya, ruang untuk pertumbuhan - hingga ukuran tertentu.  Tetapi masih ada di sana. <br><br><h2>  Kesimpulan </h2><br>  Kami berkenalan dengan dua strategi untuk mengembangkan dan men-debug kode program yang dieksekusi pada prosesor sentral kompleks Redd (menggunakan alat Microsoft Visual Studio dan pada mesin virtual dengan OS Linux).  Kami juga memperoleh keterampilan praktis dalam bekerja dengan saluran melalui mana prosesor pusat kompleks berkomunikasi dengan FPGA. <br><br>  Rupanya, sekarang tidak ada yang mencegah kita dari mentransmisikan data yang bermakna dari CPU ke FPGA dan sebaliknya (walaupun dalam artikel terakhir saya menulis kata-kata ini). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang berisi "firmware" paling sederhana untuk FPGA dan program yang mengukur kecepatan penulisan ke USB dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diunduh di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456008/">https://habr.com/ru/post/id456008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455994/index.html">Evolusi alat paling populer dari pengembang mana pun (di Visual Studio)</a></li>
<li><a href="../id455996/index.html">Transformasi digital periklanan di jaringan ritel. Mengikuti jejak Video Analytics di Retail</a></li>
<li><a href="../id456000/index.html">Membuat game Tic-Tac-Toe dengan TypeScript, React, dan Mocha</a></li>
<li><a href="../id456004/index.html">Kami mengundang Anda ke pertemuan pengembangan front-end di layanan yang sarat muatan</a></li>
<li><a href="../id456006/index.html">Kembangkan Penghasilan Anda Menggunakan Pembelian Dalam Aplikasi</a></li>
<li><a href="../id456010/index.html">Bagaimana Java 10 mengubah cara Anda menggunakan kelas dalam anonim</a></li>
<li><a href="../id456014/index.html">Tentang pelokalan produk. Bagian 2: bagaimana harga terbentuk?</a></li>
<li><a href="../id456016/index.html">Protokol untuk komunikasi antara iframe dan jendela utama</a></li>
<li><a href="../id456018/index.html">Cara mengimplementasikan penyebaran dari GitHub ke server produksi menggunakan Webhook</a></li>
<li><a href="../id456020/index.html">Bersiap untuk mengambil alih dunia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>