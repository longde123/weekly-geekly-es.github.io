<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüè≠ üëèüèæ üë©üèº‚Äçüîß Pensamiento funcional Parte 11: Final üö¥üèø üë™ üò∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy estamos terminando nuestra serie de art√≠culos sobre programaci√≥n funcional. Result√≥ 11 partes. Creo que esto es un logro. En este art√≠culo, implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento funcional Parte 11: Final</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433412/"><p>  Hoy estamos terminando nuestra serie de art√≠culos sobre programaci√≥n funcional.  Result√≥ 11 partes.  Creo que esto es un logro.  En este art√≠culo, implementamos una calculadora de pila simple (tambi√©n conocida como "notaci√≥n polaca inversa").  La implementaci√≥n se basa casi por completo en funciones, con un solo tipo especial y, en general, sin comparaci√≥n con la muestra, por lo que este es un excelente campo de pruebas para los conceptos cubiertos en nuestra serie. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><p>  Quiero agradecer a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos por</em></a> separado.  Fue √©l quien actu√≥ como el principal traductor y gerente de toda la serie de art√≠culos.  Gracias </p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sexta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">S√©ptima parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Octava parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Novena parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">D√©cimo</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Si no est√° familiarizado con dicha calculadora, funciona de la siguiente manera: los n√∫meros se insertan en la pila y las operaciones, como la suma y la multiplicaci√≥n, seleccionan los n√∫meros desde la parte superior de la pila y luego vuelven a colocar el resultado de la operaci√≥n. </p><br><p>  Esquema de c√°lculo simple en la pila: </p><br><br><p>  Antes de dise√±ar dicho sistema, debe considerar c√≥mo se usar√°.  Siguiendo una sintaxis similar a Forth, le daremos a cada acci√≥n una etiqueta apropiada para que en el ejemplo anterior pueda escribir algo como: </p><br><pre><code class="plaintext hljs">EMPTY ONE THREE ADD TWO MUL SHOW</code> </pre> <br><p>  Quiz√°s sea imposible obtener exactamente esta sintaxis, pero tratemos de acercarnos lo m√°s posible. </p><br><h2>  Tipo de datos de pila </h2><br><p>  Primero, debe definir la estructura de datos para la pila.  Para simplificar, puede usar una lista de n√∫meros de coma flotante. </p><br><pre> <code class="plaintext hljs">type Stack = float list</code> </pre> <br><p>  Pero es mejor envolverlo en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo de uni√≥n de may√∫sculas y min√∫sculas</a> para que el tipo sea m√°s visual, as√≠: </p><br><pre> <code class="plaintext hljs">type Stack = StackContents of float list</code> </pre> <br><p>  Por qu√© es mejor hacer eso, puedes leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Ahora cree una nueva pila usando <code>StackContents</code> como constructor: </p><br><pre> <code class="plaintext hljs">let newStack = StackContents [1.0;2.0;3.0]</code> </pre> <br><p>  Para extraer contenido de una pila existente, use el patr√≥n que coincide con los contenidos de <code>StackContents</code> : </p><br><pre> <code class="plaintext hljs">let (StackContents contents) = newStack //  "contents"   // float list = [1.0; 2.0; 3.0]</code> </pre> <br><h2>  Funci√≥n de empuje </h2><br><p>  A continuaci√≥n, necesitamos una forma de poner n√∫meros en esta pila.  Para hacer esto, simplemente agregue un nuevo valor a la parte superior de la lista usando " <code>::</code> ". </p><br><p>  Ejemplo de funcion: </p><br><pre> <code class="plaintext hljs">let push x aStack = let (StackContents contents) = aStack let newContents = x::contents StackContents newContents</code> </pre> <br><p>  Esta caracter√≠stica tiene una serie de caracter√≠sticas que vale la pena discutir. </p><br><p>  Primero, debe prestar atenci√≥n al hecho de que la estructura de la <code>list</code> es inmutable, lo que significa que la funci√≥n debe tomar una pila existente y devolver una nueva.  Esto no es solo un cambio en una pila existente.  De hecho, todas las funciones en este ejemplo tendr√°n un formato similar: </p><br><pre> <code class="plaintext hljs">Input: Stack   -  Output:  Stack</code> </pre> <br><p>  En segundo lugar, ¬øpor qu√© los par√°metros van en ese orden?  ¬øPor qu√© la pila debe ir primero o √∫ltimo?  En la secci√≥n sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dise√±o de funciones con aplicaci√≥n parcial,</a> se dijo que el par√°metro que cambia con m√°s frecuencia deber√≠a ser el √∫ltimo.  Pronto ser√° posible verificar que se sigan estas recomendaciones. </p><br><p>  Finalmente, la funci√≥n se puede hacer m√°s concisa haciendo coincidir con el patr√≥n en el par√°metro de la funci√≥n en s√≠, en lugar de <code>let</code> el cuerpo de la funci√≥n. </p><br><p>  La versi√≥n reescrita: </p><br><pre> <code class="plaintext hljs">let push x (StackContents contents) = StackContents (x::contents)</code> </pre> <br><p>  Mucho mejor! </p><br><p>  Por cierto, mira su elegante firma: </p><br><pre> <code class="plaintext hljs">val push : float -&gt; Stack -&gt; Stack</code> </pre> <br><p>  Como se mencion√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> , la firma nos dice mucho. <br>  En este caso, podr√≠a adivinar qu√© hace esta funci√≥n, solo por su firma, sin siquiera saber que se llama "push". <br>  Esta es otra raz√≥n por la que fue una buena idea tener nombres de tipo expl√≠citos.  Si la pila fuera solo una lista de n√∫meros de coma flotante, entonces la funci√≥n no ser√≠a tan autodocumentada. </p><br><p>  De una forma u otra, verifique: </p><br><pre> <code class="plaintext hljs">let emptyStack = StackContents [] let stackWith1 = push 1.0 emptyStack let stackWith2 = push 2.0 stackWith1</code> </pre> <br><p>  Funciona muy bien! </p><br><h2>  Apila el super√≠ndice superior usando push </h2><br><p>  Con esta funci√≥n simple, puede definir f√°cilmente una operaci√≥n que empuja un n√∫mero espec√≠fico en la pila. </p><br><pre> <code class="plaintext hljs">let ONE stack = push 1.0 stack let TWO stack = push 2.0 stack</code> </pre> <br><p>  ¬°Pero espera un minuto!  ¬øVes que el par√°metro de <code>stack</code> se menciona en ambos lados de la expresi√≥n?  De hecho, no es necesario mencionarlo dos veces.  En cambio, puede omitir el par√°metro y escribir una funci√≥n con aplicaci√≥n parcial: </p><br><pre> <code class="plaintext hljs">let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0</code> </pre> <br><p>  Ahora es obvio que si la funci√≥n <code>push</code> tuviera un orden diferente de par√°metros, la <code>stack</code> tendr√≠a que mencionarse dos veces. </p><br><p>  Tambi√©n vale la pena definir una funci√≥n que cree una pila vac√≠a: </p><br><pre> <code class="plaintext hljs">let EMPTY = StackContents []</code> </pre> <br><p>  Verifique las funciones recibidas: </p><br><pre> <code class="plaintext hljs">let stackWith1 = ONE EMPTY let stackWith2 = TWO stackWith1 let stackWith3 = THREE stackWith2</code> </pre> <br><p>  ¬øSon molestas estas pilas intermedias?  ¬øEs posible deshacerse de ellos?  Por supuesto!  Tenga en cuenta que las funciones ONE, TWO y THREE tienen la misma firma: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Entonces, ¬°est√°n perfectamente conectados entre s√≠!  La salida de una funci√≥n se puede ingresar a lo siguiente: </p><br><pre> <code class="plaintext hljs">let result123 = EMPTY |&gt; ONE |&gt; TWO |&gt; THREE let result312 = EMPTY |&gt; THREE |&gt; ONE |&gt; TWO</code> </pre> <br><h2>  Saliendo de la pila </h2><br><p>  Con la adici√≥n a la pila descubierta, pero ¬øqu√© pasa con la funci√≥n <code>pop</code> ? </p><br><p>  Cuando se recupera de la pila, obviamente es necesario devolver la parte superior de la pila, pero ¬øes solo eso? </p><br><p>  En un estilo orientado a objetos, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respuesta es s√≠</a> .  Pero en el caso de OOP, la pila se cambiar√≠a detr√°s de escena, de modo que se eliminar√≠a el elemento superior. </p><br><p>  Sin embargo, en un estilo funcional, la pila es inmutable.  Solo hay una forma de eliminar el elemento superior: crear una <em>nueva pila</em> sin este elemento.  Para que la persona que llama tenga acceso a la nueva pila reducida, debe devolverse junto con el elemento superior. </p><br><p>  En otras palabras, la funci√≥n <code>pop</code> deber√≠a devolver <em>dos</em> valores, el elemento superior y la nueva pila.  La forma m√°s sencilla de hacer esto en F # es simplemente usar una tupla. </p><br><p>  Implementaci√≥n </p><br><pre> <code class="plaintext hljs">///     ///          let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack)</code> </pre> <br><p>  La funci√≥n resultante tambi√©n es muy simple. </p><br><p>  Como antes, los <code>contents</code> extraen directamente del par√°metro. </p><br><p>  Luego, el contenido de los <code>contents</code> verifica usando la expresi√≥n <code>match..with</code> . </p><br><p>  Luego, el elemento superior se separa del resto de la lista, se crea una nueva pila basada en los elementos restantes, y finalmente todo esto se devuelve como un par de tuplas. </p><br><p>  Intente ejecutar este c√≥digo y vea qu√© sucede.  Obtendr√° un error de compilaci√≥n! <br>  El compilador ha detectado un caso que no se ha resuelto: ¬øqu√© sucede si la pila est√° vac√≠a? </p><br><p>  Tienes que decidir c√≥mo manejarlo. </p><br><ul><li>  Opci√≥n 1: Devuelva el estado especial "√âxito" o "Error", como se hizo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n de la serie "¬øpor qu√© usar F #?"</a>  . </li><li>  Opci√≥n 2: lanzar una excepci√≥n. </li></ul><br><p>  Por lo general, prefiero usar un estado especial para el error, pero en este caso particular, prefer√≠ lanzar una excepci√≥n.  Versi√≥n fija de <code>pop</code> con manejo de may√∫sculas y min√∫sculas vac√≠o: </p><br><pre> <code class="plaintext hljs">let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow"</code> </pre> <br><p>  Comprobar: </p><br><pre> <code class="plaintext hljs">let initialStack = EMPTY |&gt; ONE |&gt; TWO let popped1, poppedStack = pop initialStack let popped2, poppedStack2 = pop poppedStack</code> </pre> <br><p>  y prueba de excepci√≥n: </p><br><pre> <code class="plaintext hljs">let _ = pop EMPTY</code> </pre> <br><h2>  Funciones aritm√©ticas </h2><br><p>  Ahora que la adici√≥n y eliminaci√≥n est√°n en su lugar, puede comenzar a trabajar con las funciones "agregar" y "multiplicar": </p><br><pre> <code class="plaintext hljs">let ADD stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x + y //   push result s2 //     let MUL stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x * y //   push result s2 //    </code> </pre> <br><p>  Pruebas en l√≠nea: </p><br><pre> <code class="plaintext hljs">let add1and2 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD let add2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; ADD let mult2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; MUL</code> </pre> <br><p>  Funciona! </p><br><h3>  Tiempo de refactorizaci√≥n ... </h3><br><p>  Obviamente, una cantidad significativa de c√≥digo se duplica en estas dos funciones.  ¬øC√≥mo podemos arreglar esto? </p><br><p>  Ambas funciones extraen dos valores de la pila, les aplican una determinada funci√≥n binaria y luego vuelven a colocar el resultado en la pila.  Puede enviar el c√≥digo general a la funci√≥n binaria, que toma una funci√≥n matem√°tica con dos par√°metros: </p><br><pre> <code class="plaintext hljs">let binary mathFn stack = //    let y,stack' = pop stack //     let x,stack'' = pop stack' //  let z = mathFn xy //      push z stack''</code> </pre> <br><p>  <em>Tenga en cuenta que en esta implementaci√≥n, las diferentes versiones del "mismo" objeto se marcan con un n√∫mero diferente de comillas.</em>  <em>Esto se debe a que los sufijos num√©ricos pueden conducir f√°cilmente a la confusi√≥n.</em> </p><br><p>  Pregunta: ¬øpor qu√© los par√°metros tienen exactamente este orden, en lugar de que <code>mathFn</code> venga despu√©s de la <code>stack</code> ? </p><br><p>  Ahora que tiene una funci√≥n <code>binary</code> , es mucho m√°s f√°cil definir ADD y otras funciones: </p><br><p>  Primer intento de implementar ADD usando <code>binary</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (fun xy -&gt; x + y) aStack</code> </pre> <br><p>  Pero puedes deshacerte de lambda, porque  representa la definici√≥n <em>exacta</em> de la funci√≥n incorporada <code>+</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (+) aStack</code> </pre> <br><p>  Una vez m√°s, se puede usar una aplicaci√≥n parcial para ocultar el par√°metro de pila.  Definici√≥n final: </p><br><pre> <code class="plaintext hljs">let ADD = binary (+)</code> </pre> <br><p>  Definici√≥n de otras funciones matem√°ticas: </p><br><pre> <code class="plaintext hljs">let SUB = binary (-) let MUL = binary (*) let DIV = binary (../)</code> </pre> <br><p>  Pru√©balo en l√≠nea: </p><br><pre> <code class="plaintext hljs">let div2by3 = EMPTY |&gt; THREE|&gt; TWO |&gt; DIV let sub2from5 = EMPTY |&gt; TWO |&gt; FIVE |&gt; SUB let add1and2thenSub3 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD |&gt; THREE |&gt; SUB</code> </pre> <br><p>  Del mismo modo, puede crear una funci√≥n auxiliar para operaciones unarias </p><br><pre> <code class="plaintext hljs">let unary f stack = let x,stack' = pop stack push (fx) stack'</code> </pre> <br><p>  Y defina algunas funciones unarias: </p><br><pre> <code class="plaintext hljs">let NEG = unary (fun x -&gt; -x) let SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Modo interactivo: </p><br><pre> <code class="plaintext hljs">let neg3 = EMPTY |&gt; THREE|&gt; NEG let square2 = EMPTY |&gt; TWO |&gt; SQUARE</code> </pre> <br><h2>  Poniendo todo junto |  Poniendo todo junto </h2><br><p>  En los requisitos iniciales se mencion√≥ que nos gustar√≠a poder mostrar los resultados, por lo que vale la pena definir la funci√≥n SHOW. </p><br><pre> <code class="plaintext hljs">let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      </code> </pre> <br><p>  Tenga en cuenta que en este caso, se ignora la nueva versi√≥n de la pila recibida a trav√©s de <code>pop</code> .  El resultado final es la pila original, como si nunca hubiera cambiado. </p><br><p>  Finalmente, puede escribir el siguiente ejemplo de los requisitos originales </p><br><pre> <code class="plaintext hljs">EMPTY |&gt; ONE |&gt; THREE |&gt; ADD |&gt; TWO |&gt; MUL |&gt; SHOW</code> </pre> <br><h3>  Seguir adelante </h3><br><p>  Es divertido, pero ¬øqu√© m√°s puedes hacer? </p><br><p>  Puede definir varias funciones adicionales: </p><br><pre> <code class="plaintext hljs">///      let DUP stack = //    let x,_ = pop stack //      push x stack ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let START = EMPTY</code> </pre> <br><p>  Con estas funciones adicionales, puede escribir algunos ejemplos elegantes: </p><br><pre> <code class="plaintext hljs">START |&gt; ONE |&gt; TWO |&gt; SHOW START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW |&gt; THREE |&gt; ADD |&gt; SHOW START |&gt; THREE |&gt; DUP |&gt; DUP |&gt; MUL |&gt; MUL // 27 START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW // 3 |&gt; THREE |&gt; MUL |&gt; SHOW // 9 |&gt; TWO |&gt; SWAP |&gt; DIV |&gt; SHOW // 9 div 2 = 4.5</code> </pre> <br><h2>  Usar composici√≥n en lugar de canalizar </h2><br><p>  Pero eso no es todo.  De hecho, hay otra forma interesante de representar estas funciones. </p><br><p>  Como se se√±al√≥ anteriormente, todos tienen la misma firma: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Dado que la entrada y la salida son del mismo tipo, estas funciones tambi√©n se pueden combinar usando el operador de composici√≥n <code>&gt;&gt;</code> , y no solo a trav√©s de operadores canalizados. </p><br><p>  Algunos ejemplos </p><br><pre> <code class="plaintext hljs">//    let ONE_TWO_ADD = ONE &gt;&gt; TWO &gt;&gt; ADD START |&gt; ONE_TWO_ADD |&gt; SHOW //    let SQUARE = DUP &gt;&gt; MUL START |&gt; TWO |&gt; SQUARE |&gt; SHOW //     let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL START |&gt; THREE |&gt; CUBE |&gt; SHOW //   let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2 START |&gt; THREE |&gt; SQUARE |&gt; SUM_NUMBERS_UPTO |&gt; SHOW</code> </pre> <br><p>  En cada uno de estos ejemplos, se define una nueva funci√≥n utilizando una composici√≥n de otras funciones.  Este es un buen ejemplo de un enfoque "combinatorio" para la funcionalidad del edificio. </p><br><h2>  Transportadores vs. Composici√≥n </h2><br><p>  Vimos dos formas diferentes de usar nuestro modelo;  utilizando transportadores y composici√≥n.  Pero cual es la diferencia?  ¬øY por qu√© deber√≠a preferirse uno sobre otro? </p><br><p>  La diferencia es que las tuber√≠as son, en cierto sentido, una operaci√≥n de "transformaci√≥n en tiempo real".  Al momento de usar la tuber√≠a, las operaciones se realizan de inmediato, a trav√©s de la transferencia de una pila espec√≠fica. </p><br><p>  Por otro lado, la composici√≥n es algo as√≠ como un "plan" que queremos implementar, construyendo funciones a partir de un conjunto de componentes sin aplicaci√≥n directa. </p><br><p>  Por ejemplo, puede crear un "plan" para calcular el cuadrado de un n√∫mero mediante una combinaci√≥n de peque√±as operaciones: </p><br><pre> <code class="plaintext hljs">let COMPOSED_SQUARE = DUP &gt;&gt; MUL</code> </pre> <br><p>  No puedo dar el equivalente basado en tuber√≠as. </p><br><pre> <code class="plaintext hljs">let PIPED_SQUARE = DUP |&gt; MUL</code> </pre> <br><p>  Esto dar√° como resultado un error de compilaci√≥n.  Necesito alguna instancia de pila espec√≠fica para que la expresi√≥n funcione: </p><br><pre> <code class="plaintext hljs">let stackWith2 = EMPTY |&gt; TWO let twoSquared = stackWith2 |&gt; DUP |&gt; MUL</code> </pre> <br><p>  E incluso en este caso, puedo obtener una respuesta solo para esta entrada en particular, y no un plan de c√°lculo generalizado basado en ninguna entrada, como en el ejemplo con <code>COMPOSED_SQUARE</code> . </p><br><p>  Otra forma de crear un "plan" es pasar expl√≠citamente el lambda a funciones m√°s primitivas: </p><br><pre> <code class="plaintext hljs">let LAMBDA_SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Esta es una forma m√°s expl√≠cita (y muy probablemente m√°s r√°pida), pero se pierden todas las ventajas y la claridad del enfoque compositivo. </p><br><p>  En general, si es posible, ¬°debe luchar por un enfoque compositivo! </p><br><h2>  C√≥digo completo </h2><br><p>  C√≥digo completo para todos los ejemplos anteriores: </p><br><pre> <code class="plaintext hljs">// ============================================== //  // ============================================== type Stack = StackContents of float list // ============================================== //   // ============================================== ///     let push x (StackContents contents) = StackContents (x::contents) ///        ///       let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow" // ============================================== //  () // ============================================== //     //      //     let binary mathFn stack = let y,stack' = pop stack let x,stack'' = pop stack' let z = mathFn xy push z stack'' //    //      //     let unary f stack = let x,stack' = pop stack push (fx) stack' // ============================================== //  () // ============================================== ///      let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      ///    let DUP stack = let x,s = pop stack push x (push xs) ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let DROP stack = let _,s = pop stack //   s //   // ============================================== // ,    // ============================================== //  // ------------------------------- let EMPTY = StackContents [] let START = EMPTY //  // ------------------------------- let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0 //   // ------------------------------- let ADD = binary (+) let SUB = binary (-) let MUL = binary (*) let DIV = binary (../) let NEG = unary (fun x -&gt; -x) // ============================================== // ,     // ============================================== let SQUARE = DUP &gt;&gt; MUL let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2</code> </pre> <br><h2>  Conclusi√≥n </h2><br><p>  Tenemos una calculadora simple basada en pila.  Vimos c√≥mo, comenzando con algunas operaciones primitivas ( <code>push</code> , <code>pop</code> , <code>binary</code> , <code>unary</code> ) y otras, puede construir un DSL completo, f√°cil de implementar y usar. </p><br><p>  Como puede suponer, este ejemplo se bas√≥ en gran medida en el lenguaje Forth.  Recomiendo el libro gratuito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Thinking Forth"</a> , que habla no solo del lenguaje Forth, sino tambi√©n de otros m√©todos (¬° <em>no</em> orientados a objetos!) Para descomponer tareas que son igualmente aplicables a la programaci√≥n funcional en general. </p><br><p>  Se me ocurri√≥ la idea de este art√≠culo del hermoso blog de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ashley Feniello</a> .  Si desea profundizar en la emulaci√≥n de un lenguaje basado en pila basado en F #, comience con √©l.  <em>Divi√©rtete!</em> </p><br><h1>  Recursos Adicionales </h1><br><p>  Hay muchos tutoriales para F #, incluidos los materiales para aquellos que vienen con experiencia en C # o Java.  Los siguientes enlaces pueden ser √∫tiles a medida que profundiza en F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # por diversi√≥n y ganancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda X en minutos Y: F #</a> </li></ul><br><p>  Tambi√©n se describen varias otras formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de comenzar a aprender F #</a> . </p><br><p>  Finalmente, la comunidad F # es muy amigable para principiantes.  Hay un chat muy activo en Slack, respaldado por la F # Software Foundation, con salas para principiantes a las que puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unirte libremente</a> .  ¬°Recomendamos encarecidamente que haga esto! </p><br><p>  ¬°No te olvides de visitar el sitio de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de habla rusa F #</a> !  Si tiene alguna pregunta sobre el aprendizaje de un idioma, estaremos encantados de discutirlo en las salas de chat: </p><br><ul><li>  room <code>#ru_general</code> en el <code>#ru_general</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en gitter</a> </li><li>  room #en_general en el chat flojo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Sobre autores de traducci√≥n </h2><br><p>  Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traducci√≥n y los cambios editoriales fueron realizados por los esfuerzos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores de F # de habla rusa</a> .  Tambi√©n agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@schvepsss</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@shwars</em></a> por preparar este art√≠culo para su publicaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433412/">https://habr.com/ru/post/es433412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433402/index.html">Pensamiento funcional Parte 8</a></li>
<li><a href="../es433404/index.html">Tutorial React Parte 3: Archivos de componentes, estructura del proyecto</a></li>
<li><a href="../es433406/index.html">Pensamiento funcional Parte 9</a></li>
<li><a href="../es433408/index.html">Manejo eficiente de la memoria en Node.js</a></li>
<li><a href="../es433410/index.html">Pensamiento funcional Parte 10</a></li>
<li><a href="../es433414/index.html">Prueba de PRTG Network Monitor y comparaci√≥n con Zabbix</a></li>
<li><a href="../es433420/index.html">Resultados de ZeroNights 2018</a></li>
<li><a href="../es433424/index.html">¬øEs posible cargar un nivel intransitable en Super Mario Maker?</a></li>
<li><a href="../es433428/index.html">De d√≥nde viene la creatividad: an√°lisis de la actividad de las ondas alfa del cerebro durante las pruebas RAT</a></li>
<li><a href="../es433430/index.html">Mecool KM9 Android box en el nuevo SoC Amlogic S905X2 con 4 GB de RAM y Android TV 8.1: comprenda y perdone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>