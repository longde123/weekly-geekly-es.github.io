<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ñ üè¥ üë®üèæ‚Äçüîß "Wow, aku tidak tahu itu!" saat-saat dengan bercanda üéûÔ∏è üèáüèΩ üë©üèø‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Kursus Pengembang JavaScript dimulai Kamis ini. Dalam hal ini, kami memutuskan untuk membagikan terjemahan materi menarik lainnya. Sela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Wow, aku tidak tahu itu!" saat-saat dengan bercanda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457616/">  Halo semuanya!  Kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembang JavaScript</a> dimulai Kamis ini.  Dalam hal ini, kami memutuskan untuk membagikan terjemahan materi menarik lainnya.  Selamat membaca. <br><br><img src="https://habrastorage.org/webt/nj/it/db/njitdbm66p75yhokzwoeudcnti8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jest</a> selalu menjadi alat pengujian unit saya yang sangat diperlukan.  Sangat dapat diandalkan sehingga saya mulai berpikir bahwa saya selalu kurang menggunakannya.  Meskipun tes berhasil, lama-kelamaan saya refactored mereka di sana-sini, karena saya tidak tahu bahwa Jest bisa melakukan itu.  Setiap kali ini adalah kode baru ketika saya memeriksa dokumentasi Jest. <a name="habracut"></a><br><br>  Jadi, saya akan membagikan beberapa trik Jest favorit saya yang mungkin sudah diketahui oleh beberapa dari Anda karena Anda membaca dokumentasi dan tidak menyukai saya (malu), tetapi saya harap ini membantu mereka yang baru saja menjalankannya dengan cepat ! <br><br>  Omong-omong, saya menggunakan Jest v24.8.0 sebagai bahan referensi, jadi berhati-hatilah, beberapa hal mungkin tidak berfungsi pada versi Jest yang sedang Anda gunakan.  Selain itu, contoh-contoh tidak mewakili kode tes yang sebenarnya, ini hanya sebuah demonstrasi. <br><br><h2>  # 1  .toBe vs .toEqual </h2><br>  Pada awalnya, semua pernyataan ini tampak normal bagi saya: <br><br><pre><code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toEqual(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Berdasarkan penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chai</a> untuk pernyataan kesetaraan (to.equal), ini wajar saja.  Bahkan, Jest tidak akan mengeluh, dan pernyataan ini berlalu seperti biasa. <br><br>  Namun, Jest memiliki .toBe dan .toEqual.  Yang pertama digunakan untuk <a href="">menyatakan</a> kesetaraan menggunakan <a href="">Object.is</a> , dan yang kedua adalah untuk memberikan perbandingan objek dan array yang mendalam.  .toEqual memiliki fallback untuk menggunakan <a href="">Object.is</a> jika ternyata Anda tidak memerlukan perbandingan yang mendalam, seperti menyatakan persamaan untuk nilai primitif, yang menjelaskan mengapa contoh sebelumnya berjalan sangat baik. <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toBe(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toBe(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Dengan begitu, Anda bisa melewati semua <code>if-else</code> di <code>.toEqual</code> menggunakan <code>.toBe</code> jika Anda sudah tahu nilai apa yang Anda uji. <br>  Kesalahan umum adalah bahwa Anda akan menggunakan <code>.toBe</code> untuk menegaskan kesetaraan nilai-nilai primitif. <br><br><pre> <code class="javascript hljs">expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toBe([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Jika Anda melihat <a href="">kode sumber</a> saat .toBe lumpuh, ia akan mencoba menentukan apakah Anda benar-benar membuat kesalahan ini dengan <a href="">memanggil fungsi</a> yang .toEqual gunakan.  Ini bisa menjadi hambatan ketika mengoptimalkan tes Anda. <br><br>  Jika Anda yakin menggunakan nilai primitif, kode Anda dapat ditata ulang untuk tujuan pengoptimalan: <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.is(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Lebih detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br><h2>  # 2  Perbandingan yang lebih cocok </h2><br>  Secara teknis, Anda dapat menggunakan <code>.toBe</code> untuk memvalidasi nilai apa pun.  Dengan Jest, Anda dapat secara khusus menggunakan alat perbandingan tertentu untuk membuat tes Anda lebih mudah dibaca (dan dalam beberapa kasus lebih pendek). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// expect([1,2,3].length).toBe(3) // expect([1,2,3]).toHaveLength(3) const canBeUndefined = foo() // expect(typeof canBeUndefined !== 'undefined').toBe(true) // expect(typeof canBeUndefined).not.toBe('undefined') // expect(canBeUndefined).not.toBe(undefined) // expect(canBeUndefined).toBeDefined() class Foo { constructor(param) { this.param = param } // expect(new Foo('bar') instanceof Foo).toBe(true) // expect(new Foo('bar')).toBeInstanceOf(Foo)</span></span></code> </pre> <br>  Ini hanya beberapa yang saya pilih dari daftar panjang kompiler Jest dalam dokumentasi, Anda dapat melihat sisanya sendiri. <br><br><h2>  # 3  Pengujian snapshot pada elemen tanpa antarmuka pengguna </h2><br>  Anda mungkin pernah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian snapshot di Jest</a> , yang membantu melacak perubahan pada elemen antarmuka pengguna Anda.  Tetapi pengujian dengan snapshot tidak terbatas pada hal ini. <br><br>  Pertimbangkan contoh ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">0</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">1000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">1</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">5000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">2</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ...etc</span></span></code> </pre> <br>  Akan melelahkan jika Anda mengklaim semakin banyak karyawan.  Selain itu, jika ternyata lebih banyak klaim diperlukan untuk setiap karyawan, kalikan jumlah klaim baru dengan jumlah karyawan dan Anda mendapatkan ide. <br>  Dengan pengujian snapshot, semua ini bisa dilakukan hanya seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees).toMatchSnapshot()</code> </pre> <br>  Setiap kali regresi terjadi, Anda akan tahu persis pohon mana di simpul yang tidak cocok dengan gambar. <br><br>  Tetapi kenyamanan ada harganya: metode ini lebih rentan kesalahan.  Ada kemungkinan Anda tidak akan tahu bahwa gambar itu sebenarnya salah, dan pada akhirnya Anda akan memotretnya.  Jadi periksa ulang snapshot Anda seolah-olah itu adalah kode persetujuan Anda sendiri (karena memang begitu). <br><br>  Tentu saja, pengujian tidak terbatas pada snapshot.  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> lengkap. <br><br><h2>  # 4  deskripsikan. masing-masing dan uji </h2><br>  Pernahkah Anda menulis tes yang agak mirip dengan ini? <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'When I am a supervisor'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-supervisor'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>) }) }) describe(<span class="hljs-string"><span class="hljs-string">'When I am a manager'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a manager badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-manager'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a manager level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'manager'</span></span>) }) })</code> </pre> <br>  Ini monoton dan rutin, bukan?  Bayangkan melakukan ini dengan banyak kasus. <br>  Dengan <code>description.each</code> dan <code>test.each</code> Anda dapat memampatkan kode sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> levels = [[<span class="hljs-string"><span class="hljs-string">'manager'</span></span>], [<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privileges = [[<span class="hljs-string"><span class="hljs-string">'badges'</span></span>, <span class="hljs-string"><span class="hljs-string">'toContain'</span></span>, <span class="hljs-string"><span class="hljs-string">'badge-'</span></span>], [<span class="hljs-string"><span class="hljs-string">'level'</span></span>, <span class="hljs-string"><span class="hljs-string">'toBe'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]] describe.each(levels)(<span class="hljs-string"><span class="hljs-string">'When I am a %s'</span></span>, (level) =&gt; { test.each(privileges)(<span class="hljs-string"><span class="hljs-string">`I should have a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string"> %s`</span></span>, (kind, assert, prefix) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ level }) expect(employee[kind])[assert](<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre> <br>  Namun, saya belum menggunakan ini dalam tes saya sendiri, karena saya lebih suka tes saya lebih rinci, tetapi saya hanya berpikir itu akan menjadi trik yang menarik. <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk detail lebih lanjut tentang argumen (spoiler: sintaks tabel benar-benar keren). <br><br><h2>  # 5  Imitasi tunggal dari fungsi global </h2><br>  Pada titik tertentu, Anda harus menguji sesuatu yang tergantung pada fungsi global dalam kasus uji tertentu.  Misalnya, fungsi yang menerima informasi tentang tanggal saat ini menggunakan objek javascript Date, atau perpustakaan yang bergantung padanya.  Kesulitannya adalah ketika sampai pada tanggal saat ini, Anda tidak akan pernah bisa mendapatkan pernyataan yang benar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } expect(foo()).toBe(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now()) <span class="hljs-comment"><span class="hljs-comment">// This would throw occasionally: // expect(received).toBe(expected) // Object.is equality // // Expected: 1558881400838 // Received: 1558881400837</span></span></code> </pre> <br><br>  Pada akhirnya, Anda harus mendefinisikan ulang objek Tanggal global agar konsisten dan dapat dikelola: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Namun, ini dianggap praktik yang buruk, karena redefinisi dipertahankan antara tes.  Anda tidak akan melihat ini jika tidak ada tes lain berdasarkan Date.now, tetapi akan bocor juga. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // ??? })</span></span></code> </pre><br>  Saya dulu ‚Äúmemecahkannya‚Äù agar tidak bocor: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oriDateNow = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Date.now = oriDateNow }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Namun, ada cara yang jauh lebih baik, lebih sedikit peretas untuk melakukan ini: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() jest.spyOn(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-string"><span class="hljs-string">'now'</span></span>).mockImplementationOnce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Dengan demikian, <code>jest.spyOn</code> mengikuti objek Date global yang meniru implementasi fungsi now untuk hanya satu panggilan.  Ini pada gilirannya akan membuat Date.sekarang utuh untuk sisa tes. <br><br>  Pasti ada informasi lebih lanjut tentang bertopik di Jest.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> lengkap untuk lebih jelasnya. <br><br>  Artikel ini sudah cukup lama, jadi saya pikir itu saja untuk saat ini.  Ini hanya mempengaruhi sebagian kecil dari kemampuan Jest, dan saya hanya menyoroti favorit saya.  Jika Anda memiliki fakta menarik lainnya, beri tahu saya. <br><br>  Juga, jika Anda sering menggunakan Jest, periksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Majestic</a> , yang merupakan GUI bebas GUI untuk Jest, alternatif yang sangat bagus untuk keluaran terminal yang membosankan.  Saya tidak yakin apakah penulisnya ada di dev.to, tetapi tetap saja menghormati orang ini. <br><br>  Seperti biasa, terima kasih atas perhatian Anda! <br><br>  Itu saja.  Sampai jumpa di lapangan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457616/">https://habr.com/ru/post/id457616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457606/index.html">Alan Kay: Apa yang bisa disebut hal paling menakjubkan yang dimungkinkan oleh komputer</a></li>
<li><a href="../id457608/index.html">Cara memvisualisasikan data menjadi cerita yang menarik</a></li>
<li><a href="../id457610/index.html">Analisis kerentanan Parcel Jahat</a></li>
<li><a href="../id457612/index.html">Bagaimana cara mempercepat dekompresi LZ4 di ClickHouse?</a></li>
<li><a href="../id457614/index.html">Rahasia mencari pekerjaan di luar negeri dari seorang headhunter yang berpraktik</a></li>
<li><a href="../id457618/index.html">Menjadi pengembang penuh tumpukan modern</a></li>
<li><a href="../id457622/index.html">Mengukur Kinerja Qt</a></li>
<li><a href="../id457624/index.html">Bagaimana kami memecahkan pondok tua itu dan membangun gedung pencakar langit di tempatnya</a></li>
<li><a href="../id457626/index.html">Revisi tingkat akses pengguna menggunakan Power BI menggunakan contoh Bitrix CMS (BUS)</a></li>
<li><a href="../id457628/index.html">Program P2M dan manajemen proyek yang efektif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>