<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèΩ üö∂üèª üí¨ √úber Bitz√§hlung, vorzeichenlose Typen in Kotlin und √ºber Situationen, in denen das Speichern von √úbereinstimmungen gerechtfertigt ist üëºüèø üöµüèæ üõèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Kommentar wurde durch das Schreiben des Artikels veranlasst. Genauer gesagt, ein Satz davon. 
 ... Speicher oder Prozessorzyklen f√ºr Artikel in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber Bitz√§hlung, vorzeichenlose Typen in Kotlin und √ºber Situationen, in denen das Speichern von √úbereinstimmungen gerechtfertigt ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/451622/"><img src="https://habrastorage.org/webt/b6/qc/5k/b6qc5klplot_lkmjsi0edrecbye.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Kommentar wurde</a> durch das Schreiben des Artikels veranlasst.  Genauer gesagt, ein Satz davon. <br><blockquote>  ... Speicher oder Prozessorzyklen f√ºr Artikel in Milliarden von Dollar auszugeben ist nicht gut ... <br></blockquote>  So kam es, dass ich k√ºrzlich genau das tun musste.  Und obwohl der Fall, den ich in diesem Artikel betrachten werde, etwas Besonderes ist - die Schlussfolgerungen und angewandten L√∂sungen k√∂nnen f√ºr jemanden n√ºtzlich sein. <br><br><h1>  Ein bisschen Kontext </h1><br>  Die iFunny-Anwendung verarbeitet eine gro√üe Menge an Grafik- und Videoinhalten, und die unscharfe Suche nach Duplikaten ist eine der sehr wichtigen Aufgaben.  Dies ist an sich ein gro√ües Thema, das einen separaten Artikel verdient, aber heute werde ich nur ein wenig √ºber einige Ans√§tze zur Berechnung sehr gro√üer Zahlenfelder in Bezug auf diese Suche sprechen.  Nat√ºrlich hat jeder ein anderes Verst√§ndnis von "sehr gro√üen Arrays", und es w√§re dumm, mit dem Hadron Collider zu konkurrieren, aber immer noch.  :) :) <br><br>  Wenn der Algorithmus sehr kurz ist, wird f√ºr jedes Bild seine digitale Signatur (Signatur) aus 968 Ganzzahlen erstellt, und der Vergleich wird durchgef√ºhrt, indem der "Abstand" zwischen den beiden Signaturen ermittelt wird.  Wenn man bedenkt, dass das Inhaltsvolumen allein in den letzten zwei Monaten etwa 10 Millionen Bilder betrug, wird ein aufmerksamer Leser es leicht in seinem Kopf herausfinden - dies sind genau die ‚ÄûElemente in Milliarden von Volumen‚Äú.  Wen k√ºmmert es - willkommen bei Katze. <br><a name="habracut"></a><br>  Am Anfang wird es eine langweilige Geschichte √ºber das Sparen von Zeit und Ged√§chtnis geben, und am Ende wird es eine kurze lehrreiche Geschichte dar√ºber geben, dass es manchmal sehr n√ºtzlich ist, sich die Quelle anzusehen.  Ein Bild, das Aufmerksamkeit erregt, steht in direktem Zusammenhang mit dieser lehrreichen Geschichte. <br><br>  Ich muss zugeben, dass ich ein bisschen gerissen war.  In einer vorl√§ufigen Analyse des Algorithmus konnte die Anzahl der Werte in jeder Signatur von 968 auf 420 reduziert werden. Sie ist bereits doppelt so gut, aber die Gr√∂√üenordnung bleibt gleich. <br><br>  Wenn Sie dar√ºber nachdenken, ist es nicht so sehr, dass ich get√§uscht habe, und dies wird die erste Schlussfolgerung sein: Bevor Sie mit der Aufgabe fortfahren, sollten Sie dar√ºber nachdenken - ist es m√∂glich, sie im Voraus irgendwie zu vereinfachen? <br><br>  Der Vergleichsalgorithmus ist recht einfach: Die Wurzel der Summe der Quadrate der Differenzen der beiden Signaturen wird berechnet, geteilt durch die Summe der zuvor berechneten Werte (d. H. In jeder Iteration wird die Summierung immer noch als Konstante herausgenommen und kann √ºberhaupt nicht als konstant herausgenommen werden) und mit dem Schwellenwert verglichen werden.  Es ist anzumerken, dass Signaturelemente auf Werte von -2 bis +2 beschr√§nkt sind und dementsprechend der absolute Wert der Differenz auf Werte von 0 bis 4 begrenzt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br>  Nichts kompliziertes, aber die Menge entscheidet. <br><br><h1>  Erster Ansatz, naiv </h1><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  const val d = 0.3 // 10.000.000 . //      , //        val collection: MutableList&lt;Signature&gt; = mutableListOf() // signature ‚Äî   420   Byte class Signature(val signature: Array&lt;Byte&gt;, val norma: Double) fun getSimilar(signature: Signature) = collection .filter { calculateDistance(it, signature) &lt; d } fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; Math.pow((value - second.signature[index]).toDouble(), 2.0) }.sum()) / (first.norma + second.norma)</span></span></code> </pre> <br>  Berechnen wir, was wir hier haben, mit der Anzahl der Operationen: <br><br>  <code>10M</code> <code>Math.sqrt</code> <br>  <code>10M</code> Erg√§nzungen und Abteilungen <code>/ (first.norma + second.norma)</code> <br>  <code>4.200M</code> Subtraktionen und Quadrieren von <code>Math.pow((value - second.signature[index]).toDouble(), 2.0)</code> <br>  <code>4.200M</code> Erg√§nzungen <code>.sum()</code> <br><br>  Welche M√∂glichkeiten haben wir: <br><br><ol><li>  Bei solchen Volumina ist es eine unverzeihliche Verschwendung, ein ganzes <code>Byte</code> (oder, Gott bewahre, jemand h√§tte gedacht, <code>Int</code> zu verwenden) zum Speichern von drei signifikanten Bits auszugeben. </li><li>  Vielleicht, wie man den Umfang der Mathematik reduziert? </li><li>  Aber ist es m√∂glich, eine vorl√§ufige Filterung durchzuf√ºhren, die nicht so rechenintensiv ist? </li></ol><br><h1>  Den zweiten Ansatz packen wir </h1><br>  <i>√úbrigens, wenn jemand vorschl√§gt, wie Sie die Berechnungen mit einer solchen Verpackung vereinfachen k√∂nnen, erhalten Sie ein gro√ües Dankesch√∂n und ein Plus an Karma.</i>  <i>Obwohl einer, aber von ganzem Herzen :)</i> <br><br>  One <code>Long</code> ist 64 Bit, in unserem Fall k√∂nnen wir 21 Werte darin speichern (und 1 Bit bleibt ungekl√§rt). <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   20   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; calculatePartial(value, second.signature[index]) }.sum()) / (first.norma + second.norma) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L (0..60 step 3).onEach { val current = (first.ushr(it) and 0x7) - (second.ushr(it) and 0x7) sum += current * current } return sum.toDouble() }</span></span></code> </pre><br>  Es ist besser aus dem Speicher ( <code>4.200M</code> gegen√ºber <code>1.600M</code> , wenn auch ungef√§hr), aber was ist mit den Berechnungen? <br><br>  Ich denke, es ist offensichtlich, dass die Anzahl der Operationen gleich geblieben ist und <code>8.400M</code> Schichten und <code>8.400M</code> logische <code>8.400M</code> hinzugef√ºgt wurden. Vielleicht kann es optimiert werden, aber der Trend ist immer noch nicht gl√ºcklich - das ist nicht das, was wir wollten. <br><br><h1>  Der dritte Ansatz ist das Umpacken mit Sub-Subs </h1><br>  Am Morgen kann ich es riechen, hier kannst du etwas Magie anwenden! <br><br>  Speichern wir die Werte nicht in drei, sondern in vier Bits.  Auf diese Weise: <br><div class="scrollable-table"><table><tbody><tr><td>  -2 </td><td>  0b1100 </td></tr><tr><td>  -1 </td><td>  0b0100 </td></tr><tr><td>  0 </td><td>  0b0000 </td></tr><tr><td>  1 </td><td>  0b0010 </td></tr><tr><td>  2 </td><td>  0b0011 </td></tr></tbody></table></div><br>  Ja, wir werden die Packungsdichte im Vergleich zur vorherigen Version verlieren, aber wir werden die M√∂glichkeit bekommen, <code>Long</code> mit 16 (nicht ganz) Unterschieden mit einem <code>XOR</code> -Ohm auf einmal zu erhalten.  Dar√ºber hinaus gibt es nur 11 Optionen f√ºr die Verteilung von Bits in jedem endg√ºltigen Halbbyte, sodass Sie vorberechnete Werte der Quadrate der Differenzen verwenden k√∂nnen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   27   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) // -1    val precomputed = arrayOf(0, 1, 1, 4, 1, -1, 4, 9, 1, -1, -1, -1, 4, -1, 9, 16) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L val difference = first xor second (0..60 step 4).onEach { sum += precomputed[(difference.ushr(it) and 0xF).toInt()] } return sum.toDouble() }</span></span></code> </pre><br>  Aus dem Speicher wurde es <code>2.160M</code> gegen√ºber <code>1.600M</code> - unangenehm, aber immer noch besser als die anf√§nglichen <code>4.200M</code> . <br><br>  Berechnen wir die Operationen: <br><br>  <code>10M</code> Quadratwurzeln, Erg√§nzungen und Unterteilungen (nirgendwo hingegangen) <br>  <code>270M</code> <code>XOR</code> 's <br>  <code>4.320</code> Hinzuf√ºgungen, Verschiebungen, logische <code>4.320</code> und Extrakte aus dem Array. <br><br>  Es sieht schon interessanter aus, aber es gibt trotzdem zu viele Berechnungen.  Leider scheinen wir diese 20% der Anstrengungen bereits aufgewendet zu haben, um 80% des Ergebnisses zu erzielen, und es ist Zeit dar√ºber nachzudenken, wo Sie sonst noch profitieren k√∂nnen.  Das erste, was mir in den Sinn kommt, ist, es √ºberhaupt nicht zu einer Berechnung zu bringen und offensichtlich unangemessene Signaturen mit einem leichten Filter herauszufiltern. <br><br><h1>  Vierter Ansatz, gro√ües Sieb </h1><br>  Wenn Sie die Berechnungsformel leicht transformieren, k√∂nnen Sie diese Ungleichung erhalten (je kleiner der berechnete Abstand, desto besser): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/ny/mv/nunymvgccfhu2hlexvir0d0dlvq.png"></div><br>  Das hei√üt,  Jetzt m√ºssen wir herausfinden, wie der minimal m√∂gliche Wert der linken Seite der Ungleichung basierend auf den Informationen berechnet werden kann, die wir √ºber die Anzahl der in <code>Long</code> gesetzten Bits haben.  Dann verwerfen Sie einfach alle Unterschriften, die ihn nicht zufrieden stellen. <br>  Ich m√∂chte Sie daran erinnern, dass x <sub>i</sub> Werte von 0 bis 4 annehmen kann (das Vorzeichen ist nicht wichtig, ich denke, es ist klar, warum).  Da jeder Term quadratisch ist, l√§sst sich leicht ein allgemeines Muster ableiten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/pk/um/empkumsytnx11yoplffogdf4dbc.png"></div><br>  Die endg√ºltige Formel sieht so aus (wir werden sie nicht brauchen, aber ich habe sie lange abgeleitet und es w√§re eine Schande, sie einfach zu vergessen und niemandem zu zeigen): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/md/xd/ramdxdoczcczinkn8bouj_40zls.png"></div><br>  Wobei B die Anzahl der gesetzten Bits ist. <br><br>  Lesen Sie in einem <code>Long</code> nur 64 Bit 64 m√∂gliche Ergebnisse.  Und sie werden im Voraus perfekt berechnet und analog zum vorherigen Abschnitt zu einem Array hinzugef√ºgt. <br><br>  Dar√ºber hinaus ist es v√∂llig optional, alle 27 Longs zu berechnen. Es reicht aus, den Schwellenwert beim n√§chsten zu √ºberschreiten, und Sie k√∂nnen die Pr√ºfung unterbrechen und false zur√ºckgeben.  Der gleiche Ansatz kann √ºbrigens in der Hauptberechnung verwendet werden. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .asSequence() <span class="hljs-comment"><span class="hljs-comment">//     !? .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d } val estimateValues = arrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 69, 74, 79, 84, 89, 94, 99, 104, 109, 114, 119, 124, 129, 134, 139, 144, 151, 158, 165, 172, 179, 186, 193, 200, 207, 214, 221, 228, 235, 242, 249, 256) fun estimate(first: Signature, second: Signature):Boolean{ var bitThreshold = Math.pow(d * (first.norma + second.norma), 2.0).toLong() first.signature.forEachIndexed { index, value -&gt; bitThreshold -= estimateValues[java.lang.Long.bitCount(value xor second.signature[index])] if (bitThreshold &lt;= 0) return false } return true }</span></span></code> </pre><br>  Hierbei ist zu verstehen, dass die Wirksamkeit dieses Filters (bis zu negativ) katastrophal von der ausgew√§hlten Schwelle und etwas weniger stark von den Eingabedaten abh√§ngt.  Gl√ºcklicherweise gelingt es einer relativ kleinen Anzahl von Objekten f√ºr den erforderlichen Schwellenwert <code>d=0.3</code> den Filter zu passieren, und der Beitrag ihrer Berechnung zur Gesamtantwortzeit ist so gering, dass sie vernachl√§ssigt werden k√∂nnen.  Und wenn ja, k√∂nnen Sie etwas mehr sparen. <br><br><h1>  F√ºnfter Ansatz, Sequenz loswerden </h1><br>  Bei der Arbeit mit gro√üen Sammlungen ist die <code>sequence</code> eine gute Verteidigung gegen die √§u√üerst unangenehmen <b>Speicherausf√§lle</b> .  Wenn wir jedoch offensichtlich wissen, dass die Sammlung beim ersten Filter auf eine vern√ºnftige Gr√∂√üe reduziert wird, w√§re es eine viel vern√ºnftigere Wahl, eine gew√∂hnliche Iteration in einer Schleife mit der Erstellung einer Zwischensammlung zu verwenden, da die <code>sequence</code> nicht nur modisch und jugendlich ist, sondern auch ein Iterator. das <code>hasNext</code> Begleiter, die weit davon entfernt sind, frei zu sein. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d }</code> </pre><br>  Es scheint, dass es hier Gl√ºck ist, aber ich wollte es "sch√∂n machen".  Hier kommen wir zu der versprochenen lehrreichen Geschichte. <br><br><h1>  Sechster Ansatz, wir wollten das Beste </h1><br>  Wir schreiben √ºber Kotlin und hier einige ausl√§ndische <code>java.lang.Long.bitCount</code> !  Und in j√ºngerer Zeit wurden nicht signierte Typen in die Sprache gebracht.  Angriff! <br><br>  Kaum gesagt als getan.  Alle <code>ULong</code> durch <code>ULong</code> ersetzt. <code>ULong</code> aus der Java-Quelle herausgerissen und als Erweiterungsfunktion f√ºr <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ULong.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> i = i - (i.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>uL) i = (i and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) + (i.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>) and <span class="hljs-number"><span class="hljs-number">0x0f0f0f0f0f0f0f0f</span></span>uL i = i + i.shr(<span class="hljs-number"><span class="hljs-number">8</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">16</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.toInt() and <span class="hljs-number"><span class="hljs-number">0x7f</span></span> }</code> </pre><br>  Wir fangen an und ... etwas stimmt nicht.  Der Code begann merklich langsamer zu arbeiten.  Wir starten den Profiler und sehen etwas Seltsames (siehe <code>bitCount()</code> Artikels): etwas weniger als eine Million Aufrufe von <code>bitCount()</code> fast 16 Millionen Aufrufe von <code>Kotlin.ULong.constructor-impl</code> .  WAT !? <br><br>  Das R√§tsel wird einfach erkl√§rt - schauen Sie sich einfach den Klassencode <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ULong</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@PublishedApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@PublishedApi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) : Comparable&lt;ULong&gt; { <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.plus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.minus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bitCount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> shl bitCount) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.inc())  .. }</code> </pre><br>  Nein, ich verstehe alles, <code>ULong</code> ist jetzt <code>experimental</code> , aber wie ist das? <br>  Im Allgemeinen erkennen wir den Ansatz als fehlgeschlagen an, was schade ist. <br><br>  Nun, aber vielleicht kann noch etwas verbessert werden? <br><br>  Eigentlich kannst du.  Der urspr√ºngliche Code <code>java.lang.Long.bitCount</code> ist nicht der optimalste.  Im allgemeinen Fall ergibt sich ein gutes Ergebnis. Wenn wir jedoch im Voraus wissen, auf welchen Prozessoren unsere Anwendung funktioniert, k√∂nnen wir einen optimaleren Weg w√§hlen. Hier ist ein sehr guter Artikel √ºber Habr√©. Ich empfehle dringend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzelne Bits zu z√§hlen</a> . Ich empfehle dringend, ihn zu lesen. <br><br>  Ich habe die "kombinierte Methode" verwendet <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Long</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> n -= (n.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555L</span></span> n = ((n.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) + (n and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) n = ((((n.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>)) + n) and <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0FL</span></span>) * <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>).shr(<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.toInt() and <span class="hljs-number"><span class="hljs-number">0x7F</span></span> }</code> </pre><br><h1>  Papageien z√§hlen </h1><br>  Alle Messungen wurden willk√ºrlich w√§hrend der Entwicklung auf dem lokalen Computer durchgef√ºhrt und aus dem Speicher reproduziert. Daher ist es schwierig, √ºber die Genauigkeit zu sprechen, aber Sie k√∂nnen den ungef√§hren Beitrag jedes Ansatzes absch√§tzen. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Was hat getan </th><th>  Papageien (Sekunden) </th></tr><tr><td>  Erster Ansatz, naiv </td><td>  25 ¬± </td></tr><tr><td>  Den zweiten Ansatz packen wir </td><td>  - - </td></tr><tr><td>  Der dritte Ansatz ist das Umpacken mit Sub-Subs </td><td>  11-14 </td></tr><tr><td>  Vierter Ansatz, gro√ües Sieb </td><td>  2-3 </td></tr><tr><td>  F√ºnfter Ansatz, Sequenz loswerden </td><td>  1.8-2.2 </td></tr><tr><td>  Sechster Ansatz, wir wollten das Beste </td><td>  3-4 </td></tr><tr><td>  "Kombinierte Methode" zum Z√§hlen der gesetzten Bits </td><td>  1.5-1.7 </td></tr></tbody></table></div><br><h1>  Schlussfolgerungen </h1><br><ul><li>  Bei der Verarbeitung gro√üer Datenmengen lohnt es sich, Zeit f√ºr eine vorl√§ufige Analyse aufzuwenden.  M√∂glicherweise m√ºssen nicht alle diese Daten verarbeitet werden. </li><li>  Wenn Sie eine grobe, aber billige Vorfilterung verwenden k√∂nnen, kann dies sehr hilfreich sein. </li><li>  Ein bisschen Magie ist unser Alles.  Gegebenenfalls nat√ºrlich. </li><li>  Das Betrachten von Quellcodes von Standardklassen und -funktionen ist manchmal sehr n√ºtzlich. </li></ul><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit!  :) :) <br><br>  Und ja, um fortzufahren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451622/">https://habr.com/ru/post/de451622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451606/index.html">Internet-Geschichte: Zerfall, Teil 2</a></li>
<li><a href="../de451610/index.html">Sicherheitswoche 20: Deaktivieren von Firefox-Erweiterungen</a></li>
<li><a href="../de451614/index.html">‚ÄûWas wir in Russland diskutieren, ist auch im Westen relevant‚Äú: Interview mit Denis Neklyudov</a></li>
<li><a href="../de451618/index.html">CampusInsight: Von der Infrastruktur√ºberwachung zur Analyse der Benutzererfahrung</a></li>
<li><a href="../de451620/index.html">Automatische Autorisierung auf der Strava Heatmap-Karte</a></li>
<li><a href="../de451624/index.html">Nat√ºrlich dar√ºber, wie Harry Potter die russische Bildung gestaltet, nicht dort, wo Sie sie brauchen</a></li>
<li><a href="../de451626/index.html">Lernen ohne Lehrer: ein neugieriger Sch√ºler</a></li>
<li><a href="../de451628/index.html">Top 3D Expo Bewertung im April 2019</a></li>
<li><a href="../de451630/index.html">Kontinuierliche √úberwachung - Automatisierung der Softwarequalit√§tspr√ºfungen in der CI / CD-Pipeline</a></li>
<li><a href="../de451634/index.html">Wie wir in Gesch√§ften und Restaurants analysiert werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>