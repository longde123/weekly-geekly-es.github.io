<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏽 🚶🏻 💬 Über Bitzählung, vorzeichenlose Typen in Kotlin und über Situationen, in denen das Speichern von Übereinstimmungen gerechtfertigt ist 👼🏿 🚵🏾 🛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Kommentar wurde durch das Schreiben des Artikels veranlasst. Genauer gesagt, ein Satz davon. 
 ... Speicher oder Prozessorzyklen für Artikel in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über Bitzählung, vorzeichenlose Typen in Kotlin und über Situationen, in denen das Speichern von Übereinstimmungen gerechtfertigt ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/451622/"><img src="https://habrastorage.org/webt/b6/qc/5k/b6qc5klplot_lkmjsi0edrecbye.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Kommentar wurde</a> durch das Schreiben des Artikels veranlasst.  Genauer gesagt, ein Satz davon. <br><blockquote>  ... Speicher oder Prozessorzyklen für Artikel in Milliarden von Dollar auszugeben ist nicht gut ... <br></blockquote>  So kam es, dass ich kürzlich genau das tun musste.  Und obwohl der Fall, den ich in diesem Artikel betrachten werde, etwas Besonderes ist - die Schlussfolgerungen und angewandten Lösungen können für jemanden nützlich sein. <br><br><h1>  Ein bisschen Kontext </h1><br>  Die iFunny-Anwendung verarbeitet eine große Menge an Grafik- und Videoinhalten, und die unscharfe Suche nach Duplikaten ist eine der sehr wichtigen Aufgaben.  Dies ist an sich ein großes Thema, das einen separaten Artikel verdient, aber heute werde ich nur ein wenig über einige Ansätze zur Berechnung sehr großer Zahlenfelder in Bezug auf diese Suche sprechen.  Natürlich hat jeder ein anderes Verständnis von "sehr großen Arrays", und es wäre dumm, mit dem Hadron Collider zu konkurrieren, aber immer noch.  :) :) <br><br>  Wenn der Algorithmus sehr kurz ist, wird für jedes Bild seine digitale Signatur (Signatur) aus 968 Ganzzahlen erstellt, und der Vergleich wird durchgeführt, indem der "Abstand" zwischen den beiden Signaturen ermittelt wird.  Wenn man bedenkt, dass das Inhaltsvolumen allein in den letzten zwei Monaten etwa 10 Millionen Bilder betrug, wird ein aufmerksamer Leser es leicht in seinem Kopf herausfinden - dies sind genau die „Elemente in Milliarden von Volumen“.  Wen kümmert es - willkommen bei Katze. <br><a name="habracut"></a><br>  Am Anfang wird es eine langweilige Geschichte über das Sparen von Zeit und Gedächtnis geben, und am Ende wird es eine kurze lehrreiche Geschichte darüber geben, dass es manchmal sehr nützlich ist, sich die Quelle anzusehen.  Ein Bild, das Aufmerksamkeit erregt, steht in direktem Zusammenhang mit dieser lehrreichen Geschichte. <br><br>  Ich muss zugeben, dass ich ein bisschen gerissen war.  In einer vorläufigen Analyse des Algorithmus konnte die Anzahl der Werte in jeder Signatur von 968 auf 420 reduziert werden. Sie ist bereits doppelt so gut, aber die Größenordnung bleibt gleich. <br><br>  Wenn Sie darüber nachdenken, ist es nicht so sehr, dass ich getäuscht habe, und dies wird die erste Schlussfolgerung sein: Bevor Sie mit der Aufgabe fortfahren, sollten Sie darüber nachdenken - ist es möglich, sie im Voraus irgendwie zu vereinfachen? <br><br>  Der Vergleichsalgorithmus ist recht einfach: Die Wurzel der Summe der Quadrate der Differenzen der beiden Signaturen wird berechnet, geteilt durch die Summe der zuvor berechneten Werte (d. H. In jeder Iteration wird die Summierung immer noch als Konstante herausgenommen und kann überhaupt nicht als konstant herausgenommen werden) und mit dem Schwellenwert verglichen werden.  Es ist anzumerken, dass Signaturelemente auf Werte von -2 bis +2 beschränkt sind und dementsprechend der absolute Wert der Differenz auf Werte von 0 bis 4 begrenzt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br>  Nichts kompliziertes, aber die Menge entscheidet. <br><br><h1>  Erster Ansatz, naiv </h1><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  const val d = 0.3 // 10.000.000 . //      , //        val collection: MutableList&lt;Signature&gt; = mutableListOf() // signature —   420   Byte class Signature(val signature: Array&lt;Byte&gt;, val norma: Double) fun getSimilar(signature: Signature) = collection .filter { calculateDistance(it, signature) &lt; d } fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; Math.pow((value - second.signature[index]).toDouble(), 2.0) }.sum()) / (first.norma + second.norma)</span></span></code> </pre> <br>  Berechnen wir, was wir hier haben, mit der Anzahl der Operationen: <br><br>  <code>10M</code> <code>Math.sqrt</code> <br>  <code>10M</code> Ergänzungen und Abteilungen <code>/ (first.norma + second.norma)</code> <br>  <code>4.200M</code> Subtraktionen und Quadrieren von <code>Math.pow((value - second.signature[index]).toDouble(), 2.0)</code> <br>  <code>4.200M</code> Ergänzungen <code>.sum()</code> <br><br>  Welche Möglichkeiten haben wir: <br><br><ol><li>  Bei solchen Volumina ist es eine unverzeihliche Verschwendung, ein ganzes <code>Byte</code> (oder, Gott bewahre, jemand hätte gedacht, <code>Int</code> zu verwenden) zum Speichern von drei signifikanten Bits auszugeben. </li><li>  Vielleicht, wie man den Umfang der Mathematik reduziert? </li><li>  Aber ist es möglich, eine vorläufige Filterung durchzuführen, die nicht so rechenintensiv ist? </li></ol><br><h1>  Den zweiten Ansatz packen wir </h1><br>  <i>Übrigens, wenn jemand vorschlägt, wie Sie die Berechnungen mit einer solchen Verpackung vereinfachen können, erhalten Sie ein großes Dankeschön und ein Plus an Karma.</i>  <i>Obwohl einer, aber von ganzem Herzen :)</i> <br><br>  One <code>Long</code> ist 64 Bit, in unserem Fall können wir 21 Werte darin speichern (und 1 Bit bleibt ungeklärt). <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   20   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; calculatePartial(value, second.signature[index]) }.sum()) / (first.norma + second.norma) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L (0..60 step 3).onEach { val current = (first.ushr(it) and 0x7) - (second.ushr(it) and 0x7) sum += current * current } return sum.toDouble() }</span></span></code> </pre><br>  Es ist besser aus dem Speicher ( <code>4.200M</code> gegenüber <code>1.600M</code> , wenn auch ungefähr), aber was ist mit den Berechnungen? <br><br>  Ich denke, es ist offensichtlich, dass die Anzahl der Operationen gleich geblieben ist und <code>8.400M</code> Schichten und <code>8.400M</code> logische <code>8.400M</code> hinzugefügt wurden. Vielleicht kann es optimiert werden, aber der Trend ist immer noch nicht glücklich - das ist nicht das, was wir wollten. <br><br><h1>  Der dritte Ansatz ist das Umpacken mit Sub-Subs </h1><br>  Am Morgen kann ich es riechen, hier kannst du etwas Magie anwenden! <br><br>  Speichern wir die Werte nicht in drei, sondern in vier Bits.  Auf diese Weise: <br><div class="scrollable-table"><table><tbody><tr><td>  -2 </td><td>  0b1100 </td></tr><tr><td>  -1 </td><td>  0b0100 </td></tr><tr><td>  0 </td><td>  0b0000 </td></tr><tr><td>  1 </td><td>  0b0010 </td></tr><tr><td>  2 </td><td>  0b0011 </td></tr></tbody></table></div><br>  Ja, wir werden die Packungsdichte im Vergleich zur vorherigen Version verlieren, aber wir werden die Möglichkeit bekommen, <code>Long</code> mit 16 (nicht ganz) Unterschieden mit einem <code>XOR</code> -Ohm auf einmal zu erhalten.  Darüber hinaus gibt es nur 11 Optionen für die Verteilung von Bits in jedem endgültigen Halbbyte, sodass Sie vorberechnete Werte der Quadrate der Differenzen verwenden können. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   27   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) // -1    val precomputed = arrayOf(0, 1, 1, 4, 1, -1, 4, 9, 1, -1, -1, -1, 4, -1, 9, 16) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L val difference = first xor second (0..60 step 4).onEach { sum += precomputed[(difference.ushr(it) and 0xF).toInt()] } return sum.toDouble() }</span></span></code> </pre><br>  Aus dem Speicher wurde es <code>2.160M</code> gegenüber <code>1.600M</code> - unangenehm, aber immer noch besser als die anfänglichen <code>4.200M</code> . <br><br>  Berechnen wir die Operationen: <br><br>  <code>10M</code> Quadratwurzeln, Ergänzungen und Unterteilungen (nirgendwo hingegangen) <br>  <code>270M</code> <code>XOR</code> 's <br>  <code>4.320</code> Hinzufügungen, Verschiebungen, logische <code>4.320</code> und Extrakte aus dem Array. <br><br>  Es sieht schon interessanter aus, aber es gibt trotzdem zu viele Berechnungen.  Leider scheinen wir diese 20% der Anstrengungen bereits aufgewendet zu haben, um 80% des Ergebnisses zu erzielen, und es ist Zeit darüber nachzudenken, wo Sie sonst noch profitieren können.  Das erste, was mir in den Sinn kommt, ist, es überhaupt nicht zu einer Berechnung zu bringen und offensichtlich unangemessene Signaturen mit einem leichten Filter herauszufiltern. <br><br><h1>  Vierter Ansatz, großes Sieb </h1><br>  Wenn Sie die Berechnungsformel leicht transformieren, können Sie diese Ungleichung erhalten (je kleiner der berechnete Abstand, desto besser): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/ny/mv/nunymvgccfhu2hlexvir0d0dlvq.png"></div><br>  Das heißt,  Jetzt müssen wir herausfinden, wie der minimal mögliche Wert der linken Seite der Ungleichung basierend auf den Informationen berechnet werden kann, die wir über die Anzahl der in <code>Long</code> gesetzten Bits haben.  Dann verwerfen Sie einfach alle Unterschriften, die ihn nicht zufrieden stellen. <br>  Ich möchte Sie daran erinnern, dass x <sub>i</sub> Werte von 0 bis 4 annehmen kann (das Vorzeichen ist nicht wichtig, ich denke, es ist klar, warum).  Da jeder Term quadratisch ist, lässt sich leicht ein allgemeines Muster ableiten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/pk/um/empkumsytnx11yoplffogdf4dbc.png"></div><br>  Die endgültige Formel sieht so aus (wir werden sie nicht brauchen, aber ich habe sie lange abgeleitet und es wäre eine Schande, sie einfach zu vergessen und niemandem zu zeigen): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/md/xd/ramdxdoczcczinkn8bouj_40zls.png"></div><br>  Wobei B die Anzahl der gesetzten Bits ist. <br><br>  Lesen Sie in einem <code>Long</code> nur 64 Bit 64 mögliche Ergebnisse.  Und sie werden im Voraus perfekt berechnet und analog zum vorherigen Abschnitt zu einem Array hinzugefügt. <br><br>  Darüber hinaus ist es völlig optional, alle 27 Longs zu berechnen. Es reicht aus, den Schwellenwert beim nächsten zu überschreiten, und Sie können die Prüfung unterbrechen und false zurückgeben.  Der gleiche Ansatz kann übrigens in der Hauptberechnung verwendet werden. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .asSequence() <span class="hljs-comment"><span class="hljs-comment">//     !? .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d } val estimateValues = arrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 69, 74, 79, 84, 89, 94, 99, 104, 109, 114, 119, 124, 129, 134, 139, 144, 151, 158, 165, 172, 179, 186, 193, 200, 207, 214, 221, 228, 235, 242, 249, 256) fun estimate(first: Signature, second: Signature):Boolean{ var bitThreshold = Math.pow(d * (first.norma + second.norma), 2.0).toLong() first.signature.forEachIndexed { index, value -&gt; bitThreshold -= estimateValues[java.lang.Long.bitCount(value xor second.signature[index])] if (bitThreshold &lt;= 0) return false } return true }</span></span></code> </pre><br>  Hierbei ist zu verstehen, dass die Wirksamkeit dieses Filters (bis zu negativ) katastrophal von der ausgewählten Schwelle und etwas weniger stark von den Eingabedaten abhängt.  Glücklicherweise gelingt es einer relativ kleinen Anzahl von Objekten für den erforderlichen Schwellenwert <code>d=0.3</code> den Filter zu passieren, und der Beitrag ihrer Berechnung zur Gesamtantwortzeit ist so gering, dass sie vernachlässigt werden können.  Und wenn ja, können Sie etwas mehr sparen. <br><br><h1>  Fünfter Ansatz, Sequenz loswerden </h1><br>  Bei der Arbeit mit großen Sammlungen ist die <code>sequence</code> eine gute Verteidigung gegen die äußerst unangenehmen <b>Speicherausfälle</b> .  Wenn wir jedoch offensichtlich wissen, dass die Sammlung beim ersten Filter auf eine vernünftige Größe reduziert wird, wäre es eine viel vernünftigere Wahl, eine gewöhnliche Iteration in einer Schleife mit der Erstellung einer Zwischensammlung zu verwenden, da die <code>sequence</code> nicht nur modisch und jugendlich ist, sondern auch ein Iterator. das <code>hasNext</code> Begleiter, die weit davon entfernt sind, frei zu sein. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d }</code> </pre><br>  Es scheint, dass es hier Glück ist, aber ich wollte es "schön machen".  Hier kommen wir zu der versprochenen lehrreichen Geschichte. <br><br><h1>  Sechster Ansatz, wir wollten das Beste </h1><br>  Wir schreiben über Kotlin und hier einige ausländische <code>java.lang.Long.bitCount</code> !  Und in jüngerer Zeit wurden nicht signierte Typen in die Sprache gebracht.  Angriff! <br><br>  Kaum gesagt als getan.  Alle <code>ULong</code> durch <code>ULong</code> ersetzt. <code>ULong</code> aus der Java-Quelle herausgerissen und als Erweiterungsfunktion für <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ULong.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> i = i - (i.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>uL) i = (i and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) + (i.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>) and <span class="hljs-number"><span class="hljs-number">0x0f0f0f0f0f0f0f0f</span></span>uL i = i + i.shr(<span class="hljs-number"><span class="hljs-number">8</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">16</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.toInt() and <span class="hljs-number"><span class="hljs-number">0x7f</span></span> }</code> </pre><br>  Wir fangen an und ... etwas stimmt nicht.  Der Code begann merklich langsamer zu arbeiten.  Wir starten den Profiler und sehen etwas Seltsames (siehe <code>bitCount()</code> Artikels): etwas weniger als eine Million Aufrufe von <code>bitCount()</code> fast 16 Millionen Aufrufe von <code>Kotlin.ULong.constructor-impl</code> .  WAT !? <br><br>  Das Rätsel wird einfach erklärt - schauen Sie sich einfach den Klassencode <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ULong</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@PublishedApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@PublishedApi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) : Comparable&lt;ULong&gt; { <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.plus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.minus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bitCount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> shl bitCount) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.inc())  .. }</code> </pre><br>  Nein, ich verstehe alles, <code>ULong</code> ist jetzt <code>experimental</code> , aber wie ist das? <br>  Im Allgemeinen erkennen wir den Ansatz als fehlgeschlagen an, was schade ist. <br><br>  Nun, aber vielleicht kann noch etwas verbessert werden? <br><br>  Eigentlich kannst du.  Der ursprüngliche Code <code>java.lang.Long.bitCount</code> ist nicht der optimalste.  Im allgemeinen Fall ergibt sich ein gutes Ergebnis. Wenn wir jedoch im Voraus wissen, auf welchen Prozessoren unsere Anwendung funktioniert, können wir einen optimaleren Weg wählen. Hier ist ein sehr guter Artikel über Habré. Ich empfehle dringend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzelne Bits zu zählen</a> . Ich empfehle dringend, ihn zu lesen. <br><br>  Ich habe die "kombinierte Methode" verwendet <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Long</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> n -= (n.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555L</span></span> n = ((n.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) + (n and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) n = ((((n.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>)) + n) and <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0FL</span></span>) * <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>).shr(<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.toInt() and <span class="hljs-number"><span class="hljs-number">0x7F</span></span> }</code> </pre><br><h1>  Papageien zählen </h1><br>  Alle Messungen wurden willkürlich während der Entwicklung auf dem lokalen Computer durchgeführt und aus dem Speicher reproduziert. Daher ist es schwierig, über die Genauigkeit zu sprechen, aber Sie können den ungefähren Beitrag jedes Ansatzes abschätzen. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Was hat getan </th><th>  Papageien (Sekunden) </th></tr><tr><td>  Erster Ansatz, naiv </td><td>  25 ± </td></tr><tr><td>  Den zweiten Ansatz packen wir </td><td>  - - </td></tr><tr><td>  Der dritte Ansatz ist das Umpacken mit Sub-Subs </td><td>  11-14 </td></tr><tr><td>  Vierter Ansatz, großes Sieb </td><td>  2-3 </td></tr><tr><td>  Fünfter Ansatz, Sequenz loswerden </td><td>  1.8-2.2 </td></tr><tr><td>  Sechster Ansatz, wir wollten das Beste </td><td>  3-4 </td></tr><tr><td>  "Kombinierte Methode" zum Zählen der gesetzten Bits </td><td>  1.5-1.7 </td></tr></tbody></table></div><br><h1>  Schlussfolgerungen </h1><br><ul><li>  Bei der Verarbeitung großer Datenmengen lohnt es sich, Zeit für eine vorläufige Analyse aufzuwenden.  Möglicherweise müssen nicht alle diese Daten verarbeitet werden. </li><li>  Wenn Sie eine grobe, aber billige Vorfilterung verwenden können, kann dies sehr hilfreich sein. </li><li>  Ein bisschen Magie ist unser Alles.  Gegebenenfalls natürlich. </li><li>  Das Betrachten von Quellcodes von Standardklassen und -funktionen ist manchmal sehr nützlich. </li></ul><br>  Vielen Dank für Ihre Aufmerksamkeit!  :) :) <br><br>  Und ja, um fortzufahren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451622/">https://habr.com/ru/post/de451622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451606/index.html">Internet-Geschichte: Zerfall, Teil 2</a></li>
<li><a href="../de451610/index.html">Sicherheitswoche 20: Deaktivieren von Firefox-Erweiterungen</a></li>
<li><a href="../de451614/index.html">„Was wir in Russland diskutieren, ist auch im Westen relevant“: Interview mit Denis Neklyudov</a></li>
<li><a href="../de451618/index.html">CampusInsight: Von der Infrastrukturüberwachung zur Analyse der Benutzererfahrung</a></li>
<li><a href="../de451620/index.html">Automatische Autorisierung auf der Strava Heatmap-Karte</a></li>
<li><a href="../de451624/index.html">Natürlich darüber, wie Harry Potter die russische Bildung gestaltet, nicht dort, wo Sie sie brauchen</a></li>
<li><a href="../de451626/index.html">Lernen ohne Lehrer: ein neugieriger Schüler</a></li>
<li><a href="../de451628/index.html">Top 3D Expo Bewertung im April 2019</a></li>
<li><a href="../de451630/index.html">Kontinuierliche Überwachung - Automatisierung der Softwarequalitätsprüfungen in der CI / CD-Pipeline</a></li>
<li><a href="../de451634/index.html">Wie wir in Geschäften und Restaurants analysiert werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>