<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèº üòú ‚õ©Ô∏è D√©veloppement et test de contrat intelligent Hyperledger Fabric üõ°Ô∏è üë®‚Äçüî¨ üéÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) est une plate-forme open source qui utilise la technologie de registre distribu√© (DLT), con√ßue pour d√©velopper des applicatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement et test de contrat intelligent Hyperledger Fabric</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) est une plate-forme open source qui utilise la technologie de registre distribu√© (DLT), con√ßue pour d√©velopper des applications qui fonctionnent dans un environnement de r√©seau d'entreprise cr√©√© et contr√¥l√© par un consortium d'organisations utilisant des r√®gles d'autorisation. </p><br><p>  La plateforme prend en charge les contrats intelligents, en termes HLF - des codes de cha√Æne cr√©√©s dans des langages g√©n√©raux tels que Golang, JavaScript, Java, contrairement, par exemple, √† Ethereum, qui utilise un langage Solidity ax√© sur les contrats et √† fonctionnalit√©s limit√©es. (LLL, Viper, etc.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  Le d√©veloppement et le test de codes de cha√Æne, en raison de la n√©cessit√© de d√©ployer un nombre important de composants du r√©seau blockchain, peuvent √™tre un processus assez long avec un temps important consacr√© √† tester les changements.  Cet article pr√©sente une approche du d√©veloppement et des tests rapides des contrats intelligents HLF Golang √† l'aide de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CCKit</a> . </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  Application bas√©e sur HLF </h2><br><p>  Du point de vue du d√©veloppeur, l'application blockchain se compose de deux parties principales: </p><br><ul><li>  <strong>On-chain</strong> - contrats intelligents (programmes) fonctionnant dans un environnement isol√© du r√©seau blockchain qui d√©terminent les r√®gles de cr√©ation et la composition des attributs de transaction.  Dans un contrat intelligent, les principales actions sont la lecture, la mise √† jour et la suppression de donn√©es de l'√©tat du r√©seau blockchain.  Il convient de souligner que la suppression de donn√©es d'un √©tat laisse supposer que ces donn√©es √©taient pr√©sentes. </li><li>  <strong>Off-chain</strong> est une application (par exemple, une API) qui interagit avec l'environnement blockchain via le SDK.  L'interaction consiste √† appeler des fonctions de contrat intelligent et √† surveiller des √©v√©nements de contrat intelligent - les √©v√©nements externes peuvent entra√Æner des modifications de donn√©es dans le contrat intelligent, tandis que les √©v√©nements dans le contrat intelligent peuvent d√©clencher des actions dans des syst√®mes externes. </li></ul><br><p>  Les donn√©es sont g√©n√©ralement lues via le n≈ìud de r√©seau blockchain ¬´home¬ª.  Pour enregistrer les donn√©es, l'application envoie des requ√™tes aux n≈ìuds des organisations participant √† la ¬´politique d'approbation¬ª d'un contrat intelligent particulier. </p><br><p>  Pour d√©velopper du code hors cha√Æne (API, etc.), un SDK sp√©cialis√© est utilis√© qui encapsule l'interaction avec les n≈ìuds de la cha√Æne de blocs, la collecte des r√©ponses, etc.  Pour HLF, il existe des impl√©mentations SDK pour Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Node.Js</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Composants de tissu Hyperledger </h2><br><h3 id="kanal">  Cha√Æne </h3><br><p>  Un canal est un sous-r√©seau distinct de n≈ìuds qui prend en charge une cha√Æne de blocs isol√©e (registre), ainsi que l'√©tat actuel (valeur-cl√©) de la cha√Æne de blocs ( <em>√©tat mondial</em> ) utilis√© pour g√©rer les contrats intelligents.  Un h√¥te peut avoir acc√®s √† un nombre arbitraire de canaux. </p><br><h3 id="tranzakciya">  Transaction </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une transaction dans Hyperledger Fabric</a> est une mise √† jour atomique de l'√©tat d'une cha√Æne de blocs, r√©sultat de l'ex√©cution de la m√©thode chaincode.  Une transaction consiste en une demande d'appel de la m√©thode chaincode avec quelques arguments (proposition de transaction) sign√©s par le n≈ìud appelant et un ensemble de r√©ponses (r√©ponse de proposition de transaction) des n≈ìuds sur lesquels la transaction a √©t√© ¬´confirm√©e¬ª (avenant).  Les r√©ponses contiennent des informations sur les paires cl√©-valeur changeantes de l'√©tat de la cha√Æne de blocs de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble lecture-√©criture</a> et des informations de service (signatures et certificats des n≈ìuds confirmant la transaction).  Parce que  les cha√Ænes de blocs de canaux individuels sont physiquement s√©par√©es, une transaction ne peut √™tre effectu√©e que dans le contexte d'un canal. </p><br><p>  Les plateformes de blockchain "classiques", telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bitcoin</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ethereum</a> , utilisent le cycle de transaction Ordering-Execution ex√©cut√© par tous les n≈ìuds, ce qui limite l'√©volutivit√© du r√©seau de blockchain. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric utilise une architecture d'ex√©cution et de distribution de transactions qui comporte 3 op√©rations principales: </p><br><ul><li><p>  Ex√©cution ( <strong>ex√©cution</strong> ) - cr√©ation par un contrat intelligent s'ex√©cutant sur un ou plusieurs n≈ìuds de r√©seau, transactions - changements atomiques dans l'√©tat d'un registre distribu√© ( <em>avenant</em> ) </p><br></li><li><p>  Commande - commande et regroupement des transactions en blocs par le service de <em>commande</em> sp√©cialis√© √† l'aide d'un algorithme de consensus enfichable. </p><br></li><li><p>  Valider - v√©rification par les n≈ìuds du r√©seau des transactions provenant du <em>donneur</em> d' <em>ordre</em> avant de placer des informations de leur part dans leur copie du registre distribu√© </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Cette approche vous permet d'effectuer la phase d'ex√©cution de la transaction avant son entr√©e dans le r√©seau de la blockchain, ainsi que de dimensionner horizontalement le fonctionnement des n≈ìuds du r√©seau. </p><br><h3 id="cheynkod">  Chaincode </h3><br><p>  Un code de cha√Æne, qui peut √©galement √™tre appel√© un contrat intelligent, est un programme √©crit en Golang, JavaScript (HLF 1.1+) ou Java (HLF 1.3+), qui d√©finit les r√®gles de cr√©ation de transactions qui modifient l'√©tat d'une cha√Æne de blocs.  Le programme est ex√©cut√© simultan√©ment sur plusieurs n≈ìuds ind√©pendants du r√©seau distribu√© de n≈ìuds blockchain, ce qui cr√©e un environnement neutre pour l'ex√©cution des contrats intelligents en r√©conciliant les r√©sultats du programme sur tous les n≈ìuds n√©cessaires √† la "confirmation" de la transaction. </p><br><p>  Le code doit impl√©menter une interface compos√©e de m√©thodes: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  La m√©thode <strong>Init</strong> est appel√©e lors de l'instanciation ou de la mise √† niveau du codecode.  Cette m√©thode effectue l'initialisation n√©cessaire de l'√©tat du codecode.  Il est important de distinguer dans le code de m√©thode si l'appel est une instanciation ou une mise √† niveau, afin que par erreur vous n'initialisiez pas (r√©initialisiez) les donn√©es qui ont d√©j√† re√ßu un √©tat non nul pendant le fonctionnement du codecode. </li><li>  La m√©thode <strong>Invoke</strong> est appel√©e lorsque n'importe quelle fonction du code de code est accessible.  Cette m√©thode fonctionne avec le statut des contrats intelligents. </li></ul><br><p>  Le chaincode est install√© sur les pairs du r√©seau blockchain.  Au niveau du syst√®me, chaque instance du code correspond √† un docker-container distinct attach√© √† un n≈ìud de r√©seau sp√©cifique, qui effectue des appels de r√©partition √† l'ex√©cution du code. <br>  Contrairement aux contrats intelligents Ethereum, la logique de cha√Ænage peut √™tre mise √† jour, mais cela n√©cessite que tous les n≈ìuds qui h√©bergent le code de code installent une version mise √† jour. </p><br><p>  En r√©ponse √† un appel √† la fonction chaincode de l'ext√©rieur via le SDK, le chaincode cr√©e un changement d'√©tat de la cha√Æne de blocs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Read-Write Set</a> ), ainsi que des √©v√©nements.  Un code de cha√Æne fait r√©f√©rence √† un canal sp√©cifique et peut modifier les donn√©es dans un seul canal.  Dans le m√™me temps, si l'h√¥te sur lequel le code est install√© a √©galement acc√®s √† d'autres canaux, dans la logique du code peut √™tre la lecture des donn√©es de ces canaux. </p><br><p>  Les codes de cha√Æne sp√©ciaux pour g√©rer divers aspects du fonctionnement d'un r√©seau de cha√Ænes de blocs sont appel√©s codes de cha√Æne syst√®me. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Politique d'approbation </h3><br><p>  Une politique d'approbation d√©finit des r√®gles de consensus au niveau des transactions g√©n√©r√©es par un code de cha√Æne sp√©cifique.  La strat√©gie d√©finit les r√®gles qui d√©terminent quels n≈ìuds de canal doivent cr√©er une transaction.  Pour ce faire, chacun des n≈ìuds sp√©cifi√©s dans la politique d'approbation doit ex√©cuter la m√©thode de cha√Ænage (√©tape "Ex√©cuter"), effectuer une "simulation", apr√®s quoi les r√©sultats sign√©s seront collect√©s et v√©rifi√©s par le SDK qui a initi√© la transaction (tous les r√©sultats de simulation doivent √™tre identiques, les signatures de tous les n≈ìuds requis par la politique doivent √™tre pr√©sentes).  Ensuite, le SDK envoie la transaction √† <em>orderer</em> , apr√®s quoi tous les n≈ìuds qui ont acc√®s au canal recevront la transaction via <em>orderer</em> et effectueront l'√©tape "Valider".  Il est important de souligner que tous les n≈ìuds de canal ne doivent pas participer √† l'√©tape "Ex√©cuter". </p><br><p>  La politique d'approbation est d√©termin√©e au moment de l'instanciation ou de la mise √† niveau du code.  Dans la version 1.3, il est devenu possible de d√©finir des strat√©gies non seulement au niveau du code de cha√Æne, mais √©galement au niveau des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cl√©s d'approbation</a> individuelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bas√©es sur l'√©tat</a> .  Exemples de politiques d'approbation: </p><br><ul><li>  Noeuds A, B, C, D </li><li>  La plupart des n≈ìuds de canal </li><li>  Au moins 3 n≈ìuds de A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  √âv√©nement </h3><br><p>  Un √©v√©nement est un ensemble de donn√©es nomm√© qui vous permet de publier un ¬´flux de mise √† jour¬ª de l'√©tat de la cha√Æne de blockchain.  L'ensemble des attributs d'√©v√©nement d√©finit le code de cha√Æne. </p><br><h2 id="infrastruktura-seti">  Infrastructure r√©seau </h2><br><h3 id="uzel-seti-peer">  H√¥te (pair) </h3><br><p>  Un h√¥te est connect√© √† un nombre arbitraire de canaux pour lesquels il dispose de droits d'acc√®s.  L'h√¥te conserve sa version de la cha√Æne de blocs et l'√©tat de la cha√Æne de blocs, et fournit √©galement un environnement pour l'ex√©cution des codes de cha√Æne.  Si l'h√¥te ne fait pas partie de la politique d'approbation, il n'est pas n√©cessaire de la configurer avec des codes de cha√Æne. </p><br><p>  Au niveau du logiciel h√¥te, l'√©tat actuel de la cha√Æne de blocs (√©tat mondial) peut √™tre stock√© dans LevelDB ou dans CouchDB.  L'avantage de CouchDB est sa prise en charge des requ√™tes riches utilisant la syntaxe MongoDB. </p><br><h3 id="orderer">  Commander </h3><br><p>  Le service de gestion des transactions accepte les transactions sign√©es en entr√©e et garantit que les transactions sont r√©parties sur les n≈ìuds du r√©seau dans le bon ordre. </p><br><p>  Orderer n'ex√©cute pas de contrats intelligents et ne contient pas de cha√Ænes de blocs et d'√©tats de cha√Ænes de blocs.  √Ä l'heure actuelle (1.3), il existe deux impl√©mentations de <em>Orderer</em> - un d√©veloppement <em>solo</em> et une version bas√©e sur Kafka qui fournit une tol√©rance aux pannes.  Une mise en ≈ìuvre de la <em>commande</em> supportant la r√©sistance au comportement incorrect d'une certaine fraction des participants (tol√©rance aux pannes byzantine) est attendue fin 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Services d'identit√© </h3><br><p>  Dans un r√©seau Hyperledger Fabric, tous les membres ont des identit√©s connues des autres membres (identit√©).  Pour l'identification, l'infrastructure √† cl√© publique (PKI) est utilis√©e, √† travers laquelle les certificats X.509 sont cr√©√©s pour les organisations, les √©l√©ments d'infrastructure (n≈ìud, ordre), les applications et les utilisateurs finaux.  Par cons√©quent, l'acc√®s √† la lecture et √† la modification des donn√©es peut √™tre contr√¥l√© par des r√®gles d'acc√®s au niveau du r√©seau, sur un seul canal ou dans la logique d'un contrat intelligent.  Dans le m√™me r√©seau blockchain, plusieurs services d'identification de diff√©rents types peuvent fonctionner simultan√©ment. </p><br><h1 id="realizaciya-cheynkoda">  Impl√©mentation du codecode </h1><br><p>  Le code de cha√Æne peut √™tre consid√©r√© comme un objet dot√© de m√©thodes qui impl√©mentent une logique m√©tier sp√©cifique.  Contrairement √† la POO classique, un code de cha√Æne ne peut pas avoir de champs d'attribut.  Pour travailler avec l'√©tat, dont le stockage est fourni par la plateforme de cha√Æne de blocs HLF, la couche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChaincodeStubInterface</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√©e</a> , qui est transmise lorsque les m√©thodes <em>Init</em> et <em>Invoke</em> sont appel√©es.  Il offre la possibilit√© de recevoir des arguments d'appel de fonction et d'apporter des modifications √† l'√©tat de la cha√Æne de blocs: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  Dans le contrat intelligent Ethereum d√©velopp√© sur Solidity, chaque m√©thode a une fonction publique.  Dans le chaincode Hyperledger Fabric dans les m√©thodes <em>Init</em> et <em>Invoke</em> √† l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs (),</em> vous pouvez obtenir les arguments de l'appel de fonction sous la forme d'un tableau de tableaux d'octets, tandis que le premier √©l√©ment du tableau lors de l'appel √† <em>Invoke</em> contient le nom de la fonction chaincode.  Parce que  L'invocation de n'importe quelle m√©thode de chaincode passe par la m√©thode Invoke; nous pouvons dire qu'il s'agit d'une impl√©mentation du mod√®le de contr√¥leur frontal. </p><br><p>  Par exemple, si nous consid√©rons la mise en ≈ìuvre de l'interface Ethereum standard pour le jeton <a href="">ERC-20</a> , le contrat intelligent devrait impl√©menter les m√©thodes: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (adresse _propri√©taire) </li><li>  transfert (adresse _√†, uint256 _valeur) </li></ul><br><p>  Dans le cas de l'impl√©mentation HLF, le <em>code de</em> fonction <em>Invoke</em> doit √™tre capable de g√©rer les cas o√π le premier argument des appels <em>Invoke</em> contient le nom des m√©thodes attendues (par exemple, ¬´totalSupply¬ª ou ¬´balanceOf¬ª).  Un exemple de mise en ≈ìuvre de la norme ERC-20 peut √™tre vu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h2 id="primery-cheynkodov">  Exemples de code de cha√Æne </h2><br><p>  En plus de la documentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hyperledger Fabric</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il</a> existe quelques autres exemples de codes de cha√Æne: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application d'assurance Blockchain (2018)</a> </li><li>  <a href="">Marbres</a> </li><li>  <a href="">D√©monstration de location de voiture (2017)</a> s </li></ul><br><p>  L'impl√©mentation des codes de cha√Æne dans ces exemples est assez verbeuse et contient beaucoup de logique r√©p√©titive pour s√©lectionner les fonctions de routage appel√©es), v√©rifier le nombre d'arguments, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Une telle organisation du code entra√Æne une d√©t√©rioration de la lisibilit√© du code et des erreurs possibles, telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celle-ci</a> , lorsque vous avez simplement oubli√© de d√©-d√©clarer les donn√©es d'entr√©e.  Les pr√©sentations concernant les plans de d√©veloppement HLF mentionnent une r√©vision de l'approche pour le d√©veloppement des codes de cha√Æne, en particulier l'introduction d'annotations dans les codes de cha√Æne Java, etc., cependant, les plans concernent la version qui n'est attendue qu'en 2019.  L'exp√©rience du d√©veloppement de contrats intelligents a conduit √† la conclusion que le d√©veloppement et le test de codes de cha√Æne seront plus faciles si vous s√©lectionnez les fonctionnalit√©s de base dans une biblioth√®que s√©par√©e. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - une biblioth√®que pour d√©velopper et tester des codes de cha√Æne </h1><br><p>  La biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CCKit</a> r√©sume la pratique de d√©veloppement et de test des codes de cha√Æne.  Dans le cadre du d√©veloppement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extensions</a> de chaincode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, la</a> biblioth√®que d'extensions OpenZeppelin pour les contrats intelligents Ethereum a √©t√© utilis√©e comme exemple.  CCKit utilise les solutions architecturales suivantes: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Acheminer les appels vers les fonctions de contrat intelligent </h2><br><p>  Le routage fait r√©f√©rence √† l'algorithme par lequel l'application r√©pond √† une demande client.  Cette approche est utilis√©e, par exemple, dans presque tous les frameworks http.  Le routeur utilise certaines r√®gles pour lier la demande et le gestionnaire de demandes.  Par rapport √† un code de cha√Æne, il s'agit d'associer le nom de la fonction de code de cha√Æne √† la fonction de gestionnaire. </p><br><p>  Dans les derniers exemples de contrats intelligents, par exemple, dans l' <a href="">application d'assurance</a> , cela utilise le mappage entre le nom de la fonction chaincode et la fonction dans le code Golang du formulaire: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  Le routeur CCKit utilise une approche similaire au routeur http, ainsi que la possibilit√© d'utiliser le contexte de demande pour la fonction chaincode et les fonctions middleware </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  Le contexte de l'appel √† la fonction du code </h2><br><p>  Semblable au contexte de demande http, qui a g√©n√©ralement acc√®s aux param√®tres de demande http, le routeur CCKit utilise le contexte de l'appel √† la fonction de <a href="">contrat intelligent</a> , qui est une abstraction au-dessus de <em>shim.ChaincodeStubInterface</em> .  Le contexte peut √™tre le seul argument du gestionnaire de la fonction de cha√Ænage; √† travers lui, le gestionnaire peut recevoir les arguments de l'appel de fonction, ainsi que l'acc√®s aux fonctionnalit√©s auxiliaires pour travailler avec l'√©tat du contrat intelligent (√âtat), cr√©er des r√©ponses (R√©ponse), etc. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Parce que  Le contexte est une interface, dans certains codes de cha√Æne, il peut √™tre √©tendu. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Fonctions middleware </h2><br><p>  Les fonctions de traitement interm√©diaire (middleware) sont appel√©es avant l'appel du gestionnaire de la m√©thode du code, ont acc√®s au contexte de l'appel √† la m√©thode du code et √† la fonction interm√©diaire suivante ou directement au gestionnaire de la m√©thode de la suivante (suivante).  Le middleware peut √™tre utilis√© pour: </p><br><ul><li>  conversion des donn√©es d'entr√©e (dans l'exemple ci-dessous, <em>p.String</em> et <em>p.Struct</em> sont des middlewares) </li><li>  restrictions d'acc√®s √† la fonction (par exemple, <em>propri√©taire uniquement</em> ) </li><li>  ach√®vement du cycle de traitement des demandes </li><li>  appeler la prochaine fonction de traitement interm√©diaire √† partir de la pile </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Conversion de la structure des donn√©es </h2><br><p>  L'interface chaincode suppose qu'un tableau de tableaux d'octets est fourni √† l'entr√©e, dont chacun des √©l√©ments est un attribut de la fonction chaincode.  Afin d'emp√™cher le marshaling manuel des donn√©es du tableau d'octets vers le type de donn√©es golang (int, cha√Æne, structure, tableau) des arguments d'appel de fonction dans chaque gestionnaire de la fonction de cha√Ænage, les types de donn√©es attendus sont d√©finis au moment de la cr√©ation de la r√®gle de routage dans le routeur CCKit et le type est converti automatiquement .  Dans l'exemple qui <em>suit</em> , la fonction <em>carGet</em> attend un argument de type cha√Æne et la fonction <em>carRegister attend une</em> structure <em>CarPayload</em> .  L'argument est √©galement nomm√©, ce qui permet au gestionnaire d'obtenir sa valeur du contexte par son nom.  Un exemple de gestionnaire sera donn√© ci-dessous.  Protobuf peut √©galement √™tre utilis√© pour d√©crire le sch√©ma de donn√©es de cha√Ænage. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  De plus, la conversion automatique (marshalling) est utilis√©e lors de l'√©criture de donn√©es √† l'√©tat d'un contrat intelligent et lors de la cr√©ation d'√©v√©nements (le type golang est s√©rialis√© en un tableau d'octets) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Outils de d√©bogage et de journalisation des codes de cha√Æne </h2><br><p>  Pour d√©boguer le code, vous pouvez utiliser l'extension de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©bogage</a> , qui impl√©mente des m√©thodes de contrat intelligent qui vous permettront d'inspecter la pr√©sence de cl√©s dans l'√©tat du contrat intelligent, ainsi que de lire / modifier / supprimer directement la valeur par cl√©. </p><br><p>  Pour la journalisation dans le contexte d'un appel √† une fonction chaincode, la m√©thode Log () peut √™tre utilis√©e, qui retourne une instance de l'enregistreur utilis√© dans HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  M√©thodes de contrat intelligentes m√©thodes de contr√¥le d'acc√®s </h2><br><p>  Dans le cadre de l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propri√©taire</a> , des primitives de base pour stocker des informations sur le propri√©taire du code de cha√Æne instanci√© et des modificateurs d'acc√®s (middleware) pour les m√©thodes de contrat intelligentes sont impl√©ment√©es. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Outils de test de contrat intelligent </h2><br><p>  D√©ployer le r√©seau blockchain, installer et initialiser des codes de cha√Æne est une configuration assez compliqu√©e et une longue proc√©dure.  Le temps de r√©installation / mise √† niveau du code de contrat intelligent peut √™tre r√©duit en utilisant le mode DEV du contrat intelligent, cependant, le processus de mise √† jour du code sera toujours lent. </p><br><p>  Le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shim</a> contient une impl√©mentation de <a href="">MockStub</a> , qui <a href="">encapsule les</a> appels au code du code, simulant son fonctionnement dans l'environnement de blockchain HLF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'utilisation de MockStub</a> vous permet d'obtenir des r√©sultats de test presque instantan√©ment et de r√©duire le temps de d√©veloppement.  Si nous consid√©rons le sch√©ma g√©n√©ral de fonctionnement du code en HLF, MockStub remplace essentiellement le SDK, vous permettant d'appeler les fonctions du code et imite l'environnement de d√©marrage du code sur l'h√¥te. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  Le MockStub de la livraison HLF contient l'impl√©mentation de presque toutes les m√©thodes de l'interface <em>shim.ChaincodeStubInterface</em> , cependant, dans la version actuelle (1.3), il manque l'impl√©mentation de certaines m√©thodes importantes, telles que GetCreator.  Parce que  le code de cha√Æne peut utiliser cette m√©thode pour obtenir un certificat d'un cr√©ateur de transaction pour le contr√¥le d'acc√®s, pour une couverture maximale dans les tests, la possibilit√© d'avoir un talon de cette m√©thode est importante. </p><br><p>  La biblioth√®que CCKit contient une version √©tendue de <a href="">MockStub</a> , qui contient l'impl√©mentation des m√©thodes manquantes, ainsi que des m√©thodes de travail avec les canaux d'√©v√©nements, etc. </p><br><h2 id="primer-cheynkoda">  Exemple de code de cha√Æne </h2><br><p>  Par exemple, cr√©ons un code de cha√Æne simple pour stocker des informations sur les voitures enregistr√©es </p><br><h3 id="model-dannyh">  Mod√®le de donn√©es </h3><br><p>  L'√©tat du code de code est le stockage de valeur-cl√©, dans lequel la cl√© est une cha√Æne, la valeur est un tableau d'octets.  La pratique de base consiste √† stocker des instances de structures de donn√©es golang jonalis√©es en tant que valeurs.  Par cons√©quent, pour travailler avec des donn√©es dans le code de cha√Æne, apr√®s avoir lu √† partir de l'√©tat, vous devez d√©sarchiver le tableau d'octets. </p><br><p>  Pour enregistrer sur la voiture, nous utiliserons l'ensemble d'attributs suivant: </p><br><ul><li>  Identifiant (num√©ro de voiture) </li><li>  Mod√®le de voiture </li><li>  Informations sur le propri√©taire du v√©hicule </li><li>  Informations sur l'heure de changement des donn√©es </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Pour transf√©rer des donn√©es vers le code de cha√Æne, cr√©ez une structure distincte contenant uniquement les champs provenant de l'ext√©rieur du code de cha√Æne: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Travailler avec des cl√©s </h3><br><p>  Les cl√©s d'enregistrement dans un √©tat de contrat intelligent sont une cha√Æne.  Il prend √©galement en charge la possibilit√© de cr√©er des cl√©s composites dans lesquelles des parties de la cl√© sont s√©par√©es par un octet z√©ro ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  Dans <em>CCKit, les</em> fonctions de travail avec l'√©tat d'un contrat intelligent peuvent cr√©er automatiquement des cl√©s pour les enregistrements si les structures transf√©r√©es prennent en charge l'interface <em>Keyer</em> </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Pour enregistrer une voiture, la fonction de g√©n√©ration de cl√© sera la suivante: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  D√©claration de fonction de contrat intelligent (routage) </h3><br><p>  Dans la m√©thode constructeur du chaincode, nous pouvons d√©finir les fonctions du chaincode et leurs arguments.  Il y aura 3 fonctions dans le code d'immatriculation de la voiture </p><br><ul><li>  carList, renvoie un tableau de structures Car </li><li>  carGet, accepte un identifiant de voiture et renvoie une structure Car </li><li>  carRegister, accepte une instance s√©rialis√©e de la structure CarPayload et renvoie le r√©sultat de l'enregistrement.  L'acc√®s √† cette m√©thode n'est possible que pour le propri√©taire du code de cha√Æne, qui est enregistr√© √† l'aide du middleware du package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propri√©taire</a> </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  L'exemple ci-dessus utilise la structure <a href="">Chaincode</a> dans laquelle le traitement des m√©thodes <em>Init</em> et <em>Invoke</em> est d√©l√©gu√© au routeur: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  L'utilisation d'un routeur et de la structure de base de Chaincode permet la r√©utilisation des fonctions du gestionnaire.  Par exemple, pour impl√©menter chaincode sans v√©rifier l'acc√®s √† la fonction <code>carRegister</code> , <code>carRegister</code> suffira de cr√©er une nouvelle <a href="">m√©thode constructeur</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Mise en place des fonctions d'un contrat intelligent </h3><br><p>  Fonctions Golang - Les gestionnaires de fonctions de contrat intelligentes dans le routeur <strong>CCKit</strong> peuvent √™tre de trois types: </p><br><ul><li>  <em>StubHandlerFunc</em> - l'interface de gestionnaire standard, accepte <em>shim.ChaincodeStubInterface</em> , renvoie la r√©ponse standard <em>homologue.</em> </li><li>  <em>ContextHandlerFunc</em> - prend un contexte et renvoie un <em>pair.</em> </li><li>  <em>HandlerFunc</em> - prend un contexte, retourne une interface et une erreur.  Un tableau d'octets peut √™tre renvoy√© ou n'importe quel type de golang qui est automatiquement converti en un tableau d'octets en fonction du <em>peer.Response</em> cr√©√©.  Le statut de la r√©ponse sera <em>shim.Ok</em> ou <em>shim.Error</em> , selon l'erreur transmise. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       ‚Äî        ,     .      BDD ‚Äì Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Parce que   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426705/">https://habr.com/ru/post/fr426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426695/index.html">Cam√©ras de vision industrielle pour les passionn√©s. Comment utiliser l'appareil photo pour la navigation hors ligne?</a></li>
<li><a href="../fr426697/index.html">Travailler avec des appareils LibUsb sous Android</a></li>
<li><a href="../fr426699/index.html">Test Python avec pytest. Simple, rapide, efficace et √©volutif. Avant-propos et introduction</a></li>
<li><a href="../fr426701/index.html">Flutter - un nouveau regard sur le d√©veloppement multiplateforme</a></li>
<li><a href="../fr426703/index.html">Ce qui √©tait int√©ressant sur DataVizDay √† Minsk</a></li>
<li><a href="../fr426707/index.html">Syst√®me d'approbation. Comment nous avons invent√© le v√©lo</a></li>
<li><a href="../fr426709/index.html">Minuteries JavaScript: tout ce que vous devez savoir</a></li>
<li><a href="../fr426713/index.html">Intel Xeon W-3175X: 28 c≈ìurs pour la maison</a></li>
<li><a href="../fr426717/index.html">L'illusion de tromperie: une illusion d'optique visuelle bas√©e sur la r√©tro-pr√©vision</a></li>
<li><a href="../fr426719/index.html">Hackathon sur la science des donn√©es √† SIBUR: comment c'√©tait</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>