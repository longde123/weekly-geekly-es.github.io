<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÑÔ∏è ü§ôüèΩ üå† Bersiap untuk Berkombinasi üë©üèº‚ÄçüöÄ üöä üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setahun setengah yang lalu, saya menyanyikan pujian RxSwift . Butuh beberapa saat untuk mengetahuinya, tetapi ketika itu terjadi, tidak ada jalan untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bersiap untuk Berkombinasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470117/"><img src="https://habrastorage.org/webt/km/8-/uo/km8-uov-j3m2rfjjsxscoyeh9bc.jpeg"><br><br>  Setahun setengah yang lalu, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyanyikan pujian</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxSwift</a> .  Butuh beberapa saat untuk mengetahuinya, tetapi ketika itu terjadi, tidak ada jalan untuk kembali.  Sekarang saya memiliki palu terbaik di dunia, dan terkutuklah saya jika segala sesuatu di sekitar saya tidak tampak seperti paku. <br><br>  Apple memperkenalkan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Combine</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC</a> Summer Conference.  Sekilas, sepertinya versi RxSwift sedikit lebih baik.  Sebelum saya bisa menjelaskan apa yang saya sukai dan apa yang tidak, kita perlu memahami masalah apa yang Combine rancang untuk pecahkan. <br><a name="habracut"></a><br><h2>  Pemrograman reaktif?  Jadi apa </h2><br>  Komunitas ReactiveX - di mana komunitas RxSwift adalah bagian - menjelaskan esensinya sebagai berikut: <br><br><blockquote>  API untuk pemrograman asinkron dengan utas yang dapat diamati. </blockquote><br>  Dan juga: <br><br><blockquote>  ReactiveX adalah kombinasi dari ide-ide terbaik dari pola desain Observer dan Iterator, serta pemrograman fungsional. </blockquote><br>  Baiklah ... oke. <br><br>  Dan apa artinya ini? <br><br><h2>  Dasar-dasarnya </h2><br>  Untuk benar-benar memahami esensi pemrograman reaktif, saya merasa berguna untuk memahami bagaimana kita mendapatkannya.  Pada artikel ini, saya akan menjelaskan bagaimana Anda dapat melihat jenis yang ada dalam bahasa OOP modern, memutar mereka, dan kemudian datang ke pemrograman reaktif. <br><br>  Pada artikel ini, kita akan dengan cepat menyelidiki hutan, yang tidak <i>mutlak</i> diperlukan untuk memahami pemrograman reaktif. <br><br>  Namun, saya menganggap ini sebagai latihan akademis yang aneh, terutama dalam hal seberapa kuat bahasa yang diketik dapat membawa kita ke penemuan baru. <br><br>  Jadi tunggu posting saya berikutnya jika Anda tertarik dengan detail baru. <br><br><h2>  Terhitung </h2><br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman reaktif</a> " yang saya kenal berasal dari bahasa yang pernah saya tulis - C #.  Premisnya sendiri cukup sederhana: <br><br>  <i>Bagaimana jika, alih-alih mengekstraksi nilai dari yang dapat dihitung, mereka akan mengirimkan sendiri nilai-nilai itu kepada Anda?</i> <br><br>  Gagasan ini, "dorong bukannya tarikan," paling baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan oleh</a> Brian Beckman dan Eric Meyer.  36 menit pertama ... Saya tidak mengerti apa-apa, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai dari sekitar menit ke-36</a> itu menjadi <i>sangat</i> menarik. <br><br>  Singkatnya, mari kita merumuskan kembali gagasan sekelompok objek linear dalam Swift, serta objek yang dapat beralih pada grup linier ini.  Anda dapat melakukan ini dengan mendefinisikan protokol Swift palsu ini: <br><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ;     //    Array. protocol Enumerable { associatedtype Enum: Enumerator associatedtype Element where Self.Element == Self.Enum.Element func getEnumerator() -&gt; Self.Enum } // ,       . protocol Enumerator: Disposable { associatedtype Element func moveNext() throws -&gt; Bool var current: Element { get } } //          // Enumerator,         .   . protocol Disposable { func dispose() }</span></span></code> </pre> <br><h2>  Ganda </h2><br>  Mari balikkan semuanya dan hasilkan <i>ganda</i> .  Kami akan mengirim data ke tempat asalnya.  Dan dapatkan data dari tempat mereka pergi.  Kedengarannya tidak masuk akal, tapi tahanlah sedikit. <br><br><h3>  Enumerable ganda </h3><br>  Mari kita mulai dengan Enumerable: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerable { associatedtype Element where Self.Element == Self.Enum.Element associatedtype Enum: Enumerator func getEnumerator() -&gt; Self.Enum } protocol DualOfEnumerable { //  Enumerator : // getEnumerator() -&gt; Self.Enum //    : // getEnumerator(Void) -&gt; Enumerator // //  , : // : Void; : Enumerator // getEnumerator(Void) ‚Üí Enumerator // //     Void   Enumerator. //   -      Enumerator,   Void. // :  Enumerator; : Void func subscribe(DualOfEnumerator) }</span></span></code> </pre> <br>  Karena <code>getEnumerator()</code> mengambil <code>Void</code> dan memberikan <code>Enumerator</code> , sekarang kami menerima <code>Enumerator</code> [dobel] dan memberikan <code>Void</code> . <br><br>  Saya tahu ini aneh.  Jangan pergi. <br><br><h3>  Pencacah Ganda </h3><br>  Lalu apa itu <code>DualOfEnumerator</code> ? <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerator: Disposable { associatedtype Element // : Void; : Bool, Error func moveNext() throws -&gt; Bool // : Void; : Element var current: Element { get } } protocol DualOfEnumerator { // : Bool, Error; : Void //   Error    func enumeratorIsDone(Bool) // : Element, : Void var nextElement: Element { set } }</span></span></code> </pre> <br>  Ada beberapa masalah di sini: <br><br><ul><li>  Tidak ada konsep properti set-only di Swift. <br></li><li>  Apa yang terjadi dengan <code>throws</code> di <code>Enumerator.moveNext()</code> ? <br></li><li>  Apa yang terjadi dengan <code>Disposable</code> ? <br></li></ul><br>  Untuk memperbaiki masalah dengan properti set-only, kita dapat memperlakukannya seperti apa adanya - sebuah fungsi.  Mari kita <code>DualOfEnumerator</code> kita <code>DualOfEnumerator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool; : Void, Error //   Error    func enumeratorIsDone(Bool) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Untuk memecahkan masalah dengan <code>throws</code> , mari kita pisahkan kesalahan yang mungkin terjadi di <code>moveNext()</code> dan bekerja dengannya sebagai fungsi <code>error()</code> terpisah <code>error()</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool, Error; : Void func enumeratorIsDone(Bool) func error(Error) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Kita bisa melakukan sesuatu yang lain: lihat tanda tangan dari penyelesaian iterasi: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool)</span></span></span></span></code> </pre> <br>  Mungkin sesuatu yang serupa akan terjadi seiring waktu: <br><br><pre> <code class="swift hljs">enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     enumeratorIsDone(true)</span></span></code> </pre> <br>  Sekarang, mari sederhanakan semuanya dan panggil <code>enumeratorIsDone</code> hanya ketika ... semuanya benar-benar siap.  Dipandu oleh ide ini, kami menyederhanakan kode: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h3>  Jaga diri kita sendiri </h3><br>  Bagaimana dengan <code>Disposable</code> ?  Apa hubungannya dengan itu?  Karena <code>Disposable</code> adalah bagian <i>dari tipe</i> <code>Enumerator</code> , ketika kita mendapatkan <code>Enumerator</code> <i>double</i> , itu mungkin seharusnya tidak ada di <code>Enumerator</code> .  Sebaliknya, itu harus menjadi bagian dari <code>DualOfEnumerable</code> .  Tapi dimana tepatnya? <br><br>  <code>DualOfEnumerator</code> sini: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span></code> </pre> <br>  Jika kami menerima <code>DualOfEnumerator</code> , <code>DualOfEnumerator</code> seharusnya <code>Disposable</code> <i>dikembalikan</i> ? <br><br>  Inilah jenis ganda yang Anda dapatkan: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Sebut saja bunga mawar, meski tidak </h2><br>  Jadi, sekali lagi, inilah yang kami dapat: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  Mari kita bermain sedikit dengan namanya sekarang. <br><br>  Mari kita mulai dengan <code>DualOfEnumerator</code> .  Kami akan datang dengan nama yang lebih baik untuk fungsi untuk lebih akurat menggambarkan apa yang terjadi: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  Jauh lebih baik dan lebih bisa dimengerti. <br><br>  Bagaimana dengan mengetikkan nama?  Mereka hanya mengerikan.  Mari kita ubah sedikit. <br><br><ul><li>  <code>DualOfEnumerator</code> - sesuatu yang mengikuti apa yang terjadi pada sekelompok objek linear.  Kita dapat mengatakan bahwa dia <i>mengamati</i> kelompok linier. <br></li><li>  <code>DualOfEnumerable</code> adalah subjek observasi.  Apa yang kami tonton.  Karena itu, bisa disebut <i>observable</i> . <br></li></ul><br>  Sekarang buat perubahan terakhir dan dapatkan yang berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observer)</span></span></span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Wow </h2><br>  Kami baru saja membuat dua objek mendasar di RxSwift.  Anda dapat melihat versi aslinya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Perhatikan bahwa dalam kasus Observer, fungsi tiga <code>on()</code> digabungkan menjadi satu <code>on(Event)</code> , di mana <code>Event</code> adalah enumerasi yang menentukan apa acara - penyelesaian, nilai berikutnya atau kesalahan. <br><br>  Kedua jenis ini mendasari pemrograman RxSwift dan reaktif. <br><br><h2>  Tentang protokol palsu </h2><br>  Dua protokol "palsu" yang saya sebutkan di atas sebenarnya tidak palsu sama sekali.  Ini adalah analog dari tipe yang ada di Swift: <br><br><ul><li>  Enumerable adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sequence</a> <br></li><li>  Enumerator adalah Urutan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iterator</a> <br></li></ul><br><h2>  Jadi apa </h2><br>  Jadi apa yang harus dikhawatirkan? <br><br>  Begitu banyak dalam perkembangan modern - <i>terutama</i> pengembangan aplikasi - dikaitkan dengan asinkron.  Pengguna tiba-tiba mengklik tombol.  Pengguna tiba-tiba memilih tab di UISegmentControl.  Pengguna tiba-tiba memilih tab di UITabBar.  Soket web tiba-tiba memberi kami informasi baru.  Unduhan ini tiba-tiba - dan akhirnya - berakhir.  Tugas latar belakang ini berakhir dengan tiba-tiba.  Daftar ini terus berlanjut. <br><br>  Di dunia CocoaTouch modern, ada banyak cara untuk menangani acara seperti ini: <br><br><ul><li>  pemberitahuan <br></li><li>  panggilan balik <br></li><li>  Pengamatan Nilai-Kunci (KVO), <br></li><li>  target / mekanisme aksi. <br></li></ul><br>  Bayangkan jika <i>semuanya</i> bisa direfleksikan dalam satu antarmuka tunggal.  Yang bisa bekerja dengan <i>segala</i> jenis data atau peristiwa asinkron dalam seluruh aplikasi. <br><br>  Sekarang bayangkan jika akan ada seluruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rangkaian fungsi</a> yang memungkinkan Anda untuk memodifikasi <i>aliran</i> ini, mengubahnya dari satu jenis ke yang lain, mengekstrak informasi dari Elemen, atau bahkan menggabungkannya dengan aliran lain. <br><br>  Tiba-tiba, di tangan kita adalah seperangkat alat <i>universal</i> baru. <br>  Jadi, kami kembali ke awal: <br><br><blockquote>  API untuk pemrograman asinkron dengan utas yang dapat diamati. </blockquote><br>  Inilah yang membuat RxSwift alat yang ampuh.  Seperti Combine. <br><br><h2>  Apa selanjutnya </h2><br>  Jika Anda ingin membaca lebih lanjut tentang RxSwift <i>dalam praktek</i> , maka saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lima artikel saya yang ditulis pada tahun 2016</a> .  Mereka menggambarkan pembuatan aplikasi CocoaTouch sederhana, diikuti oleh konversi bertahap ke RxSwift. <br><br>  Dalam salah satu artikel berikut ini saya akan menjelaskan mengapa banyak teknik yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seri artikel</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk pemula</a> tidak berlaku di Combine, dan saya juga membandingkan Combine dengan RxSwift. <br><br><h1>  Combine: apa gunanya? </h1><br>  Diskusi Combine juga mencakup diskusi tentang perbedaan utama antara itu dan RxSwift.  Bagi saya ada tiga dari mereka: <br><br><ul><li>  kemungkinan menggunakan kelas non-reaktif, <br></li><li>  penanganan kesalahan <br></li><li>  tekanan balik. <br></li></ul><br>  Saya akan mencurahkan artikel terpisah untuk setiap item.  Saya akan mulai dengan yang pertama. <br><br><h2>  Fitur dari RxCocoa </h2><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting sebelumnya,</a> saya mengatakan bahwa RxSwift lebih dari ... RxSwift.  Ini memberikan banyak kemungkinan untuk menggunakan kontrol dari UIKit dalam sub-jenis-tapi-tidak-cukup dari RxCocoa.  Selain itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komunitas RxSwift</a> melangkah lebih jauh dan menerapkan banyak ikatan untuk jalan-jalan terpencil UIKit yang lebih terpencil, serta beberapa kelas CocoaTouch lain yang belum dicakup oleh RxSwift dan RxCocoa. <br><br>  Oleh karena itu, sangat mudah untuk mendapatkan aliran yang Dapat <code>Observable</code> dari, katakanlah, mengklik UIButton.  Saya akan memberikan contoh ini lagi: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Ringan <br><br><h2>  Mari (akhirnya) tetap membicarakan Combine </h2><br>  Combine sangat mirip dengan RxSwift.  Seperti yang dikatakan dalam dokumentasi: <br><br><blockquote>  Kerangka kerja Combine menyediakan Swift API deklaratif untuk menangani nilai dari waktu ke waktu. </blockquote><br>  Kedengarannya familier: ingat deskripsi ReactiveX (proyek induk untuk RxSwift): <br><br><blockquote>  API untuk pemrograman asinkron dengan utas yang dapat diamati. </blockquote><br>  Dalam kedua kasus, hal yang sama dikatakan.  Hanya saja istilah spesifik digunakan dalam deskripsi ReactiveX.  Itu dapat dirumuskan kembali sebagai berikut: <br><br><blockquote>  API untuk pemrograman asinkron dengan nilai dari waktu ke waktu. </blockquote><br>  Hampir sama dengan saya. <br><br><h2>  Sama seperti sebelumnya </h2><br>  Ketika saya mulai menganalisis API, segera menjadi jelas bahwa sebagian besar tipe yang saya tahu dari RxSwift memiliki opsi serupa di Combine: <br><br><ul><li>  Dapat diobservasi ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerbit</a> <br></li><li>  Pengamat ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelanggan</a> <br></li><li>  Sekali pakai ‚Üí Dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibatalkan</a> .  Ini adalah kemenangan pemasaran.  Anda tidak bisa membayangkan berapa banyak penampilan terkejut yang saya terima dari pengembang yang lebih tidak memihak ketika saya mulai menggambarkan Disposable di RxSwift. <br></li><li>  SchedulerType ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scheduler</a> <br></li></ul><br>  Sejauh ini bagus.  Sekali lagi, saya suka Cancellable lebih dari Disposable.  Pengganti yang hebat, tidak hanya dalam hal pemasaran, tetapi juga dalam hal deskripsi yang akurat tentang esensi objek. <br><br>  Lebih banyak bahkan lebih baik! <br><br><ul><li>  RxCocoa's Driver -&gt; Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BindableObject</a> dari SwiftUI <br></li></ul><br>  Ini tidak segera jelas, tetapi secara rohani mereka melayani satu tujuan, dan tidak satu pun dari mereka dapat menimbulkan kesalahan. <br><br><ul><li>  Lajang ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masa Depan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subjek</a> Jenis ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subjek</a> <br></li><li>  PublishSubject ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PassthroughSubject</a> <br></li></ul><br><h2>  "Istirahat untuk kotoran" </h2><br>  Semuanya berubah segera setelah Anda mulai mempelajari RxCocoa.  Ingat contoh di atas, di mana kami ingin mendapatkan aliran yang Dapat Diobservasi yang mewakili klik pada UIButton?  Ini dia: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Combine membutuhkan ... lebih banyak pekerjaan untuk melakukan hal yang sama. <br><br>  <b>Combine tidak menyediakan kemampuan apa pun untuk mengikat ke objek UIKit.</b> <br><br>  Ini ... hanya gelandangan yang tidak nyata. <br><br>  Berikut adalah cara umum untuk mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UIControl.Event</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UIControl</a> menggunakan Combine: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlPublisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIControl</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> = (control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = <span class="hljs-type"><span class="hljs-type">PassthroughSubject</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Output</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">convenience</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: control, events: [event]) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, events: [<span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events { control.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(controlAction), <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: event) } } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">controlAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIControl, forEvent event: UIControl.Event)</span></span></span></span> { subject.send(<span class="hljs-type"><span class="hljs-type">ControlEvent</span></span>(control: sender, event: event)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { subject.receive(subscriber: subscriber) } }</code> </pre> <br>  Ini ... lebih <i>banyak</i> pekerjaan.  Setidaknya panggilannya terlihat seperti: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>(control: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button, event: .touchUpInside) .sink { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }</code> </pre> <br>  Sebagai perbandingan, RxCocoa memberikan kakao yang enak dan menyenangkan dalam bentuk ikatan ke benda-benda UIKit: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) })</code> </pre> <br>  Sendiri, tantangan-tantangan ini pada akhirnya benar-benar sangat mirip.  Satu-satunya hal yang membuat frustrasi adalah saya harus menulis <code>ControlPublisher</code> sendiri untuk sampai ke titik ini.  Selain itu, RxSwift dan RxCocoa telah diuji dengan sangat baik dan digunakan dalam proyek-proyek lebih dari tambang. <br><br>  Sebagai perbandingan, <code>ControlPublisher</code> saya hanya muncul ... sekarang.  Hanya karena jumlah klien (nol) dan waktu penggunaan di dunia nyata (hampir nol dibandingkan dengan RxCocoa) kode saya dianggap jauh lebih berbahaya. <br><br>  Nyebelin. <br><br><h2>  Bantuan komunitas? </h2><br>  Sejujurnya, tidak ada yang menghalangi komunitas untuk membuat open source sendiri "CombineCocoa", yang akan mengisi celah RxCocoa seperti yang dilakukan oleh RxSwiftCommunity. <br><br>  Namun, saya menganggap ini sebagai kelemahan besar Combine.  Saya tidak ingin menulis ulang seluruh RxCocoa, hanya untuk mendapatkan binding ke objek UIKit. <br><br>  Jika saya memutuskan untuk bertaruh pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SwiftUI</a> , maka saya kira ini akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghilangkan</a> masalah kurangnya binding.  Bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi kecil saya</a> berisi <i>banyak</i> kode UI.  Membuang semua ini hanya untuk melompat ke kereta Combine akan setidaknya bodoh, atau bahkan berbahaya. <br><br>  Ngomong-ngomong, artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Acara Penerima dan Penanganan dengan</i></a> dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Combine</i></a> secara singkat menjelaskan cara menerima dan memproses acara di Combine.  Pendahuluannya bagus, ini menunjukkan cara mengekstraksi nilai dari bidang teks dan menyimpannya dalam objek model kustom.  Dokumentasi juga menunjukkan penggunaan operator untuk melakukan beberapa modifikasi lebih lanjut ke aliran yang dimaksud. <br><br><h2>  Contoh </h2><br>  Mari kita lanjutkan ke bagian akhir dokumentasi, di mana contoh kode adalah: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { ($<span class="hljs-number"><span class="hljs-number">0</span></span>.object <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSTextField</span></span>).stringValue } ) .assign(to: \<span class="hljs-type"><span class="hljs-type">MyViewModel</span></span>.filterString, on: myViewModel)</code> </pre> <br>  Saya punya ... banyak masalah dengan ini. <br><br><h2>  Beri tahu Anda bahwa saya tidak menyukainya </h2><br>  Dua baris pertama menyebabkan saya paling banyak pertanyaan: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NotificationCenter</a> adalah sesuatu seperti bus aplikasi (atau bahkan bus sistem) di mana banyak orang dapat membuang data atau menangkap potongan informasi yang terbang.  Solusi ini dari kategori all-and-for-all, sebagaimana dimaksud oleh pembuatnya.  Dan memang ada banyak situasi di mana Anda mungkin perlu mencari tahu, katakanlah, keyboard baru saja ditampilkan atau disembunyikan.  NotificationCenter adalah cara terbaik untuk mendistribusikan pesan ini ke seluruh sistem. <br><br>  Tetapi bagi saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NotificationCenter</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode dengan choke</a> .  Ada saatnya (seperti mendapatkan notifikasi tentang keyboard) ketika NotificationCenter sebenarnya merupakan solusi <i>terbaik</i> untuk masalah tersebut.  Tetapi terlalu sering bagi saya NotificationCenter adalah solusi <i>paling nyaman</i> .  Benar-benar sangat nyaman untuk menjatuhkan sesuatu di NotificationCenter dan mengambilnya di tempat lain dalam aplikasi. <br><br>  Selain itu, NotificationCenter adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"string" -typed</a> , yaitu, Anda dapat dengan mudah membuat kesalahan dengan pemberitahuan yang Anda coba terbitkan atau dengarkan.  Swift melakukan segala yang mungkin untuk memperbaiki situasi, tetapi NSString yang sama masih ada di bawah kap. <br><br><h2>  Tentang KVO </h2><br>  Di platform Apple, sudah ada cara populer untuk menerima pemberitahuan perubahan di berbagai bagian kode: observasi nilai kunci (KVO).  Apple menggambarkannya seperti ini: <br><br><blockquote>  Ini adalah mekanisme yang memungkinkan objek menerima pemberitahuan perubahan pada properti yang ditentukan dari objek lain. </blockquote><br>  Berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tweet Gui Rambo,</a> saya perhatikan bahwa Apple menambahkan binding KVO ke Combine.  Ini bisa berarti bahwa saya bisa menghilangkan banyak kekecewaan tentang kurangnya analog RxCocoa di Combine.  Jika saya dapat menggunakan KVO, ini mungkin akan menghilangkan kebutuhan untuk CombineCocoa, jadi untuk berbicara. <br><br>  Saya mencoba mencari tahu contoh menggunakan KVO untuk mendapatkan nilai dari <code>UITextField</code> dan output ke konsol: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textField.publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \<span class="hljs-type"><span class="hljs-type">UITextField</span></span>.text) .sink(receiveCompletion: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) }, receiveValue: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Text field is currently \"\($0)\""</span></span>) })</code> </pre> <br>  Terlihat bagus, teruskan? <br><br>  Tidak secepat itu, teman. <br><br>  Saya lupa tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebenaran yang tidak nyaman</a> : <br><br>  UIKit, pada umumnya, tidak kompatibel dengan KVO. <br><br>  Dan tanpa dukungan KVO, ide saya tidak akan berfungsi.  Cek saya mengkonfirmasi ini: kode tidak menampilkan apa pun ke konsol ketika saya memasukkan teks di bidang. <br><br>  Jadi, harapan saya untuk menyingkirkan kebutuhan ikatan UIKit itu indah, tapi tidak lama. <br><br><h2>  Membersihkan </h2><br>  Masalah Combine yang lain adalah masih sepenuhnya tidak jelas di mana dan bagaimana membebaskan sumber daya dalam objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cancellable</a> .  <i>Tampaknya</i> kita harus menyimpannya dalam variabel instan.  Tapi saya tidak ingat bahwa dalam dokumentasi resmi ada sesuatu yang dikatakan tentang pembersihan. <br><br>  RxSwift memiliki DisposeBag yang sangat bernama tapi sangat nyaman.  Tidak mudah untuk membuat CancelBag di Combine, tetapi saya tidak yakin bahwa dalam hal ini ini adalah solusi terbaik. <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel selanjutnya</a> kita akan berbicara tentang penanganan kesalahan dalam RxSwift dan Combine, tentang kelebihan dan kekurangan dari kedua pendekatan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470117/">https://habr.com/ru/post/id470117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470103/index.html">Membuat game clicker sederhana dari awal</a></li>
<li><a href="../id470105/index.html">Sense Data oktech # 3: Sistem Rekomendasi</a></li>
<li><a href="../id470107/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, September 2019</a></li>
<li><a href="../id470109/index.html">@Pythonetc September 2019</a></li>
<li><a href="../id470113/index.html">Bagaimana teknologi di dalam memori telah mengubah kecerdasan bisnis</a></li>
<li><a href="../id470121/index.html">Perusahaan sekolah pemrograman atau cara memasukkan TI</a></li>
<li><a href="../id470123/index.html">Perangkap keuangan Yandex.Money</a></li>
<li><a href="../id470125/index.html">Jangan menilai kode orang lain dengan ketat</a></li>
<li><a href="../id470127/index.html">Komposer dengan memori jangka pendek yang panjang</a></li>
<li><a href="../id470129/index.html">Manajemen memori deklaratif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>