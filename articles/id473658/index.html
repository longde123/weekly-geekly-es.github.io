<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§π üë©üèª‚Äçüç≥ üë®‚Äçüë¶ Menangani bug di Go 1.13 üçó üë®‚Äçüë®‚Äçüëß‚Äçüëß üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama dekade terakhir, kami telah berhasil mengeksploitasi fakta bahwa Go menangani kesalahan sebagai nilai . Meskipun pustaka standar memiliki dukun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menangani bug di Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  Selama dekade terakhir, kami telah berhasil mengeksploitasi fakta bahwa Go menangani <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan sebagai nilai</a> .  Meskipun pustaka standar memiliki dukungan minimal untuk kesalahan: hanya kesalahan. <code>errors.New</code> dan <code>fmt.Errorf</code> yang menghasilkan kesalahan yang hanya mengandung pesan - antarmuka <code>fmt.Errorf</code> memungkinkan programmer untuk menambahkan informasi apa pun.  Yang Anda butuhkan adalah tipe yang mengimplementasikan metode <code>Error</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Jenis kesalahan ini ditemukan dalam semua bahasa dan menyimpan berbagai informasi, dari cap waktu hingga nama file dan alamat server.  Kesalahan tingkat rendah yang menyediakan konteks tambahan sering disebutkan. <br><br>  Pola, ketika satu kesalahan mengandung yang lain, sangat sering ditemui di Go sehingga setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi yang hangat</a> di Go 1.13 dukungan eksplisitnya ditambahkan.  Pada artikel ini, kita akan melihat penambahan ke pustaka standar yang menyediakan dukungan yang disebutkan: tiga fungsi baru dalam paket kesalahan dan perintah pemformatan baru untuk <code>fmt.Errorf</code> . <br><br>  Sebelum membahas perubahan secara rinci, mari kita bicara tentang bagaimana kesalahan diselidiki dan dibuat dalam versi bahasa sebelumnya. <br><br><h1>  Kesalahan sebelum Go 1.13 </h1><br><h4>  Penelitian galat </h4><br>  Kesalahan dalam Go adalah artinya.  Program membuat keputusan berdasarkan nilai-nilai ini dengan cara yang berbeda.  Paling sering, kesalahan dibandingkan dengan nol untuk melihat apakah operasi gagal. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  Terkadang kami membandingkan kesalahan untuk mengetahui nilai <i>kontrol</i> dan melihat apakah ada kesalahan tertentu. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  Nilai kesalahan bisa dari jenis apa pun yang memenuhi antarmuka kesalahan yang ditentukan dalam bahasa.  Suatu program dapat menggunakan pernyataan tipe atau saklar tipe untuk melihat nilai kesalahan dari tipe yang lebih spesifik. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Menambahkan Informasi </h4><br>  Seringkali suatu fungsi melewatkan kesalahan di tumpukan panggilan, menambahkan informasi ke dalamnya, misalnya, deskripsi singkat tentang apa yang terjadi ketika kesalahan terjadi.  Ini mudah dilakukan, cukup buat kesalahan baru yang menyertakan teks dari kesalahan sebelumnya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Saat membuat kesalahan baru menggunakan <code>fmt.Errorf</code> kami membuang semuanya kecuali teks dari kesalahan asli.  Seperti yang kita lihat dalam contoh <code>QueryError</code> , kadang-kadang Anda perlu mendefinisikan jenis kesalahan baru yang berisi kesalahan asli untuk menyimpannya untuk analisis menggunakan kode: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Program dapat melihat di dalam nilai <code>*QueryError</code> dan membuat keputusan berdasarkan kesalahan asli.  Ini kadang-kadang disebut pembatalan kesalahan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Jenis <code>os.PathError</code> dari pustaka standar adalah contoh lain tentang bagaimana satu kesalahan berisi yang lain. <br><br><h1>  Kesalahan dalam Go 1.13 </h1><br><h4>  Membuka Metode </h4><br>  Dalam Go 1.13, paket standar pustaka <code>errors</code> dan <code>fmt</code> menyederhanakan <code>fmt</code> kesalahan yang berisi kesalahan lain.  Yang paling penting adalah konvensi, bukan perubahan: kesalahan yang mengandung kesalahan lain dapat menerapkan metode <code>Unwrap</code> , yang mengembalikan kesalahan asli.  Jika <code>e1.Unwrap()</code> mengembalikan <code>e2</code> , maka kita mengatakan bahwa <i>paket</i> <code>e1</code> <code>e2</code> dan Anda dapat <i>membongkar paket</i> <code>e1</code> untuk mendapatkan <code>e2</code> . <br><br>  Menurut konvensi ini, Anda bisa memberikan tipe <code>QueryError</code> dijelaskan di atas ke metode <code>QueryError</code> , yang mengembalikan kesalahan yang terkandung di dalamnya: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  Hasil membongkar kesalahan juga dapat berisi metode <code>Unwrap</code> .  Urutan kesalahan yang diperoleh melalui pembongkaran berulang, kami sebut <i>rantai kesalahan</i> . <br><br><h4>  Investigasi kesalahan dengan Is dan As </h4><br>  Di Go 1.13, paket <code>errors</code> berisi dua fungsi baru untuk menyelidiki kesalahan: <code>Is</code> dan <code>As</code> . <br><br>  Kesalahan. Fungsi membandingkan kesalahan dengan nilai. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { ‚Ä¶ } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  Fungsi <code>As</code> memeriksa apakah kesalahan berasal dari tipe tertentu. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { ‚Ä¶ } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  Dalam kasus paling sederhana, fungsi <code>errors.Is</code> berperilaku seperti perbandingan dengan kesalahan kontrol, dan fungsi <code>errors.As</code> berfungsi seperti pernyataan tipe.  Namun, ketika bekerja dengan kesalahan yang dikemas, fungsi-fungsi ini mengevaluasi semua kesalahan dalam rantai.  Mari kita lihat contoh <code>QueryError</code> atas untuk memeriksa kesalahan asli: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Menggunakan fungsi <code>errors.Is</code> . Apakah <code>errors.Is</code> dapat menulis ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  Paket <code>errors</code> juga berisi fungsi <code>Unwrap</code> baru yang mengembalikan hasil memanggil metode <code>Unwrap</code> kesalahan, atau mengembalikan nol jika kesalahan tidak memiliki metode <code>Unwrap</code> .  Biasanya lebih baik menggunakan <code>errors.Is</code> atau salah. Karena, karena mereka memungkinkan Anda untuk memeriksa seluruh rantai dalam satu panggilan. <br><br><h4>  Kemasan galat dengan% w </h4><br>  Seperti yang saya sebutkan, itu adalah praktik normal untuk menggunakan fungsi <code>fmt.Errorf</code> untuk menambahkan informasi tambahan ke kesalahan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Di Go 1.13, fungsi <code>fmt.Errorf</code> mendukung perintah <code>%w</code> baru.  Jika ya, maka kesalahan yang dikembalikan oleh <code>fmt.Errorf</code> akan berisi metode <code>Unwrap</code> yang mengembalikan argumen <code>%w</code> , yang seharusnya merupakan kesalahan.  Dalam semua kasus lain, <code>%w</code> identik dengan <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  Packing kesalahan dengan <code>%w</code> membuatnya tersedia untuk <code>errors.Is</code> dan <code>errors.As</code> : <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  Kapan harus berkemas? </h4><br>  Ketika Anda menambahkan konteks tambahan untuk kesalahan menggunakan <code>fmt.Errorf</code> atau implementasi jenis kustom, Anda perlu memutuskan apakah kesalahan baru akan berisi yang asli.  Tidak ada jawaban tunggal untuk ini, semuanya tergantung pada konteks di mana kesalahan baru dibuat.  Paket untuk menunjukkan peneleponnya.  Jangan mengemas kesalahan jika ini menyebabkan pengungkapan rincian implementasi. <br><br>  Misalnya, bayangkan fungsi <code>Parse</code> yang membaca struktur data yang kompleks dari <code>io.Reader</code> .  Jika terjadi kesalahan, kami ingin mengetahui jumlah baris dan kolom tempat terjadinya.  Jika terjadi kesalahan saat membaca dari <code>io.Reader</code> , kita harus mengemasnya untuk mengetahui alasannya.  Karena penelepon disediakan dengan fungsi <code>io.Reader</code> , masuk akal untuk menunjukkan kesalahan yang dihasilkannya. <br><br>  Kasus lain: fungsi yang membuat beberapa panggilan basis data mungkin tidak boleh mengembalikan kesalahan di mana hasil dari salah satu panggilan ini dikemas.  Jika database yang digunakan oleh fungsi ini adalah bagian dari implementasi, maka mengungkapkan kesalahan ini akan melanggar abstraksi.  Misalnya, jika fungsi <code>LookupUser</code> dari paket <code>pkg</code> menggunakan paket Go <code>database/sql</code> , maka itu mungkin mengalami kesalahan <code>sql.ErrNoRows</code> .  Jika Anda mengembalikan kesalahan menggunakan <code>fmt.Errorf("accessing DB: %v", err)</code> , maka pemanggil tidak dapat melihat ke dalam dan menemukan <code>sql.ErrNoRows</code> .  Tetapi jika fungsi mengembalikan <code>fmt.Errorf("accessing DB: %w", err)</code> , maka pemanggil dapat menulis: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) ‚Ä¶</code> </pre> <br>  Dalam hal ini, fungsi tersebut harus selalu mengembalikan <code>sql.ErrNoRows</code> jika Anda tidak ingin memecah klien, bahkan ketika beralih ke paket dengan database yang berbeda.  Dengan kata lain, pengemasan membuat kesalahan bagian dari API Anda.  Jika Anda tidak ingin melakukan dukungan untuk kesalahan ini di masa mendatang sebagai bagian dari API, jangan mengemasnya. <br><br>  Penting untuk diingat bahwa terlepas dari apakah Anda mengemasnya atau tidak, kesalahannya akan tetap tidak berubah.  <i>Seseorang</i> yang akan memahaminya akan memiliki informasi yang sama.  Membuat keputusan tentang pengemasan tergantung pada apakah informasi tambahan diperlukan untuk <i>program</i> sehingga mereka dapat membuat keputusan yang lebih tepat;  atau jika Anda ingin menyembunyikan informasi ini untuk mempertahankan tingkat abstraksi. <br><br><h4>  Menyiapkan Pengujian Kesalahan Menggunakan Metode Is dan As </h4><br>  Kesalahan. Fungsi memeriksa setiap kesalahan dalam rantai terhadap nilai target.  Secara default, kesalahan cocok dengan nilai ini jika mereka setara.  Selain itu, kesalahan dalam rantai dapat menyatakan kepatuhannya dengan nilai target menggunakan penerapan <i>metode</i> <code>Is</code> . <br><br>  Pertimbangkan kesalahan yang disebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh paket Upspin</a> , yang membandingkan kesalahan dengan templat dan hanya mengevaluasi bidang yang bukan nol: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  Fungsi <code>errors.As</code> <code>As</code> juga menyarankan metode <code>As</code> , jika ada. <br><br><h4>  API Kesalahan dan Paket </h4><br>  Paket yang mengembalikan kesalahan (dan sebagian besar paket melakukan ini) harus menjelaskan sifat-sifat kesalahan ini yang dapat diandalkan oleh seorang programmer.  Paket yang dirancang dengan baik juga akan menghindari pengembalian kesalahan dengan properti yang tidak dapat diandalkan. <br><br>  Yang paling sederhana adalah mengatakan apakah operasi itu berhasil, mengembalikan, masing-masing, nilai nihil atau non-nihil.  Dalam banyak kasus, tidak ada informasi lain yang diperlukan. <br><br>  Jika Anda membutuhkan fungsi untuk mengembalikan status kesalahan yang dapat diidentifikasi, misalnya, "elemen tidak ditemukan", maka Anda dapat mengembalikan kesalahan di mana nilai sinyal dikemas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Ada pola-pola lain untuk menyediakan kesalahan yang bisa diperiksa pemanggil secara semantik.  Misalnya, secara langsung mengembalikan nilai kontrol, tipe tertentu, atau nilai yang dapat dianalisis menggunakan fungsi predikatif. <br><br>  Dalam hal apa pun, jangan mengungkapkan detail internal kepada pengguna.  Seperti yang disebutkan dalam bab "Kapan kemasannya layak?", Jika Anda mengembalikan kesalahan dari paket lain, maka konversikannya agar tidak mengungkapkan kesalahan asli, kecuali jika Anda bermaksud berkomitmen untuk mengembalikan kesalahan spesifik ini di masa mendatang. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Jika suatu fungsi mengembalikan kesalahan dengan nilai atau tipe sinyal yang dikemas, maka jangan langsung mengembalikan kesalahan semula. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { ‚Ä¶ } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Kesimpulan </h4><br>  Meskipun kami hanya membahas tiga fungsi dan perintah pemformatan, kami berharap bahwa mereka akan sangat membantu meningkatkan penanganan kesalahan dalam program Go.  Kami berharap bahwa pengemasan demi menyediakan konteks tambahan akan menjadi praktik yang normal, membantu programmer membuat keputusan yang lebih baik dan menemukan bug lebih cepat. <br><br>  Seperti yang dikatakan Russ Cox dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pidatonya di GopherCon 2019</a> , dalam perjalanan ke Go 2 kami bereksperimen, menyederhanakan, dan mengirim.  Dan sekarang, setelah mengirimkan perubahan ini, kami membuat percobaan baru. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473658/">https://habr.com/ru/post/id473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473646/index.html">Hackathon di sebuah perusahaan kecil: cara mengatur tanpa membuang kereta sumber daya</a></li>
<li><a href="../id473648/index.html">Kuda itu mati - menangis: transisi dari tslint ke eslint</a></li>
<li><a href="../id473652/index.html">Membuat API REST dengan Node.js dan Oracle Database. Bagian 5</a></li>
<li><a href="../id473654/index.html">PHP Composer: Perbaiki dependensi tanpa rasa sakit</a></li>
<li><a href="../id473656/index.html">Hugo Static Site Generator Experience</a></li>
<li><a href="../id473660/index.html">Arcade Reverse Engineering: Rekam Michael Jordan di NBA Jam</a></li>
<li><a href="../id473664/index.html">Pengalaman belajar langsung. Yandex.Practicum - Analis Data</a></li>
<li><a href="../id473666/index.html">Sebagai penulis fiksi ilmiah, Arthur Clark hampir menutup jurnal Tech - Youth</a></li>
<li><a href="../id473668/index.html">Mengapa Bitrix - Bitrix</a></li>
<li><a href="../id473670/index.html">Stoloto: cara memperkenalkan ponsel ke lotre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>