<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎞️ 🤟🏻 💇🏿 تحسين أداء Zabbix + PostgreSQL مع التقسيم والفهرسة 👩🏾‍🤝‍👨🏽 💿 👌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="منذ حوالي عام ، كلفنا أنا وزملائي بالفرز باستخدام نظام مراقبة البنية التحتية للشبكة الشهير - Zabbix. بعد دراسة الوثائق ، شرعنا فورًا في تحميل الاختبار...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تحسين أداء Zabbix + PostgreSQL مع التقسيم والفهرسة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468463/" style=";text-align:right;direction:rtl"> منذ حوالي عام ، كلفنا أنا وزملائي بالفرز باستخدام نظام مراقبة البنية التحتية للشبكة الشهير - Zabbix.  بعد دراسة الوثائق ، شرعنا فورًا في تحميل الاختبار: لقد أردنا تقييم عدد المعلمات التي يمكن أن تعمل Zabbix دون حدوث انخفاض ملحوظ في الأداء.  تم استخدام PostgreSQL فقط كـ DBMS. <br><br>  أثناء الاختبارات ، تم تحديد بعض السمات المعمارية لتخطيط قاعدة البيانات وسلوك نظام المراقبة نفسه ، والتي لا تسمح لنظام المراقبة بالوصول إلى الحد الأقصى من طاقته افتراضيًا.  نتيجة لذلك ، تم تطوير بعض تدابير التحسين وإجرائها واختبارها بشكل أساسي من حيث ضبط قاعدة البيانات. <br><br>  أريد أن أشارك نتائج العمل المنجز في هذه المقالة.  ستكون هذه المقالة مفيدة لكلا مسؤولي Zabbix و PostgreSQL DBA ، وكذلك لكل من يريد فهم وفهم PosgreSQL DBMS الشعبي بشكل أفضل. <br><br>  مفسد صغير: على جهاز ضعيف مع حمولة 200 ألف معلمة في الدقيقة ، تمكنا من تقليل وحدة المعالجة المركزية iowait من 20 ٪ إلى 2 ٪ ، وتقليل وقت التسجيل في أجزاء لجداول البيانات الأولية بنسبة 250 مرة ، وجداول البيانات المجمعة بنسبة 32 مرة ، والحد من حجم الفهارس 5-10 مرات وتسريع استلام العينات التاريخية في بعض الحالات حتى 18 مرة. <br><a name="habracut"></a><br><h4 style=";text-align:right;direction:rtl">  اختبار الحمل </h4><br>  تم إجراء اختبار الحمل وفقًا للمخطط: خادم Zabbix واحد ، وكيل Zabbix نشط ، وكيلان.  تم تكوين كل عامل لإعطاء 50 طنًا من الأعداد الصحيحة و 50 طنًا من معلمات السلسلة في الدقيقة (أي ما مجموعه 200 طن من المعلمات في الدقيقة أو 3333 معلمة في الثانية).  لإنشاء معلمات عامل ، استخدمنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مكونًا إضافيًا لبرنامج Zabbix ،</a> وللتحقق من عدد المعلمات التي يمكن أن ينشئها الوكيل ، تحتاج إلى استخدام برنامج <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نصي خاص من نفس مؤلف المكون الإضافي zabbix_module_stress</a> .  يواجه مسؤول الويب من Zabbix صعوبات في تسجيل القوالب الكبيرة ، لذلك قمنا بتقسيم المعلمات إلى 20 قالبًا مع 5 أطنان من المعلمات (2500 سلسلة رقمية و 2500 سلسلة). <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">قالب مولد النصي لاختبار الحمل في الثعبان</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-string"><span class="hljs-string">"""     .   20   5000    ( 2500  :  echo,  ;  ping,  ) """</span></span> TEMP_HEAD = <span class="hljs-string"><span class="hljs-string">""" &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;zabbix_export&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;date&gt;2015-08-17T23:15:01Z&lt;/date&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;templates&gt; &lt;template&gt; &lt;template&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/template&gt; &lt;name&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/name&gt; &lt;description/&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;applications/&gt; &lt;items&gt; """</span></span> TEMP_END = <span class="hljs-string"><span class="hljs-string">"""&lt;/items&gt; &lt;discovery_rules/&gt; &lt;macros/&gt; &lt;templates/&gt; &lt;screens/&gt; &lt;/template&gt; &lt;/templates&gt; &lt;/zabbix_export&gt; """</span></span> TEMP_ITEM = <span class="hljs-string"><span class="hljs-string">"""&lt;item&gt; &lt;name&gt;{k}&lt;/name&gt; &lt;type&gt;0&lt;/type&gt; &lt;snmp_community/&gt; &lt;multiplier&gt;0&lt;/multiplier&gt; &lt;snmp_oid/&gt; &lt;key&gt;{k}&lt;/key&gt; &lt;delay&gt;1m&lt;/delay&gt; &lt;history&gt;3&lt;/history&gt; &lt;trends&gt;365&lt;/trends&gt; &lt;status&gt;0&lt;/status&gt; &lt;value_type&gt;{t}&lt;/value_type&gt; &lt;allowed_hosts/&gt; &lt;units/&gt; &lt;delta&gt;0&lt;/delta&gt; &lt;snmpv3_contextname/&gt; &lt;snmpv3_securityname/&gt; &lt;snmpv3_securitylevel&gt;0&lt;/snmpv3_securitylevel&gt; &lt;snmpv3_authprotocol&gt;0&lt;/snmpv3_authprotocol&gt; &lt;snmpv3_authpassphrase/&gt; &lt;snmpv3_privprotocol&gt;0&lt;/snmpv3_privprotocol&gt; &lt;snmpv3_privpassphrase/&gt; &lt;formula&gt;1&lt;/formula&gt; &lt;delay_flex/&gt; &lt;params/&gt; &lt;ipmi_sensor/&gt; &lt;data_type&gt;0&lt;/data_type&gt; &lt;authtype&gt;0&lt;/authtype&gt; &lt;username/&gt; &lt;password/&gt; &lt;publickey/&gt; &lt;privatekey/&gt; &lt;port/&gt; &lt;description/&gt; &lt;inventory_link&gt;0&lt;/inventory_link&gt; &lt;applications/&gt; &lt;valuemap/&gt; &lt;logtimefmt/&gt; &lt;/item&gt; """</span></span> TMP_FNAME_DEFAULT = <span class="hljs-string"><span class="hljs-string">"Template_App_Zabbix_Server_Stress_{count}_passive_{char}.xml"</span></span> chars = <span class="hljs-string"><span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: parser = argparse.ArgumentParser( description=<span class="hljs-string"><span class="hljs-string">'     zabbix'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--items'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'items'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1000</span></span>, help=<span class="hljs-string"><span class="hljs-string">'-   (default: 1000)'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--templates'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'templates'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1</span></span>, help=<span class="hljs-string"><span class="hljs-string">f'-  [1-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">] (default: 1)'</span></span>) args = parser.parse_args() items_count = args.items tmps_count = args.templates <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (tmps_count &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tmps_count &lt;= len(chars)): sys.exit(<span class="hljs-string"><span class="hljs-string">f"Templates must be in range 1 - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(tmps_count): fname = TMP_FNAME_DEFAULT.format(count=items_count, char=chars[i]) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(fname, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> output: output.write(TEMP_HEAD.format(count=items_count, char=chars[i])) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [(<span class="hljs-string"><span class="hljs-string">'stress.ping[{}-I-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-string"><span class="hljs-string">'stress.echo[{}-S-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)]: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(items_count/<span class="hljs-number"><span class="hljs-number">2</span></span>)): output.write(TEMP_ITEM.format(k=k.format(chars[i],j),t=t)) output.write(TEMP_END)</code> </pre> <br></div></div><br>  يعد قياس وحدة المعالجة المركزية iostat مؤشرًا جيدًا على أداء Zabbix - فهو يعكس جزء وحدة الوقت الذي ينتظر المعالج من خلاله الوصول إلى القرص.  كلما زاد ارتفاعه ، زاد احتلال القرص لعمليات القراءة والكتابة ، مما يؤثر بشكل غير مباشر على تدهور أداء نظام المراقبة ككل.  أي  هذه علامة أكيدة على وجود خطأ ما في المراقبة.  بالمناسبة ، في المساحات المفتوحة للشبكة ، السؤال الأكثر شيوعًا هو "كيفية إزالة مشغل iostat في Zabbix" ، لذلك هذه نقطة حساسة ، لأن هناك العديد من الأسباب لزيادة قيمة مقياس iowait. <br><br>  إليكم صورة مقياس وحدة المعالجة المركزية iowait الذي حصلنا عليه في البداية بعد ثلاثة أيام: <br><br><img src="https://habrastorage.org/webt/dc/md/yo/dcmdyote_ghzxca-o9sft88ptxq.png"><br><br>  ولكن ما هي الصورة لنفس المقياس الذي حصلنا عليه أيضًا في غضون ثلاثة أيام في النهاية بعد كل إجراءات التحسين التي تم تنفيذها ، والتي سيتم مناقشتها أدناه: <br><br><img src="https://habrastorage.org/webt/do/cs/fc/docsfcjjczkhgxoubjayslrohuw.png"><br><br>  كما يتضح من الرسوم البيانية ، انخفض مؤشر وحدة المعالجة المركزية iowait من ما يقرب من 20 ٪ إلى 2 ٪ ، مما سرع بشكل غير مباشر في وقت التنفيذ لجميع طلبات إضافة وقراءة البيانات.  الآن دعنا نرى لماذا ، مع إعدادات قاعدة البيانات القياسية ، ينخفض ​​الأداء العام لنظام المراقبة وكيفية إصلاحه. <br><br><h4 style=";text-align:right;direction:rtl">  أسباب انخفاض الأداء Zabbix </h4><br>  مع تراكم أكثر من 10 ملايين قيمة معلمة في كل جدول من البيانات الأولية ، لوحظ أن أداء نظام المراقبة ينخفض ​​بشكل حاد ، وذلك للأسباب التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم زيادة قياس iowait لوحدة المعالجة المركزية للخادم بأكثر من 20٪ ، مما يشير إلى زيادة في الوقت الذي تتوقع فيه وحدة المعالجة المركزية الوصول إلى عمليات القراءة والكتابة على القرص </li><li style=";text-align:right;direction:rtl">  فهارس الجداول التي يتم فيها تضخيم بيانات المراقبة إلى حد كبير </li><li style=";text-align:right;direction:rtl">  زيادة قياس الاستخدام إلى 100٪ للقرص الذي يحتوي على بيانات المراقبة ، مما يشير إلى الحمل الكامل للقرص مع عمليات القراءة والكتابة </li><li style=";text-align:right;direction:rtl">  لا تملك القيم القديمة وقتًا يجب حذفه من جداول المحفوظات عند التنظيف وفقًا لجدول مدبرة المنزل </li></ul><br>  يتفاقم الموقف في بداية كل ساعة ، عندما تحسب بالإضافة إلى ذلك ، إحصائيات كل ساعة مجمعة - أثناء قراءة وكتابة صفحات الفهرس من القرص ، وحذف البيانات القديمة من السجل ، مما يؤدي إلى نفس النتيجة - انخفاض في أداء قاعدة البيانات وزيادة وقت التنفيذ طلبات (في الحد ، تم تسجيل طلب يدوم حتى 5 دقائق!). <br><br>  القليل من المساعدة في تنظيم مستودع بيانات الرصد في Zabbix.  إنه يخزن البيانات الأولية والبيانات المجمعة في جداول مختلفة ، علاوة على ذلك ، مع فصل أنواع المعلمات.  يخزن كل جدول حقل itemid (مرجع ضمني لعنصر بيانات مسجّل في النظام) ، طابع زمني لتسجيل قيمة الساعة بتنسيق الطابع الزمني لليونيكس (مللي ثانية في عمود منفصل) وقيمة في عمود منفصل (الاستثناء هو جدول السجل ، يحتوي على المزيد من الحقول - يشبه سجل الأحداث ): <br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><th>  اسم الجدول </th><th>  موعد </th><th>  نوع البيانات </th></tr><tr><td>  تاريخ </td><td>  رصد البيانات الأولية </td><td>  رقمي (16.4) </td></tr><tr><td>  history_uint </td><td>  رصد البيانات الأولية </td><td>  رقمي (20.0) </td></tr><tr><td>  history_str </td><td>  رصد البيانات الأولية </td><td>  فارشار (255) </td></tr><tr><td>  history_text </td><td>  رصد البيانات الأولية </td><td>  نص </td></tr><tr><td>  history_logs </td><td>  رصد البيانات الأولية </td><td>  حقول النص و int </td></tr><tr><td>  اتجاهات </td><td>  بيانات الرصد المجمعة </td><td>  رقمي (16.4) </td></tr><tr><td>  trends_uint </td><td>  بيانات الرصد المجمعة </td><td>  رقمي (20.0) </td></tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  أنشطة التحسين </h4><br>  لتحسين أداء قاعدة بيانات PostgreSQL ، تم تنفيذ العديد من مقاييس التحسين ، وأهمها تقسيم الفهارس وتغييرها.  ومع ذلك ، تجدر الإشارة إلى بضع كلمات حول بعض التدابير الهامة والمفيدة التي يمكن أن تسرع عمل أي قاعدة بيانات في ظل نظام إدارة قاعدة بيانات PostgreSQL. <br><br>  <b>ملاحظة مهمة.</b>  في وقت جمع مواد المقالة ، استخدمنا Zabbix الإصدار 4.0 ، على الرغم من أن الإصدار 4.2 قد تم إصداره بالفعل وأن الإصدار 4.4 يتم إعداده للنشر.  لماذا من المهم أن أذكر هذا؟  نظرًا بدءًا من الإصدار 4.2 ، بدأ Zabbix في دعم امتداد قوي خاص للعمل مع سلاسل TimescaleDB الزمنية ، ولكن حتى الآن في الوضع التجريبي: لجميع مزايا استخدام هذا الملحق ، يُعتقد أن بعض الطلبات بدأت تعمل بشكل أبطأ وما زالت هناك مشاكل في الأداء لم يتم حلها (ستكون هناك حل في الإصدار 4.4) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قراءة هذا المقال</a> .  <i>في المقالة التالية أخطط للكتابة عن نتائج اختبار الحمل باستخدام ملحق TimescaleDB بالفعل مقارنةً بحالة الحل هذه.</i>  تم استخدام إصدار PostgreSQL 10 ، ولكن كل المعلومات المقدمة ذات صلة بالإصدارات 11 و 12 (نحن في انتظار!). <br><br>  لذلك ، أول الأشياء أولاً: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إعداد ملف التكوين باستخدام الأداة المساعدة pgtune </li><li style=";text-align:right;direction:rtl">  وضع قاعدة البيانات إلى قرص فعلي منفصل </li><li style=";text-align:right;direction:rtl">  تقسيم الجداول التاريخ مع pg_pathman </li><li style=";text-align:right;direction:rtl">  تغيير أنواع فهرس جداول المحفوظات إلى brin (ساعة) و btree-gin (itemid) </li><li style=";text-align:right;direction:rtl">  جمع وتحليل إحصائيات تنفيذ الاستعلام pg_stat_statements </li><li style=";text-align:right;direction:rtl">  وضع المعلمات رصد القرص الفعلي </li><li style=";text-align:right;direction:rtl">  تحسين أداء الأجهزة </li><li style=";text-align:right;direction:rtl">  إنشاء مجموعة موزعة (مواد خارج نطاق هذه المقالة) </li></ul><br><br><h4 style=";text-align:right;direction:rtl">  تكوين ملف التكوين باستخدام الأداة المساعدة pgtune </h4><br>  في الواقع ، PostgreSQL هو نظام إدارة قواعد البيانات خفيف الوزن إلى حد ما.  تم تكوين ملف التكوين الافتراضي الخاص به بحيث ، كما يقول زميلي ، "حتى العمل على آلة القهوة" ، أي  على الحديد متواضعة جدا.  لذلك ، من الضروري تكوين PostgreSQL لتكوين الخادم ، مع مراعاة مقدار الذاكرة وعدد المعالجات ونوع الاستخدام المقصود لقاعدة البيانات ونوع القرص (HDD أو SSD) وعدد الاتصالات. <br><br>  للأسف ، لا توجد صيغة واحدة لضبط جميع نظم إدارة قواعد البيانات ، ولكن هناك قواعد وأنماط معينة مناسبة لمعظم التكوينات (الضبط الدقيق هو بالفعل عمل خبير).  لتبسيط حياة DBA ، تمت كتابة الأداة المساعدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pgtune</a> ، والتي تم استكمالها بواسطة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إصدار الويب</a> بواسطة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">le0pard</a> ، مؤلف كتاب مثير للاهتمام ومفيد عن إدارة PostgreSQL. <br><br>  مثال على تشغيل الأداة المساعدة في وحدة التحكم مع 100 اتصال (Zabbix لديه مسؤول ويب مطالبين) لنوع التطبيق "مستودعات البيانات": <br><br><pre style=";text-align:right;direction:rtl">  pgtune -i postgresql.conf -o new_postgresql.conf -T DW -c 100 </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">معلمات التكوين التي تتغير الأداة المساعدة pgtune مع وصف الغرض (يتم إعطاء القيم كمثال)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> # DB الإصدار: 11
 نوع نظام التشغيل: لينكس
 # DB نوع: الويب
 # إجمالي الذاكرة (RAM): 8 جيجابايت
 # وحدات المعالجة المركزية الأسطوانات: 1
 # اتصالات الأسطوانات: 100
 # تخزين البيانات: الأقراص الصلبة<font></font>
<font></font>
 max_connections = 100 # الحد الأقصى لعدد اتصالات قاعدة البيانات المتزامنة
 Shared_buffers = 2GB # حجم الذاكرة لمختلف المخازن المؤقتة (ذاكرة التخزين المؤقت بشكل رئيسي من كتل الجدول وكتل الفهرس) في الذاكرة المشتركة
 effect_cache_size = 6GB # الحد الأقصى لحجم الذاكرة المطلوبة لتنفيذ الاستعلام باستخدام الفهارس
 maintenance_work_mem = 512 ميجابايت # يؤثر على سرعة العمليات VACUUM ، ANALYZE ، CREATE INDEX
 checkpoint_completion_target = 0.7 # الوقت المستهدف لإكمال إجراءات نقاط التفتيش
 wal_buffers = 16 ميغابايت # مقدار الذاكرة المستخدمة من قبل الذاكرة المشتركة للحفاظ على سجلات المعاملات
 default_statistics_target = 100 # كمية الإحصائيات التي يتم جمعها بواسطة أمر ANALYZE - عند الزيادة ، يبني المحسن الاستعلامات ببطء أكثر ، لكن أفضل
 random_page_cost = 4 # التكلفة الشرطية للوصول إلى الفهرس إلى صفحات البيانات - تؤثر على قرار استخدام الفهرس
 effect_io_concurrency = 2 # عدد عمليات الإدخال / الإخراج غير المتزامنة التي سيحاول DBMS تنفيذها في جلسة منفصلة
 work_mem = 10485 كيلو بايت # مقدار الذاكرة المستخدمة للفرز وجداول التجزئة قبل استخدام الملفات المؤقتة على القرص
 min_wal_size = 1GB # حدود أقل من عدد ملفات WAL التي سيتم إعادة تدويرها للاستخدام في المستقبل
 max_wal_size = حدود 2GB # على رأس عدد ملفات WAL التي سيتم إعادة تدويرها للاستخدام في المستقبل </pre></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">بعض خيارات التكوين postgresql المفيدة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> # إدارة معالجات الطلب المتزامنة
 max_worker_processes = 8 # الحد الأقصى لعدد عمليات الخلفية - واحد على الأقل لكل قاعدة بيانات
 max_parallel_workers_per_gather = 4 # الحد الأقصى لعدد العمليات المتوازية ضمن طلب واحد
 max_parallel_workers = 8 # الحد الأقصى لعدد عمليات العمل التي يمكن للنظام دعمها للعمليات المتوازية<font></font>
<font></font>
 # إعدادات التسجيل (طريقة سهلة للتعرف على وقت تنفيذ الطلبات دون استخدام ملحق pg_stat_statements)
 log_min_duration_statement = 3000 # اكتب إلى السجلات مدة تنفيذ جميع الأوامر التي يكون وقت تشغيلها&gt; = من القيمة المحددة بالمللي ثانية
 log_duration = إيقاف # تسجيل مدة كل أمر مكتمل
 log_statement = 'none' # التي أوامر SQL الكتابة إلى السجل ، والقيم: بلا (تعطيل) ، ddl ، وزارة الدفاع وجميع (جميع الأوامر)
 debug_print_plan = إيقاف # إخراج شجرة خطة الاستعلام لمزيد من التحليل<font></font>
<font></font>
 # ضغط الحد الأقصى للخروج من قاعدة البيانات وكن جاهزًا للحصول عليه لأي عطل (للأكثر قمعًا ، الذين يتجاهلون وجود SSD ومجموعة نظامية موزعة)
 #fsync = off # الكتابة الفعلية على قرص التغييرات ، يؤدي تعطيل fsync إلى زيادة السرعة ، ولكن يمكن أن يؤدي إلى فشل دائم
 #synchronous_commit = off # يسمح لك بالرد على العميل حتى قبل أن تكون معلومات المعاملة في WAL - بديل آمن تقريبًا لتعطيل fsync
 #full_page_writes = off # shutdown يسرع العمليات العادية ، لكن يمكن أن يؤدي إلى تلف البيانات أو تلف البيانات إذا تعطل النظام </pre></div></div><br><h4 style=";text-align:right;direction:rtl">  سرد قاعدة بيانات على قرص فعلي منفصل </h4><br>  <i>هذا العنصر اختياري ويعد حلاً انتقاليًا لمجموعة موزعة بالكامل ، لكن سيكون من المفيد معرفة هذا الاحتمال.</i>  لتسريع قاعدة البيانات ، يمكنك وضعها على قرص منفصل.  لقد قمنا بتركيب القرص بأكمله في الدليل الأساسي ، حيث يتم تخزين جميع قواعد بيانات PostgreSQL ، ولكن بشكل عام يمكن القيام بذلك بشكل مختلف: إنشاء قاعدة جداول جديدة ونقل قاعدة البيانات (أو حتى جزء منها فقط - جداول بيانات المراقبة الأساسية والمجمعة) إلى قاعدة الجداول هذه على قرص منفصل. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">جبل سبيل المثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  تحتاج أولاً إلى تهيئة القرص باستخدام نظام الملفات ext4 وتوصيله بالخادم.  تحميل القرص لقاعدة البيانات مع التسمية وقت الظهيرة: <br><br><pre style=";text-align:right;direction:rtl">  mount / dev / sdc1 / var / lib / pgsql / 10 / data / base -o noatime </pre><br>  للتثبيت الدائم ، أضف السطر إلى ملف / etc / fstab: <br><br><pre style=";text-align:right;direction:rtl"> # حيث UUID هو معرف القرص ، يمكنك رؤيته باستخدام الأداة المساعدة blkid
 UUID = 121efe29-70bf-410b-bc71-90704568ce3b / var / lib / pgsql / 10 / data / base ext4 defaults، noatime 0 0 </pre><br></div></div><br><h4 style=";text-align:right;direction:rtl">  تقسيم الجداول التاريخ مع pg_pathman </h4><br>  إحدى المشكلات التي واجهناها أثناء اختبار الضغط في Zabbix - PostgreSQL لا يمكنها حذف البيانات القديمة من قاعدة البيانات.  باستخدام التقسيم ، يمكنك تقسيم الجدول إلى الأجزاء المكونة له ، وبالتالي تقليل حجم الفهارس والأجزاء المكونة للجدول الفائق ، مما يؤثر بشكل إيجابي على سرعة قاعدة البيانات ككل. <br><br>  التقسيم يحل مشكلتين في وقت واحد: <br><br>  1. تسريع إزالة البيانات القديمة عن طريق حذف الجداول بأكملها <br><br>  2. تقسيم المؤشرات لكل جدول مركب <br><br>  هناك أربع آليات للتقسيم في PostgreSQL: <br><br>  1. معيار التقييد <br><br>  2. تمديد pg_partman ( <i>لا تخلط مع pg_pathman</i> ) <br><br>  3. تمديد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pg_pathman</a> <br><br>  4. يدويا إنشاء وصيانة أقسام من قبل أنفسنا <br><br>  حل التقسيم الأكثر ملاءمة وموثوقية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ومحسّنة</a> ، في رأينا ، هو امتداد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pg_pathman</a> .  باستخدام طريقة التقسيم هذه ، يحدد مخطط الاستعلام بمرونة الأقسام التي تبحث عن البيانات.  <i>تقول الشائعات أنه في الإصدار الثاني عشر من PostgreSQL سيكون هناك قسم ممتاز بالفعل خارج الصندوق.</i> <br><br>  وبالتالي ، بدأنا في كتابة بيانات المراقبة لكل يوم في جدول منفصل موروث عن الجدول الأعلى ، وبدأت إزالة قيم المعلمات المتقادمة تحدث من خلال إزالة جميع الجداول المتقادمة في آن واحد ، وهو أمر أسهل بكثير بالنسبة لنظام إدارة قواعد البيانات بتكاليف العمالة.  تم الحذف عن طريق استدعاء وظيفة مستخدم قاعدة البيانات كمعلمة مراقبة لخادم Zabbix في الساعة 2 صباحًا مع الإشارة إلى النطاق المقبول لتخزين الإحصاءات. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تثبيت وتكوين التقسيم ل PostgreSQL 10</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  قم بتثبيت ملحق <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pg_pathman وتكوينه</a> من مستودع OS القياسي (للحصول على إرشادات حول إنشاء أحدث إصدار من الملحق من المصادر ، انظر في نفس مستودع التخزين على github): <br><br><pre style=";text-align:right;direction:rtl"> يم تثبيت pg_pathman10
 nano /var/pgsqldb/postgresql.conf
 Shared_preload_libraries = 'pg_pathman' # مهم - هنا اكتب pg_pathman آخر مرة في القائمة
</pre><br>  نقوم بإعادة تشغيل نظام إدارة قواعد البيانات (DBMS) ، وإنشاء ملحق لقاعدة البيانات وتكوين التقسيم (يوم واحد لبيانات المراقبة الأساسية و 3 أيام لبيانات المراقبة المجمعة - يمكن القيام بذلك ليوم واحد): <br><br><pre style=";text-align:right;direction:rtl"> systemctl إعادة تشغيل postgresql-10.service
 psql -d zabbix -U postgres
 إنشاء تمدد pg_pathman ؛
 # تكوين يوم واحد لجداول بيانات الرصد الأساسية
 # 1552424400 - العد التنازلي كما الطابع الزمني يونيكس ، 86400 - ثانية في أيام
 حدد create_range_partitions ('history'، 'clock'، 1552424400، 86400)؛
 حدد create_range_partitions ('history_uint'، 'clock'، 1552424400، 86400)؛
 حدد create_range_partitions ('history_text' ، 'clock' ، 1552424400 ، 86400) ؛
 حدد create_range_partitions ('history_str' ، 'clock' ، 1552424400 ، 86400) ؛
 حدد create_range_partitions ('history_log' ، 'clock' ، 1552424400 ، 86400) ؛
 # تكوين لمدة ثلاثة أيام لجداول بيانات المراقبة المجمعة
 # 1552424400 - العد التنازلي كما الطابع الزمني يونيكس ، 259200 - ثانية في ثلاثة أيام
 حدد create_range_partitions ("الاتجاهات" ، "الساعة" ، 1545771600 ، 259200) ؛  
 حدد create_range_partitions ('trends_uint'، 'clock'، 1545771600، 259200)؛ 
</pre><br>  <i>إذا لم تكن هناك بيانات في أي من الجداول بعد ، فعند استدعاء دالة create_range_partitions ، يجب تمرير وسيطة إضافية واحدة p_count = 0_.</i> <br><br>  استعلامات مفيدة لمراقبة الأقسام وإدارتها: <br><br><pre style=";text-align:right;direction:rtl"> # قائمة عامة بالجداول المقسمة وتخزين التكوين الرئيسي:
 حدد * من pathman_config ؛
 # تمثيل مع جميع الأقسام الحالية ، وكذلك والديهم وحدود النطاق:
 حدد * من pathman_partition_list ؛
 # معلمات إضافية تتجاوز سلوك pg_pathman القياسي:
 حدد * من pathman_config_params ؛
 # نسخ المحتويات مرة أخرى إلى الجدول الأصل وحذف الأقسام:
 حدد drop_partitions ('table_name' :: regclass، false) ؛
</pre><br>  برنامج نصي مفيد لعرض الإحصاءات حول عدد الأقسام وحجمها: <br><pre style=";text-align:right;direction:rtl"> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> schemaname, relname, relkind, <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span> (reltuples <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>), pg_size_pretty(pg_relation_size(C.oid)) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"size"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class C <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace N <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (N.oid = C.relnamespace) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'pg_catalog'</span></span>, <span class="hljs-string"><span class="hljs-string">'information_schema'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'history%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'trends%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-comment"><span class="hljs-comment">-- and reltuples &gt; 0 -- and pg_relation_size(C.oid) &gt;= 0 ORDER BY schemaname, relname</span></span></code> </pre> </div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">الضبط التلقائي لحذف الأقسام القديمة (ahtung - دالة SQL كبيرة)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  لتكوين الحذف التلقائي للأقسام ، تحتاج إلى إنشاء وظيفة في قاعدة البيانات <br>  (نص عريض ، لذلك اضطررت إلى إزالة تمييز بناء الجملة): <br><br><pre style=";text-align:right;direction:rtl"> إنشاء أو استبدال وظيفة public.delete_old_partitions (history_days عدد صحيح ، اتجاهات عدد صحيح ، عدد صحيح str_days)
  عوائد النص
  اللغة plpgsql
 كما $ وظيفة $
 / *
 تحذف الدالة جميع الأقسام الأقدم من عدد الأيام المحدد:
 history_days - للأقسام history_x ، history_uint_x
 trends_days - بالنسبة للجدران trends_x ، trends_uint_x
 str_days - للأقسام history_str_x ، history_text_x ، history_log_x
 * /
 إعلان clock_today_start int؛
 إعلان clock_delete_less_history int = 0 ؛
 إعلان clock_delete_less_trends int = 0 ؛
 إعلان clock_delete_less_strings int = 0 ؛
 clock_delete_less int = 0؛
 أعلن التكرار int = 0 ؛
 قم بتعريف result_str text = ''؛
 إعلان النص buf_table_size ؛
 إعلان نص buf_table_len ؛
 يعلن النص_الفصل النص ؛
 إعلان النص clock_max ؛
 إعلان عن خطأ في كتابة النص ؛
 قم بتعريف t_start timestamp = clock_timestamp ()؛
 أعلن t_end الطابع الزمني ؛
 بدأ
     إذا كان $ 1 &lt;= 0 ثم إرجاع "ups" ، فهذا خطأ: يجب أن تكون الوسيطة history_days قيمة عدد صحيح موجب "؛  نهاية إذا ؛
     إذا كان $ 2 &lt;= 0 ثم إرجاع "ups" ، هناك خطأ ما: يجب أن تكون وسيطة trends_days قيمة عدد صحيح موجب "؛  نهاية إذا ؛
     إذا كان $ 3 &lt;= 0 ثم عاود عمليات ، فهذا خطأ: يجب أن تكون الوسيطة str_days قيمة عدد صحيح موجب ؛  نهاية إذا ؛
     clock_today_start = extract (epoch from date_trunc ('day'، now ()) :: :: int؛
     clock_delete_less_history = extract (epoch from date_trunc ('day'، now ()) - ($ 1 :: text || 'days') :: interval) :: int؛
     clock_delete_less_trends = extract (epoch from date_trunc ('day'، now ()) - ($ 2 :: text || 'days') :: interval) :: int؛
     clock_delete_less_strings = extract (epoch from date_trunc ('day'، now ()) - ($ 3 :: text || 'days') :: interval) :: int؛
     clock_delete_less = الأقل (clock_delete_less_history، clock_delete_less_trends، clock_delete_less_strings)؛
     - لاحظ إشعار "clock_today_start٪ (٪)" ، to_timestamp (clock_today_start) ، clock_today_start؛
     - لاحظ الإشعار "clock_delete_less_history٪ (٪)٪ أيام" ، to_timestamp (clock_delete_less_history) ، clock_delete_less_history ، $ 1 ؛
     - لاحظ الإشعار "clock_delete_less_trends٪ (٪)٪ أيام" ، to_timestamp (clock_delete_less_trends) ، clock_delete_less_trends ، $ 2 ؛
     - لاحظ إشعار "clock_delete_less_strings٪ (٪)٪ أيام" ، to_timestamp (clock_delete_less_strings) ، clock_delete_less_strings ، $ 3 ؛
     بالنسبة لـ partition_name ، clock_max في قسم محدد ، range_max من pathman_partition_list حيث 
     range_max :: int &lt;= الأعظم (clock_delete_less_history و clock_delete_less_trends و clock_delete_less_strings) و 
     (قسم :: نص مثل "السجل٪" أو القسم :: نص مثل "الاتجاهات٪") حسب القسم تصاعدي
     أنشوطة
         if (partition_name ~ 'history_uint_ \ d' و clock_max :: int &lt;= clock_delete_less_history)
         أو (partition_name ~ 'history_ \ d' و clock_max :: int &lt;= clock_delete_less_history)
         أو (partition_name ~ 'trends_ \ d' و clock_max :: int &lt;= clock_delete_less_trends)
         أو (partition_name ~ 'history_log_ \ d' و clock_max :: int &lt;= clock_delete_less_strings)
         أو (partition_name ~ 'history_str_ \ d' و clock_max :: int &lt;= clock_delete_less_strings)
         أو (partition_name ~ 'history_text_ \ d' و clock_max :: int &lt;= clock_delete_less_strings)
         ثم 
             التكرار = التكرار + 1 ؛
             رفع إشعار '٪' ، تنسيق ('!!! حذف٪ s٪ s' ، partition_name ، clock_max) ؛
             حدد max (reltuples :: int) ، pg_size_pretty (sum (pg_relation_size (pg_class.oid))) كـ "size" من pg_class حيث يعيد تسمية مثل partition_name ||  '٪' إلى buf_table_len صارمة ، buf_table_size ؛
             إذا result_str! = '' ثم result_str = result_str ||  ''؛  نهاية إذا ؛
             result_str = result_str ||  format ('٪ s (dt &lt;٪ s، len٪ s،٪ s)'، partition_name، to_char (to_timestamp (clock_max :: int)، 'YYYY-MM-DD')، buf_table_len، buf_table_size)؛
             تنفيذ التنسيق ('جدول الإفلات إذا كان موجودًا٪ s' ، partition_name) ؛
         نهاية إذا ؛
     حلقة النهاية ؛
     إذا كان iterator = 0 ، ثم result_str = format ('لا توجد أقسام لحذفها أقدم ، ثم٪ s date' ، to_char (to_timestamp (clock_delete_less) ، 'YYYY-MM-DD')) ؛ 
     else result_str = format ('أقسام٪ s المحذوفة في٪ s ثانية:' ، مكرر ، trunc (استخراج (بالثواني من (clock_timestamp () - t_start)) :: numeric، 3)) ||  result_str.
     نهاية إذا ؛
     - رفع إشعار '٪' ، result_str ؛
     return result_str؛
 استثناء عند الآخرين ثم
    الحصول على تشخيص مكدس err_detail = PG_EXCEPTION_CONTEXT ؛
    صيغة الإرجاع (عمليات الإغلاق ، خطأ ما:٪ s [err code٪ s] ،٪ s '، sqlerrm ، sqlstate ، err_detail) ؛
 ينتهي. 
 وظيفة $ $ ؛
</pre><br>  للاتصال تلقائيًا بوظيفة التقسيم التلقائي ، تحتاج إلى إنشاء عنصر بيانات واحد لمضيف خادم zabbix من نوع "مراقب قاعدة البيانات" بالإعدادات التالية: <br><br><pre style=";text-align:right;direction:rtl"> - النوع: رصد قاعدة البيانات
 - الاسم: delete_old_history_partitions
 - المفتاح: db.odbc.select [delete_old_history_partitions، zabbix]
 - تعبير sql: حدد delete_old_partitions (3 ، 30 ، 30) ؛
 # هنا ، تشير معلمات استدعاء دالة delete_old_partitions إلى وقت التخزين بالأيام 
 # للقيم الرقمية والقيم الرقمية المجمعة وقيم السلسلة
 - نوع البيانات: نص
 - تحديث الفاصل الزمني: 0
 - الفاصل الزمني للمستخدم: المقرر في h2
 - فترة التخزين التاريخ: 90 يوما
 - مجموعة عناصر البيانات: قاعدة البيانات
</pre><br>  نتيجةً لذلك ، سوف نحصل على إحصائيات حول تنظيف الأجزاء من هذا النوع تقريبًا: <br><br><pre style=";text-align:right;direction:rtl">  2019-09-16 02:00:00 ، تم حذف 3 أقسام في 0.024 ثانية: trends_78 (dt &lt;2019-08-17 ، لين 1 ، 48 كيلو بايت) ، history_193 (dt &lt;2019-09-13 ، لين 85343 ، 9448 كيلو بايت ) ، history_uint_186 (dt &lt;2019-09-13 ، لين 27969 ، 3480 كيلو بايت)
</pre><br>  <b>! المهم</b>  بعد إعداد الحذف التلقائي للأقسام عبر عنصر البيانات ووظيفة المستخدم ، تحتاج إلى إيقاف تشغيل السجل والتنظيف في برنامج جدولة المهام Zabbix مدبرة: من <i>خلال عنصر القائمة zabbix ، حدد "الإدارة" -&gt; "عام" -&gt; حدد "محو السجل" من القائمة في الزاوية -&gt; تعطيل جميع خانات الاختيار في قسم "التاريخ" و "ديناميات التغييرات".</i> <br></div></div><br><h4 style=";text-align:right;direction:rtl">  تغيير أنواع فهرس جداول المحفوظات إلى brin (ساعة) و btree-gin (itemid) </h4><br>  شكر خاص ل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">erogov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لسلسلة ممتازة من المقالات نظرة عامة على فهارس PostgreSQL</a> .  <i>وبالفعل فريق PostgresPRO بأكمله.</i>                            . <br><br>  ,            btree(itemid, clock) —    ,     ,   «»  ,    —  10 . <br><br> <i>          ,              ,       .</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أثناء اختبار مؤشرات مختلفة ، تم الكشف عن أنجح مزيج من المؤشرات: مؤشر برين في حقل الساعة ومؤشر btree-gin في حقل itemid لجميع جداول بيانات الرصد. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعد مؤشر brin مثاليًا لزيادة البيانات رتابة ، مثل الطابع الزمني لحقيقة حدث ما ، أي </font><font style="vertical-align: inherit;">لسلسلة زمنية. </font><font style="vertical-align: inherit;">ومؤشر btree-gin هو في الأساس مؤشر gin على أنواع البيانات القياسية ، والتي عادة ما تكون أسرع بكثير من مؤشر btree الكلاسيكي لأن </font><font style="vertical-align: inherit;">لا يتم إعادة بناء مؤشر الجن أثناء إضافة قيم جديدة ، ولكن يتم تكميلها فقط. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم وضع مؤشر btree-gin كملحق لـ PostgreSQL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فيما يلي مقارنة لسرعة أخذ العينات لاستراتيجية الفهرسة هذه والفهارس الموجودة في قاعدة بيانات Zabbix افتراضيًا. </font><font style="vertical-align: inherit;">خلال اختبارات الحمل ، جمعنا البيانات لمدة ثلاثة أيام لثلاثة أقسام:</font></font><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اسم القسم </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عدد الصفوف بالمليون </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحجم بالميجابايت </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 81.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4119 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 74.9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4426 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100.7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5387 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لتقييم النتائج ، تم إجراء ثلاثة أنواع من الاستعلامات: </font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالنسبة لعنصر معلمة محدد واحد ، بيانات الشهر الماضي ، في الواقع الأيام الثلاثة الأخيرة (إجمالي 1660 سجل) </font></font><br><br><pre style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شرح تحليل حدد * من history_uint حيث itemid = 313300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
و clock&gt; = extract (epoch from '2019-03-09 00:00:00' :: timestamp) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وعلى مدار الساعة &lt;= extract (epoch from '2019-04-09 12:00:00' :: timestamp) :: int؛</font></font><font></font>
</pre></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لبيانات معلمة واحدة محددة لمدة 12 ساعة من يوم واحد (649 إدخالات في المجموع) </font></font><br><br><pre style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شرح تحليل حدد * من history_text حيث itemid = 310650</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وعلى مدار الساعة&gt; = استخراج (فترة من '2019-04-09 00:00:00' :: الطابع الزمني) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وعلى مدار الساعة &lt;= extract (epoch from '2019-04-09 12:00:00' :: timestamp) :: int؛</font></font><font></font>
</pre></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لبيانات معلمة واحدة محددة لمدة ساعة واحدة (61 سجل في المجموع): </font></font><br><br><pre style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شرح تحليل عدد التحديد (*) من history_text حيث itemid = 336540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وعلى مدار الساعة&gt; = استخراج (عصر من '2019-04-08 11:00:00' :: الطابع الزمني) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وعلى مدار الساعة &lt;= extract (epoch from '2019-04-08 12:00:00' :: timestamp) :: int؛</font></font><font></font>
</pre></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تم جدولة نتائج الاختبار أدناه: </font></font><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نوع الفهرس </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحجم بالميجابايت * </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> طلب 1 ** في مللي </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> طلب 2 ** في مللي </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> طلب 3 ** في مللي </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btree (على مدار الساعة ، itemid) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14741 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7154.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2205.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1860.4 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brin (ساعة) ، </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btree-gin (itemid)</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.42 و 1329 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2958.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1820.4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 102.1 </font></font></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* يشار إلى الحجم بالميغابايت في ثلاثة أقسام </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">** طلب من النوع الأول - بيانات لمدة 3 أيام ، طلب من النوع 2 - بيانات لمدة 12 ساعة ، من النوع 3 طلب - بيانات لمدة ساعة </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من جدول المقارنة ، يمكن ملاحظة أنه بالنسبة لجداول البيانات الكبيرة مع عدد السجلات أكثر من 100 مليون ، يُرى بوضوح أن تغيير مؤشر btree القياسي المركب إلى مؤشرين هما brin و btree-gin له تأثير مفيد على تقليل حجم الفهارس وتسريع وقت تنفيذ الاستعلام. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم عرض كفاءة الفهرسة والتقسيم أدناه في مثال طلب لإضافة سجلات جديدة إلى الجداول history_uint و trends_uint (تحدث الإضافات في متوسط ​​قيم 2000 لكل استعلام).</font></font><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> طاولة </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> متوسط ​​وقت طلب التحسينات ، مللي ثانية </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> متوسط ​​وقت الطلب بعد التحسينات ، مللي ثانية </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trends_uint </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2201.48 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.72 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trends_uint </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1997.27 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 62.16 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بتلخيص نتائج اختبارات التكوينات المختلفة للفهارس لجداول بيانات مراقبة نظام zabbix ، يمكننا القول إن التغيير المماثل في الفهرس القياسي لجداول بيانات مراقبة zabbix يؤثر بشكل إيجابي على الأداء الكلي للنظام ، وهو ما يحدث بشكل أكبر عند تجميع وحدات تخزين البيانات التي تزيد عن 10 ملايين. يجب أن تنسى التأثير غير المباشر لـ "تورم" فهرس btree القياسي افتراضيًا - تؤدي عمليات إعادة البناء المتكررة لمؤشر متعدد الجيجابايت إلى تحميل كبير للقرص الثابت (استخدام المتري ation) ، مما يؤدي في النهاية إلى زيادة وقت عمليات القرص ووقت انتظار الوصول إلى القرص من وحدة المعالجة المركزية (iowait metric). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومع ذلك،</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لكي يعمل فهرس btree-gin مع نوع بيانات bigint (in8) ، وهو عمود itemid ، تحتاج إلى تسجيل مجموعة من مشغلي bigint لمؤشر btree-gin. </font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تسجيل عائلة مشغل bigint لمؤشر btree-gin</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl">/*<font></font>
     gin    biginteger  integer    .<font></font>
 -   gin     int2, int4, int8,<font></font>
       bigint     ,     bigint (&lt;= 2147483647)<font></font>
        intger_ops,  :<font></font>
create index on tablename using gin(columnname int8_family_ops) with (fastupdate = false);<font></font>
*/<font></font>
<font></font>
--       btree_gin<font></font>
CREATE EXTENSION btree_gin;<font></font>
<font></font>
CREATE OPERATOR FAMILY integer_ops using gin;<font></font>
<font></font>
CREATE OPERATOR CLASS int4_family_ops<font></font>
FOR TYPE int4 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint4cmp(int4,int4),<font></font>
    FUNCTION 2 gin_extract_value_int4(int4, internal),<font></font>
    FUNCTION 3 gin_extract_query_int4(int4, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int4(int4,int4,int2, internal),<font></font>
STORAGE int4;<font></font>
<font></font>
CREATE OPERATOR CLASS int8_family_ops<font></font>
FOR TYPE int8 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint8cmp(int8,int8),<font></font>
    FUNCTION 2 gin_extract_value_int8(int8, internal),<font></font>
    FUNCTION 3 gin_extract_query_int8(int8, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int8(int8,int8,int2, internal),<font></font>
STORAGE int8;<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int4,int8),<font></font>
  OPERATOR 2 &lt;=(int4,int8),<font></font>
  OPERATOR 3 =(int4,int8),<font></font>
  OPERATOR 4 &gt;=(int4,int8),<font></font>
  OPERATOR 5 &gt;(int4,int8);<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int8,int4),<font></font>
  OPERATOR 2 &lt;=(int8,int4),<font></font>
  OPERATOR 3 =(int8,int4),<font></font>
  OPERATOR 4 &gt;=(int8,int4),<font></font>
  OPERATOR 5 &gt;(int8,int4);<font></font>
</pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعيد هذا البرنامج النصي توزيع جميع الفهارس في قاعدة بيانات PostgreSQL لـ Zabbix من التكوين الافتراضي إلى التكوين الأمثل الموضح أعلاه.</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl">/*<font></font>
        <font></font>
*/<font></font>
<font></font>
--   <font></font>
drop index history_1;<font></font>
drop index history_uint_1;<font></font>
drop index history_str_1;<font></font>
drop index history_text_1;<font></font>
drop index history_log_1;<font></font>
--          PK <font></font>
-- (   ,         )<font></font>
alter table trends drop constraint trends_pk;<font></font>
alter table trends_uint drop constraint trends_uint_pk;<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--   btree-gin  bigint       <font></font>
-- https://habr.com/ru/company/postgrespro/blog/340978/#comment_10545932<font></font>
--    create extension btree_gin;<font></font>
create index on history using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_str using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_text using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_log using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--     brin    128 ,    <font></font>
--           ,<font></font>
--      https://habr.com/ru/company/postgrespro/blog/346460/<font></font>
create index on history using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_uint using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_str using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_text using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_log using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends_uint using brin(clock) with (pages_per_range = 128);<font></font>
</pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالنسبة لمؤشر برين لحجم البيانات الخاص بنا بكثافة 100 طن من المعلمات في الدقيقة (100 طن في التاريخ و 100 طن في history_uint) ، لوحظ أن الفهرس يعمل على جداول بيانات المراقبة الأولية بحجم منطقة يبلغ 512 صفحة ضعف سرعة من حجم قياسي من 128 صفحة ، ولكن هذا هو فردي ويعتمد على حجم الجداول وتكوين الخادم. في أي حال ، يشغل مؤشر brin مساحة صغيرة جدًا ، ولكن يمكن زيادة سرعته قليلاً عن طريق ضبط حجم المنطقة ، ولكن بشرط ألا يتغير معدل تدفق البيانات كثيرًا.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتيجة لذلك ، تجدر الإشارة إلى وجود قيود مرتبطة بهندسة Zabbix نفسها: في علامة التبويب "البيانات الحديثة" ، يتم جمع القيمتين الأخيرتين لكل معلمة مع مراعاة التصفية. لكل معلمة ، يتم طلب القيم في قاعدة البيانات بشكل منفصل. لذلك ، كلما تم تحديد هذه المعلمات ، سيتم تشغيل الاستعلام لفترة أطول. يتم البحث عن أحدث البيانات عندما يتم تعيين فهرس btree (itemid ، تنازلي الساعة) على جداول المحفوظات مع الفرز العكسي حسب الوقت ، لكن الفهرس نفسه بالطبع "يتضخم" على القرص ويبطئ بشكل غير مباشر قاعدة البيانات بشكل عام ، مما يسبب مشكلة ، المذكورة أعلاه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لذلك ، هناك ثلاث طرق:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">             « »      100  (..   ,     « »    ) </li><li style=";text-align:right;direction:rtl">     Zabbix ,                  ,          « » </li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اترك الفهارس كما هي افتراضيًا ، ونقصر أنفسنا على التقسيم فقط للحصول على تحديدات كبيرة جدًا في علامة التبويب البيانات الحديثة في نفس الوقت لمجموعة متنوعة من المعلمات (ومع ذلك ، فقد لوحظ أن خادم الويب Zabbix لا يزال لديه حد لعدد قيم المعلمات المعروضة في وقت واحد في علامة التبويب "البيانات الحديثة" - لذلك ، عندما أحاول عرض 5000 قيمة ، حسبت قاعدة البيانات النتيجة ، لكن تعذر على الخادم إعداد صفحة الويب وعرض مثل هذه الكمية الكبيرة من البيانات). </font></font></li></ol><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> جمع وتحليل إحصائيات تنفيذ الاستعلام pg_stat_statements </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pg_stat_statements هو امتداد لجمع الإحصاءات حول أداء الاستعلام عبر الخادم بأكمله. </font><font style="vertical-align: inherit;">تتمثل ميزة هذا الامتداد في أنه لا يحتاج إلى جمع سجلات PostgreSQL وتحليلها.</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام ملحق pg_stat_statements</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">    psql: <br><br><pre style=";text-align:right;direction:rtl"> CREATE EXTENSION pg_stat_statements; </pre><br>       postgresql.conf: <br><br><pre style=";text-align:right;direction:rtl">shared_preload_libraries = 'pg_stat_statements'<font></font>
pg_stat_statements.max = 10000 #   sql ,     (     );<font></font>
pg_stat_statements.track = all # all -   (    ), top -   /, none -  <font></font>
pg_stat_statements.save = true #     <font></font>
</pre><br>  : <br><br><pre style=";text-align:right;direction:rtl"> SELECT pg_stat_statements_reset(); </pre><br>          : <br><pre style=";text-align:right;direction:rtl"> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> query_sub, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(calls) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> calls, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(mean_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mean_time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'insert into'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'update trends'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> calls <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span></code> </pre> </div></div><br><h4 style=";text-align:right;direction:rtl">      </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لمراقبة محركات الأقراص الثابتة في Zabbix ، يتم توفير المعلمتين vfs.dev.read و vfs.dev.write فقط. لا توفر هذه الخيارات معلومات حول استخدام القرص. المعايير المفيدة لإيجاد مشاكل مع أداء محركات الأقراص الصلبة هي عامل الاستخدام ، وانتظار وقت الاستعلام ، وتحميل قائمة انتظار تحميل القرص. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وكقاعدة عامة ، يرتبط التحميل على القرص العالي بميزة iowait عالية لوحدة المعالجة المركزية نفسها ومع زيادة وقت تنفيذ استعلامات sql ، والتي تم العثور عليها أثناء اختبار التحمل لخادم zabbix بتكوين قياسي دون التقسيم وبدون إعداد فهارس بديلة. يمكنك إضافة هذه المعلمات لرصد محركات الأقراص الصلبة باستخدام الخطوات التالية ، التي تم عرضها في </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مقال</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من صديق</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ومحسّنة: يتم الآن تجميع معلمات iostat بشكل منفصل لكل قرص في معلمة وقت json ، حيث ، وفقًا لإعدادات ما بعد المعالجة ، يتم تحليلها بالفعل في معلمات المراقبة النهائية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أثناء تعليق طلب السحب ، يمكنك محاولة توسيع مراقبة معلمات القرص وفقًا </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للتعليمات المفصلة من خلال مفترقي</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد كل الخطوات الموضحة ، يمكنك إضافة رسم بياني مخصص مع iowait cpu ومعلمات الاستفادة من قرص النظام والقرص من قاعدة البيانات (إذا كانت مختلفة) إلى لوحة مراقبة خادم Zabbix الرئيسية. </font><font style="vertical-align: inherit;">قد تبدو النتيجة هكذا (sda هو القرص الرئيسي ، sdc هو القرص مع قاعدة البيانات):</font></font><br><br><img src="https://habrastorage.org/webt/oa/nj/fa/oanjfa3hajssftbq22dk8njiwj0.png"><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحسين أداء الأجهزة </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد إعداد نظم إدارة قواعد البيانات والفهرسة والتقسيم ، يمكنك المتابعة إلى التدرج الرأسي - لتحسين خصائص أجهزة الخادم: إضافة ذاكرة الوصول العشوائي وتغيير محركات الأقراص إلى الحالة الصلبة وإضافة مراكز المعالج. </font><font style="vertical-align: inherit;">هذه زيادة مضمونة في الأداء ، لكن من الأفضل القيام بذلك فقط بعد تحسين البرنامج.</font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء الكتلة الموزعة </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد التدرج الرأسي المعتدل ، تحتاج إلى بدء أفقي - إنشاء كتلة موزعة: إما حادة أو تكرار العبد الرئيسي. </font><font style="vertical-align: inherit;">ولكن هذا موضوع منفصل ومقال لمقال منفصل </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(كيفية تشكيل مجموعة من القرف والعصي)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، بالإضافة إلى مقارنة تقنية تحسين قاعدة البيانات Zabbix الموصوفة أعلاه باستخدام pg_pathman والفهرسة باستخدام تقنية تطبيق ملحق TimescaleDB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه الأثناء ، يمكن للمرء أن يأمل فقط في أن تكون المادة الواردة في هذه المقالة مفيدة وغنية بالمعلومات!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar468463/">https://habr.com/ru/post/ar468463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar468447/index.html">Laragon - WAMP مع المجالات المحلية التلقائي</a></li>
<li><a href="../ar468453/index.html">MBLT19 :: تقارير ، معركة المنتج والاختبار</a></li>
<li><a href="../ar468455/index.html">عظيم GPS وجانبها المظلم</a></li>
<li><a href="../ar468457/index.html">مولد أمثلة حسابية بسيطة لالدمى وليس فقط</a></li>
<li><a href="../ar468459/index.html">نظرة عامة على كاشف الرادار: الرائد Playme Silent 2</a></li>
<li><a href="../ar468465/index.html">رأي المحامي: كيف يمكن لشركات تكنولوجيا المعلومات إنهاء عقد مع عميل حكومي سام</a></li>
<li><a href="../ar468471/index.html">نظرة عامة على AngularConnect 2019. الجزء 1</a></li>
<li><a href="../ar468479/index.html">"يعتقد الناس أن الحر لا قيمة له. بدا لي أنه يمكنني إقناعهم "- يوري يارتسيف عن مدرسة راسل</a></li>
<li><a href="../ar468481/index.html">كيف كانت S7 الأولى في روسيا لبيع تذاكر الطيران عبر الإنترنت</a></li>
<li><a href="../ar468485/index.html">عندما تريد واجهة المستخدم الرسومية الجميلة ، ولكن GPU ليست كذلك</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>