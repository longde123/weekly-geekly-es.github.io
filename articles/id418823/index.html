<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤°ğŸ¾ ğŸ‘©ğŸ½â€ğŸ“ â” Python lambat. Mengapa ğŸ‘‚ğŸ¾ ğŸ­ ğŸ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, orang dapat mengamati semakin populernya bahasa pemrograman Python. Ini digunakan dalam DevOps, dalam analisis data, dalam pengembangan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python lambat. Mengapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418823/">  Baru-baru ini, orang dapat mengamati semakin populernya bahasa pemrograman Python.  Ini digunakan dalam DevOps, dalam analisis data, dalam pengembangan web, di bidang keamanan dan di bidang lainnya.  Tapi inilah kecepatannya ... Tidak ada yang membanggakan dari bahasa ini di sini.  Penulis materi, terjemahan yang kami terbitkan hari ini, memutuskan untuk mencari tahu alasan lambatnya Python dan menemukan cara untuk mempercepatnya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tv/zp/uz/tvzpuzzfhsgdyegpe8ri3pbl3mw.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ketentuan Umum</font> </h2><br>  Bagaimana Java, dalam hal kinerja, berhubungan dengan C atau C ++?  Bagaimana cara membandingkan C # dan Python?  Jawaban atas pertanyaan-pertanyaan ini sangat bergantung pada jenis aplikasi yang dianalisis oleh peneliti.  Tidak ada patokan yang sempurna, tetapi mempelajari kinerja program yang ditulis dalam berbagai bahasa, The Computer Language Benchmarks Game bisa menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">titik awal yang</a> baik. <br><br>  Saya telah merujuk ke The Computer Benchmarks Game selama lebih dari sepuluh tahun.  Python, dibandingkan dengan bahasa lain, seperti Java, C #, Go, JavaScript, C ++, adalah salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang paling lambat</a> .  Ini termasuk bahasa yang menggunakan kompilasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JIT</a> (C #, Java), dan kompilasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AOT</a> (C #, C ++), serta bahasa yang ditafsirkan seperti JavaScript. <br><br>  Di sini saya ingin mencatat bahwa ketika saya mengatakan "Python", maksud saya adalah implementasi referensi dari interpreter Python - CPython.  Dalam materi ini, kami akan menyentuh implementasi lainnya.  Sebenarnya, di sini saya ingin menemukan jawaban untuk pertanyaan mengapa Python membutuhkan waktu 2-10 kali lebih banyak daripada bahasa lain untuk menyelesaikan masalah yang sebanding, dan apakah itu bisa dilakukan lebih cepat. <br><br>  Berikut adalah beberapa teori dasar yang mencoba menjelaskan mengapa Python lambat: <br><br><ul><li>  Alasannya adalah GIL (Global Interpreter Lock, Global Interpreter Lock). </li><li>  Alasannya adalah bahwa Python adalah bahasa yang ditafsirkan dan bukan dikompilasi. </li><li>  Alasannya adalah pengetikan dinamis. </li></ul><br>  Kami akan menganalisis ide-ide ini dan mencoba menemukan jawaban untuk pertanyaan tentang apa yang memiliki efek terbesar pada kinerja aplikasi Python. <br><br><h2>  <font color="#3AC1EF">Gil</font> </h2><br>  Komputer modern memiliki prosesor multi-core, dan sistem multiprosesor kadang-kadang ditemukan.  Untuk menggunakan semua kekuatan komputasi ini, sistem operasi menggunakan struktur tingkat rendah yang disebut utas, sementara proses (misalnya, proses peramban Chrome) dapat meluncurkan banyak utas dan menggunakannya sesuai dengannya.  Akibatnya, misalnya, jika suatu proses sangat membutuhkan sumber daya prosesor, pelaksanaannya dapat dibagi antara beberapa core, yang memungkinkan sebagian besar aplikasi untuk menyelesaikan tugas yang mereka hadapi lebih cepat. <br><br>  Sebagai contoh, browser Chrome saya, pada saat saya menulis ini, memiliki 44 utas terbuka.  Harus diingat bahwa struktur dan API sistem untuk bekerja dengan stream berbeda dalam sistem operasi berbasis Posix (Mac OS, Linux) dan dalam keluarga sistem operasi Windows.  Sistem operasi juga merencanakan utas. <br><br>  Jika Anda belum pernah bertemu dengan pemrograman multi-thread sebelumnya, sekarang Anda harus berkenalan dengan apa yang disebut kunci (kunci).  Arti dari penguncian adalah bahwa pengunciannya memungkinkan Anda untuk memastikan perilaku sistem tersebut ketika, dalam lingkungan multi-utas, misalnya, saat mengubah variabel tertentu dalam memori, beberapa utas tidak bisa mendapatkan akses ke area memori yang sama (untuk membaca atau mengubah). <br><br>  Ketika juru bahasa CPython menciptakan variabel, itu mengalokasikan memori dan kemudian menghitung jumlah referensi yang ada untuk variabel-variabel ini.  Konsep ini dikenal sebagai penghitungan referensi.  Jika jumlah tautan sama dengan nol, maka bagian memori yang sesuai dibebaskan.  Itulah sebabnya, misalnya, pembuatan variabel "sementara", katakanlah, dalam lingkup loop, tidak mengarah pada peningkatan berlebihan dalam jumlah memori yang dikonsumsi oleh aplikasi. <br><br>  Bagian yang paling menarik dimulai ketika beberapa utas berbagi variabel yang sama, dan masalah utama di sini adalah bagaimana tepatnya CPython melakukan penghitungan referensi.  Di sinilah aksi â€œglobal interpreter lockâ€ muncul, yang dengan hati-hati mengontrol eksekusi utas. <br><br>  Seorang juru bahasa hanya dapat melakukan satu operasi pada satu waktu, terlepas dari berapa banyak utas dalam program. <br><br><h3>  <font color="#3AC1EF">â– Bagaimana GIL mempengaruhi kinerja aplikasi Python?</font> </h3><br>  Jika kami memiliki aplikasi single-threaded yang berjalan dalam proses interpreter Python yang sama, maka GIL tidak mempengaruhi kinerja dengan cara apa pun.  Misalnya, jika menyingkirkan GIL, kami tidak akan melihat adanya perbedaan dalam kinerja. <br><br>  Jika, dalam kerangka satu proses interpreter Python, perlu untuk mengimplementasikan pemrosesan data paralel menggunakan mekanisme multithreading, dan aliran yang digunakan akan secara intensif menggunakan subsistem I / O (misalnya, jika mereka bekerja dengan jaringan atau dengan disk), maka akan mungkin untuk mengamati konsekuensi dari bagaimana GIL mengelola utas.  Inilah yang terlihat dalam kasus menggunakan dua utas, proses pemuatan intensif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/379/f47/f9e379f4724ba48881f53b489ca5ed1d.png"></div><br>  <i><font color="#999999">Visualisasi GIL (diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> )</font></i> <br><br>  Jika Anda memiliki aplikasi web (misalnya, berdasarkan pada kerangka Django) dan Anda menggunakan WSGI, maka setiap permintaan untuk aplikasi web akan dilayani oleh proses interpreter Python yang terpisah, yaitu, kami hanya memiliki 1 kunci permintaan.  Karena interpreter Python mulai lambat, dalam beberapa implementasi WSGI ada yang disebut "mode daemon", ketika menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proses interpreter yang</a> dipertahankan dalam kondisi kerja, yang memungkinkan sistem untuk melayani permintaan lebih cepat. <br><br><h3>  <font color="#3AC1EF">â– Bagaimana perilaku juru bahasa Python lainnya?</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyPy</a> memiliki GIL, biasanya lebih dari 3 kali lebih cepat dari CPython. <br><br>  Tidak ada GIL di Jython, karena utas Python di Jython direpresentasikan sebagai utas Java.  Utas semacam itu menggunakan kemampuan manajemen memori JVM. <br><br><h3>  <font color="#3AC1EF">â– Bagaimana kontrol aliran diatur dalam JavaScript?</font> </h3><br>  Jika kita berbicara tentang JavaScript, maka, pertama-tama, harus dicatat bahwa semua mesin JS menggunakan algoritma pengumpulan sampah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mark-and-sweep</a> .  Seperti yang telah disebutkan, alasan utama untuk menggunakan GIL adalah algoritma manajemen memori yang digunakan dalam CPython. <br><br>  JavaScript tidak memiliki GIL, namun, JS adalah bahasa single-threaded, oleh karena itu, tidak perlu mekanisme seperti itu.  Alih-alih eksekusi kode paralel, JavaScript menggunakan teknik pemrograman asinkron berdasarkan loop peristiwa, janji, dan panggilan balik.  Python memiliki sesuatu yang serupa yang disediakan oleh modul <code>asyncio</code> . <br><br><h2>  <font color="#3AC1EF">Python - bahasa yang ditafsirkan</font> </h2><br>  Saya sering mendengar bahwa buruknya kinerja Python disebabkan oleh fakta bahwa itu adalah bahasa yang ditafsirkan.  Pernyataan seperti itu didasarkan pada penyederhanaan besar tentang bagaimana sebenarnya CPython bekerja.  Jika, di terminal, Anda memasukkan perintah seperti <code>python myscript.py</code> , maka CPython akan memulai serangkaian tindakan yang panjang, yang terdiri dari pembacaan, analisis leksikal, penguraian, kompilasi, menafsirkan, dan mengeksekusi kode skrip.  Jika Anda tertarik dengan detailnya, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Bagi kami, ketika mempertimbangkan proses ini, sangat penting bahwa di sini, pada tahap kompilasi, file <code>.pyc</code> dibuat, dan urutan bytecodes ditulis ke file dalam direktori <code>__pycache__/</code> , yang digunakan dalam Python 3 dan Python 2. <br><br>  Ini tidak hanya berlaku untuk skrip yang kami tulis, tetapi juga untuk kode yang diimpor, termasuk modul pihak ketiga. <br><br>  Akibatnya, sebagian besar waktu (kecuali jika Anda menulis kode yang hanya berjalan sekali), Python akan menjalankan bytecode yang sudah selesai.  Membandingkan ini dengan apa yang terjadi di Java dan C #, ternyata kode Java dikompilasi ke dalam "Bahasa Antara", dan mesin virtual Java membaca bytecode dan melakukan kompilasi JIT-nya ke dalam kode mesin.  "Bahasa perantara". NET CIL (yang sama dengan .NET Common-Language-Runtime, CLR) menggunakan kompilasi JIT untuk menavigasi ke kode mesin. <br><br>  Sebagai hasilnya, baik di Jawa maupun di C # beberapa â€œbahasa perantaraâ€ digunakan dan mekanisme yang serupa ada.  Jadi, mengapa Python menunjukkan tolok ukur yang jauh lebih buruk daripada Java dan C # jika semua bahasa ini menggunakan mesin virtual dan semacam bytecode?  Pertama-tama, karena fakta bahwa kompilasi JIT digunakan dalam .NET dan Java. <br><br>  Kompilasi JIT (kompilasi Just In Time, kompilasi on-the-fly atau just-in-time) membutuhkan bahasa perantara untuk memungkinkan pemisahan kode menjadi fragmen (bingkai).  Sistem kompilasi AOT (kompilasi Ahead Of Time, kompilasi sebelum eksekusi) dirancang sedemikian rupa untuk memastikan fungsionalitas penuh kode sebelum interaksi kode ini dengan sistem dimulai. <br><br>  Dengan sendirinya, menggunakan JIT tidak mempercepat eksekusi kode, karena beberapa fragmen kode byte dijalankan, seperti pada Python.  Namun, JIT memungkinkan Anda untuk melakukan optimasi kode selama eksekusi.  Pengoptimal JIT yang baik dapat mengidentifikasi bagian aplikasi yang paling banyak dimuat (bagian aplikasi ini disebut "hot spot") dan mengoptimalkan fragmen kode yang sesuai, menggantikannya dengan opsi yang dioptimalkan dan lebih produktif daripada yang digunakan sebelumnya. <br><br>  Ini berarti bahwa ketika aplikasi tertentu melakukan tindakan tertentu berulang-ulang, optimasi tersebut dapat secara signifikan mempercepat pelaksanaan tindakan tersebut.  Perlu diingat juga bahwa Java dan C # adalah bahasa yang diketik dengan kuat, sehingga pengoptimal dapat membuat lebih banyak asumsi tentang kode yang dapat membantu meningkatkan kinerja program. <br><br>  Ada kompiler JIT di PyPy, dan, seperti yang telah disebutkan, implementasi juru bahasa Python ini jauh lebih cepat daripada CPython.  Informasi tentang membandingkan berbagai penafsir Python dapat ditemukan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br><h3>  <font color="#3AC1EF">â– Mengapa CPython tidak menggunakan kompiler JIT?</font> </h3><br>  Kompiler JIT juga memiliki kelemahan.  Salah satunya adalah waktu peluncuran.  CPython sudah mulai relatif lambat, dan PyPy 2-3 kali lebih lambat dari CPython.  Waktu jangka panjang JVM juga merupakan fakta yang diketahui.  CLR .NET menghindari masalah ini dengan memulai selama boot sistem, tetapi harus dicatat bahwa CLR dan sistem operasi yang menjalankan CLR dikembangkan oleh perusahaan yang sama. <br><br>  Jika Anda memiliki satu proses Python yang telah berjalan untuk waktu yang lama, sementara dalam proses semacam itu ada kode yang dapat dioptimalkan, karena mengandung bagian yang banyak digunakan, maka Anda harus serius melihat seorang juru bahasa yang memiliki kompiler JIT. <br><br>  Namun, CPython adalah implementasi dari juru bahasa Python tujuan umum.  Oleh karena itu, jika Anda mengembangkan, menggunakan Python, aplikasi baris perintah, maka kebutuhan untuk menunggu lama untuk kompiler JIT untuk memulai setiap kali aplikasi ini diluncurkan akan sangat memperlambat pekerjaan. <br><br>  CPython berusaha memberikan dukungan untuk sebanyak mungkin kasus penggunaan Python.  Sebagai contoh, ada kemungkinan menghubungkan kompiler JIT ke Python, bagaimanapun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> yang mengimplementasikan ide ini tidak berkembang sangat aktif. <br><br>  Sebagai hasilnya, kita dapat mengatakan bahwa jika Anda menggunakan Python untuk menulis sebuah program yang kinerjanya dapat meningkat ketika menggunakan kompiler JIT, gunakan juru bahasa PyPy. <br><br><h2>  <font color="#3AC1EF">Python adalah bahasa yang diketik secara dinamis</font> </h2><br>  Dalam bahasa yang diketik secara statis, saat mendeklarasikan variabel, Anda harus menentukan jenisnya.  Di antara bahasa-bahasa ini dapat dicatat C, C ++, Java, C #, Go. <br><br>  Dalam bahasa yang diketik secara dinamis, konsep tipe data memiliki arti yang sama, tetapi tipe variabelnya dinamis. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span></code> </pre> <br>  Dalam contoh paling sederhana ini, Python pertama-tama menciptakan variabel pertama, lalu yang kedua dengan nama yang sama dari tipe <code>str</code> , dan membebaskan memori yang dialokasikan untuk variabel pertama <code>a</code> . <br><br>  Tampaknya menulis dalam bahasa dengan pengetikan dinamis lebih mudah dan lebih sederhana daripada dalam bahasa dengan pengetikan statis, namun, bahasa tersebut tidak dibuat atas kemauan seseorang.  Selama pengembangannya, fitur sistem komputer telah diperhitungkan.  Segala sesuatu yang tertulis dalam teks program, pada akhirnya, turun ke instruksi prosesor.  Ini berarti bahwa data yang digunakan oleh program, misalnya, dalam bentuk objek atau tipe data lainnya, juga dikonversi ke struktur tingkat rendah. <br><br>  Python melakukan transformasi seperti itu secara otomatis, programmer tidak melihat proses ini, dan ia tidak perlu mengurus transformasi seperti itu. <br><br>  Tidak harus menentukan jenis variabel ketika menyatakan itu bukan fitur bahasa yang membuat Python lambat.  Arsitektur bahasa memungkinkan untuk membuat hampir semua hal dinamis.  Misalnya, saat dijalankan, Anda dapat mengganti metode objek.  Sekali lagi, selama pelaksanaan program, Anda dapat menggunakan teknik "tambalan monyet" sebagaimana diterapkan pada panggilan sistem tingkat rendah.  Dengan Python, hampir semuanya mungkin. <br><br>  Ini adalah arsitektur Python yang membuat optimasi sangat sulit. <br><br>  Untuk menggambarkan ide ini, saya akan menggunakan alat untuk melacak panggilan sistem di MacOS yang disebut DTrace. <br><br>  Tidak ada mekanisme dukungan DTrace dalam distribusi CPython yang sudah jadi, jadi CPython perlu dikompilasi ulang dengan pengaturan yang sesuai.  Di sini versi 3.6.6 digunakan.  Jadi, kami menggunakan urutan tindakan berikut: <br><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/python</span></span><span class="hljs-regexp"><span class="hljs-regexp">/cpython/archive</span></span><span class="hljs-regexp"><span class="hljs-regexp">/v3.6.6.zip unzip v3.6.6.zip cd v3.6.6 ./configure</span></span> --with-dtrace make</code> </pre> <br>  Sekarang, menggunakan <code>python.exe</code> , Anda dapat menggunakan DTRace untuk melacak kode.  Baca tentang menggunakan DTrace dengan Python di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Anda dapat menemukan skrip untuk mengukur berbagai indikator kinerja program Python menggunakan DTrace.  Diantaranya adalah parameter untuk fungsi panggilan, runtime program, waktu penggunaan prosesor, informasi tentang panggilan sistem, dan sebagainya.  Inilah cara menggunakan perintah <code>dtrace</code> : <br><br><pre> <code class="hljs powershell">sudo dtrace <span class="hljs-literal"><span class="hljs-literal">-s</span></span> toolkit/&lt;tracer&gt;.d <span class="hljs-literal"><span class="hljs-literal">-c</span></span> <span class="hljs-string"><span class="hljs-string">'../cpython/python.exe script.py'</span></span></code> </pre> <br>  Dan di sini adalah bagaimana <code>py_callflow</code> jejak <code>py_callflow</code> menunjukkan pemanggilan fungsi dalam aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13e/bd4/926/13ebd492636a94b23400305293aec346.gif"></div><br>  <i><font color="#999999">Melacak Menggunakan DTrace</font></i> <br><br>  Sekarang mari kita jawab pertanyaan apakah pengetikan dinamis mempengaruhi kinerja Python.  Inilah beberapa pemikiran tentang ini: <br><br><ul><li>  Pengecekan dan konversi tipe adalah operasi yang berat.  Setiap kali variabel diakses, dibaca atau ditulis, pemeriksaan tipe dilakukan. </li><li>  Bahasa dengan fleksibilitas seperti itu sulit untuk dioptimalkan.  Alasan bahwa bahasa lain jauh lebih cepat daripada Python adalah karena mereka berkompromi dengan memilih antara fleksibilitas dan kinerja. </li><li>  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cython</a> menggabungkan pengetikan Python dan statis, yang, misalnya, seperti yang ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , mengarah ke peningkatan kinerja 84 kali lipat dari Python biasa.  Periksa proyek ini jika Anda membutuhkan kecepatan. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Alasan buruknya kinerja Python adalah sifat dan fleksibilitasnya yang dinamis.  Ini dapat digunakan sebagai alat untuk menyelesaikan berbagai tugas.  Untuk mencapai tujuan yang sama, Anda dapat mencoba mencari alat yang lebih produktif dan lebih optimal.  Mungkin mereka akan dapat menemukan, mungkin tidak. <br><br>  Aplikasi yang ditulis dengan Python dapat dioptimalkan menggunakan kemampuan eksekusi kode asinkron, alat profil, dan - memilih juru bahasa yang tepat.  Jadi, untuk mengoptimalkan kecepatan aplikasi yang waktu startupnya tidak penting, dan yang kinerjanya mungkin diuntungkan dengan menggunakan kompiler JIT, pertimbangkan untuk menggunakan PyPy.  Jika Anda membutuhkan kinerja maksimum dan siap untuk batasan pengetikan statis, lihat Cython. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mengatasi masalah kinerja Python yang buruk? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418823/">https://habr.com/ru/post/id418823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418813/index.html">Kejutan: Konstanta Hubble sebenarnya berubah-ubah</a></li>
<li><a href="../id418815/index.html">Kesalahan umum yang dilakukan pengembang selama pelatihan - dan bagaimana menghindarinya</a></li>
<li><a href="../id418817/index.html">Pengungkapan progresif di UX seluler: cara kerjanya</a></li>
<li><a href="../id418819/index.html">Zat lewat dingin dibuat di atas ISS</a></li>
<li><a href="../id418821/index.html">Fitur Angular 6.1 Baru</a></li>
<li><a href="../id418825/index.html">Metode dan alat untuk mengembangkan gaya halaman web</a></li>
<li><a href="../id418827/index.html">Rekaman suara dari 19.000 jam pembicaraan diterbitkan selama ekspedisi bulan Apollo 11</a></li>
<li><a href="../id418829/index.html">Sebagai satu-satunya garis kode kuno selama enam bulan membuat para pengembang MMORPG gila</a></li>
<li><a href="../id418833/index.html">Nodejs dan IOT: dibuat untuk satu sama lain</a></li>
<li><a href="../id418835/index.html">Bagaimana kami melakukan smartphone Rusia pertama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>