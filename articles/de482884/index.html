<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÖ ü§° üë©üèø‚Äçü§ù‚Äçüë©üèª Lektion f√ºr den Abend: Syntax-Hervorhebung schreiben üí• üî£ ü§ô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich habe ich mich daf√ºr interessiert, wie die Code-Hervorhebung von innen angeordnet ist. Zuerst schien es, dass dort alles wild kompliziert war ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lektion f√ºr den Abend: Syntax-Hervorhebung schreiben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482884/"> K√ºrzlich habe ich mich daf√ºr interessiert, wie die Code-Hervorhebung von innen angeordnet ist.  Zuerst schien es, dass dort alles wild kompliziert war - ein Syntaxbaum, eine Rekursion, und das war alles.  Bei n√§herer Betrachtung stellte sich jedoch heraus, dass es hier nichts Schwieriges gibt.  Die gesamte Arbeit kann in einem Zyklus mit kurzen Hin- und Herbewegungen ausgef√ºhrt werden. Au√üerdem werden regul√§re Ausdr√ºcke im resultierenden Skript so gut wie nie verwendet. <br><br>  Demo-Seite: <a href="https://astynk.github.io/highlight.html">Javascript Code Highlighter</a> <br><a name="habracut"></a><br><h2>  Hauptidee </h2><br>  Wir deklarieren die Statusvariable, die Informationen dar√ºber speichert, in welchem ‚Äã‚ÄãTeil des Codes wir uns befinden.  Wenn beispielsweise <i>state</i> gleich eins ist, bedeutet dies, dass wir uns in einer Zeichenfolge mit einfachen Anf√ºhrungszeichen befinden.  Das Skript wartet auf das abschlie√üende Zitat und ignoriert alles andere.  Dasselbe gilt f√ºr das Hervorheben von Kommentaren, regul√§ren Ausdr√ºcken und anderen Elementen. Jedes Element hat seinen eigenen Statuswert.  Unterschiedliche √∂ffnende und schlie√üende Zeichen stehen daher nicht in Konflikt.  Mit anderen Worten, ein Code wie dieser: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'"\'"'</span></span>;</code> </pre> <br>  wird richtig hervorgehoben, n√§mlich solche F√§lle verursachten die meisten Schwierigkeiten. <br><br><h2>  Erste Schritte </h2><br>  Wir bestimmen die m√∂glichen Werte der Zustandsvariablen, die Farbe, in der dieser oder jener Teil des Codes gezeichnet wird, sowie eine Liste von Javascript-Schl√ºsselw√∂rtern (die ebenfalls hervorgehoben werden): <br><br><div class="spoiler">  <b class="spoiler_title">const states = {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> states = { <span class="hljs-attr"><span class="hljs-attr">NONE</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">SINGLE_QUOTE</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 'string' DOUBLE_QUOTE : 2, // "string" ML_QUOTE : 3, // `string` REGEX_LITERAL : 4, // /regex/ SL_COMMENT : 5, // // single line comment ML_COMMENT : 6, // /* multiline comment */ NUMBER_LITERAL : 7, // 123 KEYWORD : 8 // function, var etc. }; const colors = { NONE : '#000', SINGLE_QUOTE : '#aaa', // 'string' DOUBLE_QUOTE : '#aaa', // "string" ML_QUOTE : '#aaa', // `string` REGEX_LITERAL : '#707', // /regex/ SL_COMMENT : '#0a0', // // single line comment ML_COMMENT : '#0a0', // /* multiline comment */ NUMBER_LITERAL : '#a00', // 123 KEYWORD : '#00a', // function, var etc. OPERATOR : '#07f' // null, true etc. }; const keywords = 'async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|set|static|super|switch|throw|try|typeof|var|void|while|with|yield|catch|finally'.split('|');</span></span></code> </pre><br></div></div><br>  Als N√§chstes erstellen wir eine Funktion, die eine Zeile mit dem Code erstellt und den fertigen HTML-Code mit dem hervorgehobenen Code zur√ºckgibt.  Zum Hervorheben werden Zeichen mit der in der Variablen colors angegebenen Farbe in SPAN eingeschlossen. <br><br>  Die Funktion hat nur einen Zyklus, der jedes Zeichen analysiert und bei Bedarf √ñffnungs- / Schlie√ü-SPANs hinzuf√ºgt. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highlight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = states.NONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; code.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> char = code[i], prev = code[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], next = code[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     } return output; }</span></span></code> </pre> <br>  Markieren Sie zun√§chst die Kommentare: einzeilig und mehrzeilig.  Wenn das aktuelle und das n√§chste Zeichen ein Schr√§gstrich sind und sich nicht in der Zeile befinden ( <i>state</i> ist 0, d. H. <i>States.NONE</i> ), ist dies der Anfang des Kommentars.  √Ñndere den <i>Zustand</i> und √∂ffne SPAN mit der gew√ºnschten Farbe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.SL_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SL_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  <i>continue ist</i> erforderlich, damit die folgenden √úberpr√ºfungen nicht funktionieren und kein Konflikt auftritt. <br><br>  Als n√§chstes warten wir auf das Ende der Zeile: Wenn das aktuelle Zeichen ein Zeilenumbruch und im <i>Status ein</i> einzeiliger Kommentar ist, schlie√üen Sie das SPAN und √§ndern Sie den <i>Status</i> auf Null: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SL_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Ebenso suchen wir nach mehrzeiligen Kommentaren, der Algorithmus ist genau der gleiche, nur die Zeichen, die Sie suchen, sind unterschiedlich: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.ML_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Das Hervorheben von Zeichenfolgen erfolgt auf √§hnliche Weise, nur muss ber√ºcksichtigt werden, dass das schlie√üende Anf√ºhrungszeichen mit einem Backslash maskiert werden kann und somit bereits kein schlie√üender Schr√§gstrich mehr ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span>) { state = states.SINGLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SINGLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Der Code ist √§hnlich wie oben, nur dass wir das Ende der Zeile nicht registrieren, wenn vor dem Anf√ºhrungszeichen ein Backslash steht. <br><br>  Die Definition von Strings in doppelten Anf√ºhrungszeichen erfolgt genauso und es macht wenig Sinn, sie im Detail zu analysieren.  Um das Bild zu vervollst√§ndigen, lege ich sie unter den Spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">if (state == states.NONE &amp;&amp; char == '' '') {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { state = states.DOUBLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.DOUBLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.DOUBLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span>) { state = states.ML_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br>  Regexp-Literale, die leicht mit dem Divisionszeichen verwechselt werden k√∂nnen, sind gesondert zu betrachten.  Wir werden am Ende des Artikels auf dieses Problem zur√ºckkommen, aber im Moment machen wir dasselbe mit regul√§ren Ausdr√ºcken wie mit Zeichenfolgen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.REGEX_LITERAL &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Dies beendet einfache F√§lle, in denen der Anfang und das Ende eines Literal durch 1-2 Zeichen bestimmt werden k√∂nnen.  Beginnen wir mit der Hervorhebung von Zahlen: Wie Sie wissen, beginnen sie immer mit einer Zahl, k√∂nnen jedoch Buchstaben in der Komposition enthalten ( <i>0xFF</i> , <i>123n</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]/</span></span>.test(char) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-z$_]/i</span></span>.test(prev)) { state = states.NUMBER_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.NUMBER_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NUMBER_LITERAL &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-fnx]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span> }</code> </pre> <br>  Hier suchen wir nach dem Anfang einer Zahl: Das vorherige Zeichen darf keine Zahl oder kein Buchstabe sein, da sonst die Zahlen in den Variablennamen hervorgehoben werden.  Sobald das aktuelle Zeichen keine Zahl oder kein Buchstabe ist, die im Literal einer Zahl enthalten sein k√∂nnen, schlie√üen Sie das SPAN und setzen Sie den <i>Status auf</i> Null. <br><br>  Alle m√∂glichen Literaltypen sind markiert, die Suche nach Stichw√∂rtern bleibt erhalten.  Dazu ben√∂tigen Sie eine verschachtelte Schleife, die nach vorn schaut und bestimmt, ob das aktuelle Zeichen der Anfang des Schl√ºsselworts ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[a-z0-9$_]/i</span></span>.test(prev)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (code[i + j] &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(code[i + j])) { word += code[i + j]; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keywords.includes(word)) { state = states.KEYWORD; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.KEYWORD + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>; } }</code> </pre> <br>  Hier sehen wir, das vorherige Zeichen darf nicht im Variablennamen enthalten sein, da sonst das Schl√ºsselwort im Wort <i>outlet hervorgehoben wird</i> .  Dann sammelt die verschachtelte Schleife das l√§ngste Wort, das m√∂glich ist, bis ein nicht-alphabetisches Zeichen angetroffen wird.  Befindet sich das empfangene Wort im <i>Keyword-</i> Array, √∂ffnen Sie das SPAN und markieren Sie das Wort.  Sobald ein nicht-alphabetisches Zeichen angetroffen wird, bedeutet dies das Ende des Wortes - schlie√üen Sie dementsprechend das SPAN: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.KEYWORD &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; }</code> </pre> <br>  Das Einfachste bleibt, die Hervorhebung von Operatoren. Hier k√∂nnen Sie einfach die Zeichen vergleichen, die in Operatoren vorkommen k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-string"><span class="hljs-string">'+-/*=&amp;|%!&lt;&gt;?:'</span></span>.indexOf(char) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.OPERATOR + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Wenn am Ende der Schleife keine der Bedingungen ausgel√∂st wird, die <i>andauern</i> , addieren wir einfach das aktuelle Zeichen zur resultierenden Variablen.  Wenn ein Literal oder ein Schl√ºsselwort beginnt oder endet, √∂ffnen / schlie√üen wir das SPAN mit Farbe.  In allen anderen F√§llen - zum Beispiel, wenn die Zeile bereits offen ist - werfen wir jeweils nur ein Zeichen nach dem anderen.  Es ist auch empfehlenswert, die √ñffnungswinkel abzuschirmen, da sie sonst das Layout besch√§digen k√∂nnen. <br><br><pre> <code class="javascript hljs">output += char.replace(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + <span class="hljs-string"><span class="hljs-string">'lt;'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  +      &lt;</span></span></code> </pre> <br><h2>  Fehlerbehebung </h2><br>  Alles schien irgendwie zu einfach und nicht umsonst: Bei gr√ºndlicheren Tests gab es F√§lle, in denen die Hintergrundbeleuchtung nicht richtig funktionierte. <br><br>  Die Division wird als regul√§rer Ausdruck erkannt. Um einen Unterschied zwischen den beiden zu machen, muss die Art und Weise ge√§ndert werden, in der der regul√§re Ausdruck bestimmt wird.  Wir deklarieren die Variable <i>isRegex = true</i> und werden danach versuchen zu "beweisen", dass dies kein regul√§rer Ausdruck ist, sondern ein Divisionszeichen.  Vor dem Divisionsvorgang d√ºrfen keine Schl√ºsselw√∂rter oder √∂ffnenden Klammern vorhanden sein. Daher erstellen wir eine verschachtelte Schleife und sehen, worauf der Schr√§gstrich zeigt. <br><br><div class="spoiler">  <b class="spoiler_title">Wie es vorher war</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, isRegex = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i + j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { j--; <span class="hljs-comment"><span class="hljs-comment">//        if ('+/-*=|&amp;&lt;&gt;%,({[?:;'.indexOf(code[i+j]) != -1) break; //   ;   -   if (!/[0-9a-z$_]/i.test(code[i+j]) &amp;&amp; word.length &gt; 0) break; //  ,     if (/[0-9a-z$_]/i.test(code[i+j])) word = code[i+j] + word; //   - ,     if (')]}'.indexOf(code[i+j]) != -1) { isRegex = false; break; } } //      -    //  : return /test/g - , plainWord /test/g -  if (word.length &gt; 0 &amp;&amp; !keywords.includes(word)) isRegex = false; if (isRegex) { state = states.REGEX_LITERAL; output += '&lt;span style="color: ' + colors.REGEX_LITERAL + '"&gt;' + char; continue; } }</span></span></code> </pre> <br>  Obwohl dieser Ansatz das Problem l√∂st, ist er immer noch nicht fehlerfrei.  Sie k√∂nnen es so einstellen, dass dieser Algorithmus auch falsch hervorhebt, zum Beispiel: <i>if (a) / regex /</i> oder so: <i>1 / / regex / / 2</i> .  Warum braucht eine Person, die Zahlen in regul√§re Ausdr√ºcke unterteilt, eine Code-Hervorhebung - dies ist eine andere Frage;  Das Design ist syntaktisch korrekt, obwohl es im wirklichen Leben nicht vorkommt. <br><br>  Bei vielen Arbeiten, beispielsweise in <a href="https://prismjs.com/test.html">prism.js,</a> treten Probleme mit der Regexp-F√§rbung auf.  Um regul√§re Ausdr√ºcke korrekt hervorheben zu k√∂nnen, m√ºssen Sie die Syntax genau verstehen, so wie es die Browser tun. <br><br>  Der zweite Fehler, mit dem ich mich befassen musste, betraf Backslashes.  Ein schlie√üendes Anf√ºhrungszeichen wurde in einer Zeichenfolge der Form <i>'test \\'</i> aufgrund eines umgekehrten Schr√§gstrichs nicht erkannt.  Zur√ºck zu der Bedingung, die das Ende der Zeile f√§ngt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>)</code> </pre> <br>  Der letzte Teil der Bedingung muss ge√§ndert werden: Wenn der umgekehrte Schr√§gstrich maskiert ist (d. H. Ein weiterer Schr√§gstrich davor steht), registrieren Sie das Ende der Zeile. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> closingCharNotEscaped = prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> || prev == <span class="hljs-string"><span class="hljs-string">'\\'</span></span> &amp;&amp; code[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... if (state == states.SINGLE_QUOTE &amp;&amp; char == '\'' &amp;&amp; closingCharNotEscaped)</span></span></code> </pre> <br>  Dieselben Ersetzungen m√ºssen bei der Suche nach Zeichenfolgen mit doppelten und umgekehrten Anf√ºhrungszeichen sowie bei der Suche nach regul√§ren Ausdr√ºcken vorgenommen werden. <br><br>  Das ist alles, Sie k√∂nnen das Highlight √ºber den Link am Anfang des Artikels testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482884/">https://habr.com/ru/post/de482884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482872/index.html">Polygone eine andere Welt</a></li>
<li><a href="../de482874/index.html">Koshcheis Tod in der Liste der Empfehlungen (kannst du YouTube bequemer und sicherer machen?)</a></li>
<li><a href="../de482876/index.html">Berechnung der Kosten f√ºr die Erzeugung von Solarstrom f√ºr den Eigenbedarf eines Haushalts in der Mitte Europas</a></li>
<li><a href="../de482878/index.html">Wie ich nach der Definition von "Produkt" gesucht habe</a></li>
<li><a href="../de482882/index.html">Motor als elektromagnetische Bremse</a></li>
<li><a href="../de482886/index.html">Habra-Analyse: Ist die Publikationsl√§nge wichtig?</a></li>
<li><a href="../de482888/index.html">Starten eines VPN-Servers hinter dem Provider NAT</a></li>
<li><a href="../de482892/index.html">Let vs const - was ist zu benutzen?</a></li>
<li><a href="../de482894/index.html">Adaptive prozedurale Generierung mit dem WaveFunctionCollapse-Algorithmus und einer A-priori-Wahrscheinlichkeitsverteilung</a></li>
<li><a href="../de482896/index.html">OSCP - Meine Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>