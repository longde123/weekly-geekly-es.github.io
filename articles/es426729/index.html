<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   TypeScript School of Magic: Gen茅ricos y extensi贸n de tipos 帮  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del art铆culo que estamos traduciendo hoy dice que TypeScript es incre铆ble. Cuando comenz贸 a usar TS, le gust贸 mucho la libertad inherente a e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript School of Magic: Gen茅ricos y extensi贸n de tipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426729/"> El autor del art铆culo que estamos traduciendo hoy dice que TypeScript es incre铆ble.  Cuando comenz贸 a usar TS, le gust贸 mucho la libertad inherente a este lenguaje.  Cuanto m谩s esfuerzo ponga un programador en su trabajo con mecanismos espec铆ficos de TS, mayores ser谩n los beneficios que recibir谩.  Luego us贸 anotaciones de tipo solo peri贸dicamente.  Algunas veces utiliz贸 las oportunidades para completar el c贸digo y las sugerencias del compilador, pero se bas贸 principalmente en su propia visi贸n de las tareas que resolvi贸. <br><br>  Con el tiempo, el autor de este material se dio cuenta de que cada vez que pasa por alto los errores detectados en la etapa de compilaci贸n, coloca una bomba de tiempo en su c贸digo que puede explotar durante la ejecuci贸n del programa.  Cada vez que "luchaba" con errores usando una construcci贸n simple <code>as any</code> , ten铆a que pagar por ello con muchas horas de depuraci贸n. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> <br><br>  Como resultado, lleg贸 a la conclusi贸n de que es mejor no hacerlo.  Se hizo amigo del compilador, comenz贸 a prestar atenci贸n a sus pistas.  El compilador encuentra problemas en el c贸digo y los informa mucho antes de que puedan causar un da帽o real.  El autor del art铆culo, al verse a s铆 mismo como desarrollador, se dio cuenta de que el compilador es su mejor amigo, ya que lo protege de s铆 mismo.  驴C贸mo no recordar las palabras de Albus Dumbledore: "Se necesita mucho coraje para hablar en contra de tus enemigos, pero no se requiere menos que eso para hablar en contra de tus amigos". <br><br>  No importa cu谩n bueno sea el compilador, no siempre es f谩cil complacerlo.  A veces, evitar el uso de <code>any</code> tipo es muy dif铆cil.  Y a veces parece que <code>any</code> es la 煤nica soluci贸n razonable para alg煤n problema. <br><br>  Este material se enfoca en dos situaciones.  Al evitar el uso de <code>any</code> tipo en ellos, puede garantizar la seguridad de tipo del c贸digo, abrir las posibilidades para su reutilizaci贸n y hacerlo intuitivo. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Gen茅ricos</font> </h2><br>  Supongamos que estamos trabajando en una base de datos de una escuela.  Escribimos una funci贸n auxiliar muy conveniente <code>getBy</code> .  Para obtener el objeto que representa al estudiante por su nombre, podemos usar un comando de la forma <code>getBy(model, "name", "Harry")</code> .  Echemos un vistazo a la implementaci贸n de este mecanismo (aqu铆, para no complicar el c贸digo, la base de datos est谩 representada por una matriz ordinaria). <br><br><pre> <code class="hljs powershell">type Student = { name: string; age: number; hasScar: boolean; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> } ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prop, value)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  Como puede ver, tenemos una buena funci贸n, pero no utiliza anotaciones de tipo, y su ausencia tambi茅n significa que dicha funci贸n no se puede llamar de tipo seguro.  Arreglarlo <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: Student[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Student</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Entonces nuestra funci贸n ya se ve mucho mejor.  El compilador ahora conoce el tipo de resultado esperado, esto ser谩 煤til m谩s adelante.  Sin embargo, para lograr un trabajo seguro con los tipos, sacrificamos las posibilidades de reutilizar la funci贸n.  驴Qu茅 pasa si alguna vez necesitamos usarlo para obtener otras entidades?  No puede ser que esta funci贸n no pueda mejorarse de ninguna manera.  Y realmente lo es. <br><br>  En TypeScript, como en otros lenguajes fuertemente tipados, podemos usar gen茅ricos, que tambi茅n se denominan "tipos gen茅ricos", "tipos universales", "generalizaciones". <br><br>  Un gen茅rico es similar a una variable regular, pero en lugar de alg煤n valor, contiene una definici贸n de tipo.  Reescribimos el c贸digo de nuestra funci贸n para que, en lugar del tipo <code>Student</code> , use el tipo universal <code>T</code> <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } const result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Belleza!  Ahora la funci贸n es ideal para la reutilizaci贸n, mientras que la seguridad de tipo sigue estando de nuestro lado.  Observe c贸mo el tipo de <code>Student</code> se establece expl铆citamente en la 煤ltima l铆nea del fragmento de c贸digo anterior donde <code>T</code> gen茅rica.  Esto se hace para que el ejemplo sea lo m谩s claro posible, pero el compilador, de hecho, puede derivar independientemente el tipo necesario, por lo que en los siguientes ejemplos no haremos tales refinamientos de tipo. <br><br>  As铆 que ahora tenemos una funci贸n auxiliar confiable adecuada para su reutilizaci贸n.  Sin embargo, todav铆a se puede mejorar.  驴Qu茅 sucede si se comete un error al ingresar el segundo par谩metro y en lugar de <code>"name"</code> parece haber <code>"naem"</code> ?  La funci贸n se comportar谩 como si el alumno que busca simplemente no se encuentra en la base de datos y, lo que es m谩s desagradable, no producir谩 ning煤n error.  Esto puede provocar una depuraci贸n a largo plazo. <br><br>  Para protegernos contra tales errores, presentamos otro tipo universal, <code>P</code>  Adem谩s, es necesario que <code>P</code> sea una clave de tipo <code>T</code> , por lo tanto, si <code>Student</code> usa <code>Student</code> aqu铆, entonces es necesario que <code>P</code> sea la cadena <code>"name"</code> , <code>"age"</code> o <code>"hasScar"</code> .  Aqu铆 te explicamos c贸mo hacerlo. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: P, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"naem"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // Error: Argument of type <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> is not assignable to <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> of type <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  El uso de gen茅ricos y la <code>keyof</code> es un truco muy poderoso.  Si escribe programas en un IDE que admite TypeScript, al ingresar argumentos, puede aprovechar las capacidades de autocompletado, lo cual es muy conveniente. <br><br>  Sin embargo, todav铆a no hemos terminado de trabajar en la funci贸n <code>getBy</code> .  Ella tiene un tercer argumento, cuyo tipo a煤n no hemos establecido.  Esto no nos conviene en absoluto.  Hasta ahora, no pod铆amos saber de antemano de qu茅 tipo deber铆a ser, ya que depende de lo que pasemos como segundo argumento.  Pero ahora, dado que tenemos el tipo <code>P</code> , podemos inferir din谩micamente el tipo para el tercer argumento.  El tipo del tercer argumento ser谩 finalmente <code>T[P]</code> .  Como resultado, si <code>T</code> es <code>Student</code> y <code>P</code> es <code>"age"</code> , entonces <code>T[P]</code> ser谩 de tipo <code>number</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  Espero que ahora tenga una comprensi贸n absolutamente clara de c贸mo usar los gen茅ricos en TypeScript, pero si desea experimentar muy bien con todo lo que desea experimentar con el c贸digo discutido aqu铆, puede echar un vistazo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> . <br><br><h2>  <font color="#3AC1EF">Extendiendo tipos existentes</font> </h2><br>  A veces podemos encontrar la necesidad de agregar datos o funcionalidades a interfaces cuyo c贸digo no podemos cambiar.  Es posible que deba cambiar el objeto est谩ndar, por ejemplo, agregar alguna propiedad al objeto de <code>window</code> o extender el comportamiento de alguna biblioteca externa como <code>Express</code> .  Y en ambos casos, no tiene la capacidad de afectar directamente el objeto con el que desea trabajar. <br><br>  <code>getBy</code> una soluci贸n a este problema agregando la funci贸n <code>getBy</code> que ya conoce al prototipo de <code>Array</code> .  Esto nos permitir谩, utilizando esta funci贸n, construir construcciones sint谩cticas m谩s precisas.  Por el momento, no estamos hablando de si es bueno o malo expandir objetos est谩ndar, ya que nuestro objetivo principal es estudiar el enfoque en consideraci贸n. <br><br>  Si intentamos agregar una funci贸n al prototipo de <code>Array</code> , al compilador no le gustar谩 mucho esto: <br><br><pre> <code class="hljs powershell">Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //  ...   ?</code> </pre> <br>  Si tratamos de tranquilizar al compilador utilizando peri贸dicamente la construcci贸n <code>as any</code> construcci贸n, anularemos todo lo que hemos logrado.  El compilador permanecer谩 en silencio, pero puede olvidarse del trabajo seguro con tipos. <br><br>  Ser铆a mejor extender el tipo de <code>Array</code> , pero antes de hacerlo, hablemos sobre c贸mo TypeScript maneja las situaciones cuando dos interfaces del mismo tipo est谩n presentes en el c贸digo.  Aqu铆 se aplica un esquema simple de acci贸n.  Los anuncios, si es posible, se combinar谩n.  Si no puede combinarlos, el sistema generar谩 un error. <br><br>  Entonces este c贸digo funciona: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Y este no es: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Ahora, habiendo lidiado con esto, vemos que nos enfrentamos a una tarea bastante simple.  Es decir, todo lo que tenemos que hacer es declarar la interfaz <code>Array&lt;T&gt;</code> y agregarle la funci贸n <code>getBy</code> . <br><br><pre> <code class="hljs powershell">interface Array&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, value: T[<span class="hljs-type"><span class="hljs-type">P</span></span>]): T | null; } Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); //   ! const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //    </code> </pre> <br>  Tenga en cuenta que la mayor parte del c贸digo que probablemente escriba en los archivos del m贸dulo, por lo tanto, para realizar cambios en la interfaz de la <code>Array</code> , necesitar谩 acceso al alcance global.  Puede hacer esto colocando la definici贸n de tipo dentro de <code>declare global</code> .  Por ejemplo, as铆: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  Si va a expandir la interfaz de una biblioteca externa, lo m谩s probable es que necesite acceso al <code>namespace</code> esta biblioteca.  Aqu铆 hay un ejemplo de c贸mo agregar el campo <code>userId</code> a <code>Request</code> de la biblioteca <code>Express</code> : <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  Puede experimentar con el c贸digo en esta secci贸n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este art铆culo, analizamos t茅cnicas para usar gen茅ricos y extensiones de tipo en TypeScript.  Esperamos que lo que aprendi贸 hoy lo ayude a escribir un c贸digo confiable, comprensible y de tipo seguro. <br><br>  <b>Estimados lectores!</b>  驴C贸mo te sientes acerca de cualquier tipo en TypeScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426729/">https://habr.com/ru/post/es426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426719/index.html">Hackathon sobre Data Science en SIBUR: c贸mo fue</a></li>
<li><a href="../es426721/index.html">Evitar fallas durante el desarrollo del producto: 10 consejos de Rookee</a></li>
<li><a href="../es426723/index.html">Microsoft y sus socios esperan crear una c谩psula del tiempo en la luna</a></li>
<li><a href="../es426725/index.html">C贸mo hacer cosas cuando no tienes ganas de hacerlas</a></li>
<li><a href="../es426727/index.html">EME? Cdm? DRM? CENC? IDK! Lo que necesitas para hacer tu propio reproductor de video en un navegador</a></li>
<li><a href="../es426731/index.html">CSS: caracter铆sticas interesantes de border-radius</a></li>
<li><a href="../es426733/index.html">El hierro no fallar谩. C贸mo preparo docenas de servidores por d铆a para la batalla</a></li>
<li><a href="../es426735/index.html">Bienvenido a JETHACK Hackathon</a></li>
<li><a href="../es426737/index.html">Brevemente sobre la arquitectura de los procesadores neurom贸rficos: una mirada al interior</a></li>
<li><a href="../es426739/index.html">Archivos proxy de AWS S3 con nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>