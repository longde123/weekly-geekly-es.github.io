<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔁 🤞🏼 🙏 TypeScript School of Magic: Genéricos y extensión de tipos ⛰️ 🍲 🧞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del artículo que estamos traduciendo hoy dice que TypeScript es increíble. Cuando comenzó a usar TS, le gustó mucho la libertad inherente a e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript School of Magic: Genéricos y extensión de tipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426729/"> El autor del artículo que estamos traduciendo hoy dice que TypeScript es increíble.  Cuando comenzó a usar TS, le gustó mucho la libertad inherente a este lenguaje.  Cuanto más esfuerzo ponga un programador en su trabajo con mecanismos específicos de TS, mayores serán los beneficios que recibirá.  Luego usó anotaciones de tipo solo periódicamente.  Algunas veces utilizó las oportunidades para completar el código y las sugerencias del compilador, pero se basó principalmente en su propia visión de las tareas que resolvió. <br><br>  Con el tiempo, el autor de este material se dio cuenta de que cada vez que pasa por alto los errores detectados en la etapa de compilación, coloca una bomba de tiempo en su código que puede explotar durante la ejecución del programa.  Cada vez que "luchaba" con errores usando una construcción simple <code>as any</code> , tenía que pagar por ello con muchas horas de depuración. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> <br><br>  Como resultado, llegó a la conclusión de que es mejor no hacerlo.  Se hizo amigo del compilador, comenzó a prestar atención a sus pistas.  El compilador encuentra problemas en el código y los informa mucho antes de que puedan causar un daño real.  El autor del artículo, al verse a sí mismo como desarrollador, se dio cuenta de que el compilador es su mejor amigo, ya que lo protege de sí mismo.  ¿Cómo no recordar las palabras de Albus Dumbledore: "Se necesita mucho coraje para hablar en contra de tus enemigos, pero no se requiere menos que eso para hablar en contra de tus amigos". <br><br>  No importa cuán bueno sea el compilador, no siempre es fácil complacerlo.  A veces, evitar el uso de <code>any</code> tipo es muy difícil.  Y a veces parece que <code>any</code> es la única solución razonable para algún problema. <br><br>  Este material se enfoca en dos situaciones.  Al evitar el uso de <code>any</code> tipo en ellos, puede garantizar la seguridad de tipo del código, abrir las posibilidades para su reutilización y hacerlo intuitivo. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Genéricos</font> </h2><br>  Supongamos que estamos trabajando en una base de datos de una escuela.  Escribimos una función auxiliar muy conveniente <code>getBy</code> .  Para obtener el objeto que representa al estudiante por su nombre, podemos usar un comando de la forma <code>getBy(model, "name", "Harry")</code> .  Echemos un vistazo a la implementación de este mecanismo (aquí, para no complicar el código, la base de datos está representada por una matriz ordinaria). <br><br><pre> <code class="hljs powershell">type Student = { name: string; age: number; hasScar: boolean; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> } ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prop, value)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  Como puede ver, tenemos una buena función, pero no utiliza anotaciones de tipo, y su ausencia también significa que dicha función no se puede llamar de tipo seguro.  Arreglarlo <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: Student[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Student</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Entonces nuestra función ya se ve mucho mejor.  El compilador ahora conoce el tipo de resultado esperado, esto será útil más adelante.  Sin embargo, para lograr un trabajo seguro con los tipos, sacrificamos las posibilidades de reutilizar la función.  ¿Qué pasa si alguna vez necesitamos usarlo para obtener otras entidades?  No puede ser que esta función no pueda mejorarse de ninguna manera.  Y realmente lo es. <br><br>  En TypeScript, como en otros lenguajes fuertemente tipados, podemos usar genéricos, que también se denominan "tipos genéricos", "tipos universales", "generalizaciones". <br><br>  Un genérico es similar a una variable regular, pero en lugar de algún valor, contiene una definición de tipo.  Reescribimos el código de nuestra función para que, en lugar del tipo <code>Student</code> , use el tipo universal <code>T</code> <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } const result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Belleza!  Ahora la función es ideal para la reutilización, mientras que la seguridad de tipo sigue estando de nuestro lado.  Observe cómo el tipo de <code>Student</code> se establece explícitamente en la última línea del fragmento de código anterior donde <code>T</code> genérica.  Esto se hace para que el ejemplo sea lo más claro posible, pero el compilador, de hecho, puede derivar independientemente el tipo necesario, por lo que en los siguientes ejemplos no haremos tales refinamientos de tipo. <br><br>  Así que ahora tenemos una función auxiliar confiable adecuada para su reutilización.  Sin embargo, todavía se puede mejorar.  ¿Qué sucede si se comete un error al ingresar el segundo parámetro y en lugar de <code>"name"</code> parece haber <code>"naem"</code> ?  La función se comportará como si el alumno que busca simplemente no se encuentra en la base de datos y, lo que es más desagradable, no producirá ningún error.  Esto puede provocar una depuración a largo plazo. <br><br>  Para protegernos contra tales errores, presentamos otro tipo universal, <code>P</code>  Además, es necesario que <code>P</code> sea ​​una clave de tipo <code>T</code> , por lo tanto, si <code>Student</code> usa <code>Student</code> aquí, entonces es necesario que <code>P</code> sea ​​la cadena <code>"name"</code> , <code>"age"</code> o <code>"hasScar"</code> .  Aquí te explicamos cómo hacerlo. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: P, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"naem"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // Error: Argument of type <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> is not assignable to <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> of type <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  El uso de genéricos y la <code>keyof</code> es un truco muy poderoso.  Si escribe programas en un IDE que admite TypeScript, al ingresar argumentos, puede aprovechar las capacidades de autocompletado, lo cual es muy conveniente. <br><br>  Sin embargo, todavía no hemos terminado de trabajar en la función <code>getBy</code> .  Ella tiene un tercer argumento, cuyo tipo aún no hemos establecido.  Esto no nos conviene en absoluto.  Hasta ahora, no podíamos saber de antemano de qué tipo debería ser, ya que depende de lo que pasemos como segundo argumento.  Pero ahora, dado que tenemos el tipo <code>P</code> , podemos inferir dinámicamente el tipo para el tercer argumento.  El tipo del tercer argumento será finalmente <code>T[P]</code> .  Como resultado, si <code>T</code> es <code>Student</code> y <code>P</code> es <code>"age"</code> , entonces <code>T[P]</code> será de tipo <code>number</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  Espero que ahora tenga una comprensión absolutamente clara de cómo usar los genéricos en TypeScript, pero si desea experimentar muy bien con todo lo que desea experimentar con el código discutido aquí, puede echar un vistazo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  <font color="#3AC1EF">Extendiendo tipos existentes</font> </h2><br>  A veces podemos encontrar la necesidad de agregar datos o funcionalidades a interfaces cuyo código no podemos cambiar.  Es posible que deba cambiar el objeto estándar, por ejemplo, agregar alguna propiedad al objeto de <code>window</code> o extender el comportamiento de alguna biblioteca externa como <code>Express</code> .  Y en ambos casos, no tiene la capacidad de afectar directamente el objeto con el que desea trabajar. <br><br>  <code>getBy</code> una solución a este problema agregando la función <code>getBy</code> que ya conoce al prototipo de <code>Array</code> .  Esto nos permitirá, utilizando esta función, construir construcciones sintácticas más precisas.  Por el momento, no estamos hablando de si es bueno o malo expandir objetos estándar, ya que nuestro objetivo principal es estudiar el enfoque en consideración. <br><br>  Si intentamos agregar una función al prototipo de <code>Array</code> , al compilador no le gustará mucho esto: <br><br><pre> <code class="hljs powershell">Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //  ...   ?</code> </pre> <br>  Si tratamos de tranquilizar al compilador utilizando periódicamente la construcción <code>as any</code> construcción, anularemos todo lo que hemos logrado.  El compilador permanecerá en silencio, pero puede olvidarse del trabajo seguro con tipos. <br><br>  Sería mejor extender el tipo de <code>Array</code> , pero antes de hacerlo, hablemos sobre cómo TypeScript maneja las situaciones cuando dos interfaces del mismo tipo están presentes en el código.  Aquí se aplica un esquema simple de acción.  Los anuncios, si es posible, se combinarán.  Si no puede combinarlos, el sistema generará un error. <br><br>  Entonces este código funciona: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Y este no es: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Ahora, habiendo lidiado con esto, vemos que nos enfrentamos a una tarea bastante simple.  Es decir, todo lo que tenemos que hacer es declarar la interfaz <code>Array&lt;T&gt;</code> y agregarle la función <code>getBy</code> . <br><br><pre> <code class="hljs powershell">interface Array&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, value: T[<span class="hljs-type"><span class="hljs-type">P</span></span>]): T | null; } Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); //   ! const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //    </code> </pre> <br>  Tenga en cuenta que la mayor parte del código que probablemente escriba en los archivos del módulo, por lo tanto, para realizar cambios en la interfaz de la <code>Array</code> , necesitará acceso al alcance global.  Puede hacer esto colocando la definición de tipo dentro de <code>declare global</code> .  Por ejemplo, así: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  Si va a expandir la interfaz de una biblioteca externa, lo más probable es que necesite acceso al <code>namespace</code> esta biblioteca.  Aquí hay un ejemplo de cómo agregar el campo <code>userId</code> a <code>Request</code> de la biblioteca <code>Express</code> : <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  Puede experimentar con el código en esta sección <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este artículo, analizamos técnicas para usar genéricos y extensiones de tipo en TypeScript.  Esperamos que lo que aprendió hoy lo ayude a escribir un código confiable, comprensible y de tipo seguro. <br><br>  <b>Estimados lectores!</b>  ¿Cómo te sientes acerca de cualquier tipo en TypeScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426729/">https://habr.com/ru/post/es426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426719/index.html">Hackathon sobre Data Science en SIBUR: cómo fue</a></li>
<li><a href="../es426721/index.html">Evitar fallas durante el desarrollo del producto: 10 consejos de Rookee</a></li>
<li><a href="../es426723/index.html">Microsoft y sus socios esperan crear una cápsula del tiempo en la luna</a></li>
<li><a href="../es426725/index.html">Cómo hacer cosas cuando no tienes ganas de hacerlas</a></li>
<li><a href="../es426727/index.html">EME? Cdm? DRM? CENC? IDK! Lo que necesitas para hacer tu propio reproductor de video en un navegador</a></li>
<li><a href="../es426731/index.html">CSS: características interesantes de border-radius</a></li>
<li><a href="../es426733/index.html">El hierro no fallará. Cómo preparo docenas de servidores por día para la batalla</a></li>
<li><a href="../es426735/index.html">Bienvenido a JETHACK Hackathon</a></li>
<li><a href="../es426737/index.html">Brevemente sobre la arquitectura de los procesadores neuromórficos: una mirada al interior</a></li>
<li><a href="../es426739/index.html">Archivos proxy de AWS S3 con nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>