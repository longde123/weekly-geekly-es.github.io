<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍳 👍🏽 🍀 Guide JavaScript Partie 4: Fonctionnalités 🈺 🤞 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous publions aujourd'hui la quatrième partie de la traduction du manuel JavaScript, consacrée aux fonctions. 

 → Partie 1: premier programme, foncti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide JavaScript Partie 4: Fonctionnalités</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430382/">  Nous publions aujourd'hui la quatrième partie de la traduction du manuel JavaScript, consacrée aux fonctions. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: premier programme, fonctionnalités linguistiques, normes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: style de code et structure du programme</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: variables, types de données, expressions, objets</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: caractéristiques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: tableaux et boucles</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 6: exceptions, points-virgules, littéraux génériques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 7: mode strict, ce mot-clé, événements, modules, calculs mathématiques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 8: Présentation des fonctionnalités d'ES6</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 9: Présentation des normes ES7, ES8 et ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">Fonctions JavaScript</font> </h2><br>  Parlons des fonctions en JavaScript, examinons-les en général et considérons les détails à leur sujet, dont la connaissance vous permettra de les utiliser efficacement. <br><a name="habracut"></a><br>  Une fonction est un bloc de code indépendant qui, une fois déclaré, peut être appelé autant de fois que nécessaire.  Une fonction peut, bien que non nécessaire, accepter des paramètres.  Les fonctions renvoient une seule valeur. <br><br>  Les fonctions en JavaScript sont des objets, ou plutôt, ce sont des objets de type <code>Function</code> .  Leur principale différence avec les objets ordinaires, en leur donnant les capacités exceptionnelles qu'ils possèdent, est que les fonctions peuvent être appelées. <br><br>  De plus, les fonctions en JavaScript sont appelées «fonctions de première classe» car elles peuvent être affectées à des variables, elles peuvent être passées à d'autres fonctions en tant qu'arguments et elles peuvent être renvoyées à partir d'autres fonctions. <br><br>  Premièrement, nous considérons les caractéristiques du travail avec les fonctions et les constructions syntaxiques correspondantes qui existaient dans le langage avant l'avènement de la norme ES6 et qui sont toujours pertinentes. <br><br>  Voici à quoi ressemble une déclaration de fonction. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  De nos jours, ces fonctions sont dites "normales", ce qui les distingue des fonctions "flèches" apparues dans ES6. <br><br>  Vous pouvez affecter une fonction à une variable ou une constante.  Une telle construction est appelée une expression de fonction. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Vous pouvez remarquer que dans l'exemple ci-dessus, la fonction est affectée à une constante, mais elle-même n'a pas de nom.  Ces fonctions sont appelées anonymes.  Des fonctions similaires peuvent recevoir des noms.  Dans ce cas, nous parlons d'une expression de fonction nommée (expression de fonction nommée). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  L'utilisation de telles expressions augmente la commodité du débogage (dans les messages d'erreur où la trace de pile est effectuée, le nom de la fonction est visible).  Le nom de la fonction dans une expression fonctionnelle peut également être nécessaire pour que la fonction puisse s'appeler, ce qui est indispensable pour implémenter des algorithmes récursifs. <br><br>  Dans la norme ES6, des fonctions flèches sont apparues, qui sont particulièrement pratiques à utiliser sous la forme de «fonctions en ligne» - comme arguments passés à d'autres fonctions (rappels). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Les fonctions fléchées, en plus du fait que les structures utilisées pour les déclarer, sont plus compactes que l'utilisation de fonctions ordinaires, elles en diffèrent par certaines caractéristiques importantes, dont nous parlerons ci-dessous. <br><br><h2>  <font color="#3AC1EF">Paramètres de fonction</font> </h2><br>  Les paramètres sont des variables qui sont définies au stade de la déclaration d'une fonction et contiendront les valeurs qui lui sont transmises (ces valeurs sont appelées arguments).  Les fonctions en JavaScript peuvent n'avoir aucun paramètre ou avoir un ou plusieurs paramètres. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br>  Voici quelques exemples de fonctions fléchées. <br><br>  À partir de la norme ES6, les fonctions peuvent avoir ce que l'on appelle des «paramètres par défaut». <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Ils représentent des valeurs standard qui sont définies par les paramètres des fonctions si, lors de son appel, les valeurs de certains paramètres ne sont pas définies.  Par exemple, la fonction illustrée ci-dessus peut être appelée à la fois en lui transmettant les deux paramètres qu'elle reçoit et par d'autres méthodes. <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br>  Dans ES8, il est devenu possible de mettre une virgule après le dernier argument d'une fonction (c'est ce qu'on appelle une virgule de fin).  Cette fonctionnalité vous permet d'augmenter la commodité de l'édition de code lors de l'utilisation de systèmes de contrôle de version pendant le développement du programme.  Des détails à ce sujet peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Les arguments passés aux fonctions peuvent être représentés sous forme de tableaux.  Afin d'analyser ces arguments, vous pouvez utiliser un opérateur qui ressemble à trois points (il s'agit de ce que l'on appelle "l'opérateur d'extension" ou "l'opérateur d'étalement").  Voici à quoi ça ressemble. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br>  Si les fonctions doivent prendre de nombreux paramètres, il peut être difficile de se souvenir de l'ordre de leur séquence.  Dans de tels cas, des objets avec des paramètres et des possibilités de déstructuration d'objets ES6 sont utilisés. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br>  Cette technique permet, en décrivant les paramètres sous forme de propriétés d'objet et en passant la fonction à l'objet, d'obtenir l'accès de la fonction aux paramètres par leurs noms sans utiliser de constructions supplémentaires.  En savoir plus sur cette technique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Valeurs renvoyées par les fonctions</font> </h2><br>  Toutes les fonctions renvoient une certaine valeur.  Si la commande de retour n'est pas explicitement spécifiée, la fonction renverra <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br>  L'exécution de la fonction se termine soit après l'exécution de tout le code qu'elle contient, soit après que le mot-clé <code>return</code> été rencontré dans le code.  Lorsque ce mot-clé est rencontré dans une fonction, son opération est terminée et le contrôle est transféré à l'endroit d'où la fonction a été appelée. <br><br>  Si après le mot-clé <code>return</code> vous spécifiez une certaine valeur, cette valeur revient à la place de l'appel de fonction suite à l'exécution de cette fonction. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br>  Une seule valeur peut être renvoyée par une fonction.  Afin de pouvoir renvoyer plusieurs valeurs, vous pouvez les renvoyer sous forme d'objet à l'aide d'un littéral d'objet ou sous forme de tableau, et lors de l'appel d'une fonction, utilisez la construction d'affectation destructrice.  Les noms des paramètres sont enregistrés.  Dans le même temps, si vous devez travailler avec un objet ou un tableau renvoyé par une fonction, notamment sous la forme d'un objet ou d'un tableau, vous pouvez vous passer de l'affectation destructrice. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br>  La construction <code>const [ name, age ] = doSomething()</code> peut être lue comme suit: "déclarez le <code>name</code> et les constantes d' <code>age</code> et affectez-leur les valeurs des éléments du tableau que la fonction renverra." <br>  Voici à quoi ressemble la même chose en utilisant un objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fonctions imbriquées</font> </h2><br>  Les fonctions peuvent être déclarées à l'intérieur d'autres fonctions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br>  La portée d'une fonction imbriquée est limitée par une fonction extérieure à elle; elle ne peut pas être appelée de l'extérieur. <br><br><h2>  <font color="#3AC1EF">Méthodes d'objet</font> </h2><br>  Lorsque des fonctions sont utilisées comme propriétés d'objets, ces fonctions sont appelées méthodes d'objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">Ce mot-clé</font> </h2><br>  Si nous comparons la flèche et les fonctions ordinaires utilisées comme méthodes d'objets, nous pouvons trouver leur différence importante, qui consiste dans la signification du mot <code>this</code> clé <code>this</code> .  Prenons un exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br>  Comme vous pouvez le voir, appeler la méthode <code>start()</code> conduit au résultat attendu, mais la méthode <code>stop()</code> ne fonctionne évidemment pas correctement. <br><br>  Cela est dû au fait que le mot-clé this se comporte différemment lorsqu'il est utilisé dans les fonctions flèche et ordinaires.  A savoir, le <code>this</code> dans la fonction flèche contient un lien vers le contexte qui inclut la fonction.  Dans ce cas, lorsqu'il s'agit du navigateur, ce contexte est l'objet <code>window</code> . <br><br>  Voici à quoi ressemble l'exécution d'un tel code dans la console du navigateur. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">Ce mot-clé figure dans les fonctions conventionnelles et fléchées</font></i> <br><br>  Comme vous pouvez le voir, l'appeler dans une fonction régulière signifie appeler l'objet, et <code>this</code> dans la fonction flèche pointe vers la <code>window</code> . <br><br>  Tout cela signifie que les fonctions fléchées ne conviennent pas au rôle des méthodes objet et constructeur (si vous essayez d'utiliser la fonction flèche comme constructeur, une <code>TypeError</code> sera <code>TypeError</code> ). <br><br><h2>  <font color="#3AC1EF">Expressions fonctionnelles appelées immédiatement</font> </h2><br>  L'expression de fonction immédiatement invoquée (IIFE) est une fonction qui est appelée automatiquement immédiatement après sa déclaration. <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  Le point-virgule avant IIFE est facultatif, mais son utilisation vous permet de vous assurer contre les erreurs associées au placement automatique des points-virgules. <br><br>  Dans l'exemple ci-dessus, le mot <code>executed</code> ira à la console, après quoi l'IFEF quittera.  L'IFEF, tout comme les autres fonctions, peut restituer les résultats de son travail. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br>  Après avoir exécuté cet exemple simple, la console obtiendra la ligne <code>IIFE</code> , qui s'est avérée être <code>something</code> après avoir exécuté l'expression de fonction immédiatement appelée.  Il peut sembler que cette conception ne présente aucun avantage particulier.  Cependant, si dans l'IFEF certains calculs complexes sont effectués qui ne doivent être effectués qu'une seule fois, après quoi les mécanismes correspondants ne sont pas nécessaires - l'utilité de l'IFEF est évidente.  A savoir, avec cette approche, après l'exécution de IIFE, seul le résultat renvoyé par la fonction sera disponible dans le programme.  De plus, nous pouvons rappeler que les fonctions peuvent renvoyer d'autres fonctions et objets.  Nous parlons de fermetures, nous en parlerons ci-dessous. <br><br><h2>  <font color="#3AC1EF">Mise à niveau des fonctionnalités</font> </h2><br>  Avant que le code JavaScript ne soit exécuté, il est réorganisé.  Nous avons déjà parlé du mécanisme de hissage des variables déclarées à l'aide du mot-clé <code>var</code> .  Un mécanisme similaire fonctionne avec des fonctions.  À savoir, nous parlons du fait que les déclarations de fonctions au cours du traitement du code avant son exécution sont déplacées vers la partie supérieure de leur portée.  Par conséquent, par exemple, il s'avère que vous pouvez appeler la fonction avant qu'elle ne soit déclarée. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br>  Si vous déplacez un appel de fonction pour qu'il passe après sa déclaration, rien ne changera. <br><br>  Si, dans une situation similaire, une expression fonctionnelle est utilisée, un code similaire générera une erreur. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br>  Dans ce cas, il s'avère que bien que la déclaration de la variable <code>doSomething</code> monte en haut de l'étendue, cela ne s'applique pas à l'opération d'affectation. <br>  Si, au lieu de <code>var</code> , vous utilisez les mots clés <code>let</code> ou <code>const</code> dans une situation similaire, ce code ne fonctionnera pas non plus, cependant, le système affichera un message d'erreur différent ( <code>ReferenceError</code> plutôt que <code>TypeError</code> ), car lors de l'utilisation de <code>let</code> et <code>const</code> , les déclarations variables et constantes ne sont pas déclenchées. <br><br><h2>  <font color="#3AC1EF">Fonctions fléchées</font> </h2><br>  Nous allons maintenant parler davantage des fonctions fléchées que nous avons déjà rencontrées.  Ils peuvent être considérés comme l'une des innovations les plus importantes de la norme ES6, ils diffèrent des fonctions ordinaires non seulement par leur apparence, mais aussi par leur comportement.  De nos jours, ils sont très largement utilisés.  Il n'y a peut-être pas un seul projet moderne où ils ne seraient pas utilisés dans la grande majorité des cas.  Nous pouvons dire que leur apparence a changé à jamais l'apparence du code JS et les caractéristiques de son travail. <br><br>  D'un point de vue purement externe, la syntaxe de déclaration des fonctions fléchées est plus compacte que la syntaxe des fonctions ordinaires.  Voici la déclaration d'une fonction régulière. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Voici l'annonce de la fonction flèche, qui, en général, si vous ne tenez pas compte des caractéristiques des fonctions flèche, est similaire à la précédente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Si le corps d'une fonction flèche ne contient qu'une seule commande, dont le résultat renvoie cette fonction, elle peut être écrite sans accolades et sans le mot clé <code>return</code> .  Par exemple, une telle fonction renvoie la somme des arguments qui lui sont passés. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br>  Comme vous pouvez le voir, les paramètres des fonctions fléchées, comme dans le cas des fonctions ordinaires, sont décrits entre parenthèses.  De plus, si une telle fonction ne prend qu'un seul paramètre, elle peut être spécifiée sans parenthèses.  Par exemple, voici une fonction qui renvoie le résultat de la division du nombre qui lui est passé par 2. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br>  En conséquence, il s'avère que les fonctions fléchées sont très pratiques à utiliser dans les situations où de petites fonctions sont nécessaires. <br><br><h3>  <font color="#3AC1EF">▍ Retour implicite des résultats de la fonction</font> </h3><br>  Nous avons déjà abordé cette caractéristique des fonctions fléchées, mais elle est si importante qu'elle devrait être discutée plus en détail.  Nous parlons du fait que les fonctions flèches sur une seule ligne supportent le retour implicite des résultats de leur travail.  Un exemple de retour d'une valeur primitive d'une fonction de flèche sur une seule ligne que nous avons déjà vu.  Et si une telle fonction devait retourner un objet?  Dans ce cas, les accolades du littéral objet peuvent confondre le système, donc les parenthèses sont utilisées dans le corps de la fonction. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Mot-clé et fonctions fléchées</font> </h3><br>  Ci-dessus, lorsque nous avons examiné les fonctionnalités du <code>this</code> , nous avons comparé les fonctions régulières et les flèches.  Cette section est destinée à attirer votre attention sur l'importance de leurs différences.  Le <code>this</code> , en lui-même, peut entraîner certaines difficultés, car il dépend du contexte de l'exécution du code et de l'activation ou non du mode strict. <br><br>  Comme nous l'avons vu, lorsque vous utilisez le <code>this</code> dans une méthode d'un objet représenté par une fonction régulière, <code>this</code> pointe vers l'objet auquel appartient la méthode.  Dans ce cas, nous parlons de lier le mot <code>this</code> clé <code>this</code> à une valeur qui représente le contexte de la fonction.  En particulier, si une fonction est appelée en tant que méthode objet, le mot-clé this est lié à cet objet. <br><br>  Dans le cas des fonctions fléchées, il s'avère que la liaison n'est pas effectuée en elles; elles utilisent le <code>this</code> de leur portée.  Par conséquent, il n'est pas recommandé de les utiliser comme méthodes d'objet. <br><br>  Le même problème se produit lors de l'utilisation de fonctions comme gestionnaires d'événements pour les éléments DOM.  Par exemple, le <code>button</code> élément HTML <code>button</code> utilisé pour décrire les boutons.  L'événement <code>click</code> est <code>click</code> lorsqu'un utilisateur clique sur un bouton.  Pour répondre à cet événement dans le code, vous devez d'abord obtenir un lien vers l'élément correspondant, puis lui affecter un gestionnaire d'événements <code>click</code> tant que fonction.  En tant que tel gestionnaire, vous pouvez utiliser à la fois la fonction régulière et la fonction flèche.  Mais, si dans le gestionnaire d'événements vous devez accéder à l'élément pour lequel il est appelé (c'est-à-dire à <code>this</code> ), la fonction de flèche ne fonctionnera pas ici, car la valeur <code>this</code> disponible en elle pointe vers l'objet <code>window</code> .  Afin de tester cela en pratique, créez une page HTML dont le code est illustré ci-dessous et cliquez sur les boutons. <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Dans ce cas, lorsque vous cliquez sur ces boutons, des fenêtres contenant <code>true</code> apparaîtront.  Cependant, dans le gestionnaire d'événements <code>click</code> du bouton avec l'identifiant <code>fn</code> , l'égalité de <code>this</code> le bouton est vérifiée, et dans le bouton avec l'identifiant <code>arrowFn</code> l'égalité de <code>this</code> et l'objet de la <code>window</code> vérifiés. <br><br>  Par conséquent, si vous devez appeler <code>this</code> dans le gestionnaire d'événements de l'élément HTML, la fonction flèche ne fonctionnera pas pour la conception d'un tel gestionnaire. <br><br><h2>  <font color="#3AC1EF">Court-circuits</font> </h2><br>  Les fermetures sont un concept important en JavaScript.  En fait, si vous avez écrit des fonctions JS, vous avez également utilisé des fermetures.  Les fermetures sont utilisées dans certains modèles de conception - dans le cas où vous devez organiser un contrôle strict de l'accès à certaines données ou fonctions. <br><br>  Lorsqu'une fonction est appelée, elle a accès à tout ce qui est à la portée de l'extérieur.  Mais il n'y a pas d'accès à ce qui est déclaré à l'intérieur de la fonction.  Autrement dit, si une variable (ou une autre fonction) a été déclarée dans une fonction, elles sont inaccessibles au code externe, soit pendant l'exécution de la fonction, soit après l'achèvement de son travail.  Cependant, si une autre fonction est renvoyée par la fonction, cette nouvelle fonction aura accès à tout ce qui a été déclaré dans la fonction d'origine.  Dans ce cas, tout cela sera caché au code externe dans la fermeture. <br><br>  Prenons un exemple.  Voici une fonction qui prend le nom du chien, puis l'affiche dans la console. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  La valeur renvoyée par cette fonction ne nous intéresse pas encore, le texte est affiché dans la console en utilisant IIFE, qui dans ce cas ne joue pas de rôle particulier, cependant, cela nous aidera à voir la connexion entre cette fonction et sa variante, dans laquelle, au lieu d'appeler une fonction qui affiche texte à la console, nous retournerons cette fonction à partir de la fonction réécrite <code>bark()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  Le résultat du code dans deux cas est le même.  Mais dans le deuxième cas, ce qui a été transféré à la fonction d'origine lors de son appel (le nom du chien, <code>Roger</code> ) est stocké dans la fermeture, après quoi il est utilisé par une autre fonction revenue de l'original. <br><br>  Faisons une autre expérience - créez, en utilisant la fonction d'origine, deux nouvelles pour différents chiens. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br>  Ce code affichera les éléments suivants. <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br>  Il s'avère que la valeur de la constante constante est liée à la fonction renvoyée par la fonction <code>prepareBark()</code> . <br><br>  Notez que <code>say</code> , lorsque vous appelez à nouveau <code>prepareBark()</code> , il obtient une nouvelle valeur, tandis que la valeur enregistrée dans <code>say</code> première fois que <code>prepareBark()</code> appelée ne change pas.  Le fait est qu'à chaque appel à cette fonction, une nouvelle fermeture est créée. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Aujourd'hui, nous avons parlé des fonctions ordinaires et des flèches, des caractéristiques de leur déclaration et de leur utilisation, du comportement de <code>this</code> mot clé dans différentes situations et des fermetures.  La prochaine fois, nous discuterons des tableaux et des boucles. <br><br>  <b>Chers lecteurs!</b>  Que pensez-vous des fonctions flèches en JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430382/">https://habr.com/ru/post/fr430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430372/index.html">Voiture à hydrogène. Est-il temps de dire au revoir à l'essence?</a></li>
<li><a href="../fr430374/index.html">Ingénierie des données et plus encore: bandes vidéo Wrike et diapositives de la réunion</a></li>
<li><a href="../fr430376/index.html">Guide JavaScript, partie 6: exceptions, points-virgules, littéraux de modèle</a></li>
<li><a href="../fr430378/index.html">J2CL - Mieux vaut tard que jamais</a></li>
<li><a href="../fr430380/index.html">Guide JavaScript Partie 5: Tableaux et boucles</a></li>
<li><a href="../fr430384/index.html">Création de cartes à partir d'entités de bruit</a></li>
<li><a href="../fr430386/index.html">Construction d'une centrale de stockage à semi-conducteurs en Inde</a></li>
<li><a href="../fr430388/index.html">Conférence Web Summit</a></li>
<li><a href="../fr430392/index.html">Comment développer et tester des API avec mon «vélo» PieceofScript</a></li>
<li><a href="../fr430394/index.html">Implémentation de la recherche instantanée dans Android à l'aide de RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>