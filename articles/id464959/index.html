<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🍳 ☀️ 🌋 Mengurai kalimat bahasa Rusia 👨🏿‍🎤 👳 🔱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan proses penguraian kalimat bahasa Rusia menggunakan tata bahasa bebas konteks dan algoritma LR-analysis. 

 Pemrosesan bahasa a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengurai kalimat bahasa Rusia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464959/">  Artikel ini menjelaskan proses penguraian kalimat bahasa Rusia menggunakan tata bahasa bebas konteks dan algoritma LR-analysis. <br><br>  <b>Pemrosesan bahasa alami</b> adalah arah umum kecerdasan buatan dan linguistik matematika.  Ini mempelajari masalah analisis komputer dan sintesis bahasa alami. <br><br>  Secara umum, proses menganalisis kalimat bahasa alami adalah sebagai berikut: (1) memisahkan kalimat menjadi unit sintaksis - kata dan frasa;  (2) penentuan parameter tata bahasa setiap unit;  (3) definisi hubungan sintaksis antar unit.  Outputnya adalah pohon parsing abstrak. <br><a name="habracut"></a><br><h3>  1. Memisahkan kalimat menjadi unit sintaksis </h3><br>  Kalimat bahasa alami terdiri dari bentuk kata dan frasa yang kuat.  Sejumlah bentuk kata dari kata yang diberikan disebut paradigma. <br><br>  Sebagai contoh <br><br><pre><code class="plaintext hljs">  "": [, , , , ,  ]</code> </pre> <br>  Frasa - kata penghubung majemuk, predikat, atau ekspresi stabil - tidak berubah dan tidak dapat didekomposisi menjadi unit yang lebih kecil tanpa kehilangan makna.  Lebih jauh, dengan kata yang kami maksud adalah unit sintaksis - bentuk kata atau frasa. <br><br>  Setiap kata dalam kalimat ditentukan oleh tiga: <br><br><ol><li>  bentuk kata / kata string ("wrote") </li><li>  bentuk kata normal ("tulis") </li><li>  satu set parameter gramatikal (['KATA KERJA', 'bernyanyi', 'musc', 'tran', 'masa lalu']) </li></ol><br>  Dengan demikian, rincian kalimat " <i>Jelas, dia tidak akan datang ke pertemuan</i> " akan memiliki bentuk sebagai berikut: <br><br><pre> <code class="plaintext hljs">[' ', '', '', '', '', '']  ' ' -  , </code> </pre> <br><h3>  2. Definisi parameter gramatikal (tata bahasa) </h3><br>  <b>Gramme</b> adalah elemen dari kategori gramatikal;  tata bahasa yang berbeda dari kategori yang sama bersifat eksklusif dan tidak dapat diungkapkan bersama.  Untuk setiap bentuk kata, kami mendefinisikan satu set tujuh tata bahasa: <br><br><pre> <code class="plaintext hljs">[  , , , , , ,  ]</code> </pre> <br>  Sebagai sumber, kita akan menggunakan kamus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenCorpora</a> dan antarmuka-nya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pymorphy2</a> .  Untuk mencari aturan dalam tata bahasa untuk set gram yang diberikan, kami akan menyajikannya dalam bentuk umum: <br><br><pre> <code class="plaintext hljs"> '' [NOUN,plur,neut,accs] -&gt; [NOUN,?numb,?per,?gend,accs,None,None]  '?' ,      </code> </pre> <br><h3>  3. Definisi hubungan sintaksis antara kata-kata </h3><br>  Untuk menentukan hubungan sintaksis antara kata-kata, kita akan menggunakan tata bahasa bebas konteks dan analisis LR. <br><br><h4>  Analisis Tata Bahasa dan LR </h4><br>  <b>Tata bahasa formal</b> adalah cara menggambarkan bahasa dalam bentuk yang disebut produksi.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">a -&gt; ab | ac</code> </pre> <br>  berarti aturan 'a' menumbuhkan 'ab' ATAU 'ac'. <br><br>  <b>Nonterminals</b> adalah objek yang menunjukkan esensi dari bahasa (kalimat, formula, dll.).  <b>Terminal</b> - objek yang secara langsung hadir dalam bahasa yang sesuai dengan tata bahasa, dan memiliki makna yang spesifik dan tidak berubah (huruf, kata, rumus, dll.).  Tata bahasa bebas konteks adalah tata bahasa di mana sisi kiri semua produk adalah non-terminal tunggal. <br><br>  Untuk menggambarkan bahasa Rusia, kita akan menggunakan teori tata bahasa komponen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frase structure grammar</a> ), yang mengklaim bahwa setiap unit tata bahasa kompleks terdiri dari dua unit yang lebih sederhana dan tidak berpotongan, yang disebut komponen langsungnya.  Komponen-komponen berikut dibedakan: <br><br>  <b>(1) Kelompok Nominal (NP)</b> <br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; N[case='nomn'] | ADJ[case='nomn'] NP[case='nomn'] | …</code> </pre> <br>  Artinya, nomina nominaative nomina adalah nomina dalam nominative case ATAU kata sifat dalam nominative case + nominative nomina phrase ATAU other. <br><br>  <b>(2) Grup verbal (VP)</b> <br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='ablt'] | ADJ VP[tran] | …</code> </pre> <br>  Dengan kata lain, grup kata kerja transitif adalah kata kerja transitif + grup kata benda ablatif ATAU kata sifat pendek + grup kata kerja transitif ATAU yang lain. <br><br>  <b>(3) Grup Preposisi (PP)</b> <br><br><pre> <code class="plaintext hljs"> PP -&gt; PREP NP[case='datv'] | ...</code> </pre> <br>  Grup preposisi adalah preposisi + grup datif nominal ATAU yang lain. <br><br>  <b>(4) Penawaran penuh (S)</b> <br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre><br>  Sebuah kalimat lengkap ada jika dan hanya jika kelompok kata benda dan kata kerja dicocokkan dalam jumlah, orang dan jenis kelamin. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">agreement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node_left, node_right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> numb2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 != numb2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> per2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 != per2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> gend2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 != gend2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>;</code> </pre><br>  Kalimat yang tidak lengkap adalah kalimat di mana bagian nominal dihilangkan.  Sebagai aturan, dalam kalimat seperti itu, kata kerja grup diekspresikan oleh kata kerja impersonal.  Misalnya, " <i>Saya ingin berjalan</i> ," "Sudah <i>mulai terang</i> ."  Kalimat berbentuk bulat panjang adalah kalimat di mana bagian kata kerjanya dihilangkan, digantikan oleh tanda hubung.  Misalnya, " <i>Di belakang belakang adalah hutan. Ke kanan dan kiri adalah rawa-rawa</i> ." <br><br>  Untuk menentukan apakah kalimat ini milik bahasa tata bahasa, kami akan menggunakan algoritma analisis LR.  Algoritma ini melibatkan konstruksi pohon parsing dari bawah ke atas (dari daun ke akar).  Elemen kunci dari algoritma ini adalah metode "transfer-convolution" ( <i>pengurangan shift</i> Inggris): <br><br>  (1) kita membaca karakter dari jalur input sampai ada rantai yang cocok dengan sisi kanan aturan mana pun, letakkan rantai yang ditemukan di tumpukan (transfer); <br>  (2) mengganti rantai yang ditemukan oleh aturan dari tata bahasa (konvolusi). <br><br>  Jika semua rantai tali telah dibungkus, maka kalimat ini milik bahasa tata bahasa, dan setidaknya ada satu pohon parse. <br><br>  <b>Pohon</b> <br><br>  Untuk mewakili koneksi sintaksis, kalimat menggunakan pohon biner, di mana daun adalah kata-kata (terminal) dengan seperangkat gram, dan simpulnya adalah aturan (preterminal).  Akar adalah kalimat (non-terminal). <br><br>  Node pohon didefinisikan sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word=None, tag=None, grammemes=None, leaf=False)</span></span></span><span class="hljs-function">:</span></span> self.word = word; <span class="hljs-comment"><span class="hljs-comment">#   self.tag = tag; #   - ,      self.grammemes = grammemes; #   self.leaf = leaf; self.l = None; self.r = None; self.p = None;</span></span></code> </pre><br>  Konstruksi pohon dimulai dengan dedaunan, yang diberi serangkaian kata atau frasa, serta seperangkat tata bahasanya. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, sent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sent: new_node = Node(word[<span class="hljs-number"><span class="hljs-number">0</span></span>], word[<span class="hljs-number"><span class="hljs-number">1</span></span>], word[<span class="hljs-number"><span class="hljs-number">2</span></span>], leaf=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) self.nodes.append(new_node)</code> </pre> <br>  Selanjutnya, analisis LR dilakukan.  Setiap konvolusi sesuai dengan penyatuan dua simpul atau daun di bawah leluhur yang sama.  Node leluhur diberikan tag preterminal yang sesuai dengan aturan tata bahasa, di samping itu, leluhur menerima tata bahasa dari anggota utama grup, misalnya, dalam grup kata kerja V [tran] PRCL (misalnya <i>"ingin"</i> ) tanda-tanda akan diambil dari kata kerja transitif V [tran], dan bukan dari partikel PRCL;  dan dalam grup kata benda NP [case = 'nomn'] NP [case = 'gent'] (misalnya <i>“bapak anak-anak”</i> ) tanda-tanda akan diambil dari kata benda dalam nominatif. <br><br>  Penting untuk dicatat bahwa konvolusi terjadi dalam urutan yang ditetapkan: <br><br><pre> <code class="plaintext hljs"> def reduce(self): self.reduce_ADJ() #  self.reduce_NP() #   self.reduce_PP() #  self.reduce_VP() #  self.reduce_S() #    </code> </pre><br>  Urutan ini penting karena tidak termasuk kemungkinan "kehilangan" beberapa anggota proposal.  Pertama, kata sifat dibentuk bersama-sama dengan pengubah (misalnya <i>sangat indah</i> ), kemudian kelompok nominal, preposisi dan akhirnya verbal.  Setelah itu, ada pencarian untuk kalimat lengkap / tidak lengkap, jika tidak ada, maka pohon itu tidak memiliki akar, dan oleh karena itu kalimat itu bukan milik bahasa tata bahasa. <br><br>  Pertimbangkan contoh kondisional untuk membangun pohon: <br><br><pre> <code class="plaintext hljs">sent = "    " def build(self, sent): for word in sent: new_node = Node(word[0], word[1], word[2], leaf=True) self.nodes.append(new_node)</code> </pre><br><img src="https://habrastorage.org/webt/dv/os/q2/dvosq2enl-vsvwnoif2ikvwspqw.png"><br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; NPRO[case='nomn'] NP[case='accs'] -&gt; N[case='accs'] NP[case='datv'] -&gt; ADJ[case='datv'] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/zo/dp/3i/zodp3iqmbp3-v7mheec_rd2d_gy.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='accs']</code> </pre> <br><img src="https://habrastorage.org/webt/ez/9a/jk/ez9ajkpo58rfxtnsqt3o0ij2las.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; VP[tran] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/w3/0y/m_/w30ym_ey2ehicxufasvky3vml4w.png"><br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre> <br><img src="https://habrastorage.org/webt/wg/f_/xw/wgf_xw3qoj9dhpk8nvhjztzhqlu.png"><br><br>  Contoh spesifik dari penguraian kalimat dua bagian: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> analyzer parser = analyzer.Parser() sent = <span class="hljs-string"><span class="hljs-string">"  ,     ."</span></span> t = parser.parse(sent) t[<span class="hljs-number"><span class="hljs-number">0</span></span>].display() S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'datv'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'datv'</span></span>] S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] PP PREP  [<span class="hljs-string"><span class="hljs-string">'PREP'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'ablt'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'ablt'</span></span>] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>]</code> </pre> <br><h3>  Masalahnya </h3><br>  Bahasa alami bersifat ambigu, pemahamannya tergantung pada sejumlah faktor - pada fitur struktur tata bahasa, pada budaya nasional, pada pembicara, dll.  Kami mencantumkan masalah utama pemrosesan bahasa mesin. <br><br><ol><li>  Pengungkapan anafora.  Seseorang yang hidup memahami anafora berdasarkan akal sehat dan konteks, tetapi bagi komputer ini jelas tidak selalu mudah. </li><li>  Homonim adalah kebetulan dalam bunyi dan ejaan unit linguistik yang maknanya tidak terkait satu sama lain.  Salah satu solusinya adalah metode probabilistik.  Dalam kalimat " <i>Saya tahu ini dengan baik,</i> " kemungkinan bahwa " <i>ini</i> " adalah kata ganti dan bukan partikel akan lebih besar.  Metode semacam itu membutuhkan penutup yang cukup besar. </li><li>  Urutan kata-kata bebas mengarah pada fakta bahwa penafsiran kalimat mungkin ambigu.  Misalnya, “ <i>Menjadi menentukan kesadaran</i> ” - apa yang menentukan apa?  Di Rusia, urutan kata gratis dikompensasi oleh morfologi, kata layanan dan tanda baca yang dikembangkan, tetapi dalam kebanyakan kasus untuk komputer ini menimbulkan masalah tambahan. </li><li>  Tidak semua orang menulis dengan benar.  Di internet, orang cenderung menggunakan singkatan, neologisme, elips, dan hal-hal lain yang mungkin bertentangan dengan norma sastra.  Karena itu, penggunaan tata bahasa dan kamus bebas konteks tidak selalu memungkinkan. </li></ol><br><h4>  Kesimpulan </h4><br>  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tersedia</a> untuk digunakan dan diedit.  Ini berisi alat analisis itu sendiri, pohon parse, serta tata bahasa Rusia dan tata bahasa Rusia dan kamus kecil gabungan serikat pekerja dan predikat yang tidak ada dalam kamus OpenCorpora.  Saat ini, untuk kalimat yang panjang dan rumit, parser dapat menemukan 3 atau lebih pohon, untuk menyelesaikan masalah ini, perubahan dilakukan pada tata bahasa, dan juga direncanakan untuk menggunakan metode probabilistik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464959/">https://habr.com/ru/post/id464959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464939/index.html">Menguji @ NonNull / @ Nullable annotations</a></li>
<li><a href="../id464947/index.html">Acara digital di Moskow dari 25 Agustus hingga 1 September</a></li>
<li><a href="../id464949/index.html">Sekali lagi tentang GCD, algoritma Euclidean dan sedikit tentang sejarah algoritma secara umum. Tentu saja dengan contoh Swift</a></li>
<li><a href="../id464951/index.html">Semakin sederhana tugasnya, semakin sering saya salah</a></li>
<li><a href="../id464955/index.html">Iron Mike Tyson dan proyek blockchain Fight to Fame</a></li>
<li><a href="../id464961/index.html">Buat komponen visual dalam Unity UI. Sistem partikel</a></li>
<li><a href="../id464963/index.html">Dengan cepat melokalkan masalah kinerja Microsoft SQL Server di Quest Foglight</a></li>
<li><a href="../id464965/index.html">Frontend Weekly Digest (19 - 25 Agustus 2019)</a></li>
<li><a href="../id464967/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 377 (19 - 25 Agustus 2019)</a></li>
<li><a href="../id464969/index.html">CRISPR memberi Anda kesempatan untuk menyelamatkan seseorang dari rasa sakit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>