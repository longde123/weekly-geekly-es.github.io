<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏭️ 🐡 👂 Lisensi untuk mengendarai mobil, atau mengapa aplikasi harus Single-Activity 🏗️ 🦋 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di AppsConf 2018 , yang berlangsung pada 8-9 Oktober, saya membuat presentasi tentang pembuatan aplikasi android dalam satu Kegiatan. Meskipun topikny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lisensi untuk mengendarai mobil, atau mengapa aplikasi harus Single-Activity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/426617/"><p><img src="https://habrastorage.org/webt/n0/m4/p4/n0m4p4tyrh-7bky85jet7jyzllc.png" alt="gambar"></p><br><p>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf 2018</a> , yang berlangsung pada 8-9 Oktober, saya membuat presentasi tentang pembuatan aplikasi android dalam satu Kegiatan.  Meskipun topiknya terkenal, ada banyak prasangka mengenai pilihan seperti itu - ruang yang penuh sesak dan jumlah pertanyaan setelah pidato mengkonfirmasi hal ini.  Agar tidak menunggu rekaman video, saya memutuskan untuk membuat artikel dengan transkrip pidato. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1b8/c2d/a29/1b8c2da294869720e98d50d529300817.jpg"></p><br><p>  Apa yang akan saya katakan </p><br><ol><li>  Mengapa dan mengapa saya harus beralih ke Aktivitas Tunggal </li><li>  Pendekatan universal untuk menyelesaikan tugas yang biasa Anda selesaikan pada beberapa Kegiatan </li><li>  Contoh tugas bisnis standar </li><li>  Kemacetan di mana kode biasanya disangga alih-alih melakukan semuanya dengan jujur </li></ol><a name="habracut"></a><br><h2 id="pochemu-single-activity---eto-pravilno">  Mengapa Kegiatan Tunggal Benar? </h2><br><h4 id="zhiznennyy-cikl">  Siklus hidup </h4><br><p><img src="https://habrastorage.org/webt/6i/k8/fk/6ik8fkusqlvahretkm_yqfhfgg8.png"></p><br><p>  Semua pengembang android mengetahui skema mulai dingin dari aplikasi.  Pertama, onCreate dipanggil pada kelas Aplikasi, kemudian siklus hidup Aktivitas pertama mulai berlaku. <br>  Jika ada beberapa Aktivitas dalam aplikasi kita (dan ada sebagian besar aplikasi semacam itu), berikut ini terjadi: </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">App</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onPause</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStop</span></span>()</code> </pre> <br><p>  Ini adalah aktivitas abstrakB log peluncuran dari ActivityA.  Baris kosong adalah saat ketika peluncuran layar baru dipanggil.  Sekilas, semuanya baik-baik saja.  Tetapi jika kita beralih ke dokumentasi, menjadi jelas: untuk memastikan bahwa layar terlihat oleh pengguna dan bahwa dia dapat berinteraksi dengannya, itu hanya mungkin setelah memanggil <code>onResume</code> di setiap layar: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">App</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">--------</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onPause</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">--------</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStop</span></span>()</code> </pre> <br><p>  Masalahnya adalah log semacam itu tidak membantu untuk memahami siklus hidup aplikasi.  Ketika pengguna masih di dalam, dan ketika dia sudah beralih ke aplikasi lain atau meminimalkan kita dan sebagainya.  Dan ini diperlukan <strong>ketika kita ingin mengikat logika bisnis ke LC aplikasi, misalnya, menjaga koneksi soket saat pengguna berada dalam aplikasi dan menutupnya ketika keluar</strong> </p><br><p>  Dalam aplikasi Aktivitas Tunggal, semuanya sederhana - Aktivitas LC menjadi aplikasi LC.  Semua yang Anda butuhkan untuk logika apa pun mudah untuk mengikat ke keadaan aplikasi. </p><br><h4 id="zapusk-ekranov">  Luncurkan layar </h4><br><p>  Sebagai pengguna, saya sering menemukan fakta bahwa panggilan dari buku telepon (yang jelas merupakan peluncuran Kegiatan terpisah) tidak terjadi setelah mengklik pada kontak.  Tidak jelas apa hubungannya dengan hal ini, tetapi mereka yang saya coba gagal tidak berhasil mengatakan mereka menerima panggilan dan mendengar suara langkah.  Pada saat yang sama, ponsel cerdas saya sudah lama berada di saku. </p><br><p><img src="https://habrastorage.org/webt/iq/u5/kx/iqu5kxfhylvhmqh5wzuwvqpztzi.png"></p><br><p>  Masalahnya adalah bahwa memulai suatu Aktivitas adalah proses yang sepenuhnya tidak sinkron!  Tidak ada jaminan untuk memulai instan, dan lebih buruk lagi, kami tidak dapat mengontrol prosesnya.  Tentu saja </p><br><p>  Dalam aplikasi Aktivitas Tunggal, bekerja dengan manajer fragmen, kita dapat mengontrol prosesnya. <br>  <code>transaction.commit()</code> - akan mengganti layar secara tidak sinkron, yang memungkinkan Anda untuk membuka atau menutup beberapa layar sekaligus. <br>  <code>transaction.commitNow()</code> - mengalihkan layar secara sinkron, jika Anda tidak perlu menambahkannya ke tumpukan. <br>  fragmentManager.executePendingTransactions () `memungkinkan Anda untuk melakukan semua transaksi yang diluncurkan sebelumnya sekarang. </p><br><h4 id="analiz-steka-ekranov">  Analisis tumpukan layar </h4><br><p>  Bayangkan bahwa logika bisnis aplikasi Anda bergantung pada kedalaman tumpukan layar saat ini (misalnya, pembatasan bersarang).  Atau, pada akhir beberapa proses, Anda harus kembali ke layar tertentu, dan jika ada beberapa yang identik, ke yang paling dekat dengan root (awal rantai). <br>  Bagaimana cara mendapatkan setumpuk Aktivitas?  Parameter apa yang harus ditentukan saat memulai layar? </p><br><p><img src="https://habrastorage.org/webt/pk/bz/5h/pkbz5hhcjv_gqiyirr7ab5e27h8.png"></p><br><p>  Omong-omong, tentang keajaiban opsi peluncuran Aktivitas: </p><br><ul><li>  Anda dapat menentukan bendera peluncuran di Intent (dan juga mencampurnya bersama-sama, dan mengubahnya dari tempat yang berbeda); </li><li>  Anda dapat menambahkan parameter peluncuran di manifes, karena semua Kegiatan harus dijelaskan di sana; </li><li>  tambahkan filter Intent di sini untuk menangani pemicu eksternal; </li><li>  dan akhirnya pikirkan MultiTasks, ketika Activities dapat berjalan di "tugas" yang berbeda. </li></ul><br><p>  Bersama-sama, ini menciptakan kebingungan dan masalah dengan debugging dukungan.  Anda tidak pernah bisa mengatakan dengan pasti bagaimana layar diluncurkan, dan bagaimana hal itu memengaruhi tumpukan. </p><br><p>  Dalam aplikasi Aktivitas Tunggal, semua layar hanya beralih melalui transaksi fragmen.  Anda dapat menganalisis tumpukan layar saat ini dan transaksi tersimpan. <br>  Dalam demo perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cicerone</a> , Anda dapat melihat bagaimana status tumpukan saat ini ditampilkan di bilah alat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/45f/285/af2/45f285af219d69df32d0994db1eeb58d.gif" alt="gambar"></p><br><p>  <em>Catatan:</em> di versi terbaru, perpustakaan dukungan memblokir akses ke array fragmen di dalam manajer fragmen, tetapi jika Anda benar-benar ingin, masalah ini selalu dapat diselesaikan. </p><br><h4 id="activity-tolko-odna-na-ekrane">  Hanya satu aktivitas di layar </h4><br><p>  Dalam aplikasi nyata, kita pasti perlu menggabungkan layar "logis" dalam satu Aktivitas, maka Anda tidak dapat menulis aplikasi HANYA di Aktivitas.  Dualitas dari pendekatan itu selalu buruk, karena masalah yang sama dapat diselesaikan dengan cara yang berbeda (di suatu tempat, tata letaknya secara langsung dalam Kegiatan, dan di suatu tempat, Kegiatan itu hanya sebuah wadah). </p><br><h4 id="dont-keep-activities">  Jangan terus beraktifitas </h4><br><p>  Bendera untuk pengujian ini benar-benar memungkinkan Anda menemukan beberapa bug dalam aplikasi, tetapi perilaku yang dihasilkannya <strong>TIDAK PERNAH</strong> terjadi pada kenyataannya!  Itu tidak terjadi bahwa proses aplikasi tetap, dan pada saat itu Aktivitas, meskipun tidak aktif, mati!  Aktivitas hanya bisa mati dengan proses aplikasi.  Jika aplikasi ditampilkan kepada pengguna, dan sistem tidak memiliki sumber daya yang cukup, semua yang ada di sekitar akan mati (aplikasi tidak aktif lainnya, layanan, dan bahkan peluncur), dan aplikasi Anda akan hidup sampai akhir yang pahit, dan jika harus mati, maka itu akan menjadi seluruhnya. <br>  Anda bisa mengeceknya. </p><br><h4 id="nasledie">  Warisan </h4><br><p>  Secara historis, ada sejumlah besar logika yang tidak perlu dalam Aktivitas yang kemungkinan besar tidak berguna bagi Anda.  Misalnya, semua yang Anda butuhkan untuk bekerja dengan <code>loaders</code> , <code>actionBar</code> , <code>action menu</code> dan sebagainya.  Ini membuat kelas itu sendiri cukup besar dan berat. </p><br><h4 id="animacii">  Animasi </h4><br><p>  Mungkin, siapa pun dapat membuat animasi pergeseran sederhana saat beralih di antara Aktivitas.  Di sini perlu diperjelas bahwa Anda perlu membuat diskon pada sinkronisasi Sinkronisasi dari aktivitas, yang telah kita bicarakan sebelumnya. <br>  Jika Anda membutuhkan sesuatu yang lebih menarik, Anda dapat mengingat contoh animasi transisi yang dibuat di Activity: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62f/b33/b28/62fb33b285f8eb80ff856c813e278552.gif" alt="gambar"></p><br><p>  Tetapi ada masalah besar: menyesuaikan animasi ini hampir tidak mungkin.  Ini tidak mungkin menyenangkan para desainer dan pelanggan. </p><br><p>  Dengan fragmen, semuanya berbeda.  Kita dapat langsung menuju ke tingkat hierarki tampilan dan membuat animasi apa pun yang dapat Anda bayangkan!  Bukti langsung di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/446/23f/e72/44623fe72553a5f7ba0b0074c45109eb.gif" alt="gambar"></p><br><p>  Jika Anda melihat kode sumber, Anda akan menemukan bahwa ini dilakukan pada tata letak biasa.  Ya, kodenya layak di sana, tetapi animasi selalu cukup sulit, dan memiliki kesempatan seperti itu selalu merupakan nilai tambah.  Jika Anda memiliki dua Kegiatan yang diaktifkan, maka aplikasi tidak memiliki wadah umum tempat Anda dapat melakukan transisi tersebut. </p><br><h4 id="izmenenie-konfiguracii-naletu">  Ubah konfigurasi dengan cepat </h4><br><p>  Poin ini tidak dalam pidato saya, tetapi juga sangat penting.  Jika Anda memiliki fitur dengan mengalihkan bahasa di dalam aplikasi, maka dengan beberapa Kegiatan akan cukup bermasalah untuk mengimplementasikannya, jika, antara lain, Anda tidak perlu memulai ulang aplikasi, tetapi tetap di tempat yang sama di mana pengguna pada saat memanggil fungsi. </p><br><p>  Dalam aplikasi Aktivitas Tunggal, cukup mengubah lokal yang dipasang dalam konteks aplikasi dan memanggil <code>recreate()</code> pada Aktivitas, seluruh sistem akan melakukan semuanya sendiri. </p><br><h4 id="naposledok">  Pada akhirnya </h4><br><p>  Google memiliki solusi navigasi, dokumentasi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara eksplisit menyatakan</a> bahwa disarankan untuk menulis aplikasi Aktivitas Tunggal. </p><br><p>  Pada titik ini, saya harap Anda tidak ragu bahwa pendekatan klasik dengan beberapa Kegiatan berisi sejumlah kekurangan, yang biasanya menutup mata, bersembunyi di balik tren umum ketidakpuasan Android. </p><br><h2 id="esli-vse-tak-to-pochemu-single-activity-esche-ne-standart-razrabotki">  Jika demikian, mengapa Single-Activity belum menjadi standar pengembangan? </h2><br><p>  Di sini saya akan mengutip teman baik saya: </p><br><p><img src="https://habrastorage.org/webt/z_/k_/ou/z_k_outvwlcibszeamtv2jhjst0.png"></p><br><p>  Memulai proyek serius baru, pimpinan apa pun takut untuk melakukan kesalahan dan menghindari keputusan yang berisiko.  Ini benar  Tetapi saya akan mencoba memberikan rencana komprehensif untuk transisi ke Kegiatan Tunggal. </p><br><h4 id="perehod-na-single-activity">  Beralih ke Aktivitas Tunggal </h4><br><p><img src="https://habrastorage.org/webt/vf/sw/8h/vfsw8hvr_sfcjs3olaxb3s2lptw.png"></p><br><p>  Jika Anda mempelajari aplikasi ini, Anda dapat menentukan dari animasi karakteristik dan perilaku yang tertulis di beberapa Kegiatan.  Saya bisa saja salah, dan semuanya dilakukan bahkan pada tampilan kustom, tetapi ini tidak akan mempengaruhi alasan kami. </p><br><p>  Sekarang perhatian!  Kami melakukannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/0v/dt/cm/0vdtcmkom7y0jt0osv3fj61wn4k.png"></p><br><p>  Kami hanya membuat dua perubahan: kami menambahkan kelas AppActivity dan mengganti semua Kegiatan dengan FlowFragment.  Pertimbangkan setiap perubahan lebih terinci. </p><br><p>  Apa yang <strong>ditanggung oleh AppActivity</strong> untuk: </p><br><ul><li>  hanya berisi wadah untuk fragmen <br><ul><li>  adalah titik inisialisasi objek Lingkup UI (dulu dilakukan dalam Aplikasi, yang salah, karena, misalnya, objek Layanan dalam aplikasi kita pasti tidak memerlukan objek seperti itu) </li><li>  adalah penyedia aplikasi </li><li>  membawa semua manfaat Aktivitas Tunggal. </li></ul></li></ul><br><p>  Apa itu <strong>FlowFragment</strong> : </p><br><ul><li>  melakukan hal yang persis sama dengan Kegiatan, alih-alih yang dibuat. </li></ul><br><h4 id="novaya-navigaciya">  Navigasi baru </h4><br><p>  Perbedaan utama dari pendekatan lama adalah navigasi. </p><br><p><img src="https://habrastorage.org/webt/6c/xe/xm/6cxexm9iv1rxz4p9ag1hov7jb90.png"></p><br><p>  Sebelumnya, pengembang punya pilihan: meluncurkan Aktivitas baru atau transaksi fragmen di saat ini.  Pilihannya belum hilang, tetapi metode telah berubah - sekarang kita perlu memutuskan apakah akan memulai fragmentasi fragmen di AppActivity atau di dalam FlowFragment saat ini. </p><br><p><img src="https://habrastorage.org/webt/am/cq/ac/amcqacvs343ah96hpnaykgnixtw.png"></p><br><p>  Begitu pula dengan pemrosesan tombol Back.  Sebelumnya, Kegiatan meneruskan acara ke fragmen saat ini, dan jika tidak memprosesnya, ia membuat keputusan sendiri.  Sekarang AppActivity meneruskan acara ke FlowFragment saat ini, dan itu, pada gilirannya, meneruskannya ke fragmen saat ini. </p><br><h4 id="peredacha-rezultata-mezhdu-ekranami">  Mentransfer hasil antar layar </h4><br><p>  Untuk pengembang yang tidak berpengalaman, masalah mentransfer data antar layar adalah masalah utama dari pendekatan baru, karena sebelumnya dimungkinkan untuk menggunakan fungsionalitas startActivityForResult ()! </p><br><p>  Bukan tahun pertama, berbagai pendekatan arsitektur untuk menulis aplikasi telah dibahas.  Tugas utama pada saat yang sama tetap pemisahan UI dan lapisan data dan logika bisnis.  Dari sudut pandang ini, startActivityForResult () memecah kanon, karena data antara layar dari <strong>satu</strong> aplikasi ditransmisikan pada sisi entitas dari lapisan UI.  Saya menekankan bahwa ini hanya <strong>satu</strong> aplikasi, karena kami memiliki lapisan data umum, model umum dalam lingkup global, dan sebagainya.  Kami tidak menggunakan peluang ini dan mengarahkan diri kami ke dalam kerangka satu Bundel (serialisasi, ukuran, dan lainnya). <br>  <strong>Saran saya</strong> : jangan gunakan startActivityForResult () di dalam aplikasi!  Gunakan hanya untuk tujuan yang dimaksudkan - untuk menjalankan aplikasi eksternal dan mendapatkan hasil darinya. </p><br><p>  Lalu bagaimana cara meluncurkan layar dengan pilihan untuk layar lain?  Ada tiga opsi: </p><br><ol><li>  Targetfragment </li><li>  Eventbus </li><li>  model jet </li></ol><br><p>  TargetFragment - opsi "out of the box", tetapi transfer data yang sama di sisi lapisan UI.  <strong>Opsi yang salah.</strong> </p><br><p>  EventBus - jika Anda dapat menyetujui tim dan - yang paling penting - mengontrol pengaturan, maka Anda dapat mengimplementasikan transfer data antar layar pada bus data global.  Tetapi karena ini adalah langkah berbahaya, kesimpulannya adalah <strong>opsi yang buruk.</strong> </p><br><p>  Model reaktif - pendekatan ini menyiratkan adanya panggilan balik dan banyak lagi.  Bagaimana Anda menerapkannya diputuskan oleh tim dari setiap proyek.  Tetapi pendekatan ini optimal, karena memberikan kontrol atas apa yang terjadi dan tidak memungkinkan kode untuk digunakan untuk tujuan lain.  <strong>Pilihan kita!</strong> </p><br><h4 id="itog">  Ringkasan </h4><br><p>  Saya suka pendekatan baru ketika mereka sederhana dan memiliki manfaat yang jelas.  Saya harap ini adalah kasusnya.  Manfaatnya dijelaskan pada bagian pertama, dan Anda harus menilai kesulitannya.  Sudah cukup untuk mengganti semua Kegiatan dengan FlowFragment, menjaga semua logikanya tidak berubah.  Ubah sedikit kode navigasi dan pikirkan untuk bekerja dengan transfer data antar layar, jika belum dilakukan. </p><br><p>  Untuk menunjukkan kesederhanaan pendekatannya, saya sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengalihkan aplikasi terbuka</a> ke Aktivitas Tunggal, dan hanya butuh beberapa jam (tentu saja, layak untuk mempertimbangkan bahwa ini bukan warisan kuno, dan semuanya kurang lebih baik dengan arsitektur di sana). </p><br><h2 id="chto-poluchilos">  Apa yang terjadi </h2><br><p>  Mari kita lihat bagaimana menyelesaikan masalah standar dalam pendekatan baru. </p><br><h4 id="bottomnavigationbar-i-navigationdrawer">  BottomNavigationBar dan NavigationDrawer </h4><br><p>  Menggunakan aturan sederhana yang kami ganti semua Kegiatan dengan FlowFragment, menu samping sekarang akan berada di beberapa fragmen dan beralih fragmen bersarang di dalamnya: </p><br><p><img src="https://habrastorage.org/webt/hp/dv/u9/hpdvu9gp85_zzzt2qi23ndafrxw.png"></p><br><p>  Mirip dengan BottomNavigationBar. <br>  Jauh lebih menarik bahwa kita dapat menginvestasikan beberapa FlowFragment pada yang lain, karena ini masih merupakan fragmen biasa! </p><br><p><img src="https://habrastorage.org/webt/vk/qo/2r/vkqo2rovrabjb_2qorv-ot6leie.png"></p><br><p>  Opsi ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitFox</a> . </p><br><p>  Ini adalah kemungkinan hanya dengan menggabungkan beberapa fragmen di dalam yang lain yang memungkinkan untuk membuat UI dinamis untuk perangkat yang berbeda tanpa masalah: tablet + smartphone. </p><br><h4 id="di-skoupy">  Lingkup DI </h4><br><p>  Jika Anda memiliki aliran pembelian produk dari beberapa layar, dan Anda perlu menunjukkan nama produk di setiap layar, Anda mungkin sudah memasukkan ini ke dalam Kegiatan terpisah yang menyimpan produk dan menyediakannya ke layar. <br>  Ini akan sama dengan FlowFragment - ini akan berisi skala DI dengan model untuk semua layar bersarang.  Pendekatan ini menghilangkan kontrol rumit dari masa hidup lingkup dengan mengikatnya ke masa hidup FlowFragment. </p><br><p><img src="https://habrastorage.org/webt/jg/o7/fc/jgo7fcldgytixv_pi4rd4vv9ynw.png"></p><br><h4 id="deep-links">  Tautan dalam </h4><br><p>  Jika Anda menggunakan filter dalam manifes untuk meluncurkan layar spesifik pada tautan dalam, Anda mungkin memiliki masalah dalam memulai Kegiatan, yang saya tulis di bagian pertama.  Dalam pendekatan baru, semua tautan dalam masuk ke AppActivity.onNewIntent.  Selanjutnya, menurut data yang diperoleh, ada transisi ke layar yang diperlukan (atau rantai layar. Saya mengusulkan untuk melihat <a href="">fungsi</a> seperti itu <a href="">di Chicheron</a> ). </p><br><p><img src="https://habrastorage.org/webt/hg/hv/dz/hghvdzuz1kp_zaj_mqqxwgbbmk0.png"></p><br><h4 id="smert-processa">  Proses kematian </h4><br><p>  Jika aplikasi ditulis pada beberapa Aktivitas, Anda harus tahu bahwa ketika aplikasi mati, dan kemudian ketika proses dikembalikan, pengguna akan berada di Aktivitas terakhir, dan semua yang sebelumnya akan dipulihkan hanya ketika mereka dikembalikan kepada mereka. </p><br><p><img src="https://habrastorage.org/webt/za/39/ws/za39wsenkveryhdk21ngp0w-hyq.png"></p><br><p>  Jika Anda tidak mempertimbangkan ini sebelumnya, masalah mungkin timbul.  Misalnya, jika ruang lingkup yang diperlukan pada Aktivitas terakhir dibuka pada sebelumnya, tidak ada yang akan membuatnya kembali.  Apa yang harus dilakukan  Bawa ini ke kelas Aplikasi?  Apakah banyak titik membuka lingkup? </p><br><p>  Semuanya lebih sederhana dengan fragmen, karena mereka berada di dalam suatu Kegiatan atau FlowFragment lain, dan wadah apa pun akan dipulihkan SEBELUM membuat ulang fragmen. </p><br><p><img src="https://habrastorage.org/webt/8p/vd/q5/8pvdq5nmwbgjbfi6am26nzotpnq.png"></p><br><p>  Kita dapat membahas tugas-tugas praktis lainnya dalam komentar, karena kalau tidak, ada kemungkinan bahwa artikel tersebut akan menjadi terlalu banyak. </p><br><p>  Dan sekarang bagian yang paling menarik. </p><br><h2 id="uzkie-mesta-nado-pomnit-i-dumat">  Kemacetan (Anda perlu mengingat dan berpikir). </h2><br><p>  Berikut ini dikumpulkan hal-hal penting yang harus Anda pikirkan dalam proyek apa pun, tetapi semua orang terbiasa "merobeknya" dalam proyek pada beberapa Kegiatan sehingga perlu diingat kembali dan diceritakan bagaimana menyelesaikannya dengan benar dalam pendekatan baru.  Dan pertama dalam daftar </p><br><h4 id="povorot-ekrana">  Rotasi layar </h4><br><p>  Itu adalah <u>kisah yang</u> paling <u>mengerikan</u> bagi penggemar rengekan bahwa Android menciptakan kembali Aktivitas ketika layar diputar.  Metode solusi yang paling populer adalah untuk memperbaiki orientasi potret.  Selain itu, proposal ini tidak lagi dibuat oleh pengembang, tetapi oleh manajer yang takut dengan frasa seperti " <em>mempertahankan belokan sangat sulit dan biaya beberapa kali lebih banyak</em> ." <br>  Kami tidak akan berdebat tentang kebenaran keputusan semacam itu.  Hal lain yang penting: <strong>memperbaiki rotasi tidak dibebaskan dari kematian Aktivitas!</strong>  Karena proses yang sama terjadi dengan banyak peristiwa lain: mode split, ketika beberapa aplikasi ditampilkan di layar, menghubungkan monitor eksternal, mengubah konfigurasi aplikasi dengan cepat dan sebagainya. </p><br><p>  Selain itu, rotasi layar memungkinkan Anda untuk memeriksa "kekakuan" tata letak yang benar, jadi di tim St. Petersburg kami, kami tidak mematikan rotasi di semua majelis penjualan, bahkan jika itu tidak ada dalam versi rilis.  Belum lagi bug khas yang masih akan ditemukan saat verifikasi. </p><br><p>  Banyak solusi telah ditulis untuk berbelok, mulai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moxy</a> dan diakhiri dengan berbagai implementasi MVVM.  Buat tidak lebih sulit dari yang lainnya. </p><br><p>  Pertimbangkan kasus menarik lainnya. <br>  Bayangkan aplikasi katalog produk.  Kami melakukannya di Aktivitas Tunggal.  Di mana-mana mode potret diperbaiki, tetapi pelanggan menginginkan fitur ketika, saat melihat galeri foto, pengguna dapat menontonnya dalam orientasi lanskap.  Bagaimana cara mendukung ini? </p><br><p>  Seseorang akan menawarkan <strong>tongkat pertama</strong> : </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:configChanges="orientation" /&gt;</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigurationChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newConfig: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Configuration</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newConfig?.orientation == Configuration.ORIENTATION_LANDSCAPE) { <span class="hljs-comment"><span class="hljs-comment">//ignore } else { super.onConfigurationChanged(newConfig) } }</span></span></code> </pre> <br><p>  Dengan demikian, kita tidak dapat memanggil <code>super.onConfigurationChanged(newConfig)</code> , tetapi memprosesnya sendiri dan hanya memutar tampilan yang diperlukan di layar. <br>  Tetapi dengan API 23, proyek akan macet dengan <code>SuperNotCalledException</code> , jadi <strong>pilihan yang buruk</strong> . </p><br><p>  <strong>Pernyataan di atas membuat kesalahan:</strong> <br>  Saya cukup dikoreksi dalam komentar yang menambahkan android: configChanges = "orientasi | screenSize" sudah cukup, dan kemudian Anda dapat memanggil super dan Kegiatan tidak akan dibuat kembali setelah rotasi.  Berguna untuk menggunakannya saat WebView atau peta ada di layar yang membutuhkan waktu lama untuk diinisialisasi, dan Anda ingin menghindarinya. <br>  Ini akan membantu untuk menyelesaikan kasus yang dijelaskan dengan galeri, tetapi pesan utama dari bagian ini: <u>jangan mengabaikan rekreasi Aktivitas</u> , ini dapat terjadi dalam banyak kasus lainnya. </p><br><p>  Seseorang mungkin menyarankan solusi lain: </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:screenOrientation="portrait" /&gt; &lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".RotateActivity" /&gt;</code> </pre> <br><p>  Tetapi dengan cara ini kita menjauh dari pendekatan Aktivitas Tunggal untuk memecahkan masalah sederhana dan menghilangkan semua manfaat dari pendekatan itu.  Ini adalah penopang, dan penopang selalu merupakan <strong>pilihan yang buruk</strong> . </p><br><p>  Inilah solusi yang tepat: </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:configChanges="orientation" /&gt;</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume() activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause() activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT }</code> </pre> <br><p>  Yaitu, ketika fragmen dibuka, aplikasi mulai "berputar", dan ketika kembali, itu diperbaiki lagi.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalaman</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> ini adalah cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerja</a> aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AirBnB</a> .  Jika Anda membuka tampilan foto perumahan, pemrosesan giliran diaktifkan, tetapi dalam orientasi lanskap, Anda dapat menarik foto ke bawah untuk keluar dari galeri.  Di bawahnya, layar sebelumnya akan terlihat dalam orientasi lansekap, yang biasanya tidak akan Anda temukan, karena segera setelah meninggalkan galeri layar akan berubah menjadi potret dan diperbaiki. </p><br><p><img src="https://habrastorage.org/webt/to/wt/kj/towtkjtucdgw_d2s5da7b2awzkm.png"></p><br><p>  Di sinilah persiapan tepat waktu untuk pergantian layar akan membantu. </p><br><h4 id="transparent-status-bar">  Bilah status transparan </h4><br><p>  Hanya Aktivitas yang dapat bekerja dengan bilah sistem, tetapi sekarang kami hanya memiliki satu, jadi Anda harus selalu menentukan </p><br><pre> <code class="hljs pgsql">&lt;item <span class="hljs-type"><span class="hljs-type">name</span></span>="android:windowTranslucentStatus"&gt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&lt;/item&gt;</code> </pre> <br><p>  Tetapi pada beberapa layar tidak perlu "merangkak" di bawahnya, dan Anda perlu menampilkan semua konten di bawah ini.  Bendera datang untuk menyelamatkan </p><br><pre> <code class="hljs objectivec">android:fitsSystemWindows=<span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br><p>  yang menunjukkan tata letak yang tidak boleh Anda gambar di bawah bilah sistem.  Tetapi jika Anda menentukannya di tata letak fragmen, dan kemudian mencoba untuk menampilkan fragmen melalui transaksi di manajer fragmen, maka Anda akan kecewa ... itu tidak akan berhasil! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jawabannya cepat google</a> <br>  Saya sangat menyarankan Anda membiasakan diri dengan jawaban yang sangat komprehensif dan banyak tautan bermanfaat. <br>  Solusi cepat dan berfungsi ( <em>tetapi bukan yang tepat</em> ) adalah membungkus tata letak di <code>CoordinatorLayout</code> </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:app</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:fitsSystemWindows</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Solusi yang lebih baik membantu memproses keyboard juga. </p><br><h4 id="izmenenie-verstki-pri-poyavlenii-klaviatury">  Ubah tata letak saat keyboard muncul </h4><br><p>  Saat keyboard keluar, tata letak harus berubah sehingga elemen penting dari UI tidak tetap di luar jangkauan.  Dan jika sebelumnya kita dapat menentukan mode reaksi yang berbeda untuk keyboard untuk Aktivitas yang berbeda, sekarang kita perlu melakukan ini di Aktivitas Tunggal.  Karena itu perlu digunakan </p><br><pre> <code class="hljs objectivec">android:windowSoftInputMode=<span class="hljs-string"><span class="hljs-string">"adjustResize"</span></span></code> </pre> <br><p>  Jika Anda menggunakan pendekatan dari bagian sebelumnya untuk memproses bilah status transparan, Anda akan menemukan kesalahan yang tidak menguntungkan: jika sebuah fragmen berhasil dirayapi di bawah bilah status, maka ketika keyboard muncul, itu akan menyusut di atas dan di bawah, karena bilah status dan keyboard di dalam sistem bekerja melalui <code>SystemWindows</code> . </p><br><p>  Perhatikan judulnya </p><br><p><img src="https://habrastorage.org/webt/vr/ay/xo/vrayxosszrpgfsq-eyia_z4hshi.gif"></p><br><p>  Apa yang harus dilakukan  Baca dokumentasinya!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan pastikan untuk melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Banes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berbicara </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">tentang WindowInsets</font></a><font style="vertical-align: inherit;"> .</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan WindowInsets akan memungkinkan </font></font></p><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cari tahu tinggi status bar yang benar (dan bukan hardcode 51dp) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyiapkan aplikasi untuk setiap guntingan di layar smartphone baru </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cari tahu ketinggian keyboard (nyata!) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menerima acara dan merespons tampilan keyboard. </font></font></li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua orang belajar WindowInsets!</font></font></strong> </p><br><h4 id="splash-screen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Layar splash </font></font></h4><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika orang lain tidak mengetahui, maka layar Splash kanonik bukanlah layar pertama dalam aplikasi yang memuat data, tetapi apa yang dilihat pengguna saat startup hingga konten Aktivitas memiliki waktu untuk dirender. </font><font style="vertical-align: inherit;">Ada banyak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang hal ini.</font></font></p><br><p><img src="https://habrastorage.org/webt/fs/nd/nt/fsndntzk-erl-iebzisfiiftsfc.png"></p><br><p>    ,   Single-Activity,    Splash screen.     ,     deep-link      Splash screen     . </p><br><h4 id="zapusk-vashego-prilozheniya-iz-drugih-prilozheniy">       </h4><br><p>  <strong>    </strong> ,    ,      ,    . </p><br><p> ,       .    Single-Activity.    -         ,   ,    . <br>                 ... <br>  Intent,   ,        ... <br>  Apa selanjutnya   : </p><br><ul><li>    ,       «».    «»,    .    ,   ! </li><li>      ,    … </li></ul><br><p>      ,     .           ?     —           «»   «»   . </p><br><p>  Apa yang harus dilakukan  ,    . </p><br><p>    Activity! <br> ,    :       ,   —        . <br>       — ,      (   Activity),    . </p><br><p>  Activity —       .      Activity,         .     . </p><br><p><img src="https://habrastorage.org/webt/hj/cs/wd/hjcswdrykm21jtyzupyongbe494.png"></p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>    ()   ,        Activity,        Android-.         ,             . </p><br><p>    :     Google       .        —      ,   ,    Activity     . </p><br><p> ,    ,      ,        !  Terima kasih </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426617/">https://habr.com/ru/post/id426617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426605/index.html">Analisis statis kode PHP menggunakan PHPStan, Phan dan Mazmur sebagai contoh</a></li>
<li><a href="../id426609/index.html">Office 365 dan produk MS lainnya akan menambahkan suara I / O untuk penderita disleksia</a></li>
<li><a href="../id426611/index.html">Integrasi dengan SAP ERP, menggunakan Django-python sebagai contoh, menggunakan protokol oData (rest)</a></li>
<li><a href="../id426613/index.html">Jangan biarkan printer 3D menjadi malas</a></li>
<li><a href="../id426615/index.html">Menulis CLI di NodeJS</a></li>
<li><a href="../id426621/index.html">String ringkas di Jawa 9</a></li>
<li><a href="../id426623/index.html">Ini adalah bus listrik: apa yang kita ketahui tentang transportasi dengan baterai</a></li>
<li><a href="../id426625/index.html">Pohon multibahasa dalam Yii2 sebagai contoh membuat modul menu</a></li>
<li><a href="../id426627/index.html">Contoh Flexbox</a></li>
<li><a href="../id426629/index.html">Filosofi reformasi pajak Trump</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>