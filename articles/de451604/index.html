<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚úàÔ∏è ü§¶üèø üêò Dieser Artikel hat zu viel Wasser. üßöüèº ‚§µÔ∏è üò∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄûWir fangen an, ein neues Spiel zu entwickeln, und wir brauchen k√ºhles Wasser. Schaffst du das? " 


 - fragte mich. ‚ÄûJa, keine Frage! Nat√ºrlich kann ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dieser Artikel hat zu viel Wasser.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451604/">  ‚ÄûWir fangen an, ein neues Spiel zu entwickeln, und wir brauchen k√ºhles Wasser.  Schaffst du das? " <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iilqtDkeIBE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - fragte mich.  ‚ÄûJa, keine Frage!  Nat√ºrlich kann ich das ‚Äú, antwortete ich, aber meine Stimme zitterte t√ºckisch.  "Und auch √ºber die Einheit?" - und mir wurde klar, dass noch viel Arbeit vor uns liegt. <br><a name="habracut"></a><br>  Also etwas Wasser.  Bis zu diesem Moment hatte ich Unity nicht genau wie C # gesehen, also beschloss ich, einen Prototyp f√ºr die Tools zu erstellen, die ich kannte: C ++ und DX9.  Was ich damals wusste und in der Praxis √ºben konnte, waren die Bildlauftexturen von Normalen zur Bildung der Oberfl√§che und die darauf basierende primitive Verschiebungsabbildung.  Sofort war es notwendig, absolut alles zu √§ndern.  Realistische animierte Form der Wasseroberfl√§che.  Komplizierte (starke) Schattierung.  Schaumbildung.  An die Kamera angeschlossenes LOD-System.  Ich begann im Internet nach Informationen zu suchen, wie man das alles macht. <br><br>  Der erste Punkt war nat√ºrlich das Verst√§ndnis von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jerry Tessendorfs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">simulierendem Meerwasser</a> . <br><br>  Akademische Pager mit einer Reihe von abstrusen Formeln wurden mir nie viel gegeben, so dass ich nach ein paar Lesungen wenig verstand.  Die allgemeinen Prinzipien waren klar: Jeder Rahmen wird durch eine H√∂henkarte unter Verwendung der schnellen Fourier-Transformation erzeugt, die in Abh√§ngigkeit von der Zeit ihre Form sanft √§ndert, um eine realistische Wasseroberfl√§che zu bilden.  Aber wie und was ich z√§hlen sollte, wusste ich nicht.  Ich vertiefte mich langsam in die Weisheit, FFT auf Shadern in D3D9 zu berechnen, und der Quellcode mit einem Artikel irgendwo in der Wildnis des Internets, den ich eine Stunde lang zu finden versuchte, aber ohne Erfolg (leider) wirklich half.  Das erste Ergebnis wurde erzielt (be√§ngstigend wie ein Atomkrieg): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tdfwF1R81O4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die ersten Erfolge waren erfreulich, und der Transfer von Wasser zu Unity begann mit seiner Fertigstellung. <br><br>  Im Spiel √ºber Seeschlachten wurden verschiedene Anforderungen an Wasser gestellt: <br><br><ul><li>  Realistischer Look.  Sch√∂n wie nahe und entfernte Verk√ºrzungen, dynamischer Schaum, Streuung usw. </li><li>  Unterst√ºtzung f√ºr verschiedene Wetterbedingungen: Ruhe, Sturm und Zwischenbedingungen.  √Ñnderung der Tageszeit. </li><li>  Physik des Auftriebs von Schiffen auf einer simulierten Oberfl√§che, schwimmende Objekte. </li><li>  Da das Spiel im Mehrspielermodus gespielt wird, sollte das Wasser f√ºr alle Teilnehmer des Kampfes gleich sein. </li><li>  Oberfl√§chenzeichnung: Gezeichnete Bereiche des Fluges der Volley-Kerne, Schaum vom Eindringen von Kernen ins Wasser. </li></ul><br><h3>  Geometrie </h3><br>  Es wurde beschlossen, eine quadtree-√§hnliche Struktur mit einem Zentrum um die Kamera herum zu bauen, die diskret wieder aufgebaut wird, wenn sich der Betrachter bewegt.  Warum diskret?  Wenn Sie das Netz reibungslos mit der Kamera bewegen oder die Neuprojektion des Bildschirmbereichs wie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echtzeit-Wasserwiedergabe verwenden - Einf√ºhrung des projizierten Gitterkonzepts -</a> , springen die Polygone in den Langzeitpl√§nen aufgrund der unzureichenden Aufl√∂sung des geometrischen Netzes nach oben und runter.  Das ist sehr auff√§llig.  Das Bild kr√§uselt sich.  Um dies zu √ºberwinden, muss entweder die Aufl√∂sung des Wassernetzpolygons stark erh√∂ht oder die Geometrie √ºber gro√üe Entfernungen ‚Äûabgeflacht‚Äú werden oder die Polygone so aufgebaut und verschoben werden, dass diese Verschiebungen nicht sichtbar sind.  Unser Wasser ist progressiv (hehe) und ich habe den dritten Weg gew√§hlt.  Wie bei jeder √§hnlichen Technik (die allen bekannt ist, die in Spielen Terrain erstellt haben), m√ºssen Sie T-√úberg√§nge an den Grenzen von √úberg√§ngen von Detailebenen entfernen.  Um dieses Problem zu l√∂sen, werden zu Beginn 3 Arten von Quads mit vorgegebenen Tessellierungsparametern berechnet: <br><br><img src="https://habrastorage.org/webt/al/df/nw/aldfnwtnd2iihq2np9juxe5lvjm.jpeg"><br><br>  Der erste Typ ist f√ºr Quads gedacht, bei denen es sich nicht um √úberg√§nge zu niedrigeren Details handelt.  Keine Seite hat eine zweifach reduzierte Anzahl von Eckpunkten.  Der zweite Typ ist f√ºr Grenz-, aber nicht f√ºr eckige Quads.  Der dritte Typ sind eckige Grenzquads.  Das endg√ºltige Wassernetz wird durch Drehen und Skalieren dieser drei Arten von Netzen konstruiert. <br><br>  So sieht ein Render mit einer anderen Farbe des LOD-Wasserstandes aus. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JycUZlod3xs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die ersten Bilder zeigen die Verbindung zweier verschiedener Detailebenen. <br><br>  Video als Frame ist mit Wasserquads gef√ºllt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VldNrYKLb0w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ich m√∂chte Sie daran erinnern, dass alles schon lange her ist (und nicht wahr ist).  Jetzt k√∂nnen Sie optimaler und flexibler direkt auf der GPU arbeiten (GPU Pro 5. Quadtrees auf der GPU).  Und es wird in einem Draw Call gezeichnet, und Tessellation kann das Detail erh√∂hen. <br><br>  Sp√§ter wechselte das Projekt zu D3D11, aber die H√§nde erreichten nicht die Aufr√ºstung dieses Teils des Ozeanputzes. <br><br><h3>  Wellenformgenerierung </h3><br>  Daf√ºr brauchen wir eine schnelle Fourier-Transformation.  F√ºr die ausgew√§hlte (notwendige) Aufl√∂sung der Wellentextur (nennen wir es zun√§chst, ich erkl√§re, welche Daten dort gespeichert sind) bereiten wir die Anfangsdaten anhand der von den K√ºnstlern festgelegten Parameter vor (Kraft, Windrichtung, Wellenabh√§ngigkeit von der Windrichtung und andere).  All dies muss in die sogenannten Formeln eingespeist werden.  Phillips-Spektrum  Wir modifizieren die f√ºr jeden Frame erhaltenen Anfangsdaten unter Ber√ºcksichtigung der Zeit und f√ºhren eine FFT f√ºr sie durch.  Am Ausgang erhalten wir eine Texturkachelung in alle Richtungen, die den Versatz der Eckpunkte des Flachnetzes enth√§lt.  Warum nicht einfach eine H√∂henkarte?  Wenn Sie nur den H√∂henversatz speichern, entsteht eine unrealistische "sprudelnde" Masse, die nur aus der Ferne dem Meer √§hnelt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2234r1xpuI8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wenn wir die Verschiebungen f√ºr alle drei Koordinaten ber√ºcksichtigen, werden sch√∂ne ‚Äûscharfe‚Äú realistische Wellen erzeugt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tFhKaV1u-AY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Eine animierte Textur reicht nicht aus.  Kacheln sind sichtbar, nicht gen√ºgend Details in naher Zukunft.  Wir nehmen den beschriebenen Algorithmus und erstellen nicht eine, sondern 3 fft-generierte Texturen.  Das erste sind gro√üe Wellen.  Es legt die Grundwellenform fest und wird f√ºr die Physik verwendet.  Das zweite sind mittlere Wellen.  Und schlie√ülich die kleinste.  3 FFT-Generatoren (4. Option ist die endg√ºltige Mischung): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gqxbAOS4sGM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Parameter der Ebenen werden unabh√§ngig voneinander eingestellt und die resultierenden Texturen werden im Wasser-Shader in die endg√ºltige Wellenform gemischt.  Parallel zu den Offsets werden auch normale Karten jeder Schicht erzeugt. <br><br>  Die "Gleichm√§√üigkeit" des Wassers f√ºr alle Schlachtteilnehmer wird durch die Synchronisation der Ozeanparameter zu Beginn des Kampfes sichergestellt.  Diese Informationen werden vom Server an jeden Client √ºbertragen. <br><br><h3>  Modell des physischen Auftriebs </h3><br>  Da musste nicht nur ein sch√∂nes Bild gemacht werden, sondern auch das realistische Verhalten der Schiffe.  Unter Ber√ºcksichtigung der Tatsache, dass ein st√ºrmisches Meer (gro√üe Wellen) im Spiel vorhanden sein sollte, bestand eine weitere Aufgabe, die gel√∂st werden musste, darin, den Auftrieb von Objekten auf der Oberfl√§che des erzeugten Meeres sicherzustellen.  Zuerst habe ich versucht, die GPU auf die Textur der Welle zur√ºckzulesen.  Da jedoch schnell klar wurde, dass die gesamte Physik des Seekampfes auf dem Server ausgef√ºhrt werden muss, muss das Meer oder vielmehr die erste Schicht, die die Wellenform festlegt, auch auf dem Server gelesen werden (und h√∂chstwahrscheinlich gibt es kein Fasten und / oder kompatible GPU) wurde beschlossen, eine voll funktionsf√§hige Kopie des GPU-FFT-Generators in Form eines nativen C ++ - Plug-Ins f√ºr Unity auf die CPU zu schreiben.  Ich habe den FFT-Algorithmus nicht selbst implementiert und ihn in der Intel Performance Primitives (IPP) -Bibliothek verwendet.  Die gesamte Bindung und Nachbearbeitung der Ergebnisse wurde jedoch von mir durchgef√ºhrt, gefolgt von der Optimierung der SSE und der Parallelisierung durch Threads.  Dies beinhaltete die Vorbereitung des Datenarrays f√ºr die FFT f√ºr jeden Frame und die endg√ºltige Konvertierung der berechneten Werte in eine Wellenversatzkarte. <br><br>  Es gab ein weiteres interessantes Merkmal des Algorithmus, das auf den Anforderungen der Wasserphysik basierte.  Was ben√∂tigt wurde, war eine Funktion, um an einem bestimmten Punkt der Welt schnell Wellenh√∂hen zu erhalten.  Dies ist logisch, da dies die Grundlage f√ºr den Auftrieb eines Objekts ist.  Da wir jedoch am Ausgang des FFT-Prozessors eine Offset-Karte und keine H√∂henkarte erhalten, hat uns die √ºbliche Auswahl aus der Textur bei Bedarf nicht die Wellenh√∂he gegeben.  Betrachten Sie der Einfachheit halber die 2D-Option: <br><br><img src="https://habrastorage.org/webt/u6/ec/pe/u6ecpek-vcazrjpgh4ygxwhon2g.jpeg"><br><br>  Um eine Welle zu bilden, enthalten Texel (durch vertikale Linien dargestellte Texturelemente) einen Vektor (Pfeile), der den Versatz des Scheitelpunkts des flachen Netzes (blaue Punkte) in Richtung seiner Endposition (Pfeilspitze) festlegt.  Angenommen, wir nehmen diese Daten und versuchen, die H√∂he des Wassers an der f√ºr uns interessanten Stelle daraus zu extrahieren.  Zum Beispiel m√ºssen wir die H√∂he bei hB kennen.  Wenn wir den Texelvektor tB nehmen, erhalten wir einen Versatz zu einem Punkt in der N√§he von hC, der sich sehr von dem unterscheiden kann, was wir brauchen.  Es gibt zwei M√∂glichkeiten, um dieses Problem zu l√∂sen: √úberpr√ºfen Sie bei jeder H√∂henanforderung den Satz benachbarter Texel, bis wir eines finden, das einen Versatz zu der f√ºr uns interessanten Position aufweist.  In unserem Beispiel finden wir, dass Texel tA den n√§chsten Versatz enth√§lt.  Dieser Ansatz kann jedoch nicht schnell genannt werden.  Das Scannen des Texelradius ist unklar, welche Gr√∂√üe (und ob das st√ºrmische Meer oder die ruhigen Verschiebungen stark variieren k√∂nnen) lange dauern kann. <br><br>  Die zweite Option: Konvertieren Sie die versetzte Karte nach der Berechnung mithilfe des Streuungsansatzes in eine H√∂henkarte.  Dies bedeutet, dass wir f√ºr jeden Versatzvektor die H√∂he der Welle schreiben, die er auf den Punkt setzt, an dem er verschoben wird.  Dies ist ein separates Datenarray, mit dem die H√∂he am interessierenden Punkt ermittelt wird.  Unter Verwendung unserer Darstellung enth√§lt die Zelle tB die H√∂he hB, die aus dem Vektor tA ‚Üí hB erhalten wird.  Es gibt noch eine weitere Funktion.  Die Zelle tA enth√§lt keinen g√ºltigen Wert, da sich kein Vektor darin bewegt.  Um solche "L√∂cher" zu f√ºllen, wird ein Durchgang gemacht, um sie mit benachbarten Werten zu f√ºllen. <br><br>  So sieht es aus, wenn Sie die Verschiebungen mithilfe von Vektoren (rot - gro√üer Versatz, gr√ºn - klein) visualisieren: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uBk8F55lR74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Rest ist einfach.  Die Ebene der bedingten Wasserlinie ist f√ºr das Schiff festgelegt.  Darauf wird ein rechteckiges Gitter von Probenpunkten bestimmt, das die Orte der Anwendung von Kr√§ften definiert, die f√ºr das Schiff aus dem Wasser dr√ºcken.  Dann pr√ºfen wir f√ºr jeden Punkt anhand der oben beschriebenen Wasserh√∂henkarte, ob er sich unter Wasser befindet oder nicht.  Wenn sich der Punkt unter Wasser befindet, √ºben Sie an diesem Punkt die vertikale Kraft bis zum physischen Rumpf des K√∂rpers aus, skaliert durch den Abstand vom Punkt zur Wasseroberfl√§che.  Wenn wir √ºber Wasser nichts tun, wird die Schwerkraft alles f√ºr uns tun.  Tats√§chlich sind die Formeln dort etwas komplizierter (alles zur Feinabstimmung des Schiffsverhaltens), aber das Grundprinzip ist dies.  In dem Video zur Auftriebsvisualisierung unten sind die blauen W√ºrfel die Positionen der Proben, und die Linien von ihnen nach unten sind die Gr√∂√üe der Kraft, die aus dem Wasser herausgedr√ºckt wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mwNRIKbRdpQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Bei der Implementierung des Servers gibt es einen weiteren interessanten Optimierungspunkt.  Es ist nicht erforderlich, unterschiedliches Wasser f√ºr unterschiedliche Kampfinstanzen zu simulieren, wenn diese unter denselben Wetterbedingungen (denselben FFT-Simulatorparametern) passieren.  Die logische Entscheidung war daher, einen Pool von Simulatoren zu erstellen, f√ºr die Kampfeinheiten Anforderungen zur Gewinnung von simuliertem Wasser mit den angegebenen Parametern erf√ºllen.  Wenn die Parameter in mehreren F√§llen gleich sind, kehrt dasselbe Wasser zu ihnen zur√ºck.  Dies wird mithilfe der Memor Mapped File API implementiert.  Wenn der FFT-Simulator erstellt wird, erh√§lt er Zugriff auf seine Daten, indem Deskriptoren der erforderlichen Bl√∂cke exportiert werden.  Anstatt einen echten Simulator zu starten, startet die Serverinstanz einen ‚ÄûDummy‚Äú, der einfach Daten preisgibt, die von diesen Deskriptoren ge√∂ffnet wurden.  Es gab einige lustige Fehler im Zusammenhang mit dieser Funktionalit√§t.  Aufgrund von Referenzz√§hlfehlern wurde der Simulator zerst√∂rt, aber die Speicherzuordnungsdatei ist aktiv, w√§hrend mindestens ein Handle dazu ge√∂ffnet ist.  Die Daten wurden nicht mehr aktualisiert (es gibt keinen Simulator) und das Wasser wurde gestoppt. <br><br>  Auf der Client-Seite ben√∂tigen wir Informationen √ºber die Wellenform, um das Eindringen von Kernen in die Welle zu berechnen und Partikel- und Schaumsysteme zu spielen.  Der Schaden wird auf dem Server berechnet und dort muss auch korrekt festgestellt werden, ob der Kern ins Wasser gelangt ist (die Welle kann das Schiff schlie√üen, insbesondere bei St√ºrmen).  Hier ist es bereits erforderlich, die H√∂henkartenverfolgung analog durchzuf√ºhren, wie dies bei Parallaxen-Mapping- oder SSAO-Effekten der Fall ist. <br><br><h3>  Schattierung </h3><br>  Im Prinzip wie anderswo.  Reflexionen, Brechungen und Streuung unter der Oberfl√§che werden geschickt geknetet, wobei die Tiefe des Bodens ber√ºcksichtigt wird, der Fresneleffekt ber√ºcksichtigt wird und der Spiegel betrachtet wird.  Wir betrachten die Streuung von Graten in Abh√§ngigkeit vom Sonnenstand.  Schaum wird wie folgt erzeugt: Erstellen Sie einen ‚ÄûSchaumfleck‚Äú auf den Wellenbergen (verwenden Sie die H√∂he als Metrik), und wenden Sie dann neu erstellte Flecken auf die Flecken aus vorherigen Bildern an, w√§hrend Sie deren Intensit√§t verringern.  So erhalten wir ein Verschmieren von Schaumflecken in Form eines Schwanzes von einem Laufwellenkamm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MyzFcwr641g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wir verwenden die erhaltene "Flecken" -Textur als Maske, mit der wir die Texturen von Blasen, Flecken usw. mischen. Wir erhalten ein ziemlich realistisches dynamisches Schaummuster auf der Oberfl√§che der Wellen.  Diese Maske wird f√ºr jede FFT-Ebene erstellt (ich erinnere Sie, wir haben 3 davon), und im endg√ºltigen Mix mischen sich alle. <br><br>  Das obige Video zeigt eine Schaummaske.  Die erste und zweite Schicht.  Ich √§ndere die Parameter des Generators und das Ergebnis ist auf der Textur sichtbar. <br><br>  Und ein Video von einem etwas ungeschickten st√ºrmischen Meer.  Hier k√∂nnen Sie die Wellenform, die Generatorf√§higkeiten und den Schaum deutlich sehen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MAPUbmV4BAA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Wasserentnahme </h3><br>  Verwendungsbild: <br><br><img src="https://habrastorage.org/webt/zz/gz/1p/zzgz1pslmj1tg5si7o8mwnxqjye.jpeg"><br><br>  Verwendet f√ºr: <br><br><ul><li>  Marker, Visualisierung der Expansionszone der Kerne. </li><li>  Schaum an der Stelle ziehen, an der die Kerne auf das Wasser treffen. </li><li>  Schaumiges Kielwasser des Schiffes </li><li>  Dr√ºcken Sie Wasser unter dem Schiff heraus, um die Auswirkungen der Wellen, die das Deck und den √ºberfluteten Laderaum √ºberfluten, zu beseitigen. </li></ul><br>  Der offensichtliche Basisfall ist die projektive Texturierung.  Es wurde umgesetzt.  Es gibt jedoch zus√§tzliche Anforderungen.  In der N√§he befindliche Arten - Seife aufgrund unzureichender Aufl√∂sung (Sie k√∂nnen sie erh√∂hen, aber nicht unendlich), und ich m√∂chte, dass diese projektiven Zeichnungen auf dem Wasser weit sichtbar sind.  Wo ist das gleiche Problem gel√∂st?  Das ist richtig, in Schatten (Schattenkarte).  Wie ist sie dort gel√∂st?  Richtig, kaskadierte (parallele geteilte) Schattenkarten.  Wir werden diese Technologie auch in Betrieb nehmen und auf unsere Aufgabe anwenden.  Wir zerlegen den Kamerastumpf in N (normalerweise 3-4) Teilst√ºmpfe.  F√ºr jedes konstruieren wir ein beschreibendes Rechteck in der horizontalen Ebene.  F√ºr jedes solche Rechteck erstellen wir eine orthographische Projektionsmatrix und zeichnen alle interessierenden Objekte f√ºr jede von N solchen ortho-Kameras.  Jede dieser Kameras zeichnet in eine separate Textur und kombiniert sie dann im Ocean Shader zu einem soliden projektiven Bild. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/etG8tddmbmk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Also habe ich ein riesiges Flugzeug mit einer Fahnenstruktur auf das Meer gesetzt: <br><br><img src="https://habrastorage.org/webt/pd/uk/jr/pdukjrlnug2wu4debjrhlxbdxrc.jpeg"><br><br>  Folgendes enthalten Splits: <br><br><img src="https://habrastorage.org/webt/ez/dw/nm/ezdwnm3u85dzpavd5iz8e2u9q2k.jpeg"><br><br>  Zus√§tzlich zu den √ºblichen Bildern ist es notwendig, auf genau die gleiche Weise eine zus√§tzliche Schaummaske (f√ºr Spuren von Schiffen und Trefferstellen von Kernen) sowie eine Maske zum Auspressen von Wasser unter den Schiffen zu zeichnen.  Das sind viele Kameras und viele G√§nge.  Zuerst funktionierte es so schnell, aber nach dem Wechsel zu D3D11, der Verwendung der ‚ÄûAusbreitung‚Äú der Geometrie im geometrischen Shader und dem Zeichnen jeder Kopie in ein separates Renderziel √ºber SV_RenderTergetArrayIndex, konnte dieser Effekt erheblich beschleunigt werden. <br><br><h3>  Verbesserungen und Upgrades </h3><br>  D3D11 ist in vielen Momenten sehr freih√§ndig.  Nachdem ich zu Unity 5 gewechselt war, habe ich einen FFT-Generator f√ºr die Compute-Shader erstellt.  Optisch hat sich nichts ge√§ndert, aber es ist etwas schneller geworden.  Die √úbersetzung der Fehlberechnung der Textur von Reflexionen von einem separaten vollwertigen Kamera-Rendering in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Screen Space Planar Reflections-</a> Technologie f√ºhrte zu einer guten Leistungssteigerung.  Ich habe oben √ºber die Optimierung von Wasseroberfl√§chenobjekten geschrieben, aber meine H√§nde haben die √úbertragung des Netzes auf die Quadtree-GPU nicht erreicht. <br><br>  Vieles k√∂nnte m√∂glicherweise optimaler und einfacher gemacht werden.  Umz√§unen Sie beispielsweise keine G√§rten mit einem CPU-Simulator, sondern f√ºhren Sie einfach die GPU-Option auf einem Server mit einem WARP (Software) -D3D-Ger√§t aus.  Die Datenfelder dort sind nicht sehr gro√ü. <br><br>  Nun, im Allgemeinen irgendwie.  Zu der Zeit, als die Entwicklung begann, war alles modern und cool.  Jetzt ist es an einigen Stellen bereits fehl am Platz.  Es gibt mehr verf√ºgbare Materialien, auch wenn es ein √§hnliches Analogon zu Github gibt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crest</a> .  Die meisten Spiele mit Meeren verfolgen einen √§hnlichen Ansatz. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451604/">https://habr.com/ru/post/de451604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451594/index.html">PHP Russia 2019 Report Guide</a></li>
<li><a href="../de451596/index.html">Grauer Kardinal .NET - John Galloway</a></li>
<li><a href="../de451598/index.html">Unit Fairy Magic Fairy: DSL in C #</a></li>
<li><a href="../de451600/index.html">So schreiben Sie ein Anschreiben bei der Arbeitssuche in den USA: 7 Tipps</a></li>
<li><a href="../de451602/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 1</a></li>
<li><a href="../de451606/index.html">Internet-Geschichte: Zerfall, Teil 2</a></li>
<li><a href="../de451610/index.html">Sicherheitswoche 20: Deaktivieren von Firefox-Erweiterungen</a></li>
<li><a href="../de451614/index.html">‚ÄûWas wir in Russland diskutieren, ist auch im Westen relevant‚Äú: Interview mit Denis Neklyudov</a></li>
<li><a href="../de451618/index.html">CampusInsight: Von der Infrastruktur√ºberwachung zur Analyse der Benutzererfahrung</a></li>
<li><a href="../de451620/index.html">Automatische Autorisierung auf der Strava Heatmap-Karte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>