<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 ⛹️ 👨🏻‍🎤 Wir schreiben USB-Treiber für verlassene Geräte 🚔 🎲 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich stieß ich bei eBay auf eine Reihe interessanter USB-Geräte (Epiphan VGA2USB LR), die VGA-Eingaben empfangen und Videos als Webcam an USB send...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben USB-Treiber für verlassene Geräte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476434/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/58/4t/ko584thwb5si-do2bof-snfagjc.jpeg" width="550"></div><br><br>  Kürzlich stieß ich bei eBay auf eine Reihe interessanter USB-Geräte (Epiphan VGA2USB LR), die VGA-Eingaben empfangen und Videos als Webcam an USB senden.  Ich war so begeistert von der Idee, dass ich mich nie wieder mit VGA-Monitoren beschäftigen müsste, und angesichts der erklärten Unterstützung für Linux habe ich die Chance genutzt und die gesamte Charge für etwa 25 US-Dollar (20 Pfund) gekauft. <br><br>  Nachdem ich das Paket erhalten hatte, schloss ich das Gerät an, aber es schien nicht einmal als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UVC</a> im System zu erscheinen.  Was ist los? <br><br>  Ich habe die Website des Herstellers studiert und festgestellt, dass ein spezieller Fahrer erforderlich ist, um zu arbeiten.  Für mich war dies ein neues Konzept, da der Kern meiner Linux-Distribution normalerweise Treiber für alle Geräte enthält. <br><a name="habracut"></a><br>  Leider wurde die Treiberunterstützung nur für diese Geräte unter Linux 4.9 eingestellt.  Daher wird es auf keinem meiner Systeme angezeigt (Debian 10 unter Linux 4.19 oder die neueste Version von LTS Ubuntu unter Linux 5.0). <br><br>  Aber es kann behoben werden, oder?  Natürlich sind die Dateien im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DKMS-Paket enthalten</a> , das den Treiber wie viele normale Treiber auf Anfrage aus dem Quellcode abholt ... <br><br>  Es ist traurig.  Aber hier ist es nicht so. <br><br>  In dem Paket befand sich nur die vorkompilierte Binärdatei <code>vga2usb.o</code> .  Ich begann es zu studieren und wunderte mich über die Komplexität des Reverse Engineering. Dabei fand ich einige interessante Zeilen: <br><br><pre> <code class="bash hljs">$ strings vga2usb.ko | grep <span class="hljs-string"><span class="hljs-string">'v2uco'</span></span> | sort | uniq v2ucom_autofirmware v2ucom_autofirmware_ezusb v2ucom_autofirmware_fpga</code> </pre> <br>  Also ist es wirklich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPGA-</a> on-a-Stick?  Wie kann man so etwas machen? <br><br>  Ein anderer lustiger und etwas störender Fund war die Zeile mit den Parametern des privaten DSA-Schlüssels.  Das hat mich gefragt: Was kann es im Fahrer schützen? <br><br><pre> <code class="bash hljs">$ strings vga2usb.ko | grep <span class="hljs-string"><span class="hljs-string">'epiphan'</span></span> | sort | uniq epiphan_dsa_G epiphan_dsa_P epiphan_dsa_Q</code> </pre> <br>  Um den Treiber in seiner normalen Umgebung zu untersuchen, nahm ich eine virtuelle Debian 9-Maschine (letzte unterstützte Version) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schaltete KVM-USB-Passthrough ein</a> , um direkten Zugriff auf das Gerät zu ermöglichen.  Dann habe ich den Treiber installiert und sichergestellt, dass es funktioniert. <br><br>  Danach wollte ich sehen, wie das Kommunikationsprotokoll aussieht.  Ich hatte gehofft, das Gerät würde rohe oder fast rohe Frames senden, da dies das Schreiben eines Treibers für den Benutzerraum erleichtern würde. <br><br>  Dazu habe ich das <code>usbmon</code> Modul auf den Host der virtuellen Maschine geladen und Wireshark gestartet, um den USB-Verkehr zum und vom Gerät während des Starts und der Videoaufnahme zu erfassen. <br><br><img src="https://habrastorage.org/webt/wo/0l/ux/wo0luxcyjaf5kmnthlsjsseo_o0.png"><br><br>  Beim Start wurde festgestellt, dass eine große Anzahl kleiner Pakete an das Gerät übertragen wird, bevor mit der Aufnahme des Bildes begonnen wird.  Es basiert wahrscheinlich auf der FPGA-Plattform ohne Datenspeicherung.  Der Treiber hat nach jeder Verbindung die Firmware in Form eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20191109230917/">FPGA-Bitstreams</a> auf das Gerät übertragen. <br><br>  Davon war ich überzeugt, als ich eine der Schachteln öffnete: <br><br><img src="https://habrastorage.org/webt/8d/df/qe/8ddfqe7xzlovfj9bnjwhmyu5due.jpeg"><br><br><div class="scrollable-table"><table><tbody><tr><td colspan="1" rowspan="1"><p>  Rot </p></td><td colspan="1" rowspan="1"><p>  ISL98002CRZ-170 - Funktioniert als ADC für VGA-Signale </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Gelb </p></td><td colspan="1" rowspan="1"><p>  XC6SLX16 - Xilinx Spartan 6 FPGA </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Cyan </p></td><td colspan="1" rowspan="1"><p>  64 MB DDR3 </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Magenta </p></td><td colspan="1" rowspan="1"><p>  CY7C68013A - USB-Controller / Front-End </p></td></tr></tbody></table></div><br>  Da Sie zum „Herunterladen“ des Geräts einen Bitstream / eine Firmware senden müssen, müssen Sie in vorkompilierten Binärdateien danach suchen.  Ich habe <code>binwalk -x</code> und nach komprimierten Objekten (zlib) gesucht.  Dazu habe ich ein Hex-Sequenz-Suchskript geschrieben und drei Bytes aus dem abgefangenen Paket angegeben. <br><br><pre> <code class="bash hljs">$ bash scan.sh <span class="hljs-string"><span class="hljs-string">"03 3f 55"</span></span> trying 0.elf trying 30020 trying 30020.zlib trying 30020.zlib.decompressed ... trying 84BB0 trying 84BB0.zlib trying 84BB0.zlib.decompressed trying AA240 trying AA240.zlib trying AA240.zlib.decompressed 000288d0 07 2f 03 3f 55 50 7d 7c 00 00 00 00 00 00 00 00 |./.?UP}|........| trying C6860 trying C6860.zlib</code> </pre> <br>  Nach dem Entpacken der Datei AA240.zlib stellte sich heraus, dass dort nicht genügend Daten für einen vollständigen Bitstream vorhanden waren.  Also habe ich beschlossen, die Firmware aus den USB-Paketen zu holen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sowohl tshark</a> als auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcpdump</a> können USB-Pakete aus pcap-Dateien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> , aber beide speichern sie nur teilweise.  Da jedes Dienstprogramm verschiedene Teile des Puzzles enthielt, habe ich ein <a href="">kleines Programm geschrieben</a> , das die Ausgabe beider Programme in Go-Strukturen kombiniert, um die Pakete auf dem Gerät abzuspielen. <br><br>  Zu diesem Zeitpunkt bemerkte ich, dass der Download in zwei Schritten erfolgt: zuerst einen USB-Controller und dann ein FPGA. <br><br>  Ich steckte mehrere Tage fest: Es schien, als würde der gesamte Bitstream geladen, aber das Gerät wurde nicht gestartet, obwohl die Pakete des realen Treibers und meine Simulation ähnlich aussehen. <br><br>  Am Ende löste ich das Problem, indem ich pcap unter Berücksichtigung der Antwortzeit für jedes Paket sorgfältig untersuchte - und bemerkte einen großen Zeitunterschied in einem bestimmten Paket: <br><br><img src="https://habrastorage.org/webt/fm/jr/cl/fmjrcloapr8mljsbnl3ed1qc0p0.png"><br><br>  Es stellte sich heraus, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Aufnahme aufgrund eines kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tippfehlers</a> im falschen Bereich des Geräts erfolgte.  Es wird mir eine Lektion sein, wie man Werte manuell eingibt ... <br><br>  Die LED am Gerät blinkte jedoch endlich!  Eine riesen Leistung! <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="https://blog.benjojo.co.uk/asset/hwDmbj53li" type="video/mp4"></video></div></div></div><br>  Es war relativ einfach, dieselben Pakete zu replizieren, die die Datenübertragung ausgelöst haben, sodass ich den USB-Massenendpunkt schreiben und die Daten sofort auf die Festplatte kopieren konnte! <br><br>  Hier begannen die wirklichen Schwierigkeiten.  Denn nach der Analyse stellte sich heraus, dass die Daten in keiner Weise explizit verschlüsselt wurden. <br><br>  Um zu beginnen, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">perf ausgeführt</a> , um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grundlegende</a> Vorstellung von der Ablaufverfolgung des Treiberstapels zur Laufzeit zu erhalten: <br><br><img src="https://habrastorage.org/webt/8u/8u/gu/8u8ugu8wikugmk_9pmp9iwdzwig.png"><br><br>  Obwohl ich Funktionen mit Rahmendaten abfangen konnte, konnte ich die Kodierung der Daten selbst nicht verstehen. <br><br><img src="https://habrastorage.org/webt/0w/hl/rx/0whlrxmpbisqikichzqziye8ilm.png"><br><br>  Um besser zu verstehen, was im realen Treiber vor sich geht, habe ich sogar das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ghidra-</a> Tool der NSA ausprobiert: <br><br><img src="https://habrastorage.org/webt/2k/w-/vk/2kw-vke76xvk_wp1zuultsc_g6m.png"><br><br>  Obwohl Ghidra unglaublich ist (als ich es zum ersten Mal anstelle von IDA Pro verwendet habe), ist es immer noch nicht gut genug, um mir zu helfen, den Treiber zu verstehen.  Reverse Engineering erforderte einen anderen Pfad. <br><br>  Ich habe beschlossen, die virtuelle Windows 7-Maschine in die Hand zu nehmen und mir den Windows-Treiber anzuschauen, da werden plötzlich Ideen auftauchen.  Und dann ist mir aufgefallen, dass es ein SDK für Geräte gibt.  Eines der Tools erwies sich als besonders interessant: <br><br><pre> <code class="bash hljs">PS&gt; ls Directory: epiphan_sdk-3.30.3.0007\epiphan\bin Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 10/26/2019 10:57 AM 528384 frmgrab.dll -a--- 10/27/2019 5:41 PM 1449548 out.aw -a--- 10/26/2019 10:57 AM 245760 v2u.exe -a--- 10/26/2019 10:57 AM 94208 v2u_avi.exe -a--- 10/26/2019 10:57 AM 102400 v2u_dec.exe -a--- 10/26/2019 10:57 AM 106496 v2u_dshow.exe -a--- 10/26/2019 10:57 AM 176128 v2u_ds_decoder.ax -a--- 10/26/2019 10:57 AM 90112 v2u_edid.exe -a--- 10/26/2019 10:57 AM 73728 v2u_kvm.exe -a--- 10/26/2019 10:57 AM 77824 v2u_libdec.dll PS&gt; .\v2u_dec.exe Usage: v2u_dec &lt;number of frames&gt; [format] [compression level] &lt;filename&gt; - sets compression level [1..5], - captures and saves compressed frames to a file v2u_dec x [format] &lt;filename&gt; - decompresses frames from the file to separate BMP files</code> </pre> <br>  Mit diesem Tool können Sie einzelne Frames "greifen", die anfangs nicht komprimiert werden, damit Sie Frames später auf einem schnelleren Computer verarbeiten können.  Das ist fast perfekt, und ich habe die Sequenz der USB-Pakete repliziert, um diese unkomprimierten Blobs zu erhalten.  Die Anzahl der Bytes entsprach ungefähr drei (RGB) pro Pixel! <br><br>  Die anfängliche Verarbeitung dieser Bilder (nur das Akzeptieren der Ausgabe und das Schreiben als RGB-Pixel) erinnerte vage an das reale Bild, das das Gerät über VGA empfing: <br><br><img src="https://habrastorage.org/webt/zw/a7/ex/zwa7ext1vs4qdprl7-nv9vzp0-m.png"><br><br>  Nach einigem Debuggen im Hex-Editor stellte sich heraus, dass jeder Marker alle 1028 Bytes wiederholt wird.  Es ist ein bisschen peinlich, wie viel Zeit ich damit verbracht habe, einen Filter zu schreiben.  Auf der anderen Seite könnte man sich dabei an einigen Beispielen zeitgenössischer Kunst erfreuen. <br><br><img src="https://habrastorage.org/webt/wq/je/ft/wqjeft0hks2k0tc7hfdwf4sm0ti.png"><br><br>  Dann wurde mir klar, dass die Neigung und Verzerrung des Bildes durch Überspringen und Pixelumbruch in jeder Zeile verursacht wird (x = 799 ist nicht gleich x = 800).  Und dann habe ich endlich ein fast korrektes Bild bekommen, abgesehen von der Farbe: <br><br><img src="https://habrastorage.org/webt/b5/wq/3o/b5wq3ocp1mjzytcefasym6nyuem.png"><br><br>  Zuerst dachte ich, das Kalibrierungsproblem liege an der Datenabtastung, wenn der VGA-Eingang einfarbig ist.  Zur Korrektur habe ich ein neues Testbild erstellt, um solche Probleme zu identifizieren.  Im Nachhinein habe ich verstanden, dass Sie so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Philips PM5544-Testkarte verwenden mussten</a> . <br><br><img src="https://habrastorage.org/webt/70/se/ue/70seuem7_dhlhaip_wfjtfzgvs0.png"><br><br>  Ich habe das Bild auf einen Laptop hochgeladen und es wurde ein solches VGA-Bild erstellt: <br><br><img src="https://habrastorage.org/webt/nb/k3/yj/nbk3yjxdr_mulhymu7enyvt3xjo.png"><br><br>  Dann habe ich die Erinnerung an eine alte Arbeit in 3D-Rendering / Shader.  Es war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem YUV-Farbschema</a> sehr ähnlich. <br><br>  Infolgedessen stürzte ich mich in die Lektüre der YUV-Literatur und erinnerte mich, dass das System beim Reverse Engineering des offiziellen <code>v2ucom_convertI420toBGR24</code> ohne die Möglichkeit einer Erneuerung einfrieren würde, wenn ich einen Haltepunkt für eine Funktion namens <code>v2ucom_convertI420toBGR24</code> .  Vielleicht war die Eingabe also I420-Codierung (von <code>-pix_fmt yuv420p</code> ) und die Ausgabe war RGB? <br><br>  Nach Verwendung der integrierten Go-Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YCbCrToRGB kam das</a> Bild dem Original plötzlich viel näher. <br><br><img src="https://habrastorage.org/webt/_8/aq/ne/_8aqnetxgrlor_21ezu2ywdqnrq.png"><br><br>  Wir haben es geschafft!  Sogar der Raw-Treiber produzierte 7 Frames pro Sekunde.  Ehrlich gesagt, das reicht mir, da ich VGA nur im Falle eines Unfalls als Backup-Anzeige verwende. <br><br>  Jetzt kennen wir dieses Gerät also gut genug, um den Algorithmus für das Starten von Anfang an zu erläutern: <br><br><ol><li>  Sie müssen <a href="">den USB-Controller initialisieren</a> .  Gemessen an der Informationsmenge übergibt der Treiber tatsächlich Code zum Herunterladen. <br></li><li>  Wenn Sie den USB-Stick geladen haben, wird das Gerät vom USB-Bus getrennt und kehrt nach einem Moment mit einem USB-Endpunkt zurück. <br></li><li>  Jetzt können Sie <a href="">den FPGA-Bitstream senden</a> , ein 64-Byte-USB-Paket für jede Steuerübertragung. <br></li><li>  Am Ende der Übertragung blinkt die Anzeige am Gerät grün.  An dieser Stelle können Sie eine scheinbare Folge von Parametern (Overscan und andere Eigenschaften) senden. <br></li><li>  Führen Sie dann das <a href="">Steuerpaket aus, um den Frame</a> mit der angegebenen Berechtigung abzurufen.  Wenn Sie eine Anforderung für einen 4: 3-Frame an den Breitbild-Eingang senden, führt dies normalerweise zu einer Beschädigung des Frames. </li></ol><br>  Für maximale Benutzerfreundlichkeit habe ich einen kleinen Webserver im Treiber implementiert.  Über die browserbasierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MediaRecorder-API wird</a> der Stream vom Bildschirm auf einfache Weise in eine Videodatei aufgezeichnet. <br><br><img src="https://habrastorage.org/webt/o4/gr/u9/o4gru9m7gywpqz85razdl6ktsd0.png"><br><br>  Um den unvermeidlichen Anspruch auf die Qualität des experimentellen Codes zu vermeiden, sage ich gleich: Ich bin nicht stolz darauf.  Wahrscheinlich befindet er sich in einem solchen Zustand, der mir für eine akzeptable Verwendung ausreicht. <br><br>  Der Code und die vorgefertigten Builds für Linux und OSX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befinden sich auf GitHub</a> . <br><br>  Auch wenn niemand das Programm startet, war es für mich eine aufregende Reise durch die Wildnis des USB-Protokolls, das Debuggen des Kernels, das Reverse Engineering des Moduls und das Videodecodierungsformat!  Wenn Sie diese Dinge mögen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Blog-Beiträge lesen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476434/">https://habr.com/ru/post/de476434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476418/index.html">Startups: 10 Imbissbuden aus 20 Lektionen an der Stanford University</a></li>
<li><a href="../de476420/index.html">Starten Sie ReactiveX von Anfang an in Dart und Flutter</a></li>
<li><a href="../de476424/index.html">Frameworks - mehr Minuspunkte als Pluspunkte</a></li>
<li><a href="../de476428/index.html">Nginx VTS Stats, Mockify - Mock API, Wiremock und Mockify Vergleich</a></li>
<li><a href="../de476430/index.html">So erstellen Sie das perfekte technische Portfolio</a></li>
<li><a href="../de476436/index.html">Berichte vom ersten Treffen der Roboterentwickler in Russland über das Roboterbetriebssystem</a></li>
<li><a href="../de476442/index.html">Geben Sie etwas Platz oder einen Mikrocontroller wie ein Frequenzmesser</a></li>
<li><a href="../de476444/index.html">Entmystifizierung der Prinzipien des Quantencomputers</a></li>
<li><a href="../de476446/index.html">Jira Plugins: Einige Beispiele für die erfolgreiche Erfindung des Fahrrads</a></li>
<li><a href="../de476448/index.html">Erkundung des Sandshaders des Journey-Spiels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>