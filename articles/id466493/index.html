<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸ–‹ï¸ ğŸ—» Docker: Untuk memulai. Perhatian Sebarkan ğŸ˜ˆ â²ï¸ ğŸ“ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seberapa sering Anda harus mengkonfigurasi lingkungan server untuk menggunakan aplikasi Anda (misalnya, situs web)? Tentunya lebih sering daripada yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: Untuk memulai. Perhatian Sebarkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466493/">  Seberapa sering Anda harus mengkonfigurasi lingkungan server untuk menggunakan aplikasi Anda (misalnya, situs web)?  Tentunya lebih sering daripada yang saya inginkan. <br><br>  Dalam kasus terbaik, Anda memiliki skrip yang melakukan semua ini secara otomatis.  Dalam kasus terburuk, bisa terlihat seperti ini: <br><br><ul><li>  instal database D versi xxx </li><li>  instal server web N versi xx, dll. </li></ul><br>  Pengelolaan lingkungan yang dikonfigurasi dengan cara ini menjadi sangat intensif sumber daya seiring waktu.  Apa pun, bahkan perubahan kecil dalam konfigurasi setidaknya berarti: <br><br><ul><li>  bahwa setiap pengembang harus mengetahui perubahan ini </li><li>  semua perubahan ini harus ditambahkan dengan aman ke lingkungan produksi </li></ul><br>  Sulit untuk melacak perubahan tersebut dan mengelolanya tanpa alat khusus.  Lagi pula, ada masalah dengan konfigurasi dependensi lingkungan.  Semakin jauh perkembangan bergerak, semakin sulit untuk menemukan dan memperbaiki masalah ini. <br><br>  Di atas, saya menggambarkan apa yang disebut vendor lock-in.  Untuk pengembangan aplikasi, khususnya tipe server, fenomena ini menjadi masalah besar.  Pada artikel ini, kami akan mempertimbangkan salah satu solusi yang mungkin - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> .  Anda akan belajar cara membuat, menggunakan, dan menjalankan aplikasi berdasarkan itu. <br><br><img src="https://habrastorage.org/webt/kq/dw/bz/kqdwbzueemmplbdx1n6cocyz1nq.png"><br><a name="habracut"></a><br>  <b>/ Penafian: /</b> Ini bukan review dari Docker.  Di akhir artikel ini adalah daftar literatur yang berguna yang menjelaskan cara bekerja dengan Docker lebih baik.  Ini adalah titik masuk pertama untuk pengembang yang berencana untuk menyebarkan aplikasi node.js menggunakan wadah Docker. <br><br>  Saat mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu proyek saya</a> , saya dihadapkan dengan kurangnya artikel rinci, yang memunculkan sejumlah besar sepeda.  Posting ini agak terlambat mencoba untuk memperbaiki kekurangan informasi tentang topik tersebut. <br><br><h2>  Dengan apa dan dengan apa ia makan? </h2><br>  Dengan kata sederhana, Docker adalah abstraksi dari wadah LXC.  Ini berarti bahwa proses yang diluncurkan menggunakan Docker hanya akan melihat diri mereka sendiri dan turunannya.  Proses semacam itu disebut wadah Docker. <br><br>  Untuk dapat membuat semacam abstraksi berdasarkan wadah tersebut, gambar ada di Docker (/ docker image /).  Berdasarkan gambar Docker, Anda dapat mengonfigurasi dan membuat wadah. <br><br>  Ada ribuan gambar Docker yang sudah jadi dengan basis data yang sudah diinstal, server web dan elemen penting lainnya.  Keuntungan lain dari Docker adalah alat ini sangat ekonomis untuk konsumsi memori, karena hanya menggunakan sumber daya yang dibutuhkan. <br><br><h2>  Lebih dekat </h2><br>  Kami tidak akan berkutat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instalasi untuk waktu yang</a> lama.  Proses selama beberapa rilis terakhir telah disederhanakan menjadi beberapa klik / tim. <br><br>  Pada artikel ini, kami akan menganalisis penyebaran aplikasi Docker menggunakan contoh aplikasi Node.js sisi server.  Berikut ini adalah kode sumber primitifnya: <br><br><pre><code class="plaintext hljs">// index const http = require('http'); const server = http.createServer(function(req, res) { res.write('hello world from Docker'); res.end(); }); server.listen(3000, function() { console.log('server in docker container is started on port : 3000'); });</code> </pre> <br>  Kami memiliki setidaknya dua cara untuk mengemas aplikasi dalam wadah Docker: <br><br><ul><li>  membuat dan menjalankan wadah dari gambar yang ada menggunakan alat command-line-interface; </li><li>  buat gambar Anda sendiri berdasarkan sampel yang sudah jadi. </li></ul><br>  Metode kedua lebih sering digunakan. <br><br>  Untuk memulai, unduh gambar resmi node.js: <br><br><pre> <code class="plaintext hljs">docker pull node</code> </pre> <br>  Perintah menarik buruh pelabuhan mengunduh gambar Docker.  Setelah itu, Anda dapat menjalankan perintah run docker.  Ini akan membuat dan menjalankan wadah berdasarkan gambar yang diunduh. <br><br><pre> <code class="plaintext hljs">docker run -it -d --rm -v "$PWD":/app -w=/app -p 80:3000 node node index.js</code> </pre> <br>  Perintah ini akan meluncurkan file index.js, memetakan 3000 port ke 80 dan menampilkan id dari wadah yang dibuat.  Sudah lebih baik!  Tetapi pada satu CLI Anda tidak akan pergi jauh.  Mari kita membuat Dockerfile untuk server kami. <br><br><pre> <code class="plaintext hljs">FROM node WORKDIR /app RUN cp . /app CMD ["node", "index.js"]</code> </pre> <br>  Dockerfile ini menjelaskan gambar dari mana versi saat ini diwarisi, serta direktori di mana perintah kontainer dan perintah file salin akan mulai dari direktori di mana perakitan gambar diluncurkan.  Baris terakhir menunjukkan perintah mana yang akan dijalankan dalam wadah yang dibuat. <br><br>  Selanjutnya, kita perlu membuat gambar dari Dockerfile ini yang akan kita gunakan: <i>docker build -t username / helloworld-with-docker: 0.1.0</i> .  Perintah ini menciptakan gambar baru, menandainya dengan <i>nama pengguna / helloworld-dengan-buruh pelabuhan</i> dan membuat tag 0,1.0. <br><br>  Wadah kami sudah siap.  Kita bisa menjalankannya dengan perintah run docker.  Jadi, kami memecahkan masalah penguncian vendor.  Peluncuran aplikasi tidak lagi tergantung pada lingkungan.  Kode dikirimkan bersama dengan gambar Docker.  Dua kriteria ini memungkinkan kami untuk menyebarkan aplikasi ke tempat di mana kami dapat menjalankan Docker. <br><br><h2>  Sebarkan </h2><br>  99% pertama tidak begitu mengerikan seperti 99% sisanya. <br><br>  Setelah kami menyelesaikan semua instruksi di atas, proses penyebaran itu sendiri menjadi masalah teknologi dan lingkungan pengembangan Anda.  Kami akan mempertimbangkan 2 opsi untuk menggunakan Docker: <br><br><ul><li>  penyebaran gambar Docker secara manual; </li><li>  penyebaran menggunakan Travis-CI. </li></ul><br>  Dalam setiap kasus, kami akan mempertimbangkan pengiriman gambar ke lingkungan yang independen, misalnya, server pementasan produk Anda. <br><br><h3>  Penerapan manual </h3><br>  Opsi ini baik jika Anda tidak memiliki lingkungan integrasi berkelanjutan.  Pertama, Anda perlu mengunggah gambar Docker ke lokasi yang dapat diakses oleh server pementasan.  Dalam kasus kami, ini akan menjadi DockerHub.  Untuk setiap pengguna, ia menyediakan satu repositori gambar pribadi gratis dan repositori publik dalam jumlah tak terbatas. <br><br>  Masuk untuk mengakses DockerHub kami: <br><br><pre> <code class="plaintext hljs">docker login -e username@gmail.com -u username -p userpass</code> </pre> <br>  Kami <i>memuat</i> gambar kami di sana: <i>buruh pelabuhan mendorong nama pengguna / helloworld-dengan-buruh pelabuhan: 0.1.0.</i> <br><br>  Selanjutnya, buka server pementasan (saya ingatkan Anda bahwa Docker harus sudah diinstal sebelumnya). <br><br>  Untuk menggunakan aplikasi kita di server, kita hanya perlu menjalankan satu perintah: <br><br><pre> <code class="plaintext hljs">docker run -d --rm -p 80:3000 username/helloworld-with-docker:0.1.0.</code> </pre> <br>  Dan itu saja!  Periksa daftar gambar lokal.  Jika Anda tidak menemukan hasil yang Anda inginkan, masukkan <i>nama pengguna / helloworld-dengan-buruh pelabuhan</i> untuk memeriksa registri DockerHub.  Gambar dengan nama ini dapat ditemukan di register, karena kami sudah mengunggahnya di sana.  Docker mengunduhnya, membuat wadah berdasarkan itu, dan meluncurkan aplikasi Anda di dalamnya. <br><br>  Sekarang, setiap kali Anda perlu memperbarui versi aplikasi Anda, Anda dapat mendorong dengan tag baru dan hanya me-restart wadah di server setiap kali. <br><br>  PS Metode ini tidak disarankan jika dimungkinkan untuk menggunakan Travis-CI. <br><br><h3>  Menyebarkan dengan Travis-CI </h3><br>  Pertama, tambahkan data DockerHub ke Travis-CI.  Mereka akan disimpan dalam variabel lingkungan. <br><br><pre> <code class="plaintext hljs">travis encrypt DOCKER_EMAIL=email@gmail.com travis encrypt DOCKER_USER=username travis encrypt DOCKER_PASS=password</code> </pre> <br>  Kemudian kami menambahkan kunci yang diterima ke file .travis.yml.  Kami juga akan menambahkan komentar untuk setiap kunci untuk membedakannya di masa mendatang. <br><br><pre> <code class="plaintext hljs">env: global: - secure: "UkF2CHX0lUZ...VI/LE=" # DOCKER_EMAIL - secure: "Z3fdBNPt5hR...VI/LE=" # DOCKER_USER - secure: "F4XbD6WybHC...VI/LE=" # DOCKER_PASS</code> </pre> <br>  Selanjutnya, kita perlu masuk dan mengunduh gambar: <br><br><pre> <code class="plaintext hljs">after_success: - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS - docker build -f Dockerfile -t username/hello-world-with-travis. - docker tag username/hello-world-with-travis 0.1.0 - docker push username/hello-world-with-travis</code> </pre> <br>  Selain itu, pengiriman gambar dapat diluncurkan dari Travis-CI dengan berbagai cara: <br><br><ul><li>  secara manual; </li><li>  melalui koneksi ssh; </li><li>  layanan penyebaran online (Menyebarkan Bot, deployhq); </li><li>  AWS CLI; </li><li>  Kubernate; </li><li>  Alat untuk penyebaran Docker. </li></ul><br><h2>  Ringkasan </h2><br>  Pada artikel ini, kami memeriksa persiapan dan penyebaran Docker menggunakan server node.js sederhana sebagai contoh dalam dua cara: otomatis dan otomatis menggunakan Travis-CI.  Saya harap artikel ini bermanfaat bagi Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466493/">https://habr.com/ru/post/id466493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466477/index.html">Penggunaan PVS-Studio saat Memeriksa Proyek Mesin Tidak Nyata pada OS Windows</a></li>
<li><a href="../id466479/index.html">Menggunakan PVS-Studio ketika memeriksa proyek-proyek Unreal Engine pada sistem operasi Windows</a></li>
<li><a href="../id466485/index.html">Mobil listrik dari tahun 90an. Bagian 1. Brothers Citroen dan Peugeot</a></li>
<li><a href="../id466489/index.html">Insinyur Korea menyarankan menggunakan Hololens sebagai alternatif untuk partisi kantor</a></li>
<li><a href="../id466491/index.html">Proyek Pelatihan di Godot - Pong (Bagian 2) Membuat dan Menyiapkan Bola</a></li>
<li><a href="../id466495/index.html">Bagaimana tidak salah dengan persaingan di Go</a></li>
<li><a href="../id466497/index.html">Lingkungan modern untuk aplikasi Bereaksi Asli</a></li>
<li><a href="../id466499/index.html">C / C ++ dari Python (ctypes)</a></li>
<li><a href="../id466501/index.html">Tindakan Github dan pembangunan lintas platform</a></li>
<li><a href="../id466503/index.html">Slurm DevOps. Hari kedua IaC, pengujian infrastruktur dan â€œSlurm menginspirasi!â€</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>