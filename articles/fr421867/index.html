<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏻 ⛹🏾 🤨 Comment rendre le code lisible 🏆 🙏🏻 👉🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parfois, nous avons tous écrit (et certains écrivent) du mauvais code, et j'espère que nous travaillons tous pour améliorer nos compétences, et pas se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre le code lisible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421867/"><p><img src="https://habrastorage.org/getpro/habr/post_images/9f7/d4e/dac/9f7d4edacc48f0d12bc8e501d349aeb0.jpg" alt="Comment rendre le code lisible"></p><br><p>  Parfois, nous avons tous écrit (et certains écrivent) du mauvais code, et j'espère que nous travaillons tous pour améliorer nos compétences, et pas seulement pour lire des articles comme celui-ci. </p><br><h3 id="zachem-nam-pisat-horoshiy-kod-a-ne-prosto-proizvoditelnyy-kod">  Pourquoi devons-nous écrire du bon code, pas seulement du code productif? </h3><br><p>  Bien que les performances de votre produit ou site soient importantes, l'apparence de votre code l'est également.  La raison en est que <strong>non seulement la machine lit votre code</strong> . </p><a name="habracut"></a><br><p>  Premièrement, tôt ou tard, vous devrez relire votre propre code et, le moment venu, seul un code bien écrit vous aidera à comprendre ce que vous avez écrit ou à trouver comment le corriger. </p><br><p>  Deuxièmement, si vous travaillez en équipe ou collaborez avec d'autres développeurs, tous les membres de l'équipe liront votre code et essaieront de l'interpréter comme ils le comprennent.  Pour leur faciliter la tâche, il est important de suivre certaines règles lors de la dénomination des variables et des fonctions, de limiter la longueur de chaque ligne et de préserver la structure de votre code. </p><br><p>  Enfin, regardons un exemple spécifique. </p><br><h2 id="chast-1-kak-opredelit-plohoy-kod">  Partie 1: Comment identifier le mauvais code? </h2><br><p>  La façon la plus simple d'identifier un mauvais code, à mon avis, est <strong>d'essayer de lire le code comme s'il s'agissait d'une phrase ou d'une phrase</strong> . </p><br><p>  Par exemple, jetez un œil à ce code: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/552/48c/156/55248c156e1ada5ace2f4cc00c42473a.jpg" alt="Capture d'écran d'une mauvaise version de traverseUpUntil"></p><br><p>  Capture d'écran d'une mauvaise version de traverseUpUntil </p><br><p>  La fonction présentée ci-dessus accepte un élément et une fonction conditionnelle et renvoie le nœud parent le plus proche qui satisfait la fonction conditionnelle. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traverseUpUntil = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, f</span></span></span><span class="hljs-function">) =&gt;</span></span> {</code> </pre> <br><p>  Sur la base du fait que le code doit être lu comme du texte brut, la première ligne a trois défauts grossiers. </p><br><ul><li>  <strong>Les paramètres de fonction ne sont pas lus comme des mots</strong> . </li><li>  Supposons que <code>el</code> puisse être compris, car un tel nom est généralement utilisé pour désigner un élément, mais le nom du paramètre <code>f</code> n'explique rien du tout. </li><li>  Le nom de la fonction peut être lu comme ceci: "commutateur jusqu'à ce que el passe f", qui est probablement mieux lu comme "commutateur jusqu'à ce que f passe pour el".  Bien sûr, la meilleure façon de procéder consiste à autoriser la fonction à être appelée <code>el.traverseUpUntil(f)</code> , mais c'est un autre problème. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = el.parentNode</code> </pre> <br><p>  Ceci est la deuxième ligne.  Encore une fois, le problème avec les noms, cette fois avec la variable.  Si quelqu'un regardait le code, alors très probablement, il comprendrait ce qu'est <code>p</code> .  Il s'agit du <code>parentNode</code> paramètre <code>el</code> .  Cependant, ce qui se passe quand on regarde <code>p</code> utilisé ailleurs, <strong>on n'a plus de contexte qui explique ce que c'est</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (p.parentNode &amp;&amp; !f(p)) {</code> </pre> <br><p>  Sur la ligne suivante, le principal problème auquel nous sommes confrontés est un manque de compréhension de ce que <code>!f(p)</code> signifie ou fait, car <strong>«f» peut signifier n'importe quoi</strong> .  On suppose que la personne qui lit le code doit comprendre que <code>!f(p)</code> est une vérification du nœud actuel pour satisfaire une certaine condition.  S'il passe, alors le cycle est interrompu. </p><br><pre> <code class="javascript hljs">p = p.parentNode</code> </pre> <br><p>  Tout est clair ici. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p</code> </pre> <br><p>  Ce qui est retourné n'est pas entièrement évident en raison d'un nom de variable non valide. </p><br><h2 id="chast-2-davayte-otrefaktorim">  Partie 2: Refactorons </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ac/501/5fb/2ac5015fbc682423616325ec10dddf5e.jpg" alt="Capture d'écran d'une bonne version de traverseUpUntil"></p><br><p>  Capture d'écran d'une bonne version de traverseUpUntil </p><br><p>  Tout d'abord, nous changeons les noms des paramètres et leur ordre: <code>(el, f) =&gt;</code> en <code>(condition, node) =&gt;</code> . <br>  Vous vous demandez peut-être pourquoi au lieu de «élément (élément russe), j'ai utilisé« nœud »( <em>nœud</em> russe).  Je l'ai utilisé pour les raisons suivantes: </p><br><ul><li>  Nous écrivons du code en termes de nœuds, par exemple <code>.parentNode</code> , alors pourquoi ne pas le rendre cohérent. </li><li>  «Node» est plus court que «element», et le <strong>sens n'est pas perdu</strong> . </li></ul><br><p>  Ensuite, nous passons aux noms de variables: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = node</code> </pre> <br><p>  Il est très important de <strong>divulguer complètement la valeur de votre variable dans son nom</strong> , donc "p" est maintenant "parent" ( <em>parent</em> russe).  Vous avez peut-être également remarqué que maintenant nous ne commençons pas par obtenir le <code>node.parentNode</code> parent, mais uniquement le nœud. </p><br><p>  Nous allons plus loin: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { parent = parent.parentNode } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (parent.parentNode &amp;&amp; !condition(parent))</code> </pre> <br><p>  Au lieu de la <code>while</code> habituelle <code>while</code> j'ai choisi la <code>do ... while</code> .  Cela signifie que nous devons obtenir le nœud parent à chaque fois avant de vérifier les conditions, et non l'inverse.  L'utilisation de la <code>do ... while</code> permet également de lire du code comme du texte brut. </p><br><p>  Essayons de lire: <strong>"Affectez le nœud parent du parent au parent, tant que le parent a un nœud parent et que la fonction de condition ne renvoie pas true</strong> . <strong>"</strong>  Déjà beaucoup plus clair. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parent</code> </pre> <br><p>  Souvent, les développeurs préfèrent utiliser une sorte de variable commune <code>ret</code> (ou <code>returnValue</code> ), <strong>mais c'est une très mauvaise pratique</strong> .  Si vous nommez correctement vos variables de retour, il devient évident ce qui est retourné.  Cependant, les fonctions peuvent parfois être longues et complexes, ce qui crée beaucoup de confusion.  Dans ce cas, <strong>je suggère de diviser votre fonction en plusieurs fonctions</strong> , et si elle est encore trop compliquée, l'ajout de commentaires peut peut-être aider. </p><br><h2 id="chast-3-uproschenie-koda">  Partie 3: Simplification du code </h2><br><p>  Maintenant que vous avez rendu le code lisible, il est temps <strong>de supprimer le code inutile</strong> .  Je suis sûr que certains d'entre vous ont déjà remarqué que nous n'avons pas du tout besoin de la variable <code>parent</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traverseUpUntil = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition, node</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { node = node.parentNode } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node.parentNode &amp;&amp; !condition(node)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node }</code> </pre> <br><p>  J'ai simplement supprimé la première ligne et remplacé «parent» par «nœud».  J'ai donc sauté l'étape inutile de créer un «parent» et je suis allé directement dans la boucle. </p><br><h3 id="no-chto-naschyot-imeni-peremennoy">  Mais qu'en est-il du nom de variable? </h3><br><p>  Bien que «nœud» ne soit pas la meilleure description de cette variable, il est satisfaisant.  Mais ne nous arrêtons pas là, renommons-le.  Qu'en est-il de "currentNode"? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traverseUpUntil = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition, currentNode</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { currentNode = currentNode.parentNode } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (currentNode.parentNode &amp;&amp; !condition(currentNode)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentNode }</code> </pre> <br><p>  C'est mieux!  Maintenant, lorsque nous lisons la méthode, nous savons que <code>currentNode</code> représente toujours le nœud dans lequel nous nous trouvons maintenant, au lieu d'être un nœud "d'une sorte". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421867/">https://habr.com/ru/post/fr421867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421851/index.html">Problèmes de hibou et de globe: connexion de deux assemblys avec des espaces de noms et des noms de classe identiques</a></li>
<li><a href="../fr421855/index.html">Projecteurs à domicile: les meilleurs «selon la version», mise au point ultra courte, champions de la luminosité et de la vitesse</a></li>
<li><a href="../fr421857/index.html">ToFoIn v 1. Réservation de passerelles et commutation entre canaux externes dans FreeBSD</a></li>
<li><a href="../fr421859/index.html">Notes du fournisseur IoT. Appareils et surenchérir</a></li>
<li><a href="../fr421863/index.html">Une nouvelle façon de créer des nanotubes: désormais en couleur</a></li>
<li><a href="../fr421869/index.html">Créez une application Android pour la détection de visage en temps réel à l'aide du kit Firebase ML</a></li>
<li><a href="../fr421871/index.html">Comment échouer lamentablement de la migration Java vers Kotlin dans une application Android</a></li>
<li><a href="../fr421873/index.html">Modèles de conception Kotlin</a></li>
<li><a href="../fr421875/index.html">Diagnostics SENS. Biomarqueurs intracellulaires «déchets»</a></li>
<li><a href="../fr421877/index.html">Immersion profonde dans le dossier .idea dans Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>