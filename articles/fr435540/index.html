<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔭 ⛓️ 👦🏾 Nouveaux mots clés en Java ✅ 🥟 👨🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un avenir proche, de nouvelles fonctionnalités apparaîtront dans le langage Java, qui sont actuellement en cours d'élaboration dans le cadre des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouveaux mots clés en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435540/"> Dans un avenir proche, de nouvelles fonctionnalités apparaîtront dans le langage Java, qui sont actuellement en cours d'élaboration dans le cadre des projets de Valhalla, Panama et Loom.  Développer une langue n'est pas une tâche facile, surtout pas une langue dans laquelle l'accent est mis sur la compatibilité descendante;  par conséquent, pour que leur intégration dans Java se déroule sans problème, les architectes de langage doivent résoudre les problèmes fondamentaux accumulés. <br><br>  Hier (8 janvier), Brian Goetz, travaillant pour Oracle en tant qu'architecte de langage Java, a publié une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lettre «Nous avons besoin de plus de mots-clés, capitaine!» Sur la</a> liste de diffusion de Project Amber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a>  dans lequel il a proposé un moyen de résoudre le problème de l'ajout de nouveaux mots clés à la langue.  Par conséquent, les mots clés peuvent apparaître dans la langue telle que <i>non nul</i> , <i>non final</i> , <i>éventuellement final</i> et <i>this-return</i> (une liste complète vous attend sous le découpage à la fin du post). <br><br>  Comme par le passé ce problème se posait rarement dans la langue, ils n'y pensaient généralement pas beaucoup et «essayaient de se déchaîner le plus rapidement possible»;  en raison des lacunes des approches existantes à l'avenir, leur application sera problématique et, à cet égard, il a été décidé de travailler à l'avance.  Solution proposée: essayer d'élargir l'ensemble des formes lexicales pouvant être utilisées comme mots clés: autoriser les mots clés séparés par un trait d'union, qui utiliseront un (ou plusieurs) mots clés existants ou un identifiant réservé. <br><br>  Remarque importante: Brown note que les nouveaux mots clés sont fournis uniquement à titre d'exemple et que vous ne devez pas vous concentrer sur eux.  Cependant, il est évident que nous avons devant nous une démonstration réfléchie de la façon dont la syntaxe du langage pourrait changer à l'avenir - dans la lettre, l'auteur mentionne que cette idée aidera à ajouter de nombreuses constructions de langage manquantes souhaitables à Java. <br><a name="habracut"></a><br><h3>  "Anciennes" méthodes </h3><br>  Comme vous le savez, il existe aujourd'hui dans le langage Java 50 mots-clés ( <i>mots-clés</i> ), dont l'utilisation est interdite comme identifiants des variables.  Une liste complète est donnée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la spécification du langage JLS dans la clause 3.9</a> .  Cette liste n'a pas beaucoup changé depuis la première version du langage - seule l' <i>assertion a été</i> ajoutée dans la version 4, l' <i>énumération</i> dans 5 et <i>_</i> dans 9. En plus d'eux, il existe également des «identifiants réservés» - <i>vrai</i> , <i>faux</i> et <i>nul</i> - qui se comportent de manière similaire aux mots clés façon. <br><br>  Lorsque les développeurs doivent ajouter un nouveau mot clé à la langue, ils doivent recourir à l'une des méthodes suivantes. <br><br><ul><li>  Transfert de propriété forcé: nous prenons les mots qui étaient auparavant des identifiants et les transformons en mots clés (par exemple, <i>affirmer</i> ). </li><li>  Élimination: un mot-clé existant commence à être utilisé d'une manière qui n'a jamais été destinée à être utilisée (un exemple est l'utilisation de la <i>valeur</i> par <i>défaut</i> pour les valeurs d'annotation ou les méthodes par défaut). </li><li>  Ne vous en servez pas: trouvez un moyen d'utiliser une syntaxe qui ne nécessite pas de nouveau mot clé - par exemple, utilisez l' <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interface</a></i> pour les annotations au lieu d' <i>annotation</i> - ou abandonnez complètement la fonctionnalité. </li><li>  Créer de la visibilité: créez l'illusion de <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mots clés</a></i> contextuels à l'aide de réalisations linguistiques héroïques ( <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mots clés restreints, noms de types réservés</a></i> ). </li></ul><br>  En principe, chacune de ces méthodes peut généralement être appliquée, mais chacune a ses inconvénients, et pour une extension sérieuse à grande échelle du langage, ces méthodes seules ne sont clairement pas suffisantes - pour les innovations futures, il sera nécessaire d'éliminer l'incapacité à étendre complètement la syntaxe du langage. <br><br><h4>  Ajout de nouveaux mots clés </h4><br>  Il y a les arguments suivants contre «juste» la prise et l'ajout de nouveaux mots. <br><br><ul><li>  Plus le mot-clé sélectionné est pratique et populaire, plus il apparaîtra souvent dans le code source des programmes, ce qui ajoutera une incompatibilité au langage (par exemple, lorsque le mot <i>assert</i> est apparu dans Java SE 1.4, tous les frameworks de test ont cessé de fonctionner). </li><li>  Le coût de l'élimination d'une telle incompatibilité de code par le développeur variera considérablement de petit (renommer une variable locale) à fatal (lorsqu'une méthode d'interface ou un type public est invalidé). </li><li>  Les mots que les développeurs de langage sont les plus susceptibles d'utiliser sont des identifiants populaires (par exemple, <i>valeur</i> , <i>var</i> ou <i>méthode</i> ); </li><li>  Si vous choisissez des mots qui sont rarement utilisés dans le code source et avec lesquels il y aura moins de collisions, vous devrez utiliser des constructions comme <i>habituellement_mais_not_always_final</i> , ce qu'il serait naturellement souhaitable d'éviter dans le langage. </li><li>  Si, cependant, vous avez recours à des mots rarement utilisés, l'utilisation trop fréquente de cette méthode ne fonctionnera pas - casser la compatibilité n'est pas bon, et il n'y a pas tellement de combinaisons plus réussies. </li></ul><br><h4>  Réutilisation des "anciens" mots clés </h4><br>  À propos de «simplement» continuer à vivre avec ces mots, il y a des considérations. <br><br><ul><li>  Des précédents de réutilisation des mots-clés dans différents contextes se retrouvent dans de nombreux langages de programmation (un exemple de Java est l'utilisation de ( <i>(ab) use</i> ) <i>final</i> pour les désignations «non mutable», «non redéfini» et «non extensible»). </li><li>  Parfois, cette approche est logique et vient d'elle-même, mais ce n'est généralement pas une priorité. </li><li>  Au fil du temps, l'ensemble des exigences pour un ensemble de mots clés s'élargit, et cela peut arriver à un point drôle - personne ne veut utiliser <i>null final</i> dans leur code. </li><li>  Si ce dernier vous a semblé exagéré, gardez à l'esprit qu'en travaillant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 325, ils ont</a> sérieusement suggéré d'utiliser la <i>nouvelle</i> construction de <i>commutateur</i> pour décrire le <i>commutateur</i> avec une sémantique différente - si vous continuez dans la même veine, après dix ans, nous pouvons atteindre <i>nouveau nouveau commutateur</i> . </li></ul><br>  Comment vivre sans nouveaux mots clés?  Il est possible d'arrêter complètement de s'engager dans l'évolution du langage, comme certains l'ont suggéré.  Mais ce n'est pas grave et ne correspond pas à l'opinion des autres, car les développeurs ont un intérêt sain pour les nouvelles fonctionnalités du langage. <br><br><h4>  Mots-clés contextuels </h4><br>  Les mots-clés contextuels qui sont utilisés pour fournir une signification spécifique dans le code, mais qui ne sont pas des mots réservés ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisés en C #</a> ) semblent à première vue être la même «baguette magique», mais ici, Brian donne son propre point de vue sur leur utilisation, basé sur la pratique ( par exemple, les implémentations <i>var</i> dans Java 10, qui n'est pas un mot-clé, mais <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un nom de type réservé</a></i> ).  En échange de l'illusion d'ajouter de nouveaux mots clés sans avoir à «casser» les programmes existants, nous obtenons une complexité et une distorsion accrues dans la langue. <br><br>  Les mots clés contextuels sont difficiles pour les rédacteurs de spécifications, les compilateurs et les IDE.  Dans le cas d'un ou deux cas spéciaux, cela ne pose pas de problème, mais lorsqu'ils commencent à être utilisés partout, cela se traduit par un coût beaucoup plus élevé de prise en charge du code ou de la queue des bogues. <br><br>  On pourrait rejeter cela - ils disent que ce n'est pas un problème des utilisateurs de la langue, mais de ses créateurs et de ceux qui écrivent des compilateurs et des IDE.  Mais en réalité, tout le monde souffre.  Pour l'IDE, cela peut être un problème important: plus de saisie sera nécessaire pour deviner ce que le développeur entre - un mot-clé contextuel ou un identifiant.  En conséquence, les utilisateurs obtiennent une détérioration du travail de mise en évidence de la syntaxe, d'auto-complétion et de refactorisation. <br><br>  Vous pouvez utiliser cet outil, mais faites-le avec prudence. <br><br><h3>  Distorsion de la langue </h3><br>  Il semblerait qu'avec les problèmes que ces approches causent - syntaxe maladroite, complication inutile de la vie et bugs - en principe, nous pourrions le supporter.  Mais il y a un autre problème qui n'est pas le plus évident - les nuances liées à l'utilisation de mots clés conduisent au fait que la conception de la langue elle-même est déformée. <br><br>  Pour les développeurs Java, écrire une <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interface</a></i> au lieu d' <i>annotation</i> est courant aujourd'hui, mais tout le monde conviendra que l'utilisation du terme convivial <i>annotation</i> au lieu d'une combinaison de @ et de l'ancien mot-clé serait beaucoup plus logique. <br><br>  Autre exemple: l'ensemble des modificateurs disponibles (public, privé, statique, final, etc.) ne peut pas être qualifié de complet - nous ne pouvons rien dire de <i>non final</i> ou de <i>statique</i> .  À son tour, cela signifie que vous ne pouvez pas créer d'entités dans lesquelles les variables ou les classes sont <i>finales</i> par défaut, ou les membres sont <i>statiques</i> par défaut, car il n'y a aucun moyen d'indiquer que nous aimerions abandonner ce modificateur. <br><br>  Ce problème n'est pas si évident pour ceux qui utilisent la langue - mais les auteurs de la langue elle-même, en raison de leur désir de la développer davantage, la rencontrent constamment, et nous devons tous payer pour de telles décisions (quand explicitement, implicitement). <br><br>  La conclusion de tout ce qui précède se suggère: nous avons besoin d'une autre source de mots clés. <br><br><h3>  Solution proposée </h3><br>  Dans les capacités expérimentales du langage, une syntaxe est utilisée pour pré-désigner de nouveaux mots clés, dans lesquels les nouveaux mots clés eux-mêmes sont précédés de deux traits de soulignement (par exemple, dans le prototype <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Project Valhalla,</a> il s'agit de <i>__ByValue</i> ).  La raison de cette décision est compréhensible - vous devez souligner qu'il s'agit d'un remplacement temporaire, pour lequel vous devrez à l'avenir prendre une décision sur la syntaxe finale, et en même temps, vous pouvez facilement éviter les conflits avec le code existant.  On pourrait suggérer d'utiliser un format similaire pour les nouveaux mots clés - en commençant par un ou deux traits de soulignement - mais cette solution ne peut pas être qualifiée de belle, car dans ce cas, nous obtiendrons la confusion des mots clés ordinaires et nouveaux. <br><br>  Par conséquent, il est proposé d'utiliser des mots clés construits à l'aide d'un trait d'union, qui utiliseront un ou plusieurs «anciens» mots clés ou identifiants réservés. <br><br>  Contrairement <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aux mots</a></i> - <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clés restreints</a></i> , cette approche créera beaucoup moins de problèmes d'analyse, car (ci-après dénommé exemple) <i>ne</i> peut pas être confondu avec une expression de soustraction, et un lexer peut toujours déterminer si <i>ab est</i> trois jetons ou un.  Grâce à cela, de nouvelles opportunités s'ouvrent à nous pour créer des mots clés qui sont beaucoup moins susceptibles d'entrer en conflit avec le code source existant ou entre eux.  En plus de cela, ils sont beaucoup plus susceptibles d'avoir des noms significatifs, car une grande partie de ce que les créateurs du langage veulent ajouter à Java est basé sur des constructions de langage existantes - par exemple, <i>non nulles</i> . <br><br>  A titre d'exemples de nouveaux mots-clés, des candidats probables à la place de nouveaux mots-clés sont donnés (je rappelle que selon l'auteur, pour l'instant cette liste est purement illustrative): <br><br>  - <i>non nul</i> ; <br>  - <i>non final</i> ; <br>  - <i>package-private</i> (modificateur du niveau d'accès aux membres de la classe par défaut, qui n'est actuellement indiqué en aucune façon); <br>  - <i>lecture</i> publique ( <i>lecture</i> publique, enregistrement privé); <br>  - <i>vérifié nul</i> ; <br>  - <i>type-statique</i> (le concept nécessaire pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valhalla</a> ; désigne statique par rapport à la spécialisation spécifique de la classe, et non la classe elle-même); <br>  - <i>valeur par défaut</i> ; <br>  - <i>éventuellement final</i> (ce qui est maintenant censé être fait en utilisant l'annotation <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Stable</a></i> ), <br>  - <i>demi-finale</i> (comme alternative à <i>scellé</i> ); <br>  - <i>commutateur exhaustif</i> ; <br>  - <i>enum-class</i> , <i>annotation-class</i> , <i>record-class</i> (les auteurs de langues pourraient utiliser ces mots clés comme alternative à <i>enum</i> et <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interface</a></i> , s'ils en avaient l'occasion); <br>  - <i>this-class</i> (pour décrire le littéral de classe pour la classe actuelle); <br>  - <i>this-return</i> (souvent demandé d'ajouter un moyen de marquer le setter / method-builder comme retournant son destinataire). <br><br>  Il existe sûrement d'autres variantes de schémas lexicaux selon lesquels il serait possible de composer des mots-clés pour qu'ils se chevauchent au minimum avec ceux déjà écrits par le code source.  Le trait d'union proposé est suffisamment lisible pour les voitures et les humains. <br><br>  Il est entendu que cette approche n'exclut nullement la possibilité de l'utiliser avec celles qui ont été utilisées auparavant, mais sera utilisée avec elles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435540/">https://habr.com/ru/post/fr435540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435530/index.html">Abonnements payants - Dépendance de la connexion automatique à un appareil mobile</a></li>
<li><a href="../fr435532/index.html">Tornado vs Aiohttp: un voyage dans le désert des frameworks asynchrones</a></li>
<li><a href="../fr435534/index.html">Science des données: livres d'entrée de gamme</a></li>
<li><a href="../fr435536/index.html">Robots humanoïdes: avantages et problèmes des mécanismes anthropomorphes</a></li>
<li><a href="../fr435538/index.html">En 2018, plus d'énergie «verte» a été reçue en Allemagne que l'électricité issue de la combustion du charbon</a></li>
<li><a href="../fr435542/index.html">Développement du jeu et défense d'un diplôme ou "Comment j'ai tué deux oiseaux avec une première galette de pierre"</a></li>
<li><a href="../fr435544/index.html">Un employé de l'Université Innopolis a reçu une subvention Facebook</a></li>
<li><a href="../fr435546/index.html">Conseils pratiques, exemples et tunnels SSH</a></li>
<li><a href="../fr435548/index.html">Piratage des services publics - possible, si vraiment nécessaire</a></li>
<li><a href="../fr435550/index.html">GitLab 11.6 publié avec des fonctionnalités sans serveur et des clusters Kubernetes pour les groupes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>