<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏿 📇 🛀 Nous recherchons une aiguille dans une pile sans utiliser d'algorithmes bien connus 👨🏿‍💼 ♐️ 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle méthode pour trouver une aiguille est plus rapide? Trier à travers une paille, ou chercher accidentellement? 

 Je pense que le meilleur moyen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous recherchons une aiguille dans une pile sans utiliser d'algorithmes bien connus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/x9/nq/rex9nqzmrtcwxfesouowufue66q.jpeg"></div><br>  Quelle méthode pour trouver une <em>aiguille est</em> plus rapide?  Trier à travers une paille, ou chercher accidentellement? <br><br>  Je pense que le meilleur moyen est d'expérimenter, malheureusement je n'ai pas de meule de foin, mais j'ai des connaissances de base en programmation, un microcontrôleur Arduino, un environnement pratique pour écrire du code, donc tout le monde peut le répéter. <br><a name="habracut"></a><br><h4>  Première étape «Comprendre» </h4><br>  Quelles données dois-je recevoir?  Temps passé à trouver la bonne solution.  La seule exécution ne convient pas en raison des spécificités de l'expérience, vous devez vérifier la méthode plusieurs fois, puis le temps qui m'intéresse est moyen.  J'ai décidé.  L'étape suivante consiste à déterminer le nombre et les variables à déclarer.  Nous avons besoin d'une variable distincte pour chaque méthode afin de stocker la somme des temps, appelons-la: <br><br>  "Time_poslMetod" et "Time_randMetod". <br><br>  Besoin d'une constante sur le nombre d'itérations: <br><br>  # définir Iter 1000. <br><br>  La valeur de sortie est obtenue en divisant la première par le nombre d'itérations. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; //  uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0;</span></span></span></span></code> </pre> <br><h4>  Deuxième étape «écrire du code» </h4><br>  La boucle For gère le nombre d'itérations, à l'intérieur nous allons «jeter» l' <em>aiguille</em> dans la botte de foin, effectuer une recherche, mesurer le temps pour chaque méthode séparément, enregistrer le temps dans une variable «globale» (Time_poslMetod / Time_randMetod) (pour l'avenir). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //     needle = random(cell + 1); potenArr[needle] = 1; //          poslMetod(); randMetod(); }</span></span></code> </pre><br>  Voici à quoi ressemblent mes méthodes. <br><br>  Méthode séquentielle: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poslMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cell; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_poslMetod += endTime; }</code> </pre><br>  Avant le tout début, nous mémorisons l'heure, puis la soustrayons de l'heure de fin de la recherche.  Nous parcourons le tableau (pile) du premier élément au dernier.  Lorsque nous trouvons l' <em>aiguille,</em> écrivez l'heure, mettez fin à la recherche, ajoutez l'heure à la variable «globale» (Time_poslMetod) et quittez la méthode. <br><br>  Méthode aléatoire: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r = random(cell + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[r] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_randMetod += endTime; }</code> </pre><br>  La différence est que nous vérifions un élément de tableau aléatoire (une place dans la pile), comptons sur la chance jusqu'à ce que nous soyons chanceux et trouvions une <em>aiguille</em> , donc nous utilisons une boucle infinie, l'essentiel est que nous ayons une condition de sortie, donc ne nous inquiétons pas.  Lorsque nous trouvons l' <em>aiguille</em> , enregistrons l'heure, terminez la recherche, ajoutez l'heure à la variable «globale» (Time_randMetod) et quittez la méthode. <br><br>  Vous remarquerez peut-être que la méthode ne nous garantit aucune garantie qu'elle est plus rapide, de cette façon, elle semble encore plus lente, car si la chance n'est pas de notre côté, nous pouvons bien faire plus de 100 vérifications des emplacements de la pile et échouer, à ce moment-là comme dans une méthode séquentielle de 100 contrôles, cela signifierait que nous avons vérifié la pile entière et que nous aurions certainement trouvé une aiguille passant le temps maximum pour cette méthode.  Néanmoins, je suis pour l'expérience, alors continuons. <br><br>  Mettre tout cela ensemble, polir le code, rendre la sortie pratique pour la compréhension: <br><br><div class="spoiler">  <b class="spoiler_title">Code entier</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; // ,         uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0; void poslMetod(); void randMetod(); void cleanArr(); void DataOutPrint(); void setup() { randomSeed(analogRead(A0)); Serial.begin(115200); } void loop() { Time_poslMetod = 0; Time_randMetod = 0; Serial.println(" "); Serial.println("Start"); calculationStartTime = millis(); //   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //        needle = random(cell + 1); potenArr[needle] = 1; //           poslMetod(); randMetod(); } //       DataOutPrint(); delay(2000); } void poslMetod(){ startTime = millis(); for(uint16_t i = 0; i &lt; cell; i++){ if(potenArr[i] == 1){ endTime = millis() - startTime; break; } } Time_poslMetod += endTime; } void randMetod(){ startTime = millis(); for(;;){ uint16_t r = random(cell + 1); if(potenArr[r] == 1){ endTime = millis() - startTime; break; } } Time_randMetod += endTime; } void cleanArr(){ for(uint16_t i = 0; i &lt; cell; i++){ potenArr[i] = 0; } } void DataOutPrint(){ calculationEndTime = (millis() - calculationStartTime)/1000; float OUTposl = (float)Time_poslMetod/Iter; float OUTrand = (float)Time_randMetod/Iter; Serial.println(" "); Serial.print("Number of iterations = "); Serial.println(Iter); Serial.print("Time for calculate (sec) = "); Serial.println(calculationEndTime); Serial.print("Posledovatelniy metod - AverageTime (ms) = "); Serial.println(OUTposl,3); Serial.print("Randomniy metod - AverageTime (ms) = "); Serial.println(OUTrand,3); }</span></span></span></span></code> </pre><br></div></div><br><h4>  Troisième étape «Analyse des résultats» </h4><br>  Nous obtenons: <br><br><img src="https://habrastorage.org/webt/4q/at/vb/4qatvb61ehgttrqdq4qp0q28lxe.jpeg"><br><br>  Honnêtement, je suis surpris des résultats.  Ayant parié l'argent que les temps seront proches, je perdrais. <br><br>  Juste ce dont j'avais peur, la chance s'est détournée de moi (nous).  Ce serait de vérifier comment les choses auraient été si si nous avions sélectionné chaque cellule suivante de la pile, nous n'aurions pas sélectionné celles déjà vérifiées.  En attendant, nous garderons à l'esprit que l'étude de la programmation, des mathématiques et des sciences exactes est utile pour réduire le temps nécessaire aux opérations de routine ennuyeuses, laissant du temps pour quelque chose d'amusant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439336/">https://habr.com/ru/post/fr439336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439326/index.html">Pick-up électrique Ford F-150 EV - dans le prototype et testé sur la route</a></li>
<li><a href="../fr439328/index.html">Ok Google! Êtes-vous bon ou mauvais?</a></li>
<li><a href="../fr439330/index.html">Reconnaissance des nombres. Comment nous avons obtenu une précision de 97% pour les nombres ukrainiens. 2e partie</a></li>
<li><a href="../fr439332/index.html">Fonctionnement du PageRank: implémentation en R via l'algèbre linéaire et la méthode d'alimentation</a></li>
<li><a href="../fr439334/index.html">Environ 2 milliards de roubles affectés à la mise en œuvre du projet de loi sur le runet durable</a></li>
<li><a href="../fr439338/index.html">Oubliez la confidentialité: vous avez toujours un ciblage terrible</a></li>
<li><a href="../fr439340/index.html">Sauvegarde GDPR - Comment le nouvel outil vous aidera</a></li>
<li><a href="../fr439342/index.html">DIYorDIE Winter Meetup 17 février</a></li>
<li><a href="../fr439344/index.html">Comme un troll: comment les monopoles gouvernent les brevets</a></li>
<li><a href="../fr439346/index.html">Laravel + Docker: notre expérience réussie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>