<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèΩ üêù üç≥ Monolith f√ºr Hunderte von Client-Versionen: Wie wir Tests schreiben und unterst√ºtzen üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üëÜ ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Ich bin ein Backend-Entwickler im Badoo-Serverteam. Auf der HighLoad-Konferenz im letzten Jahr habe ich eine Pr√§sentation gehalte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolith f√ºr Hunderte von Client-Versionen: Wie wir Tests schreiben und unterst√ºtzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Hallo allerseits! <br><br>  Ich bin ein Backend-Entwickler im Badoo-Serverteam.  Auf der HighLoad-Konferenz im letzten Jahr habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Pr√§sentation gehalten</a> , deren Textversion ich mit Ihnen teilen m√∂chte.  Dieser Beitrag ist besonders n√ºtzlich f√ºr diejenigen, die selbst Tests f√ºr das Backend schreiben und Probleme beim Testen von Legacy-Code haben, sowie f√ºr diejenigen, die komplexe Gesch√§ftslogik testen m√∂chten. <br><br>  Wor√ºber werden wir reden?  Zun√§chst werde ich kurz auf unseren Entwicklungsprozess eingehen und wie er sich auf unseren Testbedarf und den Wunsch auswirkt, diese Tests zu schreiben.  Dann werden wir die Pyramide der Testautomatisierung auf und ab gehen, die Arten von Tests diskutieren, die wir verwenden, √ºber die Werkzeuge in jedem von ihnen sprechen und welche Probleme wir mit ihrer Hilfe l√∂sen.  √úberlegen Sie sich am Ende, wie Sie all diese Dinge warten und ausf√ºhren k√∂nnen. <br><a name="habracut"></a><br><h2>  Unser Entwicklungsprozess </h2><br>  Wir haben unseren Entwicklungsprozess veranschaulicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Ein Golfer ist ein Backend-Entwickler.  Irgendwann kommt eine Entwicklungsaufgabe auf ihn zu, normalerweise in Form von zwei Dokumenten: Anforderungen von der Gesch√§ftsseite und ein technisches Dokument, das die √Ñnderungen in unserem Interaktionsprotokoll zwischen dem Backend und den Kunden (mobile Anwendungen und die Site) beschreibt. <br><br>  Der Entwickler schreibt den Code und setzt ihn fr√ºher als alle Clientanwendungen in Betrieb.  Alle Funktionen werden durch einige Funktionsflags oder A / B-Tests gesch√ºtzt. Dies ist in einem technischen Dokument vorgeschrieben.  Danach werden gem√§√ü den aktuellen Priorit√§ten und der Produkt-Roadmap Client-Anwendungen freigegeben.  F√ºr uns Backend-Entwickler ist es v√∂llig unvorhersehbar, wann eine bestimmte Funktion auf Clients implementiert wird.  Der Release-Zyklus f√ºr Client-Anwendungen ist etwas komplizierter und l√§nger als bei uns, sodass unsere Produktmanager buchst√§blich Priorit√§ten setzen. <br><br>  Die vom Unternehmen √ºbernommene Entwicklungskultur ist von gro√üer Bedeutung: Der Backend-Entwickler ist vom Zeitpunkt der Implementierung im Backend bis zur letzten Integration auf der letzten Plattform, auf der das Feature urspr√ºnglich geplant war, f√ºr das Feature verantwortlich. <br><br>  Diese Situation ist durchaus m√∂glich: Vor sechs Monaten haben Sie einige Funktionen eingef√ºhrt, Kundenteams haben sie lange Zeit nicht implementiert, weil sich die Priorit√§ten des Unternehmens ge√§ndert haben, Sie bereits mit anderen Aufgaben besch√§ftigt sind, Sie neue Fristen und Priorit√§ten haben - und hier kommen Ihre Kollegen und Sie sagen: ‚ÄûErinnerst du dich an das Ding, das du vor sechs Monaten heruntergesp√ºlt hast?  Sie arbeitet nicht".  Und anstatt sich neuen Aufgaben zu widmen, l√∂schen Sie die Feuer. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Daher haben unsere Entwickler eine f√ºr PHP-Programmierer ungew√∂hnliche Motivation - sicherzustellen, dass w√§hrend der Integrationsphase so wenig Probleme wie m√∂glich auftreten. <br><br>  Was m√∂chten Sie zuerst tun, um sicherzustellen, dass die Funktion funktioniert? <br><br>  Das erste, was mir in den Sinn kommt, ist nat√ºrlich die Durchf√ºhrung manueller Tests.  Sie holen die Anwendung ab, aber sie wei√ü nicht wie - da die Funktion neu ist, werden sich die Kunden in sechs Monaten darum k√ºmmern.  Nun, manuelle Tests geben keine Garantie daf√ºr, dass f√ºr die Zeit, die von der Ver√∂ffentlichung des Backends bis zum Beginn der Integration vergeht, niemand auf den Clients etwas kaputt macht. <br><br>  Und hier helfen uns automatisierte Tests. <br><br><h2>  Unit-Tests </h2><br>  Die einfachsten Tests, die wir schreiben, sind Unit-Tests.  Wir verwenden PHP als Hauptsprache f√ºr das Backend und PHPUnit als Framework f√ºr Unit-Tests.  Mit Blick auf die Zukunft werde ich sagen, dass alle unsere Backend-Tests auf der Grundlage dieses Frameworks geschrieben wurden. <br><br>  Unit-Tests Wir behandeln meistens einige kleine isolierte Codeteile, √ºberpr√ºfen die Leistung von Methoden oder Funktionen, dh wir sprechen von winzigen Einheiten der Gesch√§ftslogik.  Unsere Unit-Tests sollten mit nichts interagieren, auf Datenbanken oder Dienste zugreifen. <br><br><h3>  Softmocks </h3><br>  Die Hauptschwierigkeit, mit der Entwickler beim Schreiben von Komponententests konfrontiert sind, ist nicht testbarer Code, und dies ist normalerweise Legacy-Code. <br><br>  Ein einfaches Beispiel.  Badoo ist 12 Jahre alt, es war einmal ein sehr kleines Startup, das von mehreren Leuten entwickelt wurde.  Der Start war ohne Tests recht erfolgreich.  Dann wurden wir gro√ü genug und stellten fest, dass man ohne Tests nicht leben kann.  Aber zu diesem Zeitpunkt war viel Code geschrieben worden, der funktionierte.  Schreiben Sie es nicht nur zum Testen um!  Das w√§re aus gesch√§ftlicher Sicht nicht sehr vern√ºnftig. <br><br>  Aus diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grund haben</a> wir eine kleine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open-Source-Bibliothek SoftMocks entwickelt</a> , die das Schreiben von Tests billiger und schneller macht.  Es f√§ngt alle Include / Require-PHP-Dateien ab und ersetzt die Quelldatei im laufenden Betrieb durch ge√§nderten Inhalt, dh umgeschriebenen Code.  Auf diese Weise k√∂nnen wir Stubs f√ºr jeden Code erstellen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es</a> beschreibt, wie die Bibliothek funktioniert. <br><br>  So sieht es f√ºr einen Entwickler aus: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Mit Hilfe solch einfacher Konstruktionen k√∂nnen wir alles, was wir wollen, global neu definieren.  Sie erm√∂glichen es uns insbesondere, die Einschr√§nkungen des Standard-PHPUnit-Herstellers zu umgehen.  Das hei√üt, wir k√∂nnen statische und private Methoden verspotten, Konstanten neu definieren und viel mehr tun, was mit gew√∂hnlicher PHPUnit unm√∂glich ist. <br><br>  Wir sind jedoch auf ein Problem gesto√üen: Entwicklern scheint es bei SoftMocks nicht erforderlich zu sein, den getesteten Code zu schreiben. Sie k√∂nnen den Code jederzeit mit unseren globalen Mocks ‚Äûk√§mmen‚Äú, und alles wird gut funktionieren.  Dieser Ansatz f√ºhrt jedoch zu komplexerem Code und zur Anh√§ufung von "Kr√ºcken".  Aus diesem Grund haben wir verschiedene Regeln verabschiedet, die es uns erm√∂glichen, die Situation unter Kontrolle zu halten: <br><br><ol><li>  Jeder neue Code sollte leicht mit Standard-PHPUnit-Mocks getestet werden k√∂nnen.  Wenn diese Bedingung erf√ºllt ist, ist der Code testbar und Sie k√∂nnen einfach ein kleines St√ºck ausw√§hlen und nur es testen. <br></li><li>  SoftMocks k√∂nnen mit altem Code verwendet werden, der so geschrieben ist, dass er nicht f√ºr Unit-Tests geeignet ist, sowie in F√§llen, in denen es zu teuer / lang / schwierig ist, etwas anderes zu tun (betonen Sie das Notwendige). <br></li></ol><br>  Die Einhaltung dieser Regeln wird in der Phase der Code√ºberpr√ºfung sorgf√§ltig √ºberwacht. <br><br><h3>  Mutationstests </h3><br>  Separat m√∂chte ich auf die Qualit√§t von Unit-Tests eingehen.  Ich denke, viele von Ihnen verwenden Metriken wie die Codeabdeckung.  Leider beantwortet sie keine Frage: "Habe ich einen guten Unit-Test geschrieben?"  Es ist m√∂glich, dass Sie einen solchen Test geschrieben haben, der eigentlich nichts √ºberpr√ºft, keine einzige Zusicherung enth√§lt, aber eine hervorragende Codeabdeckung erzeugt.  Nat√ºrlich ist das Beispiel √ºbertrieben, aber die Situation ist nicht so weit von der Realit√§t entfernt. <br><br>  Vor kurzem haben wir begonnen, Mutationstests einzuf√ºhren.  Dies ist ein ziemlich altes, aber nicht sehr bekanntes Konzept.  Der Algorithmus f√ºr solche Tests ist recht einfach: <br><br><ul><li>  Nehmen Sie den Code und die Codeabdeckung. <br></li><li>  parsim und beginne den Code zu √§ndern: wahr zu falsch,&gt; zu&gt; =, + zu - (im Allgemeinen Schaden in jeder Hinsicht); <br></li><li>  F√ºhren Sie f√ºr jede solche Mutations√§nderung Testsuiten aus, die die ge√§nderte Zeichenfolge abdecken. <br></li><li>  Wenn die Tests fallen, sind sie gut und erlauben uns wirklich nicht, den Code zu brechen. <br></li><li>  Wenn die Tests bestanden wurden, sind sie h√∂chstwahrscheinlich trotz der Abdeckung nicht effektiv genug, und es kann sich lohnen, sie genauer zu betrachten, um eine Aussage zu treffen (oder es gibt einen Bereich, der nicht vom Test abgedeckt wird). <br></li></ul><br>  Es gibt mehrere vorgefertigte Frameworks f√ºr PHP, wie z. B. Humbug und Infection.  Leider passten sie nicht zu uns, da sie mit SoftMocks nicht kompatibel sind.  Aus diesem Grund haben wir unser eigenes kleines Konsolendienstprogramm geschrieben, das dasselbe tut, jedoch unser internes Codeabdeckungsformat verwendet und mit SoftMocks befreundet ist.  Jetzt startet der Entwickler es manuell und analysiert die von ihm geschriebenen Tests, aber wir arbeiten daran, das Tool in unseren Entwicklungsprozess einzuf√ºhren. <br><br><h2>  Integrationstests </h2><br>  Mit Hilfe von Integrationstests √ºberpr√ºfen wir die Interaktion mit verschiedenen Diensten und Datenbanken. <br><br>  Um die Geschichte besser zu verstehen, entwickeln wir eine fiktive Promo und decken sie mit Tests ab.  Stellen Sie sich vor, unsere Produktmanager haben beschlossen, Konferenztickets an unsere engagiertesten Benutzer zu verteilen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  Promo sollte angezeigt werden, wenn: <br><br><ul><li>  Der Benutzer im Feld "Arbeit" gibt "Programmierer" an. <br></li><li>  Der Benutzer nimmt am A / B-Test HL18_promo teil. <br></li><li>  Der Benutzer ist vor mehr als zwei Jahren registriert. <br></li></ul><br>  Durch Klicken auf die Schaltfl√§che "Ticket erhalten" m√ºssen wir die Daten dieses Benutzers in einer Liste speichern, um sie an unsere Manager zu √ºbertragen, die Tickets verteilen. <br><br>  Selbst in diesem recht einfachen Beispiel gibt es eine Sache, die mit Unit-Tests nicht √ºberpr√ºft werden kann - die Interaktion mit der Datenbank.  Dazu m√ºssen wir Integrationstests verwenden. <br><br>  Betrachten Sie die Standardmethode zum Testen der von PHPUnit angebotenen Datenbankinteraktion: <br><br><ol><li>  Erh√∂hen Sie die Testdatenbank. <br></li><li>  Wir bereiten DataTables und DataSets vor. <br></li><li>  F√ºhren Sie den Test aus. <br></li><li>  Wir l√∂schen die Testdatenbank. <br></li></ol><br>  Welche Schwierigkeiten warten bei einem solchen Ansatz auf Sie? <br><br><ul><li>  Sie m√ºssen die Strukturen von DataTables und DataSets unterst√ºtzen.  Wenn wir das Tabellenlayout ge√§ndert haben, m√ºssen diese √Ñnderungen im Test ber√ºcksichtigt werden. Dies ist nicht immer praktisch und erfordert zus√§tzliche Zeit. <br></li><li>  Die Vorbereitung der Datenbank dauert einige Zeit.  Jedes Mal, wenn wir den Test einrichten, m√ºssen wir dort etwas hochladen, einige Tabellen erstellen, und dies ist lang und m√ºhsam, wenn es viele Tests gibt. <br></li><li>  Und der wichtigste Nachteil: Wenn diese Tests parallel ausgef√ºhrt werden, sind sie instabil.  Wir haben Test A gestartet, er hat angefangen, an den Testtisch zu schreiben, den er erstellt hat.  Gleichzeitig haben wir Test B gestartet, der mit derselben Testtabelle arbeiten m√∂chte.  Infolgedessen entstehen gegenseitige Blockaden und andere unvorhergesehene Situationen. <br></li></ul><br>  Um diese Probleme zu vermeiden, haben wir unsere eigene kleine Bibliothek DBMocks entwickelt. <br><br><h3>  DBMocks </h3><br>  Das Funktionsprinzip lautet wie folgt: <br><br><ol><li>  Mit Hilfe von SoftMocks fangen wir alle Wrapper ab, √ºber die wir mit Datenbanken arbeiten. <br></li><li>  Wann <br>  Die Abfrage durchl√§uft einen Mock, analysiert die SQL-Abfrage, zieht DB + TableName daraus und ruft den Host von der Verbindung ab. <br></li><li>  Auf demselben Host in tmpfs erstellen wir eine tempor√§re Tabelle mit derselben Struktur wie die urspr√ºngliche (wir kopieren die Struktur mit SHOW CREATE TABLE). <br></li><li>  Danach leiten wir alle Anfragen, die √ºber diese Tabelle verspottet werden, an eine frisch erstellte tempor√§re Anfrage weiter. <br></li></ol><br>  Was gibt uns das: <br><br><ul><li>  keine Notwendigkeit, sich st√§ndig um die Strukturen zu k√ºmmern; <br></li><li>  Tests k√∂nnen Daten in Quelltabellen nicht mehr besch√§digen, da wir sie im laufenden Betrieb in tempor√§re Tabellen umleiten. <br></li><li>  Wir testen immer noch die Kompatibilit√§t mit der Version von MySQL, mit der wir arbeiten. Wenn die Anforderung pl√∂tzlich nicht mehr mit der neuen Version kompatibel ist, wird unser Test sie sehen und zum Absturz bringen. <br></li><li>  und am wichtigsten ist, dass die Tests jetzt isoliert sind. Selbst wenn Sie sie parallel ausf√ºhren, werden die Threads in verschiedene tempor√§re Tabellen aufgeteilt, da wir jedem Test in den Namen der Testtabellen einen eindeutigen Schl√ºssel hinzuf√ºgen. <br></li></ul><br><h2>  API-Tests </h2><br>  Der Unterschied zwischen Unit- und API-Tests wird durch dieses GIF gut veranschaulicht: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>Das Schloss funktioniert einwandfrei, ist aber an der falschen T√ºr angebracht.</i> <br><br>  Unsere Tests simulieren eine Client-Sitzung, k√∂nnen Anforderungen gem√§√ü unserem Protokoll an das Backend senden und das Backend antwortet darauf als echter Client. <br><br><h3>  Benutzerpool testen </h3><br>  Was brauchen wir, um solche Tests erfolgreich zu schreiben?  Kehren wir zu den Bedingungen der Show unserer Promo zur√ºck: <br><br><ul><li>  Der Benutzer im Feld "Arbeit" gibt "Programmierer" an. <br></li><li>  Der Benutzer nimmt am A / B-Test HL18_promo teil. <br></li><li>  Der Benutzer ist vor mehr als zwei Jahren registriert. <br></li></ul><br>  Anscheinend dreht sich hier alles um den Benutzer.  In der Realit√§t erfordern 99% der API-Tests einen autorisierten registrierten Benutzer, der in allen Diensten und Datenbanken vorhanden ist. <br><br>  Wo kann man es bekommen?  Sie k√∂nnen versuchen, es zum Zeitpunkt des Tests zu registrieren, aber: <br><br><ul><li>  es ist lang und ressourcenintensiv; <br></li><li>  Nach Abschluss des Tests muss dieser Benutzer irgendwie entfernt werden. Dies ist eine nicht triviale Aufgabe, wenn es sich um gro√üe Projekte handelt. <br></li><li>  Schlie√ülich f√ºhren wir, wie in vielen anderen hoch ausgelasteten Projekten, viele Vorg√§nge im Hintergrund aus (Hinzuf√ºgen eines Benutzers zu verschiedenen Diensten, Replikation in andere Rechenzentren usw.).  Tests wissen nichts √ºber solche Prozesse, aber wenn sie implizit auf den Ergebnissen ihrer Ausf√ºhrung beruhen, besteht die Gefahr einer Instabilit√§t. <br></li></ul><br><br>  Wir haben ein Tool namens Test Users Pool entwickelt.  Es basiert auf zwei Ideen: <br><br><ol><li>  Wir registrieren Benutzer nicht jedes Mal, sondern verwenden sie oft. <br></li><li>  Nach dem Test setzen wir die Benutzerdaten auf ihren urspr√ºnglichen Zustand zur√ºck (zum Zeitpunkt der Registrierung).  Andernfalls werden die Tests mit der Zeit instabil, da Benutzer mit Informationen aus anderen Tests ‚Äûverschmutzt‚Äú werden. <br></li></ol><br><br>  Es funktioniert ungef√§hr so: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  Irgendwann wollten wir unsere API-Tests in einer Produktionsumgebung ausf√ºhren.  Warum wollen wir das √ºberhaupt?  Weil die Entwicklungsinfrastruktur nicht mit der Produktion identisch ist. <br><br>  Obwohl wir versuchen, die Produktionsinfrastruktur st√§ndig in reduzierter Gr√∂√üe zu wiederholen, wird die Entwicklung niemals eine vollst√§ndige Kopie davon sein.  Um absolut sicher zu sein, dass der neue Build den Erwartungen entspricht und keine Probleme auftreten, laden wir den neuen Code in den Vorproduktionscluster hoch, der mit Produktionsdaten und -diensten arbeitet, und f√ºhren dort unsere API-Tests aus. <br><br>  In diesem Fall ist es sehr wichtig, dar√ºber nachzudenken, wie Testbenutzer von echten Benutzern isoliert werden k√∂nnen. <br><br><div class="spoiler">  <b class="spoiler_title">Was passiert, wenn Testbenutzer in unserer Anwendung real erscheinen?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  Wie zu isolieren?  Jeder unserer Benutzer hat ein <code>is_test_user</code> Flag.  In der Registrierungsphase wird es <code>yes</code> oder <code>no</code> und √§ndert sich nicht mehr.  Durch dieses Flag isolieren wir Benutzer in allen Diensten.  Es ist auch wichtig, dass wir Testbenutzer von der Gesch√§ftsanalyse und den Ergebnissen von A / B-Tests ausschlie√üen, um Statistiken nicht zu verf√§lschen. <br><br>  Sie k√∂nnen es einfacher machen: Wir haben damit begonnen, dass alle Testbenutzer in die Antarktis ‚Äûumgesiedelt‚Äú wurden.  Wenn Sie einen Geoservice haben, funktioniert dies vollst√§ndig. <br><br><h3>  QA-API </h3><br>  Wir brauchen nicht nur einen Benutzer - wir brauchen ihn mit bestimmten Parametern: um als Programmierer zu arbeiten, an einem bestimmten A / B-Test teilzunehmen und wurde vor mehr als zwei Jahren registriert.  F√ºr Testbenutzer k√∂nnen wir mithilfe unserer Backend-API problemlos einen Beruf zuweisen, aber der Einstieg in A / B-Tests ist wahrscheinlich.  Und die Registrierungsbedingung vor mehr als zwei Jahren ist im Allgemeinen schwer zu erf√ºllen, da wir nicht wissen, wann der Benutzer im Pool erschien. <br><br>  Um diese Probleme zu l√∂sen, haben wir eine QA-API.  Dies ist in der Tat eine Hintert√ºr zum Testen. Hierbei handelt es sich um gut dokumentierte API-Methoden, mit denen Sie Benutzerdaten schnell und einfach verwalten und ihren Status unter Umgehung des Hauptprotokolls unserer Kommunikation mit Kunden √§ndern k√∂nnen.  Die Methoden wurden von Backend-Entwicklern f√ºr QS-Ingenieure und zur Verwendung in UI- und API-Tests geschrieben. <br><br>  Die QA-API kann nur bei Testbenutzern angewendet werden: Wenn kein entsprechendes Flag vorhanden ist, wird der Test sofort gel√∂scht.  Hier ist eine unserer QA-API-Methoden, mit der Sie das Registrierungsdatum des Benutzers in ein beliebiges √§ndern k√∂nnen: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  Es sieht also nach drei Anrufen aus, mit denen Sie die Daten des Testbenutzers schnell √§ndern k√∂nnen, damit diese die Bedingungen f√ºr die Anzeige der Promo erf√ºllen: <br><br><ul><li>  Im Feld "Arbeit" wird der "Programmierer" angezeigt: <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  Der Benutzer nimmt am A / B-Test HL18_promo teil: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Vor mehr als zwei Jahren registriert: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Da dies eine Hintert√ºr ist, ist es wichtig, √ºber Sicherheit nachzudenken.  Wir haben unseren Service auf verschiedene Weise gesch√ºtzt: <br><br><ul><li>  Auf Netzwerkebene isoliert: Auf Dienste kann nur √ºber das B√ºronetzwerk zugegriffen werden. <br></li><li>  Bei jeder Anfrage geben wir ein Geheimnis weiter, ohne das es unm√∂glich ist, auch √ºber das B√ºronetzwerk auf die QA-API zuzugreifen. <br></li><li>  Methoden funktionieren nur mit Testbenutzern. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  Um mit dem Remote-Backend von API-Tests arbeiten zu k√∂nnen, ben√∂tigen wir m√∂glicherweise Mocks.  Wof√ºr?  Wenn der API-Test in der Produktionsumgebung beispielsweise auf die Datenbank zugreift, m√ºssen wir sicherstellen, dass die darin enthaltenen Daten von den Testdaten gel√∂scht werden.  Dar√ºber hinaus tragen Mocks dazu bei, dass die Testantwort besser zum Testen geeignet ist. <br><br>  Wir haben drei Texte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo ist eine mehrsprachige Anwendung. Wir verf√ºgen √ºber eine komplexe Lokalisierungskomponente, mit der Sie schnell √úbersetzungen f√ºr den aktuellen Standort des Benutzers √ºbersetzen und empfangen k√∂nnen.  Unsere Lokalisierer arbeiten st√§ndig daran, die √úbersetzungen zu verbessern, A / B-Tests mit Token durchzuf√ºhren und nach erfolgreicheren Formulierungen zu suchen.  W√§hrend der Durchf√ºhrung des Tests k√∂nnen wir nicht wissen, welcher Text vom Server zur√ºckgegeben wird - er kann sich jederzeit √§ndern.  Mit RemoteMocks k√∂nnen wir jedoch √ºberpr√ºfen, ob auf die Lokalisierungskomponente korrekt zugegriffen wird. <br><br>  Wie funktionieren RemoteMocks?  Der Test fordert das Backend auf, sie f√ºr seine Sitzung zu initialisieren, und nach Eingang aller nachfolgenden Anforderungen pr√ºft das Backend, ob f√ºr die aktuelle Sitzung Mocks vorhanden sind.  Wenn dies der Fall ist, werden sie einfach mit SoftMocks initialisiert. <br><br>  Wenn wir ein Remote-Modell erstellen m√∂chten, geben wir an, welche Klasse oder Methode durch welche ersetzt werden muss.  Alle nachfolgenden Backend-Anforderungen werden unter Ber√ºcksichtigung dieses Modells ausgef√ºhrt: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Nun sammeln wir unseren API-Test: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; ‚Ä¶ //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  Auf so einfache Weise k√∂nnen wir alle Funktionen testen, die im Backend zur Entwicklung kommen und √Ñnderungen im mobilen Protokoll erfordern. <br><br><h3>  API-Testverwendungsregeln </h3><br>  Alles scheint in Ordnung zu sein, aber wir sind erneut auf ein Problem gesto√üen: Die API-Tests erwiesen sich als zu praktisch f√ºr die Entwicklung, und es bestand die Versuchung, sie √ºberall zu verwenden.  Als wir feststellten, dass wir anfingen, Probleme mithilfe von API-Tests zu l√∂sen, f√ºr die sie nicht vorgesehen waren. <br><br>  Warum ist das so schlimm?  Weil API-Tests sehr langsam sind.  Sie gehen in das Netzwerk, wenden sich an das Backend, das die Sitzung aufnimmt, gehen zur Datenbank und zu einer Reihe von Diensten.  Aus diesem Grund haben wir eine Reihe von Regeln f√ºr die Verwendung von API-Tests entwickelt: <br><ul><li>  Der Zweck der API-Tests besteht darin, das Interaktionsprotokoll zwischen dem Client und dem Server sowie die korrekte Integration des neuen Codes zu √ºberpr√ºfen. <br><br></li><li>  es ist zul√§ssig, komplexe Prozesse mit ihnen abzudecken, beispielsweise Handlungsketten; <br></li><li>  Sie k√∂nnen nicht zum Testen der geringen Variabilit√§t der Serverantwort verwendet werden. Dies ist die Aufgabe von Komponententests. <br></li><li>  W√§hrend der Code√ºberpr√ºfung pr√ºfen wir, ob Tests enthalten sind. <br></li></ul><br><h2>  UI-Tests </h2><br>  Da wir √ºber eine Pyramide der Automatisierung nachdenken, werde ich Ihnen ein wenig √ºber UI-Tests erz√§hlen. <br><br>  Backend-Entwickler bei Badoo schreiben keine UI-Tests - daf√ºr haben wir ein engagiertes Team in der QS-Abteilung.  Wir decken das Feature mit UI-Tests ab, wenn es bereits in Erinnerung gerufen und stabilisiert wurde, da wir der Ansicht sind, dass es nicht zumutbar ist, Ressourcen f√ºr eine recht teure Automatisierung des Features aufzuwenden, die m√∂glicherweise nicht √ºber den A / B-Test hinausgeht. <br><br>  Wir verwenden Calabash f√ºr mobile Autotests und Selen f√ºr das Web.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es geht</a> um unsere Plattform f√ºr Automatisierung und Tests. <br><br><h2>  Testlauf </h2><br>  Wir haben jetzt 100.000 Komponententests, 6.000 Integrationstests und 14.000 API-Tests.  Wenn Sie versuchen, sie in einem Thread auszuf√ºhren, dauert selbst auf unserem leistungsst√§rksten Computer eine vollst√§ndige Ausf√ºhrung: modular - 40 Minuten, Integration - 90 Minuten, API-Tests - zehn Stunden.  Es ist zu lang <br><br><h3>  Parallelisierung </h3><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In diesem Artikel haben</a> wir √ºber unsere Erfahrungen mit der Parallelisierung von Komponententests gesprochen.</i> <br><br>  Die erste L√∂sung, die offensichtlich erscheint, besteht darin, Tests in mehreren Threads auszuf√ºhren.  Wir sind jedoch noch weiter gegangen und haben eine Cloud f√ºr den parallelen Start erstellt, um Hardwareressourcen skalieren zu k√∂nnen.  Vereinfacht sieht seine Arbeit so aus: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  Die interessanteste Aufgabe hierbei ist die Verteilung von Tests zwischen Threads, dh deren Aufteilung in Bl√∂cke. <br><br>  Sie k√∂nnen sie gleichm√§√üig aufteilen, aber alle Tests sind unterschiedlich, sodass die Ausf√ºhrungszeit eines Threads m√∂glicherweise stark verzerrt ist: Alle Threads haben bereits erreicht, und einer h√§ngt eine halbe Stunde lang, da er bei sehr langsamen Tests ‚ÄûGl√ºck‚Äú hatte. <br><br>  Sie k√∂nnen mehrere Threads starten und sie nacheinander testen.  In diesem Fall ist der Nachteil weniger offensichtlich: Es fallen Gemeinkosten f√ºr die Initialisierung der Umgebung an, die bei einer gro√üen Anzahl von Tests und diesem Ansatz eine wichtige Rolle zu spielen beginnen. <br><br>  Was haben wir getan  Wir haben angefangen, Statistiken √ºber die Zeit zu sammeln, die f√ºr die Ausf√ºhrung jedes Tests ben√∂tigt wurde, und haben dann begonnen, Bl√∂cke so zusammenzustellen, dass laut Statistik ein Thread nicht l√§nger als 30 Sekunden ausgef√ºhrt wird.  Gleichzeitig packen wir die Tests ziemlich dicht in St√ºcke, um sie kleiner zu machen. <br><br>  Unser Ansatz hat jedoch auch einen Nachteil.  Dies ist mit API-Tests verbunden: Sie sind sehr langsam und verbrauchen viel Ressourcen, sodass keine schnellen Tests ausgef√ºhrt werden k√∂nnen. <br><br>  Aus diesem Grund haben wir die Cloud in zwei Teile unterteilt: Im ersten Teil werden nur schnelle Tests gestartet, und im zweiten Teil k√∂nnen sowohl schnelle als auch langsame Tests gestartet werden.  Mit diesem Ansatz haben wir immer einen Teil der Cloud, der schnelle Tests durchf√ºhren kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  Infolgedessen wurden Unit-Tests in einer Minute ausgef√ºhrt, Integrationstests in f√ºnf Minuten und API-Tests in 15 Minuten.  Das hei√üt, ein vollst√§ndiger Lauf anstelle von 12 Stunden dauert nicht l√§nger als 22 Minuten. <br><br><h3>  Testlauf zur Codeabdeckung </h3><br>  Wir haben einen gro√üen komplexen Monolithen, und auf gute Weise m√ºssen wir st√§ndig alle Tests durchf√ºhren, da eine √Ñnderung an einem Ort etwas an einem anderen zerst√∂ren kann.  Dies ist einer der Hauptnachteile der monolithischen Architektur. <br><br>  Irgendwann kamen wir zu dem Schluss, dass Sie nicht jedes Mal alle Tests ausf√ºhren m√ºssen - Sie k√∂nnen L√§ufe basierend auf der Codeabdeckung durchf√ºhren: <br><br><ol><li>  Nehmen Sie unseren Zweig diff. <br></li><li>  Wir erstellen eine Liste der ge√§nderten Dateien. <br></li><li>  F√ºr jede Datei erhalten wir eine Liste von Tests, <br>  das deckt es ab. <br></li><li>  Aus diesen Tests erstellen wir einen Satz und f√ºhren ihn in einer Testwolke aus. <br></li></ol><br>  Wo bekomme ich Berichterstattung?  Wir sammeln einmal t√§glich Daten, wenn die Infrastruktur der Entwicklungsumgebung inaktiv ist.  Die Anzahl der durchgef√ºhrten Tests hat deutlich abgenommen, die Geschwindigkeit, mit der R√ºckmeldungen von ihnen empfangen werden, hat sich im Gegenteil erheblich erh√∂ht.  Gewinn! <br><br>  Ein zus√§tzlicher Bonus war die M√∂glichkeit, Tests f√ºr Patches durchzuf√ºhren.  Trotz der Tatsache, dass Badoo schon lange kein Startup mehr ist, k√∂nnen wir √Ñnderungen in der Produktion schnell implementieren, Hotfixes schnell einf√ºgen, Funktionen einf√ºhren und die Konfiguration √§ndern.  In der Regel ist uns die Geschwindigkeit der Einf√ºhrung von Patches sehr wichtig.  Der neue Ansatz f√ºhrte zu einer starken Erh√∂hung der R√ºckkopplungsgeschwindigkeit aus den Tests, da wir jetzt nicht mehr lange auf einen vollst√§ndigen Lauf warten m√ºssen. <br><br>    .       ,       ,   ,       .        .     ,  code coverage        . ,   , ‚Äî  ,  -        ,     .     . <br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Fazit </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ‚â† .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  12:00,  ‚Äî   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443768/">https://habr.com/ru/post/de443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443754/index.html">Informationen zur Angemessenheit von Selenium WebDriverWait</a></li>
<li><a href="../de443756/index.html">Klassendesign: Was ist gut?</a></li>
<li><a href="../de443758/index.html">Quick Draw Doodle Recognition: So machen Sie Freunde R, C ++ und Neuronale Gitter</a></li>
<li><a href="../de443764/index.html">Was der Designer geraucht hat: eine ungew√∂hnliche Waffe</a></li>
<li><a href="../de443766/index.html">Probieren Sie jetzt C ++ 20 Contract Programming aus</a></li>
<li><a href="../de443772/index.html">Antiquit√§ten: IBM ThinkPad T40, das erste drahtlose Ger√§t</a></li>
<li><a href="../de443774/index.html">Wie sich die Neurobiologie in US-Pr√§sidentschaftswahlen einmischt</a></li>
<li><a href="../de443776/index.html">China f√ºhrt ein experimentelles Gesichtserkennungssystem ein, wenn es f√ºr die U-Bahn bezahlt</a></li>
<li><a href="../de443780/index.html">MCDM-Projekt. Teil 1. Konzept</a></li>
<li><a href="../de443782/index.html">Entwickler k√∂nnen jetzt die Netzwerk-API von Valve f√ºr ihre Steam-Spiele verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>