<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∑ üëáüèº üëÜüèø .NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 1 üèóÔ∏è üö® ‚è≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe diesen Artikel urspr√ºnglich im CodingSight- Blog ver√∂ffentlicht 
 Der zweite Teil des Artikels ist hier verf√ºgbar 

 Die Notwendigkeit, Dinge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455252/">  <i>Ich habe diesen Artikel urspr√ºnglich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodingSight-</a> Blog ver√∂ffentlicht</i> <br>  <i>Der zweite Teil des Artikels ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar</i> <br><br>  Die Notwendigkeit, Dinge asynchron zu erledigen, dh gro√üe Aufgaben auf mehrere Arbeitseinheiten aufzuteilen, bestand lange vor dem Erscheinen von Computern.  Als sie jedoch auftauchten, wurde dieses Bed√ºrfnis noch offensichtlicher.  Es ist jetzt 2019, und ich schreibe diesen Artikel auf einem Laptop, der mit einer 8-Kern-Intel-Core-CPU betrieben wird, die zus√§tzlich an Hunderten von Prozessen arbeitet, wobei die Anzahl der Threads noch gr√∂√üer ist.  Neben mir liegt ein etwas veraltetes Smartphone, das ich vor ein paar Jahren gekauft habe - und in dem sich auch ein 8-Kern-Prozessor befindet.  Spezialisierte Webressourcen enthalten eine Vielzahl von Artikeln, in denen die diesj√§hrigen Flaggschiff-Smartphones mit 16-Kern-CPUs gelobt werden.  F√ºr weniger als 20 US-Dollar pro Stunde k√∂nnen Sie mit MS Azure auf eine virtuelle 128-Core-Maschine mit 2 TB RAM zugreifen.  Leider k√∂nnen Sie diese Leistung nur dann optimal nutzen, wenn Sie wissen, wie Sie die Interaktion zwischen Threads steuern. <br><a name="habracut"></a><br><h4>  Inhalt </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminologie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Metapher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Tools</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einen Thread starten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzeigen und Debuggen von Threads</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Task parallele Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√§den stoppen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwandeln einer Legacy-API mithilfe von FromAsync in eine aufgabenbasierte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwandeln einer Legacy-API mithilfe von TaskCompletionSource in eine aufgabenbasierte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps und Tricks zu TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ValueTask: Warum und wie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TaskScheduler: Steuern von Aufgabenausf√ºhrungsstrategien</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PLinq und die Parallelklasse</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li></ul><br><a name="Terminology"></a><br><h3>  Terminologie </h3><br>  <b>Prozess</b> - Ein Betriebssystemobjekt, das einen isolierten Adressraum darstellt, der Threads enth√§lt. <br><br>  <b>Thread</b> - Ein Betriebssystemobjekt, das die kleinste Ausf√ºhrungseinheit darstellt.  Threads sind Bestandteile von Prozessen, sie teilen Speicher und andere Ressourcen im Rahmen eines Prozesses untereinander auf. <br><br>  <b>Multitasking</b> - eine Betriebssystemfunktion, die die F√§higkeit darstellt, mehrere Prozesse gleichzeitig auszuf√ºhren. <br><br>  <b>Multi-Core</b> - eine CPU-Funktion, die die M√∂glichkeit darstellt, mehrere Kerne f√ºr die Datenverarbeitung zu verwenden <br><br>  <b>Multiprocessing</b> - die Funktion eines Computers, die die F√§higkeit darstellt, physisch mit mehreren CPUs zu arbeiten. <br><br>  <b>Multithreading</b> - das Merkmal eines Prozesses, das die F√§higkeit darstellt, die Datenverarbeitung auf mehrere Threads aufzuteilen und zu verteilen. <br><br>  <b>Parallelit√§t</b> - gleichzeitige physische Ausf√ºhrung mehrerer Aktionen in einer Zeiteinheit <br><br>  <b>Asynchronit√§t</b> - Ausf√ºhren einer Operation, ohne darauf zu warten, dass sie vollst√§ndig verarbeitet wird, sodass die Berechnung des Ergebnisses f√ºr eine sp√§tere Zeit verbleibt. <br><br><a name="Metaphor"></a><br><h3>  Eine Metapher </h3><br>  Nicht alle Definitionen sind wirksam und einige m√ºssen ausgearbeitet werden. Lassen Sie mich daher eine Kochmetapher f√ºr die soeben eingef√ºhrte Terminologie bereitstellen. <br><br>  Das Fr√ºhst√ºck zuzubereiten ist ein <b>Prozess</b> in dieser Metapher. <br><br>  Wenn ich morgens fr√ºhst√ºcke, gehe ich ( <b>CPU</b> ) in die K√ºche ( <b>Computer</b> ).  Ich habe zwei H√§nde ( <b>Kerne</b> ).  In der K√ºche gibt es eine Auswahl an Ger√§ten ( <b>IO</b> ): Herd, Wasserkocher, Toaster, K√ºhlschrank.  Ich schalte den Herd ein, stelle eine Pfanne darauf und gie√üe etwas Pflanzen√∂l hinein.  Ohne darauf zu warten, dass sich das √ñl erw√§rmt ( <b>asynchron, Non-Blocking-IO-Wait</b> ), hole ich einige Eier aus dem K√ºhlschrank, knacke sie √ºber eine Sch√ºssel und peitsche sie dann mit einer Hand ( <b>Faden Nr. 1</b> ).  W√§hrenddessen h√§lt der Sekundenzeiger (Faden Nr. 2) die Sch√ºssel an Ort und Stelle ( <b>Shared Resource</b> ).  Ich m√∂chte den Wasserkocher einschalten, habe aber momentan nicht gen√ºgend freie H√§nde ( <b>Thread Starvation</b> ).  W√§hrend ich die Eier peitschte, wurde die Pfanne hei√ü genug (Ergebnisverarbeitung), also gie√üe ich die geschlagenen Eier hinein.  Ich greife zum Wasserkocher, schalte ihn ein und schaue auf das gekochte Wasser ( <b>Blocking-IO-Wait</b> ) - aber ich h√§tte diese Zeit nutzen k√∂nnen, um die Sch√ºssel zu waschen. <br><br>  Ich habe nur 2 H√§nde benutzt, um das Omelett zuzubereiten (weil ich nicht mehr habe), aber es wurden 3 Operationen gleichzeitig ausgef√ºhrt: die Eier schlagen, die Sch√ºssel halten, die Pfanne erhitzen.  Die CPU ist der schnellste Teil des Computers, und E / A ist der Teil, der am h√§ufigsten gewartet werden muss. Daher ist es sehr effektiv, die CPU mit etwas Arbeit zu laden, w√§hrend sie auf die Daten von E / A wartet. <br><br>  So erweitern Sie die Metapher: <br><br><ul><li>  Wenn ich auch versucht h√§tte, mich beim Fr√ºhst√ºck umzuziehen, h√§tte ich <b>Multitasking betrieben</b> .  Computer k√∂nnen das viel besser als Menschen. </li><li>  Eine K√ºche mit mehreren K√∂chen - zum Beispiel in einem Restaurant - ist ein <b>Multi-Core-</b> Computer. </li><li>  Ein Einkaufszentrum Food Court mit vielen Restaurants w√ºrde ein <b>Rechenzentrum darstellen</b> . </li></ul><br><br><a name="NetTools"></a><br><h3>  .NET Tools </h3><br>  .NET ist wirklich gut, wenn es um die Arbeit mit Threads geht - und bei vielen anderen Dingen.  Mit jeder neuen Version bietet es mehr Tools f√ºr die Arbeit mit Threads und neuen OS-Thread-Abstraktionsschichten.  Bei der Arbeit mit Abstraktionen verwenden die Entwickler, die mit dem Framework arbeiten, einen Ansatz, der es ihnen erm√∂glicht, eine oder mehrere Ebenen nach unten zu verschieben, w√§hrend sie Abstraktionen auf hoher Ebene verwenden.  In den meisten F√§llen besteht keine wirkliche Notwendigkeit, dies zu tun (und dies kann die M√∂glichkeit mit sich bringen, sich in den Fu√ü zu schie√üen), aber manchmal ist dies m√∂glicherweise die einzige M√∂glichkeit, ein Problem zu l√∂sen, das auf der aktuellen Abstraktionsebene nicht gel√∂st werden kann. <br><br>  Als ich zuvor Tools erw√§hnte, meinte ich sowohl Programmschnittstellen (API), die vom Framework oder von Paketen von Drittanbietern bereitgestellt werden, als auch vollwertige Softwarel√∂sungen, die die Suche nach Problemen im Zusammenhang mit Multithread-Code vereinfachen. <br><br><a name="StartingAThread"></a><br><h4>  Einen Thread starten </h4><br>  Die Thread-Klasse ist die grundlegendste .NET-Klasse f√ºr die Arbeit mit Threads.  Sein Konstruktor akzeptiert einen dieser beiden Delegierten: <br><br><ul><li>  ThreadStart - keine Parameter </li><li>  ParametrizedThreadStart - Ein Parameter vom Typ Objekt. </li></ul><br><br>  Der Delegat wird nach dem Aufrufen der Start-Methode in einem neu erstellten Thread ausgef√ºhrt.  Wenn der ParametrizedThreadStart-Delegat an den Konstruktor √ºbergeben wurde, sollte ein Objekt an die Start-Methode √ºbergeben werden.  Dieser Prozess ist erforderlich, um lokale Informationen an den Thread zu √ºbergeben.  Ich sollte darauf hinweisen, dass das Erstellen eines Threads viele Ressourcen erfordert und der Thread selbst ein schweres Objekt ist - zumindest, weil er eine Interaktion mit der Betriebssystem-API erfordert und dem Stapel 1 MB Speicher zugewiesen ist. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  Die ThreadPool-Klasse repr√§sentiert das Konzept eines Pools.  In .NET ist der Thread-Pool ein Kunstwerk, und die Microsoft-Entwickler haben gro√üe Anstrengungen unternommen, damit er in allen m√∂glichen Szenarien optimal funktioniert. <br><br>  <b>Das allgemeine Konzept:</b> <br>  <i>Beim Start erstellt die App einige Threads im Hintergrund, sodass Sie bei Bedarf darauf zugreifen k√∂nnen.</i>  <i>Wenn Threads h√§ufig und in gro√üer Anzahl verwendet werden, wird der Pool erweitert, um die Anforderungen des aufrufenden Codes zu erf√ºllen.</i>  <i>Wenn der Pool zum richtigen Zeitpunkt nicht gen√ºgend freie Threads hat, wartet er entweder darauf, dass einer der aktiven Threads nicht mehr belegt ist, oder erstellt einen neuen.</i>  <i>Darauf basierend folgt, dass der Thread-Pool perfekt f√ºr kurze Aktionen ist und nicht so gut f√ºr Prozesse funktioniert, die w√§hrend der gesamten Dauer des Anwendungsbetriebs als Services fungieren.</i> <br><br>  Mit der QueueUserWorkItem-Methode k√∂nnen Threads aus dem Pool verwendet werden.  Diese Methode verwendet den <i>Delegaten vom</i> Typ <i>WaitCallback</i> .  Die Signatur stimmt mit der Signatur von ParametrizedThreadStart √ºberein, und der an sie √ºbergebene Parameter hat dieselbe Rolle. <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  Die weniger bekannte RegisterWaitForSingleObject-Threadpoolmethode wird zum Organisieren nicht blockierender E / A-Vorg√§nge verwendet.  Der Delegat, der an diese Methode √ºbergeben wird, wird aufgerufen, wenn das WaitHandle freigegeben wird, nachdem es an die Methode √ºbergeben wurde. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br><br>  In .NET gibt es einen Thread-Timer, der sich von den WinForms / WPF-Timern dadurch unterscheidet, dass sein Handler in dem aus dem Pool entnommenen Thread aufgerufen wird. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br><br>  Es gibt auch eine eher ungew√∂hnliche M√∂glichkeit, den Delegaten an einen Thread aus dem Pool zu senden - die BeginInvoke-Methode. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br><br>  Ich m√∂chte auch einen Blick auf die Funktion werfen, auf die sich viele der zuvor erw√§hnten Methoden beziehen - CreateThread aus der Kernel32.dll Win32-API.  Es gibt eine M√∂glichkeit, diese Funktion mithilfe des externen Mechanismus der Methoden aufzurufen.  Ich habe nur einmal gesehen, dass dies in einem besonders schlimmen Fall von Legacy-Code verwendet wurde - und ich verstehe immer noch nicht, was die Gr√ºnde des Autors waren. <br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><br><a name="ViewingAndDebuggingThreads"></a><br><h4>  Anzeigen und Debuggen von Threads </h4><br>  Alle Threads - ob von Ihnen, Komponenten von Drittanbietern oder dem .NET-Pool erstellt - k√∂nnen im <b>Threads-</b> Fenster von Visual Studio angezeigt werden.  In diesem Fenster werden nur die Informationen zu Threads angezeigt, wenn die Anwendung im Unterbrechungsmodus debuggt wird.  Hier k√∂nnen Sie die Namen und Priorit√§ten jedes Threads anzeigen und den Debug-Modus auf bestimmte Threads konzentrieren.  Mit der Priority-Eigenschaft der Thread-Klasse k√∂nnen Sie die Priorit√§t des Threads festlegen.  Diese Priorit√§t wird dann ber√ºcksichtigt, wenn das Betriebssystem und die CLR die Prozessorzeit zwischen den Threads aufteilen. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><a name="TaskParallelLibrary"></a><br><h4>  Task parallele Bibliothek </h4><br>  Die Task Parallel Library (TPL) wurde erstmals in .NET 4.0 angezeigt.  Derzeit ist es das Hauptwerkzeug f√ºr die Arbeit mit Asynchronit√§t.  Jeder Code, der √§ltere Ans√§tze verwendet, wird als Legacy-Code betrachtet.  Die Haupteinheit von TPL ist die <b>Task-</b> Klasse aus dem Namespace System.Threading.Tasks.  Aufgaben repr√§sentieren die Thread-Abstraktion.  Mit der neuesten Version von C # haben wir eine neue elegante Art der Arbeit mit Aufgaben erworben - die asynchronen / wartenden Operatoren.  Diese erm√∂glichen es, asynchronen Code so zu schreiben, als ob er einfach und synchron w√§re, sodass diejenigen, die sich mit der Theorie der Threads nicht auskennen, jetzt Apps schreiben k√∂nnen, die nicht mit langen Vorg√§ngen zu k√§mpfen haben.  Die Verwendung von async / await ist wirklich ein Thema f√ºr einen separaten Artikel (oder sogar einige Artikel), aber ich werde versuchen, die Grundlagen in ein paar S√§tzen zu skizzieren: <br><br><ul><li>  async ist ein Modifikator einer Methode, die eine Task oder void zur√ºckgibt </li><li>  await ist ein Operator einer nicht blockierenden Warteaufgabe. </li></ul><br><br>  Noch einmal: Der Operator "Warten" l√§sst normalerweise (es gibt Ausnahmen) den aktuellen Thread los und wenn die Aufgabe ausgef√ºhrt wird und der Thread (eigentlich der Kontext, aber wir werden sp√§ter darauf zur√ºckkommen) als frei ist Infolgedessen wird die Methode weiterhin ausgef√ºhrt.  In .NET wird dieser Mechanismus auf die gleiche Weise wie die Ertragsr√ºckgabe implementiert. Eine Methode wird in eine endliche Zustandsmaschinenklasse umgewandelt, die je nach Status in separaten Teilen ausgef√ºhrt werden kann.  Wenn dies interessant klingt, w√ºrde ich empfehlen, einen einfachen Code basierend auf async / await zu schreiben, ihn zu kompilieren und seine Kompilierung mit Hilfe von JetBrains dotPeek mit aktiviertem Compiler Generated Code zu betrachten. <br><br>  Schauen wir uns die Optionen an, die wir zum Starten und Verwenden einer Aufgabe haben.  Im folgenden Beispiel erstellen wir eine neue Aufgabe, die eigentlich nichts Produktives bewirkt (Thread.Sleep (10000)).  In realen F√§llen sollten wir es jedoch durch eine komplexe Arbeit ersetzen, die CPU-Ressourcen nutzt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br><br>  Eine Aufgabe wird mit folgenden Optionen erstellt: <br><br><ul><li>  LongRunning - Diese Option weist darauf hin, dass die Aufgabe nicht schnell ausgef√ºhrt werden kann.  Daher ist es m√∂glicherweise besser, einen separaten Thread f√ºr diese Aufgabe zu erstellen, als einen vorhandenen aus dem Pool zu nehmen, um den Schaden f√ºr andere Aufgaben zu minimieren. </li><li>  AttachedToParent - Aufgaben k√∂nnen hierarchisch angeordnet werden.  Wenn diese Option verwendet wird, wartet die Aufgabe darauf, dass ihre untergeordneten Aufgaben ausgef√ºhrt werden, nachdem sie selbst ausgef√ºhrt wurden. </li><li>  PreferFairness - Diese Option gibt an, dass die Aufgabe besser vor den sp√§ter erstellten Aufgaben ausgef√ºhrt werden soll.  Es ist jedoch eher ein Vorschlag, sodass das Ergebnis nicht immer garantiert ist. </li></ul><br><br>  Der zweite Parameter, der an die Methode √ºbergeben wurde, ist CancellationToken.  Damit der Vorgang ordnungsgem√§√ü abgebrochen werden kann, nachdem er bereits gestartet wurde, sollte der ausf√ºhrbare Code CancellationToken-Statuspr√ºfungen enthalten.  Wenn solche √úberpr√ºfungen nicht vorhanden sind, kann die f√ºr das CancellationTokenSource-Objekt aufgerufene Cancel-Methode die Taskausf√ºhrung nur stoppen, bevor die Task tats√§chlich gestartet wird. <br><br>  F√ºr den letzten Parameter haben wir ein Objekt vom Typ TaskScheduler namens Scheduler gesendet.  Diese Klasse wird zusammen mit ihren untergeordneten Klassen verwendet, um zu steuern, wie Aufgaben zwischen Threads verteilt werden.  Standardm√§√üig wird eine Aufgabe f√ºr einen zuf√§llig ausgew√§hlten Thread aus dem Pool ausgef√ºhrt <br><br>  Der Operator "Warten" wird auf die erstellte Aufgabe angewendet.  Dies bedeutet, dass der danach geschriebene Code (wenn es einen solchen Code gibt) im selben Kontext ausgef√ºhrt wird (h√§ufig bedeutet dies "im selben Thread") wie der zuvor geschriebene Code. <br><br>  Diese Methode wird als async void bezeichnet. Dies bedeutet, dass der Operator await darin verwendet werden kann, der aufrufende Code jedoch nicht auf die Ausf√ºhrung warten kann.  Wenn eine solche M√∂glichkeit ben√∂tigt wird, sollte die Methode eine Aufgabe zur√ºckgeben.  Als asynchrone Leere gekennzeichnete Methoden sind h√§ufig zu sehen: In der Regel handelt es sich um Ereignishandler oder andere Methoden, die unter dem Prinzip des Feuers und Vergessens arbeiten.  Wenn Sie warten m√ºssen, bis die Ausf√ºhrung abgeschlossen ist, und das Ergebnis zur√ºckgeben, sollten Sie Task verwenden. <br><br>  F√ºr Aufgaben, die die StartNew-Methode zur√ºckgeben, k√∂nnen wir ConfigureAwait mit dem Parameter false aufrufen. Anschlie√üend wird die Ausf√ºhrung nach dem Warten in einem zuf√§lligen Kontext anstelle eines erfassten Kontexts fortgesetzt.  Dies sollte immer dann erfolgen, wenn der nach dem Warten geschriebene Code keinen bestimmten Ausf√ºhrungskontext erfordert.  Dies ist auch eine Empfehlung von MS, wenn es darum geht, Code zu schreiben, der als Bibliothek bereitgestellt wird. <br><br>  Schauen wir uns an, wie wir warten k√∂nnen, bis eine Aufgabe erledigt ist.  Unten sehen Sie ein Beispiel f√ºr einen Code mit Kommentaren, die angeben, wann das Warten relativ gut oder schlecht implementiert ist. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  Im ersten Beispiel warten wir darauf, dass die Aufgabe ausgef√ºhrt wird, ohne den aufrufenden Thread zu blockieren. Daher werden wir das Ergebnis wieder verarbeiten, wenn es fertig ist.  Bevor dies geschieht, bleibt der aufrufende Thread f√ºr sich allein. <br><br>  Im zweiten Versuch blockieren wir den aufrufenden Thread, bis das Ergebnis der Methode berechnet ist.  Dies ist aus zwei Gr√ºnden ein schlechter Ansatz.  Zun√§chst verschwenden wir einen Thread - eine sehr wertvolle Ressource - f√ºr einfaches Warten.  Wenn die von uns aufgerufene Methode ein Warten enth√§lt, w√§hrend der Synchronisierungskontext eine R√ºckkehr zum aufrufenden Thread nach dem Warten beabsichtigt, wird ein Deadlock angezeigt.  Dies geschieht, weil der aufrufende Thread auf das Ergebnis einer asynchronen Methode wartet und die asynchrone Methode selbst erfolglos versucht, ihre Ausf√ºhrung im aufrufenden Thread fortzusetzen. <br><br>  Ein weiterer Nachteil dieses Ansatzes ist die erh√∂hte Komplexit√§t der Fehlerbehandlung.  Die Fehler k√∂nnen im asynchronen Code relativ einfach behandelt werden, wenn async / await verwendet wird - der Prozess ist in diesem Fall identisch mit dem im synchronen Code.  Wenn jedoch eine Aufgabe synchron synchronisiert wird, wird die anf√§ngliche Ausnahme in AggregateException eingeschlossen.  Mit anderen Worten, um die Ausnahme zu behandeln, m√ºssten wir den InnerException-Typ untersuchen und manuell eine if-Kette in einen catch-Block schreiben oder alternativ die catch when-Struktur anstelle der √ºblicheren Kette von catch-Bl√∂cken verwenden. <br><br>  Die beiden letzten Beispiele werden aus den gleichen Gr√ºnden als relativ schlecht bezeichnet und enthalten beide die gleichen Probleme. <br><br>  Die WhenAny- und WhenAll-Methoden sind sehr n√ºtzlich, wenn Sie auf eine Gruppe von Aufgaben warten m√∂chten. Sie wickeln diese Aufgaben in eine ein und werden entweder ausgef√ºhrt, wenn eine Aufgabe aus der Gruppe gestartet wird oder wenn alle diese Aufgaben erfolgreich ausgef√ºhrt werden. <br><br><a name="StoppingThreads"></a><br><h4>  F√§den stoppen </h4><br>  Aus verschiedenen Gr√ºnden kann es erforderlich sein, einen Thread nach dem Start anzuhalten.  Es gibt einige M√∂glichkeiten, dies zu tun.  Die Thread-Klasse verf√ºgt √ºber zwei Methoden mit entsprechenden Namen - <b>Abort</b> und <b>Interrupt</b> .  Ich w√ºrde dringend davon <b>abraten</b> , die erste zu verwenden, da nach dem <b>Aufruf</b> zu jedem beliebigen Zeitpunkt eine <b>ThreadAbortedException</b> ausgel√∂st wird, w√§hrend eine beliebig ausgew√§hlte Anweisung verarbeitet wird.  Sie erwarten nicht, dass eine solche Ausnahme auftritt, wenn eine Ganzzahlvariable inkrementiert wird, oder?  Nun, wenn Sie die Abort-Methode verwenden, wird dies eine echte M√∂glichkeit.  Falls Sie die F√§higkeit der CLR verweigern m√ºssen, solche Ausnahmen in einem bestimmten Teil des Codes zu erstellen, k√∂nnen Sie sie in die Aufrufe <b>Thread. BeginCriticalRegion</b> und <b>Thread.EndCriticalRegion einschlie√üen</b> .  Jeder im finally-Block geschriebene Code wird in diese Aufrufe eingeschlossen.  Aus diesem Grund finden Sie Bl√∂cke mit einem leeren Versuch und einem nicht leeren schlie√ülich in den Tiefen des Framework-Codes.  Microsoft mag diese Methode nicht, da sie nicht im .NET-Kern enthalten ist. <br><br>  Die <b>Interrrupt-</b> Methode funktioniert viel vorhersehbarer.  Es kann einen Thread mit einer <b>ThreadInterruptedException</b> nur <b>unterbrechen</b> , wenn sich der Thread im <b>Wartemodus</b> befindet.  Es wird in diesen Zustand versetzt, wenn es angehalten wird, w√§hrend auf WaitHandle, eine Sperre oder nach Thread.Sleep gewartet wird. <br><br>  Beide Wege haben den Nachteil der Unvorhersehbarkeit.  Um diesem Problem zu entgehen, sollten wir die <b>CancellationToken-</b> Struktur und die <b>CancellationTokenSource-</b> Klasse verwenden.  Die allgemeine Idee lautet: Eine Instanz der CancellationTokenSource-Klasse wird erstellt, und nur diejenigen, die sie besitzen, k√∂nnen den Vorgang durch Aufrufen der <b>Cancel-</b> Methode stoppen.  Nur CancellationToken wird an die Operation √ºbergeben.  Die Eigent√ºmer von CancellationToken k√∂nnen den Vorgang nicht selbst abbrechen. Sie k√∂nnen nur √ºberpr√ºfen, ob der Vorgang abgebrochen wurde.  Dies kann mithilfe der Booleschen Eigenschaft <b>IsCancellationRequested</b> und der <b>ThrowIfCancelRequested-</b> Methode erreicht werden.  Die letzte generiert eine <b>TaskCancelledException,</b> wenn die Cancel-Methode f√ºr die CancellationTokenSource-Instanz aufgerufen wurde, die das CancellationToken erstellt hat.  Dies ist die Methode, die ich empfehle.  Der Vorteil gegen√ºber den zuvor beschriebenen Methoden liegt in der Tatsache, dass sie die vollst√§ndige Kontrolle √ºber die genauen Ausnahmef√§lle bieten, in denen eine Operation abgebrochen werden kann. <br><br>  Der brutalste Weg, einen Thread zu stoppen, besteht darin, eine Win32-API-Funktion namens TerminateThread aufzurufen.  Nachdem diese Funktion aufgerufen wurde, kann das Verhalten der CLR ziemlich unvorhersehbar sein.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> wird √ºber diese Funktion Folgendes geschrieben: <i>‚ÄûTerminateThread ist eine gef√§hrliche Funktion, die nur in den extremsten F√§llen verwendet werden sollte.</i>  <i>‚Äû</i> <br><br><a name="FromAsync"></a><br><h4>  Verwandeln einer Legacy-API mithilfe von FromAsync in eine aufgabenbasierte </h4><br>  Wenn Sie das Gl√ºck hatten, an einem Projekt zu arbeiten, das nach Einf√ºhrung der Aufgaben gestartet wurde (und bei den meisten Entwicklern keinen existenziellen Horror mehr ausl√∂st), m√ºssen Sie sich nicht mit alten APIs befassen - sowohl mit Drittanbietern diejenigen und diejenigen, an denen Ihr Team in der Vergangenheit gearbeitet hat.  Gl√ºcklicherweise hat es uns das .NET Framework-Entwicklungsteam leichter gemacht - aber nach allem, was wir wissen, h√§tte dies eine Selbstversorgung sein k√∂nnen.  In jedem Fall verf√ºgt .NET √ºber einige Tools, mit denen der mit alten Ans√§tzen geschriebene Code nahtlos in die Asynchronit√§t gebracht und auf ein aktuelles Formular gebracht werden kann.  Eine davon ist die TaskFactory-Methode FromAsync.  Im folgenden Beispiel verpacke ich die alten asynchronen Methoden der WebRequest-Klasse mithilfe von FromAsync in eine Task. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Es ist nur ein Beispiel, und Sie werden wahrscheinlich nichts dergleichen mit eingebauten Typen tun.</i>  <i>In alten Projekten gibt es jedoch viele BeginDoSomething-Methoden, die IAsyncResult- und EndDoSomething-Methoden zur√ºckgeben, die sie empfangen.</i> <br><br><a name="TaskCompletionSource"></a><br><h4>  Verwandeln einer Legacy-API mithilfe von TaskCompletionSource in eine aufgabenbasierte </h4><br>  Ein weiteres Werkzeug, das es wert ist, erkundet zu werden, ist die <b>TaskCompletionSource-</b> Klasse.  In seiner Funktionalit√§t, seinem Zweck und seinem Funktionsprinzip √§hnelt es der RegisterWaitForSingleObject-Methode aus der zuvor erw√§hnten ThreadPool-Klasse.  Mit dieser Klasse k√∂nnen wir alte asynchrone APIs einfach in Aufgaben einbinden. <br><br>  <i>Vielleicht m√∂chten Sie sagen, dass ich bereits von der TaskFactory-Klasse, die diesen Zwecken diente, √ºber die FromAsync-Methode berichtet habe.</i>  <i>Hier m√ºssen wir uns an die vollst√§ndige Historie der von Microsoft in den letzten 15 Jahren bereitgestellten asynchronen Modelle erinnern: Vor TAP (Task-Based Asynchronous Patterns) gab es Asynchronous Programming Patterns (APP).</i>  <i>Bei APPs ging es ausschlie√ülich um <b>Begin</b> DoSomething, das IAsyncResult zur√ºckgibt, und um die <b>End</b> DoSomething-Methode, die dies akzeptiert - und die FromAsync-Methode ist perfekt f√ºr das diesj√§hrige Erbe.</i>  <i>Im Laufe der Zeit wurde dies jedoch durch ereignisbasierte asynchrone Muster (EAP) ersetzt, die angaben, dass ein Ereignis aufgerufen wird, wenn eine asynchrone Operation erfolgreich ausgef√ºhrt wird.</i> <br><br>  TaskCompletionSource eignet sich perfekt zum Umschlie√üen √§lterer APIs, die um das Ereignismodell herum erstellt wurden, in Aufgaben.  So funktioniert es: Objekte dieser Klasse haben eine √∂ffentliche Eigenschaft namens Task, deren Status durch verschiedene Methoden der TaskCompletionSource-Klasse (SetResult, SetException usw.) gesteuert werden kann.  An Stellen, an denen der Operator "Warten" auf diese Aufgabe angewendet wurde, wird er mit einer Ausnahme ausgef√ºhrt oder st√ºrzt ab, abh√§ngig von der auf TaskCompletionSource angewendeten Methode.  Um es besser zu verstehen, schauen wir uns diesen Beispielcode an.  Hier wird eine alte API aus der EAP-√Ñra mithilfe von TaskCompletionSource in eine Task eingeschlossen: Wenn ein Ereignis ausgel√∂st wird, wird die Task in den Status "Abgeschlossen" versetzt, w√§hrend die Methode, mit der der Operator "Warten" auf diese Task angewendet wurde, ihre Ausf√ºhrung fortsetzt nach dem Empfang eines <b>Ergebnisobjekts</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><a name="TaskCompletionSourceTips"></a><br><h4>  Tipps und Tricks zu TaskCompletionSource </h4><br>  TaskCompletionSource kann mehr als nur veraltete APIs verpacken.  Diese Klasse er√∂ffnet eine interessante M√∂glichkeit, verschiedene APIs basierend auf Aufgaben zu entwerfen, die keine Threads belegen.  Wie wir uns erinnern, ist ein Thread eine teure Ressource, die haupts√§chlich durch RAM begrenzt ist.  Wir k√∂nnen diese Grenze leicht erreichen, wenn wir eine robuste Webanwendung mit komplexer Gesch√§ftslogik entwickeln.  Schauen wir uns die Funktionen an, die ich in Aktion erw√§hnt habe, indem wir einen netten Trick implementieren, der als Long Polling bekannt ist. <br><br>  <b>Kurz gesagt, so funktioniert Long Polling:</b> <br>  <i>Sie m√ºssen von einer API einige Informationen zu Ereignissen abrufen, die auf ihrer Seite auftreten. Die API kann jedoch aus irgendeinem Grund nur einen Status zur√ºckgeben, anstatt Sie √ºber das Ereignis zu informieren.</i>  <i>Ein Beispiel hierf√ºr w√§re eine API, die √ºber HTTP erstellt wurde, bevor WebSocket angezeigt wurde, oder unter Umst√§nden, unter denen diese Technologie nicht verwendet werden kann.</i>  <i>Der Client kann den HTTP-Server fragen.</i>  <i>Der HTTP-Server kann dagegen nicht selbst Kontakt mit dem Client aufnehmen.</i>  <i>Die einfachste L√∂sung w√§re, den Server regelm√§√üig mit einem Timer zu fragen. Dies w√ºrde jedoch eine zus√§tzliche Belastung f√ºr den Server und eine allgemeine Verz√∂gerung verursachen, die ungef√§hr TimerInterval / 2 entspricht. Um dies zu umgehen, wurde Long Polling erfunden.</i>  <i>Dies f√ºhrt dazu, dass die Serverantwort verz√∂gert wird, bis das Timeout abl√§uft oder ein Ereignis eintritt.</i>  <i>Wenn ein Ereignis eintritt, wird es behandelt.</i>  <i>Wenn nicht, wird die Anfrage erneut gesendet.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Die Effektivit√§t dieser L√∂sung wird jedoch radikal sinken, wenn die Anzahl der auf das Ereignis wartenden Clients zunimmt - jeder wartende Client belegt einen vollst√§ndigen Thread.  Au√üerdem erhalten wir eine zus√§tzliche Verz√∂gerung von 1 ms f√ºr die Ereignisausl√∂sung.  Oft ist es nicht wirklich so wichtig, aber warum sollten wir unsere Software schlechter machen, als es sein k√∂nnte?  Wenn wir dagegen Thread.Sleep (1) entfernen, wird einer der CPU-Kerne zu 100% geladen, w√§hrend in einem nutzlosen Zyklus nichts unternommen wird.  Mit Hilfe von TaskCompletionSource k√∂nnen wir unseren Code einfach transformieren, um alle genannten Probleme zu l√∂sen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Bitte beachten Sie, dass dieser Code nur ein Beispiel ist und in keiner Weise produktionsbereit.</i>  <i>Um es in realen F√§llen zu verwenden, m√ºssten wir zumindest eine M√∂glichkeit hinzuf√ºgen, um Situationen zu behandeln, in denen eine Nachricht empfangen wird, wenn nichts darauf wartet: In diesem Fall sollte die AcceptMessageAsync-Methode eine bereits abgeschlossene Aufgabe zur√ºckgeben.</i>  <i>Wenn dieser Fall der h√§ufigste ist, k√∂nnen wir die Verwendung von ValueTask in Betracht ziehen.</i> <br><br>  Beim Empfang einer Nachrichtenanforderung erstellen wir eine TaskCompletionSource, platzieren sie in einem W√∂rterbuch und warten dann auf eines der folgenden Ereignisse: Entweder wird das angegebene Zeitintervall ausgegeben oder eine Nachricht wird empfangen. <br><br><a name="ValueTask"></a><br><h4>  ValueTask: Warum und wie </h4><br>  async / await-Operatoren generieren genau wie der Yield-Return-Operator eine Finite-State-Maschine aus einer Methode, was bedeutet, dass ein neues Objekt erstellt wird. Dies ist meistens nicht wirklich wichtig, kann jedoch in einigen seltenen F√§llen zu Problemen f√ºhren.  Einer dieser F√§lle kann bei h√§ufig aufgerufenen Methoden auftreten - wir sprechen von Zehntausenden von Anrufen pro Sekunde.  Wenn eine solche Methode so geschrieben ist, dass sie das Ergebnis zur√ºckgibt und in den meisten F√§llen alle Wartemethoden umgeht, bietet .NET hierf√ºr ein Optimierungstool - die ValueTask-Struktur.  Schauen wir uns ein Beispiel an, um zu verstehen, wie es funktioniert.  Angenommen, es gibt einen Cache, auf den wir regelm√§√üig zugreifen.  Wenn darin Werte enthalten sind, geben wir diese einfach zur√ºck.  Wenn es keine Werte gibt, versuchen wir, sie von einem langsamen E / A zu erhalten.  Letzteres sollte idealerweise asynchron erfolgen, damit die gesamte Methode asynchron ist.  Der naheliegendste Weg, diese Methode zu implementieren, ist folgender: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br>  Mit dem Wunsch, es ein wenig zu optimieren und der Sorge, was Roslyn beim Kompilieren dieses Codes erzeugen wird, k√∂nnten wir die Methode wie folgt neu schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br>  Die beste L√∂sung in diesem Fall w√§re jedoch die Optimierung des Hot-Path - insbesondere das Abrufen von W√∂rterbuchwerten ohne unn√∂tige Zuordnungen und ohne Belastung des GC.  In den seltenen F√§llen, in denen wir Daten von IO abrufen m√ºssen, bleiben die Dinge fast gleich: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br>  Schauen wir uns dieses Codefragment genauer an: Wenn ein Wert im Cache vorhanden ist, erstellen wir eine Struktur.  Andernfalls wird die eigentliche Aufgabe in eine ValueTask eingeschlossen.  Der Pfad, √ºber den dieser Code ausgef√ºhrt wird, ist f√ºr den aufrufenden Code nicht wichtig: Aus Sicht der C # -Syntax verh√§lt sich eine ValueTask wie eine normale Aufgabe. <br><br><a name="TaskScheduler"></a><br><h4>  TaskScheduler: Steuern von Aufgabenausf√ºhrungsstrategien </h4><br>  Die n√§chste API, √ºber die ich sprechen m√∂chte, ist die <b>TaskScheduler-</b> Klasse und die daraus abgeleiteten.  Ich habe bereits erw√§hnt, dass TPL die M√∂glichkeit bietet, zu steuern, wie genau Aufgaben zwischen Threads verteilt werden.  Diese Strategien werden in Klassen definiert, die von TaskScheduler erben.  Fast jede Strategie, die wir ben√∂tigen, finden Sie in der <b>ParallelExtensionsExtras-</b> Bibliothek.  Diese Bibliothek wurde von Microsoft entwickelt, ist jedoch nicht Teil von .NET, sondern wird als Nuget-Paket verteilt.  Schauen wir uns einige der Strategien an: <br><br><ul><li>  CurrentThreadTaskScheduler - f√ºhrt Aufgaben f√ºr den aktuellen Thread aus </li><li>  LimitedConcurrencyLevelTaskScheduler - begrenzt die Anzahl der gleichzeitig ausgef√ºhrten Aufgaben mithilfe des N-Parameters, den es im Konstruktor akzeptiert </li><li>  OrderedTaskScheduler - ist als LimitedConcurrencyLevelTaskScheduler (1) definiert, sodass Aufgaben nacheinander ausgef√ºhrt werden. </li><li>  WorkStealingTaskScheduler - Implementiert den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Work-Stealing-</a> Ansatz f√ºr die Aufgabenausf√ºhrung.  Im Wesentlichen kann es als separater ThreadPool angezeigt werden.  Dies hilft bei dem Problem, dass ThreadPool eine statische Klasse in .NET ist. Wenn es in einem Teil der Anwendung √ºberladen oder nicht ordnungsgem√§√ü verwendet wird, k√∂nnen an einer anderen Stelle unangenehme Nebenwirkungen auftreten.  Die tats√§chlichen Ursachen solcher Fehler k√∂nnen schwer zu lokalisieren sein. Daher m√ºssen Sie m√∂glicherweise separate WorkStealingTaskSchedulers in den Teilen der Anwendung verwenden, in denen die Verwendung von ThreadPool aggressiv und unvorhersehbar sein kann. </li><li>  QueuedTaskScheduler - Erm√∂glicht die Ausf√ºhrung von Aufgaben auf der Grundlage einer priorisierten Warteschlange </li><li>  ThreadPerTaskScheduler - Erstellt einen separaten Thread f√ºr jede Aufgabe, die darauf ausgef√ºhrt wird.  Dies kann f√ºr Aufgaben hilfreich sein, deren Ausf√ºhrungszeit nicht gesch√§tzt werden kann. </li></ul><br>  Es gibt einen sehr guten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber TaskScheduler im Microsoft-Blog. Schauen Sie sich das an. <br><br>  In Visual Studio gibt es ein Aufgabenfenster, das beim Debuggen aller Aufgaben helfen kann.  In diesem Fenster k√∂nnen Sie den Status der Aufgabe anzeigen und zur aktuell ausgef√ºhrten Codezeile springen. <br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><a name="PLinq"></a><br><h4>  PLinq und die Parallelklasse </h4><br>  Abgesehen von Aufgaben und allen damit verbundenen Dingen gibt es in .NET zwei zus√§tzliche Tools, die wir interessant finden k√∂nnen - <b>PLinq</b> (Linq2Parallel) und die <b>Parallel-</b> Klasse.  Der erste verspricht die parallele Ausf√ºhrung aller Linq-Operationen auf allen Threads.  Die Anzahl der Threads kann durch eine Erweiterungsmethode WithDegreeOfParallelism konfiguriert werden.  Leider verf√ºgt PLinq im Standardmodus in den meisten F√§llen nicht √ºber gen√ºgend Informationen zur Datenquelle, um die Geschwindigkeit erheblich zu erh√∂hen.  Andererseits sind die Kosten f√ºr den Versuch sehr gering: Sie m√ºssen <b>AsParallel nur</b> vor der Kette der Linq-Methoden aufrufen und Leistungstests durchf√ºhren.  Dar√ºber hinaus k√∂nnen Sie mithilfe des Partitionsmechanismus zus√§tzliche Informationen √ºber die Art Ihrer Datenquelle an PLinq √ºbergeben.  Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Die statische Parallel-Klasse bietet Methoden zum parallelen Auflisten von Sammlungen √ºber Foreach, zum Ausf√ºhren des For-Zyklus und zum parallelen Ausf√ºhren mehrerer Delegaten zu Invoke.  Die Ausf√ºhrung des aktuellen Threads wird gestoppt, bis die Ergebnisse berechnet sind.  Sie k√∂nnen die Anzahl der Threads konfigurieren, indem Sie ParallelOptions als letztes Argument √ºbergeben.  TaskScheduler und CancellationToken k√∂nnen auch mithilfe von Optionen festgelegt werden. <br><br><a name="Summary"></a><br><h3>  Zusammenfassung </h3><br>  Als ich anfing, diesen Artikel zu schreiben, basierend auf meiner These und dem Wissen, das ich w√§hrend der Arbeit danach gewonnen hatte, dachte ich nicht, dass es so viele Informationen geben w√ºrde.  Jetzt, da mir der Texteditor vorwurfsvoll mitteilt, dass ich fast 15 Seiten geschrieben habe, m√∂chte ich eine Zwischenschlussfolgerung ziehen.  Wir werden uns im n√§chsten Artikel mit anderen Techniken, APIs, visuellen Tools und versteckten Gefahren befassen. <br><br>  <b>Schlussfolgerungen:</b> <br><br><ul><li>  Um die Ressourcen moderner PCs effektiv nutzen zu k√∂nnen, ben√∂tigen Sie Tools f√ºr die Arbeit mit Threads, Asynchronit√§t und Parallelit√§t. </li><li>  In .NET gibt es viele solche Tools </li><li>  Nicht alle von ihnen wurden gleichzeitig erstellt, daher kann es h√§ufig vorkommen, dass Sie auf alten Code sto√üen. Es gibt jedoch M√∂glichkeiten, alte APIs mit geringem Aufwand zu transformieren. </li><li>  In .NET werden die Klassen Thread und ThreadPool zum Arbeiten mit Threads verwendet </li><li>  Die Thread.Abort- und Thread.Interrupt-Methoden sowie die Win32-API-Funktion TerminateThread sind gef√§hrlich und werden nicht zur Verwendung empfohlen.  Stattdessen ist es besser, CancellationTokens zu verwenden </li><li>  Threads sind eine wertvolle Ressource und ihre Anzahl ist begrenzt.  Sie sollten F√§lle vermeiden, in denen Threads durch Warten auf Ereignisse belegt sind.  Die TaskCompletionSource-Klasse kann dabei helfen. </li><li>  Aufgaben sind das leistungsst√§rkste und robusteste Tool, mit dem .NET mit Parallelit√§t und Asynchronit√§t arbeiten kann. </li><li>  Die asynchronen / wartenden C # -Operatoren implementieren das Konzept eines nicht blockierenden Wartens </li><li>  Sie k√∂nnen mithilfe von Klassen, die von TaskScheduler abgeleitet wurden, steuern, wie Aufgaben zwischen Threads verteilt werden </li><li>  Die ValueTask-Struktur kann verwendet werden, um Hot-Paths und Speicherverkehr zu optimieren </li><li>  Die Fenster Aufgaben und Threads in Visual Studio bieten viele hilfreiche Informationen zum Debuggen von Multithread- oder asynchronem Code </li><li>  PLinq ist ein gro√üartiges Tool, das jedoch m√∂glicherweise nicht alle erforderlichen Informationen zu Ihrer Datenquelle enth√§lt - die mit dem Partitionierungsmechanismus weiterhin behoben werden k√∂nnen </li></ul><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung</a> folgt ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455252/">https://habr.com/ru/post/de455252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455242/index.html">Weniger Ohren oder wie man den Sound im Spiel nicht von Anfang an verdirbt</a></li>
<li><a href="../de455244/index.html">Comic "L√∂ten ist einfach" in der aktualisierten Version (2019)</a></li>
<li><a href="../de455246/index.html">Die Registrierung f√ºr den Customer Experience Day in St. Petersburg ist am 20. Juni ge√∂ffnet</a></li>
<li><a href="../de455248/index.html">Top Entwicklungsfehler bei der Arbeit mit PostgreSQL</a></li>
<li><a href="../de455250/index.html">Derjenige, der Herzog Nukem wiederbelebt hat: Interview mit Randy Pitchford, Magier von Gearbox</a></li>
<li><a href="../de455256/index.html">Habr Weekly # 4 / Computex, wie k√∂nnen wir Apple Beta, Durov hungert, BadComedian Katze, warum hat das neuronale Netzwerk nach Pornodarstellern gesucht</a></li>
<li><a href="../de455258/index.html">Die Abstimmung f√ºr die Berichte der Backend-Sektion zum Jubil√§um von DevConfX begann am 21. und 22. Juni in Moskau</a></li>
<li><a href="../de455260/index.html">Merkle Tree: rostig und schnell</a></li>
<li><a href="../de455264/index.html">Sei wie Munch oder ein paar Worte √ºber technische Pflicht</a></li>
<li><a href="../de455268/index.html">Wie alles begann: flexible und faltbare Displays - die Geschichte des Auftretens und Austritts von "Menschen"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>