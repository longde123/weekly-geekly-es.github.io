<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 😣 👩‍🔧 5 secrets cachés en Java 🙍🏻 🏇🏻 🤬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article " 5 secrets cachés en Java " de Justin Albano . 

 Vous voulez devenir un Java Jedi? Découv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 secrets cachés en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"> Bonjour, Habr!  Je vous présente la traduction de l'article " <a href="https://dzone.com/articles/5-hidden-secrets-in-java">5 secrets cachés en Java</a> " de <a href="https://dzone.com/users/1144561/albanoj2.html">Justin Albano</a> . <br><br>  Vous voulez devenir un Java Jedi?  Découvrez les anciens secrets de Java.  Nous nous concentrerons sur l'extension des annotations, l'initialisation, les commentaires et les interfaces d'énumération. <br><br>  Avec le développement des langages de programmation, des fonctions cachées commencent également à apparaître, et les constructions auxquelles les fondateurs n'ont jamais pensé sont de plus en plus répandues pour un usage général.  Certaines de ces fonctions sont généralement acceptées dans la langue, tandis que d'autres se déplacent dans les coins les plus sombres de la communauté linguistique.  Dans cet article, nous examinerons cinq secrets qui sont souvent négligés par de nombreux développeurs Java (pour être honnête, certains d'entre eux ont de bonnes raisons à cela).  Nous examinerons à la fois les options pour leur utilisation et les raisons qui ont conduit à l'apparition de chaque fonction, ainsi que quelques exemples qui montrent quand il est conseillé d'utiliser ces fonctions. <br><a name="habracut"></a><br>  Le lecteur doit comprendre que toutes ces fonctions ne sont pas réellement cachées, elles ne sont tout simplement pas souvent utilisées dans la programmation quotidienne.  Certains d'entre eux peuvent être très utiles au bon moment, alors que l'utilisation d'autres est presque toujours une mauvaise idée, et ils sont présentés dans cet article pour intéresser le lecteur (et éventuellement le faire rire).  Le lecteur doit également décider quand utiliser les fonctions décrites dans cet article: "Le fait que cela puisse être fait ne signifie pas qu'il doit être fait." <br><br><h3>  1. Mettre en œuvre des annotations </h3><br>  À partir du kit de développement Java (JDK) 5, les annotations font partie intégrante de nombreuses applications et environnements Java.  Dans la grande majorité des cas, les annotations s'appliquent aux constructions telles que les classes, les champs, les méthodes, etc.  Cependant, ils peuvent également être utilisés comme interfaces implémentées.  Par exemple, supposons que nous ayons la définition d'annotation suivante: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Test { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Nous appliquons généralement cette annotation à une méthode comme indiqué ci-dessous: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestFixure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenFooWhenBarThenBaz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Ensuite, nous pouvons traiter cette annotation comme décrit dans <a href="https://dzone.com/articles/creating-custom-annotations-in-java">Création d'annotations en Java</a> .  Si nous voulions également créer une interface qui nous permette de créer des tests en tant qu'objets, nous devrions créer une nouvelle interface, en l'appelant quelque chose d'autre, et non pas Test: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Ensuite, nous pouvons créer une instance de l'objet TestInstance: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTestInstance</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } } TestInstance myTest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooTestInstance();</code> </pre> <br>  Bien que notre annotation et notre interface soient presque identiques, avec une duplication très notable, il semble qu'il n'y ait aucun moyen de combiner ces deux constructions.  Heureusement, l'apparence est trompeuse et il existe une méthode pour combiner ces deux constructions: Implémentation des annotations: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends Annotation&gt; annotationType() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.class; } }</code> </pre> <br>  Notez que nous devons implémenter la méthode annotationType et également retourner le type d'annotation, car il s'agit d'une partie implicite de l'interface Annotation.  Bien que dans presque tous les cas, l'implémentation d'annotations ne soit pas la bonne décision de conception (le compilateur Java affichera un avertissement lors de l'implémentation de l'interface), cela peut être utile dans certains cas, par exemple, dans le cadre des annotations. <br><br><h3>  2. Blocs d'initialisation non statiques. </h3><br>  En Java, comme dans la plupart des langages de programmation orientés objet, les objets sont créés exclusivement à l'aide du constructeur (à quelques exceptions près, comme la désérialisation des objets Java).  Même lorsque nous créons des méthodes d'usine statiques pour créer des objets, nous enfermons simplement un appel dans le constructeur de l'objet pour l'instancier.  Par exemple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(name); } } Foo foo = Foo.withName(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>);</code> </pre> <br>  Par conséquent, lorsque nous voulons initialiser un objet, nous combinons la logique d'initialisation dans le constructeur de l'objet.  Par exemple, nous définissons le champ de nom de la classe Foo dans son constructeur paramétré.  Bien qu'il puisse sembler raisonnable de supposer que toute la logique d'initialisation se trouve dans le constructeur ou l'ensemble de constructeurs de la classe, ce n'est pas le cas en Java.  Au lieu de cela, nous pouvons utiliser <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html">des blocs d'initialisation non statiques</a> pour exécuter du code lors de la création d'un objet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Les blocs d'initialisation non statiques sont spécifiés en ajoutant une logique d'initialisation à un ensemble d'accolades dans la définition de classe.  Lorsqu'un objet est créé, les premiers blocs d'initialisation non statiques sont appelés, puis les constructeurs de l'objet.  Notez que vous pouvez spécifier plusieurs blocs d'initialisation non statiques, auquel cas chacun est appelé dans l'ordre dans lequel il est spécifié dans la définition de classe.  En plus des blocs d'initialisation non statiques, nous pouvons également créer des blocs statiques qui sont exécutés lorsque la classe est chargée en mémoire.  Pour créer un bloc d'initialisation statique, nous ajoutons simplement le mot-clé statique: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Lorsque les trois méthodes d'initialisation sont présentes dans la classe (constructeurs, blocs d'initialisation non statiques et blocs d'initialisation statiques), les méthodes statiques sont toujours exécutées en premier (lorsque la classe est chargée en mémoire) dans l'ordre de leur déclaration, puis les blocs d'initialisation non statiques sont exécutés dans l'ordre dans lequel ils sont déclarés, et après eux - les concepteurs.  Lorsqu'une superclasse est introduite, l'ordre d'exécution change un peu: <br><br><ol><li>  Blocs d'initialisation de superclasse statique, dans l'ordre de leur déclaration </li><li>  Blocs d'initialisation de sous-classe statiques, dans l'ordre de leur déclaration </li><li>  Blocs d'initialisation de superclasse non statiques, dans l'ordre où ils sont déclarés </li><li>  Constructeur de superclasse </li><li>  Blocs d'initialisation de sous-classe non statiques, dans l'ordre dans lequel ils sont déclarés </li><li>  Constructeur de sous-classe </li></ol><br>  Par exemple, nous pouvons créer l'application suivante: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:name-constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:name-constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Baz"</span></span>); } }</code> </pre> <br>  Si nous exécutons ce code, nous obtenons la sortie suivante: <br><br><pre> <code class="java hljs">Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:constructor Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:name-constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:name-constructor</code> </pre> <br>  Notez que les blocs d'initialisation statiques n'ont été exécutés qu'une seule fois, même si deux objets Foo ont été créés.  Bien que des blocs d'initialisation non statistiques et statiques puissent être utiles, la logique d'initialisation doit être placée dans les constructeurs et des méthodes (ou méthodes statiques) doivent être utilisées dans les cas où une logique complexe nécessite l'initialisation de l'état de l'objet. <br><br><h3>  3. Initialisation double parenthèse </h3><br>  De nombreux langages de programmation incluent une sorte de mécanisme de syntaxe pour créer rapidement et brièvement une liste ou une carte (ou un dictionnaire) sans utiliser de code de modèle détaillé.  Par exemple, C ++ inclut l' <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">initialisation entre parenthèses</a> , qui permet aux développeurs de créer rapidement une liste de valeurs énumérées ou même d'initialiser des objets entiers si le constructeur de l'objet prend en charge cette fonction.  Malheureusement, avant JDK 9, une telle fonction n'était pas implémentée (plus à ce sujet plus tard).  Pour créer simplement une liste d'objets, nous procédons comme suit: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); myInts.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Bien que cela remplisse notre objectif de créer une nouvelle liste initialisée avec trois valeurs, elle est trop verbeuse, obligeant le développeur à répéter le nom de la variable de liste pour chaque ajout.  Pour raccourcir ce code, nous pouvons utiliser une <a href="https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java">double initialisation des crochets</a> : <br><br><pre> <code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {{ add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); }};</code> </pre> <br>  Une initialisation à deux crochets, qui tire son nom d'un ensemble de deux accolades ouvertes et fermées, est en fait une collection de plusieurs éléments de syntaxe.  Tout d'abord, nous créons <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">une classe interne anonyme</a> qui étend la classe ArrayList.  Comme ArrayList n'a pas de méthodes abstraites, nous pouvons créer un corps vide pour une implémentation anonyme: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {};</code> </pre> <br>  En utilisant ce code, nous créons essentiellement une sous-classe anonyme, ArrayList est exactement la même que la ArrayList d'origine.  L'une des principales différences est que notre classe interne a une référence implicite à la classe contenante (sous la forme d'une variable capturée par celle-ci), car  nous créons une classe interne non statique.  Cela nous permet d'écrire une logique intéressante, sinon confuse.  Par exemple, ajouter cette variable à une classe interne anonyme initialisée avec un double crochet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Foo&gt;() {{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); List&lt;Foo&gt; fooList = foo.getListWithMeIncluded(); System.out.println(foo.equals(fooList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>))); } }</code> </pre> <br>  Si cette classe interne était définie comme statique, nous n'aurions pas accès à Foo.this.  Par exemple, le code suivant qui crée une classe interne FooArrayList statique n'a pas accès au lien Foo.this et ne compile donc pas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooArrayList(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&gt; </span></span>{{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }} }</code> </pre> <br>  En reprenant la construction avec notre ArrayList initialisé entre crochets, une fois qu'une classe interne non statique a été créée, nous utilisons des blocs d'initialisation non statiques, comme décrit ci-dessus, pour ajouter les trois éléments initiaux lors de l'instanciation d'une classe interne anonyme.  Lorsqu'une classe interne anonyme est créée et lorsqu'il n'y a qu'un seul objet d'une classe interne anonyme, nous pouvons dire que nous avons créé un objet interne non statique qui ajoute trois éléments initiaux lors de sa création.  Cela se verra si nous séparons une paire d'accolades, où une accolade représente la définition d'une classe interne anonyme et l'autre marque le début de la logique d'initialisation de l'instance: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() { { add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); } };</code> </pre> <br>  Bien que cette astuce puisse être utile, JDK 9 ( <a href="http://openjdk.java.net/jeps/269">JEP 269</a> ) a remplacé l'utilité de cette astuce par un ensemble de méthodes d'usine statiques pour List (ainsi que de nombreux autres types de collections).  Par exemple, nous pourrions créer une liste plus tôt en utilisant ces méthodes d'usine statiques, comme indiqué ci-dessous: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Cette technique d'usine statique est utilisée pour deux raisons principales: (1) une classe interne anonyme n'est pas créée et (2) pour réduire le code standard nécessaire pour créer une liste.  Il faut se rappeler que dans ce cas, le résultat de List est inchangé et ne peut pas être modifié après sa création.  Pour créer un fichier List mutable avec tous les éléments initiaux, nous devons utiliser une méthode régulière ou une méthode avec une parenthèse d'initialisation double. <br><br>  Notez que l'initialisation simple, le double crochet et les méthodes d'usine statique JDK 9 ne sont pas uniquement disponibles pour List.  Ils sont disponibles pour les objets Set et Map, comme illustré dans l'extrait de code suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;(); myMap.put("Foo", 10); myMap.put("Bar", 15); //     Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;() {{ put("Foo", 10); put("Bar", 15); }}; //    Map&lt;String, Integer&gt; myMap = Map.of("Foo", 10, "Bar", 15);</span></span></code> </pre> <br>  Il est important de comprendre comment le double support est initialisé avant de décider de son utilisation.  Cela améliore la lisibilité du code, mais certains effets secondaires peuvent apparaître. <br><br><h3>  4. Commentaires exécutables </h3><br>  Les commentaires font partie intégrante de presque tous les programmes, et le principal avantage des commentaires est qu'ils ne sont pas exécutés.  Cela devient encore plus évident lorsque nous commentons une ligne de code dans notre programme: nous voulons enregistrer le code dans notre application, mais nous ne voulons pas qu'il s'exécute.  Par exemple, le programme suivant affiche «5» en conséquence: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Beaucoup de gens pensent que les commentaires ne sont jamais exécutés, mais ce n'est pas entièrement vrai.  Par exemple, que produira l'extrait de code suivant? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// \u000dvalue = 8; System.out.println(value); }</span></span></code> </pre> <br>  Vous pouvez supposer qu'il s'agit à nouveau de 5, mais si nous exécutons le code ci-dessus, nous verrons 8 à la sortie.  La raison de cette «erreur» est le caractère Unicode \ u000d;  ce caractère est en fait un <a href="https://www.compart.com/en/unicode/U%2B000D">retour chariot Unicode</a> et le code source Java est utilisé par le compilateur sous forme de fichiers texte au format Unicode.  Son ajout au code définit la valeur = 8 dans la ligne suivant le commentaire, assurant son exécution.  Cela signifie que le fragment de code ci-dessus est en fait égal à ce qui suit: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Bien que cela ressemble à un bogue Java, il s'agit en fait d'une fonctionnalité spécialement ajoutée au langage.  L'objectif initial était de créer un langage indépendant de la plate-forme (d'où la création d'une machine virtuelle Java ou JVM), et l'interopérabilité du code source est un aspect clé de cet objectif.  En permettant au code source Java de contenir des caractères Unicode, nous pouvons utiliser des caractères non latins de manière universelle.  Cela garantit que le code écrit dans une région du monde (qui peut contenir des caractères non latins, comme dans les commentaires), peut être exécuté dans n'importe quelle autre.  Voir <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-3.html">Section 3.3 Spécifications du langage Java ou JLS</a> pour plus d'informations. <br><br>  Nous pouvons pousser cela à l'extrême et même écrire une application entière en Unicode.  Par exemple, que fait le programme suivant (code source, dérivé de <a href="https://programming.guide/java/executing-code-in-comments.html">Java: exécution de code dans les commentaires?!</a> )? <br><br><pre> <code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code> </pre> <br>  Si vous placez le code ci-dessus dans un fichier appelé Ugly.java et l'exécutez, Hello world sera imprimé sur la sortie standard.  Si nous convertissons ces caractères Unicode en caractères du <a href="https://en.wikipedia.org/wiki/ASCII">code standard américain pour l'échange d'informations (ASCII)</a> , nous obtenons le programme suivant: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ugly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello w"</span></span>+<span class="hljs-string"><span class="hljs-string">"orld"</span></span>); } }</code> </pre> <br>  Ainsi, les caractères Unicode peuvent être inclus dans le code source Java, mais s'ils ne sont pas requis, il est fortement recommandé de ne pas les utiliser (par exemple, pour inclure des caractères non latins dans les commentaires).  S'ils sont néanmoins requis, assurez-vous qu'ils n'incluent pas de caractères, tels que les retours chariot, qui modifient le comportement attendu du code source. <br><br><h3>  5. Implémentation de l'interface Enum </h3><br>  L'une des limites des énumérations (une liste d'énumération) par rapport aux autres classes de Java est que les énumérations ne peuvent pas étendre une autre classe ou les énumérations elles-mêmes.  Par exemple, vous ne pouvez pas effectuer les opérations suivantes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person extends Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } Person.JOE.speak();</code> </pre> <br>  Cependant, nous pouvons forcer nos énumérations à implémenter l'interface et fournir une implémentation pour ses méthodes abstraites comme suit: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Nous pouvons maintenant utiliser une instance de Person partout où un objet Speaker est requis.  De plus, nous pouvons également assurer la mise en œuvre de méthodes d'interface abstraites sur une base continue (les méthodes dites spécifiques aux constantes): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi, my name is Joseph"</span></span>); } }, JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hey, what's up?"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Contrairement à certains des autres secrets de cet article, cette technique ne doit être utilisée que lorsque cela est nécessaire.  Par exemple, si une constante d'énumération, telle que JOE ou JIM, peut être utilisée à la place d'une interface, telle que Speaker, alors l'énumération définissant une constante doit implémenter ce type d'interface.  Voir Paragraphe 38 (p. 176-9) <a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Java effectif, 3e édition</a> pour plus d'informations. <br><br><h3>  Conclusion </h3><br>  Dans cet article, nous avons examiné cinq secrets cachés en Java, à savoir: (1) les annotations peuvent être étendues, (2) les blocs d'initialisation non statiques peuvent être utilisés pour configurer un objet lors de sa création, (3) l'initialisation avec des crochets doubles peut être utilisée pour exécuter des instructions lors de la création une classe interne anonyme, (4) des commentaires peuvent parfois être exécutés et (5) des énumérations peuvent implémenter des interfaces.  Bien que ces fonctions soient utilisées par un certain type de tâche, certaines doivent être évitées (par exemple, créer des commentaires exécutables).  Lorsque vous décidez d'utiliser ces secrets, veillez à respecter la règle: "Le fait que cela puisse être fait ne signifie pas que cela doit être fait." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480544/">https://habr.com/ru/post/fr480544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480532/index.html">EDA sous un angle différent</a></li>
<li><a href="../fr480534/index.html">16 conseils de développement pour Android dans Kotlin. 2e partie</a></li>
<li><a href="../fr480538/index.html">Quoi de mieux pour les jeux: Intel Optane ou SSD?</a></li>
<li><a href="../fr480540/index.html">Sortie d'Umbraco 8.4: le CMS est encore plus pratique</a></li>
<li><a href="../fr480542/index.html">Sensibilisation à la sécurité des adultes: comment supprimer une vulnérabilité de phishing</a></li>
<li><a href="../fr480550/index.html">Hello World de Bytecode pour JVM</a></li>
<li><a href="../fr480552/index.html">Firefox se bat pour l'avenir du Web</a></li>
<li><a href="../fr480554/index.html">L'avenir du cloud computing de Sun qui n'est jamais venu</a></li>
<li><a href="../fr480556/index.html">NGINX: Vérification de la communauté informatique russe</a></li>
<li><a href="../fr480558/index.html">Comment le niveau d'équilibre du minage vous permet de déterminer le point de pivot du bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>