<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ üò£ üë©‚Äçüîß 5 secrets cach√©s en Java üôçüèª üèáüèª ü§¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article " 5 secrets cach√©s en Java " de Justin Albano . 

 Vous voulez devenir un Java Jedi? D√©couv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 secrets cach√©s en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"> Bonjour, Habr!  Je vous pr√©sente la traduction de l'article " <a href="https://dzone.com/articles/5-hidden-secrets-in-java">5 secrets cach√©s en Java</a> " de <a href="https://dzone.com/users/1144561/albanoj2.html">Justin Albano</a> . <br><br>  Vous voulez devenir un Java Jedi?  D√©couvrez les anciens secrets de Java.  Nous nous concentrerons sur l'extension des annotations, l'initialisation, les commentaires et les interfaces d'√©num√©ration. <br><br>  Avec le d√©veloppement des langages de programmation, des fonctions cach√©es commencent √©galement √† appara√Ætre, et les constructions auxquelles les fondateurs n'ont jamais pens√© sont de plus en plus r√©pandues pour un usage g√©n√©ral.  Certaines de ces fonctions sont g√©n√©ralement accept√©es dans la langue, tandis que d'autres se d√©placent dans les coins les plus sombres de la communaut√© linguistique.  Dans cet article, nous examinerons cinq secrets qui sont souvent n√©glig√©s par de nombreux d√©veloppeurs Java (pour √™tre honn√™te, certains d'entre eux ont de bonnes raisons √† cela).  Nous examinerons √† la fois les options pour leur utilisation et les raisons qui ont conduit √† l'apparition de chaque fonction, ainsi que quelques exemples qui montrent quand il est conseill√© d'utiliser ces fonctions. <br><a name="habracut"></a><br>  Le lecteur doit comprendre que toutes ces fonctions ne sont pas r√©ellement cach√©es, elles ne sont tout simplement pas souvent utilis√©es dans la programmation quotidienne.  Certains d'entre eux peuvent √™tre tr√®s utiles au bon moment, alors que l'utilisation d'autres est presque toujours une mauvaise id√©e, et ils sont pr√©sent√©s dans cet article pour int√©resser le lecteur (et √©ventuellement le faire rire).  Le lecteur doit √©galement d√©cider quand utiliser les fonctions d√©crites dans cet article: "Le fait que cela puisse √™tre fait ne signifie pas qu'il doit √™tre fait." <br><br><h3>  1. Mettre en ≈ìuvre des annotations </h3><br>  √Ä partir du kit de d√©veloppement Java (JDK) 5, les annotations font partie int√©grante de nombreuses applications et environnements Java.  Dans la grande majorit√© des cas, les annotations s'appliquent aux constructions telles que les classes, les champs, les m√©thodes, etc.  Cependant, ils peuvent √©galement √™tre utilis√©s comme interfaces impl√©ment√©es.  Par exemple, supposons que nous ayons la d√©finition d'annotation suivante: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Test { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Nous appliquons g√©n√©ralement cette annotation √† une m√©thode comme indiqu√© ci-dessous: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestFixure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenFooWhenBarThenBaz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Ensuite, nous pouvons traiter cette annotation comme d√©crit dans <a href="https://dzone.com/articles/creating-custom-annotations-in-java">Cr√©ation d'annotations en Java</a> .  Si nous voulions √©galement cr√©er une interface qui nous permette de cr√©er des tests en tant qu'objets, nous devrions cr√©er une nouvelle interface, en l'appelant quelque chose d'autre, et non pas Test: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Ensuite, nous pouvons cr√©er une instance de l'objet TestInstance: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTestInstance</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } } TestInstance myTest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooTestInstance();</code> </pre> <br>  Bien que notre annotation et notre interface soient presque identiques, avec une duplication tr√®s notable, il semble qu'il n'y ait aucun moyen de combiner ces deux constructions.  Heureusement, l'apparence est trompeuse et il existe une m√©thode pour combiner ces deux constructions: Impl√©mentation des annotations: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends Annotation&gt; annotationType() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.class; } }</code> </pre> <br>  Notez que nous devons impl√©menter la m√©thode annotationType et √©galement retourner le type d'annotation, car il s'agit d'une partie implicite de l'interface Annotation.  Bien que dans presque tous les cas, l'impl√©mentation d'annotations ne soit pas la bonne d√©cision de conception (le compilateur Java affichera un avertissement lors de l'impl√©mentation de l'interface), cela peut √™tre utile dans certains cas, par exemple, dans le cadre des annotations. <br><br><h3>  2. Blocs d'initialisation non statiques. </h3><br>  En Java, comme dans la plupart des langages de programmation orient√©s objet, les objets sont cr√©√©s exclusivement √† l'aide du constructeur (√† quelques exceptions pr√®s, comme la d√©s√©rialisation des objets Java).  M√™me lorsque nous cr√©ons des m√©thodes d'usine statiques pour cr√©er des objets, nous enfermons simplement un appel dans le constructeur de l'objet pour l'instancier.  Par exemple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(name); } } Foo foo = Foo.withName(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>);</code> </pre> <br>  Par cons√©quent, lorsque nous voulons initialiser un objet, nous combinons la logique d'initialisation dans le constructeur de l'objet.  Par exemple, nous d√©finissons le champ de nom de la classe Foo dans son constructeur param√©tr√©.  Bien qu'il puisse sembler raisonnable de supposer que toute la logique d'initialisation se trouve dans le constructeur ou l'ensemble de constructeurs de la classe, ce n'est pas le cas en Java.  Au lieu de cela, nous pouvons utiliser <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html">des blocs d'initialisation non statiques</a> pour ex√©cuter du code lors de la cr√©ation d'un objet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Les blocs d'initialisation non statiques sont sp√©cifi√©s en ajoutant une logique d'initialisation √† un ensemble d'accolades dans la d√©finition de classe.  Lorsqu'un objet est cr√©√©, les premiers blocs d'initialisation non statiques sont appel√©s, puis les constructeurs de l'objet.  Notez que vous pouvez sp√©cifier plusieurs blocs d'initialisation non statiques, auquel cas chacun est appel√© dans l'ordre dans lequel il est sp√©cifi√© dans la d√©finition de classe.  En plus des blocs d'initialisation non statiques, nous pouvons √©galement cr√©er des blocs statiques qui sont ex√©cut√©s lorsque la classe est charg√©e en m√©moire.  Pour cr√©er un bloc d'initialisation statique, nous ajoutons simplement le mot-cl√© statique: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } }</code> </pre> <br>  Lorsque les trois m√©thodes d'initialisation sont pr√©sentes dans la classe (constructeurs, blocs d'initialisation non statiques et blocs d'initialisation statiques), les m√©thodes statiques sont toujours ex√©cut√©es en premier (lorsque la classe est charg√©e en m√©moire) dans l'ordre de leur d√©claration, puis les blocs d'initialisation non statiques sont ex√©cut√©s dans l'ordre dans lequel ils sont d√©clar√©s, et apr√®s eux - les concepteurs.  Lorsqu'une superclasse est introduite, l'ordre d'ex√©cution change un peu: <br><br><ol><li>  Blocs d'initialisation de superclasse statique, dans l'ordre de leur d√©claration </li><li>  Blocs d'initialisation de sous-classe statiques, dans l'ordre de leur d√©claration </li><li>  Blocs d'initialisation de superclasse non statiques, dans l'ordre o√π ils sont d√©clar√©s </li><li>  Constructeur de superclasse </li><li>  Blocs d'initialisation de sous-classe non statiques, dans l'ordre dans lequel ils sont d√©clar√©s </li><li>  Constructeur de sous-classe </li></ol><br>  Par exemple, nous pouvons cr√©er l'application suivante: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bar:name-constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 1"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:static 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:name-constructor"</span></span>); } { System.out.println(<span class="hljs-string"><span class="hljs-string">"Foo:instance 2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Baz"</span></span>); } }</code> </pre> <br>  Si nous ex√©cutons ce code, nous obtenons la sortie suivante: <br><br><pre> <code class="java hljs">Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:constructor Bar:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Bar:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Bar:name-constructor Foo:instance <span class="hljs-number"><span class="hljs-number">1</span></span> Foo:instance <span class="hljs-number"><span class="hljs-number">2</span></span> Foo:name-constructor</code> </pre> <br>  Notez que les blocs d'initialisation statiques n'ont √©t√© ex√©cut√©s qu'une seule fois, m√™me si deux objets Foo ont √©t√© cr√©√©s.  Bien que des blocs d'initialisation non statistiques et statiques puissent √™tre utiles, la logique d'initialisation doit √™tre plac√©e dans les constructeurs et des m√©thodes (ou m√©thodes statiques) doivent √™tre utilis√©es dans les cas o√π une logique complexe n√©cessite l'initialisation de l'√©tat de l'objet. <br><br><h3>  3. Initialisation double parenth√®se </h3><br>  De nombreux langages de programmation incluent une sorte de m√©canisme de syntaxe pour cr√©er rapidement et bri√®vement une liste ou une carte (ou un dictionnaire) sans utiliser de code de mod√®le d√©taill√©.  Par exemple, C ++ inclut l' <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">initialisation entre parenth√®ses</a> , qui permet aux d√©veloppeurs de cr√©er rapidement une liste de valeurs √©num√©r√©es ou m√™me d'initialiser des objets entiers si le constructeur de l'objet prend en charge cette fonction.  Malheureusement, avant JDK 9, une telle fonction n'√©tait pas impl√©ment√©e (plus √† ce sujet plus tard).  Pour cr√©er simplement une liste d'objets, nous proc√©dons comme suit: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); myInts.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); myInts.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Bien que cela remplisse notre objectif de cr√©er une nouvelle liste initialis√©e avec trois valeurs, elle est trop verbeuse, obligeant le d√©veloppeur √† r√©p√©ter le nom de la variable de liste pour chaque ajout.  Pour raccourcir ce code, nous pouvons utiliser une <a href="https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java">double initialisation des crochets</a> : <br><br><pre> <code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {{ add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); }};</code> </pre> <br>  Une initialisation √† deux crochets, qui tire son nom d'un ensemble de deux accolades ouvertes et ferm√©es, est en fait une collection de plusieurs √©l√©ments de syntaxe.  Tout d'abord, nous cr√©ons <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">une classe interne anonyme</a> qui √©tend la classe ArrayList.  Comme ArrayList n'a pas de m√©thodes abstraites, nous pouvons cr√©er un corps vide pour une impl√©mentation anonyme: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() {};</code> </pre> <br>  En utilisant ce code, nous cr√©ons essentiellement une sous-classe anonyme, ArrayList est exactement la m√™me que la ArrayList d'origine.  L'une des principales diff√©rences est que notre classe interne a une r√©f√©rence implicite √† la classe contenante (sous la forme d'une variable captur√©e par celle-ci), car  nous cr√©ons une classe interne non statique.  Cela nous permet d'√©crire une logique int√©ressante, sinon confuse.  Par exemple, ajouter cette variable √† une classe interne anonyme initialis√©e avec un double crochet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Foo&gt;() {{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); List&lt;Foo&gt; fooList = foo.getListWithMeIncluded(); System.out.println(foo.equals(fooList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>))); } }</code> </pre> <br>  Si cette classe interne √©tait d√©finie comme statique, nous n'aurions pas acc√®s √† Foo.this.  Par exemple, le code suivant qui cr√©e une classe interne FooArrayList statique n'a pas acc√®s au lien Foo.this et ne compile donc pas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListWithMeIncluded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FooArrayList(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&gt; </span></span>{{ add(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }} }</code> </pre> <br>  En reprenant la construction avec notre ArrayList initialis√© entre crochets, une fois qu'une classe interne non statique a √©t√© cr√©√©e, nous utilisons des blocs d'initialisation non statiques, comme d√©crit ci-dessus, pour ajouter les trois √©l√©ments initiaux lors de l'instanciation d'une classe interne anonyme.  Lorsqu'une classe interne anonyme est cr√©√©e et lorsqu'il n'y a qu'un seul objet d'une classe interne anonyme, nous pouvons dire que nous avons cr√©√© un objet interne non statique qui ajoute trois √©l√©ments initiaux lors de sa cr√©ation.  Cela se verra si nous s√©parons une paire d'accolades, o√π une accolade repr√©sente la d√©finition d'une classe interne anonyme et l'autre marque le d√©but de la logique d'initialisation de l'instance: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;() { { add(<span class="hljs-number"><span class="hljs-number">1</span></span>); add(<span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-number"><span class="hljs-number">3</span></span>); } };</code> </pre> <br>  Bien que cette astuce puisse √™tre utile, JDK 9 ( <a href="http://openjdk.java.net/jeps/269">JEP 269</a> ) a remplac√© l'utilit√© de cette astuce par un ensemble de m√©thodes d'usine statiques pour List (ainsi que de nombreux autres types de collections).  Par exemple, nous pourrions cr√©er une liste plus t√¥t en utilisant ces m√©thodes d'usine statiques, comme indiqu√© ci-dessous: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Cette technique d'usine statique est utilis√©e pour deux raisons principales: (1) une classe interne anonyme n'est pas cr√©√©e et (2) pour r√©duire le code standard n√©cessaire pour cr√©er une liste.  Il faut se rappeler que dans ce cas, le r√©sultat de List est inchang√© et ne peut pas √™tre modifi√© apr√®s sa cr√©ation.  Pour cr√©er un fichier List mutable avec tous les √©l√©ments initiaux, nous devons utiliser une m√©thode r√©guli√®re ou une m√©thode avec une parenth√®se d'initialisation double. <br><br>  Notez que l'initialisation simple, le double crochet et les m√©thodes d'usine statique JDK 9 ne sont pas uniquement disponibles pour List.  Ils sont disponibles pour les objets Set et Map, comme illustr√© dans l'extrait de code suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;(); myMap.put("Foo", 10); myMap.put("Bar", 15); //     Map&lt;String, Integer&gt; myMap = new HashMap&lt;&gt;() {{ put("Foo", 10); put("Bar", 15); }}; //    Map&lt;String, Integer&gt; myMap = Map.of("Foo", 10, "Bar", 15);</span></span></code> </pre> <br>  Il est important de comprendre comment le double support est initialis√© avant de d√©cider de son utilisation.  Cela am√©liore la lisibilit√© du code, mais certains effets secondaires peuvent appara√Ætre. <br><br><h3>  4. Commentaires ex√©cutables </h3><br>  Les commentaires font partie int√©grante de presque tous les programmes, et le principal avantage des commentaires est qu'ils ne sont pas ex√©cut√©s.  Cela devient encore plus √©vident lorsque nous commentons une ligne de code dans notre programme: nous voulons enregistrer le code dans notre application, mais nous ne voulons pas qu'il s'ex√©cute.  Par exemple, le programme suivant affiche ¬´5¬ª en cons√©quence: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Beaucoup de gens pensent que les commentaires ne sont jamais ex√©cut√©s, mais ce n'est pas enti√®rement vrai.  Par exemple, que produira l'extrait de code suivant? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// \u000dvalue = 8; System.out.println(value); }</span></span></code> </pre> <br>  Vous pouvez supposer qu'il s'agit √† nouveau de 5, mais si nous ex√©cutons le code ci-dessus, nous verrons 8 √† la sortie.  La raison de cette ¬´erreur¬ª est le caract√®re Unicode \ u000d;  ce caract√®re est en fait un <a href="https://www.compart.com/en/unicode/U%2B000D">retour chariot Unicode</a> et le code source Java est utilis√© par le compilateur sous forme de fichiers texte au format Unicode.  Son ajout au code d√©finit la valeur = 8 dans la ligne suivant le commentaire, assurant son ex√©cution.  Cela signifie que le fragment de code ci-dessus est en fait √©gal √† ce qui suit: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// value = 8; System.out.println(value); }</span></span></code> </pre> <br>  Bien que cela ressemble √† un bogue Java, il s'agit en fait d'une fonctionnalit√© sp√©cialement ajout√©e au langage.  L'objectif initial √©tait de cr√©er un langage ind√©pendant de la plate-forme (d'o√π la cr√©ation d'une machine virtuelle Java ou JVM), et l'interop√©rabilit√© du code source est un aspect cl√© de cet objectif.  En permettant au code source Java de contenir des caract√®res Unicode, nous pouvons utiliser des caract√®res non latins de mani√®re universelle.  Cela garantit que le code √©crit dans une r√©gion du monde (qui peut contenir des caract√®res non latins, comme dans les commentaires), peut √™tre ex√©cut√© dans n'importe quelle autre.  Voir <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-3.html">Section 3.3 Sp√©cifications du langage Java ou JLS</a> pour plus d'informations. <br><br>  Nous pouvons pousser cela √† l'extr√™me et m√™me √©crire une application enti√®re en Unicode.  Par exemple, que fait le programme suivant (code source, d√©riv√© de <a href="https://programming.guide/java/executing-code-in-comments.html">Java: ex√©cution de code dans les commentaires?!</a> )? <br><br><pre> <code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code> </pre> <br>  Si vous placez le code ci-dessus dans un fichier appel√© Ugly.java et l'ex√©cutez, Hello world sera imprim√© sur la sortie standard.  Si nous convertissons ces caract√®res Unicode en caract√®res du <a href="https://en.wikipedia.org/wiki/ASCII">code standard am√©ricain pour l'√©change d'informations (ASCII)</a> , nous obtenons le programme suivant: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ugly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello w"</span></span>+<span class="hljs-string"><span class="hljs-string">"orld"</span></span>); } }</code> </pre> <br>  Ainsi, les caract√®res Unicode peuvent √™tre inclus dans le code source Java, mais s'ils ne sont pas requis, il est fortement recommand√© de ne pas les utiliser (par exemple, pour inclure des caract√®res non latins dans les commentaires).  S'ils sont n√©anmoins requis, assurez-vous qu'ils n'incluent pas de caract√®res, tels que les retours chariot, qui modifient le comportement attendu du code source. <br><br><h3>  5. Impl√©mentation de l'interface Enum </h3><br>  L'une des limites des √©num√©rations (une liste d'√©num√©ration) par rapport aux autres classes de Java est que les √©num√©rations ne peuvent pas √©tendre une autre classe ou les √©num√©rations elles-m√™mes.  Par exemple, vous ne pouvez pas effectuer les op√©rations suivantes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person extends Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } Person.JOE.speak();</code> </pre> <br>  Cependant, nous pouvons forcer nos √©num√©rations √† impl√©menter l'interface et fournir une impl√©mentation pour ses m√©thodes abstraites comme suit: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>), JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Nous pouvons maintenant utiliser une instance de Person partout o√π un objet Speaker est requis.  De plus, nous pouvons √©galement assurer la mise en ≈ìuvre de m√©thodes d'interface abstraites sur une base continue (les m√©thodes dites sp√©cifiques aux constantes): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speaker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Person implements Speaker { JOE(<span class="hljs-string"><span class="hljs-string">"Joseph"</span></span>) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi, my name is Joseph"</span></span>); } }, JIM(<span class="hljs-string"><span class="hljs-string">"James"</span></span>){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hey, what's up?"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); } } Person.JOE.speak();</code> </pre> <br>  Contrairement √† certains des autres secrets de cet article, cette technique ne doit √™tre utilis√©e que lorsque cela est n√©cessaire.  Par exemple, si une constante d'√©num√©ration, telle que JOE ou JIM, peut √™tre utilis√©e √† la place d'une interface, telle que Speaker, alors l'√©num√©ration d√©finissant une constante doit impl√©menter ce type d'interface.  Voir Paragraphe 38 (p. 176-9) <a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Java effectif, 3e √©dition</a> pour plus d'informations. <br><br><h3>  Conclusion </h3><br>  Dans cet article, nous avons examin√© cinq secrets cach√©s en Java, √† savoir: (1) les annotations peuvent √™tre √©tendues, (2) les blocs d'initialisation non statiques peuvent √™tre utilis√©s pour configurer un objet lors de sa cr√©ation, (3) l'initialisation avec des crochets doubles peut √™tre utilis√©e pour ex√©cuter des instructions lors de la cr√©ation une classe interne anonyme, (4) des commentaires peuvent parfois √™tre ex√©cut√©s et (5) des √©num√©rations peuvent impl√©menter des interfaces.  Bien que ces fonctions soient utilis√©es par un certain type de t√¢che, certaines doivent √™tre √©vit√©es (par exemple, cr√©er des commentaires ex√©cutables).  Lorsque vous d√©cidez d'utiliser ces secrets, veillez √† respecter la r√®gle: "Le fait que cela puisse √™tre fait ne signifie pas que cela doit √™tre fait." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480544/">https://habr.com/ru/post/fr480544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480532/index.html">EDA sous un angle diff√©rent</a></li>
<li><a href="../fr480534/index.html">16 conseils de d√©veloppement pour Android dans Kotlin. 2e partie</a></li>
<li><a href="../fr480538/index.html">Quoi de mieux pour les jeux: Intel Optane ou SSD?</a></li>
<li><a href="../fr480540/index.html">Sortie d'Umbraco 8.4: le CMS est encore plus pratique</a></li>
<li><a href="../fr480542/index.html">Sensibilisation √† la s√©curit√© des adultes: comment supprimer une vuln√©rabilit√© de phishing</a></li>
<li><a href="../fr480550/index.html">Hello World de Bytecode pour JVM</a></li>
<li><a href="../fr480552/index.html">Firefox se bat pour l'avenir du Web</a></li>
<li><a href="../fr480554/index.html">L'avenir du cloud computing de Sun qui n'est jamais venu</a></li>
<li><a href="../fr480556/index.html">NGINX: V√©rification de la communaut√© informatique russe</a></li>
<li><a href="../fr480558/index.html">Comment le niveau d'√©quilibre du minage vous permet de d√©terminer le point de pivot du bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>