<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‚ğŸ¼ ğŸŒ³ ğŸ›€ğŸ¼ Sortasi Hibrid â¬…ï¸ â™€ï¸ ğŸ‘â€ğŸ—¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti yang sudah diketahui semua orang, penyortiran dapat didasarkan pada pertukaran, sisipan, pemilihan, penggabungan, dan distribusi. 

 Tetapi ji...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortasi Hibrid</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/483786/"> <a href="https://habr.com/ru/company/edison/blog/483786/"><img width="694" height="321" src="https://habrastorage.org/webt/ql/cs/2p/qlcs2psim6ksv4hbrwrndioyifi.png"></a> <br><br>  Seperti yang sudah diketahui semua orang, penyortiran dapat didasarkan pada pertukaran, sisipan, pemilihan, penggabungan, dan distribusi. <br><br>  Tetapi jika metode yang berbeda digabungkan dalam algoritma, maka itu milik kelas macam hibrida. <a name="habracut"></a><habracut text=""></habracut><blockquote> <a href="https://www.edsd.ru/" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a> <br clear="right">  Artikel ini ditulis dengan dukungan EDISON. <br><br>  Kami terlibat dalam <a href="https://www.edsd.ru/ru/o_kompanii/novosti/dorabotka-i-soprovozhdenie-sajta-na-1s-bitriks">penyelesaian dan pemeliharaan situs di 1C-Bitrix</a> , serta <a href="https://www.edsd.ru/ru/proekty/mobilnye_prilozhenija">pengembangan aplikasi mobile Android dan iOS</a> . <br><br>  Kami menyukai teori algoritma!  ;-) </blockquote>  Mari kita cepat mengingat apa yang dimiliki algoritma pengurutan kelas dan apa saja fitur masing-masing. <br><br><h4>  Pertukaran macam </h4><img align="right" width="350" height="132" src="https://habrastorage.org/webt/ay/2k/km/ay2kkmr3ipze-pdbcmxfjgdp-le.png"><br>  Elemen-elemen array dibandingkan berpasangan satu sama lain dan pertukaran dibuat untuk pasangan yang tidak teratur. <br><br>  Perwakilan paling efektif dari kelas ini adalah <b>jenis cepat</b> legendaris. <br><br><h4>  Urutan Penyisipan </h4><img align="right" width="398" height="102" src="https://habrastorage.org/webt/tm/hd/35/tmhd35egnxxtisoa_zd8d_ucggi.png"><br>  Elemen dari bagian array yang tidak disortir dimasukkan ke dalam tempatnya di area yang diurutkan. <br><br>  Dari kelas ini, <b>menyortir berdasarkan sisipan sederhana</b> paling sering digunakan.  Meskipun algoritma ini memiliki kompleksitas rata-rata O ( <b>n <sup>2</sup></b> ), pengurutan ini bekerja sangat cepat dengan array yang hampir teratur - pada mereka kompleksitas mencapai O ( <b>n</b> ).  Selain itu, pengurutan ini adalah salah satu opsi terbaik untuk memproses array kecil. <br><br>  <b>Mengurutkan menggunakan pohon pencarian biner</b> juga termasuk dalam kelas ini. <br><br><h4>  Sortir berdasarkan pilihan </h4><img align="right" width="300" height="100" src="https://habrastorage.org/webt/gp/bh/ho/gpbhhomuobutgbg6l-r9basjzlg.png"><br>  Di area tidak berurutan, elemen minimum / maksimum dipilih, yang ditransfer ke akhir / awal bagian array yang tidak disortir. <br><br>  Penyortiran dengan pilihan sederhana bekerja sangat lambat (rata-rata O ( <b>n <sup>2</sup></b> )), tetapi di kelas ini ada <b>penyortiran yang</b> sulit <b>dengan tumpukan</b> (alias <b>penyortiran piramidal</b> ), yang memiliki kompleksitas waktu O ( <b>n</b> log <b>n</b> ) - dan, yang sangat berharga, Tidak ada kasus degenerasi penyortiran ini, apa pun data yang masuk.  Ngomong-ngomong, pengurutan ini juga tidak memiliki kasus terbaik untuk data yang masuk. <br><br><h4>  Gabungkan Urusan </h4><br>  Area yang diurutkan diambil dalam array dan digabung, yaitu, subarrays yang lebih kecil digabungkan menjadi subarray yang lebih besar. <br><br><div style="text-align:center;"><img width="677" height="50" src="https://habrastorage.org/webt/qm/mh/vn/qmmhvnkmevjb34akg2dxjquef90.png"></div><br><br>  Jika dua subarrays diurutkan, maka menggabungkannya adalah operasi yang mudah diimplementasikan dan waktu cepat.  Sisi lain dari koin adalah bahwa penggabungan hampir selalu membutuhkan biaya memori tambahan O ( <b>n</b> ) - walaupun ada beberapa opsi yang sangat canggih untuk menyortir dengan penggabungan, di mana biaya memori adalah O (1). <br><br><h4>  Urutkan berdasarkan distribusi </h4><br>  Elemen-elemen dari array didistribusikan dan didistribusikan kembali ke dalam kelas sampai array menerima keadaan yang diurutkan. <br><br>  Elemen-elemen tersebar ke dalam kelompok baik tergantung pada nilainya (apa yang disebut <b>sorting penghitungan</b> ) atau tergantung pada nilai digit individu (ini sudah <b>sortasi bitwise</b> ). <br><br><div style="text-align:center;"><img width="657" height="219" src="https://habrastorage.org/webt/42/ch/6z/42ch6zg2eg2zfkqbmgxmte9arii.png"></div><br><br>  <b>Penyortiran ember</b> juga termasuk dalam kelas ini. <br><br>  Ciri pengurutan berdasarkan distribusi adalah bahwa keduanya tidak menggunakan perbandingan elemen berpasangan di antara mereka sendiri, atau perbandingan semacam itu hanya ada pada tingkat yang kecil.  Oleh karena itu, pengurutan berdasarkan distribusi seringkali lebih cepat, misalnya, pengurutan cepat.  Di sisi lain, pengurutan berdasarkan distribusi seringkali membutuhkan banyak memori tambahan, karena kelompok elemen yang terus-menerus didistribusikan perlu disimpan di suatu tempat. <br><br><hr><hr><hr><hr><hr><br>  Perselisihan tentang penyortiran mana <i>yang terbaik</i> adalah sangat sering, tetapi faktanya adalah bahwa tidak ada dan tidak bisa menjadi algoritma yang ideal untuk semua kesempatan.  Misalnya, penyortiran cepat sangat cepat (tapi bukan yang tercepat) di sebagian besar situasi, tetapi penyortiran juga terjadi pada kasus yang merosot saat terjadi kerusakan.  Menyortir berdasarkan sisipan sederhana lambat, tetapi untuk array yang hampir dipesan, akan dengan mudah mem-bypass algoritma lain.  Heap sorting bekerja cukup cepat dengan data yang masuk, tetapi tidak secepat sortasi lainnya dalam kondisi tertentu dan tidak ada cara untuk mempercepat piramida.  Menggabungkan pengurutan lebih lambat dari pengurutan cepat, namun jika ada diurutkan sub-array dalam array, maka lebih cepat untuk menggabungkan mereka daripada mengurutkan dengan pengurutan cepat.  Jika array memiliki banyak elemen berulang atau kita mengurutkan baris, maka kemungkinan besar mengurutkan berdasarkan distribusi adalah pilihan terbaik.  Setiap metode sangat baik dalam situasi yang paling menguntungkan. <br><br>  Meskipun demikian, programmer terus menciptakan sortasi tercepat di dunia, mensintesis metode paling efektif dari kelas yang berbeda.  Mari kita lihat seberapa sukses itu untuk mereka. <br><br>  Karena banyak algoritma non-sepele disebutkan dalam artikel, saya hanya membahas secara singkat prinsip-prinsip dasar pekerjaan mereka, tanpa membebani artikel dengan animasi dan penjelasan rinci.  Di masa depan akan ada artikel terpisah, di mana akan ada kartun untuk setiap algoritma dan nuansa halus yang terperinci. <br><br><hr><hr><hr><hr><hr><br><h2>  Sisipkan + Gabung </h2><br>  Kesimpulan murni empiris adalah bahwa fusi dan / atau penyisipan paling sering digunakan dalam hibrida.  Dalam sebagian besar penyortiran, satu atau metode lain ditemukan, atau keduanya bersamaan.  Dan ada penjelasan logis untuk ini. <br><br>  Sortir penemu sering berusaha untuk membuat algoritma paralel yang secara bersamaan memesan berbagai bagian array.  Cara terbaik untuk menangani beberapa subarrays yang diurutkan adalah dengan menggabungkannya - ini akan menjadi yang tercepat. <br><br>  Algoritma modern sering menggunakan rekursi.  Selama turunan rekursif, array biasanya dibagi menjadi dua bagian, pada level terendah, array dipesan.  Ketika kembali ke level rekursi yang lebih tinggi, muncul pertanyaan menggabungkan sub-array yang diurutkan pada level yang lebih rendah. <br><br>  Sedangkan untuk sisipan, dalam algoritma hibrid pada tahap tertentu sering kira-kira sub-susunan pesanan diperoleh, yang terbaik mengarah pada pemesanan akhir dengan bantuan sisipan. <br><br>  Grup ini berisi jenis hibrid, di mana ada penggabungan dan penyisipan, dan metode ini digunakan sangat berbeda. <br><br><h3>  Sortir penggabungan-penyisipan <br>  Algoritma Ford Johnson :: Algoritma Ford-Johnson </h3><br><h4>  <i>Gabung + Sisipkan</i> </h4><img align="right" width="200" height="285" src="https://habrastorage.org/webt/pr/io/c-/prioc-ed14huk3as3gadpjccxks.jpeg"><br clear="left">  Cara yang sangat kuno, sudah di tahun 1959.  Hal ini dijelaskan secara terperinci dalam karya abadi Donald Knuth, â€œSeni Pemrograman,â€ Volume 3, â€œPenyortiran dan Pencarian,â€ Bab 5, â€œPenyortiran,â€ Bagian 5.3, â€œPenyortiran Optimal,â€ subbagian, â€œPenyortiran dengan Jumlah Minimum Perbandingan,â€ dan bagian â€œPenyortiran dengan Penyisipan dan Penggabunganâ€. . <br><br>  Penyortiran sekarang tidak memiliki nilai praktis, tetapi menarik bagi mereka yang menyukai teori algoritma.  Masalah menemukan cara untuk mengurutkan <b>n</b> elemen dengan jumlah perbandingan paling sedikit dipertimbangkan.  Modifikasi heuristik non-sepele penyortiran penyisipan (penyisipan Anda tidak akan menemukan tempat lain) menggunakan <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25AF%25D0%25BA%25D0%25BE%25D0%25B1%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D1%258F">nomor Jacobstal diusulkan</a> untuk meminimalkan jumlah perbandingan.  Sampai saat ini, juga diketahui bahwa ini bukan pilihan terbaik dan Anda bahkan bisa dengan lebih cekatan menghindari dan mendapatkan lebih sedikit perbandingan.  Secara umum, penyortiran akademik standar tidak berguna secara praktis, tetapi bagi para pecinta genre, senang membongkar trik semacam itu dengan bias aljabar. <br><br><h3>  Sortir Tim :: Timsort </h3><br><h4>  <i>Sisipkan + Gabung</i> </h4><img align="right" width="530" height="192" src="https://habrastorage.org/webt/cu/mf/fu/cumfful_rsg9ipz1yryimfpldxi.jpeg"><br clear="left">  <i>Diposting oleh Tim Peters 15 tahun yang lalu dan sekarang</i> <br><br>  Penyortiran HabrÃ© seperti ini sering diingat. <br>  Tesis: dalam sebuah array, sub-array kecil yang hampir dipesan dicari untuk menyortir penyisipan yang digunakan.  Subarrays ini kemudian digabung menggunakan gabungan. <br><br>  Penggabungan dalam TimSort adalah bagian yang paling menarik: penggabungan ke atas klasik lebih dioptimalkan untuk situasi yang berbeda.  Misalnya, diketahui bahwa penggabungan lebih efisien jika subarrays yang digabung kira-kira berukuran sama.  Di TimSort, jika ukurannya sangat berbeda, maka setelah tindakan tambahan ada penyesuaian (kita dapat mengatakan bahwa bagian dari elemen akan "mengalir" dari subarray yang lebih besar ke yang lebih kecil, setelah penggabungan akan dilanjutkan dalam mode standar).  Berbagai situasi berbahaya juga disediakan - misalnya, jika dalam satu subarray semua elemen akan kurang dari yang lain.  Dalam hal ini, perbandingan elemen-elemen dari kedua sub-layar akan menganggur.  Prosedur merger yang dimodifikasi akan "memperhatikan" perkembangan peristiwa yang tidak diinginkan pada waktunya, dan jika "yakin" akan opsi pesimistis menggunakan pencarian biner, ia akan beralih ke opsi pemrosesan yang lebih optimal. <br><br>  Rata-rata, pengurutan ini bekerja sedikit lebih lambat daripada QuickSort, namun, jika array yang masuk berisi jumlah yang cukup dari urutan elemen berikutnya, maka kecepatan meningkat secara signifikan dan di sini TimSort lebih maju dari yang lain. <br><br><h3>  Block merge sort :: Blok merge sort <br>  Wiki-sort :: Wiki-sort <br>  Holy Grail Sort :: Grailsort </h3><br><h4>  <i>Sisipan + Gabung + Bucket</i> </h4><img align="right" width="343" height="240" src="https://habrastorage.org/webt/bz/ev/g6/bzevg6rsbv563fjqzz-hsqpfeso.gif"><br clear="left">  <i>Blokir animasi penyortiran gabungan dari Wikipedia.</i> <br><br>  Ini sangat segar (2008) dan pada saat yang sama algoritma yang sangat menjanjikan.  Faktanya adalah bahwa masalah penggabungan yang relatif signifikan adalah biaya memori tambahan.  Biasanya, di mana penggabungan ada, ada juga kompleksitas memori O ( <b>n</b> ). <br><br>  Tetapi WikiSort dirancang agar penggabungan terjadi tanpa menggunakan memori tambahan - di antara jenis penggabungan, dalam hal ini, ini adalah contoh yang sangat jarang.  Selain itu, algoritma ini stabil.  Nah, jika sorting gabungan konvensional memiliki kecepatan algoritmik terbaik O ( <b>n</b> log <b>n</b> ), maka dalam wiki sorting indikator ini adalah O ( <b>n</b> ).  Sampai baru-baru ini, pada prinsipnya diyakini bahwa menggabungkan penyortiran dengan seperangkat karakteristik seperti itu tidak mungkin, tetapi programmer Cina mengejutkan semua orang. <br><br>  Algoritma ini sangat rumit untuk dijelaskan dalam beberapa kalimat.  Tapi suatu hari nanti aku akan menulis kebiasaan berbeda tentang dia. <br><br>  Awalnya, algoritma itu tanpa nama disebut Block Merge Sort, namun, dengan tangan ringan Tim Peters, yang mempelajari penyortiran secara detail (untuk menentukan apakah beberapa idenya harus ditransfer ke TimSort), nama WikiSort melekat padanya. <br><br>  Habruiser yang berangkat sebelum waktunya <a href="https://habr.com/ru/users/mrrl/" class="user_link">secara</a> independen bekerja selama beberapa tahun untuk menyortir gabungan, yang secara bersamaan cepat dengan data yang masuk, ekonomis dalam memori, dan stabil.  <a href="https://habr.com/ru/post/205290/">Pencarian kreatifnya berhasil</a> dan dia kemudian menyebut algoritma yang dikembangkan sebagai penyortiran Holy Grail (karena memenuhi semua persyaratan tinggi "penyortiran sempurna").  Sebagian besar ide dari algoritma ini mirip dengan yang diterapkan di WikiSort, meskipun jenis ini tidak identik dan dikembangkan secara independen satu sama lain. <br><br><h3>  Sortir tabel hash :: Sortir tabel hash </h3><br><h4>  <i>Distribusi + Sisipkan + Gabung</i> </h4><br>  Array secara rekursif dibagi menjadi dua, sampai jumlah elemen dalam subarrays yang dihasilkan mencapai nilai ambang tertentu.  Pada tingkat rekursi terendah, perkiraan distribusi terjadi (menggunakan tabel hash) dan subarray diurutkan berdasarkan sisipan.  Lalu ada pengembalian rekursif ke tingkat yang lebih tinggi, bagian yang diurutkan dikombinasikan dengan penggabungan. <br><br>  Saya <a href="https://habr.com/ru/post/478654/">berbicara</a> sedikit lebih banyak tentang algoritma ini <a href="https://habr.com/ru/post/478654/">sebulan yang lalu</a> . <br><br><hr><hr><hr><hr><hr><br><h2>  Sortir cepat sebagai primer </h2><br>  Setelah menggabungkan dan menyisipkan, tempat ketiga dalam parade hit hibrida dipegang teguh oleh jenis cepat favorit semua orang. <br><br>  Ini adalah algoritma yang sangat efisien, tetapi ada kasus yang merosot untuk itu juga.  Beberapa penemu mencoba membuat QuickSort benar-benar kebal terhadap data masuk yang buruk dan menyarankan untuk melengkapi dengan ide-ide kuat dari jenis lain. <br><br><h3>  Sortir introspektif :: Introsort, Introspektif sort, std :: sort </h3><br><h4>  <i>Sisipan + heap + cepat</i> </h4><img align="right" width="395" height="470" src="https://habrastorage.org/webt/kq/om/vq/kqomvqs3ugrvl1xdnrw0vm54jnu.png"><br clear="left">  Heap sorting bekerja lebih lambat daripada sortasi cepat, tetapi pada saat yang sama, tidak seperti QuickSort, ia tidak memiliki kasus yang merosot - rata-rata, kompleksitas waktu algoritmik algoritme terbaik dan terburuk adalah O ( <b>n</b> log <b>n</b> ). <br><br>  Oleh karena itu, David Musser mengusulkan untuk aman selama penyortiran cepat - jika ada tingkat sarang yang terlalu tinggi, maka ini dianggap sebagai serangan pada sistem, yang menyelipkan array yang "buruk".  Beralih ke pengurutan berdasarkan tumpukan terjadi, yang bukan megabyte, tetapi juga tidak lambat untuk mengatasi data yang masuk. <br><br>  C ++ memiliki algoritma yang disebut std :: sort, yang merupakan implementasi dari penyortiran introspektif.  Tambahan kecil - jika pada tingkat rekursi berikutnya <nobr>jumlah elemen subarray adalah â‰¤ 16</nobr> , maka penyortiran penyisipan diterapkan ke subarray. <br><br><h3>  Urut multikey :: Urut multikey <br>  Bitwise Quick Sort :: Radix quick sort </h3><br><h4>  <i>Peringkat + cepat</i> </h4><br>  Penyortiran cepat, hanya nilai-nilai elemen array yang dibandingkan satu sama lain, tetapi masing-masing digit (pertama, kami memesan digit yang lebih tinggi dengan cara ini, kami bergerak dari yang terendah). <br><br>  Atau lebih - ini pengurutan bitwise dengan urutan tinggi, pemesanan di dalam bit berikutnya dilakukan sesuai dengan algoritma pengurutan cepat. <br><br><h3>  Sortir Menyebar :: Spreadsort </h3><br><h4>  <i>Cepat + gabungkan + ember + pelepasan</i> </h4><br>  Gestalt dari quicksort, merge sort, sort ember, dan bitwise sort. <br><br>  Singkatnya, jangan menjelaskan.  Kami akan menganalisis algoritme ini secara rinci di salah satu artikel berikut. <br><br><hr><hr><hr><hr><hr><br><h2>  Hibrida lainnya </h2><br><h3>  Jenis penghitungan pohon </h3><br><h4>  <i>Menghitung + pohon</i> </h4><br>  Algoritma yang <a href="https://habr.com/ru/post/418355/">diajukan oleh</a> pengguna <a href="https://habr.com/ru/users/alexanderusatov/" class="user_link">AlexanderUsatov</a> .  Jenis penghitungan, jumlah kunci yang dihitung disimpan di pohon seimbang. <br><br><h3>  J-sort :: J-sort </h3><br><h4>  <i>Sisipan tumpukan +</i> </h4><br>  Saya <a href="https://habr.com/ru/post/221095/">sudah menulis</a> tentang penyortiran ini <a href="https://habr.com/ru/post/221095/">5 tahun yang lalu</a> .  Semuanya cukup sederhana - pertama dalam array Anda perlu membangun heap yang tidak bertambah sekali, dan kemudian melakukan yang sebaliknya - membangun yang tidak berkurang sekali.  Sebagai hasil dari operasi pertama, minimum akan berada di tempat pertama array, dan elemen-elemen kecil secara keseluruhan akan secara signifikan pindah ke awal.  Dalam kasus kedua, maksimum akan berada di tempat terakhir, dan elemen besar bermigrasi ke akhir array.  Secara umum, kita mendapatkan array yang hampir diurutkan dengan apa yang kita lakukan?  Benar - bereskan sisipan. <br><br><div style="text-align:center;"><img width="646" height="304" src="https://habrastorage.org/webt/uv/ed/ud/uvedudkaitwonk4bfuy2alkkvwk.gif"></div><br><br><hr><hr><hr><hr><hr><br><h2>  Referensi </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Merge-insertion_sort">Penggabungan-penyisipan</a> , <a href="https://en.wikipedia.org/wiki/Block_sort">Blok-gabungan</a> , <a href="https://en.wikipedia.org/wiki/Timsort">Tim</a> , <a href="https://en.wikipedia.org/wiki/Introsort">Introspektif</a> , <a href="https://en.wikipedia.org/wiki/Spreadsort">Spread</a> , <a href="https://en.wikipedia.org/wiki/Multi-key_quicksort">Multikey</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png">  <a href="https://github.com/Mrrl/GrailSort">Cawan</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/205290/">Cawan</a> , <a href="https://habr.com/ru/post/203032/">Meja Hash</a> , <a href="https://habr.com/ru/post/418355/">Hitung / Pohon</a> , <a href="https://habr.com/ru/post/221095/">J</a> <br><br><h3>  Artikel Seri: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Pertukaran macam</a> </li><li>  <a href="https://habr.com/post/415935/">Urutan Penyisipan</a> </li><li>  <a href="https://habr.com/post/422085/">Sortir berdasarkan pilihan</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Gabungkan Urusan</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Urutkan berdasarkan distribusi</a> </li><li>  <strong>Sortasi Hibrid</strong> <br><ul><li>  Sisipkan Gabung Sortir </li><li>  Sortir Tim </li><li>  Sortir Wiki </li><li>  Sortir Menyebar </li></ul><br></li></ul>  Dari semua penyortiran yang disajikan di sini, dalam aplikasi excel AlgoLab hanya untuk animasi Jsort saat ini diimplementasikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483786/">https://habr.com/ru/post/id483786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483774/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Januari 2020</a></li>
<li><a href="../id483776/index.html">Pengantar metode diferensial semantik dalam 5 menit</a></li>
<li><a href="../id483778/index.html">Minggu Keamanan 03: Prinsip-prinsip Laporan Bug yang Bertanggung Jawab</a></li>
<li><a href="../id483780/index.html">Apa itu Kendur dan Bagaimana Cara Kerjanya?</a></li>
<li><a href="../id483784/index.html">Cara membuat aplikasi multi-tenant dari aplikasi non-tenant</a></li>
<li><a href="../id483788/index.html">Negara kepulauan kecil menghasilkan berkat Twitch</a></li>
<li><a href="../id483790/index.html">Catatan dari penyedia IoT. Teknologi dan ekonomi LoRaWAN dalam pencahayaan perkotaan</a></li>
<li><a href="../id483794/index.html">Meninggalkan: mengapa Anda tidak mengambil kontroffer</a></li>
<li><a href="../id483796/index.html">Parameter Opsional dalam Repositori Data Musim Semi</a></li>
<li><a href="../id483798/index.html">Cara mengotomatiskan penulisan iklan di Google Ads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>