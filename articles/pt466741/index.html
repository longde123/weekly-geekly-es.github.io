<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç´ üôãüèΩ üñêüèæ O melhor √© o inimigo do bem üç† üôåüèæ ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© sobre como decidimos melhorar um pouco a ferramenta interna SelfTester, usada para verificar a qualidade do analisador PVS-Studio. A mel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O melhor √© o inimigo do bem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466741/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Quadro 12" align="left"></p>  Este artigo √© sobre como decidimos melhorar um pouco a ferramenta interna SelfTester, usada para verificar a qualidade do analisador PVS-Studio.  A melhoria foi simples e parecia √∫til, mas criou muitos problemas para n√≥s, e mais tarde resultou que seria melhor se n√£o o fiz√©ssemos. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Desenvolvemos e promovemos o analisador de c√≥digo est√°tico PVS-Studio para C, C ++, C # e Java.  Para verificar a qualidade do analisador, usamos ferramentas internas chamadas coletivamente de SelfTester.  Cada um dos idiomas suportados possui sua pr√≥pria vers√£o do SelfTester.  Isso se deve aos recursos dos testes e √© apenas mais conveniente.  Portanto, no momento, nossa empresa usa tr√™s ferramentas internas do SelfTester para C \ C ++, C # e Java, respectivamente.  A seguir, falarei sobre a vers√£o do Windows do SelfTester para projetos do Visual Studio em C \ C ++, chamando-a simplesmente de SelfTester.  Este testador foi o primeiro da linha de ferramentas internas, √© o mais avan√ßado e mais complexo de todos. <br><br>  Como o SelfTester funciona?  A id√©ia √© simples: pegue um conjunto de projetos de teste (usamos projetos reais de c√≥digo aberto) e analise-os usando o PVS-Studio.  Como resultado, um log de aviso do analisador √© gerado para cada projeto.  Este log √© comparado com o log de <i>refer√™ncia</i> para o mesmo projeto.  Ao comparar logs, o SelfTester cria um <i>log de</i> compara√ß√£o de logs em um formato conveniente para os desenvolvedores perceberem. <br><br>  Depois de estudar o di√°rio de bordo, o desenvolvedor conclui as mudan√ßas no comportamento do analisador: o n√∫mero e a natureza dos avisos, a velocidade da opera√ß√£o, h√° erros internos no analisador, etc.  Toda essa informa√ß√£o √© muito importante, pois permite entender o desempenho do analisador. <br><br>  Com base no log de compara√ß√£o de logs, o desenvolvedor faz altera√ß√µes no n√∫cleo do analisador (por exemplo, ao criar uma nova regra de diagn√≥stico), controlando imediatamente o efeito de suas edi√ß√µes.  Se o desenvolvedor n√£o tiver mais perguntas sobre a pr√≥xima compara√ß√£o dos logs, ele <i>far√°</i> do log de aviso <i>atual</i> do projeto uma <i>refer√™ncia</i> .  Caso contr√°rio, o trabalho continua. <br><br>  Portanto, a tarefa do SelfTester √© trabalhar com um conjunto de projetos de teste (a prop√≥sito, j√° existem mais de 120 deles para C / C ++).  Projetos para o pool s√£o selecionados como solu√ß√µes do Visual Studio.  Isso √© feito para testar adicionalmente o analisador em diferentes vers√µes do Visual Studio suportadas pelo analisador (do Visual Studio 2010 ao Visual Studio 2019 no momento). <br><br>  <i>Nota</i> : Separarei ainda mais os conceitos de <i>solu√ß√£o</i> e <i>projeto</i> , entendendo o projeto como parte da solu√ß√£o, como √© habitual no Visual Studio. <br><br>  A interface do SelfTester √© semelhante a: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Quadro 3"></div><br>  √Ä esquerda, h√° uma lista de solu√ß√µes, √† direita, os resultados dos testes para cada vers√£o do Visual Studio. <br><br>  As marcas cinza "N√£o suportado" indicam que a solu√ß√£o n√£o suporta a vers√£o selecionada do Visual Studio ou n√£o foi convertida para esta vers√£o.  Algumas solu√ß√µes no pool t√™m uma configura√ß√£o que indica a vers√£o espec√≠fica do Visual Studio para verificar.  Se a vers√£o n√£o for especificada, a solu√ß√£o ser√° atualizada para todas as vers√µes subseq√ºentes do Visual Studio.  Um exemplo dessa solu√ß√£o na captura de tela √© "smart_ptr_check.sln" (a verifica√ß√£o foi realizada para todas as vers√µes do Visual Studio). <br><br>  Uma marca verde ‚ÄúOK‚Äù indica que a pr√≥xima verifica√ß√£o n√£o revelou diferen√ßas no log de refer√™ncia.  Uma marca vermelha ‚ÄúDiff‚Äù indica diferen√ßas.  √â nesses r√≥tulos que o desenvolvedor deve prestar aten√ß√£o.  Para fazer isso, ele precisa clicar duas vezes no r√≥tulo desejado.  A solu√ß√£o selecionada ser√° aberta na vers√£o desejada do Visual Studio e uma janela com um log de aviso tamb√©m ser√° aberta l√°.  Os bot√µes de controle abaixo permitem reiniciar a an√°lise das decis√µes selecionadas ou de todas as decis√µes, atribuir o registro selecionado (ou todos de uma vez) aos padr√µes etc. <br><br>  Os resultados apresentados do trabalho do SelfTester s√£o sempre duplicados no relat√≥rio html (log de diferen√ßas). <br><br>  Al√©m da GUI, o SelfTester tamb√©m possui modos automatizados para execu√ß√£o durante compila√ß√µes noturnas.  No entanto, o padr√£o de uso usual √© lan√ßamentos repetidos pelo desenvolvedor durante o dia √∫til.  Portanto, uma das caracter√≠sticas importantes do SelfTester √© sua <i>velocidade</i> . <br><br>  Por que a velocidade √© importante: <br><br><ol><li>  Para executar durante os testes noturnos, o tempo necess√°rio para concluir cada etapa √© cr√≠tico.  Obviamente, quanto mais r√°pido os testes forem aprovados, melhor.  E o tempo m√©dio de opera√ß√£o do SelfTester atualmente excede 2 horas; </li><li>  Ao iniciar o SelfTester durante o dia, o desenvolvedor precisa esperar menos pelo resultado, o que aumenta a produtividade do trabalho. </li></ol><br>  Foi o desejo de acelerar o trabalho do SelfTester que causou as melhorias desta vez. <br><br><h2>  Multithreading no SelfTester </h2><br>  O SelfTester foi originalmente criado como um aplicativo multiencadeado com a capacidade de verificar v√°rias solu√ß√µes em paralelo.  A √∫nica limita√ß√£o era que voc√™ n√£o pode verificar simultaneamente a mesma solu√ß√£o para vers√µes diferentes do Visual Studio, pois muitas solu√ß√µes precisam ser atualizadas para determinadas vers√µes do Visual Studio antes de verificar.  Durante isso, as altera√ß√µes s√£o feitas diretamente nos <i>arquivos do</i> projeto <i>.vcxproj</i> , o que gera erros ao executar em paralelo. <br><br>  Para tornar o trabalho mais eficiente, o SelfTester usa um agendador de tarefas inteligente, que permite definir um valor estritamente limitado para encadeamentos paralelos e mant√™-lo. <br><br>  O planejador √© usado em dois n√≠veis.  O primeiro √© o n√≠vel da <i>solu√ß√£o</i> , usado para come√ßar a verificar a solu√ß√£o <i>.sln</i> usando o <i>utilit√°rio PVS-Studio_Cmd.exe</i> .  Dentro do <i>PVS-Studio_Cmd.exe</i> (no n√≠vel de verifica√ß√£o dos <i>arquivos de</i> c√≥digo-fonte), o mesmo agendador √© usado, mas com um <i>n√≠vel</i> diferente <i>de</i> configura√ß√£o <i>de paralelismo</i> . <br><br>  O grau de paralelismo √© um par√¢metro que realmente indica quantos threads paralelos devem ser executados simultaneamente.  Para valores de grau de paralelismo no n√≠vel de decis√£o e arquivos, os valores padr√£o de <i>quatro</i> e <i>oito</i> foram selecionados, respectivamente.  Portanto, o n√∫mero de threads paralelos para esta implementa√ß√£o deve ser igual a 32 (quatro solu√ß√µes testadas simultaneamente e oito arquivos).  Essa configura√ß√£o nos parece ideal para o analisador trabalhar em um processador de oito n√∫cleos. <br><br>  O desenvolvedor pode definir independentemente outros valores do grau de paralelismo, concentrando-se no desempenho do computador ou nas tarefas atuais.  Se ele n√£o definir esse par√¢metro, por padr√£o, o n√∫mero de processadores l√≥gicos do sistema ser√° selecionado. <br><br>  <i>Nota</i> : consideraremos ainda que o trabalho √© realizado com o grau padr√£o de valores de paralelismo. <br><br>  O <i>planejador LimitedConcurrencyLevelTaskScheduler √©</i> herdado de <i>System.Threading.Tasks.TaskScheduler</i> e refinado para fornecer o n√≠vel m√°ximo de paralelismo ao trabalhar na parte superior do <i>ThreadPool</i> .  Hierarquia de heran√ßa: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler</i> permite pausar tarefas, e <i>LimitedConcurrencyLevelTaskScheduler</i> , al√©m disso, fornece controle inteligente da fila de tarefas e agendamento de sua execu√ß√£o, levando em considera√ß√£o o grau de paralelismo, a quantidade de tarefas agendadas e outros fatores.  O planejador √© usado ao iniciar as tarefas <i>System.Threading.Tasks.Task</i> . <br><br><h2>  Pr√©-requisitos para melhorias </h2><br>  A implementa√ß√£o do trabalho descrito acima tem uma desvantagem: n√£o √© ideal quando se trabalha com solu√ß√µes de tamanhos diferentes.  E o tamanho das solu√ß√µes no pool de teste √© <i>muito</i> diferente: de 8 KB a 4 GB para o tamanho da pasta com a solu√ß√£o e de um a v√°rios milhares de arquivos de c√≥digo-fonte em cada um. <br><br>  O planejador enfileira as decis√µes simplesmente em ordem, sem nenhum componente intelectual.  Deixe-me lembr√°-lo de que, por padr√£o, mais de quatro solu√ß√µes n√£o podem ser verificadas ao mesmo tempo.  Se, no momento, quatro grandes solu√ß√µes est√£o sendo verificadas (o n√∫mero de arquivos em cada uma √© superior a oito), presume-se que estamos trabalhando com efici√™ncia, pois usamos o n√∫mero m√°ximo poss√≠vel de threads (32). <br><br>  Mas imagine uma situa√ß√£o bastante comum quando v√°rias pequenas solu√ß√µes s√£o testadas.  Por exemplo, uma solu√ß√£o √© grande e cont√©m 50 arquivos (um m√°ximo de oito threads estar√° envolvido) e as outras tr√™s cont√™m tr√™s, quatro e cinco arquivos cada.  Nesse caso, usamos apenas 20 threads (8 + 3 + 4 + 5).  Temos uma subutiliza√ß√£o do tempo do processador e uma diminui√ß√£o no desempenho geral. <br><br>  <i>Nota</i> : de fato, o gargalo, como regra, ainda √© o subsistema de disco, n√£o o processador. <br><br><h2>  Melhorias </h2><br>  Uma melhoria que se sugere nesse caso √© o ranking da lista de solu√ß√µes enviadas para verifica√ß√£o.  √â necess√°rio obter o uso ideal de um determinado n√∫mero de threads executados simultaneamente (32) enviando projetos com o n√∫mero "correto" de arquivos para verifica√ß√£o. <br><br>  Vejamos nosso exemplo novamente, quando quatro solu√ß√µes s√£o testadas com o seguinte n√∫mero de arquivos em cada uma: 50, 3, 4 e 5. Uma tarefa que verifica uma solu√ß√£o de <i>tr√™s</i> arquivos provavelmente funcionar√° em breve.  E, em vez disso, seria ideal adicionar uma solu√ß√£o na qual haja oito ou mais arquivos (para usar no m√°ximo oito fluxos dispon√≠veis para esta solu√ß√£o).  No total, usaremos j√° 25 threads (8 + <b>8</b> + 4 + 5).  Nada mal.  No entanto, sete threads ainda n√£o foram utilizados.  E aqui surge a id√©ia de outro refinamento, relacionada √† remo√ß√£o da restri√ß√£o em quatro threads para verifica√ß√£o de solu√ß√µes.  De fato, no exemplo acima, voc√™ pode adicionar n√£o uma, mas v√°rias solu√ß√µes, usando o m√°ximo poss√≠vel todos os 32 threads.  Vamos imaginar que temos mais duas solu√ß√µes, tr√™s e quatro arquivos cada.  A adi√ß√£o dessas tarefas fechar√° completamente a ‚Äúlacuna‚Äù nos encadeamentos n√£o utilizados e haver√° 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ). <br><br>  Eu acho que a ideia √© clara.  De fato, a implementa√ß√£o dessas melhorias tamb√©m n√£o exigiu muito esfor√ßo.  Tudo foi feito em um dia. <br><br>  Era necess√°rio refinar a classe de tarefa: heran√ßa de <i>System.Threading.Tasks.Task</i> e adicionar o campo "weight".  Para definir o peso da solu√ß√£o, um algoritmo simples √© usado: se o n√∫mero de arquivos na solu√ß√£o for menor que oito, o peso ser√° definido igual a esse valor (por exemplo, 5), se o n√∫mero de arquivos for maior ou igual a oito, o peso ser√° escolhido igual a oito. <br><br>  Tamb√©m era necess√°rio refinar o agendador: ensin√°-lo a escolher solu√ß√µes com o peso certo para atingir um valor m√°ximo de 32 threads.  Tamb√©m era necess√°rio permitir a aloca√ß√£o de mais de quatro threads para verifica√ß√£o simult√¢nea de solu√ß√µes. <br><br>  Por fim, foi necess√°ria uma etapa preliminar para analisar todas as solu√ß√µes de pool (avalia√ß√£o usando a API do MSBuild) para calcular e definir os pesos da solu√ß√£o (obter o n√∫mero de arquivos com c√≥digo fonte). <br><br><h2>  Resultado </h2><br>  Acho que, ap√≥s uma introdu√ß√£o t√£o longa, voc√™ j√° adivinhou que o resultado era zero. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Quadro 15"></div><br>  √â bom que as melhorias sejam simples e r√°pidas. <br><br>  Bem, agora, de fato, come√ßa a parte do artigo sobre "criou muitos problemas para n√≥s", e √© tudo. <br><br><h2>  Efeitos colaterais </h2><br>  Portanto, um resultado negativo tamb√©m √© um resultado.  Verificou-se que o n√∫mero de solu√ß√µes grandes no pool excede <i>significativamente</i> o n√∫mero de pequenas (menos de oito arquivos).  Nessas condi√ß√µes, as melhorias realizadas n√£o t√™m um efeito percept√≠vel, pois s√£o praticamente invis√≠veis: sua verifica√ß√£o leva um tempo microsc√≥pico em compara√ß√£o aos grandes projetos. <br><br>  No entanto, foi decidido deixar a revis√£o como "n√£o interferindo" e potencialmente √∫til.  Al√©m disso, o conjunto de solu√ß√µes de teste √© constantemente reabastecido; portanto, no futuro, talvez, a situa√ß√£o mude. <br><br>  E ent√£o ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Quadro 5"></div><br>  Um dos desenvolvedores reclamou da "queda" do SelfTester.  Bem, acontece.  Para evitar que esse erro seja perdido, um incidente interno (ticket) foi iniciado com o nome ‚ÄúExce√ß√£o ao trabalhar com o SelfTester‚Äù.  O erro ocorreu durante a avalia√ß√£o do projeto.  √â verdade que uma abund√¢ncia de janelas testemunhou o problema tamb√©m no manipulador de erros.  Mas isso foi rapidamente eliminado e, na semana seguinte, nada quebrou.  De repente, outro usu√°rio reclamou do SelfTester.  E, novamente, ao erro da avalia√ß√£o do projeto: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Quadro 8"></div><br>  Desta vez, a pilha continha informa√ß√µes mais √∫teis - um erro no formato xml.  Provavelmente, ao processar o arquivo de projeto <i>Proto_IRC.vcxproj</i> (sua representa√ß√£o em xml), algo aconteceu com o pr√≥prio arquivo, portanto, o <i>XmlTextReader</i> n√£o p√¥de process√°-lo. <br><br>  A presen√ßa de dois erros em um per√≠odo de tempo bastante curto nos levou a examinar mais de perto o problema.  Al√©m disso, como eu disse acima, o SelfTester √© usado ativamente pelos desenvolvedores. <br><br>  Para come√ßar, foi feita uma an√°lise do √∫ltimo local do outono.  Infelizmente, nada suspeito pode ser identificado.  Por precau√ß√£o, eles pediram aos desenvolvedores (usu√°rios do SelfTester) que estivessem alertas e relatassem poss√≠veis erros. <br><br>  Um ponto importante: o c√≥digo no qual o erro ocorreu foi reutilizado no SelfTester.  Inicialmente, √© usado para avaliar projetos no pr√≥prio analisador ( <i>PVS-Studio_Cmd.exe</i> ).  √â por isso que a aten√ß√£o ao problema aumentou.  No entanto, nenhuma queda semelhante ocorreu no analisador. <br><br>  Enquanto isso, um ticket sobre problemas com o SelfTester foi reabastecido com novos erros: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Quadro 9"></div><br>  E novamente <i>XmlException</i> .  Obviamente, em algum lugar h√° threads concorrentes trabalhando com arquivos de projeto de leitura e grava√ß√£o.  O SelfTester trabalha com projetos nos seguintes casos: <br><br><ol><li>  Avalia√ß√£o de projetos durante o c√°lculo preliminar de pesos de decis√£o: uma nova etapa que inicialmente despertou suspeitas; </li><li>  Atualizando projetos para as vers√µes necess√°rias do Visual Studio: executadas imediatamente antes da verifica√ß√£o (os projetos n√£o se cruzam de forma alguma) e n√£o devem afetar o trabalho; </li><li>  Avalia√ß√£o de projetos durante a verifica√ß√£o: mecanismo seguro de thread depurado, que foi reutilizado no <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Recuperando arquivos de projeto (substituindo arquivos <i>.vcxproj</i> modificados <i>pelos</i> arquivos de refer√™ncia originais) ao sair do SelfTester, pois os arquivos de projeto podem ser atualizados para as vers√µes necess√°rias do Visual Studio no processo: a etapa final, que tamb√©m n√£o afeta outros mecanismos. </li></ol><br>  Suspeita-se do novo c√≥digo adicionado para otimiza√ß√£o (c√°lculo de pesos).  Por√©m, o estudo desse c√≥digo mostrou que, se o usu√°rio iniciava a an√°lise imediatamente ap√≥s o in√≠cio do SelfTester, o testador sempre aguardava corretamente o final da avalia√ß√£o preliminar.  Este lugar parecia seguro. <br><br>  Mais uma vez, n√£o conseguimos identificar a fonte do problema. <br><br><h2>  Dor </h2><br>  Durante o m√™s seguinte, o SelfTester continuou a cair de tempos em tempos.  O ticket foi reabastecido com dados, mas n√£o estava claro o que fazer com esses dados.  A maioria das falhas ocorreu com o mesmo <i>XmlException</i> .  Ocasionalmente, havia algo mais, mas no mesmo c√≥digo reutilizado do <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Quadro 1"></div><br>  Por tradi√ß√£o, n√£o s√£o impostos requisitos t√£o altos √†s ferramentas internas; portanto, o trabalho com erros do SelfTester foi realizado de forma residual.  De tempos em tempos, pessoas diferentes se conectavam (durante todo o per√≠odo do incidente, seis pessoas trabalhavam no problema, incluindo dois estagi√°rios).  No entanto, a tarefa teve que ser distra√≠da. <br><br>  <i>Nosso primeiro erro.</i>  De fato, aqui j√° era poss√≠vel resolver o problema de uma vez por todas.  Como  Ficou claro que o erro foi causado por uma nova otimiza√ß√£o.  Afinal, antes disso, tudo funcionava bem e o c√≥digo reutilizado obviamente n√£o podia ser t√£o ruim.  Al√©m disso, essa otimiza√ß√£o n√£o trouxe nenhum benef√≠cio.  Ent√£o, o que tinha que ser feito?  <i>Remova essa otimiza√ß√£o</i> <b>.</b>  Como voc√™ sabe, isso n√£o foi feito.  Continuamos trabalhando em um problema que n√≥s mesmos criamos.  A busca continuou pela resposta √† pergunta: "COMO ???"  Como cai?  No entanto, parece estar escrito corretamente. <br><br>  <i>Nosso segundo erro.</i>  <i>Outras pessoas</i> estavam <i>conectadas</i> √† solu√ß√£o do problema.  Um erro muito, muito grande.  Infelizmente, isso n√£o apenas n√£o resolveu o problema, mas tamb√©m foram gastos recursos adicionais.  Sim, novas pessoas trouxeram novas id√©ias, mas, para sua implementa√ß√£o, levou (absolutamente desperdi√ßado) muito tempo de trabalho.  Em um certo est√°gio, os programas de teste foram escritos (pelos mesmos estagi√°rios) que simulam a avalia√ß√£o do mesmo projeto em diferentes threads com modifica√ß√£o paralela do projeto em outro thread.  N√£o ajudou.  Al√©m do que j√° sab√≠amos antes, a API do MSBuild √© segura para threads por dentro, eles n√£o descobriram nada de novo.  E no SelfTester, um mini-despejo foi adicionado quando um <i>XmlException foi</i> lan√ßado.  Ent√£o tudo isso algu√©m estremeceu, horror.  Discuss√µes foram realizadas, muitas outras coisas desnecess√°rias foram feitas. <br><br>  <i>Finalmente, nosso terceiro erro</i> .  Voc√™ sabe quanto tempo se passou desde que o problema com o SelfTester surgiu e at√© que ele foi resolvido?  Embora n√£o, conte-se.  O incidente foi criado em 17/09/2018 e encerrado em 20/02/2019, e existem mais de 40 (quarenta!) Mensagens l√°.  Gente, isso √© muito tempo!  N√≥s <i>nos permitimos</i> fazer TI <i>por</i> cinco meses.  Ao mesmo tempo (em paralelo), est√°vamos empenhados em oferecer suporte ao Visual Studio 2019, adicionando a linguagem Java, come√ßando a implementar o padr√£o MISRA C / C ++, aprimorando o analisador C #, participando ativamente de confer√™ncias, escrevendo v√°rios artigos, etc.  E todos esses trabalhos n√£o receberam o tempo dos desenvolvedores devido ao erro est√∫pido do SelfTester. <br><br>  Cidad√£os, aprendam com nossos erros e nunca fazem isso.  E n√≥s n√£o vamos. <br><br>  Eu tenho tudo <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Quadro 17"></div><br>  Claro, isso √© uma piada, e vou lhe dizer qual foi o problema com o SelfTester :) <br><br><h2>  Bingo! </h2><br>  Felizmente, entre n√≥s havia uma pessoa com a consci√™ncia menos nublada (meu colega Sergey Vasiliev), que apenas olhou o problema de um √¢ngulo completamente diferente (e tamb√©m teve um pouco de sorte).  E se o SelfTester estiver realmente bom e os projetos quebrarem algo do lado de fora?  Paralelamente ao SelfTester, geralmente nada foi iniciado; em alguns casos, controlamos rigorosamente o tempo de execu√ß√£o.  Nesse caso, esse "algo" s√≥ poderia ser o pr√≥prio SelfTester, mas outra inst√¢ncia. <br><br>  Ao sair do SelfTester, o fluxo de restaura√ß√£o de arquivos de projeto dos padr√µes continua funcionando por algum tempo.  Neste ponto, voc√™ pode reiniciar o testador.  A prote√ß√£o contra a execu√ß√£o de v√°rias inst√¢ncias do SelfTester ao mesmo tempo foi adicionada <i>posteriormente</i> e agora se parece com isso: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Quadro 16"></div><br>  Mas ent√£o ela se foi. <br><br>  Incrivelmente, por quase meio ano de tormento, ningu√©m prestou aten√ß√£o nisso.  Restaurar projetos a partir de padr√µes √© um procedimento em segundo plano r√°pido o suficiente, mas, infelizmente, n√£o √© r√°pido o suficiente para n√£o interferir na reinicializa√ß√£o do SelfTester.  E o que acontece na inicializa√ß√£o?  √â isso mesmo, calculando pesos de decis√£o.  Um processo substitui arquivos <i>.vcxproj</i> , enquanto outro tenta l√™-los.  Ol√°, <i>XmlException</i> . <br><br>  Sergey descobriu tudo isso quando adicionou ao testador a capacidade de mudar para o modo de trabalhar com outro conjunto de logs padr√£o.  A necessidade disso surgiu ap√≥s a adi√ß√£o do conjunto de regras MISRA ao analisador.  Voc√™ pode alternar diretamente na interface, enquanto o usu√°rio v√™ a janela: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Quadro 14"></div><br>  Ap√≥s o que o SelfTester √© <i>reiniciado</i> .  Bem, antes, aparentemente, os usu√°rios de alguma maneira imitaram o problema, iniciando o testador novamente. <br><br><h2>  Discuss√£o e conclus√µes </h2><br>  Obviamente, exclu√≠mos ou desativamos a otimiza√ß√£o criada anteriormente.  Al√©m disso, era muito mais f√°cil do que fazer algum tipo de sincroniza√ß√£o entre o restante do testador.  E tudo come√ßou a funcionar muito bem, como antes.  E como uma medida adicional, a prote√ß√£o descrita acima contra o lan√ßamento simult√¢neo do testador foi adicionada. <br><br>  Eu j√° escrevi acima sobre nossos principais erros durante a busca do problema, de modo que a auto-flagela√ß√£o √© suficiente.  Tamb√©m somos pessoas e, portanto, estamos enganados.  √â importante aprender com seus erros e tirar conclus√µes.  As conclus√µes aqui s√£o bastante simples: <br><br><ul><li>  √â necess√°rio rastrear e avaliar o crescimento da complexidade da tarefa; </li><li>  Pare no tempo; </li><li>  Tente analisar o problema de maneira mais ampla, pois com o tempo a vis√£o fica "borrada" e o √¢ngulo de vis√£o √© reduzido; </li><li>  N√£o tenha medo de excluir c√≥digo antigo ou desnecess√°rio. </li></ul><br>  Agora, com certeza - √© isso.  Obrigado pela leitura.  Para todo o c√≥digo sem esperan√ßa! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O melhor √© o inimigo do bem</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466741/">https://habr.com/ru/post/pt466741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466731/index.html">Extravag√¢ncia. Setembro sobe</a></li>
<li><a href="../pt466733/index.html">Bem-vindo ao DINS Java EVENTO 18 de setembro</a></li>
<li><a href="../pt466735/index.html">Uma maneira f√°cil de criar um alerta de voz no sistema de automa√ß√£o residencial (‚ÄúSmart Home‚Äù)</a></li>
<li><a href="../pt466737/index.html">Por que a rede social do Google+ falhou</a></li>
<li><a href="../pt466739/index.html">O melhor √© o inimigo do bem</a></li>
<li><a href="../pt466745/index.html">O primeiro local de trabalho ou como come√ßar a desenvolver API no Node.js</a></li>
<li><a href="../pt466747/index.html">Desenvolvedores Mitap iOS na Redmadrobot</a></li>
<li><a href="../pt466753/index.html">Administra√ß√£o de rede r√°pida e eficiente - Network MACMonitor</a></li>
<li><a href="../pt466755/index.html">O computador vai te deixar gostoso</a></li>
<li><a href="../pt466757/index.html">O primeiro mitap do Flutter em S√£o Petersburgo - 26 de setembro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>