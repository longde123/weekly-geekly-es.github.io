<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 🤾🏼 💷 DynamicData: Mengubah koleksi, pola desain MVVM, dan ekstensi reaktif 😂 👩🏾‍🏫 🥦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bulan Februari 2019, ReactiveUI 9 , kerangka kerja lintas platform untuk membangun aplikasi GUI pada platform Microsoft .NET, dirilis. ReactiveUI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DynamicData: Mengubah koleksi, pola desain MVVM, dan ekstensi reaktif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445098/"> Pada bulan Februari 2019, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI 9</a> , kerangka kerja lintas platform untuk membangun aplikasi GUI pada platform Microsoft .NET, dirilis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI</a> adalah alat untuk mengintegrasikan ekstensi reaktif dengan pola desain MVVM.  Kenalan dengan kerangka kerja dapat dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel tentang Habré</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari halaman depan dokumentasi</a> .  Pembaruan ReactiveUI 9 mencakup banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbaikan dan peningkatan</a> , tetapi mungkin perubahan yang paling menarik dan signifikan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi yang erat dengan kerangka kerja DynamicData</a> , yang memungkinkan bekerja dengan mengubah koleksi dengan gaya reaktif.  Mari kita coba mencari tahu dalam kasus apa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berguna</a> dan bagaimana kerangka reaktif yang kuat ini diatur di dalam! <br><a name="habracut"></a><br><h3>  Latar belakang </h3><br>  Pertama, kita mendefinisikan berbagai tugas yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipecahkan DynamicData</a> dan mencari tahu mengapa alat standar untuk bekerja dengan mengubah set data dari <code>System.Collections.ObjectModel</code> namespace tidak cocok untuk kita. <br><br>  Template MVVM, seperti yang Anda ketahui, melibatkan pembagian tanggung jawab antara lapisan model, presentasi, dan model presentasi aplikasi.  Lapisan model diwakili oleh entitas domain dan layanan, dan tidak tahu apa-apa tentang model presentasi.  Lapisan model merangkum seluruh logika aplikasi kompleks, dan model presentasi mendelegasikan operasi model, memberikan tampilan akses ke informasi tentang keadaan aplikasi saat ini melalui properti yang dapat diamati, perintah, dan koleksi.  Alat standar untuk bekerja dengan mengubah properti adalah antarmuka <code>INotifyPropertyChanged</code> , <code>INotifyPropertyChanged</code> untuk bekerja dengan tindakan pengguna, dan <code>INotifyCollectionChanged</code> mengimplementasikan koleksi dan mengimplementasikan <code>ObservableCollection</code> dan <code>ReadOnlyObservableCollection</code> . <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/504/c83/ab0/504c83ab04fe2e2d1eed037317b8aa2c.jpg"><br><br>  Implementasi <code>INotifyPropertyChanged</code> dan <code>ICommand</code> biasanya tetap pada hati nurani pengembang dan kerangka kerja MVVM yang digunakan, tetapi penggunaan <code>ObservableCollection</code> memberlakukan sejumlah batasan pada kami!  Misalnya, kami tidak dapat mengubah koleksi dari utas latar belakang tanpa <code>Dispatcher.Invoke</code> Panggilan atau panggilan serupa, dan ini bisa berguna jika bekerja dengan array data yang beberapa operasi latar belakang disinkronkan dengan server.  Perlu dicatat bahwa dalam MVVM idiomatik, lapisan model tidak perlu tahu tentang arsitektur aplikasi GUI yang digunakan, dan kompatibel dengan model dari MVC atau MVP, dan inilah sebabnya banyak <code>Dispatcher.Invoke</code> memungkinkan akses ke kontrol antarmuka pengguna dari latar belakang thread running dalam layanan domain, melanggar prinsip berbagi tanggung jawab antara lapisan aplikasi. <br><br>  Tentu saja, dalam layanan domain akan dimungkinkan untuk mendeklarasikan suatu peristiwa, dan sebagai argumen dari suatu peristiwa, memberikan potongan dengan data yang diubah.  Kemudian berlangganan acara tersebut, bungkus <code>Dispatcher.Invoke</code> Panggilan di antarmuka sehingga tidak tergantung pada kerangka GUI yang digunakan, pindah <code>Dispatcher.Invoke</code> model presentasi dan ubah <code>ObservableCollection</code> yang Dapat <code>ObservableCollection</code> kebutuhan, namun ada cara yang jauh lebih sederhana dan lebih elegan untuk menyelesaikan berbagai tugas yang ditunjukkan tanpa harus menulis sepeda .  Ayo mulai belajar! <br><br><h2>  Ekstensi reaktif.  Kelola aliran data </h2><br>  Untuk pemahaman lengkap tentang abstraksi yang diperkenalkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> dan prinsip-prinsip bekerja dengan mengubah dataset reaktif, mari kita ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu pemrograman reaktif dan bagaimana menerapkannya dalam konteks platform Microsoft .NET dan pola desain MVVM</a> .  Cara untuk mengatur interaksi antar komponen program dapat bersifat interaktif dan reaktif.  Dalam interaksi interaktif, fungsi konsumen secara sinkron menerima data dari fungsi penyedia (pendekatan berbasis-tarik, <code>T</code> , <code>IEnumerable</code> ), dan dalam interaksi reaktif, fungsi konsumen secara tidak sinkron mengirimkan data ke fungsi konsumen (pendekatan berbasis-push, <code>Task</code> , <code>IObservable</code> ). <br><br><img width="500" src="https://habrastorage.org/webt/mb/ts/mj/mbtsmjfyhjqeeb4tv8ynotvkdms.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman reaktif</a> adalah pemrograman menggunakan aliran data asinkron, dan ekstensi reaktif adalah kasus khusus dari implementasinya, berdasarkan pada <code>IObserver</code> dan <code>IObserver</code> dari namespace Sistem, yang mendefinisikan sejumlah operasi mirip LINQ pada antarmuka <code>IObservable</code> , yang disebut LINQ over Observable.  Ekstensi reaktif mendukung .NET Standard dan berfungsi di mana pun platform Microsoft .NET berfungsi. <br><br><img src="https://habrastorage.org/webt/ue/qe/80/ueqe80neq0ufivj-bq5hipdrldo.gif"><br><br>  Kerangka kerja ReactiveUI mengundang pengembang aplikasi untuk mengambil keuntungan dari implementasi reaktif <code>ICommand</code> dan <code>INotifyPropertyChanged</code> , menyediakan alat yang kuat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ReactiveCommand&lt;TIn, TOut&gt;</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>WhenAnyValue</code></a> .  <code>WhenAnyValue</code> memungkinkan <code>WhenAnyValue</code> untuk mengkonversi properti kelas yang mengimplementasikan INotifyPropertyChanged menjadi aliran peristiwa tipe <code>IObservable&lt;T&gt;</code> , yang menyederhanakan penerapan properti dependen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { [Reactive] <span class="hljs-comment"><span class="hljs-comment">//  ReactiveUI.Fody,  // -  // OnPropertyChanged   Name. public string Name { get; set; } public ExampleViewModel() { //  OnPropertyChanged("Name"). this.WhenAnyValue(x =&gt; x.Name) //   IObservable&lt;string&gt; .Subscribe(Console.WriteLine); } }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ReactiveCommand&lt;TIn, TOut&gt;</code></a> memungkinkan Anda untuk bekerja dengan perintah tersebut, seperti kejadian tipe <code>IObservable&lt;TOut&gt;</code> , yang diterbitkan kapan pun perintah menyelesaikan eksekusi.  Juga, perintah apa pun memiliki properti <code>IObservable&lt;Exception&gt;</code> tipe <code>IObservable&lt;Exception&gt;</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// ReactiveCommand&lt;Unit, int&gt; var command = ReactiveCommand.Create(() =&gt; 42); command //   IObservable&lt;int&gt; .Subscribe(Console.WriteLine); command .ThrownExceptions //   IObservable&lt;Exception&gt; .Select(exception =&gt; exception.Message) //   IObservable&lt;string&gt; .Subscribe(Console.WriteLine); command.Execute().Subscribe(); // : 42</span></span></code> </pre><br>  Selama ini kami bekerja dengan <code>IObservable&lt;T&gt;</code> , seperti peristiwa yang menerbitkan nilai baru tipe <code>T</code> setiap kali keadaan objek yang dipantau berubah.  Sederhananya, <code>IObservable&lt;T&gt;</code> adalah aliran peristiwa, urutan membentang dari waktu ke waktu. <br><br>  Tentu saja, kami dapat dengan mudah dan alami bekerja dengan koleksi - setiap kali koleksi berubah, publikasikan koleksi baru dengan elemen yang diubah.  Dalam hal ini, nilai yang dipublikasikan akan bertipe <code>IEnumerable&lt;T&gt;</code> atau lebih terspesialisasi, dan event itu sendiri akan bertipe <code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> .  Tetapi, seperti yang ditunjukkan oleh pembaca yang berpikir kritis, ini penuh dengan masalah serius dengan kinerja aplikasi, terutama jika tidak ada selusin elemen dalam koleksi kami, tetapi seratus, atau bahkan beberapa ribu! <br><br><h2>  Pengantar DynamicData </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> adalah perpustakaan yang memungkinkan Anda menggunakan kekuatan penuh ekstensi reaktif saat bekerja dengan koleksi.  Ekstensi reaktif di luar kotak tidak menyediakan cara optimal untuk bekerja dengan mengubah kumpulan data, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas DynamicData</a> adalah memperbaikinya.  Di sebagian besar aplikasi, ada kebutuhan untuk memperbarui koleksi secara dinamis - biasanya, koleksi diisi dengan beberapa elemen ketika aplikasi dimulai, dan kemudian diperbarui secara tidak sinkron, menyinkronkan informasi dengan server atau database.  Aplikasi modern cukup kompleks, dan seringkali ada kebutuhan untuk membuat proyeksi koleksi - filter, ubah atau sortir elemen.  DynamicData dirancang hanya untuk menghilangkan kode yang sangat rumit yang kita perlukan untuk mengelola set data yang berubah secara dinamis.  Alat ini dikembangkan dan difinalisasi secara aktif, dan sekarang lebih dari 60 operator untuk bekerja dengan koleksi didukung. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/hn/7j/v3/hn7jv3fv1qgfxlhqrd9g6dokkao.gif"></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> bukan merupakan implementasi alternatif dari <code>ObservableCollection&lt;T&gt;</code> .  Arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> didasarkan terutama pada konsep-konsep pemrograman khusus domain.  Ideologi penggunaan didasarkan pada fakta bahwa Anda mengelola beberapa sumber data, kumpulan yang dapat diakses oleh kode yang bertanggung jawab untuk menyinkronkan dan mengubah data.  Selanjutnya, Anda menerapkan sejumlah operator ke sumber, yang dengannya Anda dapat mengubah data secara deklaratif, tanpa perlu secara manual membuat dan memodifikasi koleksi lainnya.  Bahkan, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> Anda memisahkan operasi baca dan tulis, dan Anda hanya bisa membaca dengan cara reaktif - karena itu, koleksi yang diwarisi akan selalu disinkronkan dengan sumbernya. <br><br>  Alih-alih <code>IObservable&lt;T&gt;</code> klasik, DynamicData mendefinisikan operasi pada <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;&gt;</code> dan <code>IObservable&lt;IChangeSet&lt;TValue, TKey&gt;&gt;</code> , di mana <code>IChangeSet</code> adalah bongkahan berisi informasi tentang perubahan koleksi - jenis perubahan dan elemen yang terpengaruh.  Pendekatan ini dapat secara signifikan meningkatkan kinerja kode untuk bekerja dengan koleksi yang ditulis dengan gaya reaktif.  Pada saat yang sama, <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> selalu dapat diubah menjadi <code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> biasa <code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> jika menjadi perlu untuk memproses semua elemen koleksi sekaligus.  Jika kedengarannya rumit - jangan khawatir, dari contoh kode semuanya akan menjadi jelas dan transparan! <br><br><h2>  Contoh DynamicData </h2><br>  Mari kita lihat serangkaian contoh untuk lebih memahami bagaimana DynamicData bekerja, perbedaannya dengan <code>System.Reactive</code> dan tugas apa yang dapat diselesaikan oleh pengembang perangkat lunak aplikasi biasa dengan GUI.  Mari kita mulai dengan contoh komprehensif yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diposting oleh DynamicData di GitHub</a> .  Dalam contoh, sumber data adalah <code>SourceCache&lt;Trade, long&gt;</code> , yang berisi kumpulan transaksi.  Tugasnya adalah hanya menampilkan transaksi aktif, mengubah model menjadi objek proxy, mengurutkan koleksi. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    System.Collections.ObjectModel, //       . ReadOnlyObservableCollection&lt;TradeProxy&gt; list; //   ,   . //   Add, Remove, Insert   . var source = new SourceCache&lt;Trade, long&gt;(trade =&gt; trade.Id); var cancellation = source //      . //   IObservable&lt;IChangeSet&lt;Trade, long&gt;&gt; .Connect() //       . .Filter(trade =&gt; trade.Status == TradeStatus.Live) //    -. //   IObservable&lt;IChangeSet&lt;TrandeProxy, long&gt;&gt; .Transform(trade =&gt; new TradeProxy(trade)) //    . .Sort(SortExpressionComparer&lt;TradeProxy&gt; .Descending(trade =&gt; trade.Timestamp)) //  GUI    . .ObserveOnDispatcher() //    - //    System.Collections.ObjectModel. .Bind(out list) // ,       //    . .DisposeMany() .Subscribe();</span></span></code> </pre><br>  Dalam contoh di atas, ketika Anda mengubah <code>SourceCache</code> , yang merupakan sumber data, <code>ReadOnlyObservableCollection</code> juga <code>ReadOnlyObservableCollection</code> berubah.  Dalam hal ini, saat menghapus elemen dari koleksi, metode <code>Dispose</code> akan dipanggil, koleksi akan selalu diperbarui hanya dalam aliran GUI dan tetap diurutkan dan difilter.  Keren, tidak ada <code>Dispatcher.Invoke</code> Kode <code>Dispatcher.Invoke</code> dan rumit! <br><br><h2>  SourceList dan Sumber Data SourceCache </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> menyediakan dua koleksi khusus yang dapat digunakan sebagai sumber data yang bisa berubah.  Koleksi ini adalah tipe <code>SourceList</code> dan <code>SourceCache&lt;TObject, TKey&gt;</code> .  Disarankan untuk menggunakan <code>SourceCache</code> setiap kali <code>TObject</code> memiliki kunci unik, jika tidak gunakan <code>SourceList</code> .  Objek-objek ini menyediakan .NET developer API untuk memodifikasi data - <code>Add</code> , <code>Remove</code> , <code>Insert</code> dan sejenisnya.  Untuk mengonversi sumber data ke <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> atau <code>IObservable&lt;IChangeSet&lt;T, TKey&gt;&gt;</code> , gunakan operator <code>.Connect()</code> .  Misalnya, jika Anda memiliki layanan yang memperbarui koleksi elemen di latar belakang, Anda dapat dengan mudah menyinkronkan daftar elemen-elemen ini dengan GUI, tanpa <code>Dispatcher.Invoke</code> dan ekses arsitektur: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundService</span></span> : <span class="hljs-title"><span class="hljs-title">IBackgroundService</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . private readonly SourceList&lt;Trade&gt; _trades; //     . //  ,     , //    Publish()  Rx. public IObservable&lt;IChangeSet&lt;Trade&gt;&gt; Connect() =&gt; _trades.Connect(); public BackgroundService() { _trades = new SourceList&lt;Trade&gt;(); _trades.Add(new Trade()); //    ! //    . } }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> menggunakan tipe .NET bawaan untuk memetakan data ke dunia luar.  Menggunakan operator DynamicData yang kuat, kita dapat mengubah <code>IObservable&lt;IChangeSet&lt;Trade&gt;&gt;</code> menjadi <code>ReadOnlyObservableCollection</code> model tampilan kami. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TradesViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; _trades; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; Trades =&gt; _trades; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TradesViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBackgroundService background</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,  ,  //     System.Collections.ObjectModel. background.Connect() .Transform(x =&gt; new TradeVm(x)) .ObserveOn(RxApp.MainThreadScheduler) .Bind(out _trades) .DisposeMany() .Subscribe(); } }</span></span></code> </pre><br>  Selain <code>Transform</code> , <code>Filter</code> dan <code>Sort</code> , DynamicData mencakup sejumlah operator lain, mendukung pengelompokan, operasi logis, perataan koleksi, menggunakan fungsi agregasi, tidak termasuk elemen identik, elemen penghitungan, dan bahkan virtualisasi pada level model representasi.  Baca lebih lanjut tentang semua operator di <a href="">proyek README di GitHub</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jy/6-/4a/jy6-4azw__6rou9alucffpjhkrq.gif"></a> <br><br><h2>  Koleksi berulir tunggal dan ubah pelacakan </h2><br>  Selain <code>SourceList</code> dan <code>SourceCache</code> , pustaka DynamicData juga menyertakan implementasi single-threaded dari koleksi yang bisa diubah - <code>ObservableCollectionExtended</code> .  Untuk menyinkronkan dua koleksi di model tampilan Anda, deklarasikan satu sebagai <code>ObservableCollectionExtended</code> dan yang lainnya sebagai <code>ReadOnlyObservableCollection</code> dan gunakan operator <code>ToObservableChangeSet</code> , yang berperilaku sama seperti <code>Connect</code> tetapi dirancang untuk bekerja dengan <code>ObservableCollection</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   . ReadOnlyObservableCollection&lt;TradeVm&gt; _derived; //    -. var source = new ObservableCollectionExtended&lt;Trade&gt;(); source.ToObservableChangeSet(trade =&gt; trade.Key) .Transform(trade =&gt; new TradeProxy(trade)) .Filter(proxy =&gt; proxy.IsChecked) .Bind(out _derived) .Subscribe();</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> juga mendukung pelacakan perubahan di kelas yang mengimplementasikan antarmuka <code>INotifyPropertyChanged</code> .  Misalnya, jika Anda ingin diberitahu tentang perubahan koleksi setiap kali properti item berubah, gunakan <code>AutoRefresh</code> dan berikan pemilih properti yang diinginkan dengan argumen.  <code>AutoRefesh</code> dan operator DynamicData lainnya akan memungkinkan Anda untuk dengan mudah dan alami memvalidasi sejumlah besar formulir dan sub-formulir yang ditampilkan di layar! <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  IObservable&lt;bool&gt; var isValid = databases .ToObservableChangeSet() //      IsValid. .AutoRefresh(database =&gt; database.IsValid) //       . .ToCollection() // ,    . .Select(x =&gt; x.All(y =&gt; y.IsValid)); //   ReactiveUI, IObservable&lt;bool&gt; //     ObservableAsProperty. _isValid = isValid .ObserveOn(RxApp.MainThreadScheduler) .ToProperty(this, x =&gt; x.IsValid);</span></span></code> </pre><br>  Berdasarkan fungsionalitas DynamicData, Anda dapat dengan cepat membuat antarmuka yang cukup kompleks - ini terutama berlaku untuk sistem yang menampilkan sejumlah besar data waktu nyata, sistem pengiriman pesan instan, dan sistem pemantauan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/98/nh/ws/98nhws7gl4yzk8kgcovbpvvozoi.gif"></a> <br><br><h2>  Kesimpulan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekstensi reaktif</a> adalah alat yang ampuh yang memungkinkan Anda bekerja secara deklaratif dengan data dan antarmuka pengguna, menulis kode portabel dan didukung, dan memecahkan masalah rumit dengan cara yang sederhana dan elegan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI</a> memungkinkan pengembang .NET untuk secara erat mengintegrasikan ekstensi reaktif ke dalam proyek mereka menggunakan arsitektur MVVM dengan memberikan implementasi reaktif dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>INotifyPropertyChanged</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ICommand</code></a> , sementara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> menangani sinkronisasi pengumpulan dengan menerapkan <code>INotifyCollectionChanged</code> , memperluas kemampuan ekstensi reaktif dan menjaga kinerja. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pustaka</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> kompatibel dengan kerangka kerja GUI paling populer dari platform .NET, termasuk Windows Presentation Foundation, Universal Windows Platform, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Avalonia</a> , Xamarin. Android, Formulir Xamarin, Xamarin.iOS.  Anda dapat mulai mempelajari DynamicData dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dokumentasi ReactiveUI yang sesuai</a> .  Pastikan juga untuk memeriksa proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData Snippets</a> , yang berisi contoh penggunaan DynamicData untuk semua kesempatan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445098/">https://habr.com/ru/post/id445098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445086/index.html">Misi Lunar "Bereshit" - video pertama dari kamera onboard dan foto baru di luar angkasa</a></li>
<li><a href="../id445088/index.html">Apakah petualangan dalam hidup Anda lebih menarik daripada di game komputer?</a></li>
<li><a href="../id445090/index.html">Akankah YouTube tetap seperti yang kita ketahui?</a></li>
<li><a href="../id445092/index.html">HATEOAS Masalah Tautan Dalam</a></li>
<li><a href="../id445094/index.html">Akses terpusat ke tanda tangan digital dan kunci perlindungan elektronik lainnya menggunakan perangkat keras USB melalui IP</a></li>
<li><a href="../id445100/index.html">Anycubic: Foton S, 4Max Pro, dan penggantian nama besar</a></li>
<li><a href="../id445102/index.html">Flash-animasi di Unity3D dari awal. Bagian satu, liris</a></li>
<li><a href="../id445104/index.html">Sejarah singkat merek audio Klipsch</a></li>
<li><a href="../id445106/index.html">Round table: Teknologi aditif sebagai alternatif untuk manufaktur tradisional</a></li>
<li><a href="../id445108/index.html">Tidak satu pun Falcon - proyek ESA dan ULA yang dapat digunakan kembali yang berbeda secara fundamental</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>