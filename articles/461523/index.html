<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèª üôâ üë©üèø‚Äçü§ù‚Äçüë®üèª WAL en PostgreSQL: 4. Configuraci√≥n de registro üíå üç° ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entonces, nos familiarizamos con el dispositivo de la memoria cach√© del b√∫fer y, usando su ejemplo, nos dimos cuenta de que cuando el contenido de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL en PostgreSQL: 4. Configuraci√≥n de registro</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/">  Entonces, nos familiarizamos con el dispositivo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoria cach√©</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer</a> y, usando su ejemplo, nos dimos cuenta de que cuando el contenido de la RAM desaparece en caso de falla, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> requiere un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro de pregrabaci√≥n</a> para la recuperaci√≥n.  El tama√±o de los archivos de registro necesarios y el tiempo de recuperaci√≥n est√°n limitados debido a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">punto de control</a> ejecutado peri√≥dicamente. <br><br>  En art√≠culos anteriores, ya hemos analizado un n√∫mero bastante grande de configuraciones importantes, de una forma u otra relacionadas con la revista.  En este art√≠culo (el √∫ltimo de esta serie), consideraremos aquellos problemas de ajuste que a√∫n no se han discutido: los niveles de registro y su prop√≥sito, as√≠ como la confiabilidad y el rendimiento del registro. <br><br><h1>  Niveles de registro </h1><br>  El prop√≥sito principal del registro de pregrabaci√≥n es proporcionar recuperaci√≥n despu√©s de una falla.  Pero, si a√∫n tiene que llevar un diario, puede adaptarse para otras tareas, agregando una cierta cantidad de informaci√≥n adicional.  Hay varios niveles de registro.  Se establecen mediante el par√°metro <em>wal_level</em> y se organizan de modo que el registro de cada nivel siguiente incluya todo lo que se incluye en el registro del nivel anterior, m√°s algo nuevo. <br><a name="habracut"></a><br><h2>  M√≠nimo </h2><br>  El nivel m√≠nimo posible se establece mediante el valor <em>wal_level</em> = m√≠nimo y garantiza solo la recuperaci√≥n despu√©s de una falla.  Para ahorrar espacio, las operaciones relacionadas con el procesamiento de datos en masa (como CREATE TABLE AS SELECT o CREATE INDEX) no se registran.  En cambio, los datos necesarios se escriben inmediatamente en el disco, y se agrega un nuevo objeto al directorio del sistema y se hace visible cuando se confirma la transacci√≥n.  Si ocurre una falla durante la operaci√≥n, los datos ya registrados permanecen invisibles y no violan la consistencia.  Si la falla ocurre despu√©s de que se completa la operaci√≥n, todo lo necesario ya ha llegado al disco y no necesita registrarse. <br><br>  A ver  Primero, establezca el nivel requerido (para esto tambi√©n deber√° cambiar otro par√°metro: <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Tenga en cuenta que cambiar el nivel requiere un reinicio del servidor. <br><br>  Recuerde la posici√≥n actual en el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Ahora creemos la tabla (CREAR TABLA COMO SELECCIONAR) y escriba nuevamente la posici√≥n en el registro.  La cantidad de datos seleccionados por la instrucci√≥n SELECT no importa en este caso, por lo que nos limitaremos a una l√≠nea. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  Con la utilidad familiar pg_waldump, veamos las entradas de registro. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Algunos detalles, por supuesto, pueden diferir de un lanzamiento a otro, pero en este caso, esto es lo que sucedi√≥.  La entrada del administrador Heap2 se refiere a la limpieza, aqu√≠ se trata de una limpieza en la p√°gina de una de las tablas del cat√°logo del sistema (los objetos del sistema se distinguen f√°cilmente a simple vista por el n√∫mero "corto" en rel): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Luego hay un registro sobre c√≥mo obtener el siguiente OID para la tabla que vamos a crear: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Ahora la creaci√≥n real de la tabla: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  Sin embargo, la inserci√≥n de datos en una tabla no se registra.  Luego hay numerosas entradas sobre la inserci√≥n de filas en diferentes tablas e √≠ndices: este PostgreSQL registra la tabla creada en el directorio del sistema (lo doy en forma abreviada): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Y finalmente, la fijaci√≥n de transacciones: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  R√©plica </h2><br>  Cuando restauramos el sistema desde la copia de seguridad, comenzamos desde alg√∫n estado del sistema de archivos y llevamos gradualmente los datos al punto de recuperaci√≥n, reproduciendo las entradas de diario archivadas.  El n√∫mero de tales registros puede ser muy grande (por ejemplo, varios d√≠as), es decir, el per√≠odo de recuperaci√≥n no cubrir√° un punto de control, sino muchos.  Por lo tanto, est√° claro que el nivel m√≠nimo del registro no es suficiente: si alguna operaci√≥n no se registra, simplemente no sabremos que debe repetirse.  Para restaurar desde una copia de seguridad, <em>todas las</em> operaciones deben estar registradas. <br><br>  Lo mismo es cierto para la replicaci√≥n: todo lo que no est√© registrado no se transferir√° a la r√©plica y no se reproducir√°.  Pero, si queremos ejecutar solicitudes en una r√©plica, a√∫n es complicado. <br><br>  Primero, necesitamos informaci√≥n sobre bloqueos exclusivos que se producen en el servidor primario, ya que pueden entrar en conflicto con las solicitudes en la r√©plica.  Dichos bloqueos se registran y aplican en la r√©plica (en nombre del proceso de inicio). <br><br>  En segundo lugar, debe poder crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas de datos</a> , y para esto, como recordamos, se necesita informaci√≥n sobre las transacciones en curso.  En el caso de una r√©plica, estamos hablando no solo de transacciones locales, sino tambi√©n de transacciones en el servidor principal.  La √∫nica forma de transmitir esta informaci√≥n es escribirla peri√≥dicamente en el registro (esto sucede cada 15 segundos). <br><br>  El nivel de registro, que garantiza tanto la capacidad de recuperaci√≥n de una copia de seguridad como la posibilidad de replicaci√≥n f√≠sica, se establece mediante el valor wal_level = <em>replica</em> .  (Antes de la versi√≥n 9.6, hab√≠a dos niveles separados archive y hot_standby, pero luego se combinaron en uno com√∫n). <br><br>  Comenzando con PostgreSQL 10, es este nivel el que se establece de manera predeterminada (y antes era m√≠nimo).  Por lo tanto, solo restablezca los par√°metros a los valores predeterminados: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Eliminamos la tabla y repetimos exactamente la misma secuencia de acciones que la √∫ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  Ahora verifique las entradas del diario. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Limpieza, obtenci√≥n de OID, creaci√≥n de una tabla y registro en el directorio del sistema; por ahora, todo est√° como estaba: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, ‚Ä¶ rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Pero algo nuevo.  El registro de un bloqueo exclusivo relacionado con el administrador de Standby: en este caso, est√° bloqueando el n√∫mero de transacci√≥n (por qu√© es necesario, hablaremos en detalle en la pr√≥xima serie de art√≠culos): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  Y este es un registro sobre la inserci√≥n de filas en nuestra tabla (compare el n√∫mero de archivo rel con el indicado anteriormente en el registro CREATE): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Confirmar registro: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  Y otro registro, que ocurre peri√≥dicamente y no est√° vinculado a la transacci√≥n completada, se refiere al administrador de Standby e informa sobre las transacciones actualmente en curso: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  L√≥gico </h2><br>  Finalmente, el √∫ltimo nivel se establece mediante el valor del par√°metro <em>wal_level</em> = logical y proporciona la posibilidad de decodificaci√≥n l√≥gica y replicaci√≥n l√≥gica.  Debe estar habilitado en el servidor de publicaci√≥n. <br><br>  Desde el punto de vista de las entradas de diario, este nivel pr√°cticamente no es diferente de la r√©plica: se agregan registros relacionados con los or√≠genes de replicaci√≥n y entradas l√≥gicas arbitrarias que se pueden agregar al registro de la aplicaci√≥n.  B√°sicamente, la decodificaci√≥n l√≥gica depende de la informaci√≥n sobre las transacciones en curso, ya que necesita crear una instant√°nea de los datos para rastrear los cambios en el cat√°logo del sistema. <br><br>  Ahora no entraremos en detalles sobre el funcionamiento de la copia de seguridad y la replicaci√≥n; este es un gran tema para una serie separada de art√≠culos. <br><br><h1>  Fiabilidad de registro </h1><br>  Est√° claro que el mecanismo de registro en diario debe ser confiable y proporcionar garant√≠as de la posibilidad de recuperaci√≥n en cualquier situaci√≥n (por supuesto, no relacionado con da√±os al soporte de datos).  La confiabilidad est√° influenciada por muchos factores, de los cuales consideraremos el almacenamiento en cach√©, la corrupci√≥n de datos y la atomicidad de las grabaciones. <br><br><h2>  Almacenamiento en cach√© </h2><br>  Existen numerosas memorias cach√© en la ruta de datos al almacenamiento no vol√°til (como una unidad de disco duro). <br><br>  Cuando un programa (cualquiera, pero en nuestro caso PostgreSQL) le pide al sistema operativo que escriba algo en el disco, el sistema operativo transfiere los datos a su cach√© en la RAM.  La grabaci√≥n real se produce de forma as√≠ncrona, seg√∫n la configuraci√≥n del planificador de E / S del sistema operativo. <br><br>  Cuando el sistema operativo decide escribir datos, caen en la memoria cach√© de la unidad (disco duro).  La electr√≥nica de la unidad tambi√©n puede retrasar la grabaci√≥n, por ejemplo, la recopilaci√≥n de datos en grupos que son m√°s rentables para grabar al mismo tiempo.  Y si se utiliza un controlador RAID, aparece otro nivel de almacenamiento en cach√© entre el sistema operativo y la unidad. <br><br>  Por lo tanto, si no toma medidas especiales, no est√° completamente claro cu√°ndo los datos realmente se almacenar√°n de forma segura.  Esto generalmente no es importante, pero hay lugares cr√≠ticos donde PostgreSQL necesita asegurarse de que los datos se escriban de forma segura.  En primer lugar, esto es el registro en diario (si la entrada del diario no lleg√≥ al disco, desaparecer√° junto con el resto del contenido de la RAM) y un punto de control (debe asegurarse de que las p√°ginas sucias est√©n realmente escritas en el disco).  Pero hay otras situaciones, por ejemplo, la ejecuci√≥n de operaciones no periodizadas al nivel m√≠nimo, etc. <br><br>  El sistema operativo proporciona herramientas que deben garantizar la escritura inmediata de datos en la memoria no vol√°til.  Hay varias opciones, pero se reducen a dos principales: se da un comando de sincronizaci√≥n despu√©s de la grabaci√≥n (fsync, fdatasync) o al abrir un archivo (o escribir en √©l), se indica un indicador especial para la sincronizaci√≥n o incluso la grabaci√≥n directa, sin pasar por el cach√© del sistema operativo. <br><br>  En cuanto al registro, la utilidad pg_test_fsync le permite elegir el m√©todo m√°s adecuado para un sistema operativo espec√≠fico y un sistema de archivos espec√≠fico, y se instala en el par√°metro de configuraci√≥n <em>wal_sync_method</em> .  Los archivos normales siempre se sincronizan con fsync. <br><br>  El punto sutil es que al elegir un m√©todo, se deben tener en cuenta las caracter√≠sticas del equipo.  Por ejemplo, si usa un controlador compatible con una bater√≠a de respaldo, no hay raz√≥n para no usar su cach√©, ya que la bater√≠a guardar√° datos en caso de una falla de energ√≠a. <br><br><blockquote>  La documentaci√≥n contiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchos detalles</a> sobre este tema. <br></blockquote><br>  En cualquier caso, la sincronizaci√≥n es costosa y se lleva a cabo no m√°s de lo absolutamente necesario (volveremos a este tema un poco m√°s abajo cuando hablemos del rendimiento). <br><br>  En t√©rminos generales, la sincronizaci√≥n se puede desactivar (el par√°metro <em>fsync</em> es responsable de esto), pero en este caso debe olvidarse de la confiabilidad del almacenamiento.  Al deshabilitar <em>fsync</em> , acepta que los datos pueden perderse irremediablemente en cualquier momento.  Probablemente, la √∫nica opci√≥n razonable para usar esta opci√≥n es aumentar temporalmente la productividad, cuando los datos se pueden restaurar f√°cilmente desde otra fuente (por ejemplo, durante la migraci√≥n inicial). <br><br><h2>  Corrupci√≥n de datos </h2><br>  El equipo es imperfecto y los datos pueden da√±arse en los medios al transmitir datos a trav√©s de cables de interfaz, etc. Algunos de estos errores se procesan a nivel de hardware, pero otros no. <br><br>  Para detectar el problema a tiempo, las entradas de diario siempre se proporcionan con sumas de verificaci√≥n. <br><br>  Las p√°ginas de datos tambi√©n se pueden proteger con sumas de verificaci√≥n.  Por ahora, esto solo se puede hacer cuando se inicializa el cl√∫ster, pero en PostgreSQL 12 ser√° posible activarlos y desactivarlos utilizando la utilidad pg_checksums (aunque todav√≠a no est√° en marcha, pero solo cuando el servidor est√° detenido). <br><br>  En un entorno de producci√≥n, se deben incluir las sumas de verificaci√≥n, a pesar de la sobrecarga de su c√°lculo y control.  Esto reduce la probabilidad de que no se detecte una falla a tiempo. <br><br><blockquote>  Reduce, pero no elimina. <br>  En primer lugar, las sumas de verificaci√≥n solo se verifican al acceder a la p√°gina; por lo tanto, el da√±o puede pasar desapercibido hasta que llegue a todas las copias de seguridad.  Es por eso que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_probackup</a> busca sumas de verificaci√≥n de todas las p√°ginas del cl√∫ster durante la copia de seguridad. <br>  En segundo lugar, una p√°gina llena de ceros se considera correcta: si el sistema de archivos "anula" el archivo por error, esto puede pasar desapercibido. <br>  En tercer lugar, las sumas de verificaci√≥n protegen solo la capa principal de los archivos de datos.  Las capas restantes y otros archivos (por ejemplo, estados de transacciones XACT) no est√°n protegidos por nada. <br>  Por desgracia <br></blockquote><br>  Veamos como funciona.  Primero, aseg√∫rese de que las sumas de verificaci√≥n est√©n habilitadas (tenga en cuenta que este no es el caso al instalar un paquete en sistemas similares a Debian): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  El par√°metro <em>data_checksums</em> es de solo lectura. <br><br>  Aqu√≠ est√° el archivo en el que se encuentra nuestra tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Detenga el servidor y cambie algunos bytes en la p√°gina cero, por ejemplo, elimine la √∫ltima entrada del registro del encabezado LSN. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  En principio, el servidor no se pudo detener.  Es suficiente que la p√°gina se haya escrito en el disco y se haya forzado a salir de la memoria cach√© (de lo contrario, el servidor trabajar√° con la p√°gina desde la memoria cach√©).  Pero tal escenario es m√°s dif√≠cil de reproducir. <br><br>  Ahora iniciamos el servidor e intentamos leer la tabla. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  ¬øPero qu√© pasa si los datos no se pueden restaurar desde la copia de seguridad?  El par√°metro <em>ignore_checksum_failure le</em> permite intentar leer la tabla, naturalmente con el riesgo de obtener datos distorsionados. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  Por supuesto, en este caso, todo va bien, porque confundimos solo el t√≠tulo de la p√°gina y no los datos en s√≠. <br><br>  Y una cosa m√°s.  Cuando se activan las sumas de verificaci√≥n, se escriben fragmentos de mensajes en el registro (los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">examinamos</a> anteriormente), ya que un cambio en cualquier bit, incluso no esencial, tambi√©n conduce a un cambio en la suma de verificaci√≥n.  Cuando las sumas de comprobaci√≥n est√°n desactivadas, el par√°metro <em>wal_log_hints</em> es responsable de escribir bits de sugerencia en el <em>registro</em> . <br><br>  Los cambios en los bits de informaci√≥n sobre herramientas siempre se registran como una <em>imagen de p√°gina completa</em> (FPI, imagen de p√°gina completa), lo que aumenta el tama√±o del registro en orden.  En este caso, tiene sentido habilitar la compresi√≥n de im√°genes completas utilizando el par√°metro <em>wal_compression</em> (este par√°metro apareci√≥ en la versi√≥n 9.5).  A continuaci√≥n nos fijamos en n√∫meros espec√≠ficos. <br><br><h2>  Registro de atomicidad </h2><br>  Y finalmente, est√° el problema de la atomicidad del registro.  Una p√°gina de base de datos toma al menos 8 KB (puede ser 16 o 32 KB), y en un nivel bajo, la grabaci√≥n se produce en bloques que generalmente son m√°s peque√±os (generalmente 512 bytes o 4 KB).  Por lo tanto, en caso de una falla de energ√≠a, la p√°gina de datos puede ser parcialmente grabada.  Est√° claro que durante la recuperaci√≥n no tiene sentido aplicar entradas de diario ordinarias a dicha p√°gina. <br><br>  Para protecci√≥n, PostgreSQL le permite escribir en el registro la <em>imagen completa de la p√°gina</em> cuando se cambia por primera vez despu√©s del inicio del punto de control (la misma imagen se registra cuando cambian los bits de informaci√≥n sobre herramientas).  El par√°metro <em>full_page_writes controla esto</em> , y est√° habilitado de forma predeterminada. <br><br>  Si se encuentra una imagen de p√°gina durante la recuperaci√≥n en un registro, se escribe incondicionalmente (sin verificaci√≥n LSN) en el disco: hay m√°s confianza en ella, porque, como cualquier registro de registro, est√° protegida por una suma de verificaci√≥n.  Y ya se aplican entradas de diario regulares a esta imagen correcta garantizada. <br><br>  Aunque PostgreSQL excluye el espacio no asignado de la imagen de la p√°gina completa (anteriormente analizamos la estructura de bloques), el volumen de entradas de diario generadas aumenta significativamente.  Como ya se mencion√≥, la situaci√≥n se puede mejorar comprimiendo las im√°genes completas (par√°metro <em>wal_compression</em> ). <br><br>  Para sentir de alguna manera el cambio en el tama√±o del registro, realizaremos un experimento simple usando la utilidad pgbench.  Inicialicemos: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  La <em>opci√≥n full_page_writes est√°</em> habilitada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  Ejecute el punto de interrupci√≥n e inmediatamente ejecute la prueba durante 30 segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Tama√±o de registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  Ahora apague el par√°metro full_page_writes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Y repite el experimento. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Tama√±o de registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  S√≠, el tama√±o ha disminuido, pero no es tan significativo como cabr√≠a esperar. <br><br>  La raz√≥n es que el cl√∫ster se inicializa con sumas de verificaci√≥n en las p√°ginas de datos y, por lo tanto, a√∫n debe escribir im√°genes de p√°gina completa en el registro al cambiar los bits de informaci√≥n sobre herramientas.  Estos datos (en nuestro caso) representan aproximadamente la mitad del volumen total, que se puede ver mirando las estad√≠sticas: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  Por compacidad, elimin√© las filas cero de la tabla.  Preste atenci√≥n a la l√≠nea total (Total) y compare el tama√±o de las im√°genes completas (tama√±o FPI) con el tama√±o de los registros ordinarios (Tama√±o de registro). <br><br>  El par√°metro <em>full_page_writes</em> solo se puede deshabilitar si el sistema de archivos y el hardware utilizados por ellos mismos garantizan la grabaci√≥n at√≥mica.  Pero, como podemos ver, no hay una gran raz√≥n para esto (suponiendo que las sumas de verificaci√≥n est√©n incluidas). <br><br>  Ahora veamos c√≥mo ayuda la compresi√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Repite el mismo experimento. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Tama√±o de registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Conclusi√≥n: en presencia de una gran cantidad de im√°genes de p√°gina completa (debido a sumas de verificaci√≥n o <em>escrituras</em> de p√°gina completa, es decir, casi siempre), lo m√°s probable es que tenga sentido usar la compresi√≥n a pesar de que esto carga el procesador. <br><br><h1>  Rendimiento </h1><br>  Durante el funcionamiento normal del servidor, se produce una grabaci√≥n secuencial continua de archivos de registro.  Como no hay acceso aleatorio, los discos duros normales tambi√©n hacen frente a esta tarea.  Pero esta naturaleza de la carga es significativamente diferente de c√≥mo se accede a los archivos de datos. <br><br>  Por lo tanto, generalmente es ventajoso colocar el registro en un disco f√≠sico separado (o matriz de discos) montado en el sistema de archivos del servidor.  En lugar del directorio $ PGDATA / pg_wal, debe crear un enlace simb√≥lico al directorio correspondiente. <br><br><blockquote>  Hay un par de situaciones en las que los archivos de registro no solo deben escribirse, sino tambi√©n leerse.  El primero es un caso comprensible de recuperaci√≥n despu√©s de una falla.  El segundo es menos trivial.  Ocurre si se usa la replicaci√≥n de transmisi√≥n y la r√©plica no logra recibir entradas de diario mientras todav√≠a est√°n en los b√∫feres de RAM del servidor principal.  Luego, el proceso de walsender tiene que leer los datos necesarios del disco.  Hablaremos de esto con m√°s detalle cuando lleguemos a la replicaci√≥n. <br></blockquote><br>  El registro se lleva a cabo en uno de dos modos: <br><br><ul><li>  s√≠ncrono: cuando se confirma una transacci√≥n, la continuaci√≥n del trabajo es imposible hasta que todas las entradas de diario sobre esta transacci√≥n est√©n en el disco; </li><li>  as√≠ncrono: la transacci√≥n se completa de inmediato y el registro se escribe en segundo plano. </li></ul><br>  El modo s√≠ncrono est√° determinado por el par√°metro <em>synchronous_commit</em> y est√° habilitado de forma predeterminada. <br><br>  Dado que la sincronizaci√≥n est√° asociada con E / S real (es decir, lenta), es beneficioso realizarla lo menos posible.  Para hacer esto, el proceso de servicio que completa la transacci√≥n y escribe un registro toma una breve pausa, determinada por el par√°metro <em>commit_delay</em> .       ,       <em>commit_siblings</em>  .     ,                 .    ,     ,  -    . <br><br>    <em>commit_siblings</em> = 5,  <em>commit_delay</em> = 0,      .  <em>commit_delay</em>     ,     OLTP-. <br><br>          LSN (  ,       ).     . <br><br>      ( D   ACID) ‚Äî   ,            .     ,       ( COMMIT      )    . <br><br>    ,  <em>synchronous_commit</em> = off ( local). <br><br>         wal writer,      (   <em>wal_writer_delay</em> = 200ms  ). <br><br>    ,  ,         WAL.  ,    , , ,     . (,    :  ,    ,         .) <br><br>       ,     (  )   ‚Äî    ? <br><br>     ,            ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La grabaci√≥n asincr√≥nica es m√°s eficiente que la grabaci√≥n sincr√≥nica: la confirmaci√≥n de los cambios no espera a la grabaci√≥n. Sin embargo, la confiabilidad disminuye: los datos capturados pueden desaparecer en caso de falla si transcurre menos de 3 √ó </font><font style="vertical-align: inherit;">tiempo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entre la confirmaci√≥n y la falla </font><font style="vertical-align: inherit;">(que, por defecto, es un poco m√°s de medio segundo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una elecci√≥n dif√≠cil - eficiencia o confiabilidad - permanece con el administrador del sistema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta: a diferencia de desactivar la sincronizaci√≥n ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsync</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off), el modo as√≠ncrono no conduce a la imposibilidad de recuperaci√≥n. En caso de falla, el sistema a√∫n restaurar√° un estado consistente, pero quiz√°s algunas de las √∫ltimas transacciones estar√°n ausentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√°metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronous_commit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede configurar como parte de transacciones individuales. Esto le permite aumentar la productividad al sacrificar la confiabilidad de solo una parte de la transacci√≥n. Digamos que las transacciones financieras siempre deben corregirse sincr√≥nicamente, y los mensajes de chat a veces pueden descuidarse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En realidad, ambos modos funcionan juntos. Incluso con la confirmaci√≥n sincr√≥nica, los registros de transacciones largos se escribir√°n de forma asincr√≥nica para liberar los buffers WAL. Y si, al restablecer una p√°gina desde la memoria cach√© del b√∫fer, resulta que la entrada de diario correspondiente a√∫n no est√° en el disco, se restablecer√° inmediatamente en modo s√≠ncrono. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para tener una idea de lo que ofrece la confirmaci√≥n asincr√≥nica, intentamos repetir la prueba pgbench en este modo.</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br>       900    (tps),   ‚Äî 1500. ,         ,  ,         . <br><br>         .  -    ,       .  Gracias a todos! <br><br>         ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461523/">https://habr.com/ru/post/461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461507/index.html">¬øPor qu√© decidimos lanzar el acelerador corporativo Gazprom Neft StartupDrive y qui√©n ya lo ha aprobado?</a></li>
<li><a href="../461509/index.html">Asistentes de viaje: una selecci√≥n de gadgets y accesorios</a></li>
<li><a href="../461511/index.html">Python Dependency Management: una comparaci√≥n de enfoques</a></li>
<li><a href="../461517/index.html">Los mejores algoritmos de copiar y pegar para C y C ++. Haiku OS Cookbook</a></li>
<li><a href="../461519/index.html">Los mejores algoritmos de copiar y pegar para C y C ++. Colecci√≥n de Recetas Haiku OS</a></li>
<li><a href="../461525/index.html">C√≥mo hice un control deslizante realmente adaptable (carrusel)</a></li>
<li><a href="../461527/index.html">Levitaci√≥n ac√∫stica de bricolaje</a></li>
<li><a href="../461531/index.html">Tic Tac Toe, Parte 6: Frasco y apio / RabbitMQ</a></li>
<li><a href="../461533/index.html">Visualizaci√≥n del sue√±o del primer a√±o del beb√©.</a></li>
<li><a href="../461535/index.html">C ++, FIX, Oracle y PL / SQL: lo que un especialista de TI necesita saber para obtener un trabajo en finanzas + oportunidades de trabajo reales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>