<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧣 👨‍👩‍👦‍👦 🤶🏽 JavaScript元编程 👨🏾‍✈️ ✌️ 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="元编程是一种与程序的创建相关联的程序设计，这些程序的创建会由于其工作而生成其他程序，或者在执行过程中会自行更改程序。 （维基百科） 

 用一种简单的语言，可以将JavaScript内部的元编程视为一种机制，使您可以根据任何操作实时分析和更改程序。 而且，很可能您每天都在编写脚本时以某种方式使用它们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript元编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/417097/"><blockquote> 元编程是一种与程序的创建相关联的程序设计，这些程序的创建会由于其工作而生成其他程序，或者在执行过程中会自行更改程序。  （维基百科） </blockquote><p> 用一种简单的语言，可以将JavaScript内部的元编程视为一种机制，使您可以根据任何操作实时分析和更改程序。 而且，很可能您每天都在编写脚本时以某种方式使用它们。 </p><a name="habracut"></a><br><p> 从本质上讲，JavaScript是一种非常强大的动态语言，可让您很好地编写灵活的代码： </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   save-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comment = { <span class="hljs-attr"><span class="hljs-attr">authorId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">comment</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comment) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pascalCasedName = name.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + name.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>); comment[<span class="hljs-string"><span class="hljs-string">`save</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pascalCasedName}</span></span></span><span class="hljs-string">`</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } } comment.saveAuthorId(); //  authorId comment.saveComment(); //  comment</span></span></code> </pre> <br><p> 用于动态创建其他语言方法的类似代码通常可能需要特殊的语法或API。 例如，PHP还是一种动态语言，但是在其中它将需要更多的努力： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $authorId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $comment; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($authorId, $comment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;authorId = $authorId; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;comment = $comment; } <span class="hljs-comment"><span class="hljs-comment">//       public function __call($methodName, $arguments) { foreach (get_object_vars($this) as $fieldName =&gt; $fieldValue) { $saveMethodName = "save" . strtoupper($fieldName[0]) . substr($fieldName, 1); if ($methodName == $saveMethodName) { //   } } } } $comment = new Comment(1, ''); $comment-&gt;saveAuthorId(); //  authorId $comment-&gt;saveComment(); //  comment</span></span></code> </pre> <br><p> 除了灵活的语法外，我们还有许多用于编写动态代码的有用函数：Object.create，Object.defineProperty，Function.apply等。 </p><br><p> 更详细地考虑它们。 </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码生成</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理对象</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反映API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">符号</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代理人</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ol><br><h2 id="1-generaciya-koda">  1.代码生成 </h2><br><p> 动态执行代码的标准工具是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eval</a>函数，它允许您从传递的字符串中执行代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">'alert("Hello, world")'</span></span>);</code> </pre> <br><p> 不幸的是，eval有许多细微差别： </p><br><ul><li> 如果我们的代码以严格模式（“ use strict”）编写，则在eval中声明的变量将在调用eval代码中不可见。 同时，eval中的代码本身可以随时更改外部变量。 </li><li>  eval中的代码既可以在全局上下文中（如果通过window.eval调用），也可以在其中进行调用的函数的上下文中执行（如果只是eval，没有窗口）。 </li><li> 当用较小的变量名替换变量名以减小大小时，由于JS的缩小会出现问题。 作为字符串传递给eval的代码通常不会碰到minifier，因此，我们可以使用旧的未最小化的名称开始访问外部变量，这将导致细微的错误。 </li></ul><br><p> 解决这些问题有一个很好的选择- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新功能</a> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'alert("Hello, " + name)'</span></span>); hello(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-comment"><span class="hljs-comment">// alert("Hello, ");</span></span></code> </pre> <br><p> 与eval不同，我们总是可以通过函数的参数显式传递参数，并动态地为其提供上下文（通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.apply</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.call</a> ）。 另外，创建的函数总是在全局范围内调用。 </p><br><p> 在过去，eval通常用于动态更改代码，因为  JavaScript的反射机制很少，没有评估就不可能做到。 但是在现代语言标准中，出现了更多的高级功能，并且现在很少使用eval了。 </p><br><h2 id="2-rabota-s-funkciyami">  2.使用功能 </h2><br><p>  JavaScript为我们提供了许多出色的工具来动态处理函数，使我们能够在运行时获取有关函数的各种信息并进行更改： </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.length-</a>允许您从函数中找到参数数量： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${surname}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>) }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(func.length) <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.apply</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.call-</a>允许您动态更改此函数的上下文： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">introduce</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } } person.introduce(); <span class="hljs-comment"><span class="hljs-comment">//   person.introduce.call({ name: '' }); //  </span></span></code> </pre> <br><p> 它们之间的区别仅在于，在Function.apply中，函数的参数用作数组，在Function.call中，以逗号分隔。 经常在将此参数列表作为数组传递给函数之前使用此功能。 一个常见的示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Math.max</a>函数（默认情况下，它无法与数组一起使用）： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre> <br><p> 随着新的点<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">差运算符</a>的出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>您可以简单地编写以下代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.bind-</a>允许您从现有函数创建一个副本，但具有不同的上下文： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">introduce</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } } person.introduce(); <span class="hljs-comment"><span class="hljs-comment">//   const introduceEgor = person.introduce.bind({ name: '' }); introduceEgor(); //  </span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.caller-</a>允许您获取调用函数。  <strong>不建议使用它</strong> ，因为它在语言标准中是不存在的，并且在严格模式下无法使用。 这是由于以下事实：如果各种JavaScript引擎实现了语言规范中描述的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尾部调用</a>优化，则调用Function.caller可能会开始产生错误的结果。 用法示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.caller == b); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ a(); } b(); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function.toString-</a>返回<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">函数</a>的字符串表示形式。 这是一项非常强大的功能，可让您检查函数的内容及其参数： </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${surname}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${middlename}</span></span></span><span class="hljs-string">`</span></span>); } getFullName.toString() <span class="hljs-comment"><span class="hljs-comment">/* * "(name, surname, middlename) =&gt; { * console.log(`${surname} ${name} ${middlename}`); * }" */</span></span></code> </pre> <br><p> 收到函数的字符串表示形式后，我们可以解析和解析它。 例如，这可以用于提取函数参数的名称，并根据名称自动替换所需的参数。 通常，有两种解析方法： </p><br><ul><li> 解析一堆常规数据，我们将获得可接受的可靠性水平（如果我们不涵盖所有可能的函数条目类型，则可能无法正常工作）。 </li><li> 我们获得该函数的字符串表示形式，并将其放入完成的JavaScript解析器中（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">esprima</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">acorn</a> ），然后使用结构化AST。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过esprima进行AST解析的示例。</a> 我还可以为Alexei Okhrimenko的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解析器</a>提供一份<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不错的报告</a> 。 </li></ul><br></li></ul><br><p> 具有常规函数解析的简单示例： </p><br><div class="spoiler">  <b class="spoiler_title">获取函数参数列表</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    . * @param fn  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFunctionParams = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> COMMENTS = <span class="hljs-regexp"><span class="hljs-regexp">/(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_PARAMS = <span class="hljs-regexp"><span class="hljs-regexp">/=[^,]+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FAT_ARROW = <span class="hljs-regexp"><span class="hljs-regexp">/=&gt;.*$/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ARGUMENT_NAMES = <span class="hljs-regexp"><span class="hljs-regexp">/([^\s,]+)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formattedFn = fn .toString() .replace(COMMENTS, <span class="hljs-string"><span class="hljs-string">""</span></span>) .replace(FAT_ARROW, <span class="hljs-string"><span class="hljs-string">""</span></span>) .replace(DEFAULT_PARAMS, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = formattedFn .slice(formattedFn.indexOf(<span class="hljs-string"><span class="hljs-string">"("</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, formattedFn.indexOf(<span class="hljs-string"><span class="hljs-string">")"</span></span>)) .match(ARGUMENT_NAMES); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params || []; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(surname + <span class="hljs-string"><span class="hljs-string">' '</span></span> + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + middlename); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(getFunctionParams(getFullName)); <span class="hljs-comment"><span class="hljs-comment">// ["name", "surname", "middlename"]</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><div class="spoiler">  <b class="spoiler_title">获得身体机能</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *     . * @param fn  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFunctionBody = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restoreIndent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">body</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = body.split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bodyLine = lines.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> =&gt;</span></span> line.trim() !== <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indent = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> bodyLine !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span> ? <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/[ \t]*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">.exec(bodyLine</span></span></span><span class="hljs-function">) || [])[0] : ""; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indent</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indent</span></span></span><span class="hljs-function"> || ""; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lines</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line =&gt; line.replace(indent, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">join</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span></span><span class="hljs-function">); }; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rawBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">substring</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> fnStr.indexOf(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"{"</span></span></span></span></span><span class="hljs-function">) + 1, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lastIndexOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"}"</span></span></span></span></span><span class="hljs-function">) ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indentedBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">restoreIndent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rawBody</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trimmedBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indentedBody</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/^\s+|\s+$/g</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trimmedBody</span></span></span><span class="hljs-function">; }; //       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getFullName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getFullName</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(surname + <span class="hljs-string"><span class="hljs-string">' '</span></span> + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + middlename); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(getFunctionBody(getFullName));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p> 重要的是要注意，使用缩小器时，解析函数内部的代码本身及其参数都可以被优化，因此可以更改。 </p><br><h2 id="3-rabota-s-obektami">  3.处理对象 </h2><br><p>  JavaScript有一个全局Object对象，其中包含许多用于动态处理对象的方法。 </p><br><p> 这些语言中的大多数方法早已在该语言中存在并被广泛使用。 </p><br><h3 id="svoystva-obekta"> 对象属性 </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.assign-</a>方便地将一个或多个对象的属性复制到第一个参数指定的对象： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }) <span class="hljs-comment"><span class="hljs-comment">// {a: 1, b: 2, c: 3}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.keys</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.values-</a>返回键列表或对象值列表： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// ["a", "b", "c"] console.log(Object.values(obj)); // [1, 2, 3]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.entries-</a>以<em>[[key1，value1]，[key2，value2]]</em>格式返回其属性的列表： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-comment"><span class="hljs-comment">// [["a", 1], ["b", 2], ["c", 3]]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.prototype.hasOwnProperty-</a>检查属性是否包含在对象中（不在其原型链中）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; obj.__proto__ = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log(obj.hasOwnProperty('b')) // false</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getOwnPropertyNames-</a>返回其自身属性的列表，包括枚举和非枚举： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//    for (let key in obj) { console.log(key); } // "a", "b" console.log(Object.getOwnPropertyNames(obj)); // [ "a", "b", "c" ]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getOwnPropertySymbols-</a>返回其自身的列表（包含在对象中，而不在其原型链中）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); obj[a] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertySymbols(obj)); <span class="hljs-comment"><span class="hljs-comment">// [ Symbol(a) ]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.prototype.propertyIsEnumerable-</a>检查属性是否可枚举（例如，在for-in，for-of循环中可用）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [ <span class="hljs-string"><span class="hljs-string">' '</span></span> ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr.propertyIsEnumerable(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true —  ' '   console.log(arr.propertyIsEnumerable('length')); // false —  length   </span></span></code> </pre> <br></li></ul><br><h3 id="deskriptory-svoystv-obekta"> 对象属性描述符 </h3><br><p> 描述符允许您微调属性参数。 使用它们，我们可以在读取/写入任何属性（getter和setters-get / set），使属性不可变或不可枚举以及许多其他事情时方便地制作自己的拦截器。 </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.defineProperty</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.defineProperties-</a>创建一个或多个属性描述符。 使用getter和setter创建自己的描述符： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'fullname'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//     fullname get: function() { return `${this.name} ${this.surname}`; }, //     fullname (     delete obj.fullname) set: function(value) { const [name, surname] = value.split(' '); this.name = name; this.surname = surname; }, }); console.log(obj.fullname); //   obj.fullname = ' '; console.log(obj.name); //  console.log(obj.surname); // </span></span></code> </pre> <br><p> 在上面的示例中，fullname属性没有自己的值，而是动态使用name和surname属性。 不必同时定义getter和setter-我们可以只保留getter并获得只读属性。 或者，我们可以在设置器中添加其他操作以及设置值，例如，日志记录。 <br> 除了get / set属性外，描述符还具有其他几个要配置的属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">//      get/set,       value.    get/set  value.   — undefined. Object.defineProperty(obj, 'name', { value: '' }); // ,         (for-in, for-of, Object.keys).   — false. Object.defineProperty(obj, 'a', { enumerable: true }); //         defineProperty     delete.   — false. Object.defineProperty(obj, 'b', { configurable: false }); //      .   — false. Object.defineProperty(obj, 'c', { writable: true });</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getOwnPropertyDescriptor</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getOwnPropertyDescriptors-</a>允许您获取所需的对象描述符或其完整列表： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, <span class="hljs-string"><span class="hljs-string">"a"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { configurable: true, enumerable: true, value: 1, writable: true } /** * { * a: { configurable: true, enumerable: true, value: 1, writable: true }, * b: { configurable: true, enumerable: true, value: 2, writable: true } * } */ console.log(Object.getOwnPropertyDescriptors(obj));</span></span></code> </pre> <br></li></ul><br><h3 id="sozdanie-ogranicheniy-pri-rabote-s-obektami"> 在处理对象时创建限制 </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.freeze-</a> “冻结”对象的属性。 这种“冻结”的结果是对象属性的完全不变性-无法更改和删除它们，添加新属性，更改描述符： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//       ,       . obj.a = 2; obj.b = 3; console.log(obj); // { a: 1 } console.log(Object.isFrozen(obj)) // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.seal-</a> “密封”对象的属性。 密封与Object.freeze相似，但是有很多区别。 与Object.freeze中一样，我们禁止添加新属性，删除现有属性，更改其描述符，但同时我们可以更改属性值： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); obj.a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  a   2 //     ,       . obj.b = 3; console.log(obj); // { a: 2 } console.log(Object.isSealed(obj)) // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.preventExtensions-</a>禁止添加新的属性/描述符： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); obj.a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       ,       . obj.b = 3; console.log(obj); // { a: 2 } console.log(Object.isExtensible(obj)) // false</span></span></code> </pre> <br></li></ul><br><h3 id="prototipy-obektov"> 对象原型 </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.create-</a>使用参数中指定的原型创建对象。 此功能可用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原型继承</a>和创建“干净”对象，而无需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.prototype的</a>属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pureObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getPrototypeOf</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.setPrototypeOf-</a>获取/更改对象的原型： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duck = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bird = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf(duck, bird); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(duck) === bird); <span class="hljs-comment"><span class="hljs-comment">// true console.log(duck.__proto__ === bird); // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.prototype.isPrototypeOf-</a>检查当前对象是否包含在另一个对象的原型链中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duck = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bird = {}; duck.__proto__ = bird; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bird.isPrototypeOf(duck)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li></ul><br><h2 id="4-reflect-api">  4.反映API </h2><br><p> 随着ES6的到来，全局<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect</a>对象已添加到JavaScript中，以存储与反射和自省有关的各种方法。 </p><br><p> 他的大多数方法是将现有方法从诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function之</a>类的全局对象转移到一个单独的名称空间的结果，并进行了一些重构以使使用更加舒适。 </p><br><p> 将函数转移到Reflect对象不仅可以方便地寻找必要的反射方法并提供更大的语义，而且还可以避免在我们的对象原型中不包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.prototype的</a>情况出现，但我们想从那里使用这些方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); obj.qwerty = <span class="hljs-string"><span class="hljs-string">'qwerty'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.__proto__) <span class="hljs-comment"><span class="hljs-comment">// null console.log(obj.hasOwnProperty('qwerty')) // Uncaught TypeError: obj.hasOwnProperty is not a function console.log(obj.hasOwnProperty === undefined); // true console.log(Object.prototype.hasOwnProperty.call(obj, 'qwerty')); // true</span></span></code> </pre> <br><p> 重构使方法的行为更加明确和单调。 例如，如果在更早的时候，当对不正确的值（例如数字或字符串）调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.defineProperty</a>时，会引发异常，但同时，对不存在的对象描述符调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.getOwnPropertyDescriptor</a>时会默默返回undefined，然后Reflect的类似方法始终会为不正确的数据引发异常。 </p><br><p> 还添加了几种新方法： </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.construct</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.create</a>的更方便的替代方法，它不仅允许使用指定的原型创建对象，还可以立即对其进行初始化： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.formatParam(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surname = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.formatParam(surname); } Person.prototype.formatParam = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + param.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldPerson = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Person.prototype); <span class="hljs-comment"><span class="hljs-comment">// {} Person.call(oldPerson, '', ''); // {name: "", surname: ""} const newPerson = Reflect.construct(Person, ['', '']); // {name: "", surname: ""}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.ownKeys-</a>返回属于指定对象（而不是原型链中的对象）的属性的数组： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; person.__proto__ = { <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(person)); <span class="hljs-comment"><span class="hljs-comment">// ["name", "surname"]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.deleteProperty-</a> <em>删除</em>操作符的替代方法，以一种方法的形式进行： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> person.name; <span class="hljs-comment"><span class="hljs-comment">// person = {surname: ""} Reflect.deleteProperty(person, 'surname'); // person = {}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.has</a> - <em>in</em>运算符的替代方法，以一种方法的形式实现： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> person); <span class="hljs-comment"><span class="hljs-comment">// true console.log(Reflect.has(person, 'name')); // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.get</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reflect.set-</a>用于读取/更改对象属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(person, <span class="hljs-string"><span class="hljs-string">'name'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  Reflect.set(person, 'surname', '') // person = {name: "", surname: ""}</span></span></code> </pre> <br></li></ul><br><p> 有关更改的更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </p><br><h3 id="reflect-metadata"> 反映元数据 </h3><br><p> 除了上面列出的“反射对象”方法外，还有一个实验性建议，可以方便地将各种元数据绑定到对象。 </p><br><p> 元数据可以是与对象没有直接关系的任何有用信息，例如： </p><br><ul><li>  TypeScript在打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">embedDecoratorMetadata</a>标志<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时，会</a>在元数据中写入有关类型的信息，从而允许您在运行时访问它们。 此外，可以通过以下关键设计获取此信息：类型： <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeData = Reflect.getMetadata(<span class="hljs-string"><span class="hljs-string">"design:type"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, propertyName);</code> </pre> </li><li> 流行的用于反转控制的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">InversifyJS</a>库将有关所描述关系的各种信息存储在元数据中。 </li></ul><br><p> 目前，此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">polyfill可</a>在浏览器中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </p><br><h2 id="5-simvoly-symbols">  5.符号 </h2><br><p> 符号是一种新的不可变数据类型，主要用于为对象属性标识符创建唯一的名称。 我们可以通过两种方式创建角色： </p><br><ol><li><p> 本地符号-Symbol函数的参数中的文本不会影响唯一性，仅在调试时才需要： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sym1 == sym2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br></li><li><p> 全局字符-字符存储在全局注册表中，因此具有相同键的字符相等： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym3 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym4 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym5 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'other name'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sym3 == sym4); <span class="hljs-comment"><span class="hljs-comment">// true,        'name' console.log(sym3 == sym5); // false,    </span></span></code> </pre> <br></li></ol><br><p> 创建此类标识符的能力使我们不必担心会覆盖我们未知对象中的某些属性。 这种质量使标准的创建者可以轻松地向对象添加新的标准属性，而不会破坏与各种现有库（可能已经定义了相同属性）和用户代码的兼容性。 因此，存在许多标准符号，其中一些提供了新的反思机会： </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.iterator-</a>允许您使用<em>for-of</em>或<em>... spread运算符</em>创建用于迭代对象的自己的规则： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//       arr[Symbol.iterator] = function() { const self = this; let pos = this.length - 1; return { next() { if (pos &gt;= 0) { return { done: false, value: self[pos--] }; } else { return { done: true }; } } } }; console.log([...arr]); // [3, 2, 1]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.hasInstance</a>是一种确定构造函数是否将对象识别为其实例的方法。 由instanceof运算符使用： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.hasInstance](instance) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(instance); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MyArray); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.isConcatSpread-</a>指示在Array.concat中串联时是否应展平数组： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondArr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; firstArr.concat(secondArr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6] secondArr[Symbol.isConcatSpreadable] = false; console.log(firstArr.concat(secondArr)); // [1, 2, 3, [4, 5, 6]]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.species-</a>允许您指定将使用哪个构造函数在类内部创建派生对象。 <br> 例如，我们有一个用于处理数组的标准Array类，它具有一个.map方法，该方法根据当前数组创建一个新数组。 为了找出用于创建该新数组的类，Array如下调用<em>this.constructor [Symbol.species]</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ArrayClass = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.species]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, index, arr</span></span></span><span class="hljs-function">) =&gt;</span></span> { result[index] = cb(value, index, arr); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 因此，重写Symbol.species，我们可以创建自己的用于处理数组的类，并说所有标准方法（例如.map，.reduce等）都不返回Array类的实例，而是返回我们类的实例： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.species]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyArray(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(arr instanceof MyArray); // true console.log(arr instanceof Array); // true //   Array.map     Array,    Symbol.species  this      MyArray const doubledArr = arr.map(x =&gt; x * 2); console.log(doubledArr instanceof MyArray); // true console.log(doubledArr instanceof Array); // true</span></span></code> </pre> <br><p> 当然，这不仅适用于数组，而且适用于其他标准类。 此外，即使我们仅使用返回相同类的新实例的方法来创建自己的类，也应使用this.constructor [Symbol.species]来获取对构造函数的引用。 </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.toPrimitive-</a>允许您指定如何将我们的对象转换为原始值。 如果是更早的版本，为了简化为原始类型，我们需要将toString和valueOf一起使用，现在一切都可以通过一种方便的方法完成： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> figure = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toPrimitive](hint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hint === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hint === <span class="hljs-string"><span class="hljs-string">'number'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// default return this.name; } } } console.log(`${figure}`); // hint = string console.log(+figure); // hint = number console.log(figure + ''); // hint = default</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.match-</a>允许您为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">String.prototype.match</a>函数的方法创建自己的处理程序类： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartAndEndsWithMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.match](str) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startsWith = str.startsWith(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endsWith = str.endsWith(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startsWith &amp;&amp; endsWith) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testMatchResult = <span class="hljs-string"><span class="hljs-string">'||'</span></span>.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StartAndEndsWithMatcher(<span class="hljs-string"><span class="hljs-string">'|'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(testMatchResult); <span class="hljs-comment"><span class="hljs-comment">// ["|"] const catMatchResult = '|'.match(new StartAndEndsWithMatcher('|')); console.log(catMatchResult) // null</span></span></code> </pre> <br><p>     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.replace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.search</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbol.split</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">String.prototype</a> . </p><br></li></ul><br><p>  ,   (  reflect-metadata   )         .  -   ,    ,       .        : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> validationRules = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'validationRules'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; person[validationRules] = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: [<span class="hljs-string"><span class="hljs-string">'max-length-256'</span></span>, <span class="hljs-string"><span class="hljs-string">'required'</span></span>], <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: [<span class="hljs-string"><span class="hljs-string">'max-length-256'</span></span>] };</code> </pre> <br><h2 id="6-proksi-proxy"> 6.  (Proxy) </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Proxy</a>    ,    Reflect API  Symbols  ES6,       //  ,  ,       .  ,  <em>   </em> . </p><br><p>           ,    data-binding  MobX  React, Vue  .       . </p><br><p>  : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formData = { <span class="hljs-attr"><span class="hljs-attr">login</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'pass'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxyFormData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(formData, { set(target, name, value) { target[name] = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); <span class="hljs-comment"><span class="hljs-comment">//   React- } }); //       forceUpdate()    React proxyFormData.login = 'User2'; //     ,   -      proxyFormData.age = 20;</span></span></code> </pre> <br><p>        ,  /: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formData = { <span class="hljs-attr"><span class="hljs-attr">login</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'pass'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxyFormData = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> formData) { <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.defineProperty(proxyFormData, <span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: formData[param], <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.defineProperty(proxyFormData, param, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>]; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>] = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); <span class="hljs-comment"><span class="hljs-comment">//   React- }, enumerable: true, configurable: true }); } //       forceUpdate()    React proxyFormData.login = 'User2'; //                  -  Reflect.defineProperty proxyFormData.age = 20;</span></span></code> </pre> <br><p>          -,     —   Proxy            (  ,       ),    /             ,           <em>delete obj[name]</em> . </p><br><h2 id="7-zaklyuchenie"> 7.  </h2><br><p> JavaScript        ,           ECMAScript 4,             .               ,   . </p><br><p>             <a href="">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">You Don't Know JS</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417097/">https://habr.com/ru/post/zh-CN417097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417085/index.html">浏览器使WebRTC应用程序中的声音静音。 停什么</a></li>
<li><a href="../zh-CN417087/index.html">HPE Digitize 2018：活动和现场直播</a></li>
<li><a href="../zh-CN417089/index.html">量子计算机：一个光子统治一切</a></li>
<li><a href="../zh-CN417091/index.html">为网络创建卡通水着色器。 第三部分</a></li>
<li><a href="../zh-CN417093/index.html">带有Modbus的触摸开关：为什么需要它们以及如何在智能公寓中应用它们</a></li>
<li><a href="../zh-CN417099/index.html">我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第二章</a></li>
<li><a href="../zh-CN417101/index.html">Ready的定义-我们忘了告诉我们的</a></li>
<li><a href="../zh-CN417103/index.html">Spark SQL。 关于查询优化器的一些知识</a></li>
<li><a href="../zh-CN417105/index.html">在3D打印机上打印。 3Dtool的秘密经历</a></li>
<li><a href="../zh-CN417107/index.html">True时游戏的创造者：了解（）游戏开发，VR问题和ML模拟的知识</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>