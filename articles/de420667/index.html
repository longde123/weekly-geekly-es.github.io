<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏲️ 🐲 👨🏽‍🤝‍👨🏼 Funktionsprinzipien des EIGRP-Protokolls 👨🏼‍⚖️ 👩🏻 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird über EIGRP gesprochen und die Funktionsweise dieses Protokolls erläutert. EIGRP ist ein Distanzvektorprotokoll, manchmal wird e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsprinzipien des EIGRP-Protokolls</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420667/"> In diesem Artikel wird über EIGRP gesprochen und die Funktionsweise dieses Protokolls erläutert.  EIGRP ist ein Distanzvektorprotokoll, manchmal wird es als Hybrid bezeichnet, aber das ist es nicht.  Lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfang des Artikels</a> über OSPF und Sie werden verstehen, warum EIGRP ein Remote-Vektorprotokoll ist.  EIGRP ist ein fortschrittliches dynamisches Routing-Protokoll für Distanzvektoren, das von Cisco entwickelt wurde.  Lass es uns richtig machen.  Wir werden die folgende Topologie verwenden: <br><br><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ed/cbb/733/4edcbb7335c70442a6ad9c1e4754e851.jpg" alt="Mein bild"></a> <a name="habracut"></a><br><br>  Führen Sie EIGRP auf vIOS1 und vIOS2 aus und sehen Sie, wie Informationen zwischen Routern übertragen werden.  Sobald EIGRP auf dem Router aktiviert ist, beginnt der Router mit dem Senden von Hello-Paketen.  Wir listen auch andere Arten von Nachrichten auf, die in EIGRP verwendet werden. <br><br><ul><li>  Hallo - Router verwenden Hallo-Pakete, um Nachbarn zu entdecken.  Multicast-Pakete werden gesendet und erfordern keine Empfangsbestätigung. </li><li>  Update - enthält Informationen zum Ändern von Routen.  Sie werden nur an die vom Update betroffenen Router gesendet.  Diese Pakete können an einen bestimmten Router (Unicast) oder eine Gruppe von Routern (Multicast) gesendet werden.  Der Empfang eines Update-Pakets wird durch Senden eines ACK bestätigt. </li><li>  Abfrage - Wenn der Router die Route berechnet und keinen realisierbaren Nachfolger hat, sendet er ein Abfragepaket an seine Nachbarn, um festzustellen, ob sie einen realisierbaren Nachfolger für dieses Ziel haben.  In der Regel werden Abfragepakete per Multicast gesendet, es kann jedoch Unicast geben.  Der Empfang des Abfragepakets wird durch Senden der ACK durch den Paketempfänger bestätigt. </li><li>  Antwort - Der Router sendet ein Antwortpaket als Antwort auf das Abfragepaket.  Antwortpakete werden Unicast an denjenigen gesendet, der das Abfragepaket gesendet hat.  Der Empfang eines Antwortpakets wird durch Senden einer Bestätigung bestätigt. </li><li>  ACK - ein Paket, das den Empfang von Aktualisierungs-, Abfrage- und Antwortpaketen bestätigt.  ACK-Pakete werden Unicast gesendet und enthalten eine Bestätigungsnummer.  In der Tat sind dies Hallo-Pakete, die keine Daten übertragen.  Es wird eine nicht garantierte Lieferung verwendet. </li></ul><br>  Es gibt auch SIA-Pakete, aber wir werden unten darüber sprechen. <br>  Pakete werden alle 5 Sekunden an die Multicast-Adresse 224.0.0.10 gesendet (Hallo Timer). Der Hold-Timer beträgt 15 Sekunden = 3 Hallo-Intervalle. Wenn während dieses Timers keine Hallo-Pakete von einem Nachbarn empfangen wurden, wird der Nachbar aus der Liste der Nachbarn entfernt.  Das Paket sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/144/cd2/7a5/144cd27a50a78ca0aeb70c7e4b15cfae.jpg" alt="Mein bild"><br><br>  Das Paket enthält die Parameter der Koeffizienten (K1, K2, K3, K4, K5, K6), den Hold-Timer und die Nummer des autonomen Systems.  Bei der Berechnung der Metrik werden Koeffizienten (K1, K2, K3, K4, K5, K6) verwendet, auf die wir später noch eingehen werden, sowie EIGRP-Timer.  Jetzt ist es wichtig, über das Autonome System (AS) zu sprechen.  Um EIGRP zu aktivieren, muss einem bestimmten EIGRP-Prozess wie in OSPF eine Nummer zugewiesen werden.  Im Gegensatz zu OSPF kann diese Option jedoch nicht für jeden Router zufällig ausgewählt werden, sondern muss für alle Router gleich sein.  Wenn der Router ein Hello-Paket mit einem anderen AS empfängt, besteht keine Nachbarbeziehung. <br><br>  Damit Router Nachbarn werden können, müssen folgende Bedingungen erfüllt sein: <br><br><ul><li>  Router müssen authentifiziert sein, </li><li>  Router müssen sich im selben AS befinden, </li><li>  Nachbarschaftsbeziehungen sollten an primären Adressen hergestellt werden (wenn ein Hallo-Paket eintrifft, prüft der Router, ob die Absenderadresse des Netzwerks zur primären Adresse der Schnittstelle gehört). </li><li>  Werte der K-Koeffizienten müssen übereinstimmen. </li></ul><br>  Damit Router zu EIGRP-Nachbarn werden können, müssen sie nicht mit der Hello- und Hold-Zeit übereinstimmen.  Der Router verwendet vom Nachbarn empfangene Timerwerte.  Wenn der Hello- oder Hold-Timer auf einem der Router geändert wird, verwenden die Nachbarn dieses Routers diese Werte.  Damit der Router andere Werte verwenden kann, muss der Timer an der entsprechenden Schnittstelle des Nachbarn geändert werden.  Nach dem Austausch von Hello-Paketen wird ein Update-Paket gesendet, das jedoch noch keine Routen enthält. Es enthält das Init-Flag, das den Routern den Beginn des Informationsaustauschs über Routen mitteilt.  Dieses Paket wird direkt an die Adresse des Routers gesendet.  Nach dem Austausch solcher Nachrichten sendet jeder Router ein Aktualisierungspaket mit Routen an die Multicast-Adresse 224.0.0.10: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/0da/c1c/dd90dac1c80680d40681289160f1898b.jpg" alt="Mein bild"><br><br>  Wie Sie sehen können, enthält das Update-Paket keine Metrik, sondern nur Informationen wie Bandbreite, Verzögerung, MTU usw. Nachdem der Router diese Informationen erhalten hat, berechnet er die Metrik selbst anhand der K1-K6-Koeffizienten.  Diese Pakete können entweder an einen bestimmten Router oder an einen Multicast gesendet werden.  Im Allgemeinen gibt es drei Arten von Updates: <br><br><ul><li>  Nicht periodisch (nicht periodisch) - Aktualisierungen werden nicht in regelmäßigen Abständen gesendet, sondern wenn sich die Topologie oder Metrik ändert. </li><li>  Teilweise (teilweise) - Nicht alle Informationen aus der Routing-Tabelle werden in Aktualisierungen übertragen, sondern nur Änderungen. </li><li>  Begrenzt - Updates werden nur an die beteiligten Router gesendet. </li></ul><br>  Nachbarschaften auf Paketebene sehen folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/588/fe6/68a588fe6adbe793d98c2b57b7da301e.jpg" alt="Mein bild"><br><br>  Möglicherweise stellen Sie fest, dass es neben dem von uns aufgelisteten Hello und Update auch Hello (ACK) gibt und die Anzahl der Anzahl der an die Multicast-Adresse gesendeten Update-Pakete entspricht.  Alles dreht sich um das RTP-Protokoll.  Das RTP-Protokoll steuert den Prozess der Übertragung von EIGRP-Paketen und bietet: <br><br><ul><li>  Garantierte Paketzustellung. </li><li>  Beibehaltung der Reihenfolge der Pakete. </li></ul><br>  Das sind die Dinge.  Was haben wir  Routen ausgetauscht Aktualisieren Sie Pakete und jetzt ist es Zeit, eine Routing-Tabelle zu erstellen.  Jedes Update wird verarbeitet und Daten (Bandbreite, Verzögerung usw.) durch eine spezielle Formel ersetzt. Die Metrik wird berechnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/0ab/062/cc60ab0622cbe1abb96521c2520b96ee.jpg" alt="Mein bild"><br><br>  Eine solche Formel sieht fantastisch aus, aber das Beste daran ist, dass Sie sie vielleicht nicht kennen, nur wissen, dass so etwas existiert.  Ein weiterer netter Trick ist, dass die Standard-EIGRP-Koeffizienten sind: <br><br><ul><li>  K1 = 1 </li><li>  K2 = 0 </li><li>  K3 = 1 </li><li>  K4 = 0 </li><li>  K5 = 0 </li></ul><br>  Und die Formel wird einfach zu Metrik = Bandbreite + Verzögerung.  Daher ist es so wichtig, dass die Koeffizienten auf allen Routern gleich sind, damit es aufgrund unterschiedlicher Metriken auf den Routern keine Probleme gibt.  Lassen Sie uns etwas detaillierter über die Daten in Update sprechen. <br><br><ul><li>  Bandbreite - Der Mindestwert unter den zum Netzwerk führenden Bandbreitenkanälen wird ausgewählt und an Update gesendet. </li><li>  Verzögerung - Fasst die Verzögerung aller Kanäle zusammen, die zu diesem Netzwerk führen. </li><li>  Zuverlässigkeit - das schlechteste Maß an Zuverlässigkeit, basierend auf Keepalive </li><li>  Laden - der schlechteste Indikator für das vollständige Laden von Verbindungen, basierend auf der Paketrate und der konfigurierten Bandbreite auf der Schnittstelle </li><li>  MTU ist die kleinste MTU auf dem ganzen Weg.  Trotz der Tatsache, dass es in Update verwendet wird, nimmt es nicht an der Berechnung der Metrik selbst teil. </li></ul><br>  Wie oben erwähnt, werden standardmäßig Bandbreite und Verzögerung verwendet.  Die übrigen Parameter sind bei Bedarf selten erforderlich, mit deren Hilfe ist jedoch eine feinere Anpassung der Metrik möglich.  Somit übergibt der Router im Aktualisierungspaket die Route und die damit verbundenen Daten und überträgt die Metrik selbst nicht.  Der Router, der das Update erhalten hat, berechnet die Metrik gemäß der Formel und entscheidet abhängig von den Metriken, ob die Route an die Routing-Tabelle weitergeleitet werden soll oder nicht.  Es ist auch wichtig zu beachten, dass der <b>Router nur die Routen überträgt, die er verwendet.</b>  Mal sehen, wie man eine Topologietabelle erstellt. <br><br>  <b>Topologietabelle</b> - Eine Liste der Routen, die von jedem Nachbarn gelernt wurden.  In der Topologietabelle werden auch die Metrik gespeichert, die jeder Nachbar für jede Route (AD) meldet, und die Metrik, die der lokale Router verwendet, um die Route über den Nachbarn (FD) zu erreichen. <br><br>  Es ist notwendig zu erklären, was AD und FD sind.  Wir werden EIGRP auf allen unseren Routern konfigurieren.  Um komplexe Zahlen in der Metrik zu vermeiden, ändern wir auch die Koeffizienten von K1 = 1 K2 = 0 K3 = 1 K4 = 0 K5 = 0 zu K1 = 0 K2 = 0 K3 = 1 K4 = 0 K5 = 0. Somit haben wir 256 * Verzögerungsformel und wir erhalten auch eine einfache Möglichkeit, Metriken durch Ändern des Verzögerungsparameters an den Schnittstellen zu manipulieren.  Wenn man bedenkt, dass bei Schnittstellen die Verzögerung 1 Sekunde beträgt, kostet jede Verbindung, wenn Sie die OSPF-Terminologie verwenden, 256. Sehen wir uns die Topologietabelle unter vIOS1 an: <br><blockquote>  vIOS1 # show ip eigrp topology <br>  EIGRP-IPv4-Topologietabelle für AS (1) / ID (192.168.1.1) <br>  Codes: P - Passiv, A - Aktiv, U - Update, Q - Abfrage, R - Antwort, <br>  r - Antwortstatus, s - sia Status <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 512 <br>  über 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 512 <br>  über 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 512 <br>  über 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 512 <br>  über 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 512 <br>  über 192.168.14.4 (512/256), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 3 Nachfolger, FD ist 768 <br>  über 192.168.12.2 (768/512), GigabitEthernet0 / 3 <br>  über 192.168.13.3 (768/512), GigabitEthernet0 / 0 <br>  über 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Wenn Sie sich beispielsweise das Netzwerk 192.168.5.0/24 ansehen, werden Sie drei Pfade durch vIOS2, vIOS3 und vIOS4 mit denselben Metriken bemerken.  Für 192.168.5.0/24 FD ist es für alle Pfade gleich - 768 und AD - 512. Geben wir eine Definition aus einem anderen Artikel und versuchen zu erklären: <br><br><ul><li>  <b>Die angekündigte Entfernung (AD)</b> , auch als gemeldete Entfernung (RD) bezeichnet, sind die Kosten für die Entfernung zwischen dem benachbarten Router, der die Route ankündigt, und dem Zielnetzwerk. </li><li>  <b>Machbare Entfernung (FD)</b> - die Kosten für die Entfernung vom lokalen Router zum Zielnetzwerk = AD, das den benachbarten Router ankündigt + die Kosten für die Entfernung zwischen dem lokalen Router und dem benachbarten Router. </li></ul><br><blockquote>  P 192.168.5.0/24, 3 Nachfolger, FD ist 768 über 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Lassen Sie uns diese Zeile aus der Topologietabelle auf vIOS1 untersuchen.  vIOS1 lernte die Route von vIOS4 (192.168.14.4) kennen.  Da vIOS1 drei Links von 192.168.5.0/24 trennt, lautet die FD-Metrik mit unseren Einstellungen 3 * 256 = 768.  Und AD ist die Routenmetrik relativ zum Router (vIOS4), der dieses Netzwerk angekündigt hat.  AD ist die FD-Metrik dieser Route unter vIOS4.  Schauen wir uns die Topologietabelle unter vIOS4 an: <br><blockquote>  P 192.168.5.0/24, 1 Nachfolger, FD ist 512 über 192.168.45.5 (512/256), GigabitEthernet0 / 1 </blockquote><br>  AD auf vIOS1 = FD auf vIOS4.  Lautlos verwirrend, aber versuchen Sie, die Logik der Arbeit zu erklären.  Der Router, der die Route ankündigt, sendet die Parameter (Bandbreite, Verzögerung usw.) der Route in der Aktualisierungsnachricht, ohne die Verbindung zwischen dem angekündigten Router zu berücksichtigen.  Das heißt, vIOS4 berücksichtigt nur die Parameter von zwei Links: vIOS4 Gi0 / 1 - vIOS5 Gi0 / 1 und vIOS5 Gi0 / 0 - VPC.  Nach Erhalt des Updates berechnet vIOS1, das die erhaltenen Parameter in der Formel ersetzt, was?  Das stimmt - AD = 512.  Nachdem die Verbindungsparameter, von denen die Route stammt, vIOS1 Gi0 / 2 - vIOS4 Gi0 / 2 übernommen und erneut in die Formel eingesetzt wurden.  Zählt, bekommt die Nummer 256 und addiert sie mit AD (512), wir bekommen FD - 768. Das sind die Dinge!  Aber warum all dieses Ritual? <br>  Und das alles, um eine Sonderregel namens <b>Machbare Bedingung</b> zu schaffen, die eines der Mittel zum Schutz vor Schleifenbildung und schneller Konvergenz darstellt. <br>  Definieren wir folgende Begriffe: <br><br><ul><li>  Nachfolger ist ein benachbarter Router mit einem schleifenfreien Pfad und dem kostengünstigsten Pfad zum Zielnetzwerk. </li><li>  Machbarer Nachfolger - Backup-Router mit Pfad ohne Schleifen (AD machbarer Nachfolger sollte kleiner als FD der aktuellen Nachfolgeroute sein). </li><li>  Machbarer Zustand - Der mögliche AD-Nachfolger muss kleiner sein als der FD der aktuellen Nachfolgeroute. </li></ul><br>  Um zu erklären, wie alles funktioniert, und die Feinheiten anzuzeigen, müssen Sie einige Metriken ändern.  Lassen Sie uns Folgendes tun und die Verzögerung so ändern, dass wir solche Verbindungsmetriken haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/678/c11/c2b/678c11c2b0f9b1dabb87a01ac62ff9e4.jpg" alt="Mein bild"><br><br>  Dies erfolgt mit dem Befehl delay auf der Schnittstelle.  Jetzt haben wir gesagt - delay = 1 und die Metrik ist 256. Mal sehen, welche Metriken wir für das Netzwerk 192.168.5.0/24 auf dem vIOS1-Router erhalten: <br><br><ul><li>  Über vIOS2 - FD = 2304, AD = 1280 </li><li>  Über vIOS4 - FD = 1024, AD = 768 </li><li>  Über vIOS3 - FD = 1536, AD = 768 </li></ul><br>  Da wir sehen, dass die beste FD für die Route durch vIOS4 ist, wird sie der allgemeinen Routing-Tabelle hinzugefügt. Diese Route heißt <b>Nachfolger</b> : <br><blockquote>  vIOS1 # show ip route eigrp <br>  Codes: L - lokal, C - verbunden, S - statisch, R - RIP, M - mobil, B - BGP <br>  D - EIGRP, EX - EIGRP extern, O - OSPF, IA - OSPF Interbereich <br>  N1 - OSPF NSSA externer Typ 1, N2 - OSPF NSSA externer Typ 2 <br>  E1 - OSPF externer Typ 1, E2 - OSPF externer Typ 2 <br>  i - IS-IS, su - IS-IS-Zusammenfassung, L1 - IS-IS-Ebene 1, L2 - IS-IS-Ebene 2 <br>  ia - IS-IS-Zwischenbereich, * - Standardkandidat, U - statische Route pro Benutzer <br>  o - ODR, P - periodisch heruntergeladene statische Route, H - NHRP, l - LISP <br>  a - Anwendungsweg <br>  + - replizierte Route,% - Überschreibung des nächsten Hops, p - Überschreibungen von PfR <br><br>  Das Gateway des letzten Auswegs ist nicht festgelegt <br><br>  D 192.168.2.0/24 [90/512] über 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] über 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 </blockquote><br>  Was passiert mit den beiden anderen Routen? Sie werden auf den FS-Zustand (Machbarer Zustand) überprüft.  Die Route durch vIOS3 besteht diese Bedingung AD (über vIOS3) = 768 &lt;1024 = FD (über vIOS1).  Daher wird diese Route, obwohl sie nicht zur allgemeinen Routing-Tabelle hinzugefügt wird, in den Topologietabellen gespeichert: <br><blockquote>  vIOS1 # show ip eigrp topology <br>  EIGRP-IPv4-Topologietabelle für AS (1) / ID (192.168.1.1) <br>  Codes: P - Passiv, A - Aktiv, U - Update, Q - Abfrage, R - Antwort, <br>  r - Antwortstatus, s - sia Status <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  über 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  über 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 768 <br>  über Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 768 <br>  über 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 512 <br>  über Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 768 <br>  über Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 2 <br>  <b>P 192.168.5.0/24, 1 Nachfolger, FD ist 1024</b> <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  <b>über 192.168.13.3 (1536/768), GigabitEthernet0 / 0</b> </blockquote><br>  Es hat nicht die Metrik der besten Route, das heißt, es ist kein Nachfolger, aber es spielt die Rolle einer Sicherungsroute und tritt sofort an seine Stelle, wenn der Nachfolger verloren geht.  Dies erreicht eine sehr schnelle Konvergenz des Protokolls, aber dazu später mehr.  Diese Route wird als <b>machbarer Nachfolger bezeichnet</b> .  Und was wird mit der dritten Route passieren?  Nichts, es erfüllt nicht die FC-Bedingung (1280&gt; 1024) und wird nicht berücksichtigt, um es vor Schleifen zu schützen.  Alle Routen, die über Update empfangen, aber nicht von FC getestet wurden, können mit dem Befehl show ip eigrp topology all-links angezeigt werden.  Es ist nicht klar, warum die FS-Bedingung vor der Bildung von Schleifen schützt. Versuchen wir nun zu erklären.  Es ist wichtig zu wissen, dass es beim Studium des EIGRP-Protokolls wichtig ist, das Prinzip der FC-Bedingung und den Zweck, für den es verwendet wird, zu verstehen.  Betrachten Sie eine leicht modifizierte Topologie (eine Verknüpfung zwischen vIOS2 und vIOS4 wurde hinzugefügt) und verwenden Sie auch die primitivste Metrik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/050/472/7340504727cf56fa62300883800f363f.jpg" alt="Mein bild"><br><br>  Die Route zum Netzwerk 192.168.5.0/24 ist bei AD und FD dieselbe: <br><br><ul><li>  vIOS4 - über vIOS5, AD = 5, FD = 10. </li><li>  vIOS1 - über vIOS4, AD = 10, FD = 11. </li><li>  vIOS3 - über vIOS1, AD = 11, FD = 12. </li></ul><br>  VIOS4 erhält jedoch ein Update von vIOS2, das die Route zum Netzwerk 192.168.5.0/24 über vIOS2 mit der Metrik AD = 12, FD = 15 enthält.  Es ist klar, dass es kein Nachfolger sein kann. Wenn diese Route plötzlich vom realisierbaren Nachfolger ausgewählt würde, würde eine Schleife auftreten, wenn der Nachfolger auf vIOS4 fällt und der Nachfolger diese Route wählt.  FC erlaubt es jedoch nicht, diese Route als FS als AD = 12&gt; 10 = FD festzulegen.  Die Route zu vIOS2 enthält den Pfad durch vIOS4, und in jedem Fall enthält die AD auch FD vIOS4.  Das heißt, AD unter vIOS2 enthält die folgenden Links: <br><blockquote>  12 = AD auf vIOS2 = Gi0 / 3 vIOS3 + Gi0 / 2 vIOS4 + Gi0 / 1 vIOS5 + eth0 VPC5, wobei Gi0 / 1 vIOS5 + eth0 VPC5 = FD = 10 - dies ist FD vIOS4 und es ist unmöglich, dass AD &lt;FD ist weniger. </blockquote><br>  Somit überprüft die Bedingung FC die Route auf das Vorhandensein von sich selbst in dieser Route.  Nur Routen, die diese Bedingung erfüllen, können garantieren, dass keine Schleifen vorhanden sind.  Es kann Fälle geben, in denen die Route keine Schleife erstellt, aber gleichzeitig die FC-Bedingung nicht erfüllt. Wir werden sie nicht verwenden. In solchen Fällen wählen wir die Netzwerkstabilität.  Wenn Sie sich damit beschäftigen, ist die Bedingung recht einfach und intuitiv.  Der Algorithmus, der die besten Routen im EIGRP-Protokoll auswählt, heißt <b>DUAL</b> .  Betrachten Sie nun das EIGRP-Protokoll zur Frage der Konvergenz beim Verlust der Hauptroute.  Kehren wir zu unserer alten großen Topologie zurück und stellen uns vor, dass vIOS4 weg ist.  Abhängig davon, wie vIOS4 verloren gegangen ist, unterscheidet sich das Verhalten geringfügig, es unterscheidet sich jedoch, wenn der Trigger ausgelöst wird.  Wenn wir beispielsweise die Gi 0/2-Schnittstelle auf vIOS1 deaktivieren, erkennt vIOS1 sofort den Verlust eines Nachbarn und beginnt zu handeln. Wenn der Nachbar ohne Vorwarnung verschwindet, funktioniert der Hold Timer, nachdem er 15 Sekunden lang keine Hello-Pakete empfangen hat: <br><blockquote>  D 192.168.2.0/24 [90/512] über 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] über 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] über 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  über 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  über 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 768 <br>  über Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 768 <br>  über 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 512 <br>  über Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 768 <br>  über Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  über Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 1 Nachfolger, FD ist 1024 <br>  über 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  über 192.168.13.3 (1536/768), GigabitEthernet0 / 0 </blockquote><br>  Ich habe die Routing- und Topologietabelle der Einfachheit halber noch einmal gebracht. Um zu verstehen, wie sich der Router auf jeder Route verhält, müssen Sie wissen, in welchem ​​Zustand sie sich zuvor befanden.  Beispielsweise geht die zuvor besprochene Route, die Route 192.168.5.0/24, verloren, hatte jedoch FS in der Topologietabelle und wird daher, sobald die Hauptroute verloren geht, ihren Platz in der Routing-Tabelle einnehmen.  Eine interessante Frage ist, was mit Routen ohne FS passieren wird.  Aber ein bisschen Hardware: <br><br>  Einträge in der Topologietabelle können in zwei Zuständen vorliegen: aktiv und passiv.  Die Route befindet sich in einem passiven Zustand, wenn die Route stabil ist und die Suche nach der besten Route nicht erfolgt.  Im aktiven Zustand - wenn Sie nach der besten Route suchen.  Eine Routensuche wird durchgeführt, wenn es keinen realisierbaren Nachfolger für das Zielnetz gibt.  Der Router sendet auf der Suche nach einer besseren Route eine Anfrage (sendet ein Abfragepaket) an jeden benachbarten Router.  Wenn der Nachbar eine Route zum Zielnetzwerk hat, antwortet er (sendet ein Antwortpaket). Wenn keine Route vorhanden ist, sendet der Nachbar eine Anfrage an seine Nachbarn.  Der Router vergleicht alle FDs, um ein bestimmtes Netzwerk zu erreichen, wählt die Route mit dem kleinsten FD aus und platziert sie in der Routing-Tabelle.  In der Topologietabelle können 6 Routen zum Netzwerk des Empfängers (primär und Backup) gespeichert werden. <br><br>  Routen, die verloren gegangen sind und kein FS hatten, wechseln zu Aktiv und vIOS1 fragt nach den verbleibenden Nachbarn.  Dies erfolgt mithilfe von Abfragenachrichten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 sendet Abfragenachrichten an vIOS2- und vIOS3-Router, wo klar angegeben wird, welche Routen benötigt werden. In unserem Fall sind diese Routen 192.168.14.0/24, 192.168.45.0/24. Mit dieser Nachricht informiert vIOS1 die Router auch darüber, dass Routen über vIOS1 zu diesen Netzwerken unbrauchbar sind. Dies erfolgt durch Angabe des Parameters Delay: Infifnity in der Metrik dieser Route, dh die Metrik ist unendlich groß. Sobald Router solche Nachrichten erhalten, löschen sie diese Routen über vIOS1. Diese Technologie heißt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Poison Reverse wird auch für Update-Nachrichten verwendet. Ich werde etwas später darauf eingehen. Nach Erhalt einer Abfrage mit einer Anforderung für die Routen 192.168.14.0/24, 192.168.45.0/24 sehen vIOS2 und vIOS3, ob sie über diese Routen verfügen, die sie gegebenenfalls verwenden, und senden sofort eine Antwort mit neuen Metriken für diese Routen. Wie wir wissen, haben vIOS2 und vIOS3 ihre Routen nicht verloren, daher senden sie sofort eine Antwort. Wenn der ebenfalls abgefragte Router diese Route nicht hat, leitet er die Abfrage an seine Nachbarn weiter und so weiter. vIOS1 wartet auf die Antwort von vIOS2, vIOS3 und dann tritt Active Timer in die Szene ein, die startet, sobald eine Abfrage gesendet wird: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- das Zeitintervall, in dem die Route im aktiven Zustand bleiben kann. Wenn der Timer abläuft, bevor alle Antworten von Nachbarn empfangen wurden (Antwort), versetzt der Router die Route in den Status "Nicht aktiv". Außerdem sind die Beziehungen der Nachbarschaft zu den Nachbarn unterbrochen, von denen keine Antwort erhalten wurde. Standardmäßig beträgt dieser Timer 3 Minuten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, wenn die Antwort trotz der Hello-Pakete nicht innerhalb von 3 Minuten eingeht, wird die Nachbarschaft unterbrochen und dies ist sehr schlecht. Trotz der Tatsache, dass 3 Minuten für solche Protokolle wie eine Ewigkeit sind, sind solche Situationen mit großen Topologien möglich. Zum Schutz vor fehlerhafter Trennung der Nachbarschaftsbeziehung wurden spezielle Nachrichten erfunden - SIA-Query und SIA-Reply.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Reaktion des Routers auf den Status der aktiven Route zu verbessern, werden zusätzlich zwei Arten von Nachrichten eingeführt: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Abfrage - Wird nach 1,5 Minuten versendet (Standard), um den Status eines direkt verbundenen Routers zu überprüfen. </font><font style="vertical-align: inherit;">Wenn die Route hinter dem Nachbarn verloren geht (während die Verbindung zum Nachbarn normal ist), werden die Nachbarschaftsbeziehungen zum direkt verbundenen Router nicht zurückgesetzt. </font><font style="vertical-align: inherit;">Erfordert keine Empfangsbestätigung. </font><font style="vertical-align: inherit;">Nachdem drei Nachrichten gesendet und keine Antwort empfangen wurden, wird der Nachbar als ausgefallen betrachtet und die Route aus der Topologietabelle entfernt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Antwort - Wird als Antwort auf die SIA-Abfrage gesendet. </font><font style="vertical-align: inherit;">Erfordert keine Empfangsbestätigung.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nach 1,5 Minuten keine Antwort auf eine Anfrage empfangen wird, wird eine SIA-Anfrage gesendet, für die keine neue Route erforderlich ist, sondern nur eine SIA-Antwort gesendet werden muss, um sicherzustellen, dass der Nachbar in Ordnung ist. Sie kann einfach nicht die richtige finden Route </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke darüber nach, wie der Router auf den Verlust der Route reagiert, wenn FS vorhanden ist oder nicht, haben wir genug gesagt. Es ist nur erforderlich, folgende Änderungen vorzunehmen. Wir haben FD nicht ganz richtig definiert, die Metrik, die wir nach der Formel berechnen, wenn wir zum ersten Mal eine Route erhalten oder wenn sich der Routenstatus weiter ändert. Es wäre richtig, CD - Computed Distance aufzurufen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD ist der beste Indikator für eine bestimmte Route, die jemals erhalten wurde, und er ist es, der am FC-Check teilnimmt. </font><font style="vertical-align: inherit;">Meistens ist FD = CD die beste Route, aber lassen Sie uns sehen, wie sich FD nach dem Zusammenbruch der Nachbarschaft mit vIOS4 verändert hat:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, FD ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1536</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768) ist </font><font style="vertical-align: inherit;">, GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben keine Route mehr mit CD = 1024, die beste Route durch vIOS3 ist CD = 1536, aber wie Sie sehen können, ist FD = 1024, die behoben wurde, als es eine Route durch vIOS4 gab. </font><font style="vertical-align: inherit;">FD wird nur aktualisiert, wenn diese Route in den aktiven Zustand versetzt wird. </font><font style="vertical-align: inherit;">Bis sich der Status von Passiv zu Aktiv ändert, ändert sich auch FD nicht. </font><font style="vertical-align: inherit;">Regelmäßige Updates gelten nicht dafür. </font><font style="vertical-align: inherit;">Noch eine Bemerkung. </font><font style="vertical-align: inherit;">Lassen Sie uns dieses Experiment durchführen: Geben Sie die Nachbarschaft mit vIOS4, CD über vIOS3 = 1536 und über vIOS2 = 2048 zurück. Erhöhen Sie die Kanalverzögerung zwischen vIOS1 und vIOS3, sodass sie größer als die vIOS2-CD wird:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, ist FD 1024 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2304</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768) ist </font><font style="vertical-align: inherit;">, GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir sehen, ist die CD durch vIOS3 = 2304, aber sie blieb FS, da sich AD nicht geändert hat und die FC-Bedingung wie zuvor erfüllt war. </font><font style="vertical-align: inherit;">Wir stellen uns eine Frage: Was passiert, wenn eine Route durch vIOS2 verloren geht? </font><font style="vertical-align: inherit;">Die erwartete und logische Antwort, wie uns beigebracht wurde, ist stattdessen FS, aber nein! </font><font style="vertical-align: inherit;">Da es immer noch eine Route durch vIOS2 mit CD = 2048 &lt;2304 gibt, wird die Route in den aktiven Status versetzt und berechnet die Metrik dafür neu und wählt die beste Route aus, obwohl sie eine Sicherungsroute hatte. </font><font style="vertical-align: inherit;">Wir schauen uns die Topologietabelle an und erhalten:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD ist 2048</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über 192.168.12.2 (2048/1280), GigabitEthernet0 / 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über 192.168.13.3 (2304/768), GigabitEthernet0 / 0</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Route über vIOS2 wird verwendet und hat sich, wie von FD angegeben, auch aufgrund des Übergangs der Route in den aktiven Zustand geändert. </font><font style="vertical-align: inherit;">Und die Route durch vIOS3 teilt wieder das Schicksal des Ersatzteils.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regeln für geteilten Horizont und Giftumkehr in EIGRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in RIP verwendet EIGRP die Split Horizon-Regel. Wenn eine Route über eine bestimmte Schnittstelle erreichbar ist, ist diese Route nicht in dem Update enthalten, das über diese Schnittstelle gesendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn vIOS4 beispielsweise eine Route zum Netzwerk 192.168.0.0/24 von vIOS1 empfängt, sendet es diese Route nicht über die Schnittstelle, mit der vIOS1 verbunden ist, an Update. Stellen Sie sich genauer gesagt vor, dass vIOS1 über das Netzwerk 192.168.0.0/24 gesprochen hat. Ich habe ein Update an vIOS4 gesendet, vIOS4 wird es empfangen, und Split Horizon sollte sein Update in der Regel nicht mit dieser Route an vIOS1 senden, aber in Wirklichkeit wird es mit einer unendlichen Metrik gesendet. Als ob vIOS4 vIOS1 sagt - "Wagen Sie es nicht, die Route zum Netzwerk 192.168.0.0/24 über mich zu verwenden, ich habe diese Route von Ihnen erhalten, und wenn Sie sie verwenden, wird es eine Schleife geben."</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse - Zeigt eine nicht erreichbare Route mithilfe einer Metrik an, wenn sie verloren geht. </font><font style="vertical-align: inherit;">In EIGRP erfolgt dies mit dem Parameter Delay. </font><font style="vertical-align: inherit;">Wir haben oben angegeben, wie diese Technologie verwendet wird, wenn vIOS1 den Kontakt zu vIOS4 verliert. </font><font style="vertical-align: inherit;">Aus den obigen Ausführungen zu Split Horizon können wir schließen, dass die Poison Reverse-Technologie nicht nur in Abfragenachrichten, sondern auch in Updates verwendet wird. </font><font style="vertical-align: inherit;">Außerdem verstößt Poison Reverse möglicherweise gegen die Split Horizon-Regel und sendet ein Update mit unendlichen Metriken von der Schnittstelle, von der es dieses Update erhalten hat. </font><font style="vertical-align: inherit;">Diese beiden Regeln bieten zusammen mit der FC-Klausel einen Schutz des EIGRP-Protokolls gegen Schleifen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stub-Router </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Optimierung wurde im Protokoll eine spezielle Rolle für Router eingeführt - Stub. </font><font style="vertical-align: inherit;">So etwas wie die Stub-Zone in OSPF, aber hier ist ein etwas anderes Funktionsprinzip. </font><font style="vertical-align: inherit;">Wenn der Router im Stub-Modus konfiguriert wird, meldet er seinem Nachbarn sofort in Hello-Paketen seinen Stub-Status und kann je nach Stub-Modus bestimmte Routentypen senden:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS5 # eigrp stub [verbunden | </font><font style="vertical-align: inherit;">Leckkarte | </font><font style="vertical-align: inherit;">Nur empfangen | </font><font style="vertical-align: inherit;">umverteilt | </font><font style="vertical-align: inherit;">statisch | </font><font style="vertical-align: inherit;">Zusammenfassung]</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eigrp-Stub-Befehlsoptionen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ohne Optionen (Standard) - verbunden und Zusammenfassung; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verbunden - Ermöglicht dem Stub-Router, verbundene Routen zu senden, jedoch nur für Schnittstellen, deren Adressen sich in den durch den Netzwerkbefehl angegebenen Netzwerken befinden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leckkarte - Erlaubt dynamische Präfixe basierend auf der Leckkarte; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur empfangen - Verhindert, dass der Stub-Router Routen sendet. </font></font></li><li> redistributed —  stub   redistributed ; </li><li> static —  stub   static ,  ,      ; </li><li> summary —  stub     (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptmerkmal dieser Einstellung ist jedoch, dass der Router, wenn er weiß, dass sich sein Nachbar in der Stub-Rolle befindet, keine Abfrage für aktiv gewordene Routen an ihn sendet. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise vIOS5 als Stub konfigurieren, wird vIOS2-4 dies herausfinden und wenn Routen verloren gehen, werden sie Query nicht vergiften. </font><font style="vertical-align: inherit;">In Anbetracht der Probleme, die auftreten können, wenn keine Antwort vorliegt, wäre es hilfreich, eine Abfrage nur dort zu senden, wo dies sinnvoll ist. </font><font style="vertical-align: inherit;">Dies ist in großen Topologien wichtig, in denen Konvergenz ein komplexer Prozess sein kann. </font><font style="vertical-align: inherit;">Wenn es also einen Router gibt, der endgültig ist und nur Benutzernetzwerke mit ihm verbunden sind (relativ gesehen hat er nur einen Nachbarn), ist es besser, darüber nachzudenken, ihn als Stub einzurichten.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein paar Worte zu Timern </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben über einige von ihnen gesprochen. Wenn Sie sich die Ausgabe des Befehls show ip eigrp neighbours ansehen, sehen wir Folgendes: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 # show ip eigrp Nachbarn </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIGRP-IPv4 Nachbarn für AS (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressschnittstelle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haltezeit </font><font style="vertical-align: inherit;">SRTT </font><font style="vertical-align: inherit;">RTO Q Seq </font><font style="vertical-align: inherit;">(Sek.) (ms) Cnt Num </font><font style="vertical-align: inherit;">2 192.168.14.4 Gi0 / 2 11 00:48:43 23 138 0 168 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 192.168.12.2 Gi0 / 3 12 02:31:12 6 100 0 258 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 192.168.13.3 Gi0 / 0 10 2d13h 7 100 0 291 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 #</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind Timer, die einer Erklärung bedürfen. </font><font style="vertical-align: inherit;">Wenn als Antwort auf das Senden eines Multicast-Pakets, für das eine Empfangsbestätigung erforderlich ist, keine Bestätigung (ACK) gesendet wurde, wird das Unicast-Paket an den Nachbarn gesendet, der nicht antwortet. </font><font style="vertical-align: inherit;">Wenn die Bestätigung auch nach dem Senden von 16 Unicast-Paketen nicht empfangen wurde, gilt der Nachbar als inaktiv.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Roundtrip-Zeit (SRTT)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die Zeit zwischen dem Senden eines Pakets an einen Nachbarn und dem Empfangen einer Bestätigung von ihm. </font><font style="vertical-align: inherit;">Gemessen in Millisekunden. </font><font style="vertical-align: inherit;">Die Berechnungsformel ist proprietär.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast Flow Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Maximalwert des Intervalls in Sekunden, in dem der Router nach dem Senden des EIGRP-Pakets an die Multicast-Adresse auf das ACK-Paket wartet, bevor er zum Unicast-Senden wechselt. </font><font style="vertical-align: inherit;">Es wird auf Basis von SRTT berechnet, die Berechnungsformel selbst ist proprietär.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTO (Retransmission Timeout) - das</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intervall zwischen dem Senden von Unicast-Paketen. </font><font style="vertical-align: inherit;">Es wird auf Basis von SRTT berechnet, die Berechnungsformel selbst ist proprietär.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daran denke ich, um den Artikel zu beenden. </font><font style="vertical-align: inherit;">Unten ist ein nützlicher Link:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cisconinja.wordpress.com/2009/09/18/eigrp-sia-query-and-sia-reply </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru/wiki/EIGRP</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=FYUK7blhCZk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Webinar über EIGRP für ungefähr viereinhalb Stunden. </font><font style="vertical-align: inherit;">Erforderlich zum Anzeigen)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html#anc9</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420667/">https://habr.com/ru/post/de420667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420657/index.html">Analyse: Auf wessen Geld kann Elon Musk Tesla vom Umtausch abheben</a></li>
<li><a href="../de420659/index.html">USB-Kampagne der HRF (Human Rights Foundation) „Flash Drives for Freedom“</a></li>
<li><a href="../de420661/index.html">Kontinuierliche Cloud-Infrastruktur</a></li>
<li><a href="../de420663/index.html">Einfache Metriken und eine Möglichkeit, Zeit zu sparen, wenn Sie nach Problemen in der Infrastruktur suchen</a></li>
<li><a href="../de420665/index.html">Erstellen einer Anwendung auf .NET Core und Kubernetes: Unsere Erfahrung</a></li>
<li><a href="../de420669/index.html">Marktüberblick über Enterprise Automation: Lösungen für Bau- und Verwaltungsunternehmen für Wohnungsbau und Versorgungsunternehmen</a></li>
<li><a href="../de420671/index.html">[Ekaterinburg, Ankündigung] UralJS # 9 - drei Berichte über Microservices, Tests und Fehlerprotokollierung an der Vorderseite</a></li>
<li><a href="../de420673/index.html">Docker für Symfony 4 - vom LAN bis zur Produktion</a></li>
<li><a href="../de420675/index.html">SOC sind Menschen. „Hallo, wir suchen Talente“ oder woher kommen die Analysten des Überwachungs- und Reaktionszentrums für Cyberangriffe</a></li>
<li><a href="../de420677/index.html">Die Geschichte, wie Epson den Planeten mit 30 Millionen "Fabriken" versorgte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>