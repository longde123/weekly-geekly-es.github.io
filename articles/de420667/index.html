<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≤Ô∏è üê≤ üë®üèΩ‚Äçü§ù‚Äçüë®üèº Funktionsprinzipien des EIGRP-Protokolls üë®üèº‚Äç‚öñÔ∏è üë©üèª üë∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird √ºber EIGRP gesprochen und die Funktionsweise dieses Protokolls erl√§utert. EIGRP ist ein Distanzvektorprotokoll, manchmal wird e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsprinzipien des EIGRP-Protokolls</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420667/"> In diesem Artikel wird √ºber EIGRP gesprochen und die Funktionsweise dieses Protokolls erl√§utert.  EIGRP ist ein Distanzvektorprotokoll, manchmal wird es als Hybrid bezeichnet, aber das ist es nicht.  Lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfang des Artikels</a> √ºber OSPF und Sie werden verstehen, warum EIGRP ein Remote-Vektorprotokoll ist.  EIGRP ist ein fortschrittliches dynamisches Routing-Protokoll f√ºr Distanzvektoren, das von Cisco entwickelt wurde.  Lass es uns richtig machen.  Wir werden die folgende Topologie verwenden: <br><br><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ed/cbb/733/4edcbb7335c70442a6ad9c1e4754e851.jpg" alt="Mein bild"></a> <a name="habracut"></a><br><br>  F√ºhren Sie EIGRP auf vIOS1 und vIOS2 aus und sehen Sie, wie Informationen zwischen Routern √ºbertragen werden.  Sobald EIGRP auf dem Router aktiviert ist, beginnt der Router mit dem Senden von Hello-Paketen.  Wir listen auch andere Arten von Nachrichten auf, die in EIGRP verwendet werden. <br><br><ul><li>  Hallo - Router verwenden Hallo-Pakete, um Nachbarn zu entdecken.  Multicast-Pakete werden gesendet und erfordern keine Empfangsbest√§tigung. </li><li>  Update - enth√§lt Informationen zum √Ñndern von Routen.  Sie werden nur an die vom Update betroffenen Router gesendet.  Diese Pakete k√∂nnen an einen bestimmten Router (Unicast) oder eine Gruppe von Routern (Multicast) gesendet werden.  Der Empfang eines Update-Pakets wird durch Senden eines ACK best√§tigt. </li><li>  Abfrage - Wenn der Router die Route berechnet und keinen realisierbaren Nachfolger hat, sendet er ein Abfragepaket an seine Nachbarn, um festzustellen, ob sie einen realisierbaren Nachfolger f√ºr dieses Ziel haben.  In der Regel werden Abfragepakete per Multicast gesendet, es kann jedoch Unicast geben.  Der Empfang des Abfragepakets wird durch Senden der ACK durch den Paketempf√§nger best√§tigt. </li><li>  Antwort - Der Router sendet ein Antwortpaket als Antwort auf das Abfragepaket.  Antwortpakete werden Unicast an denjenigen gesendet, der das Abfragepaket gesendet hat.  Der Empfang eines Antwortpakets wird durch Senden einer Best√§tigung best√§tigt. </li><li>  ACK - ein Paket, das den Empfang von Aktualisierungs-, Abfrage- und Antwortpaketen best√§tigt.  ACK-Pakete werden Unicast gesendet und enthalten eine Best√§tigungsnummer.  In der Tat sind dies Hallo-Pakete, die keine Daten √ºbertragen.  Es wird eine nicht garantierte Lieferung verwendet. </li></ul><br>  Es gibt auch SIA-Pakete, aber wir werden unten dar√ºber sprechen. <br>  Pakete werden alle 5 Sekunden an die Multicast-Adresse 224.0.0.10 gesendet (Hallo Timer). Der Hold-Timer betr√§gt 15 Sekunden = 3 Hallo-Intervalle. Wenn w√§hrend dieses Timers keine Hallo-Pakete von einem Nachbarn empfangen wurden, wird der Nachbar aus der Liste der Nachbarn entfernt.  Das Paket sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/144/cd2/7a5/144cd27a50a78ca0aeb70c7e4b15cfae.jpg" alt="Mein bild"><br><br>  Das Paket enth√§lt die Parameter der Koeffizienten (K1, K2, K3, K4, K5, K6), den Hold-Timer und die Nummer des autonomen Systems.  Bei der Berechnung der Metrik werden Koeffizienten (K1, K2, K3, K4, K5, K6) verwendet, auf die wir sp√§ter noch eingehen werden, sowie EIGRP-Timer.  Jetzt ist es wichtig, √ºber das Autonome System (AS) zu sprechen.  Um EIGRP zu aktivieren, muss einem bestimmten EIGRP-Prozess wie in OSPF eine Nummer zugewiesen werden.  Im Gegensatz zu OSPF kann diese Option jedoch nicht f√ºr jeden Router zuf√§llig ausgew√§hlt werden, sondern muss f√ºr alle Router gleich sein.  Wenn der Router ein Hello-Paket mit einem anderen AS empf√§ngt, besteht keine Nachbarbeziehung. <br><br>  Damit Router Nachbarn werden k√∂nnen, m√ºssen folgende Bedingungen erf√ºllt sein: <br><br><ul><li>  Router m√ºssen authentifiziert sein, </li><li>  Router m√ºssen sich im selben AS befinden, </li><li>  Nachbarschaftsbeziehungen sollten an prim√§ren Adressen hergestellt werden (wenn ein Hallo-Paket eintrifft, pr√ºft der Router, ob die Absenderadresse des Netzwerks zur prim√§ren Adresse der Schnittstelle geh√∂rt). </li><li>  Werte der K-Koeffizienten m√ºssen √ºbereinstimmen. </li></ul><br>  Damit Router zu EIGRP-Nachbarn werden k√∂nnen, m√ºssen sie nicht mit der Hello- und Hold-Zeit √ºbereinstimmen.  Der Router verwendet vom Nachbarn empfangene Timerwerte.  Wenn der Hello- oder Hold-Timer auf einem der Router ge√§ndert wird, verwenden die Nachbarn dieses Routers diese Werte.  Damit der Router andere Werte verwenden kann, muss der Timer an der entsprechenden Schnittstelle des Nachbarn ge√§ndert werden.  Nach dem Austausch von Hello-Paketen wird ein Update-Paket gesendet, das jedoch noch keine Routen enth√§lt. Es enth√§lt das Init-Flag, das den Routern den Beginn des Informationsaustauschs √ºber Routen mitteilt.  Dieses Paket wird direkt an die Adresse des Routers gesendet.  Nach dem Austausch solcher Nachrichten sendet jeder Router ein Aktualisierungspaket mit Routen an die Multicast-Adresse 224.0.0.10: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/0da/c1c/dd90dac1c80680d40681289160f1898b.jpg" alt="Mein bild"><br><br>  Wie Sie sehen k√∂nnen, enth√§lt das Update-Paket keine Metrik, sondern nur Informationen wie Bandbreite, Verz√∂gerung, MTU usw. Nachdem der Router diese Informationen erhalten hat, berechnet er die Metrik selbst anhand der K1-K6-Koeffizienten.  Diese Pakete k√∂nnen entweder an einen bestimmten Router oder an einen Multicast gesendet werden.  Im Allgemeinen gibt es drei Arten von Updates: <br><br><ul><li>  Nicht periodisch (nicht periodisch) - Aktualisierungen werden nicht in regelm√§√üigen Abst√§nden gesendet, sondern wenn sich die Topologie oder Metrik √§ndert. </li><li>  Teilweise (teilweise) - Nicht alle Informationen aus der Routing-Tabelle werden in Aktualisierungen √ºbertragen, sondern nur √Ñnderungen. </li><li>  Begrenzt - Updates werden nur an die beteiligten Router gesendet. </li></ul><br>  Nachbarschaften auf Paketebene sehen folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/588/fe6/68a588fe6adbe793d98c2b57b7da301e.jpg" alt="Mein bild"><br><br>  M√∂glicherweise stellen Sie fest, dass es neben dem von uns aufgelisteten Hello und Update auch Hello (ACK) gibt und die Anzahl der Anzahl der an die Multicast-Adresse gesendeten Update-Pakete entspricht.  Alles dreht sich um das RTP-Protokoll.  Das RTP-Protokoll steuert den Prozess der √úbertragung von EIGRP-Paketen und bietet: <br><br><ul><li>  Garantierte Paketzustellung. </li><li>  Beibehaltung der Reihenfolge der Pakete. </li></ul><br>  Das sind die Dinge.  Was haben wir  Routen ausgetauscht Aktualisieren Sie Pakete und jetzt ist es Zeit, eine Routing-Tabelle zu erstellen.  Jedes Update wird verarbeitet und Daten (Bandbreite, Verz√∂gerung usw.) durch eine spezielle Formel ersetzt. Die Metrik wird berechnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/0ab/062/cc60ab0622cbe1abb96521c2520b96ee.jpg" alt="Mein bild"><br><br>  Eine solche Formel sieht fantastisch aus, aber das Beste daran ist, dass Sie sie vielleicht nicht kennen, nur wissen, dass so etwas existiert.  Ein weiterer netter Trick ist, dass die Standard-EIGRP-Koeffizienten sind: <br><br><ul><li>  K1 = 1 </li><li>  K2 = 0 </li><li>  K3 = 1 </li><li>  K4 = 0 </li><li>  K5 = 0 </li></ul><br>  Und die Formel wird einfach zu Metrik = Bandbreite + Verz√∂gerung.  Daher ist es so wichtig, dass die Koeffizienten auf allen Routern gleich sind, damit es aufgrund unterschiedlicher Metriken auf den Routern keine Probleme gibt.  Lassen Sie uns etwas detaillierter √ºber die Daten in Update sprechen. <br><br><ul><li>  Bandbreite - Der Mindestwert unter den zum Netzwerk f√ºhrenden Bandbreitenkan√§len wird ausgew√§hlt und an Update gesendet. </li><li>  Verz√∂gerung - Fasst die Verz√∂gerung aller Kan√§le zusammen, die zu diesem Netzwerk f√ºhren. </li><li>  Zuverl√§ssigkeit - das schlechteste Ma√ü an Zuverl√§ssigkeit, basierend auf Keepalive </li><li>  Laden - der schlechteste Indikator f√ºr das vollst√§ndige Laden von Verbindungen, basierend auf der Paketrate und der konfigurierten Bandbreite auf der Schnittstelle </li><li>  MTU ist die kleinste MTU auf dem ganzen Weg.  Trotz der Tatsache, dass es in Update verwendet wird, nimmt es nicht an der Berechnung der Metrik selbst teil. </li></ul><br>  Wie oben erw√§hnt, werden standardm√§√üig Bandbreite und Verz√∂gerung verwendet.  Die √ºbrigen Parameter sind bei Bedarf selten erforderlich, mit deren Hilfe ist jedoch eine feinere Anpassung der Metrik m√∂glich.  Somit √ºbergibt der Router im Aktualisierungspaket die Route und die damit verbundenen Daten und √ºbertr√§gt die Metrik selbst nicht.  Der Router, der das Update erhalten hat, berechnet die Metrik gem√§√ü der Formel und entscheidet abh√§ngig von den Metriken, ob die Route an die Routing-Tabelle weitergeleitet werden soll oder nicht.  Es ist auch wichtig zu beachten, dass der <b>Router nur die Routen √ºbertr√§gt, die er verwendet.</b>  Mal sehen, wie man eine Topologietabelle erstellt. <br><br>  <b>Topologietabelle</b> - Eine Liste der Routen, die von jedem Nachbarn gelernt wurden.  In der Topologietabelle werden auch die Metrik gespeichert, die jeder Nachbar f√ºr jede Route (AD) meldet, und die Metrik, die der lokale Router verwendet, um die Route √ºber den Nachbarn (FD) zu erreichen. <br><br>  Es ist notwendig zu erkl√§ren, was AD und FD sind.  Wir werden EIGRP auf allen unseren Routern konfigurieren.  Um komplexe Zahlen in der Metrik zu vermeiden, √§ndern wir auch die Koeffizienten von K1 = 1 K2 = 0 K3 = 1 K4 = 0 K5 = 0 zu K1 = 0 K2 = 0 K3 = 1 K4 = 0 K5 = 0. Somit haben wir 256 * Verz√∂gerungsformel und wir erhalten auch eine einfache M√∂glichkeit, Metriken durch √Ñndern des Verz√∂gerungsparameters an den Schnittstellen zu manipulieren.  Wenn man bedenkt, dass bei Schnittstellen die Verz√∂gerung 1 Sekunde betr√§gt, kostet jede Verbindung, wenn Sie die OSPF-Terminologie verwenden, 256. Sehen wir uns die Topologietabelle unter vIOS1 an: <br><blockquote>  vIOS1 # show ip eigrp topology <br>  EIGRP-IPv4-Topologietabelle f√ºr AS (1) / ID (192.168.1.1) <br>  Codes: P - Passiv, A - Aktiv, U - Update, Q - Abfrage, R - Antwort, <br>  r - Antwortstatus, s - sia Status <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber 192.168.14.4 (512/256), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 3 Nachfolger, FD ist 768 <br>  √ºber 192.168.12.2 (768/512), GigabitEthernet0 / 3 <br>  √ºber 192.168.13.3 (768/512), GigabitEthernet0 / 0 <br>  √ºber 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Wenn Sie sich beispielsweise das Netzwerk 192.168.5.0/24 ansehen, werden Sie drei Pfade durch vIOS2, vIOS3 und vIOS4 mit denselben Metriken bemerken.  F√ºr 192.168.5.0/24 FD ist es f√ºr alle Pfade gleich - 768 und AD - 512. Geben wir eine Definition aus einem anderen Artikel und versuchen zu erkl√§ren: <br><br><ul><li>  <b>Die angek√ºndigte Entfernung (AD)</b> , auch als gemeldete Entfernung (RD) bezeichnet, sind die Kosten f√ºr die Entfernung zwischen dem benachbarten Router, der die Route ank√ºndigt, und dem Zielnetzwerk. </li><li>  <b>Machbare Entfernung (FD)</b> - die Kosten f√ºr die Entfernung vom lokalen Router zum Zielnetzwerk = AD, das den benachbarten Router ank√ºndigt + die Kosten f√ºr die Entfernung zwischen dem lokalen Router und dem benachbarten Router. </li></ul><br><blockquote>  P 192.168.5.0/24, 3 Nachfolger, FD ist 768 √ºber 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Lassen Sie uns diese Zeile aus der Topologietabelle auf vIOS1 untersuchen.  vIOS1 lernte die Route von vIOS4 (192.168.14.4) kennen.  Da vIOS1 drei Links von 192.168.5.0/24 trennt, lautet die FD-Metrik mit unseren Einstellungen 3 * 256 = 768.  Und AD ist die Routenmetrik relativ zum Router (vIOS4), der dieses Netzwerk angek√ºndigt hat.  AD ist die FD-Metrik dieser Route unter vIOS4.  Schauen wir uns die Topologietabelle unter vIOS4 an: <br><blockquote>  P 192.168.5.0/24, 1 Nachfolger, FD ist 512 √ºber 192.168.45.5 (512/256), GigabitEthernet0 / 1 </blockquote><br>  AD auf vIOS1 = FD auf vIOS4.  Lautlos verwirrend, aber versuchen Sie, die Logik der Arbeit zu erkl√§ren.  Der Router, der die Route ank√ºndigt, sendet die Parameter (Bandbreite, Verz√∂gerung usw.) der Route in der Aktualisierungsnachricht, ohne die Verbindung zwischen dem angek√ºndigten Router zu ber√ºcksichtigen.  Das hei√üt, vIOS4 ber√ºcksichtigt nur die Parameter von zwei Links: vIOS4 Gi0 / 1 - vIOS5 Gi0 / 1 und vIOS5 Gi0 / 0 - VPC.  Nach Erhalt des Updates berechnet vIOS1, das die erhaltenen Parameter in der Formel ersetzt, was?  Das stimmt - AD = 512.  Nachdem die Verbindungsparameter, von denen die Route stammt, vIOS1 Gi0 / 2 - vIOS4 Gi0 / 2 √ºbernommen und erneut in die Formel eingesetzt wurden.  Z√§hlt, bekommt die Nummer 256 und addiert sie mit AD (512), wir bekommen FD - 768. Das sind die Dinge!  Aber warum all dieses Ritual? <br>  Und das alles, um eine Sonderregel namens <b>Machbare Bedingung</b> zu schaffen, die eines der Mittel zum Schutz vor Schleifenbildung und schneller Konvergenz darstellt. <br>  Definieren wir folgende Begriffe: <br><br><ul><li>  Nachfolger ist ein benachbarter Router mit einem schleifenfreien Pfad und dem kosteng√ºnstigsten Pfad zum Zielnetzwerk. </li><li>  Machbarer Nachfolger - Backup-Router mit Pfad ohne Schleifen (AD machbarer Nachfolger sollte kleiner als FD der aktuellen Nachfolgeroute sein). </li><li>  Machbarer Zustand - Der m√∂gliche AD-Nachfolger muss kleiner sein als der FD der aktuellen Nachfolgeroute. </li></ul><br>  Um zu erkl√§ren, wie alles funktioniert, und die Feinheiten anzuzeigen, m√ºssen Sie einige Metriken √§ndern.  Lassen Sie uns Folgendes tun und die Verz√∂gerung so √§ndern, dass wir solche Verbindungsmetriken haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/678/c11/c2b/678c11c2b0f9b1dabb87a01ac62ff9e4.jpg" alt="Mein bild"><br><br>  Dies erfolgt mit dem Befehl delay auf der Schnittstelle.  Jetzt haben wir gesagt - delay = 1 und die Metrik ist 256. Mal sehen, welche Metriken wir f√ºr das Netzwerk 192.168.5.0/24 auf dem vIOS1-Router erhalten: <br><br><ul><li>  √úber vIOS2 - FD = 2304, AD = 1280 </li><li>  √úber vIOS4 - FD = 1024, AD = 768 </li><li>  √úber vIOS3 - FD = 1536, AD = 768 </li></ul><br>  Da wir sehen, dass die beste FD f√ºr die Route durch vIOS4 ist, wird sie der allgemeinen Routing-Tabelle hinzugef√ºgt. Diese Route hei√üt <b>Nachfolger</b> : <br><blockquote>  vIOS1 # show ip route eigrp <br>  Codes: L - lokal, C - verbunden, S - statisch, R - RIP, M - mobil, B - BGP <br>  D - EIGRP, EX - EIGRP extern, O - OSPF, IA - OSPF Interbereich <br>  N1 - OSPF NSSA externer Typ 1, N2 - OSPF NSSA externer Typ 2 <br>  E1 - OSPF externer Typ 1, E2 - OSPF externer Typ 2 <br>  i - IS-IS, su - IS-IS-Zusammenfassung, L1 - IS-IS-Ebene 1, L2 - IS-IS-Ebene 2 <br>  ia - IS-IS-Zwischenbereich, * - Standardkandidat, U - statische Route pro Benutzer <br>  o - ODR, P - periodisch heruntergeladene statische Route, H - NHRP, l - LISP <br>  a - Anwendungsweg <br>  + - replizierte Route,% - √úberschreibung des n√§chsten Hops, p - √úberschreibungen von PfR <br><br>  Das Gateway des letzten Auswegs ist nicht festgelegt <br><br>  D 192.168.2.0/24 [90/512] √ºber 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] √ºber 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 </blockquote><br>  Was passiert mit den beiden anderen Routen? Sie werden auf den FS-Zustand (Machbarer Zustand) √ºberpr√ºft.  Die Route durch vIOS3 besteht diese Bedingung AD (√ºber vIOS3) = 768 &lt;1024 = FD (√ºber vIOS1).  Daher wird diese Route, obwohl sie nicht zur allgemeinen Routing-Tabelle hinzugef√ºgt wird, in den Topologietabellen gespeichert: <br><blockquote>  vIOS1 # show ip eigrp topology <br>  EIGRP-IPv4-Topologietabelle f√ºr AS (1) / ID (192.168.1.1) <br>  Codes: P - Passiv, A - Aktiv, U - Update, Q - Abfrage, R - Antwort, <br>  r - Antwortstatus, s - sia Status <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  √ºber 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  √ºber 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 2 <br>  <b>P 192.168.5.0/24, 1 Nachfolger, FD ist 1024</b> <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  <b>√ºber 192.168.13.3 (1536/768), GigabitEthernet0 / 0</b> </blockquote><br>  Es hat nicht die Metrik der besten Route, das hei√üt, es ist kein Nachfolger, aber es spielt die Rolle einer Sicherungsroute und tritt sofort an seine Stelle, wenn der Nachfolger verloren geht.  Dies erreicht eine sehr schnelle Konvergenz des Protokolls, aber dazu sp√§ter mehr.  Diese Route wird als <b>machbarer Nachfolger bezeichnet</b> .  Und was wird mit der dritten Route passieren?  Nichts, es erf√ºllt nicht die FC-Bedingung (1280&gt; 1024) und wird nicht ber√ºcksichtigt, um es vor Schleifen zu sch√ºtzen.  Alle Routen, die √ºber Update empfangen, aber nicht von FC getestet wurden, k√∂nnen mit dem Befehl show ip eigrp topology all-links angezeigt werden.  Es ist nicht klar, warum die FS-Bedingung vor der Bildung von Schleifen sch√ºtzt. Versuchen wir nun zu erkl√§ren.  Es ist wichtig zu wissen, dass es beim Studium des EIGRP-Protokolls wichtig ist, das Prinzip der FC-Bedingung und den Zweck, f√ºr den es verwendet wird, zu verstehen.  Betrachten Sie eine leicht modifizierte Topologie (eine Verkn√ºpfung zwischen vIOS2 und vIOS4 wurde hinzugef√ºgt) und verwenden Sie auch die primitivste Metrik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/050/472/7340504727cf56fa62300883800f363f.jpg" alt="Mein bild"><br><br>  Die Route zum Netzwerk 192.168.5.0/24 ist bei AD und FD dieselbe: <br><br><ul><li>  vIOS4 - √ºber vIOS5, AD = 5, FD = 10. </li><li>  vIOS1 - √ºber vIOS4, AD = 10, FD = 11. </li><li>  vIOS3 - √ºber vIOS1, AD = 11, FD = 12. </li></ul><br>  VIOS4 erh√§lt jedoch ein Update von vIOS2, das die Route zum Netzwerk 192.168.5.0/24 √ºber vIOS2 mit der Metrik AD = 12, FD = 15 enth√§lt.  Es ist klar, dass es kein Nachfolger sein kann. Wenn diese Route pl√∂tzlich vom realisierbaren Nachfolger ausgew√§hlt w√ºrde, w√ºrde eine Schleife auftreten, wenn der Nachfolger auf vIOS4 f√§llt und der Nachfolger diese Route w√§hlt.  FC erlaubt es jedoch nicht, diese Route als FS als AD = 12&gt; 10 = FD festzulegen.  Die Route zu vIOS2 enth√§lt den Pfad durch vIOS4, und in jedem Fall enth√§lt die AD auch FD vIOS4.  Das hei√üt, AD unter vIOS2 enth√§lt die folgenden Links: <br><blockquote>  12 = AD auf vIOS2 = Gi0 / 3 vIOS3 + Gi0 / 2 vIOS4 + Gi0 / 1 vIOS5 + eth0 VPC5, wobei Gi0 / 1 vIOS5 + eth0 VPC5 = FD = 10 - dies ist FD vIOS4 und es ist unm√∂glich, dass AD &lt;FD ist weniger. </blockquote><br>  Somit √ºberpr√ºft die Bedingung FC die Route auf das Vorhandensein von sich selbst in dieser Route.  Nur Routen, die diese Bedingung erf√ºllen, k√∂nnen garantieren, dass keine Schleifen vorhanden sind.  Es kann F√§lle geben, in denen die Route keine Schleife erstellt, aber gleichzeitig die FC-Bedingung nicht erf√ºllt. Wir werden sie nicht verwenden. In solchen F√§llen w√§hlen wir die Netzwerkstabilit√§t.  Wenn Sie sich damit besch√§ftigen, ist die Bedingung recht einfach und intuitiv.  Der Algorithmus, der die besten Routen im EIGRP-Protokoll ausw√§hlt, hei√üt <b>DUAL</b> .  Betrachten Sie nun das EIGRP-Protokoll zur Frage der Konvergenz beim Verlust der Hauptroute.  Kehren wir zu unserer alten gro√üen Topologie zur√ºck und stellen uns vor, dass vIOS4 weg ist.  Abh√§ngig davon, wie vIOS4 verloren gegangen ist, unterscheidet sich das Verhalten geringf√ºgig, es unterscheidet sich jedoch, wenn der Trigger ausgel√∂st wird.  Wenn wir beispielsweise die Gi 0/2-Schnittstelle auf vIOS1 deaktivieren, erkennt vIOS1 sofort den Verlust eines Nachbarn und beginnt zu handeln. Wenn der Nachbar ohne Vorwarnung verschwindet, funktioniert der Hold Timer, nachdem er 15 Sekunden lang keine Hello-Pakete empfangen hat: <br><blockquote>  D 192.168.2.0/24 [90/512] √ºber 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] √ºber 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] √ºber 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br><br>  P 192.168.3.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  √ºber 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  √ºber 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 Nachfolger, FD ist 512 <br>  √ºber Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 Nachfolger, FD ist 768 <br>  √ºber Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 Nachfolger, FD ist 256 <br>  √ºber Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 1 Nachfolger, FD ist 1024 <br>  √ºber 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  √ºber 192.168.13.3 (1536/768), GigabitEthernet0 / 0 </blockquote><br>  Ich habe die Routing- und Topologietabelle der Einfachheit halber noch einmal gebracht. Um zu verstehen, wie sich der Router auf jeder Route verh√§lt, m√ºssen Sie wissen, in welchem ‚Äã‚ÄãZustand sie sich zuvor befanden.  Beispielsweise geht die zuvor besprochene Route, die Route 192.168.5.0/24, verloren, hatte jedoch FS in der Topologietabelle und wird daher, sobald die Hauptroute verloren geht, ihren Platz in der Routing-Tabelle einnehmen.  Eine interessante Frage ist, was mit Routen ohne FS passieren wird.  Aber ein bisschen Hardware: <br><br>  Eintr√§ge in der Topologietabelle k√∂nnen in zwei Zust√§nden vorliegen: aktiv und passiv.  Die Route befindet sich in einem passiven Zustand, wenn die Route stabil ist und die Suche nach der besten Route nicht erfolgt.  Im aktiven Zustand - wenn Sie nach der besten Route suchen.  Eine Routensuche wird durchgef√ºhrt, wenn es keinen realisierbaren Nachfolger f√ºr das Zielnetz gibt.  Der Router sendet auf der Suche nach einer besseren Route eine Anfrage (sendet ein Abfragepaket) an jeden benachbarten Router.  Wenn der Nachbar eine Route zum Zielnetzwerk hat, antwortet er (sendet ein Antwortpaket). Wenn keine Route vorhanden ist, sendet der Nachbar eine Anfrage an seine Nachbarn.  Der Router vergleicht alle FDs, um ein bestimmtes Netzwerk zu erreichen, w√§hlt die Route mit dem kleinsten FD aus und platziert sie in der Routing-Tabelle.  In der Topologietabelle k√∂nnen 6 Routen zum Netzwerk des Empf√§ngers (prim√§r und Backup) gespeichert werden. <br><br>  Routen, die verloren gegangen sind und kein FS hatten, wechseln zu Aktiv und vIOS1 fragt nach den verbleibenden Nachbarn.  Dies erfolgt mithilfe von Abfragenachrichten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 sendet Abfragenachrichten an vIOS2- und vIOS3-Router, wo klar angegeben wird, welche Routen ben√∂tigt werden. In unserem Fall sind diese Routen 192.168.14.0/24, 192.168.45.0/24. Mit dieser Nachricht informiert vIOS1 die Router auch dar√ºber, dass Routen √ºber vIOS1 zu diesen Netzwerken unbrauchbar sind. Dies erfolgt durch Angabe des Parameters Delay: Infifnity in der Metrik dieser Route, dh die Metrik ist unendlich gro√ü. Sobald Router solche Nachrichten erhalten, l√∂schen sie diese Routen √ºber vIOS1. Diese Technologie hei√üt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Poison Reverse wird auch f√ºr Update-Nachrichten verwendet. Ich werde etwas sp√§ter darauf eingehen. Nach Erhalt einer Abfrage mit einer Anforderung f√ºr die Routen 192.168.14.0/24, 192.168.45.0/24 sehen vIOS2 und vIOS3, ob sie √ºber diese Routen verf√ºgen, die sie gegebenenfalls verwenden, und senden sofort eine Antwort mit neuen Metriken f√ºr diese Routen. Wie wir wissen, haben vIOS2 und vIOS3 ihre Routen nicht verloren, daher senden sie sofort eine Antwort. Wenn der ebenfalls abgefragte Router diese Route nicht hat, leitet er die Abfrage an seine Nachbarn weiter und so weiter. vIOS1 wartet auf die Antwort von vIOS2, vIOS3 und dann tritt Active Timer in die Szene ein, die startet, sobald eine Abfrage gesendet wird: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- das Zeitintervall, in dem die Route im aktiven Zustand bleiben kann. Wenn der Timer abl√§uft, bevor alle Antworten von Nachbarn empfangen wurden (Antwort), versetzt der Router die Route in den Status "Nicht aktiv". Au√üerdem sind die Beziehungen der Nachbarschaft zu den Nachbarn unterbrochen, von denen keine Antwort erhalten wurde. Standardm√§√üig betr√§gt dieser Timer 3 Minuten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, wenn die Antwort trotz der Hello-Pakete nicht innerhalb von 3 Minuten eingeht, wird die Nachbarschaft unterbrochen und dies ist sehr schlecht. Trotz der Tatsache, dass 3 Minuten f√ºr solche Protokolle wie eine Ewigkeit sind, sind solche Situationen mit gro√üen Topologien m√∂glich. Zum Schutz vor fehlerhafter Trennung der Nachbarschaftsbeziehung wurden spezielle Nachrichten erfunden - SIA-Query und SIA-Reply.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Reaktion des Routers auf den Status der aktiven Route zu verbessern, werden zus√§tzlich zwei Arten von Nachrichten eingef√ºhrt: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Abfrage - Wird nach 1,5 Minuten versendet (Standard), um den Status eines direkt verbundenen Routers zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn die Route hinter dem Nachbarn verloren geht (w√§hrend die Verbindung zum Nachbarn normal ist), werden die Nachbarschaftsbeziehungen zum direkt verbundenen Router nicht zur√ºckgesetzt. </font><font style="vertical-align: inherit;">Erfordert keine Empfangsbest√§tigung. </font><font style="vertical-align: inherit;">Nachdem drei Nachrichten gesendet und keine Antwort empfangen wurden, wird der Nachbar als ausgefallen betrachtet und die Route aus der Topologietabelle entfernt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Antwort - Wird als Antwort auf die SIA-Abfrage gesendet. </font><font style="vertical-align: inherit;">Erfordert keine Empfangsbest√§tigung.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nach 1,5 Minuten keine Antwort auf eine Anfrage empfangen wird, wird eine SIA-Anfrage gesendet, f√ºr die keine neue Route erforderlich ist, sondern nur eine SIA-Antwort gesendet werden muss, um sicherzustellen, dass der Nachbar in Ordnung ist. Sie kann einfach nicht die richtige finden Route </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke dar√ºber nach, wie der Router auf den Verlust der Route reagiert, wenn FS vorhanden ist oder nicht, haben wir genug gesagt. Es ist nur erforderlich, folgende √Ñnderungen vorzunehmen. Wir haben FD nicht ganz richtig definiert, die Metrik, die wir nach der Formel berechnen, wenn wir zum ersten Mal eine Route erhalten oder wenn sich der Routenstatus weiter √§ndert. Es w√§re richtig, CD - Computed Distance aufzurufen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD ist der beste Indikator f√ºr eine bestimmte Route, die jemals erhalten wurde, und er ist es, der am FC-Check teilnimmt. </font><font style="vertical-align: inherit;">Meistens ist FD = CD die beste Route, aber lassen Sie uns sehen, wie sich FD nach dem Zusammenbruch der Nachbarschaft mit vIOS4 ver√§ndert hat:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, FD ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1536</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768) ist </font><font style="vertical-align: inherit;">, GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben keine Route mehr mit CD = 1024, die beste Route durch vIOS3 ist CD = 1536, aber wie Sie sehen k√∂nnen, ist FD = 1024, die behoben wurde, als es eine Route durch vIOS4 gab. </font><font style="vertical-align: inherit;">FD wird nur aktualisiert, wenn diese Route in den aktiven Zustand versetzt wird. </font><font style="vertical-align: inherit;">Bis sich der Status von Passiv zu Aktiv √§ndert, √§ndert sich auch FD nicht. </font><font style="vertical-align: inherit;">Regelm√§√üige Updates gelten nicht daf√ºr. </font><font style="vertical-align: inherit;">Noch eine Bemerkung. </font><font style="vertical-align: inherit;">Lassen Sie uns dieses Experiment durchf√ºhren: Geben Sie die Nachbarschaft mit vIOS4, CD √ºber vIOS3 = 1536 und √ºber vIOS2 = 2048 zur√ºck. Erh√∂hen Sie die Kanalverz√∂gerung zwischen vIOS1 und vIOS3, sodass sie gr√∂√üer als die vIOS2-CD wird:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, ist FD 1024 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2304</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768) ist </font><font style="vertical-align: inherit;">, GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir sehen, ist die CD durch vIOS3 = 2304, aber sie blieb FS, da sich AD nicht ge√§ndert hat und die FC-Bedingung wie zuvor erf√ºllt war. </font><font style="vertical-align: inherit;">Wir stellen uns eine Frage: Was passiert, wenn eine Route durch vIOS2 verloren geht? </font><font style="vertical-align: inherit;">Die erwartete und logische Antwort, wie uns beigebracht wurde, ist stattdessen FS, aber nein! </font><font style="vertical-align: inherit;">Da es immer noch eine Route durch vIOS2 mit CD = 2048 &lt;2304 gibt, wird die Route in den aktiven Status versetzt und berechnet die Metrik daf√ºr neu und w√§hlt die beste Route aus, obwohl sie eine Sicherungsroute hatte. </font><font style="vertical-align: inherit;">Wir schauen uns die Topologietabelle an und erhalten:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 Nachfolger, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD ist 2048</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber 192.168.12.2 (2048/1280), GigabitEthernet0 / 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber 192.168.13.3 (2304/768), GigabitEthernet0 / 0</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Route √ºber vIOS2 wird verwendet und hat sich, wie von FD angegeben, auch aufgrund des √úbergangs der Route in den aktiven Zustand ge√§ndert. </font><font style="vertical-align: inherit;">Und die Route durch vIOS3 teilt wieder das Schicksal des Ersatzteils.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regeln f√ºr geteilten Horizont und Giftumkehr in EIGRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in RIP verwendet EIGRP die Split Horizon-Regel. Wenn eine Route √ºber eine bestimmte Schnittstelle erreichbar ist, ist diese Route nicht in dem Update enthalten, das √ºber diese Schnittstelle gesendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn vIOS4 beispielsweise eine Route zum Netzwerk 192.168.0.0/24 von vIOS1 empf√§ngt, sendet es diese Route nicht √ºber die Schnittstelle, mit der vIOS1 verbunden ist, an Update. Stellen Sie sich genauer gesagt vor, dass vIOS1 √ºber das Netzwerk 192.168.0.0/24 gesprochen hat. Ich habe ein Update an vIOS4 gesendet, vIOS4 wird es empfangen, und Split Horizon sollte sein Update in der Regel nicht mit dieser Route an vIOS1 senden, aber in Wirklichkeit wird es mit einer unendlichen Metrik gesendet. Als ob vIOS4 vIOS1 sagt - "Wagen Sie es nicht, die Route zum Netzwerk 192.168.0.0/24 √ºber mich zu verwenden, ich habe diese Route von Ihnen erhalten, und wenn Sie sie verwenden, wird es eine Schleife geben."</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse - Zeigt eine nicht erreichbare Route mithilfe einer Metrik an, wenn sie verloren geht. </font><font style="vertical-align: inherit;">In EIGRP erfolgt dies mit dem Parameter Delay. </font><font style="vertical-align: inherit;">Wir haben oben angegeben, wie diese Technologie verwendet wird, wenn vIOS1 den Kontakt zu vIOS4 verliert. </font><font style="vertical-align: inherit;">Aus den obigen Ausf√ºhrungen zu Split Horizon k√∂nnen wir schlie√üen, dass die Poison Reverse-Technologie nicht nur in Abfragenachrichten, sondern auch in Updates verwendet wird. </font><font style="vertical-align: inherit;">Au√üerdem verst√∂√üt Poison Reverse m√∂glicherweise gegen die Split Horizon-Regel und sendet ein Update mit unendlichen Metriken von der Schnittstelle, von der es dieses Update erhalten hat. </font><font style="vertical-align: inherit;">Diese beiden Regeln bieten zusammen mit der FC-Klausel einen Schutz des EIGRP-Protokolls gegen Schleifen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stub-Router </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Optimierung wurde im Protokoll eine spezielle Rolle f√ºr Router eingef√ºhrt - Stub. </font><font style="vertical-align: inherit;">So etwas wie die Stub-Zone in OSPF, aber hier ist ein etwas anderes Funktionsprinzip. </font><font style="vertical-align: inherit;">Wenn der Router im Stub-Modus konfiguriert wird, meldet er seinem Nachbarn sofort in Hello-Paketen seinen Stub-Status und kann je nach Stub-Modus bestimmte Routentypen senden:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS5 # eigrp stub [verbunden | </font><font style="vertical-align: inherit;">Leckkarte | </font><font style="vertical-align: inherit;">Nur empfangen | </font><font style="vertical-align: inherit;">umverteilt | </font><font style="vertical-align: inherit;">statisch | </font><font style="vertical-align: inherit;">Zusammenfassung]</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eigrp-Stub-Befehlsoptionen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ohne Optionen (Standard) - verbunden und Zusammenfassung; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verbunden - Erm√∂glicht dem Stub-Router, verbundene Routen zu senden, jedoch nur f√ºr Schnittstellen, deren Adressen sich in den durch den Netzwerkbefehl angegebenen Netzwerken befinden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leckkarte - Erlaubt dynamische Pr√§fixe basierend auf der Leckkarte; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur empfangen - Verhindert, dass der Stub-Router Routen sendet. </font></font></li><li> redistributed ‚Äî  stub   redistributed ; </li><li> static ‚Äî  stub   static ,  ,      ; </li><li> summary ‚Äî  stub     (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hauptmerkmal dieser Einstellung ist jedoch, dass der Router, wenn er wei√ü, dass sich sein Nachbar in der Stub-Rolle befindet, keine Abfrage f√ºr aktiv gewordene Routen an ihn sendet. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise vIOS5 als Stub konfigurieren, wird vIOS2-4 dies herausfinden und wenn Routen verloren gehen, werden sie Query nicht vergiften. </font><font style="vertical-align: inherit;">In Anbetracht der Probleme, die auftreten k√∂nnen, wenn keine Antwort vorliegt, w√§re es hilfreich, eine Abfrage nur dort zu senden, wo dies sinnvoll ist. </font><font style="vertical-align: inherit;">Dies ist in gro√üen Topologien wichtig, in denen Konvergenz ein komplexer Prozess sein kann. </font><font style="vertical-align: inherit;">Wenn es also einen Router gibt, der endg√ºltig ist und nur Benutzernetzwerke mit ihm verbunden sind (relativ gesehen hat er nur einen Nachbarn), ist es besser, dar√ºber nachzudenken, ihn als Stub einzurichten.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein paar Worte zu Timern </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben √ºber einige von ihnen gesprochen. Wenn Sie sich die Ausgabe des Befehls show ip eigrp neighbours ansehen, sehen wir Folgendes: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 # show ip eigrp Nachbarn </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIGRP-IPv4 Nachbarn f√ºr AS (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressschnittstelle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haltezeit </font><font style="vertical-align: inherit;">SRTT </font><font style="vertical-align: inherit;">RTO Q Seq </font><font style="vertical-align: inherit;">(Sek.) (ms) Cnt Num </font><font style="vertical-align: inherit;">2 192.168.14.4 Gi0 / 2 11 00:48:43 23 138 0 168 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 192.168.12.2 Gi0 / 3 12 02:31:12 6 100 0 258 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 192.168.13.3 Gi0 / 0 10 2d13h 7 100 0 291 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 #</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind Timer, die einer Erkl√§rung bed√ºrfen. </font><font style="vertical-align: inherit;">Wenn als Antwort auf das Senden eines Multicast-Pakets, f√ºr das eine Empfangsbest√§tigung erforderlich ist, keine Best√§tigung (ACK) gesendet wurde, wird das Unicast-Paket an den Nachbarn gesendet, der nicht antwortet. </font><font style="vertical-align: inherit;">Wenn die Best√§tigung auch nach dem Senden von 16 Unicast-Paketen nicht empfangen wurde, gilt der Nachbar als inaktiv.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Roundtrip-Zeit (SRTT)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die Zeit zwischen dem Senden eines Pakets an einen Nachbarn und dem Empfangen einer Best√§tigung von ihm. </font><font style="vertical-align: inherit;">Gemessen in Millisekunden. </font><font style="vertical-align: inherit;">Die Berechnungsformel ist propriet√§r.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast Flow Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Maximalwert des Intervalls in Sekunden, in dem der Router nach dem Senden des EIGRP-Pakets an die Multicast-Adresse auf das ACK-Paket wartet, bevor er zum Unicast-Senden wechselt. </font><font style="vertical-align: inherit;">Es wird auf Basis von SRTT berechnet, die Berechnungsformel selbst ist propriet√§r.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTO (Retransmission Timeout) - das</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intervall zwischen dem Senden von Unicast-Paketen. </font><font style="vertical-align: inherit;">Es wird auf Basis von SRTT berechnet, die Berechnungsformel selbst ist propriet√§r.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daran denke ich, um den Artikel zu beenden. </font><font style="vertical-align: inherit;">Unten ist ein n√ºtzlicher Link:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cisconinja.wordpress.com/2009/09/18/eigrp-sia-query-and-sia-reply </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru/wiki/EIGRP</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=FYUK7blhCZk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Webinar √ºber EIGRP f√ºr ungef√§hr viereinhalb Stunden. </font><font style="vertical-align: inherit;">Erforderlich zum Anzeigen)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html#anc9</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420667/">https://habr.com/ru/post/de420667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420657/index.html">Analyse: Auf wessen Geld kann Elon Musk Tesla vom Umtausch abheben</a></li>
<li><a href="../de420659/index.html">USB-Kampagne der HRF (Human Rights Foundation) ‚ÄûFlash Drives for Freedom‚Äú</a></li>
<li><a href="../de420661/index.html">Kontinuierliche Cloud-Infrastruktur</a></li>
<li><a href="../de420663/index.html">Einfache Metriken und eine M√∂glichkeit, Zeit zu sparen, wenn Sie nach Problemen in der Infrastruktur suchen</a></li>
<li><a href="../de420665/index.html">Erstellen einer Anwendung auf .NET Core und Kubernetes: Unsere Erfahrung</a></li>
<li><a href="../de420669/index.html">Markt√ºberblick √ºber Enterprise Automation: L√∂sungen f√ºr Bau- und Verwaltungsunternehmen f√ºr Wohnungsbau und Versorgungsunternehmen</a></li>
<li><a href="../de420671/index.html">[Ekaterinburg, Ank√ºndigung] UralJS # 9 - drei Berichte √ºber Microservices, Tests und Fehlerprotokollierung an der Vorderseite</a></li>
<li><a href="../de420673/index.html">Docker f√ºr Symfony 4 - vom LAN bis zur Produktion</a></li>
<li><a href="../de420675/index.html">SOC sind Menschen. ‚ÄûHallo, wir suchen Talente‚Äú oder woher kommen die Analysten des √úberwachungs- und Reaktionszentrums f√ºr Cyberangriffe</a></li>
<li><a href="../de420677/index.html">Die Geschichte, wie Epson den Planeten mit 30 Millionen "Fabriken" versorgte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>