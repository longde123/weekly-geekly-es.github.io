<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è üëàüèº ü¶ï Emulaci√≥n de literales de propiedad con la referencia de m√©todo Java 8 ü§∫ üõÉ ü§¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De un traductor: la ofensa por la falta de un operador nameOf en Java me empuj√≥ a traducir este art√≠culo. Para los impacientes: al final del art√≠culo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Emulaci√≥n de literales de propiedad con la referencia de m√©todo Java 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420533/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rx/cy/ut/rxcyutfwkaqvjicfkhp78xtv_ts.png"></div><br>  <i>De un traductor: la ofensa por la falta de un operador nameOf en Java me empuj√≥ a traducir este art√≠culo.</i>  <i>Para los impacientes: al final del art√≠culo hay una implementaci√≥n preparada en las fuentes y los binarios.</i> <br><br>  Una de las cosas que los desarrolladores de bibliotecas en Java a menudo carecen son los literales de propiedad.  En esta publicaci√≥n, le mostrar√© c√≥mo puede usar creativamente la Referencia de m√©todos de Java 8 para emular literales de propiedad mediante la generaci√≥n de bytecode. <br><br>  Al igual que los literales de clase (por ejemplo, <code>Customer.class</code> ), los literales de propiedad permitir√≠an hacer referencia a las propiedades de las clases de bean seguras.  Esto ser√≠a √∫til para dise√±ar una API donde sea necesario realizar acciones en las propiedades o de alguna manera configurarlas. <br><br>  <i>Del traductor: Debajo del corte, analizamos c√≥mo implementar esto desde medios improvisados.</i> <br><a name="habracut"></a><br>  Por ejemplo, considere la API de configuraci√≥n de asignaci√≥n de √≠ndice en Hibernate Search: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchMapping().entity(Address.class) .indexed() .property(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, ElementType.METHOD) .field();</code> </pre><br>  O el m√©todo <code>validateValue()</code> de Bean Validation API, que le permite verificar el valor contra las restricciones de la propiedad: <br><br><pre> <code class="java hljs">Set&lt;ConstraintViolation&lt;Address&gt;&gt; violations = validator.validateValue(Address.class, <span class="hljs-string"><span class="hljs-string">"city"</span></span>, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span> );</code> </pre><br>  En ambos casos, el tipo de <code>String</code> se usa para referirse a la propiedad de <code>city</code> del objeto <code>Address</code> . <br><br>  Esto puede conducir a errores: <br><ul><li>  la clase de direcci√≥n puede no tener una propiedad de la <code>city</code> en absoluto.  O, alguien podr√≠a olvidar actualizar el nombre de la cadena de la propiedad despu√©s de cambiar el nombre de los m√©todos get / set al refactorizar. </li><li>  en el caso de <code>validateValue()</code> , no tenemos forma de verificar que el tipo del valor pasado coincida con el tipo de la propiedad. </li></ul><br>  Los usuarios de esta API solo pueden conocer estos problemas al iniciar la aplicaci√≥n.  ¬øNo ser√≠a genial si el compilador y el sistema de tipos impidieran tal uso desde el principio?  Si Java tuviera literales de propiedad, entonces podr√≠amos hacer esto (este c√≥digo no se compila): <br><br><pre> <code class="java hljs">mapping.entity(Address.class) .indexed() .property(Address::city, ElementType.METHOD ) .field();</code> </pre><br>  Y: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::city, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Podr√≠amos evitar los problemas mencionados anteriormente: cualquier error tipogr√°fico en el nombre de la propiedad provocar√≠a un error de compilaci√≥n, que puede notarse directamente en su IDE.  Esto nos permitir√≠a dise√±ar la API de configuraci√≥n de Hibernate Search para que solo acepte las propiedades de la clase Address cuando configuramos la entidad Address.  Y en el caso de Bean Validation <code>validateValue()</code> los literales de propiedad ayudar√≠an a asegurarnos de que estamos pasando un valor del tipo correcto. <br><br><h2>  Referencia del m√©todo Java 8 </h2><br>  Java 8 no admite literales de propiedad (y no est√° previsto admitirlos en Java 11), pero al mismo tiempo, proporciona una forma interesante de emularlos: Referencia de m√©todo (referencia de m√©todo).  Inicialmente, la Referencia del m√©todo se agreg√≥ para simplificar el trabajo con expresiones lambda, pero se pueden usar como literales de propiedad para los pobres. <br><br>  Considere la idea de usar una referencia al m√©todo getter como un literal de propiedad: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::getCity, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Obviamente, esto solo funcionar√° si tienes un captador.  Pero si sus clases ya siguen la convenci√≥n JavaBeans, que suele ser el caso, entonces est√° bien. <br><br>  ¬øC√≥mo ser√≠a una declaraci√≥n del m√©todo <code>validateValue()</code> ?  El punto clave es el uso del nuevo tipo de <code>Function</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value);</code> </pre><br>  Usando dos par√°metros de tipeo, podemos verificar que el tipo de contenedor, las propiedades y el valor pasado sean correctos.  Desde el punto de vista de la API, obtuvimos lo que necesitamos: es seguro usarlo y el IDE incluso complementar√° autom√°ticamente los nombres de m√©todos que comienzan con <code>Address::</code> .  Pero, ¬øc√≥mo derivar el nombre de la propiedad del objeto <code>Function</code> en la implementaci√≥n del m√©todo <code>validateValue()</code> ? <br><br>  Y luego comienza la diversi√≥n, ya que la interfaz funcional de Function solo declara un m√©todo: <code>apply()</code> , que ejecuta el c√≥digo de funci√≥n para la instancia <code>T</code> pasada.  Esto no parece ser lo que necesit√°bamos. <br><br><h2>  ByteBuddy al rescate </h2><br>  ¬°Resulta que el truco est√° en aplicar la funci√≥n!  Al crear una instancia de proxy de tipo T, tenemos el objetivo de llamar al m√©todo y obtener su nombre en el controlador de llamadas de proxy.  (Del traductor: en adelante estamos hablando de proxies din√°micos de Java - java.lang.reflect.Proxy). <br><br>  Java admite servidores proxy din√°micos listos para usar, pero este soporte est√° limitado solo a las interfaces.  Como nuestra API deber√≠a funcionar con cualquier bean, incluidas las clases reales, voy a usar una gran herramienta, ByteBuddy, en lugar de Proxy.  ByteBuddy proporciona un DSL simple para crear clases sobre la marcha, que es lo que necesitamos. <br><br>  Comencemos por definir una interfaz que nos permita almacenar y recuperar el nombre de propiedad extra√≠do de la Referencia del m√©todo. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String propertyName)</span></span></span></span>; }</code> </pre> <br>  Ahora usamos ByteBuddy para crear mediante programaci√≥n clases proxy que sean compatibles con los tipos que nos interesan (por ejemplo: Direcci√≥n) e implementar <code>PropertyNameCapturer</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; T <span class="hljs-comment"><span class="hljs-comment">/* &amp; PropertyNameCapturer */</span></span> getPropertyNameCapturer(Class&lt;T&gt; type) { DynamicType.Builder&lt;?&gt; builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuddy() (<span class="hljs-number"><span class="hljs-number">1</span></span>) .subclass( type.isInterface() ? Object.class : type ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.isInterface()) { (<span class="hljs-number"><span class="hljs-number">2</span></span>) builder = builder.implement(type); } Class&lt;?&gt; proxyType = builder .implement(PropertyNameCapturer.class) (<span class="hljs-number"><span class="hljs-number">3</span></span>) .defineField(<span class="hljs-string"><span class="hljs-string">"propertyName"</span></span>, String.class, Visibility.PRIVATE) .method( ElementMatchers.any()) (<span class="hljs-number"><span class="hljs-number">4</span></span>) .intercept(MethodDelegation.to( PropertyNameCapturingInterceptor.class )) .method(named(<span class="hljs-string"><span class="hljs-string">"setPropertyName"</span></span>).or(named(<span class="hljs-string"><span class="hljs-string">"getPropertyName"</span></span>))) (<span class="hljs-number"><span class="hljs-number">5</span></span>) .intercept(FieldAccessor.ofBeanProperty()) .make() .load( (<span class="hljs-number"><span class="hljs-number">6</span></span>) PropertyNameCapturer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER ) .getLoaded(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Class&lt;T&gt; typed = (Class&lt;T&gt;) proxyType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typed.newInstance(); (<span class="hljs-number"><span class="hljs-number">7</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstantiationException | IllegalAccessException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HibernateException( <span class="hljs-string"><span class="hljs-string">"Couldn't instantiate proxy for method name retrieval"</span></span>, e ); } }</code> </pre><br>  El c√≥digo puede parecer un poco confuso, as√≠ que d√©jenme explicarlo.  Primero obtenemos una instancia de ByteBuddy (1), que es el punto de entrada DSL.  Se utiliza para crear tipos din√°micos que extienden el tipo deseado (si es una clase) o heredan Object e implementan el tipo deseado (si es una interfaz) (2). <br><br>  Luego, indicamos que el tipo implementa la interfaz PropertyNameCapturer y agregamos un campo para almacenar el nombre de la propiedad deseada (3).  Luego decimos que las llamadas a todos los m√©todos deben ser interceptadas por PropertyNameCapturingInterceptor (4).  Solo setPropertyName () y getPropertyName () (desde la interfaz PropertyNameCapturer) deben acceder a la propiedad real creada anteriormente (5).  Finalmente, la clase se crea, se carga (6) y se instancia (7). <br><br>  Eso es todo lo que necesitamos para crear tipos de proxy, gracias ByteBuddy, esto se puede hacer en unas pocas l√≠neas de c√≥digo.  Ahora echemos un vistazo al interceptor de llamadas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@RuntimeType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@This PropertyNameCapturer capturer, @Origin Method method)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">1</span></span>) capturer.setPropertyName(getPropertyName(method)); (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getReturnType() == <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>.class) { (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ... ) { } <span class="hljs-comment"><span class="hljs-comment">// ... handle all primitve types // ... } else { return null; } } private static String getPropertyName(Method method) { (4) final boolean hasGetterSignature = method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != null; String name = method.getName(); String propName = null; if (hasGetterSignature) { if (name.startsWith("get") &amp;&amp; hasGetterSignature) { propName = name.substring(3, 4).toLowerCase() + name.substring(4); } else if (name.startsWith("is") &amp;&amp; hasGetterSignature) { propName = name.substring(2, 3).toLowerCase() + name.substring(3); } } else { throw new HibernateException( "Only property getter methods are expected to be passed"); (5) } return propName; } }</span></span></code> </pre><br>  El m√©todo intercept () acepta el m√©todo llamado y el objetivo de la llamada (1).  Las <code>@This</code> <code>@Origin</code> y <code>@This</code> se usan para especificar los par√°metros apropiados para que ByteBuddy pueda generar las llamadas correctas intercept () en un proxy din√°mico. <br><br>  Tenga en cuenta que no existe una dependencia estricta del receptor de los tipos ByteBuddy, ya que ByteBuddy se usa solo para crear un proxy din√°mico, pero no cuando se usa. <br><br>  Al llamar a <code>getPropertyName()</code> (4) podemos obtener el nombre de propiedad correspondiente a la referencia de m√©todo pasada y guardarlo en <code>PropertyNameCapturer</code> (2).  Si el m√©todo no es un captador, entonces el c√≥digo arroja una excepci√≥n (5).  El tipo de retorno del captador no importa, por lo que devolvemos nulo considerando el tipo de propiedad (3). <br><br>  Ahora estamos listos para obtener el nombre de la propiedad en el m√©todo <code>validateValue()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value) { T capturer = getPropertyNameCapturer(type); property.apply(capturer); String propertyName = ((PropertyLiteralCapturer) capturer).getPropertyName(); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br>  Despu√©s de aplicar la funci√≥n al proxy creado, enviamos el tipo a PropertyNameCapturer y obtenemos el nombre de Method. <br><br>  Entonces, usando algo de la magia de generar bytecode, usamos la Referencia de m√©todos de Java 8 para emular literales de propiedad. <br><br>  Por supuesto, si tuvi√©ramos literales de propiedad real en el lenguaje, todos estar√≠amos mejor.  Incluso permitir√≠a trabajar con propiedades privadas y, probablemente, se podr√≠a hacer referencia a las propiedades a partir de anotaciones.  Los literales de propiedad real ser√≠an m√°s ordenados (sin el prefijo "get") y no se ver√≠an como un truco. <br><br><h2>  Del traductor </h2><br>  Vale la pena se√±alar que otros buenos idiomas ya admiten (o casi) un mecanismo similar: <br><br><ul><li>  C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instrucci√≥n nameOf</a> </li><li>  Groovy y Scala: hay conocidos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacks de metaprogramaci√≥n y macros</a> </li><li>  Kotlin: hay una sintaxis normal <code>User::login.name</code> </li></ul><br>  Si de repente usa el proyecto Lombok con Java, entonces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> escribe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador de tiempo de compilaci√≥n de bytecode</a> . <br><br>  Inspirado por el enfoque descrito en el art√≠culo, su humilde servidor cre√≥ una peque√±a biblioteca que implementa nameOfProperty () para Java 8: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Binarios</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420533/">https://habr.com/ru/post/es420533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420521/index.html">Ahora oficialmente: TLS 1.3 reconocido como est√°ndar</a></li>
<li><a href="../es420523/index.html">An√°lisis de gr√°ficos de opciones binarias o c√≥mo una vez m√°s me demostr√© a m√≠ mismo que los obsequios no existen</a></li>
<li><a href="../es420525/index.html">Redes para los m√°s experimentados. Parte quince. QoS</a></li>
<li><a href="../es420527/index.html">Puede sonar una sonrisa y es contagiosa</a></li>
<li><a href="../es420529/index.html">¬øUso avanzado de Geeta o c√≥mo retirarse seis meses antes?</a></li>
<li><a href="../es420537/index.html">Otra historia de c√≥mo el dinero se toma relativamente honestamente en un meg√°fono</a></li>
<li><a href="../es420539/index.html">Enfoque personalizado para normalizar y restablecer estilos (custom-reset.css)</a></li>
<li><a href="../es420541/index.html">Investigadores de Carnegie Mellon han creado los "deepfakes" m√°s cre√≠bles</a></li>
<li><a href="../es420547/index.html">Mientras escrib√≠a y defend√≠a un diploma en DEVOPS y pr√°cticas de ingenier√≠a en 1C desde cero</a></li>
<li><a href="../es420549/index.html">Plantillas FreeMarker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>