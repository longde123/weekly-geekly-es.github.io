<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèΩ üî± üéÖüèª So organisieren Sie Ihre Abh√§ngigkeiten in einer Vue-Anwendung ü¶ñ ü§¥üèΩ üñïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder, der mit Vue vertraut ist, wei√ü, dass eine Vue-Anwendung einen Einstiegspunkt hat - die Datei main.js Dort gibt es neben dem Erstellen einer Ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So organisieren Sie Ihre Abh√§ngigkeiten in einer Vue-Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423013/"> Jeder, der mit Vue vertraut ist, wei√ü, dass eine Vue-Anwendung einen Einstiegspunkt hat - die Datei <code>main.js</code>  Dort gibt es neben dem Erstellen einer Instanz von Vue einen Import und eine Art Abh√§ngigkeitsinjektion aller Ihrer globalen Abh√§ngigkeiten (Direktiven, Komponenten, Plugins).  Je gr√∂√üer das Projekt, desto mehr Abh√§ngigkeiten werden, die dar√ºber hinaus jeweils ihre eigene Konfiguration haben.  Als Ergebnis erhalten wir eine gro√üe Datei mit allen Konfigurationen. <br>  In diesem Artikel wird erl√§utert, wie Sie globale Abh√§ngigkeiten organisieren, um dies zu vermeiden. <br><br><img src="https://habrastorage.org/webt/sv/fa/xn/svfaxnl2uh7vozipy4n5to6qpqm.png"><br><a name="habracut"></a><br><h2>  Warum selbst schreiben? </h2><br>  Viele m√∂gen denken - warum ist das notwendig, wenn es zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nuxt gibt</a> , das dies f√ºr Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erledigt</a> ?  In meinen Projekten habe ich es auch verwendet, aber in einfachen Projekten kann dies √ºberfl√ºssig sein.  Dar√ºber hinaus hat niemand Projekte mit Legacy-Code abgebrochen, die wie Schnee auf Ihrem Kopf auf Sie fallen.  Und schlie√üen Sie das Framework dort an - praktisch von Grund auf neu. <br><br><h2>  Mastermind </h2><br>  Der Organisator einer solchen Organisation war Nuxt.  Es wurde von mir bei einem gro√üen Projekt mit Vue verwendet. <br>  Nuxt hat eine gro√üartige Funktion - Plugins.  Jedes Plugin ist eine Datei, die eine Funktion exportiert.  Die Konfiguration wird an die Funktion √ºbergeben, die beim Erstellen der Instanz auch an den Vue-Konstruktor sowie an den gesamten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher √ºbergeben wird</a> . <br><br>  Dar√ºber hinaus ist in jedem Plugin eine √§u√üerst n√ºtzliche Funktion, <code>inject</code> verf√ºgbar.  Es wird eine Abh√§ngigkeitsinjektion f√ºr die Stamminstanz von Vue und f√ºr das <code>store</code> .  Dies bedeutet, dass in jeder Komponente, in jeder Speicherfunktion die angegebene Abh√§ngigkeit dadurch verf√ºgbar ist. <br><br><h2>  Wo kann das n√ºtzlich sein? </h2><br>  Zus√§tzlich zu der Tatsache, dass <code>main.js</code> erheblich ‚Äûabnehmen‚Äú, erhalten Sie auch die M√∂glichkeit, die Abh√§ngigkeit √ºberall in der Anwendung ohne unn√∂tige Importe zu verwenden. <br><br>  Ein Paradebeispiel f√ºr Dependency Injection ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue-Router</a> .  Es wird nicht sehr oft verwendet - um die Parameter der aktuellen Route abzurufen, um eine Umleitung durchzuf√ºhren, aber dies ist eine globale Abh√§ngigkeit.  Wenn es in einer Komponente n√ºtzlich sein kann, warum nicht global machen?  Dank dessen wird der Status au√üerdem global gespeichert und f√ºr die gesamte Anwendung ge√§ndert. <br><br>  Ein weiteres Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vue-wait</a> .  Die Entwickler dieses Plugins gingen noch weiter und f√ºgten die <code>$wait</code> Eigenschaft nicht nur der Vue-Instanz, sondern auch dem Vuex-Store hinzu.  Angesichts der Besonderheiten des Plugins erweist sich dies als √§u√üerst n√ºtzlich.  Beispielsweise verf√ºgt der Speicher √ºber eine Aktion, die f√ºr mehrere Komponenten aufgerufen wird.  In jedem Fall m√ºssen Sie den Loader f√ºr ein Element anzeigen.  Anstatt vor und nach jedem Aktionsaufruf <code>$wait.start('action')</code> und <code>$wait.end('action')</code> aufzurufen, k√∂nnen Sie diese Methoden einfach einmal in der Aktion selbst aufrufen.  Und dies ist viel lesbarer und weniger ausf√ºhrlich als der <code>dispatch('wait/start', 'action' {root: true})</code> .  Im Falle eines Gesch√§fts ist dies syntaktischer Zucker. <br><br><h2>  Von W√∂rtern zu Code </h2><br><h3>  Die Grundstruktur des Projekts </h3><br>  Mal sehen, wie das Projekt jetzt aussieht: <br> <code>src <br> - store <br> - App.vue <br> - main.js <br></code> <br>  <code>main.js</code> sieht <code>main.js</code> aus: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App), store }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>);</code> </pre><br><br><h3>  Wir verbinden die erste Abh√§ngigkeit </h3><br>  Jetzt wollen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Axios</a> mit unserem Projekt verbinden und eine Konfiguration daf√ºr erstellen.  Ich folgte der Nuxt-Terminologie und erstellte ein <code>plugins</code> Verzeichnis in <code>src</code> .  Im Verzeichnis befinden sich die <code>axios.js</code> <code>index.js</code> und <code>axios.js</code> . <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> - store <br> - App.vue <br> - main.js <br></code> <br>  Wie oben erw√§hnt, muss jedes Plugin eine Funktion exportieren.  Gleichzeitig m√∂chten wir innerhalb der Funktion Zugriff auf den Speicher und anschlie√üend auf die <code>inject</code> Funktion haben. <br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       ‚Äì , , interceptors  .. axios.defaults.baseURL = process.env.API_BASE_URL; axios.defaults.headers.common['Accept'] = 'application/json'; axios.defaults.headers.post['Content-Type'] = 'application/json'; axios.interceptors.request.use(config =&gt; { ... return config; }); }</span></span></code> </pre><br>  <code>index.js</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}; <span class="hljs-comment"><span class="hljs-comment">//   inject,        Dependency Injection axios(app, inject); //       Vue    }</span></span></code> </pre><br><br>  Wie Sie sehen k√∂nnen, exportiert die Datei <code>index.js</code> auch die Funktion.  Dies geschieht, um das <code>app</code> Objekt dort √ºbergeben zu k√∂nnen.  Lassen Sie uns nun <code>main.js</code> √§ndern und diese Funktion aufrufen. <br><br>  <code>main.js</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initPlugins <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./plugins'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    // ,    Vue,  ,     initPlugins const app = { render: h =&gt; h(App), store }; initPlugins(app); new Vue(app).$mount('#app'); //   initPlugins   </span></span></code> </pre><br><br><h3>  Ergebnis </h3><br>  Zu diesem Zeitpunkt haben wir erreicht, dass wir die Plugin-Konfiguration aus <code>main.js</code> in einer separaten Datei entfernt haben. <br><br>  Der Vorteil der √úbergabe des <code>app</code> Objekts an alle unsere Plugins besteht √ºbrigens darin, dass wir in jedem Plugin jetzt Zugriff auf den Store haben.  Sie k√∂nnen es frei verwenden, indem Sie <code>commit</code> und <code>dispatch</code> aufrufen sowie auf <code>store.state</code> und <code>store.getters</code> . <br><br>  Wenn Sie ES6-Stil m√∂gen, k√∂nnen Sie dies sogar tun: <br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, commit, state, getters}}</span></span></span><span class="hljs-function">) </span></span>{ ... }</code> </pre><br><h2>  Zweite Stufe - Abh√§ngigkeitsinjektion </h2><br>  Wir haben bereits das erste Plugin erstellt und jetzt sieht unser Projekt so aus: <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> - store <br> - App.vue <br> - main.js <br></code> <br>  Da in den meisten Bibliotheken, in denen dies wirklich erforderlich ist, Dependency Injection bereits mit <code>Vue.use</code> implementiert ist, <code>Vue.use</code> wir unser eigenes einfaches Plugin. <br><br>  Versuchen Sie beispielsweise zu wiederholen, was <code>vue-wait</code> tut.  Dies ist eine ziemlich umfangreiche Bibliothek. Wenn Sie also den Loader auf zwei Schaltfl√§chen anzeigen m√∂chten, ist es besser, ihn zu verlassen.  Ich konnte jedoch seiner Bequemlichkeit nicht widerstehen und wiederholte in seinem Projekt seine grundlegende Funktionalit√§t, einschlie√ülich des syntaktischen Zuckers im Laden. <br><br><h3>  Warten Sie Plugin </h3><br>  Erstellen Sie eine weitere Datei im <code>plugins</code> Verzeichnis - <code>wait.js</code> <br><br>  Ich habe bereits ein Vuex-Modul, das ich auch <code>wait</code> .  Er macht drei einfache Schritte: <br><br>  - <code>start</code> - setzt die state-Eigenschaft eines Objekts mit dem Namen <code>action</code> auf <code>true</code> <br>  - <code>end</code> - Entfernt eine Eigenschaft eines Objekts mit dem Namen <code>action</code> aus dem Status <br>  - <code>is</code> - ruft vom Status eine Eigenschaft eines Objekts mit dem Namen <code>action</code> <br><br>  In diesem Plugin werden wir es verwenden. <br><br> <code>wait.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, getters}}, inject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = { <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/start'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/end'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">is</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> getters[<span class="hljs-string"><span class="hljs-string">'wait/waiting'</span></span>](action) }; inject(<span class="hljs-string"><span class="hljs-string">'wait'</span></span>, wait); }</code> </pre><br><br>  Und verbinden Sie unser Plugin: <br><br>  <code>index.js</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wait'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}; Injection axios(app, inject); wait(app, inject); }</code> </pre><br><br><h3>  Injizieren Sie die Funktion </h3><br>  Jetzt implementieren wir die <code>inject</code> Funktion. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   2 : // name ‚Äì ,       this.  ,   Vue        Dependency Injection // plugin ‚Äì ,       this.  ,  ,           let inject = (name, plugin) =&gt; { let key = `$${name}`; //      app[key] = plugin; //     app app.store[key] = plugin; //     store //  Vue.prototype Vue.use(() =&gt; { if (Vue.prototype.hasOwnProperty(key)) { return; } Object.defineProperty(Vue.prototype, key, { get () { return this.$root.$options[key]; } }); }); };</span></span></code> </pre><br><br><h4>  Die Magie von Vue.prototype </h4><br>  Nun zur Magie.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue-Dokumentation</a> besagt, dass es ausreicht, <code>Vue.prototype.$appName = ' ';</code> zu schreiben <code>Vue.prototype.$appName = ' ';</code>  und <code>$appName</code> werden hier verf√ºgbar sein. <br><br>  In Wirklichkeit stellte sich jedoch heraus, dass dies nicht der Fall ist.  Aufgrund von Googeln gab es keine Antwort, warum ein solches Design nicht funktionierte.  Daher habe ich mich entschlossen, die Autoren des Plugins zu kontaktieren, die dies bereits implementiert haben. <br><br><h4>  Globales Mixin </h4><br>  Wie in unserem Beispiel habe ich mir den <code>vue-wait</code> Plugin-Code angesehen.  Sie bieten eine solche Implementierung an (der Quellcode wird aus Gr√ºnden der √úbersichtlichkeit bereinigt): <br><br><pre> <code class="javascript hljs">Vue.mixin({ beforeCreate() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { wait, store } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$options; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; instance.init(Vue, store); <span class="hljs-comment"><span class="hljs-comment">// inject to store this.$wait = instance; // inject to app } });</span></span></code> </pre><br>  Anstelle eines Prototyps wird vorgeschlagen, ein globales Mixin zu verwenden.  Der Effekt ist vielleicht im Grunde der gleiche, vielleicht mit Ausnahme einiger Nuancen.  Da die Injektion jedoch hier im Gesch√§ft erfolgt, sieht sie nicht genau richtig aus und entspricht √ºberhaupt nicht der Dokumentation. <br><br><h4>  Aber was ist, wenn Prototyp? </h4><br>  Die Idee hinter der im <code>inject</code> verwendeten Prototypl√∂sung wurde von Nuxt √ºbernommen.  Es sieht viel richtiger aus als das globale Mixin, also habe ich mich darauf festgelegt. <br><br><pre> <code class="javascript hljs"> Vue.use(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        if (Vue.prototype.hasOwnProperty(key)) { return; } //    ,         app  Object.defineProperty(Vue.prototype, key, { get () { return this.$root.$options[key]; //  ,    this } }); });</span></span></code> </pre><br><br><h3>  Ergebnis </h3><br>  Nach diesen Manipulationen erhalten wir die M√∂glichkeit, darauf zuzugreifen <code>this.$wait</code> von jeder Komponente sowie von jeder Methode im Gesch√§ft. <br><br><h2>  Was ist passiert? </h2><br>  Projektstruktur: <br><br> <code>src <br> - plugins <br> -- index.js <br> -- axios.js <br> -- wait.js <br> - store <br> - App.vue <br> - main.js <br></code> <br><br>  <code>index.js</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wait'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, plugin</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">`$</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>; app[key] = plugin; app.store[key] = plugin; Vue.use(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vue.prototype.hasOwnProperty(key)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(Vue.prototype, key, { get () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$root.$options[key]; } }); }); }; axios(app, inject); wait(app, inject); }</code> </pre><br><br> <code>wait.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{store: {dispatch, getters}}, inject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = { <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/start'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(<span class="hljs-string"><span class="hljs-string">'wait/end'</span></span>, action), <span class="hljs-attr"><span class="hljs-attr">is</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> getters[<span class="hljs-string"><span class="hljs-string">'wait/waiting'</span></span>](action) }; inject(<span class="hljs-string"><span class="hljs-string">'wait'</span></span>, wait); }</code> </pre><br><br> <code>axios.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app</span></span></span><span class="hljs-function">) </span></span>{ axios.defaults.baseURL = process.env.API_BASE_URL; axios.defaults.headers.common[<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>] = <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>; axios.defaults.headers.post[<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>] = <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>; }</code> </pre><br><br>  <code>main.js</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initPlugins <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./plugins'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = { <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App), store }; initPlugins(app); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue(app).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>);</code> </pre><br><h2>  Fazit </h2><br>  Als Ergebnis der Manipulationen haben wir einen Import- und einen Funktionsaufruf in der Datei <code>main.js</code> .  Und jetzt ist sofort klar, wo f√ºr jedes Plugin und jede globale Abh√§ngigkeit nach der Konfiguration gesucht werden muss. <br><br>  Wenn Sie ein neues Plugin hinzuf√ºgen, m√ºssen Sie nur eine Datei erstellen, die die Funktion exportiert, in <code>index.js</code> und diese Funktion aufrufen. <br><br>  In meiner Praxis hat sich eine solche Struktur als sehr praktisch erwiesen, au√üerdem kann sie leicht von Projekt zu Projekt √ºbertragen werden.  Jetzt gibt es keine Schmerzen mehr, wenn Sie Dependency Injection ausf√ºhren oder ein anderes Plugin konfigurieren m√ºssen. <br><br>  Teilen Sie Ihre Erfahrungen mit dem Abh√§ngigkeitsmanagement in den Kommentaren mit.  Erfolgreiche Projekte! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423013/">https://habr.com/ru/post/de423013/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422999/index.html">Erstellen Sie Ihren eigenen Alien-Datensatz</a></li>
<li><a href="../de423005/index.html">Wie Yandex.Zen, das WordPress-Caching-Plugin und das Hosting, meinen Druck steigerten</a></li>
<li><a href="../de423007/index.html">‚ÄûMalyavki, aber gut‚Äú: Wie wir die Sch√ºler zum √úben gebracht haben</a></li>
<li><a href="../de423009/index.html">SENS-Diagnose. Proteinglykations-Biomarker</a></li>
<li><a href="../de423011/index.html">Microservice Management mit Kubernetes und Istio</a></li>
<li><a href="../de423015/index.html">Git: H√§ufige Fehler und wie man sie behebt</a></li>
<li><a href="../de423017/index.html">Bobbiniki: Zehn Kult-Tonbandger√§te - erz√§hlen und zeigen</a></li>
<li><a href="../de423021/index.html">Online Hackathon von Naviaddress</a></li>
<li><a href="../de423023/index.html">Warum brauchen Entwickler Unterricht?</a></li>
<li><a href="../de423025/index.html">Wie kann ein Cash-Programm Analytics sparen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>