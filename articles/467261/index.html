<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóΩ üëÉüèΩ ü•ê Roscado adecuado en Qt üèÇüèΩ ü¶í ü§∞üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt es un marco extremadamente potente y conveniente para C ++. Pero esta conveniencia tiene un inconveniente: muchas cosas en Qt suceden ocultas para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Roscado adecuado en Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt es un marco extremadamente potente y conveniente para C ++.  Pero esta conveniencia tiene un inconveniente: muchas cosas en Qt suceden ocultas para el usuario.  En la mayor√≠a de los casos, la funcionalidad correspondiente en Qt funciona "m√°gicamente" y le ense√±a al usuario a simplemente dar por sentado esta magia.  Sin embargo, cuando la magia se rompe, es extremadamente dif√≠cil reconocer y resolver un problema que aparece repentinamente en un nivel aparentemente plano. <br><br>  Este art√≠culo es un intento de sistematizar la forma en que Qt "bajo el cap√≥" implementa el trabajo con flujos y sobre una serie de dificultades no obvias asociadas con las limitaciones de este modelo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los fundamentos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hilo de afinidad, inicializaci√≥n y sus limitaciones.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hilo principal, QCoreApplication y GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hilo de renderizado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  Los fundamentos </h3><br>  Comencemos con lo b√°sico.  En Qt, cualquier objeto capaz de manejar se√±ales y ranuras son descendientes de la clase QObject.  Estos objetos por dise√±o no se pueden copiar y, l√≥gicamente, representan algunas entidades individuales que "hablan" entre s√≠, reaccionan a ciertos eventos y pueden generar eventos por s√≠ mismos.  En otras palabras, QObject en Qt implementa el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patr√≥n de actores</a> .  Si se implementa correctamente, cualquier programa Qt es esencialmente nada m√°s que una red de QObjects que interact√∫an entre s√≠ en la que toda la l√≥gica del programa "vive". <br><br>  Adem√°s de un conjunto de QObjects, un programa Qt puede incluir objetos de datos.  Estos objetos no pueden generar y recibir se√±ales, pero pueden copiarse.  Por ejemplo, puede comparar QStringList y QStringListModel entre ellos.  Uno de ellos es QObject y no es copiable, pero puede interactuar directamente con los objetos de la interfaz de usuario, el otro es un contenedor de datos copiable normal.  A su vez, los objetos con datos se dividen en "Qt Meta-tipos" y todos los dem√°s.  Por ejemplo, QStringList es un metatipo Qt, pero std :: list &lt;std :: string&gt; (sin gestos adicionales) no lo es.  El primero se puede usar en cualquier contexto Qt-shnom (transmitido a trav√©s de se√±ales, en QVariant, etc.), pero requiere un procedimiento de registro especial y la clase debe tener un destructor p√∫blico, un constructor de copias y un constructor predeterminado.  Los segundos son tipos arbitrarios de C ++. <br><br><a name="part2"></a><h3>  Pase sin problemas a los hilos reales </h3><br>  Entonces, tenemos "datos" condicionales y hay un "c√≥digo" condicional que funciona con ellos.  Pero, ¬øqui√©n ejecutar√° realmente este c√≥digo?  En el modelo Qt, la respuesta a esta pregunta se establece expl√≠citamente: cada QObject est√° estrictamente vinculado a alg√∫n hilo QThread que, de hecho, se dedica al servicio de ranuras y otros eventos de este objeto.  Un hilo puede servir muchos QObjects a la vez, o ninguno en absoluto, pero QObject siempre tiene un hilo padre y siempre es exactamente uno.  De hecho, podemos suponer que cada QThread "posee" un conjunto de QObject.  En la terminolog√≠a Qt, esto se llama Thread Affinity.  Tratemos de visualizar para mayor claridad: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  Dentro de cada QThread hay una cola de mensajes dirigidos a objetos que este QThread "posee".  En el modelo Qt, se supone que si queremos que un QObject realice alguna acci√≥n, "enviamos" un mensaje QEvent a este QObject: <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  En esta llamada segura para subprocesos, Qt encuentra el QThread al que pertenece el objeto receptor, escribe el QEvent en la cola de mensajes de este subproceso y lo activa si es necesario.  Se espera que el c√≥digo que se ejecuta en este QThread en alg√∫n momento posterior lea el mensaje de la cola y realice la acci√≥n correspondiente.  Para que esto suceda realmente, el c√≥digo en QThread debe ingresar el bucle de eventos QEventLoop, crear el objeto apropiado y llamarlo ya sea el m√©todo exec () o el m√©todo processEvents ().  La primera opci√≥n ingresa un bucle de procesamiento de mensajes sin fin (antes de que QEventLoop reciba el evento quit ()), la segunda se limita al procesamiento de mensajes que se han acumulado previamente en la cola. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  Es f√°cil ver que los eventos para todos los objetos que pertenecen a un hilo se procesan secuencialmente.  Si el procesamiento de un evento por un subproceso lleva mucho tiempo, todos los dem√°s objetos se "congelar√°n"; sus eventos se acumular√°n en la cola de la secuencia, pero no se procesar√°n.  Para evitar que esto suceda, Qt ofrece la posibilidad de multitarea cooperativa: los controladores de eventos en cualquier lugar pueden "interrumpir temporalmente" creando un nuevo QEventLoop y pas√°ndole el control.  Dado que el controlador de eventos tambi√©n se llam√≥ previamente desde QEventLoop en la secuencia, con este enfoque, se forma una cadena de bucles de eventos "anidados" entre s√≠. <br><br><div class="spoiler">  <b class="spoiler_title">Algunas palabras sobre el despachador de eventos</b> <div class="spoiler_text">  Estrictamente hablando, QEventLoop no es m√°s que un contenedor f√°cil de usar sobre una primitiva dependiente del sistema de nivel inferior llamada Event Dispatcher e implementa la interfaz QAbstractEventDispatcher.  Es √©l quien realiza la recopilaci√≥n y el procesamiento reales de los eventos.  Un subproceso puede tener solo un QAbstractEventDispatcher y se instala solo una vez.  Entre otras cosas, comenzando con Qt5, esto le permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reemplazar</a> f√°cilmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el despachador por uno m√°s adecuado</a> si es necesario agregando solo 1 l√≠nea a la inicializaci√≥n de la transmisi√≥n y sin tocar los lugares potencialmente numerosos donde se usa QEventLoop. </div></div><br>  ¬øQu√© se incluye en el concepto de "evento" procesado en dicho ciclo?  Bien conocido por todos los empleados de Qt, "se√±ales" es solo un ejemplo particular, QEvent :: MetaCall.  Tal QEvent almacena un puntero a la informaci√≥n necesaria para identificar la funci√≥n (ranura) que debe llamarse y sus argumentos.  Sin embargo, adem√°s de las se√±ales en Qt, hay alrededor de un centenar (!) Otros eventos, de los cuales una docena est√° reservada para eventos especiales de Qt (ChildAdded, DeferredDelete, ParentChange) y el resto corresponde a varios mensajes del sistema operativo. <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© hay tantos y por qu√© era imposible hacerlo sin solo se√±ales?</b> <div class="spoiler_text">  El lector puede preguntar: ¬øpor qu√© hay tantos eventos y por qu√© fue imposible sobrevivir con un solo mecanismo de se√±al universal y conveniente?  El hecho es que diferentes se√±ales pueden procesarse de manera muy diferente.  Por ejemplo, algunas de las se√±ales son compresibles: si la cola ya tiene un mensaje sin procesar de este tipo (por ejemplo, QEvent :: Paint), los mensajes posteriores simplemente lo modifican.  Se pueden filtrar otras se√±ales.  La presencia de un peque√±o n√∫mero de QEvents est√°ndar y f√°cilmente identificables simplifica significativamente el procesamiento correspondiente.  Adem√°s, el procesamiento de QEvent debido a un dispositivo notablemente m√°s simple generalmente se lleva a cabo algo m√°s r√°pido que el procesamiento de una se√±al similar. </div></div><br>  Una de las trampas m√°s obvias aqu√≠ es que en Qt, una secuencia, en t√©rminos generales, puede que ni siquiera tenga un Despachador y, por lo tanto, ni un solo EventLoop.  Los objetos que pertenecen a esta secuencia no responder√°n a los eventos que se les env√≠en.  Dado que QThread :: run () por defecto llama a QThread :: exec () dentro del cual se acaba de implementar el EventLoop est√°ndar, aquellos que a menudo intentan determinar su propia versi√≥n de run () heredada de QThread a menudo enfrentan este problema.  Un caso de uso similar para QThread es, en principio, bastante v√°lido e incluso se recomienda en la documentaci√≥n, pero va en contra de la idea general de organizar el c√≥digo en Qt descrito anteriormente y, a menudo, no funciona como <i>esperan los</i> usuarios.  Un error t√≠pico en este caso es un intento de detener un QThread personalizado llamando a QThread :: exit () o quit ().  Ambas funciones env√≠an un mensaje a QEventLoop, pero si simplemente no hay QEventLoop en la secuencia, entonces naturalmente no hay nadie para procesarlas.  Como resultado, los usuarios inexpertos que intentan "arreglar una clase rota" comienzan a intentar usar un QThread :: terminate "funcional", lo cual es absolutamente imposible.  Tenga en cuenta que si redefine run () y no utiliza el bucle de eventos est√°ndar, deber√° proporcionar un mecanismo para salir del hilo usted mismo, por ejemplo, usando la funci√≥n QThread :: requestInterruption () especialmente agregada para esto.  Sin embargo, es m√°s correcto simplemente no heredar de QThread si realmente no va a implementar alg√∫n nuevo tipo especial de subprocesos y usar el QtConcurrent creado especialmente para dichos scripts, o poner la l√≥gica en un objeto de trabajo especial heredado de QObject, colocar este √∫ltimo en QThread est√°ndar y administrar Trabajador utilizando se√±ales. <br><br><a name="part3"></a><h3>  Hilo de afinidad, inicializaci√≥n y sus limitaciones. </h3><br>  Entonces, como ya hemos descubierto, cada objeto en Qt "pertenece" a alguna secuencia.  Al mismo tiempo, surge una pregunta l√≥gica: ¬øa qu√©, de hecho, exactamente?  Las siguientes convenciones son aceptadas en Qt: <br><br>  <b>1. Todos los "hijos" de cualquier "padre" siempre viven en la misma secuencia que el padre</b> <br><br>  Esta es quiz√°s la limitaci√≥n m√°s poderosa del modelo de flujo Qt, y los intentos de romperlo a menudo dan resultados muy extra√±os para el usuario.  Por ejemplo, un intento de hacer setParent en un objeto que vive en otro hilo en Qt simplemente falla silenciosamente (se escribe una advertencia en la consola).  Aparentemente, este compromiso se alcanz√≥ debido al hecho de que la eliminaci√≥n segura de los "ni√±os" en el caso de la muerte de un padre que vive en otro hilo es muy poco trivial y propensa a errores dif√≠ciles de atrapar.  Si desea implementar una jerarqu√≠a de objetos interactivos que viven en diferentes flujos, tendr√° que organizar la eliminaci√≥n usted mismo. <br><br>  <b>2. Un objeto cuyo padre no se especifica durante la creaci√≥n vive en la secuencia que lo cre√≥</b> <br><br>  Todo aqu√≠ al mismo tiempo, simple y al mismo tiempo, no siempre es obvio.  Por ejemplo, en virtud de esta regla, QThread (como un objeto) vive en un hilo diferente al hilo que se controla a s√≠ mismo (y en virtud de la regla 1, no puede poseer ninguno de los objetos creados en este hilo).  O, por ejemplo, si redefine QThread :: run y crea cualquier descendiente de QObject dentro, sin tomar medidas especiales (como se discuti√≥ en el cap√≠tulo anterior), los objetos creados no responder√°n a las se√±ales. <br><br>  La afinidad de subprocesos se puede cambiar si es necesario llamando a QObject :: moveToThread.  En virtud de la regla 1, solo se pueden mover "padres" de nivel superior (para los cuales padre == nulo), un intento de mover a cualquier "ni√±o" se ignorar√° en silencio.  Cuando el "padre" de nivel superior se mueve, todos sus "hijos" tambi√©n se mover√°n a una nueva secuencia.  Curiosamente, la llamada a moveToThread (nullptr) tambi√©n es legal y es una forma de crear un objeto con una afinidad de hilo "nulo";  tales objetos no pueden recibir ning√∫n mensaje. <br><br>  Puede obtener el hilo de ejecuci√≥n "actual" a trav√©s de una llamada a la funci√≥n QThread :: currentThread (), el hilo al que est√° asociado el objeto, a trav√©s de una llamada a QObject :: thread () <br><br><div class="spoiler">  <b class="spoiler_title">Una pregunta interesante sobre la atenci√≥n</b> <div class="spoiler_text">  Tenga en cuenta que la implementaci√≥n de la funcionalidad de propiedad de objetos y almacenamiento de QEventos dirigidos a ellos, obviamente, requiere que el flujo almacene los datos correspondientes en alg√∫n lugar.  En el caso de Qt, la clase base QThread generalmente est√° involucrada en la extracci√≥n y gesti√≥n de dichos datos.  Pero, ¬øqu√© sucede si crea un QObject en alg√∫n std :: thread o llama a la funci√≥n QThread :: currentThread () desde este hilo?  Resulta que en este caso Qt impl√≠citamente "detr√°s de escena" crear√° un objeto contenedor especial QAdoptedThread no propietario.  Al mismo tiempo, corresponde al usuario asegurarse independientemente de que todos los objetos de dicha secuencia se eliminen antes de que se detenga la secuencia que los gener√≥. <br></div></div><br><a name="part4"></a><h3>  Hilo principal, QCoreApplication y GUI </h3><br>  Entre todos los hilos, Qt definitivamente seleccionar√° un "hilo principal", que en el caso de aplicaciones de IU tambi√©n se convierte en un hilo GUI.  En este hilo vive el objeto QApplication (QCoreApplication / QGuiApplication) que sirve el bucle principal de eventos orientado a trabajar con mensajes del sistema operativo.  En virtud de la regla No. 2 de la secci√≥n anterior, en la pr√°ctica, el hilo "principal" ser√° el que realmente cre√≥ el objeto QApplication, y dado que en muchos sistemas operativos el "hilo principal" tiene un significado especial, la documentaci√≥n recomienda crear QApplication con el primer objeto en su conjunto. Qt programa y hazlo inmediatamente despu√©s de iniciar la aplicaci√≥n (== dentro del primer hilo del proceso).  Para obtener un puntero al hilo principal de la aplicaci√≥n, respectivamente, puede usar una construcci√≥n del formulario QCoreApplication :: instance () -&gt; thread ().  Sin embargo, desde el punto de vista t√©cnico, QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tambi√©n se puede colgar en un flujo no principal ()</a> , por ejemplo, si la interfaz Qt se crea dentro de alg√∫n tipo de complemento y, en muchos casos, funcionar√° bien. <br><br>  Debido a la regla "los objetos creados heredan el hilo actual", siempre puede trabajar con calma sin ir m√°s all√° de los l√≠mites de un hilo.  Todos los objetos creados ir√°n autom√°ticamente al hilo "principal" para el mantenimiento, donde siempre habr√° un bucle de eventos y (debido a la ausencia de otros hilos) nunca habr√° problemas con la sincronizaci√≥n.  Incluso si est√° trabajando con un sistema m√°s complejo que requiere subprocesos m√∫ltiples, la mayor√≠a de los objetos probablemente caer√°n en la secuencia principal, con la excepci√≥n de los pocos que se colocar√°n expl√≠citamente en otro lugar.  Quiz√°s es precisamente esta circunstancia la que da lugar a la aparente "magia" en la que los objetos parecen funcionar independientemente sin ning√∫n esfuerzo (porque la multitarea cooperativa se implementa dentro del flujo) y al mismo tiempo no requieren sincronizaci√≥n, bloqueo o similares (porque todo sucede en un hilo ) <br><br>  Adem√°s del hecho de que el subproceso "principal" es el "primero" y contiene el bucle principal de procesamiento de eventos QCoreApplication, otra limitaci√≥n caracter√≠stica de Qt es que todos los objetos relacionados con la GUI deben "vivir" en este subproceso.  Esto es en parte una consecuencia de Legacy: debido al hecho de que en algunos sistemas operativos cualquier operaci√≥n con la GUI puede ocurrir solo en el hilo principal, Qt subdivide todos los objetos en "widgets" y "no widgets".  El objeto de tipo widget solo puede vivir en el hilo principal, un intento de "superar" tal objeto en cualquier otro se encender√° autom√°ticamente.  En virtud de esto, incluso hay un m√©todo especial QObject :: isWidgetType () que refleja diferencias internas bastante profundas en la mec√°nica de trabajar con dichos objetos.  Pero es interesante que en el QtQuick mucho m√°s nuevo, donde intentaron alejarse de la muleta con isWidgetType, el mismo problema persist√≠a <br><br>  Cual es el problema  En Qt5, los objetos QML ya no son widgets y se pueden representar en un hilo separado.  Pero esto condujo a otro problema: dificultades de sincronizaci√≥n.  La representaci√≥n de los objetos de la interfaz de usuario es una "lectura" de su estado y debe ser coherente: si intentamos cambiar el estado de un objeto al mismo tiempo que su representaci√≥n, el resultado de la "raza" resultante puede no agradarnos.  Adem√°s, OpenGL en torno al cual se construye el "nuevo" gr√°fico Qt est√° extremadamente "agudizado" por el hecho de que la formaci√≥n de comandos de dibujo se lleva a cabo mediante un hilo que trabaja con alg√∫n estado global: el "contexto gr√°fico" que solo puede cambiar como una serie de operaciones secuenciales.  Simplemente no podemos dibujar simult√°neamente dos objetos gr√°ficos diferentes en la pantalla: siempre se dibujar√°n secuencialmente uno tras otro.  Como resultado, volvemos a la misma soluci√≥n: la representaci√≥n de la IU se asigna a un subproceso.  Sin embargo, un lector atento se dar√° cuenta de que este hilo no tiene que ser el hilo principal, y en Qt5 el marco realmente intentar√° usar un hilo de renderizado separado para esto. <br><br><a name="part5"></a><h3>  Hilo de renderizado </h3><br>  En el marco del nuevo modelo Qt5, toda la representaci√≥n de objetos tiene lugar en un hilo especialmente asignado para esto, el hilo de representaci√≥n.  Al mismo tiempo, para que esto tenga sentido y no se limite a simplemente cambiar de un flujo "principal" a otro, los objetos se dividen impl√≠citamente en un "front-end" que el programador ve y generalmente un "back-end" oculto para √©l que realmente realiza la representaci√≥n real.  El back-end vive en el hilo de renderizado, mientras que el front-end, te√≥ricamente, puede vivir en cualquier otro hilo.  Se supone que el front-end realiza el trabajo √∫til (si lo hay) en forma de procesamiento de eventos, mientras que la funci√≥n de back-end est√° limitada solo por la representaci√≥n.  En teor√≠a, resulta ganar-ganar: la parte posterior peri√≥dicamente "sondea" el estado actual de los objetos y los dibuja en la pantalla, mientras que no puede ser "detenido" por el hecho de que algunos de los objetos estaban "pensando" demasiado mientras procesaba el evento debido al hecho de que esto el procesamiento lento ocurre en otro hilo.  A su vez, el flujo del objeto no necesita esperar "respuestas" del controlador de gr√°ficos que confirman la finalizaci√≥n de la representaci√≥n, y diferentes objetos pueden funcionar en diferentes flujos. <br><br>  Pero como ya mencion√© en el cap√≠tulo anterior, dado que tenemos una secuencia que crea datos (un frente) y una secuencia que los lee (atr√°s), necesitamos sincronizarlos de alguna manera.  Esta sincronizaci√≥n en Qt se realiza mediante bloqueos.  El flujo donde vive el frente se suspende temporalmente, seguido de una llamada de funci√≥n especial (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: synchronize ()) cuya √∫nica tarea es copiar el objeto relevante para la visualizaci√≥n desde el frente hacia atr√°s ".  En este caso, la llamada a dicha funci√≥n ocurre <i>dentro del hilo de renderizado</i> , pero debido al hecho de que el hilo donde vive el objeto en este momento se detiene, el usuario puede trabajar libremente con los datos del objeto como si sucediera "como de costumbre", dentro del flujo al que pertenece el objeto. <br><br>  ¬øEst√° todo bien, est√° todo bien?  Desafortunadamente, no, y los momentos bastante obvios comienzan aqu√≠.  Si tomamos un bloqueo individualmente para cada objeto, ser√° bastante lento ya que el hilo de renderizado se ver√° obligado a esperar hasta que estos objetos terminen de procesar sus eventos.  La secuencia "colgar" donde vive el objeto es "colgar" y renderizar.  Adem√°s, ser√° posible una "desincronizaci√≥n" cuando, cuando se cambien dos objetos simult√°neamente, uno se dibujar√° en el cuadro N y el otro se dibujar√° solo en el cuadro N + 1.  Ser√≠a preferible tomar el bloqueo solo una vez y para todos los objetos a la vez y solo cuando estemos seguros de que este bloqueo ser√° exitoso. <br><br>  ¬øQu√© se implement√≥ para resolver este problema en Qt?  En primer lugar, se decidi√≥ que todos los objetos "gr√°ficos" de una ventana vivir√≠an en una secuencia.  Por lo tanto, para dibujar una ventana y bloquear todos los objetos contenidos en ella, se vuelve suficiente para detener esta secuencia solo.  En segundo lugar, el subproceso con objetos de interfaz de usuario inicia el bloqueo para actualizar el back-end, enviando un mensaje al subproceso de representaci√≥n sobre la necesidad de sincronizarse y detenerse a s√≠ mismo (QSGThreadedRenderLoop :: polishAndSync si alguien est√° interesado).  Esto garantiza que el subproceso de representaci√≥n nunca "esperar√°" una secuencia de front-end.  Si de repente se "cuelga", el hilo de representaci√≥n simplemente continuar√° dibujando el estado "antiguo" de los objetos sin recibir mensajes sobre la necesidad de actualizar.  Esto realmente da lugar a errores bastante divertidos de la forma "si por alguna raz√≥n el renderizado no puede dibujar la ventana inmediatamente, el hilo principal se congela", pero en general es un compromiso razonable.  Comenzando con QtQuick 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios objetos "animados"</a> pueden incluso ser "poblados" en el hilo de renderizado para que la animaci√≥n tambi√©n pueda continuar funcionando si el hilo principal est√° "pensado". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  Sin embargo, la consecuencia pr√°ctica de esta soluci√≥n es que todos los objetos de la interfaz de usuario deben vivir en el mismo hilo de todos modos.  En el caso de los widgets antiguos, en el hilo "principal", en el caso de los nuevos objetos Qt Quick, en el hilo del objeto QQuickWindow que los posee.  La √∫ltima regla es bastante elegante: para dibujar un QQuickItem necesita hacer setParent en la QQuickWindow correspondiente, que, como ya se discuti√≥, asegura que el objeto se mueva a la secuencia correspondiente o la llamada setParent falle. <br><br>  Y ahora, por desgracia, una mosca en el ung√ºento: aunque QQuickWindow diferente podr√≠a vivir te√≥ricamente en diferentes flujos, en la pr√°ctica esto requiere el env√≠o preciso de mensajes del sistema operativo a ellos y en Qt hoy no est√° implementado.  En Qt 5.13, por ejemplo, QCoreApplication intenta comunicarse con QQuickWindow a trav√©s de sendEvent que requiere que el receptor y la parte emisora ‚Äã‚Äãest√©n en el mismo hilo (en lugar de postEvent que permite que los hilos sean diferentes).  Por lo tanto, en la pr√°ctica, QQuickWindow solo funciona correctamente en un hilo GUI y, como resultado, todos los objetos QtQuick viven en el mismo lugar.  Como resultado, a pesar de la presencia del hilo de representaci√≥n, casi todos los objetos relacionados con la GUI disponibles para el usuario todav√≠a viven en el mismo hilo de la GUI.  Quiz√°s esto cambie en Qt 6. <br><br>  Adem√°s de lo anterior, vale la pena recordar que, dado que Qt funciona en muchas plataformas diferentes (incluidas las que no admiten subprocesos m√∫ltiples), el marco proporciona un n√∫mero decente de fallos y, en algunos casos, la funcionalidad del hilo de renderizado es realmente realizada por el mismo hilo gui .  En este caso, toda la interfaz de usuario, incluida la representaci√≥n, vive en un hilo y el problema de sincronizaci√≥n desaparece autom√°ticamente.  La situaci√≥n es similar con la interfaz de usuario m√°s antigua, basada en widgets de estilo Qt4.      Qt    ¬´¬ª       QSG_RENDER_LOOP   . <br><br><a name="part6"></a><h3>  Conclusi√≥n </h3><br> Qt ‚Äî              .     ,   ,           Qt      . <br><br>     ; <br><br><ul><li>    ¬´¬ª         ,   queued signals </li><li>  ¬´¬ª     Qt Event Loop                   exit() </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los padres y los descendientes siempre viven en la misma corriente. </font><font style="vertical-align: inherit;">Solo el padre de nivel superior se puede transferir de una transmisi√≥n a otra. </font><font style="vertical-align: inherit;">La violaci√≥n de esta regla puede resultar en una falla silenciosa de la operaci√≥n setParent o moveToThread</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un objeto cuyo padre no se especifica se convierte en propiedad del hilo que cre√≥ este objeto. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos los objetos de la GUI, excepto el back-end de representaci√≥n, deben vivir en la secuencia de la GUI </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El hilo GUI es aquel en el que se cre√≥ el objeto QApplication </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espero que esto lo ayude a usar Qt de manera m√°s eficiente y no cometer errores asociados con su modelo de subprocesos m√∫ltiples </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467261/">https://habr.com/ru/post/467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467251/index.html">Rehenes COBOL y Matem√°ticas. Parte 1</a></li>
<li><a href="../467253/index.html">Rehenes COBOL y Matem√°ticas. Parte 2</a></li>
<li><a href="../467255/index.html">Tres errores de seguridad comunes que todo desarrollador de React debe conocer</a></li>
<li><a href="../467257/index.html">No guardes todos tus huevos en una canasta a la vez</a></li>
<li><a href="../467259/index.html">DPI (inspecci√≥n SSL) contradice el significado de la criptograf√≠a, pero las empresas la implementan</a></li>
<li><a href="../467263/index.html">Ganamos en energ√≠a solar o ingresos pasivos al 25% anual, experiencia pr√°ctica. Parte 2</a></li>
<li><a href="../467269/index.html">Modelos en seguridad de la informaci√≥n</a></li>
<li><a href="../467271/index.html">Programador vocacional, qu√≠mico de profesi√≥n.</a></li>
<li><a href="../467275/index.html">Al d√≠a del programador. Programador en 2019</a></li>
<li><a href="../467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>