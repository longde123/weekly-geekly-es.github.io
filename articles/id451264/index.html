<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔞 🔽 🌪️ Aplikasi praktis dari ELK. Konfigurasikan logstash ✉️ 🥪 📪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Menyebarkan sistem berikutnya, dihadapkan dengan kebutuhan untuk memproses sejumlah besar berbagai log. Sebagai alat yang dipilih ELK. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi praktis dari ELK. Konfigurasikan logstash</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451264/"><h1>  Pendahuluan </h1><br>  Menyebarkan sistem berikutnya, dihadapkan dengan kebutuhan untuk memproses sejumlah besar berbagai log.  Sebagai alat yang dipilih ELK.  Artikel ini akan membahas pengalaman kami dengan menyetel tumpukan ini. <br><br>  Kami tidak menetapkan tujuan untuk menggambarkan semua kemungkinannya, tetapi kami ingin berkonsentrasi tepat pada penyelesaian masalah praktis.  Ini disebabkan oleh fakta bahwa di hadapan sejumlah besar dokumentasi dan gambar siap pakai, ada banyak jebakan, setidaknya kami menemukannya. <br><a name="habracut"></a><br>  Kami menyebarkan tumpukan melalui docker-compose.  Selain itu, kami memiliki docker-compose.yml yang ditulis dengan baik, yang memungkinkan kami untuk meningkatkan tumpukan tanpa masalah.  Dan bagi kami tampaknya kemenangan sudah dekat, sekarang kita akan sedikit memutar agar sesuai dengan kebutuhan kita dan hanya itu. <br><br>  Sayangnya, upaya untuk menyempurnakan sistem untuk menerima dan memproses log dari aplikasi kami tidak berhasil.  Karena itu, kami memutuskan bahwa ada baiknya mengeksplorasi setiap komponen secara terpisah, dan kemudian kembali ke hubungan mereka. <br><br>  Jadi, kami mulai dengan logstash. <br><br><h1>  Lingkungan, penyebaran, luncurkan Logstash di wadah </h1><br>  Untuk penyebaran, kami menggunakan docker-compose, percobaan yang dijelaskan di sini dilakukan pada MacOS dan Ubuntu 18.0.4. <br><br>  Gambar logstash yang terdaftar dengan kami di docker-compose.yml asli adalah docker.elastic.co/logstash/logstash:6.3.2 <br><br>  Kami akan menggunakannya untuk eksperimen. <br><br>  Untuk menjalankan logstash, kami menulis docker-compose.yml terpisah.  Tentu saja, dimungkinkan untuk meluncurkan gambar dari baris perintah, tetapi kami memang memecahkan masalah tertentu, di mana semuanya dari docker-compose diluncurkan. <br><br><h2>  Secara singkat tentang file konfigurasi </h2><br>  Sebagai berikut dari deskripsi, logstash dapat dijalankan baik untuk satu saluran, dalam hal ini, perlu mentransfer file * .conf atau untuk beberapa saluran, dalam hal ini perlu ditransfer file pipelines.yml, yang, pada gilirannya, akan terhubung ke file .conf untuk setiap saluran. <br>  Kami pergi ke jalan kedua.  Bagi kami, itu lebih universal dan dapat diukur.  Oleh karena itu, kami membuat pipelines.yml, dan membuat direktori jalur pipa tempat kami akan meletakkan file .conf untuk setiap saluran. <br><br>  Di dalam wadah ada file konfigurasi lain - logstash.yml.  Kami tidak menyentuhnya, gunakan apa adanya. <br><br>  Jadi, struktur direktori kami: <br><br><img src="https://habrastorage.org/webt/ci/zd/49/cizd49eci9alvlbi1fwk8nyyaky.png"><br><br>  Untuk mendapatkan input, untuk saat ini, kami percaya bahwa ini adalah tcp pada port 5046, dan untuk output kami akan menggunakan stdout. <br><br>  Berikut ini adalah konfigurasi sederhana untuk proses pertama.  Karena tugas awal adalah meluncurkan. <br><br>  Jadi, kami memiliki docker-compose.yml ini <br><br><pre><code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro</code> </pre> <br>  Apa yang kita lihat di sini? <br><br><ol><li>  Jaringan dan volume diambil dari buruh pelabuhan asli-compose.yml (yang mana seluruh tumpukan diluncurkan) dan saya pikir mereka tidak secara signifikan mempengaruhi keseluruhan gambar di sini. </li><li>  Kami membuat satu layanan logstash dari gambar docker.elastic.co/logstash/logstash:6.3.2 dan memberinya nama logstash_one_channel. </li><li>  Kami meneruskan port 5046 di dalam wadah ke port internal yang sama. </li><li>  Kami memetakan file pengaturan saluran kami ./config/pipelines.yml ke file /usr/share/logstash/config/pipelines.yml di dalam wadah, tempat logstash akan mengambilnya dan membuatnya hanya-baca, untuk berjaga-jaga. </li><li>  Kami menampilkan direktori ./config/pipelines, di mana kami memiliki file dengan pengaturan saluran, di direktori / usr / share / logstash / config / pipeline dan juga membuatnya hanya-baca. </li></ol><br><img src="https://habrastorage.org/webt/5u/s3/dw/5us3dwu8forutzwmtlfnlcjt-ic.png"><br><br>  File Pipelines.yml <br><br><pre> <code class="plaintext hljs">- pipeline.id: HABR pipeline.workers: 1 pipeline.batch.size: 1 path.config: "./config/pipelines/habr_pipeline.conf"</code> </pre><br>  Di sini, satu saluran dengan pengidentifikasi HABR dan jalur ke file konfigurasinya dijelaskan. <br><br>  Dan akhirnya file "./config/pipelines/habr_pipeline.conf" <br><br><pre> <code class="plaintext hljs">input { tcp { port =&gt; "5046" } } filter { mutate { add_field =&gt; [ "habra_field", "Hello Habr" ] } } output { stdout { } }</code> </pre><br>  Mari kita tidak menjelaskan deskripsinya untuk saat ini, cobalah menjalankan: <br><br><pre> <code class="bash hljs">docker-compose up</code> </pre><br>  Apa yang kita lihat <br><br>  Wadah mulai.  Kami dapat memeriksa operasinya: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'13123123123123123123123213123213'</span></span> | nc localhost 5046</code> </pre><br>  Dan kita melihat jawabannya di konsol wadah: <br><br><img src="https://habrastorage.org/webt/uj/oy/tz/ujoytzcsc_mmiagm05savxahnzm.jpeg"><br><br>  Tetapi pada saat yang sama, kita juga melihat: <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59.790] <font color="«CC0000»">[ERROR] [logstash.licensechecker.licensereader] Tidak dapat mengambil informasi lisensi dari server lisensi {: message =&gt; "Elasticsearch Tidak Dapat Dicapai: [http: // elasticsearch: 9200 /]</font> [Manticore :: ResolutionFailure] elasticsearch ", ... <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59.894] [INFO] [logstash.pipeline] <font color="green">Pipeline mulai berhasil</font> {: pipeline_id =&gt; ". Monitoring-logstash" ,: thread =&gt; "# &lt;Thread: 0x119abb86 run&gt;"} <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59.988] [INFO] [logstash.agent] Pipa berjalan {: count =&gt; 2 ,: running_pipelines =&gt; [: HABR ,: ". Monitoring-logstash"] ,: non_running_pipelines =&gt; [ ]} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 00.015] <font color="«CC0000»">[ERROR] [logstash.inputs.metrics] X-Pack diinstal pada Logstash tetapi tidak pada Elasticsearch.</font>  <font color="«CC0000»">Silakan instal X-Pack di Elasticsearch untuk menggunakan fitur pemantauan.</font>  <font color="«CC0000»">Fitur lain mungkin tersedia.</font> <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 00,526] [INFO] [logstash.agent] Berhasil memulai titik akhir API Logstash {: port =&gt; 9600} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04.478] [INFO] [logstash.outputs.elasticsearch] Menjalankan pemeriksaan kesehatan untuk melihat apakah koneksi Elasticsearch berfungsi {: healthcheck_url =&gt; http: // elasticsearch: 9200 / ,: path =&gt; "/"} <br>  l <font color="«#38B9C7»">ogstash_one_channel |</font>  [2019-04-29T11: 29: 04.487] <font color="orange">[</font> PERINGATAN] <font color="orange">[logstash.outputs.elasticsearch] Mencoba untuk menghidupkan kembali koneksi ke instance ES yang mati, tetapi mengalami kesalahan.</font>  <font color="orange">{: url =&gt; “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elasticsearch</a> : 9200 /” ,: error_type =&gt; LogStash :: Outputs :: ElasticSearch :: HttpClient :: Pool :: HostUnreachableError ,: error =&gt; “Elasticsearch Tidak Dapat Dicapai: [http: // elasticsearch: 9200 / ] [Manticore :: ResolutionFailure] elasticsearch ”}</font> <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04.704] [INFO] [logstash.licensechecker.licensereader] Menjalankan pemeriksaan kesehatan untuk melihat apakah koneksi Elasticsearch berfungsi {: healthcheck_url =&gt; http: // elasticsearch: 9200 / ,: path =&gt; "/"} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04.710] <font color="orange">[</font> PERINGATAN] <font color="orange">[logstash.licensechecker.licensereader] Berusaha membangkitkan kembali koneksi ke instance ES yang mati, tetapi mengalami kesalahan.</font>  <font color="orange">{: url =&gt; “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elasticsearch</a> : 9200 /” ,: error_type =&gt; LogStash :: Outputs :: ElasticSearch :: HttpClient :: Pool :: HostUnreachableError ,: error =&gt; “Elasticsearch Tidak Dapat Dicapai: [http: // elasticsearch: 9200 / ] [Manticore :: ResolutionFailure] elasticsearch ”}</font> <br><br>  Dan log kami terus merayap. <br><br>  Di sini saya menyoroti pesan hijau bahwa pipa mulai berhasil, merah - pesan kesalahan dan kuning - pesan tentang upaya untuk menghubungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elasticsearch</a> : 9200. <br>  Ini terjadi karena logstash.conf yang termasuk dalam gambar memiliki pemeriksaan ketersediaan elasticsearch.  Bagaimanapun, logstash mengasumsikan bahwa ia berfungsi sebagai bagian dari tumpukan Elk, dan kami memisahkannya. <br><br>  Anda dapat bekerja, tetapi tidak nyaman. <br><br>  Solusinya adalah dengan menonaktifkan pemeriksaan ini melalui variabel lingkungan XPACK_MONITORING_ENABLED. <br><br>  Buat perubahan ke docker-compose.yml dan jalankan kembali: <br><br><pre> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro</code> </pre><br>  Sekarang semuanya baik-baik saja.  Wadah siap untuk eksperimen. <br><br>  Kita dapat mengetik lagi di konsol berikutnya: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'13123123123123123123123213123213'</span></span> | nc localhost 5046</code> </pre><br>  Dan lihat: <br><br><pre> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "message" =&gt; "13123123123123123123123213123213", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T11:43:44.582Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "host" =&gt; "gateway", logstash_one_channel | "port" =&gt; 49418 logstash_one_channel | }</code> </pre><br><h1>  Bekerja dalam satu saluran </h1><br>  Jadi, kami mulai.  Sekarang Anda benar-benar dapat meluangkan waktu untuk mengkonfigurasi logstash secara langsung.  Kami tidak akan menyentuh file pipelines.yml untuk saat ini, kami akan melihat apa yang dapat Anda peroleh dengan bekerja dengan satu saluran. <br><br>  Saya harus mengatakan bahwa prinsip umum bekerja dengan file konfigurasi saluran dijelaskan dengan baik dalam panduan resmi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br>  Jika Anda ingin membaca dalam bahasa Rusia, maka kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (tetapi sintaks kueri sudah tua di sana, kami harus mempertimbangkan ini). <br><br>  Mari kita berurutan dari bagian Input.  Kami sudah melihat pekerjaan di tcp.  Apa lagi yang menarik di sini? <br><br><h2>  Tes pesan menggunakan detak jantung </h2><br>  Ada peluang yang sangat menarik untuk menghasilkan pesan pengujian otomatis. <br>  Untuk melakukan ini, Anda harus memasukkan plugin heartbean di bagian input. <br><br><pre> <code class="plaintext hljs">input { heartbeat { message =&gt; "HeartBeat!" } }</code> </pre><br>  Hidupkan, mulai satu menit sekali untuk menerima <br><br><pre> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "@timestamp" =&gt; 2019-04-29T13:52:04.567Z, logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "HeartBeat!", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "host" =&gt; "a0667e5c57ec" logstash_one_channel | }</code> </pre><br>  Kami ingin lebih sering, kami perlu menambahkan parameter interval. <br>  Ini adalah bagaimana kami akan menerima pesan setiap 10 detik. <br><br><pre> <code class="plaintext hljs">input { heartbeat { message =&gt; "HeartBeat!" interval =&gt; 10 } }</code> </pre><br><h2>  Mengambil data dari file </h2><br>  Kami juga memutuskan untuk melihat mode file.  Jika ini bekerja secara normal dengan file, maka ada kemungkinan bahwa tidak ada agen yang diperlukan, setidaknya untuk penggunaan lokal. <br><br>  Menurut deskripsi, mode operasi harus mirip dengan tail -f, yaitu  membaca baris baru atau, sebagai opsi, membaca seluruh file. <br><br>  Jadi apa yang ingin kita dapatkan: <br><br><ol><li>  Kami ingin mendapatkan baris yang ditambahkan ke satu file log. </li><li>  Kami ingin menerima data yang ditulis ke beberapa file log, sambil dapat membagikan apa yang berasal. </li><li>  Kami ingin memeriksa bahwa ketika memulai kembali logstash tidak akan menerima data ini lagi. </li><li>  Kami ingin memeriksa apakah logstash dinonaktifkan, dan data terus ditulis ke file, maka ketika kami menjalankannya, kami akan mendapatkan data ini. </li></ol><br>  Untuk melakukan percobaan, tambahkan baris lain ke docker-compose.yml, buka direktori tempat kami meletakkan file. <br><br><pre> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro - ./logs:/usr/share/logstash/input</code> </pre><br>  Dan ubah bagian input di habr_pipeline.conf <br><br><pre> <code class="plaintext hljs">input { file { path =&gt; "/usr/share/logstash/input/*.log" } }</code> </pre><br>  Kita mulai: <br><br><pre> <code class="bash hljs">docker-compose up</code> </pre><br>  Untuk membuat dan merekam file log, kita akan menggunakan perintah: <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt; logs/number1.log</code> </pre><br><pre> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:28:53.876Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log" logstash_one_channel | }</code> </pre><br>  Ya, itu berhasil! <br><br>  Pada saat yang sama, kami melihat bahwa kami secara otomatis menambahkan bidang jalur.  Jadi di masa mendatang, kita dapat memfilter catatan dengan itu. <br><br>  Mari kita coba lagi: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'2'</span></span> &gt;&gt; logs/number1.log</code> </pre><br><pre> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:28:59.906Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "2", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log" logstash_one_channel | }</code> </pre><br><br>  Dan sekarang ke file lain: <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt; logs/number2.log</code> </pre><br><pre> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:29:26.061Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number2.log" logstash_one_channel | }</code> </pre><br>  Hebat!  File diambil, path benar, semuanya baik-baik saja. <br><br>  Hentikan logstash dan mulai ulang.  Mari kita tunggu.  Kesunyian.  Yaitu  Kami tidak menerima catatan ini lagi. <br><br>  Dan sekarang percobaan paling berani. <br><br>  Kami menaruh logstash dan menjalankan: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'3'</span></span> &gt;&gt; logs/number2.log <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'4'</span></span> &gt;&gt; logs/number1.log</code> </pre><br>  Jalankan logstash lagi dan lihat: <br><br><pre> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "3", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number2.log", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:48:50.589Z logstash_one_channel | } logstash_one_channel | { logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "4", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:48:50.856Z logstash_one_channel | }</code> </pre><br>  Hore!  Semuanya diambil. <br><br>  Tetapi, kita harus memperingatkan tentang yang berikut ini.  Jika wadah dengan logstash dihapus (buruh pelabuhan berhenti logstash_one_channel &amp;&amp; buruh pelabuhan rm logstash_one_channel), maka tidak ada yang akan diambil.  Di dalam wadah, posisi file yang dibaca disimpan.  Jika dijalankan dari awal, itu hanya akan menerima baris baru. <br><br><h3>  Baca file yang ada </h3><br>  Misalkan kita menjalankan logstash untuk pertama kalinya, tetapi kami sudah memiliki log dan kami ingin memprosesnya. <br>  Jika kami menjalankan logstash dengan bagian input yang kami gunakan di atas, kami tidak akan mendapatkan apa pun.  Hanya baris baru yang akan diproses oleh logstash. <br><br>  Untuk menarik baris dari file yang ada, tambahkan baris tambahan ke bagian input: <br><br><pre> <code class="plaintext hljs">input { file { start_position =&gt; "beginning" path =&gt; "/usr/share/logstash/input/*.log" } }</code> </pre><br>  Selain itu, ada nuansa, ini hanya mempengaruhi file baru yang belum terlihat logstash.  Untuk file yang sama yang sudah jatuh ke bidang tampilan logstash, dia sudah ingat ukurannya dan sekarang hanya akan mengambil entri baru di dalamnya. <br><br>  Mari kita mempelajari bagian input.  Ada banyak opsi lagi, tetapi bagi kami, untuk percobaan lebih lanjut untuk saat ini sudah cukup. <br><br><h2>  Routing dan konversi data </h2><br>  Mari kita coba untuk menyelesaikan masalah berikut, katakanlah kita memiliki pesan dari satu saluran, beberapa di antaranya bersifat informasi, dan sebagian lagi merupakan pesan kesalahan.  Tag berbeda.  Beberapa INFO, yang lain ERROR. <br><br>  Kita perlu memisahkan mereka pada output.  Yaitu  Kami menulis pesan informasi dalam satu saluran, dan pesan kesalahan di saluran lain. <br><br>  Untuk melakukan ini, pergi dari bagian input untuk memfilter dan output. <br><br>  Menggunakan bagian filter, kami akan mem-parsing pesan yang masuk, mendapatkan dari hash (pasangan nilai kunci), yang sudah bisa Anda gunakan, mis.  dibongkar oleh kondisi.  Dan di bagian output, kami memilih pesan dan mengirim masing-masing ke saluran kami. <br><br><h3>  Parsing pesan menggunakan grok </h3><br>  Untuk mengurai string teks dan mendapatkan seperangkat bidang dari mereka, ada plugin khusus di bagian filter - grok. <br><br>  Tidak bermaksud untuk memberikan deskripsi rinci di sini (untuk ini saya merujuk pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> ), saya akan memberikan contoh sederhana saya. <br><br>  Untuk melakukan ini, Anda perlu memutuskan format jalur input.  Saya memilikinya: <br><br>  1 pesan INFO1 <br>  2 pesan KESALAHAN2 <br><br>  Yaitu  Pengenal datang terlebih dahulu, lalu INFO / GALAT, lalu beberapa kata tanpa spasi. <br>  Tidak sulit, tetapi cukup untuk memahami cara kerjanya. <br><br>  Jadi, di bagian filter, di plugin grok, kita perlu mendefinisikan pola untuk mem-parsing baris kita. <br><br>  Ini akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">filter { grok { match =&gt; { "message" =&gt; ["%{INT:message_id} %{LOGLEVEL:message_type} %{WORD:message_text}"] } } }</code> </pre><br>  Ini pada dasarnya adalah ekspresi reguler.  Pola siap pakai digunakan, seperti INT, LOGLEVEL, WORD.  Deskripsi mereka, serta pola lainnya, dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Sekarang, melewati filter ini, string kita akan berubah menjadi hash dari tiga bidang: message_id, message_type, message_text. <br><br>  Mereka akan ditampilkan di bagian output. <br><br><h3>  Merutekan pesan di bagian output menggunakan perintah if </h3><br>  Di bagian keluaran, seperti yang kita ingat, kami akan membagi pesan menjadi dua aliran.  Beberapa - yang iNFO, kami akan output ke konsol, dan dengan kesalahan, kami akan output ke file. <br><br>  Bagaimana kami membagi posting ini?  Kondisi masalah sudah meminta solusi - kami sudah memiliki bidang message_type yang dipilih, yang hanya dapat mengambil dua nilai INFO dan ERROR.  Bagi dia kita akan membuat pilihan menggunakan pernyataan if. <br><br><pre> <code class="plaintext hljs">if [message_type] == "ERROR" { #     } else { #    stdout }</code> </pre><br>  Deskripsi bekerja dengan bidang dan operator dapat ditemukan di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual resmi ini</a> . <br><br>  Sekarang, tentang kesimpulan yang sebenarnya. <br><br>  Output ke konsol, semuanya jelas di sini - stdout {} <br><br>  Dan di sini adalah output ke file - ingat bahwa kita menjalankan semuanya dari wadah dan agar file yang kita tulis hasilnya dapat diakses dari luar, kita perlu membuka direktori ini di docker-compose.yml. <br><br>  Total: <br><br>  Bagian output dari file kami terlihat seperti ini: <br><br><pre> <code class="plaintext hljs"> output { if [message_type] == "ERROR" { file { path =&gt; "/usr/share/logstash/output/test.log" codec =&gt; line { format =&gt; "custom format: %{message}"} } } else {stdout { } } }</code> </pre><br>  Di docker-compose.yml, tambahkan volume lain ke keluaran: <br><br><pre> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro - ./logs:/usr/share/logstash/input - ./output:/usr/share/logstash/output</code> </pre><br>  Kami mulai, kami mencoba, kami melihat pembagian menjadi dua aliran. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451264/">https://habr.com/ru/post/id451264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451254/index.html">Kategori: penyedia IaaS besi unboxing</a></li>
<li><a href="../id451256/index.html">Apa itu sistem pelaporan yang ideal. Apakah realistis untuk memahami apa yang terjadi di perusahaan?</a></li>
<li><a href="../id451258/index.html">Tangkap aku jika kau bisa. Surat manajer</a></li>
<li><a href="../id451260/index.html">10 acara tematik Universitas ITMO</a></li>
<li><a href="../id451262/index.html">Ilmuwan dari Stanford: gadget yang ditempatkan di telinga akan dapat memonitor fungsi otak</a></li>
<li><a href="../id451266/index.html">Pemodelan tiga dimensi di dunia modern</a></li>
<li><a href="../id451268/index.html">Victor Gamov tentang Kafka Streaming IQ di jug.msk.ru</a></li>
<li><a href="../id451270/index.html">B = Perhatian, atau cara membuat waktu</a></li>
<li><a href="../id451272/index.html">Jika Anda sudah mengetuk pintu: cara melindungi informasi pada perangkat</a></li>
<li><a href="../id451274/index.html">Senjata Sempurna, Perang Perspektif dan Manusia yang Mencapai Langit-Langit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>