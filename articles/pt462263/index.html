<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è© üë®üèø‚Äçü§ù‚Äçüë®üèæ üèÇüèæ Pedal no ch√£o: crie outro manipulador de p√© para PC üéõÔ∏è üîä ü§¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° apenas um m√™s, me deparei com este artigo, que fala sobre pedalar o Vim. Um pouco mais tarde, ap√≥s meu longo estudo de tr√™s minutos, descobri que e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedal no ch√£o: crie outro manipulador de p√© para PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  H√° apenas um m√™s, me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> artigo, que fala sobre pedalar o Vim.  Um pouco mais tarde, ap√≥s meu longo estudo de tr√™s minutos, descobri que esse t√≥pico n√£o √© mais novo e bastante popular.  Eu mesmo uso o Vim apenas em caso de emerg√™ncia (se tiver que trabalhar no console, prefiro o Nano), mas voc√™ pode fazer o mesmo para outros aplicativos. <br><a name="habracut"></a><br>  Inicialmente, queria criar um pequeno artigo, mas recebi um tutorial completo sobre como criar este dispositivo com a reda√ß√£o passo a passo do c√≥digo e uma explica√ß√£o sobre o que e como.  Para n√£o inflar o artigo, nos spoilers haver√° v√°rias informa√ß√µes que pareciam interessantes e dignas da aten√ß√£o dos rec√©m-chegados ao Arduino, usu√°rios avan√ßados e especialmente apressados ‚Äã‚Äãpodem n√£o perder tempo com isso.  O c√≥digo fonte completo tamb√©m √© apresentado no final do artigo. <br><br><h2>  Por que eu preciso disso? </h2><br>  Se voc√™ n√£o tiver d√∫vidas sobre a necessidade e utilidade deste dispositivo, poder√° pular este item.  De resto, gostaria de falar primeiro sobre os pr√©-requisitos para a cria√ß√£o deste dispositivo. <br><br>  Em todos os momentos, programadores e designers tentam criar uma interface conveniente e amig√°vel para que o usu√°rio possa trabalhar com o aplicativo usando o mouse e o teclado sem problemas desnecess√°rios. Por que precisamos de outro manipulador?  Bem, vamos olhar um pouco para a hist√≥ria, ou melhor, no in√≠cio do s√©culo 18, quando um instrumento musical como o piano foi inventado.  Como voc√™ sabe, essa palavra se traduz literalmente como "alto e silencioso", mas poucas pessoas pensam que um mestre italiano inteligente recebeu esse instrumento ao "esmagar" o cravo que existia na √©poca, o que tornou poss√≠vel controlar o volume do som at√© certo ponto, sem tirando as m√£os das teclas. <br><br>  Existem muitos exemplos.  O carro tem pedais para n√£o jogar o volante, se voc√™ precisar adicionar gasolina.  O kit de bateria tamb√©m possui pedais para bater no bumbo e nos pratos.  E o que os pedais podem oferecer ao usar um computador?  Bem, por exemplo, voc√™ pode definir uma combina√ß√£o de teclas de atalho ou at√© mesmo adicionar uma tecla que n√£o existe, como ativar e desativar o som.  Os pedais podem ajudar se suas m√£os estiverem ocupadas: eu mesmo toco viol√£o e, √†s vezes, para o acompanhamento, seria muito conveniente rolar a parte de tr√°s sem tentar alcan√ßar constantemente o teclado.  E, finalmente, os controladores podem oferecer possibilidades completamente desumanas nos jogos: seria legal construir toda a sua base em uma estrat√©gia com um clique ou destruir inimigos a uma velocidade de uma d√∫zia de batidas por segundo em atiradores, certo? <br><br>  Em geral, espero ter convencido voc√™, o que significa que √© hora de prosseguir diretamente para o pr√≥prio desenvolvimento. <br><br><h2>  Recursos necess√°rios </h2><br><ul><li>  <b>Na verdade, os pedais.</b>  Algumas dificuldades surgiram imediatamente devido ao fato de eu n√£o conseguir pensar em um nome para esse pedal.  Eu s√≥ sabia que essas coisas s√£o usadas em m√°quinas de costura.  Em geral, a pedido do <b>pedal el√©trico,</b> ainda consegui encontrar o que precisava no Aliexpress e, sem pensar duas vezes, pedi 3 pe√ßas. <br></li><li>  <b>Controlador</b>  A pedaleira deve emular o teclado e, possivelmente, o mouse para poder se conectar a um PC sem drivers desnecess√°rios.  Para isso, a placa Arduino Pro Micro √© perfeita e, apesar de n√£o ter algumas conclus√µes, √© a mais compacta poss√≠vel.  Vamos ao mesmo Aliexpress e compramos a vers√£o chinesa desse milagre. <br></li><li>  <b>Fios.</b>  Para colocar 3 pedais embaixo da mesa, voc√™ precisa de pelo menos um fio de quatro fios com um comprimento de pelo menos um metro.  Penso que aqui n√£o devem surgir problemas. <br></li><li>  <b>LED RGB e bot√£o.</b>  O primeiro √© necess√°rio para indicar os modos e o segundo √© para troc√°-los. <br></li><li>  Bem, √© claro, precisamos de um IDE do Arduino, um ferro de solda e bra√ßos retos. <br></li></ul><br><h2>  Diagrama do dispositivo </h2><br>  Antes mesmo de as encomendas chegarem, comecei a criar um diagrama de dispositivos.  Embora isso seja dito muito, j√° que eu tive que conectar os pedais, diodo e bot√£o.  Aconteceu algo assim: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  Para pedais, decidi alocar 4 portas PB1-PB4 de uma s√≥ vez, ou seja, duas para a esquerda e duas para a perna direita, embora at√© agora eu tenha apenas tr√™s pedais.Al√©m disso, eles est√£o todos no mesmo grupo e est√£o localizados em um s√≥ lugar.  Sob o LED, peguei as sa√≠das PD0, PD1 e PD4, sob o bot√£o - PD7. <br>  Nesse caso, n√£o precisamos de resistores pull-up, se voc√™ usar aqueles que est√£o embutidos no controlador.  √â verdade que, quando voc√™ pressiona um bot√£o ou pedal, a entrada ser√° baixa e, quando liberada, ser√° alta, ou seja, as prensas ser√£o invertidas e voc√™ n√£o deve esquecer isso. <br><br><h2>  Escrita de c√≥digo </h2><br>  Essa etapa foi a mais dif√≠cil: devido a alguns erros nos ponteiros, eu apaguei o carregador de inicializa√ß√£o v√°rias vezes e, como resultado, quase falhei na placa no n√≠vel do software.  Abaixo de todos os est√°gios de cria√ß√£o do firmware, s√£o descritos em detalhes; para aqueles que desejam apenas obter um c√≥digo funcional, ele estar√° no final do artigo. <br><br><h3>  Prepara√ß√£o </h3><br>  Primeiro, precisamos entender o que √© o pedal em termos de programa.  Decidi tornar poss√≠vel definir os pedais de um dos dois modos - tempo real e gatilho.  Ao mesmo tempo, cada pedal possui dois programas: o primeiro √© executado quando o pedal √© pressionado em tempo real ou com pressionamentos √≠mpares no modo de disparo, o segundo √© quando o pedal √© liberado em tempo real ou quando os pedais s√£o pressionados uniformemente no modo de disparo.  O pedal tamb√©m possui uma porta, um estado e duas vari√°veis ‚Äã‚Äã- as posi√ß√µes atuais nos programas 1 e 2. Eu obtive essa estrutura: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 ‚Äî   , 1 ‚Äî  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  O Arduino possui um pouco de mem√≥ria e tamb√©m possui 8 bits, portanto, √© melhor tentar usar char em vez de int sempre que poss√≠vel. <br><br>  Tamb√©m precisamos da biblioteca padr√£o do teclado para funcionar como um teclado. <br><br><h3>  Clique em Processamento </h3><br>  Agora precisamos criar um int√©rprete que leia os dados da matriz e envie-os na forma de pressionamentos de teclas para a m√°quina, al√©m de selecionar v√°rios valores para v√°rios comandos internos.  Abrimos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina</a> com os c√≥digos de chave e vemos o que e como podemos clicar.  Eu n√£o me aprofundava e estudava todos os tipos de padr√µes de teclado, pois as informa√ß√µes aqui me pareciam suficientes para esse projeto.  A primeira metade √© reservada para caracteres ASCII padr√£o (embora alguns deles n√£o sejam imprim√≠veis ou n√£o sejam usados), a segunda metade √© para v√°rias teclas modificadoras.  Existem at√© c√≥digos separados para as teclas esquerda e direita, o que √© muito agrad√°vel, mas eu n√£o vi nenhum c√≥digo especial para os n√∫meros do nampad, embora, tanto quanto eu saiba, eles sejam percebidos de uma maneira especial no sistema que os n√∫meros comuns.  Talvez seus c√≥digos estejam em algum lugar nos ‚Äúburacos‚Äù, entre os intervalos, mas agora n√£o √© sobre isso.  Portanto, o maior c√≥digo √© a chave para cima - 218, o que significa que o intervalo 219-255 pode ser considerado livre, ou, pelo menos, n√£o h√° chaves importantes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Eu acho que mesmo uma pessoa com o mais alto n√≠vel de conhecimento de C n√£o ter√° perguntas sobre o que est√° acontecendo aqui.  Primeiro, a fun√ß√£o seleciona o pedal desejado e determina, dependendo do modo e condi√ß√£o do pedal, qual programa deve ser executado.  Ao ler cada elemento da matriz, se n√£o for um caractere de controle, a fun√ß√£o Keyboard.write () √© chamada, que emula a press√£o e a libera√ß√£o de uma tecla.  Os caracteres de controle s√£o processados ‚Äã‚Äãseparadamente e s√£o necess√°rios para fixar as combina√ß√µes de teclas e navegar no programa. <br><br><div class="spoiler">  <b class="spoiler_title">Alguns recursos do modo teclado</b> <div class="spoiler_text">  Keyboard.write () tem algumas nuances simples, mas n√£o √≥bvias para iniciantes, com base no fato de enviarmos dados n√£o na forma bruta, mas como pressionamentos de tecla.  Em primeiro lugar, estranhamente, sem drivers adicionais, o computador pode aceitar apenas caracteres do teclado que est√£o no teclado, o que significa que n√£o poderemos enviar 0x03 (sinal de interrup√ß√£o) ou 0x1B (in√≠cio da sequ√™ncia ESCAPE).  Em segundo lugar, podemos ajustar as letras mai√∫sculas como est√£o na tabela ASCII, mas a m√°quina obter√° a combina√ß√£o de teclas Shift + &lt;letra min√∫scula&gt;.  Isso pode se tornar um problema se o CapsLock estiver ativado e "inesperadamente" recebermos letras pequenas em vez de letras grandes e vice-versa.  Em terceiro lugar, n√£o podemos usar o idioma russo, nem em qualquer outro idioma.  Isso acontece novamente devido a coisas irritantes como <b>c√≥digos de chave</b> .  Embora Keyboard.write () aceite isso como argumento, o c√≥digo correspondente √† tecla na qual ele est√° no layout padr√£o em ingl√™s ainda √© enviado via USB, e se tentarmos enviar o alfabeto cir√≠lico, n√£o saberemos o que.  Portanto, se quisermos dizer ol√° aos nossos amigos que falam russo atrav√©s do Arduino, no c√≥digo, precisamos escrever "Ghbdtn" e envi√°-lo depois de selecionar o layout em russo.  Essa "sauda√ß√£o" funcionar√° no layout ucraniano, mas em b√∫lgaro, apesar de haver tamb√©m um alfabeto cir√≠lico, nada resultar√° disso, pois as letras est√£o em lugares completamente diferentes.  (Uma vez ouvi a opini√£o de que, para muitos desenvolvedores americanos e ingleses, √© incompreens√≠vel que algu√©m possa precisar usar v√°rios layouts, mas tamb√©m troc√°-los.) <br></div></div><br>  Portanto, temos um int√©rprete e um entendimento aproximado de como nossa pedaleira interage com um computador.  Agora precisamos levar tudo isso ao estado de firmware completo e verificar o desempenho em um pedal.  Se voc√™ criar uma inst√¢ncia do pedal e chamar ciclicamente pedalAction (), em teoria, executaremos o programa especificado na estrutura. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  A prop√≥sito, nunca esque√ßa os terminadores nulos nesses "programas" se o tamanho for menor que o tamanho da matriz e se n√£o forem c√≠clicos, porque o Arduino n√£o apenas tentar√° interpretar os dados que n√£o est√£o definidos, mas tamb√©m os enviar√° para a m√°quina com grande velocidade, e √© o mesmo que dar um teclado a um macaco. <br><br><h3>  Um pedal √© bom e dois √© melhor </h3><br>  Agora √© hora de lidar com o processamento de sinais de v√°rios pedais, al√©m de adicionar modos de comuta√ß√£o.  No in√≠cio do artigo, foram alocadas 4 portas para pedais, cada uma das quais deve poder trabalhar em sete modos.  Por que 7?  Porque, sem usar o PWM, nosso LED pode fornecer apenas 7 cores e a oitava desligada.  Essa quantidade √© suficiente para o usu√°rio m√©dio, mas em casos extremos pode ser facilmente aumentada.  Portanto, armazenaremos os pedais em uma matriz bidimensional de 7 x 4. Para n√£o obstruir a mem√≥ria, valores comuns a v√°rias estruturas, como o n√∫mero da porta, podem ser obtidos em matrizes separadas.  Como resultado, temos algo parecido com isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">A magia do n√∫mero 255</b> <div class="spoiler_text">  Voc√™ provavelmente notou que, no artigo, o n√∫mero 255 costuma aparecer, onde seria mais l√≥gico colocar 0. Olhando para o futuro, direi que isso √© necess√°rio para a conveni√™ncia de salvar pedais na EEPROM, j√° que na f√°brica cada uma de suas c√©lulas n√£o cont√©m 0, mas apenas 255, o que significa que esse n√∫mero ser√° muito mais conveniente para indicar vari√°veis ‚Äã‚Äãindefinidas que 0, para que voc√™ n√£o substitua a mem√≥ria toda vez. <br></div></div><br>  √â importante que conhe√ßamos apenas o tipo de pedal e dois programas, para que os deixemos apenas diretamente na estrutura, deixando a automa√ß√£o fazer o resto.  Os m√©todos de prepara√ß√£o e loop agora ter√£o a seguinte apar√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  O controlador considerar√° o modo n√£o utilizado se n√£o for declarado um √∫nico pedal (modo = 255), o que significa que, quando o tocar, passar√° imediatamente para o pr√≥ximo, mas o primeiro modo sempre existir√°.  Ao alternar o modo, todos os valores nas matrizes s√£o anulados, pois n√£o precisamos salv√°-los para cada modo (certo?). E o loop ignora todos os pedais e chama pedalAction para eles. <br><br>  Al√©m disso, no in√≠cio do m√©todo pedalAction (), voc√™ precisa adicionar a seguinte linha para que ele entenda com qual das estruturas lidar: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  A estrutura existente do pedal1 pode ser removida como desnecess√°ria. <br><br>  Tudo isso tamb√©m funciona muito bem, no entanto, encontrei um problema: alguns programas n√£o t√™m tempo para receber cliques na velocidade com que o Arduino os envia.  A solu√ß√£o mais √≥bvia √© adicionar a capacidade de definir atrasos entre as a√ß√µes, quando necess√°rio.  √â somente quando nos sentamos para escrever programas para microcontroladores que todos os chips, como multithreading de hardware, permanecem em algum lugar l√°, em computadores de alto n√≠vel, quando adicionamos um atraso, todo o programa para at√© que o controlador conte o n√∫mero certo de ciclos.  Como n√£o temos multithreading, teremos que cri√°-lo. <br><br><h3>  Dif√≠cil dizer sim f√°cil de fazer </h3><br>  Eu n√£o inventei uma bicicleta, mas peguei a biblioteca ArduinoThread pronta.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> voc√™ pode ler um pouco sobre como funciona e fazer o download.  Voc√™ pode fazer o download da biblioteca a partir do pr√≥prio IDE do Arduino.  Em resumo, permite executar periodicamente uma fun√ß√£o com um determinado intervalo, enquanto n√£o permite entrar em um loop infinito se a execu√ß√£o demorar mais que o intervalo.  O que voc√™ precisa  Crie outra matriz com threads para cada pedal: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Agora, temos 6 threads virtuais id√™nticos, mas ao mesmo tempo s√£o objetos diferentes. <br><br>  Vamos reescrever o ciclo de desvio do pedal para trabalhar com a nova funcionalidade: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Agora, o valor 252 na matriz do programa, que corresponde a "n√£o fazer nada", fornecer√° um atraso de 10 milissegundos (embora na verdade um pouco mais, pois a execu√ß√£o do c√≥digo tamb√©m leva tempo).  A adi√ß√£o de algumas linhas ao int√©rprete possibilitar√° definir o atraso em v√°rios desses "quanta", gastando apenas 2 bytes da matriz: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  Diferentemente de outros comandos, esta instru√ß√£o deve ser adicionada exatamente no in√≠cio do int√©rprete, ou seja, imediatamente ap√≥s "while (1) {", pois o atraso deve ser processado antes que o int√©rprete continue a ler o programa.  A matriz de espera precisa ser declarada da mesma maneira que foi feita com portas, estado etc.  e tamb√©m redefina suas c√©lulas ao alternar o modo, para que o atraso n√£o v√° para outro programa. <br><br>  Agora, com a possibilidade de definir um atraso de at√© 2,55 segundos, n√£o devem surgir problemas com a defini√ß√£o de chaves pelos programas. <br><br><h3>  Programa√ß√£o on-the-go </h3><br>  Em princ√≠pio, aqui seria poss√≠vel terminar o c√≥digo e come√ßar a montar o dispositivo, mas, neste caso, se algu√©m de repente reprogramar os pedais, ele ter√° que abrir o Arduino IDE, editar o c√≥digo e baixar o firmware novamente.  Naturalmente, essa op√ß√£o n√£o √© a melhor, ent√£o decidi adicionar a capacidade de alterar o programa da porta serial do Arduino e armazenar os programas na EEPROM.  Para trabalhar com mem√≥ria n√£o vol√°til, voc√™ deve conectar a biblioteca padr√£o EEPROM.h.  O c√≥digo do modo de programa√ß√£o √© o seguinte: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  O que esse c√≥digo faz √© explicado pela ajuda contida nele: um n√∫mero de espa√ßo √© inserido para o n√∫mero do modo, n√∫mero do pedal e um comando, dos quais existem 3 - leitura, grava√ß√£o e <s>execu√ß√£o de uma</s> exclus√£o de programa.  Todos os dados nos pedais s√£o armazenados um ap√≥s o outro em uma sequ√™ncia de 33 bytes, ou seja, o tipo de pedal e dois programas, e ocupamos 7 * 4 * 33 = 924 de 1024 bytes de EEPROM.  Joguei fora a op√ß√£o de usar o tamanho din√¢mico dos pedais na mem√≥ria, porque, neste caso, ao reprogramar um pedal, voc√™ precisar√° substituir quase todas as c√©lulas e h√° um n√∫mero finito de ciclos de reescrita, por isso recomendamos fazer o m√≠nimo poss√≠vel. <br><br><div class="spoiler">  <b class="spoiler_title">Recursos de trabalho com EEPROM</b> <div class="spoiler_text">  Gostaria tamb√©m de chamar a aten√ß√£o para as linhas do formul√°rio: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Gra√ßas a esta biblioteca, do ponto de vista do programador, a mem√≥ria n√£o vol√°til √© uma matriz de caracteres comum, mas, como "arduino", precisamos entender que gravar na ROM √© uma opera√ß√£o muito dif√≠cil, que leva at√© ~ 3 segundos do controlador e √© recomend√°vel n√£o interromper isso. processo.  Esse design faz o diodo brilhar em vermelho durante essas opera√ß√µes e, em seguida, retorna a cor verde "segura". <br></div></div><br>  No modo de grava√ß√£o de programa, a entrada √© feita diretamente pelos valores de bytes no sistema de n√∫meros decimais com um espa√ßo.  Acontece com muita gravidade, mas voc√™ n√£o precisa escrever um analisador complexo.  Al√©m disso, a reprograma√ß√£o n√£o ocorre com tanta frequ√™ncia e, nesses casos, √© bem poss√≠vel examinar a tabela ASCII. <br><br>  Com a preserva√ß√£o das estruturas resolvidas, agora precisamos, de alguma forma, extrair nossos dados de l√° e convert√™-los na visualiza√ß√£o "pedal": <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Nada sobrenatural tamb√©m acontece aqui: o controlador l√™ os dados da mem√≥ria e preenche as estruturas existentes. <br><br>  A vantagem da programa√ß√£o atrav√©s do UART √© que, novamente, n√£o precisamos de drivers especiais, para que voc√™ possa definir o comportamento do manipulador, mesmo a partir do telefone. <br><br><h2>  Demonstra√ß√£o </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  C√≥digo fonte completo </h2><br><div class="spoiler">  <b class="spoiler_title">Ele esta aqui</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 ‚Äî   , 1 ‚Äî  , 255 ‚Äî    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Posf√°cio </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora inicialmente eu pedi uma pedaleira para a possibilidade de rolar a grava√ß√£o enquanto tocava guitarra, no entanto, pessoalmente achei conveniente usar os pedais em tarefas comuns, o principal √© me acostumar com um manipulador t√£o incomum. </font><font style="vertical-align: inherit;">E aqui est√° outro problema: j√° sem seus pedais favoritos, trabalhar ao contr√°rio se torna mais dif√≠cil, pois voc√™ precisa se lembrar do que, onde e por que pressionar. </font><font style="vertical-align: inherit;">Se os pedais ainda podem ser usados ‚Äã‚Äãe conectados ao escrit√≥rio, ent√£o no instituto √© mais dif√≠cil andar com eles nas salas de aula. </font><font style="vertical-align: inherit;">Portanto, usar este dispositivo para algo que n√£o seja seu objetivo original √© por sua conta e risco. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pedal montado:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462263/">https://habr.com/ru/post/pt462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462245/index.html">auto git bisect como um exemplo do kernel do Linux</a></li>
<li><a href="../pt462251/index.html">O modo de navega√ß√£o an√¥nima no navegador √© uma fic√ß√£o?</a></li>
<li><a href="../pt462253/index.html">As primeiras experi√™ncias usando o protocolo de streaming no exemplo de comunica√ß√£o de CPU e processador no FPGA Redd</a></li>
<li><a href="../pt462257/index.html">Kafka em Kubernetes - isso √© bom?</a></li>
<li><a href="../pt462259/index.html">Fazendo um controlador para uma casa inteligente</a></li>
<li><a href="../pt462265/index.html">Python e cubos</a></li>
<li><a href="../pt462267/index.html">Conhe√ßa o PVS-Studio Static Analyzer for Java</a></li>
<li><a href="../pt462269/index.html">John Romero para Doom: 80s Game Dev</a></li>
<li><a href="../pt462271/index.html">C√≥digo de bloqueio no iOS: como a Apple mudou de defesa em defesa para proteger uma √∫nica fronteira</a></li>
<li><a href="../pt462273/index.html">Gerencie seu suporte para laptop com o digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>