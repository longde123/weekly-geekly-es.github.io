<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕗 👀 🔪 (in) Endlicher Krieg 👰🏿 🐱 🕞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben ein Problem. Das Problem beim Testen. Das Problem beim Testen von React-Komponenten ist ziemlich grundlegend. Es geht um den Unterschied zwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(in) Endlicher Krieg</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436692/"><p><img src="https://habrastorage.org/webt/4w/m4/cc/4wm4ccdyq2tqs2giqspeys3e9sa.jpeg" alt="unendlicher Krieg"></p><br><p> Wir haben ein Problem.  Das Problem beim Testen.  Das Problem beim Testen von React-Komponenten ist ziemlich grundlegend.  Es geht um den Unterschied zwischen <code>unit testing</code> und <code>integration testing</code> .  Es geht um den Unterschied zwischen dem, was wir Unit-Tests nennen, und dem, was wir Integrationstests nennen, der Größe und dem Umfang. </p><br><p>  Es geht nicht darum, sich selbst zu testen, sondern um die Komponentenarchitektur.  Informationen zum Unterschied zwischen Testkomponenten, eigenständigen Bibliotheken und endgültigen <strong>Anwendungen</strong> . </p><br><p>  Jeder weiß, wie man einfache Komponenten testet (sie sind einfach), wahrscheinlich weiß man, wie man Anwendungen (E2E) testet.  Wie man <em>endliche</em> und <em>unendliche</em> Dinge <em>testet</em> ... </p><a name="habracut"></a><br><h2 id="define-the-problem">  Definieren Sie das Problem </h2><br><p>  Es gibt zwei verschiedene Möglichkeiten, um React Component zu testen - <code>shallow</code> und alles andere, einschließlich <code>mount</code> , React <code>react-testing-library</code> , <code>webdriver</code> und so weiter.  Nur <code>shallow</code> ist etwas Besonderes - der Rest verhält sich genauso. </p><br><p>  Und dieser Unterschied betrifft <em>die Größe und den Umfang</em> - darüber, WAS getestet werden würde und nur teilweise <em>wie</em> . </p><br><p>  Kurz gesagt - <code>shallow</code> zeichnet nur Aufrufe von React.createElement auf, führt jedoch keine Nebenwirkungen aus, einschließlich des Renderns von DOM-Elementen. Dies ist ein (algebraischer) Nebeneffekt von React.createElement. </p><br><p>  Jeder andere Befehl führt den Code aus, den Sie mit jedem Nebeneffekt angegeben haben, der ebenfalls ausgeführt wird.  Wie es real wäre, und das ist das Ziel. </p><br><p>  Und <strong>das Problem</strong> ist folgendes: <code>you can NOT run each and every side effect</code> . </p><br><h3 id="why-not">  Warum nicht? </h3><br><p>  Funktionsreinheit?  Reinheit und Unveränderlichkeit - die heiligen Kühe von heute.  Und du schlachtest einen von ihnen.  Die Axiome des Unit-Tests - keine Nebenwirkungen, Isolation, Verspottung, alles unter Kontrolle. </p><br><ul><li><p>  Aber das ist <em>kein Problem</em> für ... <code>dumb components</code> .  Sie sind dumm, enthalten nur die Präsentationsschicht, aber keine "Nebenwirkungen". </p><br></li><li><p>  Aber das ist <em>ein Problem</em> für <code>Containers</code> .  Solange sie nicht dumm sind, enthalten, was sie wollen, und vollständig über Nebenwirkungen.  Sie sind das Problem! </p><br></li></ul><br><p>  Wenn wir die Regeln für "Die richtige Komponente" definieren, können wir sie wahrscheinlich leicht testen - sie werden uns leiten und uns helfen. </p><br><blockquote>  TRDL: Die endliche Komponente </blockquote><br><h2 id="smart-and-dumb-components">  Intelligente und dumme Komponenten </h2><br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dan Abramov</a> sind Artikelpräsentationskomponenten: </p><br><ul><li>  Sind besorgt darüber, wie die Dinge aussehen. </li><li>  Kann sowohl Präsentations- als auch Containerkomponenten <code>**</code> enthalten und hat normalerweise einige eigene DOM-Markups und Stile. </li><li>  Erlauben Sie häufig die Eindämmung über this.props.children. </li><li>  Haben Sie keine Abhängigkeiten vom Rest der App, wie z. B. Flux-Aktionen oder Stores. </li><li>  Geben Sie nicht an, wie die Daten geladen oder mutiert werden. </li><li>  Empfangen Sie Daten und Rückrufe ausschließlich über Requisiten. </li><li>  Selten haben sie einen eigenen Status (wenn sie dies tun, ist es eher der UI-Status als Daten). </li><li>  Werden als Funktionskomponenten geschrieben, es sei denn, sie benötigen Status-, Lebenszyklus-Hooks oder Leistungsoptimierungen. </li><li>  Beispiele: Seite, Seitenleiste, Story, UserInfo, Liste. </li><li>  .... </li><li>  Und Container sind nur Daten- / Requisitenanbieter für diese Komponenten. </li></ul><br><p>  Nach den Ursprüngen: <strong>In der idealen Anwendung ...</strong> <strong><br></strong>  <strong>Container sind der Baum.</strong>  <strong>Komponenten sind Baumblätter.</strong> </p><br><h4 id="find-the-black-cat-in-the-dark-room">  Finde die schwarze Katze im dunklen Raum </h4><br><p>  Die geheime Sauce hier, eine Änderung, die wir in dieser Definition ändern müssen, ist in <em>„Kann sowohl Präsentations- als auch Containerkomponenten enthalten <code>**</code> “</em> versteckt. Lassen Sie mich den Originalartikel zitieren: </p><br><blockquote>  In einer früheren Version dieses Artikels habe ich behauptet, dass Präsentationskomponenten nur andere Präsentationskomponenten enthalten sollten.  Ich glaube nicht mehr, dass dies der Fall ist.  Ob eine Komponente eine Präsentationskomponente oder ein Container ist, ist das Implementierungsdetail.  Sie sollten in der Lage sein, eine Präsentationskomponente durch einen Container zu ersetzen, ohne eine der Aufrufstellen zu ändern.  Daher können sowohl Präsentations- als auch Containerkomponenten andere Präsentations- oder Containerkomponenten enthalten. </blockquote><p>  Ok, aber was ist mit der Regel, die die Einheit der Präsentationskomponenten testbar macht - <em>"Keine Abhängigkeiten vom Rest der App"</em> ? </p><br><p>  Leider machen Sie durch das Einfügen von Containern in die Präsentationskomponenten die zweiten <strong>unendlich</strong> und fügen dem Rest der App eine Abhängigkeit hinzu. </p><br><p>  Wahrscheinlich warst du nicht dazu bestimmt.  Ich habe also keine andere Wahl, als dumme Komponenten endlich zu machen: </p><br><p>  <strong>PRÄSENTATIONSKOMPONENTEN DÜRFEN NUR ANDERE PRÄSENTATIONSKOMPONENTEN ENTHALTEN</strong> </p><br><p>  Und die einzige Frage, die Sie stellen sollten (Blick auf Ihre aktuelle Codebasis): <em>Wie?</em>  : tableflip:?! </p><br><p>  Heutzutage werden Präsentationskomponenten und -container nicht nur verwickelt, sondern manchmal auch nicht als "reine" Entitäten extrahiert (Hallo GraphQL). </p><br><h4 id="solution-1---di">  Lösung 1 - DI </h4><br><p>  Lösung 1 ist einfach - enthalten Sie keine verschachtelten Container in der dummen Komponente - enthalten Sie <code>slots</code> .  Akzeptiere einfach "Inhalt" (Kinder) als Requisiten, und das würde das Problem lösen: </p><br><ul><li>  Sie können dumme Komponenten ohne "den Rest Ihrer App" testen. </li><li>  Sie können die Integration mit Rauch / Integration / e2e-Test testen, nicht mit Tests. </li></ul><br><pre> <code class="plaintext hljs">// Test me with mount, with "slots emty". const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); // test me with shallow, or real integration test const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</code> </pre> <br><p>  Von Dan selbst genehmigt: <br>  {% twitter 1021850499618955272%} </p><br><p>  DI (sowohl Dependecy Injection als auch Dependency Inversion) ist hier wahrscheinlich eine äußerst wiederverwendbare Technik, die Ihr Leben viel, viel einfacher machen kann. </p><br><blockquote>  Punkt hier - Dumme Komponenten sind dumm! </blockquote><br><h4 id="solution-2---boundaries">  Lösung 2 - Grenzen </h4><br><p>  Dies ist eine recht deklarative Lösung und könnte <code>Solution 1</code> - deklarieren Sie einfach alle <em>Erweiterungspunkte</em> .  Wickeln Sie sie einfach mit ... <code>Boundary</code> </p><br><pre> <code class="plaintext hljs">const Boundary = ({children}) =&gt; ( process.env.NODE_ENV === 'test' ? null : children // or `jest.mock` ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</code> </pre> <br><p>  Dann können Sie <code>Boundary</code> (nur Null) deaktivieren, um den Komponentenumfang zu verringern und ihn <em>endlich zu machen</em> . </p><br><blockquote>  Punkt hier - Die Grenze befindet sich auf der Ebene der stummen Komponenten.  Die dumme Komponente steuert, wie dumm sie ist. </blockquote><br><h3 id="solution-3---tier">  Lösung 3 - Tier </h3><br><p>  Entspricht Lösung 2, jedoch mit einer intelligenteren Grenze, die in der Lage ist, Ebenen oder <em>Ebenen</em> oder was auch immer Sie sagen, zu verspotten: </p><br><pre> <code class="plaintext hljs">const checkTier = tier =&gt; tier === currentTier; const withTier = tier =&gt; WrapperComponent =&gt; (props) =&gt; ( (process.env.NODE_ENV !== 'test' || checkTier(tier)) &amp;&amp; &lt;WrapperComponent{...props} /&gt; ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); const ASideContainer = withTier('UI')(...) const Page = withTier('Page')(...) const PageChromeContainer = withTier('UI')(PageChrome);</code> </pre> <br><blockquote>  Auch wenn dies dem Beispiel "Grenze" fast ähnlich ist - Die dumme Komponente ist "Dumm", und Container steuern die Sichtbarkeit anderer Container. </blockquote><br><h4 id="solution-4---separate-concerns">  Lösung 4 - Getrennte Bedenken </h4><br><p>  Eine andere Lösung besteht darin, Bedenken zu trennen!  Ich meine - du hast es bereits getan und wahrscheinlich ist es Zeit, es zu nutzen. </p><br><blockquote>  Indem Sie <code>connect</code> Komponente mit Redux oder GQL verbinden, produzieren Sie <em>bekannte</em> Container.  Ich meine - mit <em>bekannten</em> Namen - <code>Container(WrapperComponent)</code> .  Sie können sie mit ihren Namen verspotten </blockquote><br><pre> <code class="plaintext hljs">const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); // remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</code> </pre> <br><p>  Dieser Ansatz ist etwas unhöflich - er löscht <em>alles</em> , was es schwieriger macht, Contaiers selbst zu testen, und Sie können ein etwas komplexeres Verspotten verwenden, um das "erste" beizubehalten: </p><br><pre> <code class="plaintext hljs">import {createElement, remock} from 'react-remock'; // initially "open" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // "close" and render real component &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // it's "closed" : null )} &lt;/ContainerCondition.Consumer&gt; )</code> </pre> <br><blockquote>  Punkt hier: Es gibt keine Logik innerhalb oder Präsentation, keinen Container - alle Logik ist außerhalb. </blockquote><br><h4 id="bonus-solution---separate-concerns">  Bonuslösung - Separate Bedenken </h4><br><p>  Sie können die <em>enge Kopplung</em> mit <code>defaultProps</code> und diese Requisiten in Tests aufheben ... </p><br><pre> <code class="plaintext hljs">const PageChrome = ({Content = Page, Aside = ASideContainer}) =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Aside/&gt;&lt;/aside&gt; &lt;Content/&gt; &lt;/section&gt; );</code> </pre> <br><h2 id="so">  Also? </h2><br><p>  Daher habe ich gerade einige Möglichkeiten veröffentlicht, um den Umfang einer Komponente zu verringern und sie viel testbarer zu machen.  Der einfache Weg, um einen <code>gear</code> aus dem <code>gearbox</code> zu holen.  Ein einfaches Muster, um Ihnen das Leben zu erleichtern. </p><br><p>  E2E-Tests sind großartig, aber es ist schwierig, einige Bedingungen, die in einem tief verschachtelten Feature auftreten können, zu simulieren und darauf vorbereitet zu sein.  Sie müssen Unit-Tests durchführen, um verschiedene Szenarien simulieren zu können.  Sie müssen Integrationstests durchführen, um sicherzustellen, dass alles ordnungsgemäß verdrahtet ist. </p><br><p>  Sie wissen, wie Dan in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem anderen Artikel schrieb</a> : </p><br><blockquote>  Wenn sich eine Schaltfläche beispielsweise in einem von 5 verschiedenen Zuständen befinden kann (normal, aktiv, Schweben, Gefahr, deaktiviert), muss der Code, der die Schaltfläche aktualisiert, für 5 × 4 = 20 mögliche Übergänge korrekt sein - oder einige davon verbieten.  Wie zähmen wir die kombinatorische Explosion möglicher Zustände und machen die visuelle Ausgabe vorhersehbar? </blockquote><p>  Während die richtige Lösung hier Zustandsmaschinen sind, ist es die Grundvoraussetzung, ein einzelnes Atom oder Molekül auswählen und damit spielen zu können. </p><br><h3 id="the-main-points-of-this-article">  Die Hauptpunkte dieses Artikels </h3><br><ol><li>  Präsentationskomponenten sollten nur andere Präsentationskomponenten enthalten. </li><li>  Container sind der Baum.  Komponenten sind Baumblätter. </li><li>  Sie müssen nicht <em>immer</em> NICHT Container in Präsentationscontainern <em>enthalten</em> , sondern <em>sie dürfen</em> nur in Tests enthalten sein. </li></ol><br><blockquote>  Sie können tiefer in das Problem eintauchen, indem Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mittleren Artikel</a> lesen, aber hier lassen Sie uns den ganzen Zucker überspringen. </blockquote><p>  PS: Dies ist eine Übersetzung des <em>Ru-Habr-</em> Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habr-Version</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436692/">https://habr.com/ru/post/de436692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436682/index.html">Erstellen Sie kein eigenes JL (DSL), um die Funktionalität der Anwendung zu erweitern</a></li>
<li><a href="../de436684/index.html">Jubiläum Android 10 (Q). Was ist jetzt bekannt?</a></li>
<li><a href="../de436686/index.html">JPEG aus der 3D-Welt. Was ist glTF?</a></li>
<li><a href="../de436688/index.html">Der IT-Riese verlässt den Markt für Chips für Rechenzentren - sagen Sie uns, was dies für die Branche bedeutet</a></li>
<li><a href="../de436690/index.html">[Fragen - Antworten] zu geistigem Eigentum und Datenschutz</a></li>
<li><a href="../de436694/index.html">Mein Pascal Compiler und polnische zeitgenössische Kunst</a></li>
<li><a href="../de436696/index.html">So erzeugen Sie binauralen Sound auf einer Monokanal-Audiospur - Video hilft</a></li>
<li><a href="../de436698/index.html">Auf wie viele Arten kann ich Fakultät in Schema schreiben?</a></li>
<li><a href="../de436700/index.html">Anti-Spoofing: Wie widerstehen Gesichtserkennungssysteme Betrügern?</a></li>
<li><a href="../de436704/index.html">Die Geschichte, wie wir Waagen für die Automatisierung von Registrierkassen ausgewählt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>