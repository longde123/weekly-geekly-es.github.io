<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåç ‚õπÔ∏è üí™üèº EHCI secara manusiawi dalam bahasa Rusia ü§∑üèº üèá üï¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saya menyambut semua orang. Hari ini saya ingin berbagi pengalaman saya dan masih, menurut pendapat saya, jelas menjelaskan tentang itu,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI secara manusiawi dalam bahasa Rusia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="gambar"><br><br><h3>  <b>Pendahuluan</b> </h3><br>  Saya menyambut semua orang.  Hari ini saya ingin berbagi pengalaman saya dan masih, menurut pendapat saya, jelas menjelaskan tentang itu, pada pandangan pertama, standar sederhana untuk pengontrol host USB 2.0. <br><br>  Awalnya, Anda dapat membayangkan bahwa port USB 2.0 hanya 4 pin, dua di antaranya hanya mentransmisikan data (Seperti, misalnya, port COM), tetapi pada kenyataannya, semuanya tidak begitu, dan bahkan sebaliknya.  Pengontrol USB, pada prinsipnya, tidak memungkinkan kami untuk mentransfer data melalui port COM biasa.  EHCI adalah standar yang agak canggih yang memungkinkan transfer data yang andal dan cepat dari perangkat lunak ke perangkat itu sendiri, dan dalam arah yang berlawanan. <br><br>  Anda mungkin menemukan artikel ini berguna jika, misalnya, Anda tidak memiliki keterampilan menulis yang cukup untuk driver dan membaca dokumentasi untuk perangkat keras.  Contoh sederhana: Anda ingin menulis OS untuk mini-PC, sehingga beberapa Windows atau distribusi Linux lainnya tidak mengunduh perangkat keras, dan Anda menggunakan semua kekuatannya secara eksklusif untuk keperluan Anda sendiri. <br><a name="habracut"></a><br><h3>  <b>Apa itu EHCI?</b> </h3><br>  Baiklah, mari kita mulai.  EHCI - Enhanced Host Controller Interface, dirancang untuk mentransfer data dan mengontrol permintaan ke perangkat USB, dan ke arah lain, dan dalam 99% kasus, ini merupakan tautan antara perangkat lunak apa pun dan perangkat fisik.  EHCI berfungsi sebagai perangkat PCI, dan karenanya menggunakan MMIO (Memory-Mapped-IO) untuk mengontrol pengontrol (ya, saya tahu bahwa beberapa perangkat PCI menggunakan porta, tapi di sini saya menggeneralisasi semuanya).  Dokumentasi dari Intel hanya menjelaskan prinsip operasi, dan tidak ada petunjuk sama sekali tentang algoritma yang ditulis setidaknya dalam pseudo-code.  EHCI memiliki 2 jenis register MMIO: Kemampuan dan Operasional.  Yang pertama berfungsi untuk mendapatkan karakteristik controller, sedangkan yang kedua berfungsi untuk mengendalikannya.  Sebenarnya, saya akan melampirkan esensi koneksi antara perangkat lunak dan pengontrol EHCI: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="gambar"><br><br>  Setiap pengontrol EHCI memiliki beberapa port, yang masing-masing dapat dihubungkan ke perangkat USB apa pun.  Perlu diketahui juga bahwa EHCI adalah versi perbaikan dari UHCI, yang juga dikembangkan oleh Intel beberapa tahun sebelumnya.  Untuk kompatibilitas mundur, setiap pengontrol UHCI / OHCI yang memiliki versi lebih rendah dari EHCI akan menjadi pendamping EHCI.  Misalnya, Anda memiliki keyboard USB (dan sebagian besar keyboard tahun ini seperti itu) yang bekerja pada USB 1.1 (perhatikan bahwa kecepatan maksimum USB 1.1 adalah 12 megabit per detik, dan FullSpeed ‚Äã‚ÄãUSB 2.0 memiliki bandwidth sebanyak 480 Mbps), dan Anda memiliki komputer dengan port USB 2.0, saat Anda menyambungkan keyboard ke komputer, pengontrol host EHCI entah bagaimana akan bekerja dengan USB 1.1.  Model ini ditunjukkan pada diagram berikut: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="gambar"><br><br>  Juga, untuk masa depan saya ingin segera memperingatkan Anda bahwa driver Anda mungkin tidak berfungsi dengan benar karena situasi yang absurd: Anda menginisialisasi UHCI, dan kemudian EHCI, sambil menambahkan dua perangkat yang sama, mengatur bit Kontrol Pemilik Port ke register port, dan kemudian UHCI berhenti bekerja, karena EHCI secara otomatis menyeret port ke dirinya sendiri, dan port pada UHCI berhenti merespons, situasi ini perlu dipantau. <br><br>  Juga, mari kita lihat diagram yang menunjukkan arsitektur EHCI itu sendiri: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="gambar"><br><br>  Di sebelah kanan ditulis tentang antrian - tentang mereka sedikit kemudian. <br><br><h2>  Register pengendali EHCI </h2><br>  Untuk mulai dengan, saya ingin mengklarifikasi sekali lagi bahwa melalui register ini Anda akan mengontrol perangkat Anda, oleh karena itu mereka sangat penting - dan tanpa mereka pemrograman EHCI tidak mungkin. <br><br>  Pertama, Anda perlu mendapatkan alamat MMIO yang diberikan kepada pengontrol ini, di offset + 0x10 akan menjadi alamat register lama kami.  Ada satu hal: pertama, register Kemampuan pergi, dan hanya setelah mereka - Operasional, oleh karena itu, pada offset 0 (dari alamat sebelumnya, yang kami terima pada offset 0x10 relatif terhadap awal MMIO EHCI kami), ada satu byte - panjang register Kemampuan. <br><br><h3>  <b>Register kemampuan</b> </h3><br>  Pada offset 2, register <b>HCIVERSION berada</b> - nomor revisi HC ini, yang menempati 2 byte dan berisi versi revisi BCD (BCD apa yang dapat ditemukan di Wikipedia). <br>  Pada offset +4, register <b>HCSPARAMS berada</b> , ukurannya 2 kata, berisi parameter struktural perangkat dan bitnya menunjukkan yang berikut: <br><br><ul><li>  Bit 16 - Indikator Port - LED yang tersedia untuk perangkat USB yang terhubung. </li><li>  Bit 15:12 - jumlah pengontrol pengiring yang ditugaskan untuk pengontrol ini </li><li>  Bit 11: 8 - jumlah port pada pengontrol pendamping </li><li>  Bit 7 - Aturan Routing Port - menunjukkan bagaimana port ini dipetakan ke port pendamping </li><li>  Bit 4 - Port Power Control - menunjukkan apakah perlu menyalakan daya untuk setiap port, 0 - daya disediakan secara otomatis </li><li>  Bits 3: 0 - jumlah port untuk pengontrol ini. </li><li>  Pada offset +8 terletak register HCCPARAMS - ia menunjukkan parameter kompatibilitas, bitnya berarti sebagai berikut: </li><li>  Bit 2 - ketersediaan antrian sinkron, </li><li>  Bit 1 - ketersediaan antrian periodik (berurutan) </li><li>  Kompatibilitas bit 0 - 64 bit </li></ul><br><h3>  <b>Register operasi</b> </h3><br>  Pada offset 0, register <b>USBCMD</b> adalah register perintah controller, bit-bitnya berarti sebagai berikut: <br><br><ul><li>  Bit 23:16 - Interrupt Threshold Control - menunjukkan berapa banyak mikro-frame yang akan digunakan untuk satu frame biasa.  Semakin banyak, semakin cepat, tetapi jika lebih dari 8, maka mikro-frame akan diproses pada kecepatan yang sama seperti untuk 8. </li><li>  Bit 6 - interupsi setelah setiap transaksi dalam antrian asinkron, </li><li>  Bit 5 - adalah antrian asinkron yang digunakan </li><li>  Bit 4 - penggunaan antrian berurutan, </li><li>  Bit 3: 2 - ukuran FrameList'a (lebih lanjut tentang itu nanti).  0 berarti 1024 elemen, 1 - 512, 2 - 256, 3 - dicadangkan </li><li>  Bit 1 - Set untuk mengatur ulang pengontrol host. </li><li>  Bit 0 - Run / Stop </li></ul>  . <br>  Selanjutnya, pada offset +4, ada register <b>USBSTS</b> - status pengontrol host, <br><br><ul><li>  Bit 15 menunjukkan apakah antrian asinkron digunakan. </li><li>  Bit 14 menunjukkan apakah antrian berurutan sedang digunakan, </li><li>  Bit 13 - menunjukkan bahwa antrian asinkron kosong telah terdeteksi, </li><li>  Bit 12 diatur ke 1, jika terjadi kesalahan saat memproses transaksi, maka pengontrol host akan menghentikan semua antrian. </li><li>  Bit 4 diatur ke 1, jika kesalahan serius terjadi, pengontrol host menghentikan semua antrian. </li><li>  Bit 3 FrameList (Register) Rollover - atur ke 1 ketika pengontrol host memproses seluruh frameList. </li><li>  Bit 1 - USB Error Interrupt - Apakah saya menghasilkan interupsi kesalahan? </li><li>  Bit 0 - USB Interrupt - ditetapkan setelah pemrosesan transaksi berhasil, jika IOC diinstal pada TD </li></ul><br>  Tidak lelah?  Anda dapat menuangkan burung camar yang kuat dan membawa hati, kami berada di awal! <br><br>  Pada offset +8, ada register <b>USBINTR</b> - interrupt enable register <br>  Agar tidak menulis untuk waktu yang lama, dan lebih dari itu, agar Anda tidak membaca untuk waktu yang lama, nilai bit register ini dapat ditemukan dalam spesifikasi, tautan ke sana akan tertinggal di bawah.  Di sini saya hanya menulis 0, karena  Saya sama sekali tidak memiliki keinginan untuk menulis penangan, interupsi peta, dll., Jadi ini saya pikir hampir tidak ada gunanya. <br><br>  Pada offset +12 (0x0C), register <b>FRINDEX berada</b> , di mana nomor frame saat ini terletak, dan saya ingin mencatat bahwa 4 bit terakhir menunjukkan nomor frame mikro, di bagian atas 28 bit nomor frame (nilainya juga belum tentu lebih kecil dari ukuran frameList) Tetapi jika Anda membutuhkan indeks, lebih baik membawanya dengan mask 0x3FF (atau 0x1FF, dll.). <br><br>  Register <b>CTRLDSSEGMENT</b> berada pada offset + 0x10, ini menunjukkan pengendali host 32 bit paling signifikan dari alamat frame sheet. <br><br>  Register <b>PERIODICLISTBASE</b> memiliki offset + 0x14, Anda dapat memasukkan 32 bit frame sheet yang lebih rendah ke dalamnya, perhatikan bahwa alamat tersebut harus disejajarkan dengan ukuran halaman memori (4096). <br><br>  Register <b>ASYNCLISTADDR</b> memiliki offset + 0x18, Anda dapat memasukkan alamat antrian asinkron di dalamnya, perhatikan bahwa itu harus disejajarkan pada batas 32 byte, sementara itu harus dalam empat gigabytes pertama dari memori fisik. <br><br>  Register <b>CONFIGFLAG</b> menunjukkan apakah perangkat dikonfigurasi.  Anda harus menetapkan bit 0 setelah menyelesaikan pengaturan perangkat, ia memiliki offset + 0x40. <br><br>  Mari kita beralih ke register port.  Setiap port memiliki register status-perintahnya sendiri, setiap register port diimbangi <b>+ 0x44 + (PortNumber - 1) * 4</b> , bit-bitnya berarti sebagai berikut: <br><br><ul><li>  Bit 12 - port power, 1 - power dipasok, 0 - no. </li><li>  Bit 8 - Port Rest - diatur untuk mengatur ulang perangkat. </li><li>  Bit 3 - Port Enable / Disable Change - atur ketika mengubah status "inklusi" port. </li><li>  Bit 2 - port on / off. </li><li>  Bit 1 - Mengubah status koneksi, diatur ke 1, misalnya, jika Anda menghubungkan atau melepas perangkat USB. </li><li>  Bit 0 - status koneksi, 1 - terhubung, 0 - no. </li></ul><br>  Sekarang mari kita beralih ke jus itu sendiri. <br><br><h2>  Transfer Data dan Struktur Permintaan </h2><br>  Mengatur struktur untuk memproses permintaan termasuk antrian dan transfer deskriptor (TDs). <br><br>  Saat ini, kami hanya akan mempertimbangkan 3 struktur. <br><br><h3>  Daftar berurutan </h3><br>  Daftar berurutan (Periodik, Pereodik) disusun sebagai berikut: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="gambar"><br><br>  Seperti yang Anda lihat dalam diagram, pemrosesan dimulai dengan memperoleh bingkai yang diinginkan dari bingkai sheet, masing-masing elemennya menempati 4 byte dan memiliki struktur sebagai berikut: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="gambar"><br><br>  Seperti yang dapat Anda lihat dalam gambar, transfer antrian / descriptor diselaraskan pada batas 32 byte, bit 0 berarti bahwa pengontrol host tidak akan memproses elemen ini, bit 3: 1 menunjukkan jenis apa yang akan diproses oleh pengontrol host: 0 - isosynchronous TD (iTD), 1 - turn, 2 dan 3 dalam artikel ini saya tidak akan pertimbangkan. <br><br><h3>  Antrian asinkron </h3><br>  Pengontrol host memproses antrian ini hanya ketika frame berurutan kosong atau pengontrol host telah memproses seluruh daftar seri. <br><br>  Antrian asinkron adalah penunjuk ke antrian yang berisi antrian lain yang perlu diproses.  Skema: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="gambar"><br><br><h3>  qTD (Penjelasan Transfer Elemen Antrian) </h3><br>  TD ini memiliki struktur berikut: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="gambar"><br><br>  <b>Next qTD Pointer</b> - pointer ke kelanjutan antrian untuk diproses (untuk Eksekusi Horizontal), bit 0 Next qTD Pointer menunjukkan bahwa tidak ada lagi antrian. <br>  <b>qTD Token</b> - TD token, menunjukkan parameter transfer data: <br><br><ul><li>  Bit 31 - Data Toggle (lebih lanjut tentang itu nanti) </li><li>  Bit 30:16 - jumlah data yang ditransfer, setelah penyelesaian transaksi, nilainya berkurang dengan jumlah data yang ditransfer. </li><li>  Bit 15 - IOC - Interrupt On Complete - menyebabkan gangguan setelah pemrosesan deskriptor selesai. </li><li>  Bit 14:12 menunjukkan jumlah buffer saat ini ke / dari mana data dipertukarkan, lebih lanjut tentang ini nanti. </li><li>  Bit 11:10 - jumlah kesalahan yang diizinkan.  Tabel ini menunjukkan kapan jumlah kesalahan berkurang: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="gambar"><br><br>  Catatan Kaki 1 - mendeteksi Babble atau Stall secara otomatis menghentikan eksekusi kepala antrian.  Catatan Kaki 3 - Kesalahan buffer data adalah masalah dengan host.  Mereka tidak memperhitungkan coba ulang perangkat. </li><li>  9: 8 - Kode PID - jenis token: 0 - token ke input (dari host ke perangkat), 1 - token ke output (dari perangkat ke host), 2 - token ‚ÄúSETUP‚Äù </li><li>  Bits 7: 0 menunjukkan status TD: <br>  Bit 7 menunjukkan bahwa TD dalam keadaan aktif (mis., Pengendali host memproses TD ini) <br>  Bit 6 - Dihentikan - menunjukkan bahwa kesalahan telah terjadi dan eksekusi TD telah berhenti. <br>  Bit 4 - Babble Detected - jumlah data yang kami kirim ke perangkat, atau per revolusi, kurang dari yang kami kirimkan, mis., Perangkat mengirimi kami 100 byte data, dan kami hanya membaca 50 byte, dan kemudian 50 lainnya, Bit yang Dihentikan juga akan diatur jika bit ini disetel ke 1. <br>  Bit 3 - Kesalahan Transaksi - Kesalahan terjadi selama transaksi. </li></ul><br>  <b>qTD Buffer Page Pointer List</b> - salah satu dari 5 buffer.  Ini berisi tautan ke mana dalam memori transaksi harus dilakukan (mengirim data ke perangkat / menerima data dari perangkat), semua alamat dalam buffer, kecuali yang pertama, harus disejajarkan dengan ukuran halaman (4096 byte). <br><br><h3>  Kepala baris </h3><br>  Kepala Antrian memiliki struktur berikut: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="gambar"><br><br>  <b>Queue Head Horizontal Link Pointer</b> - penunjuk ke antrian berikutnya, bit 2: 1 memiliki nilai berikut tergantung pada jenis antrian: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="gambar"><br><br>  <b>Kemampuan / Karakteristik Endpoint</b> - karakteristik antrian: <br><br><ul><li>  Bit 26:16 berisi ukuran paket maksimum untuk transmisi </li><li>  Bit 14: Data Toggle Control - menunjukkan di mana pengontrol host harus mengambil nilai Data Toggle awal, 0 - mengabaikan bit DT dalam qTD, menyimpan bit DT untuk kepala antrian. </li><li>  Bit 13:12 - karakteristik laju transmisi: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="gambar"></li><li>  Bits 11: 8 - nomor titik akhir yang diminta permintaannya </li><li>  Bit 6: 0 - alamat perangkat </li></ul><br>  <b>Kemampuan Endpoint: Antrian Kepala DWord 2</b> - kelanjutan dari kata ganda sebelumnya: <br><br><ul><li>  Bit 29:23 - Nomor Hub </li><li>  Bit 22:16 - Alamat hub </li></ul><br>  <b>Current qTD Link Pointer</b> - penunjuk ke qTD saat ini. <br><br>  Kami lolos ke yang paling menarik. <br><br><h2>  Pengemudi EHCI </h2><br>  Mari kita mulai dengan pertanyaan apa yang bisa dipenuhi EHCI.  Ada 2 jenis permintaan: Kontrol - perintah ala, dan Massal - ke titik akhir, untuk pertukaran data, misalnya, sebagian besar drive flash USB (USB MassStorage) menggunakan tipe transfer data Massal / Massal / Massal.  Mouse dan keyboard juga menggunakan permintaan Massal untuk transfer data. <br><br>  Inisialisasi EHCI dan konfigurasikan antrian asinkron dan berurutan: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br>  Sebenarnya, kode untuk mengatur ulang port ke keadaan semula: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Kontrol permintaan ke perangkat: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  Kode Pemrosesan Antrian: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  Dan sekarang permintaan titik akhir (permintaan massal) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  Saya pikir topiknya cukup menarik, di Internet dalam bahasa Rusia hampir tidak ada dokumentasi, deskripsi, dan artikel tentang topik ini, dan jika ada, itu sangat kabur.  Jika topik bekerja dengan pengembangan perangkat keras dan OS menarik, maka ada banyak yang bisa diceritakan. <br><br>  Dermaga: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426421/">https://habr.com/ru/post/id426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426411/index.html">Mengembangkan Kelas Deskripsi C ++ / CLI</a></li>
<li><a href="../id426413/index.html">Prinsip SOLID yang Harus Diketahui Setiap Pengembang</a></li>
<li><a href="../id426415/index.html">Fintech-digest: kontrol digitalisasi oleh Bank Sentral, gaji cryptocurrency, kartu Mir dalam bentuk gelang dan gantungan kunci</a></li>
<li><a href="../id426417/index.html">Pavel 2.0: konsultan reptiloid pada JS, node.js dengan soket dan telepon</a></li>
<li><a href="../id426419/index.html">Metode overload atau jembatan terlarang di Jawa</a></li>
<li><a href="../id426423/index.html">mmWave pada smartphone: bagaimana Qualcomm membuat yang tidak mungkin menjadi mungkin</a></li>
<li><a href="../id426425/index.html">Seluruh kebenaran tentang RTOS. Artikel # 14. Bagian memori: pengantar dan layanan dasar</a></li>
<li><a href="../id426427/index.html">Barang yang berguna untuk "barang": pilihan kecil dengan harga murah</a></li>
<li><a href="../id426429/index.html">Menginstal FreeSWITCH 1.8 pada Debian 9 (Raspbian Stretch, gambar dasar dari sistem Smart Home MajorDoMo di Rasbperri Pi)</a></li>
<li><a href="../id426431/index.html">Membongkar mesin novel visual Qlie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>