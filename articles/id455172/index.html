<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏽 🔍 👢 Pohon pencarian biner seimbang: implementasi pada Julia 🙇 🎽 🛩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ilustrasi dari karya G.M. Adelson-Welsky dan E.M. Landis 1962 


 Pohon pencarian adalah struktur data untuk penyimpanan teratur dan pencarian sederha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pohon pencarian biner seimbang: implementasi pada Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>  <em>Ilustrasi dari karya G.M.</em>  <em>Adelson-Welsky dan E.M.</em>  <em>Landis 1962</em> </p><br><p>  Pohon pencarian adalah struktur data untuk penyimpanan teratur dan pencarian sederhana untuk item.  Pohon pencarian <em>biner</em> banyak digunakan, di mana setiap node hanya memiliki dua anak.  Dalam artikel ini, kami mempertimbangkan dua metode untuk mengatur pohon pencarian biner: algoritma Adelson-Welsky dan Landis (pohon AVL) dan pohon AVL yang melemah (pohon WAVL). </p><a name="habracut"></a><br><p>  Mari kita mulai dengan definisi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pohon biner</a> terdiri dari <em>node</em> , setiap node menyimpan <em>catatan</em> dalam bentuk pasangan <em>kunci-nilai</em> (atau, dalam kasus sederhana, hanya nilai) dan tidak memiliki lebih dari dua <em>anak</em> .  Node turunan dibedakan oleh <em>kanan</em> dan <em>kiri</em> , dan kondisi untuk pemesanan kunci terpenuhi: kunci anak kiri tidak lebih, dan yang kanan tidak kurang dari kunci node induk.  Selain itu, informasi layanan dapat disimpan (dan biasanya disimpan) dalam node - misalnya, tautan ke simpul induk atau data lainnya.  Kasus khusus adalah <em>simpul akar</em> dari mana pohon masuk, dan <em>simpul kosong</em> yang tidak menyimpan informasi apa pun.  Node di mana kedua keturunannya kosong disebut <em>daun</em> pohon.  Node dengan semua keturunan membentuk <em>subtree</em> .  Jadi, setiap simpul adalah akar dari pohon subtree atau daun. </p><br><p> Definisi ini memungkinkan Anda untuk membangun struktur sederhana untuk menyimpan node dan pohon itu sendiri.  Kami berasumsi bahwa simpul kosong memiliki nilai khusus <code>nothing</code> .  Kemudian dalam node itu sudah cukup untuk menyimpan referensi ke keturunan kanan dan kiri dan ke induknya.  Struktur untuk menyimpan pohon hanya berisi tautan ke simpul akar. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># K -   # V -    mutable struct BSTNode{K, V} key::K value::V left::Union{Nothing, BSTNode{K,V}} right::Union{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} end mutable struct BST{K, V} root::BSTNode{K,V} end</span></span></code> </pre> <br><p>  Dalam kasus ini, muncul pertanyaan tentang bagaimana merepresentasikan pohon kosong.  Untuk melakukan ini, kami menggunakan pendekatan dari buku "Algoritma: Konstruksi dan Analisis" dan memasukkan sebagai titik masuk ke pohon bukan root, tetapi simpul dummy, yang akan menjadi induknya sendiri.  Untuk membuat simpul seperti itu, tambahkan konstruktor ke deskripsi struktur BSTNode: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> BSTNode{K, V} key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function BSTNode{K,V}() where {K,V} node = new{K,V}() node.parent = node node.left = node.right = nothing return node end #    - function BSTNode{K,V}(key, value) where {K, V} node = new{K,V}() node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end BSTNode() = BSTNode{Any, Any}() #     ! struct BST{K, V} entry::BSTNode{K,V} BST{K,V}() where {K,V} = new{K,V}(BSTNode{K,V}()) end BST() = BST{Any, Any}() Base.isempty(bst::BST) = bst.entry.left == nothing</span></span></code> </pre> <br><p>  Dalam hal ini, struktur <code>BST</code> dapat dibuat tidak berubah, karena  tautan ke titik masuk tidak perlu lagi diubah.  Lebih lanjut, kita mengasumsikan bahwa simpul akar pohon adalah keturunan kanan dan kiri dari simpul input. </p><br><p>  Operasi utama yang membutuhkan pohon pencarian adalah, tentu saja, pencarian elemen.  Karena kunci anak kiri tidak lebih, dan yang kanan tidak kurang dari kunci induk, prosedur pencarian elemen ditulis dengan sangat sederhana: mulai dari akar pohon, bandingkan kunci input dengan kunci simpul saat ini;  jika kunci cocok, kami mengembalikan nilainya, jika tidak, pergi ke subtree kiri atau kanan, tergantung pada urutan tombol.  Jika pada saat yang sama mereka mencapai simpul kosong - tidak ada kunci di pohon, berikan pengecualian. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.getindex()    #      tree[key] function Base.getindex(bst::BST{K,V}, key) where {K,V} key = convert(K, key) node = bst.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><p>  Mencari elemen dengan kunci, jelas, membutuhkan waktu <em>O</em> ( <em>h</em> ), di mana <em>h</em> adalah ketinggian pohon, mis.  jarak maksimum dari akar ke daun.  Sangat mudah untuk menghitung bahwa pohon biner dengan tinggi <em>h</em> dapat mengandung paling banyak 2 <sup>jam + 1</sup> -1 node jika <em>padat penduduk</em> , mis.  semua node, kecuali, mungkin, lapisan yang paling ekstrim, memiliki kedua keturunan.  Selain itu, jelas bahwa urutan tombol apa pun yang diberikan di muka dapat menyebabkan pohon yang padat.  Ini memberikan asimtotik yang sangat optimis untuk menemukan elemen dalam pohon ketika dibangun secara optimal dalam waktu <em>O</em> (log <sub>2</sub> <em>N</em> ), di mana <em>N</em> adalah jumlah elemen. </p><br><p>  Tentu saja, algoritma untuk menambahkan elemen ke pohon pencarian perlu dibangun sedemikian rupa sehingga kondisi pada urutan tombol terpenuhi.  Mari kita menulis implementasi naif dari memasukkan elemen dengan kunci: </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.setindex!()    #       tree[key] = value function Base.setindex!(bst::BST{K,V}, val::SV, key::SK) where {K, V} key, value = convert(K, key), convert(V, val) parent = bst.entry.left #   -     if parent == nothing newnode.parent = bst.entry bst.entry.left = bst.entry.right = newnode return val end key_found = false while !key_found if key &lt; parent.key if parent.left == nothing parent.left = BSTNode{K,V}(key, value) parent.left.parent = parent key_found = true else parent = parent.left end elseif key &gt; parent.key if parent.right == nothing parent.right = BSTNode{K,V}(key, value) newnode.parent = parent key_found = true else parent = parent.right end else key_found = true parent.value = value end end return val end</span></span></code> </pre> <br><p>  Sayangnya, konstruksi naif pohon akan memberikan struktur yang diinginkan hanya pada data input acak, tetapi pada kenyataannya mereka seringkali cukup terstruktur.  Dalam kasus terburuk, jika kunci yang masuk diatur secara ketat (setidaknya dalam urutan naik, setidaknya dalam urutan menurun), konstruksi pohon naif akan mengirim elemen baru sepanjang waktu dalam satu arah, mengumpulkan, pada kenyataannya, daftar linier.  Sangat mudah untuk menebak bahwa penyisipan elemen, bahwa pencarian akan terjadi dengan struktur seperti itu selama <em>O</em> ( <em>N</em> ), yang meniadakan semua upaya untuk membangun struktur data yang kompleks. </p><br><p>  Kesimpulan: pohon pencarian harus <em>seimbang</em> selama konstruksi, mis.  menyelaraskan ketinggian subtree kanan dan kiri di setiap node.  Ada beberapa pendekatan untuk menyeimbangkan.  Yang paling sederhana adalah menentukan sejumlah operasi penyisipan atau penghapusan tertentu, setelah itu pohon akan diseimbangkan kembali.  Dalam kasus ini, pohon akan berada dalam kondisi yang agak "berjalan" sebelum menyeimbangkan, karena itu penyeimbangan akan memakan waktu sekitar <em>O</em> ( <em>N</em> ) dalam kasus terburuk, tetapi operasi selanjutnya hingga batas penyisipan / penghapusan tertentu akan dilakukan dalam waktu logaritmik.  Pilihan lain adalah membangun algoritma penyisipan dan penghapusan segera sehingga pohon selalu tetap seimbang, yang memberikan kompleksitas waktu yang <em>dijamin</em> <em>O</em> (log <sub>2</sub> <em>N</em> ) untuk operasi apa pun. </p><br><p>  Karena kenyataan bahwa ada algoritma di mana pohon diizinkan untuk "menjadi liar", tetapi setelah itu, operasi dapat dilakukan untuk waktu yang agak lama dalam waktu logaritmik, sebelum pohon harus dibawa kembali ke keadaan seimbang untuk waktu yang lama, waktu penyisipan / penghapusan yang <em>dijamin</em> dan <em>diamortisasi</em> dibedakan.  Untuk beberapa implementasi operasi dengan pohon pencarian biner, kompleksitas memasukkan dan menghapus <em>O</em> (log <sub>2</sub> <em>N</em> ) dijamin, untuk beberapa itu diamortisasi, dengan deteriorasi ke <em>O</em> ( <em>N</em> ). </p><br><h3 id="algoritm-adelson-velskogo-i-landisa-avl">  Adelson-Welsky dan Landis Algorithm (AVL) </h3><br><p>  Implementasi pertama pohon pencarian biner yang menyeimbangkan diri diusulkan pada tahun 1962 oleh Adelson-Welsky dan Landis.  Dalam literatur modern tentang huruf awal nama keluarga, struktur ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVL-tree</a> .  Struktur dijelaskan oleh properti berikut: </p><br><ol><li>  Pemesanan: untuk setiap simpul, kunci di bagian atas subtree kiri lebih besar daripada di bagian atas subtree kanan daripada kunci node itu sendiri (jika turunannya bukan node kosong). </li><li>  Peningkatan tinggi: ketinggian simpul orangtua adalah satu lebih dari ketinggian maksimum turunannya.  Ketinggian node kosong dapat dianggap sama dengan nol. </li><li>  Keseimbangan AVL: untuk setiap simpul, ketinggian sub pohon kanan dan kiri berbeda tidak lebih dari 1. </li></ol><br><p>  Dari sifat-sifat ini dapat disimpulkan bahwa ketinggian seluruh pohon adalah <em>O</em> (log <sub>2</sub> <em>N</em> ), di mana <em>N</em> adalah jumlah catatan yang disimpan di pohon, yang berarti bahwa catatan tersebut dicari dalam waktu logaritmik.  Agar kondisi keseimbangan ABL tetap setelah setiap penyisipan, setiap penyisipan disertai dengan operasi <em>penyeimbangan</em> .  Untuk implementasi operasi ini yang efektif, setiap node perlu menyimpan informasi layanan.  Untuk kesederhanaan, pertahankan ketinggian simpul di sana. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> AVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment"># ,       255 # (  10^38 ) height::UInt8 key::K value::V left::Union{Nothing, AVLNode{K,V}} right::Union{Nothing, AVLNode{K,V}} parent::AVLNode{K,V} #   function AVLNode{K,V}() where {K,V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing return node end #    - function AVLNode{K,V}(key::SK, value::SV) where {K, V, SK&lt;:K, SV&lt;:V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end avlheight(node::Union{Nothing,AVLNode}) = node == nothing ? 0 : Int(node.height)</span></span></code> </pre> <br><h4 id="vstavka-zapisi">  Sisipkan catatan </h4><br><p>  Penyisipan dasar dilakukan sesuai dengan algoritma standar - turun pohon, cari di mana Anda dapat memasukkan simpul baru dan masukkan.  Kami akan menulis pembungkus untuk mendapatkan dan mengganti simpul anak menggunakan indeks -1 dan 1 alih-alih kiri dan kanan: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> child(root::AVLNode, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> insert_child!(root::AVLNode{K,V}, newnode::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,AVLNode{K,V}}, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} newnode == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> || (newnode.parent = root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left = newnode <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right = newnode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Selanjutnya, kita naik pohon dan mencari pelanggaran kondisi 2 dan 3. Selanjutnya, kita mempertimbangkan opsi yang mungkin muncul (dalam gambar, hijau menunjukkan simpul yang mengubah ketinggian, simpul yang sedang diproses adalah induknya). </p><br><p>  <strong>Kasing 0</strong> <br>  Setelah penyisipan, ketinggian simpul menjadi sama dengan saudara perempuan, dan 1 kurang dari tinggi (tua) dari simpul induk. </p><br><p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br><p>  Kasus terbaik, tidak perlu menyentuh apa pun lebih lanjut.  Di atas juga, Anda tidak bisa lagi menonton, karena  tidak ada yang akan berubah di sana. </p><br><p>  <strong>Kasus 1</strong> <br>  Sebelum dimasukkan, ketinggian simpul sama dengan tinggi simpul adik.  Penyisipan mengangkat akar subtree, dan ketinggian node dibandingkan dengan ketinggian induk. </p><br><p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br><p>  Dalam hal ini, cukup untuk "menaikkan" simpul induk, menambah ketinggiannya dengan 1. Pada saat yang sama, Anda harus terus berpindah ke akar pohon, karena mengubah ketinggian simpul induk dapat menyebabkan pelanggaran kondisi 2 satu tingkat lebih tinggi. </p><br><p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height += by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height -= by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  <strong>Kasus 2</strong> </p><br><p>  Setelah penyisipan, perbedaan ketinggian dengan subtree sister menjadi 2, dan subtree kiri "didorong" ke atas: </p><br><p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br><p>  Masalahnya ditangani dengan operasi yang disebut "rotasi sederhana" yang mengubah pohon sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br><p>  Giliran sederhana membutuhkan 6 perubahan pointer. </p><br><p>  Perhatikan bahwa dalam proyeksi ke sumbu horizontal, urutan simpul <em>n</em> , <em>p</em> dan pohon <em>T</em> <sub>1</sub> - <em>T</em> <sub>3</sub> sebelum dan sesudah rotasi tetap sama.  Ini adalah pemenuhan kondisi pemesanan.  Seperti yang Anda lihat, setelah menyalakan pohon, keseimbangan tidak lagi diperlukan. </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  <strong>Kasus 3</strong> <br>  Setelah penyisipan, perbedaan ketinggian dengan subtree sister menjadi 2, dan subtree kanan "didorong" ke atas: </p><br><p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br><p>  Dalam hal ini, satu belokan sederhana tidak akan lagi membantu, tetapi Anda dapat membuat belokan kiri sederhana di sekitar keturunan kanan, yang akan mengarah ke kasus 2, yang sudah ditangani dengan belokan kanan sederhana. </p><br><p>  Untuk mengurangi jumlah "lebih banyak" dari node, dua putaran dapat digabungkan menjadi satu operasi, yang disebut putaran besar, atau ganda.  Kemudian, alih-alih 12 perubahan pointer, hanya diperlukan 10. Sebagai hasil dari rotasi ganda, pohon mengambil bentuk berikut: </p><br><p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br><p>  Seperti yang Anda lihat, setelah belokan ganda, keseimbangan lebih lanjut pada pohon juga tidak diperlukan. </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       funtion double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  Jadi, ketika Anda memasukkan catatan ke pohon AVL, Anda perlu <em>O</em> (log <sub>2</sub> <em>N</em> ) perubahan informasi tentang ketinggian node dan tidak lebih dari dua operasi rotasi.  Gabungkan semuanya menjadi satu fungsi insert.  Ini akan berbeda dari insert dasar hanya setelah simpul baru <code>fix_insertion!()</code> , yang berpindah dari node yang baru dimasukkan ke root, memeriksa dan, jika perlu, mengoreksi keseimbangan. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left <span class="hljs-comment"><span class="hljs-comment">#   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 # true == 1, false == 0 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> <br><p>  Fungsi <code>fix_insertion!()</code> Memeriksa perbedaan ketinggian antara dua simpul anak, mulai dari simpul induk dari yang dimasukkan.  Jika sama dengan 1 - kita berada dalam kasus 1, Anda perlu menaikkan ketinggian node dan pergi lebih tinggi.  Jika nol, pohon seimbang.  Jika sama dengan 2 - ini adalah kasus 2 atau 3, Anda perlu menerapkan rotasi yang sesuai, dan pohon mencapai kondisi seimbang. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#     -  , #   -  imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) #      0 - ..        while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 #       , # ..   dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end</span></span></code> </pre> <br><h4 id="udalenie-zapisi">  Hapus catatan </h4><br><p>  Menghapus sedikit lebih sulit daripada memasukkan. </p><br><p>  Untuk memulai, pertimbangkan penghapusan entri dari pohon pencarian biner yang biasa. </p><br><ol><li>  Jika catatan yang dihapus ada di lembar, maka catatan itu hanya dihapus, semuanya sederhana di sini. </li><li>  Jika catatan yang dihapus berada dalam node yang hanya memiliki satu keturunan, maka keturunan ini, bersama dengan semua subtree-nya, diletakkan di tempat node jarak jauh. </li><li>  Jika ada dua keturunan, maka elemen maksimum dicari di subtree kiri, atau minimum di kanan, diekstraksi dari pohon (oleh properti pohon pencarian, node dengan elemen maksimum dijamin tidak memiliki keturunan kanan, dan dengan elemen minimum ke kiri, jadi penghapusan ini mudah) dan menempatkan catatan yang dihapus. </li></ol><br><p>  Tetapi setelah itu, keseimbangan pohon mungkin terganggu, jadi Anda harus naik dari induk dari simpul jarak jauh, memulihkannya.  Perhatikan bahwa pada awalnya dijamin bahwa salah satu keturunan dari orang tua yang dimaksud mengurangi ketinggian dengan 1. Dengan mempertimbangkan hal ini, Anda perlu mempertimbangkan opsi (node ​​yang mengubah ketinggian ditunjukkan dengan warna merah, simpul yang diproses adalah induk dari merah): </p><br><p>  <strong>Kasus 1</strong> <br>  Ketidakseimbangan nol.  Jadi, sebelum dihapus, itu adalah 1 modulo, dan sekarang simpul anak 2 lebih rendah dari induknya. </p><br><p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br><p>  Anda harus menurunkan simpul induk sebanyak 1 dan terus bergerak ke atas. </p><br><p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br><p>  <strong>Kasus 2</strong> <br>  Ketidakseimbangan 1 modulo. </p><br><p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br><p>  Kondisi AVL puas, Anda bisa berhenti. </p><br><p>  <strong>Kasus 3</strong> <br>  Ketidakseimbangan 2 adalah modulo, simpul saudara ke simpul turun memiliki ketidakseimbangan yang tidak nol. </p><br><p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br><p>  Kami mengembalikan keseimbangan dengan sederhana (jika T1 lebih rendah dari T2) atau dengan menggandakan (jika tidak) rotasi, seperti yang dilakukan selama penyisipan.  Ketinggian subtree berkurang, mis.  pelanggaran dapat terjadi di atas pohon. </p><br><p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br><p>  <strong>Kasus 4</strong> <br>  Ketidakseimbangan 2 modulo, simpul saudara memiliki nol ketidakseimbangan. </p><br><p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br><p>  Rotasi sederhana mengembalikan kondisi keseimbangan, sedangkan ketinggian subtree tidak berubah - kami berhenti bergerak ke atas. </p><br><p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br><div class="spoiler">  <b class="spoiler_title">Kode Penghapusan Kunci</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::AVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::AVLNode) node = start skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">2</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew = imbalance(n) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(prev_skew) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_skew == dir node = double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = rotate!(n, dir) prev_skew != <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.height -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="vzlyot-i-padenie-avl-derevev">  Naik turunnya pohon AVL </h3><br><p>  Fitur yang tidak terlalu bagus dari pohon AVL klasik adalah kesulitan menghapus catatan:  rotasi dapat "mengatur ulang" seluruh subtree satu tingkat ke bawah, maka dalam kasus terburuk, menghapus memerlukan rotasi pohon <em>O</em> (log <sub>2</sub> <em>N</em> ) - setiap kali Anda naik satu tingkat di <code>fix_deletion!()</code> . </p><br><p>  Karena perilaku asimptotik yang tidak begitu baik ini, pohon AVL memberi jalan kepada pohon merah-hitam yang muncul pada tahun 1970-an dan memiliki kondisi keseimbangan yang lebih lemah - jalur dari akar ke daun terjauh tidak lebih dari dua kali jalur dari akar ke daun terdekat.  Karena itu, ketinggian pohon merah-hitam dalam kasus terburuk 2log <sub>2</sub> <em>N</em> versus 1.44log <sub>2</sub> <em>N</em> untuk pohon AVL, tetapi menghapus catatan tidak memerlukan lebih dari tiga rotasi sederhana.  Dengan demikian, pencarian dan penyisipan karena tinggi pohon yang lebih tinggi berpotensi kehilangan kinerja, tetapi ada keuntungan potensial jika penyisipan sering diselingi dengan penghapusan. </p><br><h3 id="avl-nanosyat-otvetnyy-udar">  AVL menyerang balik </h3><br><p>  Ternyata algoritma "ideal" untuk membangun pohon pencarian biner harus menjamin ketinggian kecil (pada tingkat pohon AVL klasik) dan jumlah rotasi konstan baik ketika menambah atau menghapus catatan.  Ini belum ditemukan, tetapi pada 2015 sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karya</a> diterbitkan yang mengusulkan struktur yang meningkatkan sifat-sifat AVL dan pohon merah-hitam.  Idenya terletak lebih dekat ke pohon AVL, tetapi kondisi keseimbangan santai untuk memungkinkan penghapusan catatan yang lebih efisien.  Sifat-sifat struktur yang disebut "pohon AVL lemah" (W (eak) pohon AVL) dirumuskan sebagai berikut: </p><br><ol><li>  Pemesanan: untuk setiap simpul, kunci di bagian atas subtree kiri kurang dari kunci di bagian atas subtree kanan (jika turunannya bukan node kosong). </li><li>  Pangkat naik.  Setiap node diberi peringkat.  Pangkat semua node kosong adalah nol, pangkat lembaran adalah 1. Pangkat simpul orangtua secara ketat lebih besar dari pangkat anak. </li><li>  Lemah ABL-balance: pangkat suatu simpul berbeda dari pangkat simpul anak dengan tidak lebih dari 2. </li></ol><br><p>  Ternyata struktur seperti itu termasuk properti dari kedua pohon AVL klasik dan pohon merah-hitam.  Secara khusus, jika kami memperkenalkan kondisi bahwa <em>kedua</em> node anak tidak dapat berbeda dari orang tua di peringkat oleh 2, kami mendapatkan pohon AVL biasa, dan peringkat tersebut akan sama persis dengan ketinggian subtree. </p><br><p>  Keindahan pohon SAVL adalah bahwa sedikit melemahnya kondisi AVL memungkinkan pohon untuk menjadi seimbang ketika menghapus catatan dengan tidak lebih dari dua putaran!  Perkiraan tinggi pohon adalah h &lt;min (1,44 log <sub>2</sub> <em>M</em> , 2log <sub>2</sub> <em>N</em> ), di mana <em>N</em> adalah jumlah entri di pohon, <em>M</em> adalah jumlah sisipan, dibandingkan dengan h &lt; <sub>2</sub> log <sub>2</sub> <em>N</em> untuk pohon merah-hitam.  ,  -   ,       ,      . </p><br><p>  -             ,          .  -        . </p><br><h4 id="struktura-hraneniya">  . </h4><br><p>     -,  ""    "".  ,   : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> WAVLNode rank::<span class="hljs-built_in"><span class="hljs-built_in">UInt8</span></span> key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} parent::WAVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function WAVLNode{K,V}() where {K,V} node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing return node end #    - function WAVLNode{K,V}(key, value) where {K,V} key, value = convert(K, key), convert(V, value) node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end struct WAVLTree{K, V} entry::WAVLNode{K,V} WAVLTree{K,V}() where {K,V} = new{K,V}(WAVLNode{K,V}()) end function child(root::WAVLNode, side::Signed) if side == -1 root.left elseif side == 1 root.right else throw(ArgumentError("Expecting side=-1 to get the left child or side=1 to get the right child")) end end function Base.getindex(avlt::WAVLTree{K,V}, key) where {K,V} key = convert(K, key) node = avlt.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><h4 id="vstavka-zapisi-1">   </h4><br><p>    ,     -.  :      1    ,      —      ,          0 (  )  1 (    ).      <code>imbalance()</code> ,     ,  . </p><br><pre> <code class="julia hljs">wavlrank(node::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,WAVLNode}) = node == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(node.rank) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> imbalance(node::WAVLNode) rr, lr = wavlrank(node.right), wavlrank(node.left) skew = rr - lr diff = node.rank - max(rr, lr) skew, diff <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    ,           .  ,  ,    ,    ,    -,   - . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end # pivot       function double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end function Base.setindex!(avlt::AVLTree{K,V}, val, key) where {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left #   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> </div></div><br><h4 id="udalenie-zapisi-1">   </h4><br><p>    ,     —    -.        . </p><br><p> <strong> 0</strong> <br>       , ..: </p><br><ol><li>  1,     1   </li><li>  0,    2  ,     . <br>    . </li></ol><br><p> <strong> 1</strong> <br>     2 ( 0,   2   ). <br>    1   . </p><br><p> <strong> 2</strong> <br>  1,     2. </p><br><p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br><p>      1,  . </p><br><p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br><p> <strong> 3</strong> <br>  2 (     1, ..          ),         2  . </p><br><p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br><p>       ,    .  . </p><br><p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br><p> <strong> 4</strong> <br><img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br><p>  ,          ,      , ..      . </p><br><p>   —   T <sub>1</sub>  T <sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1. </p><br><p> <strong> 5</strong> <br><img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br><p> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::WAVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::WAVLNode) node = start skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> node.rank = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> diff == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew, prev_diff = imbalance(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_diff == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> prev_skew == <span class="hljs-number"><span class="hljs-number">0</span></span> n.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> prev_skew == dir double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rotate!(n, dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>      -. </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wavl = WAVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avl = AVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dd = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; x = trues(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       ~  julia&gt; for i = 1:1_000_000; dd[i] = avl[i] = wavl[i] = i * i; end julia&gt; for i=1:500_000 k = rand(1:1_000_000) x[k] = false delete!(avl, k) delete!(wavl, k) delete!(dd, k) end # ,     julia&gt; const y = Int[] julia&gt; for i in eachindex(x); if x[i] push!(y, i); end; end julia&gt; @btime let s = 0.0; for idx in y; s += dd[idx]; end; s; end 57.626 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += wavl[idx]; end; s; end 57.796 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += avl[idx]; end; s; end 53.884 ms (0 allocations: 0 bytes) 2.0238199367708794e17</span></span></code> </pre> <br><p> ,        ,    . , ,   -    ,   -,    . </p><br><h3 id="primenenie-derevev-poiska">    </h3><br><p>    —   ? <br>   —   ,   . ,   ,  . </p><br><p>           . </p><br><h4 id="uporyadochennoe-mnozhestvo">   </h4><br><p>    —   ,           .      <em>n</em> -   . ,     , ..  ,       . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th></tr></thead><tbody><tr><td>    </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td> <em>n</em> -  </td><td> <em>O</em> (log <em>N</em> )* </td><td> <em>O</em> (1) </td></tr></tbody></table></div><br><p> *         </p><br><h4 id="associativnyy-massiv">   </h4><br><p>   —   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th> - </th><th>  </th><th>   </th></tr></thead><tbody><tr><td>  Cari </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> )** </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>    </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr></tbody></table></div><br><p> *    <br> **     <em>O</em> (1),     ... </p><br><h4 id="ochered-s-prioritetami">    </h4><br><p>    ,       " — ".      ,    .   —     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th><th>  </th><th>  / </th></tr></thead><tbody><tr><td>   </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1)** </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr></tbody></table></div><br><p> *        <br> **  ,       </p><br><h3 id="vyvod">  Kesimpulan </h3><br><p> ()    —       ,   , ,   , ,    .      —     , ..  ,         ,   . </p><br><h2 id="ssylki">  Referensi </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">nickme</a> </li><li> Rank-Balanced Trees by Bernhard Haeupler, Siddhartha Sen, Robert E. Tarjan // ACM Transactions on Algorithms | June 2015, Vol 11(4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pdf</a> </li><li> Goodrich MT, Tamassia R. Algorithm Design and Applications </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455172/">https://habr.com/ru/post/id455172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455160/index.html">Entity Framework 6 dengan Pencarian Teks Lengkap via LINQ</a></li>
<li><a href="../id455164/index.html">Elena Balashova: "Para aktivis mengajukan pertanyaan bahwa data portal GIS kami harus terbuka untuk OpenStreetMap"</a></li>
<li><a href="../id455166/index.html">VPN pada router Beeline untuk memotong kunci</a></li>
<li><a href="../id455168/index.html">Demo 492 byte pada ATtiny5</a></li>
<li><a href="../id455170/index.html">Arsitektur baru untuk akses byte ke SSD - cara kerjanya</a></li>
<li><a href="../id455176/index.html">Apakah mungkin tanpa Redux?</a></li>
<li><a href="../id455178/index.html">Tangkap aku jika kau bisa. Versi Direktur</a></li>
<li><a href="../id455184/index.html">Printer 3D seharga $ 250 kamar</a></li>
<li><a href="../id455186/index.html">Printer 3D MIT: hingga 10 bahan per model</a></li>
<li><a href="../id455190/index.html">Pencetakan 3D sel otot jantung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>