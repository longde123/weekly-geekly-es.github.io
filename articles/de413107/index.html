<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßú üçµ üö£üèª √úbersetzung des Svelto.ECS-Projekt-Wikis. ECS-Framework f√ºr Unity3D üçÇ üë©üèæ‚Äçü§ù‚Äçüë©üèª üç°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inhaltsverzeichnis  INHALT 


1. Einf√ºhrung 
2. Kompositionswurzel und Motorenwurzel 
3. Entit√§ten 
4. Motoren 
5. Entit√§tsdarstellungen 
6. Komponent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úbersetzung des Svelto.ECS-Projekt-Wikis. ECS-Framework f√ºr Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413107/"><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><h2>  INHALT </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompositionswurzel und Motorenwurzel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entit√§ten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Motoren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entit√§tsdarstellungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komponenten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entit√§tsdeskriptoren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Impulatoren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entit√§tserstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommunikation bei Svelto.ECS</a> </li></ol><br></div></div><br>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Wikis des <a href="">Svelto.ECS-</a> Projekts von Sebastiano Mandal√†. <br><br>  Svelto.ECS ist das Ergebnis langj√§hriger Forschung und Anwendung von SOLID-Prinzipien bei der Entwicklung von Spielen auf Unity.  Dies ist eine der vielen Implementierungen des f√ºr C # verf√ºgbaren ECS-Musters mit verschiedenen einzigartigen Funktionen, die eingef√ºhrt wurden, um die M√§ngel des Musters selbst zu beheben. <a name="habracut"></a><br><br><h2>  Erster Blick </h2><br>  Der einfachste Weg, um die Grundfunktionen von Svelto.ECS zu sehen, ist das Herunterladen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vanilla Example</a> .  Wenn Sie die Benutzerfreundlichkeit sicherstellen m√∂chten, zeige ich Ihnen ein Beispiel: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  void ApplicationCompositionRoot() { var simpleSubmissionEntityViewScheduler = new SimpleSubmissionEntityViewScheduler(); _enginesRoot = new EnginesRoot(simpleSubmissionEntityViewScheduler); var entityFactory = _enginesRoot.GenerateEntityFactory(); var entityFunctions = _enginesRoot.GenerateEntityFunctions(); _enginesRoot.AddEngine(new BehaviourForSimpleEntityEngine(entityFunctions)); entityFactory.BuildEntity&lt;SimpleEntityDescriptor&gt;(new EGID(1), new[] { new SimpleImplementor() });` } //  class SimpleEntityDescriptor : GenericEntityDescriptor&lt;BehaviourEntityViewForSimpleEntity&gt; { } public class BehaviourEntityViewForSimpleEntity : EntityView { public ISimpleComponent simpleComponent; } public interface ISimpleComponent { public int counter {get; set;} } class SimpleImplementor : ISimpleComponent { public int counter { get; set; } } //  ()    public class BehaviourForSimpleEntityAsStructEngine : IQueryingEntityViewEngine { public IEntityViewsDB entityViewsDB { private get; set; } public void Ready() { Update().Run(); } //   . //    N ,  N    0  1. IEnumerator Update() { Console.Log("Task Waiting"); while (true) { var entityViews = entityViewsDB .QueryGroupedEntityViews&lt;BehaviourEntityViewForSimpleEntity&gt;(0); if (entityViews.Length&gt; 0) { for (var i = 0; i &lt; entityViews.Length; i++) AddOne(entityViews[i].counter); Console.Log("Task Done"); yield break; } yield return null; } } static void AddOne(int counter) { counter += 1; } }</span></span></code> </pre> <br>  Leider ist es nicht m√∂glich, die Theorie hinter diesem Code schnell zu verstehen, die einfach, aber gleichzeitig verwirrend aussehen kann.  Um dies zu verstehen, m√ºssen Sie Zeit damit verbringen, die ‚ÄûTextwand‚Äú zu lesen und die obigen Beispiele auszuprobieren. <br><a name="Introduction"></a><br><h2>  Einf√ºhrung </h2><br>  In letzter Zeit habe ich mit mehreren mehr oder weniger erfahrenen Programmierern <b>viel</b> √ºber <b>Svelto.ECS gesprochen</b> .  Ich habe viele R√ºckmeldungen gesammelt und viele Notizen gemacht, die ich als Ausgangspunkt f√ºr meine n√§chsten Artikel verwenden werde, in denen ich mehr √ºber Theorie und bew√§hrte Praktiken sprechen werde.  Ein kleiner Spoiler: Ich habe festgestellt, dass die gr√∂√üte H√ºrde bei <b>der</b> Verwendung von Svelto.ECS darin besteht, <b>das Programmierparadigma zu √§ndern</b> .  Es ist erstaunlich, wie viel ich schreiben muss, um die neuen Konzepte von Svelto.ECS zu erkl√§ren, verglichen mit der geringen Menge an Code, die zur Entwicklung des Frameworks geschrieben wurde.  W√§hrend das Framework selbst sehr einfach und leicht ist, verhindert der √úbergang von OOP unter aktiver Verwendung der Vererbung oder der √ºblichen Unity-Komponenten zu dem von Svelto.ECS angebotenen ‚Äûneuen‚Äú modularen und lose gekoppelten Design, dass sich Benutzer an das Framework anpassen. <br><br>  Svelto.ECS wird in <b>Freejam</b> aktiv verwendet (Anmerkung des √úbersetzers - Der Autor ist der technische Direktor dieser Firma).  Da ich meinen Kollegen immer die grundlegenden Konzepte des Frameworks erkl√§ren kann, brauchen sie weniger Zeit, um die Arbeit damit zu verstehen.  Obwohl Svelto.ECS so hart wie m√∂glich ist, sind schlechte Gewohnheiten schwer zu √ºberwinden, sodass Benutzer dazu neigen, eine gewisse Flexibilit√§t zu missbrauchen, die es ihnen erm√∂glicht, das Framework an die ‚Äûalten‚Äú Paradigmen anzupassen, mit denen sie vertraut sind.  Dies kann aufgrund von Missverst√§ndnissen oder Verzerrungen der der Rahmenlogik zugrunde liegenden Konzepte zu einer Katastrophe f√ºhren.  Aus diesem Grund beabsichtige ich, so viele Artikel wie m√∂glich zu schreiben, zumal ich sicher bin, dass das ECS-Paradigma derzeit die beste L√∂sung ist, um effektiven und unterst√ºtzten Code f√ºr gro√üe Projekte zu schreiben, die sich √ºber mehrere Jahre hinweg mehrmals √§ndern und √ºberarbeiten.  <b>Robocraft</b> und <b>Cardlife</b> sind ein Beweis daf√ºr. <br><br>  Ich werde nicht viel √ºber die Theorien sprechen, die diesem Artikel zugrunde liegen.  Ich m√∂chte Sie nur daran erinnern, warum ich mich geweigert habe, den <b>IoC-Container zu verwenden,</b> und ausschlie√ülich das ECS-Framework verwendet habe: Der IoC-Container ist ein sehr gef√§hrliches Werkzeug, wenn er verwendet wird, ohne das Wesentliche der Steuerungsinversion zu verstehen.  Wie Sie aus meinen vorherigen Artikeln sehen k√∂nnen, unterscheide ich zwischen der Inversion der Erstellungssteuerung (Inversion der Erstellungssteuerung) und der Inversion der Flusssteuerung (Inversion der Flusssteuerung).  Das Umkehren der Flusskontrolle ist wie Hollywoods Prinzip: "Rufen Sie uns nicht an, wir rufen Sie an."  Dies bedeutet, dass injizierte Abh√§ngigkeiten niemals direkt √ºber √∂ffentliche Methoden verwendet werden sollten, da Sie dabei einfach den IoC-Container als Ersatz f√ºr jede andere Form der globalen Injektion verwenden, z. B. Singleton.  Wenn der IoC-Container jedoch auf der Grundlage von Inversion of Management (IoC) verwendet wird, kommt es im Wesentlichen darauf an, das Muster ‚ÄûVorlagenmethode‚Äú wiederzuverwenden, um Manager einzuf√ºhren, die nur zum Registrieren von von ihnen verwalteten Objekten verwendet werden.  Im realen Kontext von Flusskontrollinversionen sind Manager immer f√ºr die Verwaltung von Entit√§ten verantwortlich.  Sieht das aus wie ein ECS-Muster?  Nat√ºrlich.  Basierend auf dieser √úberlegung habe ich das ECS-Muster genommen und ein starres Framework darauf basierend entwickelt, und seine Verwendung ist gleichbedeutend mit der Anwendung des neuen Programmierparadigmas. <br><a name="Composition_Root"></a><br><h2>  Composition Root und EnginesRoot </h2><br>  Die Hauptklasse ist die Kompositionswurzel der Anwendung.  Die Wurzel der Komposition ist der Ort, an dem Abh√§ngigkeiten erstellt und implementiert werden (dar√ºber habe ich in meinen Artikeln viel gesprochen).  Eine Kompositionswurzel geh√∂rt zu einem Kontext, aber ein Kontext kann mehr als eine Kompositionswurzel haben.  Zum Beispiel ist die Fabrik die Wurzel der Komposition.  Eine Anwendung kann mehr als einen Kontext haben, dies ist jedoch ein erweitertes Szenario. In diesem Beispiel wird dies nicht ber√ºcksichtigt. <br><br>  Bevor wir uns mit dem Code befassen, sollten wir uns mit den ersten Regeln der Sprache Svelto.ECS vertraut machen.  ECS ist die Abk√ºrzung Entity Component System.  Die ECS-Infrastruktur wurde in Artikeln von vielen Autoren gut analysiert, aber w√§hrend die Grundkonzepte allgemein sind, variieren die Implementierungen stark.  Erstens gibt es keinen Standardweg, um einige Probleme zu l√∂sen, die bei der Verwendung von ECS-orientiertem Code auftreten.  In Bezug auf dieses Thema mache ich den gr√∂√üten Teil meiner Bem√ºhungen, aber ich werde sp√§ter oder in den folgenden Artikeln dar√ºber sprechen.  Die Theorie basiert auf den Konzepten von Essenz, Komponenten (Entit√§ten) und Systemen.  Obwohl ich verstehe, warum das Wort System in der Vergangenheit verwendet wurde, fand ich es von Anfang an nicht intuitiv genug f√ºr diesen Zweck. Daher habe ich die Engine als Synonym f√ºr das System verwendet, und Sie k√∂nnen je nach Ihren Vorlieben einen dieser Begriffe verwenden. <br><br>  Die EnginesRoot-Klasse ist der Kern von Svelto.ECS.  Mit seiner Hilfe k√∂nnen Sie Engines registrieren und die gesamte Essenz des Spiels entwerfen.  Das dynamische Erstellen von Engines ist wenig sinnvoll. Daher sollten sie alle der EnginesRoot-Instanz aus demselben Stammverzeichnis der Komposition hinzugef√ºgt werden, in der sie erstellt wurden.  Aus √§hnlichen Gr√ºnden sollte eine EnginesRoot-Instanz niemals bereitgestellt werden, und Engines sollten nach dem Hinzuf√ºgen nicht gel√∂scht werden. <br><br>  Um Abh√§ngigkeiten zu erstellen und zu implementieren, ben√∂tigen wir mindestens eine Wurzel der Komposition.  Ja, in einer Anwendung gibt es m√∂glicherweise mehr als einen EnginesRoot, aber wir werden dies im aktuellen Artikel nicht ansprechen, den ich so weit wie m√∂glich zu vereinfachen versuche.  So sieht die Kompositionswurzel bei der Erstellung von Engines und der Abh√§ngigkeitsinjektion aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupEnginesAndEntities</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Engines Root   Svelto.ECS.      EngineRoot // ,  Composition Root     ,   //   . //UnitySumbmissionEntityViewScheduler -  ,   //EnginesRoot,     EntityViews. //    ,   , //         Unity. _enginesRoot = new EnginesRoot(new UnitySumbmissionEntityViewScheduler()); //Engines root      ,   , //   . //   EntityFactory  EntityFunctions. //EntityFactory      //(    ), //   . _entityFactory = _enginesRoot.GenerateEntityFactory(); // EntityFunctions     //   , //  .        var entityFunctions = _enginesRoot.GenerateEntityFunctions(); //GameObjectFactory   Unity GameObject //   // GameObject.Instantiate.      // ,    ,   //       //(  ,   //         //      -  ) GameObjectFactory factory = new GameObjectFactory(); //    3     Svelto.ECS. //        //  . //         //     . var enemyKilledObservable = new EnemyKilledObservable(); var scoreOnEnemyKilledObserver = new ScoreOnEnemyKilledObserver(enemyKilledObservable); //ISequencer   3     Svelto.ECS // .       : //1)       //(   //,   ,     //  ). //2)   ,     // . ISequencer      //  Sequencer playerDamageSequence = new Sequencer(); Sequencer enemyDamageSequence = new Sequencer(); //    Unity. //     . IRayCaster rayCaster = new RayCaster(); ITime time = new Others.Time(); // .         //  . var playerHealthEngine = new HealthEngine(entityFunctions, playerDamageSequence); var playerShootingEngine = new PlayerGunShootingEngine(enemyKilledObservable, enemyDamageSequence, rayCaster, time); var playerMovementEngine = new PlayerMovementEngine(rayCaster, time); var playerAnimationEngine = new PlayerAnimationEngine(); //  var enemyAnimationEngine = new EnemyAnimationEngine(); var enemyHealthEngine = new HealthEngine(entityFunctions, enemyDamageSequence); var enemyAttackEngine = new EnemyAttackEngine(playerDamageSequence, time); var enemyMovementEngine = new EnemyMovementEngine(); var enemySpawnerEngine = new EnemySpawnerEngine(factory, _entityFactory); //    var hudEngine = new HUDEngine(time); var damageSoundEngine = new DamageSoundEngine(); // Sequencer  ,    // ,     . playerDamageSequence.SetSequence( new Steps // ,  ! { { //  //      Next   enemyAttackEngine, new To //        { //      //   Next playerHealthEngine, } }, { //  playerHealthEngine, //      Next   new To //       { //      Next     //DamageCondition.damage { DamageCondition.damage, new IStep[] { hudEngine, damageSoundEngine } }, //      Next     //DamageCondition.dead { DamageCondition.dead, new IStep[] { hudEngine, damageSoundEngine, playerMovementEngine, playerAnimationEngine, enemyAnimationEngine } }, } } }); enemyDamageSequence.SetSequence( new Steps { { playerShootingEngine, new To { enemyHealthEngine, } }, { enemyHealthEngine, new To { { DamageCondition.damage, new IStep[] { enemyAnimationEngine, damageSoundEngine } }, { DamageCondition.dead, new IStep[] { enemyMovementEngine, enemyAnimationEngine, playerShootingEngine, enemySpawnerEngine, damageSoundEngine } }, } } }); // ,     //  _enginesRoot.AddEngine(playerMovementEngine); _enginesRoot.AddEngine(playerAnimationEngine); _enginesRoot.AddEngine(playerShootingEngine); _enginesRoot.AddEngine(playerHealthEngine); _enginesRoot.AddEngine(new PlayerInputEngine()); _enginesRoot.AddEngine(new PlayerGunShootingFXsEngine()); //  _enginesRoot.AddEngine(enemySpawnerEngine); _enginesRoot.AddEngine(enemyAttackEngine); _enginesRoot.AddEngine(enemyMovementEngine); _enginesRoot.AddEngine(enemyAnimationEngine); _enginesRoot.AddEngine(enemyHealthEngine); //  _enginesRoot.AddEngine(new CameraFollowTargetEngine(time)); _enginesRoot.AddEngine(damageSoundEngine); _enginesRoot.AddEngine(hudEngine); _enginesRoot.AddEngine(new ScoreEngine(scoreOnEnemyKilledObserver));</span></span></code> </pre><br>  Dieser Code stammt aus dem Survival-Beispiel, das jetzt auskommentiert ist und fast allen Regeln bew√§hrter Verfahren entspricht, die ich anwenden m√∂chte, einschlie√ülich der Verwendung plattformunabh√§ngiger und getesteter Engine-Logik.  Kommentare helfen Ihnen, die meisten von ihnen zu verstehen, aber ein Projekt dieser Gr√∂√üe kann schwierig zu verstehen sein, wenn Sie neu bei Svelto sind. <br><a name="Entities"></a><br><h2>  Entit√§ten </h2><br>  Der erste Schritt nach dem Erstellen des leeren Stamms der Komposition und einer Instanz der EnginesRoot-Klasse besteht darin, die Objekte zu identifizieren, mit denen Sie zuerst arbeiten m√∂chten.  Es ist logisch, mit Entity Player zu beginnen.  Die Essenz von Svelto.ECS sollte nicht mit dem Unity Game Object (GameObject) verwechselt werden.  Wenn Sie andere Artikel zu ECS lesen, k√∂nnen Sie feststellen, dass Entit√§ten in vielen von ihnen h√§ufig als Indizes bezeichnet werden.  Dies ist wahrscheinlich der schlechteste Weg, um das ECS-Konzept einzuf√ºhren.  Obwohl dies f√ºr Svelto.ECS zutrifft, ist es darin versteckt.  Ich m√∂chte, dass der Svelto.ECS-Benutzer jede Entit√§t in Bezug auf die Game Design Domain-Sprache darstellt, beschreibt und identifiziert.  Die Entit√§t im Code muss das Objekt sein, das im Designdokument des Spiels beschrieben ist.  Jede andere Form der Entit√§tsdefinition f√ºhrt zu einer weit hergeholten Methode, um Ihre alten Ansichten an die Svelto.ECS-Prinzipien anzupassen.  Befolgen Sie diese Grundregel und Sie werden sich nicht irren.  Die Entit√§tsklasse selbst ist im Code nicht vorhanden, Sie sollten sie jedoch nicht abstrakt definieren. <br><a name="Engines"></a><br><h2>  Motoren </h2><br>  Der n√§chste Schritt besteht darin, dar√ºber nachzudenken, welches Verhalten die Entit√§ten zu fragen haben.  Jedes Verhalten wird immer innerhalb der Engine modelliert. Sie k√∂nnen keinen anderen Klassen in der Svelto.ECS-Anwendung Logik hinzuf√ºgen.  Wir k√∂nnen beginnen, indem wir den Charakter des Spielers verschieben und die <b>PlayerMovementEngine-</b> Klasse definieren.  Der Name des Motors sollte sehr eng fokussiert sein, denn je spezifischer er ist, desto wahrscheinlicher ist es, dass der Motor der Einzelverantwortungsregel folgt.  Die korrekte Benennung von Klassen in Svelto.ECS ist von grundlegender Bedeutung.  Und das Ziel ist nicht nur, Ihre Absichten klar zu zeigen, sondern Ihnen auch zu helfen, sie selbst zu ‚Äûsehen‚Äú. <br><br>  Aus dem gleichen Grund ist es wichtig, dass sich Ihre Engine in einem sehr speziellen Namespace befindet.  Wenn Sie Namespaces gem√§√ü der Ordnerstruktur definieren, passen Sie sie an die Konzepte von Svelto.ECS an.  Die Verwendung bestimmter Namespaces hilft dabei, Entwurfsfehler zu erkennen, wenn Entit√§ten in inkompatiblen Namespaces verwendet werden.  Beispielsweise wird nicht davon ausgegangen, dass ein feindliches Objekt im Namespace des Spielers verwendet wird, es sei denn, das Ziel besteht darin, die Regeln zu brechen, die mit der Modularit√§t und der schwachen Kopplung von Objekten verbunden sind.  Die Idee ist, dass Objekte eines bestimmten Namespace nur innerhalb dieses oder des √ºbergeordneten Namespace verwendet werden k√∂nnen.  Mit Svelto.ECS ist es viel schwieriger, Ihren Code in Spaghetti umzuwandeln, in die Abh√§ngigkeiten rechts und links eingef√ºgt werden. Diese Regel hilft Ihnen dabei, die Messlatte f√ºr die Codequalit√§t noch h√∂her zu legen, wenn Abh√§ngigkeiten zwischen Klassen korrekt abstrahiert werden. <br><br>  In Svelto.ECS bewegt sich die Abstraktion einige Zeilen vorw√§rts, aber ECS hilft im Wesentlichen dabei, Daten von der Logik zu abstrahieren, die die Daten verarbeiten soll.  Entit√§ten werden durch ihre Daten bestimmt, nicht durch ihr Verhalten.  In diesem Fall ist Engines ein Ort, an dem Sie das gemeinsame Verhalten identischer Entit√§ten platzieren k√∂nnen, sodass Engines immer mit einer Reihe von Entit√§ten arbeiten k√∂nnen. <br><br>  Svelto.ECS und das ECS-Paradigma erm√∂glichen es dem Encoder, einen der heiligen Grale der reinen Programmierung zu erreichen, der die ideale Verkapselung der Logik darstellt.  Motoren sollten keine √∂ffentlichen Funktionen haben.  Die einzigen √∂ffentlichen Funktionen, die vorhanden sein m√ºssen, sind diejenigen, die zur Implementierung der Framework-Schnittstellen erforderlich sind.  Dies f√ºhrt dazu, dass die Abh√§ngigkeitsinjektion vergessen wird, und hilft, fehlerhaften Code zu vermeiden, der bei Verwendung der Abh√§ngigkeitsinjektion ohne Steuerungsinversion auftritt.  Motoren sollten NIEMALS in einen anderen Motor oder eine andere Klasse eingebettet werden.  Wenn Sie glauben, die Engine implementieren zu wollen, machen Sie einfach einen grundlegenden Fehler im Code-Design. <br><br>  Im Vergleich zu Unity MonoBehaviours weisen Engines bereits den ersten gro√üen Vorteil auf, n√§mlich den Zugriff auf alle Zust√§nde von Entit√§ten dieses Typs aus demselben Codebereich.  Dies bedeutet, dass der Code den Status aller Objekte problemlos direkt von derselben Stelle aus verwenden kann, an der die Logik des gemeinsamen Objekts ausgef√ºhrt wird.  Dar√ºber hinaus k√∂nnen einzelne Engines dieselben Objekte verarbeiten, sodass die Engine den Status des Objekts √§ndern kann, w√§hrend die andere Engine es lesen kann, wobei effektiv zwei Engines f√ºr die Kommunikation √ºber dieselben Entit√§tsdaten verwendet werden.  Ein Beispiel finden Sie in den <b>Engines PlayerGunShootingEngine</b> und <b>PlayerGunShootingFxsEngine</b> .  In diesem Fall befinden sich zwei Engines im selben Namespace, sodass sie dieselben Entit√§tsdaten gemeinsam nutzen k√∂nnen.  <b>PlayerGunShootingEngine</b> ermittelt, ob ein Spieler (Feind) besch√§digt wurde, und schreibt den <b>lastTargetPosition-</b> Wert der <b>IGunAttributesComponent-</b> Komponente (die eine <b>PlayerGunEntity-</b> Komponente ist).  <b>PlayerGunShootFxsEngine</b> verarbeitet die grafischen Effekte der Waffe und liest die Position des vom Spieler ausgew√§hlten Ziels.  Dies ist ein Beispiel f√ºr die Interaktion zwischen Engines durch Datenabfrage.  Sp√§ter in diesem Artikel werde ich zeigen, wie ein Mechanismus durch <i>Pushen von Daten (Daten-Pushing)</i> oder <i>Datenbindung (Datenbindung</i> <i>)</i> zwischen ihnen kommunizieren kann.  Logischerweise sollten Motoren niemals den Status speichern. <br><br>  Motoren m√ºssen nicht wissen, wie sie mit anderen Motoren interagieren sollen.  Externe Kommunikation erfolgt durch Abstraktion, und Svelto.ECS l√∂st die Verbindung zwischen den Motoren auf drei verschiedene offizielle Arten, aber ich werde sp√§ter darauf eingehen.  Die besten Motoren sind solche, die keine externe Kommunikation erfordern.  Diese Engines spiegeln ein gut gekapseltes Verhalten wider und arbeiten normalerweise durch eine logische Schleife.  Schleifen werden immer mit Svelto.Task-Tasks in Svelto.ECS-Anwendungen modelliert.  Da die Bewegung des Spielers bei jedem physischen Tick aktualisiert werden muss, ist es selbstverst√§ndlich, eine Aufgabe zu erstellen, die bei jedem physischen Tick ausgef√ºhrt wird.  Mit Svelto.Tasks k√∂nnen Sie jeden <b>IEnumerator-</b> Typ auf mehreren Schedulertypen <b>ausf√ºhren</b> .  In diesem Fall haben wir beschlossen, eine Aufgabe in <b>PhysicScheduler</b> zu erstellen, mit der Sie die Position des Spielers aktualisieren k√∂nnen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayerMovementEngine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IRayCaster raycaster, ITime time</span></span></span><span class="hljs-function">)</span></span> { _rayCaster = raycaster; _time = time; _taskRoutine = TaskRunner.Instance.AllocateNewTaskRoutine() .SetEnumerator(PhysicsTick()).SetScheduler(StandardSchedulers.physicScheduler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Stop(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,      //  EnginesRoot    . // ,         . var _playerEntityViews = entityViewsDB.QueryEntityViews&lt;PlayerEntityView&gt;(); var playerEntityView = _playerEntityViews[0]; while (true) { Movement(playerEntityView); Turning(playerEntityView); //   yield,     ! yield return null; } }</span></span></code> </pre><br>  Svelto.Tasks-Aufgaben k√∂nnen direkt oder √ºber <b>ITaskRoutine-</b> Objekte ausgef√ºhrt werden.  Ich werde hier nicht viel √ºber Svelto sprechen. Aufgaben, da ich andere Artikel daf√ºr geschrieben habe.  Der Grund, warum ich mich f√ºr die Task-Routine entschieden habe, anstatt die IEnumerator-Implementierung direkt zu starten, liegt im Ermessen.  Ich wollte zeigen, dass Sie einen Zyklus starten k√∂nnen, wenn das Objekt eines Spielers zur Engine hinzugef√ºgt wird, und es stoppen k√∂nnen, wenn es gel√∂scht wird.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu m√ºssen Sie jedoch wissen, wann ein Objekt hinzugef√ºgt und gel√∂scht wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Svelto.ECS f√ºhrt das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzuf√ºgen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√ºckrufen ein </font><font style="vertical-align: inherit;">, </font><b><font style="vertical-align: inherit;">um</font></b><font style="vertical-align: inherit;"> zu wissen, wann bestimmte Entit√§ten hinzugef√ºgt oder entfernt werden. Dies ist etwas Einzigartiges in Svelto.ECS, aber dieser Ansatz sollte mit Bedacht verwendet werden. Ich habe oft gesehen, dass diese R√ºckrufe missbraucht werden, da sie in vielen F√§llen ausreichen, um Entit√§ten abzufragen. Selbst eine Entit√§tsreferenz als Engine-Feld sollte eher als Ausnahme als als Regel betrachtet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur wenn diese R√ºckrufe verwendet werden sollen, sollte die Engine entweder von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingleEntityViewEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiEntitiesViewEngine &lt;EntityView1, ..., EntityViewN&gt; geerbt werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Auch hier sollte die Verwendung dieser Daten selten sein, und sie beabsichtigen in keiner Weise zu melden, welche Objekte die Engine verarbeiten wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Engines implementieren am h√§ufigsten die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryingEntityViewEngine-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><font style="vertical-align: inherit;">. Auf diese Weise k√∂nnen Sie auf Daten aus einer Entit√§tsdatenbank zugreifen und diese extrahieren. Denken Sie daran, dass Sie jederzeit ein Objekt innerhalb der Engine anfordern k√∂nnen. Sobald Sie jedoch eine Entit√§t anfordern, die nicht mit dem Namespace kompatibel ist, in dem sich die Engine befindet, sollten Sie verstehen, dass Sie bereits etwas falsch machen. Engines sollten niemals davon ausgehen, dass auf Entit√§ten zugegriffen werden kann, und sollten an einer Reihe von Objekten arbeiten. Es sollte nicht davon ausgegangen werden, dass immer nur ein Spieler im Spiel ist, wie ich es im Codebeispiel tue. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnemyMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt einen sehr allgemeinen Ansatz zum Anfordern von Objekten: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ready</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Tick().Run(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemyTargetEntityViews = entityViewsDB.QueryEntityViews&lt;EnemyTargetEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyTargetEntityViews.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetEntityView = enemyTargetEntityViews[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemies = entityViewsDB.QueryEntityViews&lt;EnemyEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = enemies[i].movementComponent; component.navMeshDestination = targetEntityView.targetPositionComponent.position; } } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall startet der Haupt-Engine-Zyklus direkt auf dem vordefinierten Scheduler. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§kchen () .Run ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt den k√ºrzesten Weg, um IEnumerator mit Svelto.Tasks zu starten. IEnumerator wird weiterhin dem n√§chsten Frame nachgeben, bis mindestens ein Enemy-Ziel gefunden wurde. Da wir wissen, dass es immer nur ein Ziel geben wird (eine weitere schlechte Annahme), w√§hle ich das erste verf√ºgbare. W√§hrend das Ziel von Enemy Target nur eines sein kann (obwohl es mehr geben k√∂nnte!), Gibt es viele Feinde, und der Motor k√ºmmert sich dennoch um die Logik der Bewegung f√ºr alle. In diesem Fall habe ich betrogen, da ich tats√§chlich das Unity Nav Mesh-System verwende. Ich muss also nur das Ziel auf NavMesh setzen. Ehrlich gesagt habe ich den Unity NavMesh-Code nie verwendet, daher bin ich mir nicht einmal sicher, wie er funktioniert. Dieser Code wurde nur von der urspr√ºnglichen Survival-Demo geerbt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass eine Komponente niemals direkt eine Navmesh Unity-Abh√§ngigkeit bereitstellt. </font><font style="vertical-align: inherit;">Die Entit√§tskomponente sollte, wie ich sp√§ter erl√§utern werde, immer Werttypen verf√ºgbar machen. </font><font style="vertical-align: inherit;">In diesem Fall k√∂nnen Sie mit dieser Regel auch den Code unter Kontrolle halten, da der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werttyp des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Felds </font><b><font style="vertical-align: inherit;">navMeshDestination</font></b><font style="vertical-align: inherit;"> sp√§ter ohne Verwendung von Unity Nav Mesh implementiert werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Absatz √ºber Motoren zu vervollst√§ndigen, beachten Sie, dass es keinen zu kleinen Motor gibt. </font><font style="vertical-align: inherit;">Haben Sie daher keine Angst davor, eine Engine zu schreiben, die mehrere Codezeilen enth√§lt, da Sie keine Logik an einer anderen Stelle schreiben k√∂nnen und Ihre Engines der Regel der einheitlichen Verantwortung folgen m√ºssen.</font></font><br><a name="Entity_Views"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entit√§tsdarstellungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir das Konzept der Engine und die abstrakte Definition der Essenz eingef√ºhrt. Lassen Sie uns nun definieren, was die Darstellung der Essenz ist. Ich muss zugeben, dass von den 5 Konzepten, auf denen Svelto.ECS basiert, Entity Views wahrscheinlich die verwirrendsten sind. Fr√ºher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node genannt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ein Name aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS Ash-Framework</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wurde mir klar, dass der Name ‚ÄûNode‚Äú nichts bedeutet. EntityView kann auch irref√ºhrend sein, da Programmierer Ansichten normalerweise einem Konzept zuordnen, das aus einer Vorlage stammt. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Model View Controller) Svelto.ECS verwendet jedoch View, da EntityView EntityView ist, wie die Engine Entity sieht. Ich beschreibe es gerne so, weil es am nat√ºrlichsten erscheint, aber ich k√∂nnte es auch EntityMap nennen, weil EntityView die Komponenten der Entit√§t anzeigt, auf die die Engine zugreifen soll. Dieses Schema der Svelto.ECS-Konzepte sollte ein wenig helfen: </font></font><br><br><img src="https://habrastorage.org/webt/b4/ph/ui/b4phuignfk8myvfpojldjsyxlkq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schlage vor, mit der Engine zu beginnen, und jetzt sind wir auf der rechten Seite dieses Schemas. Jede Engine verf√ºgt √ºber einen eigenen Satz von EntityViews. Die Engine kann EntityViews, die mit dem Namespace kompatibel sind, wiederverwenden, aber meistens definiert die Engine ihre EntityViews. Die Engine k√ºmmert sich nicht darum, ob die Player-Entit√§t wirklich definiert ist, sondern gibt an, dass sie </font><b><font style="vertical-align: inherit;">PlayerEntityView</font></b><font style="vertical-align: inherit;"> ben√∂tigt</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die Arbeit. </font><font style="vertical-align: inherit;">Das Schreiben des Codes h√§ngt von den Anforderungen der Engine ab. Sie sollten keine Entit√§t und ihr Feld erstellen, bevor Sie nicht verstanden haben, wie sie verwendet werden. </font><font style="vertical-align: inherit;">In einem komplexeren Szenario k√∂nnte der Name EntityView noch spezifischer sein. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise komplexe Engines schreiben </font><b><font style="vertical-align: inherit;">m√ºssten</font></b><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">um die Player-Logik zu handhaben und Player-Grafiken (oder Animationen usw.) zu rendern, k√∂nnten wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEntityView verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es k√∂nnen spezifischere Namen verwendet werden, z. B. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicJumpEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (usw.). </font></font><br><a name="Components"></a><br><h2>  Komponenten </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben festgestellt, dass Engines das Verhalten f√ºr eine Reihe von Entit√§tsdaten modellieren, und wir verstehen, dass Engines Entit√§ten nicht direkt verwenden, sondern Entit√§tskomponenten durch Darstellungen von Entit√§ten verwenden. Wir haben festgestellt, dass EntityView eine Klasse ist, die NUR √∂ffentliche Komponenten von Entit√§ten enthalten kann. Ich habe auch angedeutet, dass Entit√§tskomponenten immer Schnittstellen sind. Geben wir daher eine bessere Definition: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entit√§ten sind eine Sammlung von Daten, und Entit√§tskomponenten sind eine M√∂glichkeit, auf diese Daten zuzugreifen. Wenn Sie dies noch nicht bemerkt haben, ist das Definieren von Entit√§tskomponenten als Schnittstellen eine weitere ziemlich einzigartige Funktion von Svelto.ECS. In der Regel sind Komponenten in anderen Frameworks Objekte. Die Verwendung von Schnittstellen kann den Code erheblich reduzieren. Wenn Sie dem Prinzip folgen</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äû</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prinzip der Schnittstellentrennung‚Äú Nachdem Sie kleine Komponentenschnittstellen geschrieben haben, auch mit jeweils einer Eigenschaft, werden Sie feststellen, dass Sie begonnen haben, Komponentenschnittstellen innerhalb verschiedener Entit√§ten wiederzuverwenden. In unserem Beispiel wird ITransformComponent in vielen Entit√§tsdarstellungen wiederverwendet. Durch die Verwendung von Komponenten als Schnittstellen k√∂nnen sie auch dieselben Objekte implementieren. Dies vereinfacht in vielen F√§llen die Beziehung zwischen Entit√§ten, die dieselbe Entit√§t sehen, unter Verwendung unterschiedlicher Darstellungen von Entit√§ten (oder, falls m√∂glich, derselben). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher ist in Svelto.ECS die Entit√§tskomponente immer eine Schnittstelle, und diese Schnittstelle wird nur √ºber das Feld EntityView in der Engine verwendet. Die Entit√§tskomponentenschnittstelle wird dann von der sogenannten implementiert</font></font><b>¬´¬ª.      ,       .</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten sollten immer aussagekr√§ftige Typen speichern, und Felder sind immer Eigenschaften. Ausnahmen k√∂nnen nur gemacht werden, um Setter und Getter als Methoden zur Verwendung des Schl√ºsselworts ref zu schreiben, wenn eine Optimierung erforderlich ist. Dies bedeutet nicht, dass der Code datenorientiert ist, aber Sie k√∂nnen Code f√ºr Tests erstellen, da die Logik der Engine keine Verkn√ºpfungen zu externen Abh√§ngigkeiten verarbeiten sollte. Au√üerdem wird dadurch verhindert, dass Codierer das Framework betr√ºgen und √∂ffentliche Funktionen (einschlie√ülich Logik!) Von zuf√§lligen Objekten verwenden. Der einzige Grund, warum Sie das Bed√ºrfnis versp√ºren konnten, Links innerhalb der Schnittstellen von Entit√§tskomponenten zu verwenden, bestand darin, sich mit Abh√§ngigkeiten von Drittanbietern wie Unity-Objekten zu befassen. Das Survival-Beispiel zeigt jedoch, wie Sie damit umgehen k√∂nnen:Verlassen des Engine-Testcodes, ohne sich um Unity-Abh√§ngigkeiten k√ºmmern zu m√ºssen.</font></font><br><a name="Entity_Descriptors"></a><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier kommen Entity Descriptors zur Rettung, um alles zusammenzusetzen. Wir wissen, dass Engines √ºber Komponenten, die in Entit√§tsansichten gespeichert sind, auf Entit√§tsdaten zugreifen k√∂nnen. Wir wissen, dass Engines Klassen sind, EntityView Klassen, die nur Komponentenentit√§ten enthalten, und dass Komponenten Schnittstellen sind. Obwohl ich eine abstrakte Definition der Essenz gegeben habe, haben wir keine einzige Klasse gesehen, die tats√§chlich die Essenz darstellt. Dies entspricht dem Konzept von Objekten, die Identifikatoren innerhalb des modernen ECS-Systems sind. Ohne die korrekte Definition von Entit√§ten werden die Codierer jedoch gezwungen, Entit√§ten mit Repr√§sentationen von Entit√§ten zu identifizieren, was katastrophal falsch w√§re. Die Darstellung von Entit√§ten ist die Art und Weise, wie mehrere Engines dieselbe Entit√§t sehen k√∂nnen.aber sie sind keine Entit√§ten. Die Entit√§t selbst sollte immer als ein Datensatz betrachtet werden, der durch die Komponenten der Entit√§t definiert wird, aber selbst dies ist eine schwache Definition. Eine EntityDescriptor-Instanz erm√∂glicht es dem Encoder, seine Entit√§ten korrekt zu bestimmen, unabh√§ngig von den Engines, die sie verarbeiten. Daher ben√∂tigen wir im Fall von Entity Player</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Klasse wird zum Erstellen von Entit√§ten verwendet, und obwohl das, was sie wirklich tut, etwas v√∂llig anderes ist, </font><font style="vertical-align: inherit;">hilft </font><font style="vertical-align: inherit;">die Tatsache, dass der Benutzer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity &lt;PlayerEntityDescriptor&gt; ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben kann, </font><font style="vertical-align: inherit;">sehr einfach, Entit√§ten zum </font><b><font style="vertical-align: inherit;">Erstellen</font></b><font style="vertical-align: inherit;"> und Kommunizieren von Absichten f√ºr andere zu visualisieren. Encoder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was EntityDescriptor jedoch wirklich tut, ist eine EntityViews-Liste zu erstellen !!! In den fr√ºhen Phasen der Entwicklung des Frameworks erlaubte ich Codierern, diese EntityViews-Liste manuell zu erstellen, was zu sehr h√§sslichem Code f√ºhrte, da nicht mehr visualisiert werden konnte, was tats√§chlich geschah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So sieht </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Camera; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.HUD; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Enemies; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Sound; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Svelto.ECS.Example.Survive.Player</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerEntityDescriptor</span></span> : <span class="hljs-title"><span class="hljs-title">GenericEntityDescriptor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">HUDDamageEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">PlayerEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">EnemyTargetEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">DamageSoundEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">HealthEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">CameraTargetEntityView</span></span>&gt; { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entit√§tsdeskriptoren (und Implementierer) sind die einzigen Klassen, die Bezeichner aus mehreren Namespaces verwenden k√∂nnen. </font><font style="vertical-align: inherit;">In diesem Fall </font><font style="vertical-align: inherit;">definiert </font><font style="vertical-align: inherit;">der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Liste von EntityViews, die beim Erstellen der PlayerEntity instanziiert und in die Engine eingef√ºgt werden sollen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EntityDescriptorHolder </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntityDescriptorHolder ist eine Erweiterung f√ºr Unity und sollte nur in bestimmten F√§llen verwendet werden. Am h√§ufigsten wird eine Art Polymorphismus erstellt, in dem Informationen zu Entit√§ten zum Erstellen eines Unity GameObject gespeichert werden. Somit kann derselbe Code verwendet werden, um mehrere Arten von Entit√§ten zu erstellen. Bei Robocraft verwenden wir beispielsweise eine einzelne W√ºrfelfabrik, in der alle W√ºrfel hergestellt werden, aus denen die Maschinen bestehen. Der W√ºrfeltyp f√ºr die Montage wird im Fertighaus des W√ºrfels selbst gespeichert. Dies ist gut, solange die Implementierer zwischen den Cubes oder in GameObject dieselben sind wie die von MonoBehaviour. Das direkte Erstellen von Entit√§ten ist vorzuziehen. Verwenden Sie EntityDescriptorHolders daher nur, wenn Sie die Prinzipien von Svelto.ECS richtig verstanden haben. Andernfalls besteht die Gefahr eines Missbrauchs. Diese Funktion aus dem Beispiel zeigt, wie die Klasse verwendet wird:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildEntitiesFromScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnityContext contextHolder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//EntityDescriptorHolder -    Svelto.ECS , //       . //         . //      , //    //     IEntityDescriptorHolder[] entities = contextHolder.GetComponentsInChildren&lt;IEntityDescriptorHolder&gt;(); //     Svelto.ECS, ,   //      . //        . //    EntityDescriptorHolder, //    for (int i = 0; i &lt; entities.Length; i++) { var entityDescriptorHolder = entities[i]; var entityDescriptor = entityDescriptorHolder.RetrieveDescriptor(); _entityFactory.BuildEntity (((MonoBehaviour) entityDescriptorHolder).gameObject.GetInstanceID(), entityDescriptor, (entityDescriptorHolder as MonoBehaviour).GetComponentsInChildren&lt;IImplementor&gt;()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass ich in diesem Beispiel eine weniger bevorzugte, nicht generische </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion verwende </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich werde das erkl√§ren. </font><font style="vertical-align: inherit;">In diesem Fall sind die Implementierer die MonoBehaviour-Klassen, die an das GameObject angeh√§ngt sind. </font><font style="vertical-align: inherit;">Dies ist keine gute Praxis. </font><font style="vertical-align: inherit;">Ich h√§tte diesen Code aus dem Beispiel entfernen sollen, bin aber gegangen, um Ihnen diesen Sonderfall zu zeigen. </font><font style="vertical-align: inherit;">Implementierer sollten, wie wir sp√§ter sehen werden, nur bei Bedarf MonoBehaviours-Klassen sein!</font></font><br><a name="Implementors"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Impulatoren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir unsere Essenz erstellen, definieren wir das letzte Konzept in Svelto.ECS, n√§mlich den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impaler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wie wir wissen, sind Entit√§tskomponenten immer Schnittstellen, und C # -Schnittstellen m√ºssen implementiert werden. </font><font style="vertical-align: inherit;">Ein Objekt, das diese Schnittstellen implementiert, wird als "Implementierer" bezeichnet. </font><font style="vertical-align: inherit;">Implementierer haben mehrere wichtige Merkmale:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die M√∂glichkeit, die Anzahl der zusammenzusetzenden Objekte von der Anzahl der Entit√§tskomponenten zu trennen, die zur Bestimmung der Entit√§tsdaten erforderlich sind. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die M√∂glichkeit, Daten zwischen verschiedenen Komponenten auszutauschen, da Komponenten Daten √ºber Eigenschaften bereitstellen, k√∂nnen verschiedene Eigenschaften einer Komponente dasselbe Implementierungsfeld zur√ºckgeben. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂glichkeit zum Erstellen einer Stub-Entit√§t f√ºr Schnittstellenkomponenten. </font><font style="vertical-align: inherit;">Dies ist wichtig, um den Motorcode testen zu lassen.</font></font><br></li><li>      Svelto.ECS   (third party) .     .    Unity,    ,       ,      <b>Monobehaviour</b> .  ,        Unity,   <b>OnTriggerEnter</b> / <b>OnTriggerExit</b> ,         Unity.        ,      .  : <br></li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyTriggerImplementor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IImplementor</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTriggerComponent</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTargetComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; entityInRange; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTriggerComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _targetInRange = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTargetComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _targetInRange; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerExit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _targetInRange; }</code> </pre><br> <i>,    ,        .    ,     .</i> <br><a name="Build_Entity"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entit√§tserstellung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, wir haben unsere </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Engines erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sie zu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnginesRoot</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzugef√ºgt und </font><font style="vertical-align: inherit;">ihre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entit√§tsansichten erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , f√ºr die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Schnittstellen </font><font style="vertical-align: inherit;">erforderlich </font><font style="vertical-align: inherit;">sind, die in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierern implementiert werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist Zeit, unsere erste Essenz zu erschaffen. </font><font style="vertical-align: inherit;">Eine Entit√§t wird immer √ºber eine Instanz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Factory erstellt, die von EnginesRoot √ºber die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GenerateEntityFactory-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion erstellt wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Gegensatz zu einer EnginesRoot-Instanz kann eine IEntityFactory-Instanz bereitgestellt und √ºbertragen werden. </font><font style="vertical-align: inherit;">Objekte k√∂nnen innerhalb des Kompositionsstamms oder dynamisch innerhalb der Fabriken erstellt werden. In letzterem Fall m√ºssen Sie eine IEntityFactory √ºber einen Parameter √ºbergeben.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEntityFactory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet mehrere √§hnliche Funktionen. In diesem Artikel werde ich die Erkl√§rung Funktionen √ºberspringen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreallocateEntitySlots</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildMetaEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auf die am h√§ufigsten verwendeten Funktionen zu konzentrieren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist am besten, immer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup zu verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber f√ºr das Survival-Beispiel ist dies nicht erforderlich. </font><b><font style="vertical-align: inherit;">Sehen</font></b><font style="vertical-align: inherit;"> wir uns also an, wie die √ºbliche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Beispiel verwendet wird:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntervaledTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  :       //MonoBehaviour    . //       //   . // ,     , //         . //        ,     . //  ,        //   , //  .      , // ,   ,   . var enemiestoSpawn = ReadEnemySpawningDataServiceRequest(); while (true) { //Svelto.Tasks    yield  Unity, //    . //       . // ,  , //    . yield return _waitForSecondsEnumerator; if (enemiestoSpawn != null) { for (int i = enemiestoSpawn.Length - 1; i &gt;= 0 &amp;&amp; _numberOfEnemyToSpawn &gt; 0; --i) { var spawnData = enemiestoSpawn[i]; if (spawnData.timeLeft &lt;= 0.0f) { //          int spawnPointIndex = Random.Range(0, spawnData.spawnPoints.Length); //       . var go = _gameobjectFactory.Build(spawnData.enemyPrefab); //        MonoBehaviour. //      . var data = go.GetComponent&lt;EnemyAttackDataHolder&gt;(); //     MonoBehaviour   // : List&lt;IImplementor&gt; implementors = new List&lt;IImplementor&gt;(); go.GetComponentsInChildren(implementors); implementors.Add(new EnemyAttackImplementor(data.timeBetweenAttacks, data.attackDamage)); //         EntityViews, //     EntityDescriptor. //,       EntityView //  ,     ,  EntityDescriptorHolder //       , //    . _entityFactory.BuildEntity&lt;EnemyEntityDescriptor&gt;( go.GetInstanceID(), implementors.ToArray()); var transform = go.transform; var spawnInfo = spawnData.spawnPoints[spawnPointIndex]; transform.position = spawnInfo.position; transform.rotation = spawnInfo.rotation; spawnData.timeLeft = spawnData.spawnTime; numberOfEnemyToSpawn--; } spawnData.timeLeft -= 1.0f; } } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, alle Kommentare in diesem Beispiel zu lesen, damit Sie die Konzepte von Svelto.ECS besser verstehen. Aufgrund der Einfachheit des Beispiels verwende ich nicht die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die in komplexeren Projekten verwendet wird. In Robocraft verarbeitet jede Engine, die die Logik von Funktionsw√ºrfeln verarbeitet, die Logik ALLER Funktionsw√ºrfel dieses bestimmten Typs im Spiel. Es ist jedoch h√§ufig erforderlich zu wissen, zu welchem ‚Äã‚ÄãFahrzeug die W√ºrfel geh√∂ren. Wenn Sie also f√ºr jede Maschine eine Gruppe verwenden, k√∂nnen Sie die W√ºrfel desselben Typs in Maschinen aufteilen, wobei die Maschinen-ID die Gruppen-ID ist. Auf diese Weise k√∂nnen wir coole Dinge implementieren, z. B. das Ausf√ºhren einer Svelto.Tasks-Aufgabe auf einem Computer innerhalb derselben Engine, die mithilfe von Multithreading parallel arbeiten kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code zeigt ein wichtiges Problem, das ich in den folgenden Artikeln ausf√ºhrlicher behandeln werde ... aus dem Kommentar (falls Sie ihn nicht gelesen haben): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie niemals MonoBehaviour-Imprementoren nur zur Datenspeicherung. Daten sollten unabh√§ngig von der Datenquelle immer √ºber die Service-Schicht abgerufen werden. Die Vorteile sind zahlreich, einschlie√ülich der Tatsache, dass Sie zum √Ñndern der Datenquelle nur den Servicecode √§ndern m√ºssen. In diesem einfachen Beispiel verwende ich nicht die Service-Schicht, aber im Allgemeinen ist die Idee klar. Beachten Sie auch, dass ich Daten f√ºr jeden Anwendungsstart au√üerhalb der Hauptschleife nur einmal hochlade. Sie k√∂nnen diesen Trick immer verwenden, wenn die ben√∂tigten Daten nie ge√§ndert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs habe ich Daten direkt von MonoBehaviour gelesen, wie es ein guter Lazy Encoder tun w√ºrde. </font><font style="vertical-align: inherit;">Dadurch habe ich einen schreibgesch√ºtzten MonoBehaviore-Serializer-Implementierer erstellt. </font><font style="vertical-align: inherit;">Dies ist akzeptabel, wenn wir die Datenquelle nicht abstrahieren m√∂chten. Es ist jedoch viel besser, die Informationen in eine JSON-Datei zu serialisieren und auf Anfrage an den Dienst zu lesen, als diese Daten aus der Entit√§tskomponente zu lesen.</font></font><br><a name="Communication"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kommunikation bei Svelto.ECS </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Problem, dessen L√∂sung durch keine ECS-Implementierung standardisiert wurde, ist die Kommunikation zwischen Systemen. </font><font style="vertical-align: inherit;">Dies ist ein weiterer Ort, an dem ich viel nachgedacht habe, und Svelto.ECS l√∂st es auf zwei neue Arten. </font><font style="vertical-align: inherit;">Die dritte M√∂glichkeit besteht darin, das Standardmuster "Beobachter / Beobachtet" zu verwenden, das in sehr spezifischen und spezifischen F√§llen akzeptabel ist.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DispatchOnSet / DispatchOnChange </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir gesehen, wie Engines mithilfe von Data Polling Daten √ºber Entity Components austauschen k√∂nnen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind die einzigen Referenzen (nicht signifikante Typen), die von den Eigenschaften von Entit√§tskomponenten zur√ºckgegeben werden k√∂nnen, aber der Typ des generischen Parameters T muss ein aussagekr√§ftiger Typ sein. Die Namen der Funktionen klingen wie ein Ereignis-Dispatcher, sollten jedoch als Methoden zum Pushen der Daten betrachtet werden, im Gegensatz zu Datenabfragen, die ein bisschen wie Datenbindung sind. Das ist alles, manchmal ist das Abrufen von Daten unpraktisch. Wir m√∂chten nicht in jedem Frame eine Variable abfragen, wenn wir wissen, dass sich Daten selten √§ndern. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht gestartet werden, ohne die Daten zu √§ndern. Dies erm√∂glicht es uns, sie als Datenbindungsmechanismus anstelle eines regul√§ren Ereignisses zu betrachten. </font><font style="vertical-align: inherit;">Es gibt auch keine Startfunktion zum Aufrufen. Stattdessen muss der Wert der von diesen Klassen gehaltenen Daten festgelegt oder ge√§ndert werden. </font><font style="vertical-align: inherit;">Im Survival - </font><font style="vertical-align: inherit;">Code keine gro√üen Beispielen, aber man kann sehen , </font><font style="vertical-align: inherit;">wie ein boolean Feld </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">targetHit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGunHitTargetComponent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Unterschied zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besteht darin, dass letzteres das Ereignis nur </font><b><font style="vertical-align: inherit;">ausl√∂st</font></b><font style="vertical-align: inherit;"> , wenn sich die Daten tats√§chlich √§ndern, und erstere immer.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sequenzer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideale Engines sind vollst√§ndig gekapselt, und Sie k√∂nnen die Logik dieser Engine als Folge von Anweisungen mit Svelto.Tasks und IEnumerators schreiben. Dies ist jedoch nicht immer m√∂glich, da Engines in einigen F√§llen Ereignisse an andere Engines senden m√ºssen. Dies erfolgt normalerweise √ºber Entit√§tsdaten, insbesondere mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im Fall von Entit√§ten, die im Beispiel ‚Äûbesch√§digt‚Äú sind, wirkt jedoch eine Reihe unabh√§ngiger und nicht verwandter Motoren darauf ein. </font><font style="vertical-align: inherit;">In anderen F√§llen m√∂chten Sie, dass die Reihenfolge in der Reihenfolge, in der die Motoren aufgerufen wurden, streng ist, wie in dem Beispiel, in dem der Tod f√ºr letztere immer eintreten soll. </font><font style="vertical-align: inherit;">In diesem Fall ist die Sequenz nicht nur sehr einfach zu bedienen, sondern auch sehr praktisch! </font><font style="vertical-align: inherit;">Sequenz-Refactoring ist sehr einfach. </font><font style="vertical-align: inherit;">Verwenden Sie daher IEnumerator Svelto-Aufgaben f√ºr "vertikale" Engines und Sequenzen f√ºr "horizontale" Logik zwischen Engines.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beobachter / Beobachtet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe die M√∂glichkeit verlassen, dieses Muster speziell f√ºr F√§lle zu verwenden, in denen Legacy-Code oder Code, der Svelto.ECS nicht verwendet, mit den Svelto.ECS-Engines interagieren sollte. </font><font style="vertical-align: inherit;">In anderen F√§llen sollte es mit √§u√üerster Vorsicht verwendet werden, da die M√∂glichkeit eines Missbrauchs des Musters besteht, da es den meisten Codierern, die neu in Svelto.ECS sind, bekannt ist und Sequenzer normalerweise die beste Wahl sind.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413107/">https://habr.com/ru/post/de413107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413097/index.html">Basierend auf Software auf Unternehmensebene, millionenfach getestet: openSUSE Leap 15 ver√∂ffentlicht</a></li>
<li><a href="../de413099/index.html">Downclocking RAM auf MacBook</a></li>
<li><a href="../de413101/index.html">STM32F4 Debug Board im Raspberry Pi Formfaktor</a></li>
<li><a href="../de413103/index.html">3CX v15.5 Update 5 Beta und REST-Integration mit AmoCRM ver√∂ffentlicht</a></li>
<li><a href="../de413105/index.html">Hinweise des IoT-Anbieters. Aktivierung und Sicherheit in LoraWAN</a></li>
<li><a href="../de413109/index.html">So erstellen Sie eine SaaS-Produktintegrationsplattform: Poster Cloud Checkout Experience</a></li>
<li><a href="../de413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../de413113/index.html">Klasse JavaScript Unterst√ºtzung der JavaScript-Serialisierung</a></li>
<li><a href="../de413117/index.html">So programmieren Sie sicher in Bash</a></li>
<li><a href="../de413119/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 317 (28. Mai - 3. Juni 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>