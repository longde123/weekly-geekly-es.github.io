<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’†ğŸ¾ ğŸ‘†ğŸ¼ ğŸ“¶ Analisis suara untuk pusat panggilan berbasis SOLR ğŸ†• ğŸ· ğŸ‘†ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin berbicara tentang pengalaman kami dalam mengembangkan aplikasi berdasarkan platform pencarian teks lengkap Apache Solr. 

 Tugas kami adala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis suara untuk pusat panggilan berbasis SOLR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/speechpro/blog/429590/">  Saya ingin berbicara tentang pengalaman kami dalam mengembangkan aplikasi berdasarkan platform pencarian teks lengkap Apache Solr. <br><br>  Tugas kami adalah mengembangkan sistem analisis wicara untuk pusat kontak.  Sistem ini didasarkan pada dua teknologi dasar: pengenalan ucapan dan pencarian yang diindeks.  Untuk pengakuan, kami menggunakan mesin kami, dan untuk pengindeksan dan pencarian, kami memilih Solr. <br><br>  Mengapa solr?  Kami tidak melakukan penelitian komparatif kami sendiri tentang mesin pencari yang diindeks, tetapi dengan cermat memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendapat rekan-rekan kami</a> .  Tentu saja, pilihan dapat dibuat untuk mendukung Elasticsearch atau Sphinx, tetapi, tampaknya, bintang-bintang di proyek kami dibentuk untuk Solr, kami â€œmenggergajiâ€ nya.  Sudah selama proyek berlangsung, kami menentukan bahwa pengaturan yang tersedia di Solr sudah cukup untuk dikonfigurasikan untuk tugas-tugas kami. <br><a name="habracut"></a><br><h3>  Fitur proyek kami </h3><br>  Sistem ini dikembangkan untuk analitik panggilan pelanggan, yang dicatat di pusat kontak untuk memantau kualitas layanan.  Itu tidak menganalisis suara, tetapi teks diperoleh sebagai hasil dari pengakuan otomatis dialog.  Teks-teks pidato yang diakui pada dasarnya berbeda dari teks-teks yang kita temui secara teratur di situs web atau email.  Bahkan dengan akurasi pengenalan 100%, teks pidato spontan yang dikenali tampaknya tidak memiliki makna. <br><br>  Ini karena dua faktor utama.  Pertama, dalam pidato lisan, ekspresi nonverbal dan wajah sangat sering digunakan, yang tidak dikenali dalam teks, tetapi penting untuk memahami apa yang telah dikatakan.  Kedua, dalam pidato, singkatan dan penghilangan struktur bahasa terus digunakan, yang dapat dipulihkan dari konteks situasi komunikatif.  Fenomena dalam linguistik ini disebut elipsis. <br><br>  Untuk melihat dengan mata Anda sendiri teks pidato yang dikenal dengan semua fitur-fiturnya, lihat subtitle otomatis untuk video di youtube dengan suara dimatikan.  Itu tentang konten ini, materi masuk ke input dari sistem analitik ucapan. <br><br><h3>  Pertanyaan yang rumit </h3><br>  Meskipun Solr mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pernyataan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengelompokan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bersyarat</a> standar, seringkali kemampuan ini tidak cukup untuk menerapkan semua skenario untuk analis. <br><br>  Seringkali, analis perlu membangun kueri dengan parameter yang tidak termasuk dalam indeks Solr.  Misalnya, temukan semua kata "terima kasih" yang diucapkan dalam 30 detik terakhir percakapan.  Kata-kata diindeks oleh Solr, tetapi tidak ada posisi kata sementara.  Kami menyebut kueri semacam itu "kompleks" - kueri yang menyertakan parameter indeks Solr dan parameter pemilihan data lainnya yang tidak termasuk dalam indeks Solr. <br><br><h3>  Bagaimana seorang analis membentuk pertanyaan? </h3><br>  Analis tidak memiliki gagasan tentang komposisi indeks Solr, penting baginya untuk mencari dan memotong semua atribut phonogram panggilan dan transkrip teks mereka.  Oleh karena itu, konsep "query kompleks" untuk analis adalah murni pragmatis: kueri di mana ada banyak parameter pemilihan, atau kueri diatur dalam hierarki. <br><br>  Menggambarkan tindakan analis dalam bahasa teori himpunan, kita dapat mengatakan bahwa dengan bantuan pertanyaan, analis mengeksplorasi hubungan antara himpunan bagian yang berbeda: persimpangan, perbedaan, penambahan.  Menggunakan kueri hierarkis, analis mem-parsing array data ke tingkat detail struktur yang diperlukan. <br><br><img src="https://habrastorage.org/webt/9r/ts/cy/9rtscyivdzpyd30v4i3yomz2bt4.png"><br>  <i>Gambar 1. Permintaan hierarkis</i> <br><br>  Gambar 2 menunjukkan contoh klasik dari query kompleks yang mengandung kriteria seleksi tekstual dan numerik. <br><br><img src="https://habrastorage.org/webt/e1/_o/_x/e1_o_xjd89bemvnaot6i4av9wly.png"><br>  <i>Gambar 2. Permintaan kompleks yang berisi parameter pemilihan data kuantitatif dan leksikal</i> <br><br><h3>  Seperti apa bentuk query untuk Solr? </h3><br>  Pertimbangkan mekanisme umum untuk mengeksekusi kueri dalam Solr menggunakan contoh kueri <b>B</b> pada Gambar 1. Seperti yang dapat kita lihat, kueri <b>B</b> memiliki kueri induk <b>A</b> , dengan kata lain <b>BâŠ†A</b> .  Dalam analitik ucapan, permintaan tidak dapat dipenuhi sementara setidaknya satu dari "orang tuanya" tidak terpenuhi.  Dengan demikian, kueri <b>A</b> dieksekusi terlebih dahulu, dan hanya kemudian <b>B.</b>  Jelas, <b>B</b> harus mengandung kondisi permintaan <b>A.</b> <br><br>  Hal pertama yang terlintas dalam pikiran adalah menggabungkan kondisi kedua kueri melalui <code>AND</code> dan menempelkannya ke <code>query</code> : <br><br> <code>q=key:A AND key:B</code> <br> <br>  Namun, jika kami hanya menggabungkan semua kueri berturut-turut ke dalam satu <code>query</code> , itu akan menjadi besar, itu akan berbeda untuk setiap kueri dan itu akan dihitung secara keseluruhan.  Juga, kondisi <b>A</b> akan mempengaruhi relevansi hasil permintaan <b>B</b> , yang tidak diinginkan. <br><br>  Mari kita coba menambahkan kueri induk sebagai <code>FilterQuery</code> .  Dalam hal ini, kueri <b>A</b> tidak akan terpengaruh oleh ketidak relevansi dan kami dapat berharap bahwa itu telah selesai dan hasilnya ada di cache.  Dengan demikian, Solr harus menghitung hanya permintaan <b>B</b> , sementara Solr akan mengurutkan pilihan yang dihasilkan dengan cara yang kita butuhkan: <br><br> <code>q=keyword:B &amp;fq=keyword:A</code> <br> <br>  Jika kami mempertimbangkan format permintaan untuk Solr secara skematis, kami dapat membedakan dua entitas utama: <br><br><ol><li>  <code>MainQuery</code> - kueri utama dengan serangkaian parameter yang harus dipenuhi oleh dokumen.  Misalnya, permintaan pencarian untuk operator yang sopan akan terlihat seperti ini: <code>text_operator: â€ â€</code> . <br>  Ini berarti bidang text_operator pada dokumen pencarian harus mengandung frasa <code>â€œ â€</code> <br></li><li>  <code>FilterQuery</code> - satu set filter tambahan yang membatasi pilihan yang dihasilkan.  Format <code>MainQuery</code> cocok dengan <code>MainQuery</code> <br></li></ol><br>  Memisahkan permintaan menjadi <code>Main</code> dan <code>Filter</code> memungkinkan Anda untuk: <br><br><ol><li>  secara eksplisit menunjukkan parameter kueri mana yang harus memengaruhi peringkat dokumen dalam pemilihan, dan yang hanya berfungsi untuk pemilihan dalam pemilihan yang dihasilkan.  Relevansi untuk membangun peringkat dokumen dihitung ketika bagian dari permintaan MainQuery dieksekusi, dan ketika bagian dari permintaan <code>FilterQuery</code> dokumen yang tidak memenuhi kondisi permintaan </li><li>  secara signifikan mengurangi beban di mesin pencari, karena sampel yang dihasilkan diperoleh setelah perhitungan <code>FilterQuery</code> -cache sepenuhnya, sedangkan hasil perhitungan <code>MainQuery</code> disimpan dalam cache hanya untuk yang pertama di peringkat 50 nilai </li></ol><br>  <code>MainQuery</code> dan <code>FiletrQuery</code> memiliki efek berbeda pada fungsi Solr.  Misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyorotan</a> , fungsi yang bertanggung jawab untuk menyoroti fragmen dokumen yang relevan, hanya <code>MainQuery</code> , dan parameter <code>FilterQuery</code> tidak memengaruhi <code>highlighting</code> .  Ini logis, karena relevansi dihitung tepat di bagian permintaan <code>MainQuery</code> .  Beginilah hasil yang terlihat seperti pencarian nyata teks dengan kata-kata "halo" dan "layanan". <br><br><img src="https://habrastorage.org/webt/95/h5/py/95h5py4psgllol-p6tqa3vkhkhc.png"><br>  <i>Gambar 3. Menyorot kata-kata yang relevan setelah menyelesaikan permintaan <code>MainQuery</code> .</i> <i><br></i> <br><h3>  Kueri yang rumit di Solr </h3><br>  Mari kita kembali ke contoh operator yang sopan.  Dalam contoh ini, kami menentukan panggilan yang sesuai dengan kehadiran frasa "selamat siang" dalam pidato operator, tetapi tidak menunjukkan interval waktu untuk mencari kata kunci relatif terhadap awal atau akhir percakapan. <br><br>  Tampaknya ada semua yang diperlukan untuk ini - transkrip teks percakapan telepon berisi stempel waktu untuk setiap kata, serta informasi tentang siapa dari peserta dalam dialog yang dimilikinya.  Data ini juga dapat digunakan dalam pencarian. <br><br><img src="https://habrastorage.org/webt/tw/wp/sh/twwpsh4y4ahynhwptbjkycefpwa.png"><br>  <i>Gambar 4. Sebuah fragmen dekripsi tekstual dengan markup yang tidak termasuk dalam indeks Solr: afiliasi pembicara, cap waktu.</i> <br><br>  Tetapi bagaimana cara memproses permintaan pencarian untuk Solr, jika parameter yang tidak dapat diindeks terlibat dalam permintaan - waktu kata diucapkan? <br><br>  Dua cara yang jelas untuk mengatasi masalah ini muncul: <br><br><ol><li>  tambahkan parameter yang tidak diindeks ke indeks Solr.  Pada saat yang sama, konsumsi memori akan sedikit meningkat, tetapi indeks akan secara signifikan lebih berat </li><li>  pemilihan data berdasarkan parameter yang tidak dapat diindekskan harus dilakukan dengan menggunakan layanannya, dan dalam pengumpulan dokumen yang diperoleh setelah pemilihan tersebut, cari menggunakan indeks Solr.  Pada saat yang sama, konsumsi memori akan secara signifikan lebih besar daripada dalam kasus pertama, tetapi kinerjanya akan dapat diprediksi </li></ol><br>  Kami telah memilih opsi kedua.  Untuk melakukan ini, kami telah mengembangkan layanan yang menghitung koleksi berdasarkan permintaan yang berisi parameter logis dan numerik apa pun yang tidak termasuk dalam indeks Solr.  Sebagai hasil karya layanan ini, bagian dari koleksi yang tidak memenuhi permintaan ditandai dengan tag khusus ("lolos") dan kemudian tidak berpartisipasi dalam perhitungan hasil permintaan. <br><br>  Bayangkan kita ingin memaksakan pembatasan pencarian pada query <b>B</b> yang sudah kita ketahui, hanya dalam 30 detik pertama dialog.  Pada tahap pertama, kita mengeksekusi <b>B</b> sebagai kueri sederhana, lalu "menyaring" kata-kata yang melampaui rentang yang dipilih sehingga mereka tidak jatuh ke dalam indeks Solr, tetapi pada saat yang sama, kita dapat mengembalikan dokumen asli dari mereka.  Dokumen yang dihasilkan ditempatkan dalam koleksi Solr terpisah dan pencarian untuk permintaan <b>B</b> dimulai kembali di atasnya. <br><br>  Di sini saya harus mengatakan bahwa pembatasan pada awal atau akhir percakapan adalah bunga, beri adalah pembatasan pada hasil permintaan orang tua.  Pertimbangkan eksekusi permintaan seperti itu. <br><table><tbody><tr><td>  Bayangkan dokumen kita terdiri dari bola-bola dengan angka.  Mari kita coba menemukan semua bola "6" yang terletak tidak lebih dari dua bola di sebelah kanan "5". <br>  Anda sudah menyadari bahwa nomor bola termasuk dalam indeks Solr, dan tidak ada jarak antara bola. <br></td><td width="220"><img src="https://habrastorage.org/webt/vg/qk/b9/vgqkb9zlunaa4_uqh25u3qhdzio.png"></td></tr><tr><td>  Temukan semua dokumen dengan bola "6" dan "5".  Sebagai <code>MainQuery</code> menggunakan kueri untuk bola "5", dan kueri untuk "6" kami akan kirim ke <code>FilterQuery</code> .  Sebagai hasilnya, Solr akan menyoroti bola "5" di hasil pencarian, yang akan sangat menyederhanakan hidup kita di langkah selanjutnya. </td><td><img src="https://habrastorage.org/webt/vg/yu/d1/vgyud1tpttqcanutybl81rccj40.png"></td></tr><tr><td>  Kami menyaring semua bola kecuali yang berada pada jarak yang diinginkan dari "5".  Dokumen yang diterima (dokumen dengan bola yang diinginkan) akan ditempatkan dalam koleksi terpisah. </td><td><img src="https://habrastorage.org/webt/s3/z3/ug/s3z3ugwju6mnzxphfsfaavgrkic.png"></td></tr><tr><td>  Mari kita jalankan <code>FilterQuery</code> pada bola "6" di koleksi yang dihasilkan, hasilnya adalah dokumen yang kita <code>FilterQuery</code> . </td><td><img src="https://habrastorage.org/webt/ie/nr/de/ienrdekwhhbhjfvrw8jkhg8awna.png"></td></tr></tbody></table><br>  Dalam praktiknya, bola 5 dan 6 biasanya menyembunyikan kueri yang menempati beberapa layar dalam representasi tekstualnya.  Saya senang kami menerapkan pencarian ini tidak sia-sia - analis sering menggunakan pertanyaan dengan batasan dari orang tua. <br><br><h3>  Kesimpulan </h3><br>  Apa yang kami pelajari, apa yang kami pelajari dan apa yang kami capai sebagai hasil dari proyek ini? <br><br>  Kami tahu cara menggunakan Solr secara efektif untuk bekerja dengan data dari berbagai jenis, kami dapat "mengajarkan" Solr untuk memproses permintaan dengan parameter yang tidak termasuk dalam indeks pencariannya. <br><br>  Kami telah mengembangkan sistem analisis suara industri yang beroperasi di bawah beban tinggi: permintaan pencarian yang kompleks dari para analis dihitung untuk sampel hingga lima juta dokumen teks.  Itu mungkin dan lebih, tetapi tidak ada kebutuhan praktis.  Sampel analis yang biasa digunakan adalah hingga sekitar 500 ribu teks panggilan telepon yang dikenali, dan jumlah total panggilan dapat mencapai 15 juta. <br><br>  Untuk pelanggan kami di pusat kontak, sistem memberikan peluang yang belum pernah terjadi sebelumnya untuk analisis yang sangat berbeda: analisis topik dan alasan permintaan, analisis kepuasan pelanggan, dan banyak lainnya. <br><br>  Sekarang kami menghubungkan sumber baru ke analitik kami - obrolan teks pelanggan dengan operator.  Kami menerapkan satu aplikasi untuk analitik panggilan klien di semua saluran pusat kontak: telepon, obrolan, formulir di situs, dll. <br><br>  Kami akan dengan senang hati menjawab pertanyaan Anda. <br><br>  Terima kasih <br><br>  PS Solr adalah hal yang sangat sulit dan membutuhkan penyetelan yang baik untuk mendapatkan hasil yang baik.  Kami akan menceritakan tentang pengalaman kami di bidang ini dalam artikel berikut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429590/">https://habr.com/ru/post/id429590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429578/index.html">Kesalahan apa yang disembunyikan dalam kode Infer.NET?</a></li>
<li><a href="../id429580/index.html">Interaksi mikro di iOS. Kuliah Yandex</a></li>
<li><a href="../id429582/index.html">Indikator analog beban komputer</a></li>
<li><a href="../id429586/index.html">Cara menentukan waktu terbaik untuk berdagang di bursa</a></li>
<li><a href="../id429588/index.html">Seluruh kebenaran tentang RTOS. Artikel # 20. Semaphores: Layanan Tambahan dan Struktur Data</a></li>
<li><a href="../id429592/index.html">Bagaimana kartu bank mempengaruhi ekonomi dan mengapa bola cue tidak lepas landas</a></li>
<li><a href="../id429594/index.html">Analisis kecepatan mikromotor molekuler untuk diagnosis HIV</a></li>
<li><a href="../id429596/index.html">Apa yang perlu Anda lakukan di Jawa untuk sepenuhnya mendukung pembelajaran mesin</a></li>
<li><a href="../id429598/index.html">Inventarisasi UHF RFID. Bagaimana cara menemukan semua tag?</a></li>
<li><a href="../id429600/index.html">Kilau dan kemiskinan 1C untuk toko online. Bersinar emas untuk pewaralaba dan kemiskinan fungsionalitas bagi pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>