<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 🧚🏿 😪 Kapselung in C ++ und C. 🏴 👨‍👨‍👦‍👦 🖖🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Definition 


 Die Kapselung ist eine Reihe von Tools zur Steuerung des Zugriffs auf Daten oder Methoden, die diese Daten verwalten. Eine detaillierte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kapselung in C ++ und C.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444602/"><p><img src="https://habrastorage.org/webt/uq/da/c9/uqdac9e3znu_dgoypeekipj7so8.png"></p><br><h1 id="opredelenie">  Definition </h1><br><p>  Die Kapselung ist eine Reihe von Tools zur Steuerung des Zugriffs auf Daten oder Methoden, die diese Daten verwalten.  Eine detaillierte Definition des Begriffs „Einkapselung“ finden Sie in meiner vorherigen Veröffentlichung auf dem Habré unter diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> .  Dieser Artikel konzentriert sich auf Kapselungsbeispiele in C ++ und C. </p><br><h1 id="inkapsulyaciya-v-si">  Kapselung in C ++ </h1><br><p> Standardmäßig sind in einer Klasse ( <code>class</code> ) Daten und Methoden privat ( <code>private</code> ).  Sie können nur von der Klasse gelesen und geändert werden, zu der sie gehören.  Die Zugriffsebene kann mit den entsprechenden Schlüsselwörtern geändert werden, die C ++ bereitstellt. </p><br><p>  In C ++ sind mehrere Qualifizierer verfügbar, die den Datenzugriff wie folgt ändern: </p><a name="habracut"></a><br><ul><li>  öffentliche Daten stehen allen zur Verfügung; </li><li>  geschützt ( <code>protected</code> ) - nur für Klassen- und Kinderklassen verfügbar; </li><li>  privat - <code>private</code> - nur für die Klasse verfügbar, zu der sie gehören. </li></ul><br><p>  Der Kürze halber werden in den Beispielen nur zwei Ebenen (privat und öffentlich) hervorgehoben. </p><br><h2 id="primer-inkapsulyacii">  Verkapselungsbeispiel </h2><br><p>  In der <code>Contact</code> Klasse kann über das Hauptprogramm auf öffentliche Variablen und Methoden zugegriffen werden.  Private Variablen und Methoden können nur von der Klasse selbst gelesen, aufgerufen oder geändert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; int main() { Contact Tony; Tony.print_numbers(); // cout &lt;&lt; Tony.mobile_number &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Der Versuch, die private Variable <code>mobile_number</code> aus dem Hauptprogramm ( <code>main</code> ) zu drucken oder zu ändern, führt zu einem Kompilierungsfehler, da der Zugriff auf private Daten in der Klasse eingeschränkt ist. </p><br><h2 id="narushenie-inkapsulyacii-s-druzyami-horoshaya-praktika">  Verkapselungsverletzung mit Freunden (Gute Praxis) </h2><br><p>  In C ++ gibt es ein Schlüsselwort "Freund", mit dem Sie Ausnahmen zu den allgemeinen Regeln für den Zugriff auf Daten hinzufügen können.  Wenn eine Funktion oder Klasse als Freund der <code>Contact</code> Klasse bezeichnet wird, erhalten sie freien Zugriff auf geschützte oder private Daten. </p><br><p>  Es gibt zwei Grundregeln der Freundschaft - Freundschaft wird nicht vererbt und ist nicht gegenseitig.  Auch die Anwesenheit von „Freunden“ ändert nichts an der Datensicherheit - private Daten bleiben mit Ausnahme von „Freund“ privat. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } // Declaring a global 'friend' function friend void print_numbers( Contact some_contact ); }; void print_numbers( Contact some_contact ) { cout &lt;&lt; "Mobile number: " &lt;&lt; some_contact.mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; some_contact.home_number &lt;&lt; endl; } int main() { Contact Tony; print_numbers(Tony); return 0; }</span></span></span></span></code> </pre> <br><p>  In diesem Beispiel ist die Funktion <code>print_numbers()</code> eine normale Funktion und keine Methode der <code>Contact</code> Klasse.  Das Deklarieren der Funktion <code>print_numbers()</code> "Freund" der <code>Contact</code> Klasse ist der einzige Grund, <code>print_numbers()</code> Funktion <code>print_numbers()</code> Zugriff auf private Daten hat.  Wenn Sie die Zeile mit der Definition eines Freundes entfernen, wird der Code nicht kompiliert. </p><br><p>  <em>Hinweis</em> : Es ist besser, Freunde nicht zu missbrauchen.  Das Hinzufügen eines Freundes sollte als Ausnahme und nicht als allgemeine Praxis betrachtet werden. </p><br><h2 id="narushenie-inkapsulyacii-s-preobrazovaniem-tipov-i-ukazatelyami-plohaya-praktika">  Kapselungsverletzung mit Typkonvertierung und Zeigern (schlechte Praxis) </h2><br><p>  Zunächst ist anzumerken, dass die Verwendung von Zeigern und die Typkonvertierung auf diese Weise eine schlechte Idee ist.  Diese Methode garantiert nicht den Empfang der erforderlichen Daten.  Es ist schlecht gelesen und schlecht gepflegt.  Trotzdem existiert er. </p><br><p>  C ++ hat viele Tools von C geerbt, von denen eines <code>typecasting</code> .  Standardmäßig sind alle Variablen und Methoden in der Klasse privat.  Gleichzeitig ist die Standardstufe des Datenzugriffs in der Struktur ( <code>struct</code> ) öffentlich.  Es ist möglich, eine Struktur oder eine vollständig öffentliche Klasse zu erstellen, in der sich die Daten identisch mit den Daten in der <code>Contact</code> , und mithilfe der Typkonvertierung auf private Daten zuzugreifen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; struct Contact_struct { int mobile_number; int home_number; }; int main() { Contact Tony; Contact_struct * structured_Tony; Tony.print_numbers(); structured_Tony = (Contact_struct *) &amp; Tony; structured_Tony-&gt;mobile_number = 20; structured_Tony-&gt;home_number = 30; Tony.print_numbers(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Private Daten wurden aufgrund der Typkonvertierung gelesen und geändert</em> </p><br><h1 id="inkapsulyaciya-v-si-1">  C-Einkapselung </h1><br><p>  Die Kapselung wird traditionell als eines der wichtigsten OOP-Prinzipien angesehen.  Dies schränkt jedoch die Verwendung dieses Prinzips in prozedural ausgerichteten Sprachen nicht ein.  In C wird die Kapselung trotz des Fehlens der Schlüsselwörter "privat" und "öffentlich" lange Zeit verwendet. </p><br><h2 id="privatnye-peremennye">  Private Variablen </h2><br><p>  Im Zusammenhang mit der Kapselung können alle Daten in C standardmäßig als öffentlich betrachtet werden.  Die Zugriffsebene auf Variablen in Strukturen ( <code>struct</code> ) kann in private geändert werden, wenn ihre Definition vom Hauptprogramm isoliert ist.  Der gewünschte Effekt kann durch die Verwendung separater Header- (Header, .h) und Quelldateien (Source, .c) erzielt werden. </p><br><p>  In diesem Beispiel wurde die Struktur in einer separaten Quelldatei „private_var.c“ definiert.  Da das Initialisieren der Struktur in C das Zuweisen und Freigeben von Speicher erfordert, wurden mehrere Hilfsfunktionen hinzugefügt. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } void delete_contact( struct Contact * some_contact ) { free(some_contact); }</span></span></span></span></code> </pre> <br><p>  In der entsprechenden Header-Datei "private_var.h" wurde die <code>Contact</code> deklariert, ihr Inhalt blieb jedoch für das Hauptprogramm verborgen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_VAR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_VAR struct Contact; struct Contact * create_contact(); void delete_contact( struct Contact * some_contact ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_VAR */</span></span></span></span></code> </pre> <br><p>  Daher ist für "main.c" der Inhalt der Struktur unbekannt, und Versuche, private Daten zu lesen oder zu ändern, führen zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // printf( "Mobile number: %d\n", Tony-&gt;mobile_number); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-peremennym-s-ukazatelyami">  Zugriff auf private Variablen mit Zeigern </h2><br><p>  Die Typkonvertierung kann verwendet werden, um die Kapselung sowohl in C als auch in C ++ zu überwinden. Dieser Ansatz wurde jedoch bereits beschrieben.  In dem Wissen, dass die Daten in der Struktur in der Reihenfolge ihrer Deklaration angeordnet sind, sind Zeiger und Arithmetik von Zeigern geeignet, um das Ziel zu erreichen. </p><br><p>  Der Zugriff auf Variablen in der Struktur ist begrenzt.  Es werden jedoch nur Variablen ausgeblendet, nicht der Speicher, in dem die Daten gespeichert sind.  Zeiger können als Referenz auf die Speicheradresse betrachtet werden, und wenn dieser Speicher dem Programm zur Verfügung steht, können die in diesem Speicher gespeicherten Daten gelesen und geändert werden.  Wenn der Zeiger dem Speicher zugewiesen ist, in dem die Struktur ihre Daten speichert, können sie gelesen werden.  Bei Verwendung derselben Strukturdefinition (dieselben ".c" - und ".h" -Dateien) und der geänderten "main.c" -Datei wurde die Zugriffsbeschränkung überwunden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); int * mobile_number_is_here = (int *)Tony; printf("Mobile number: %d\n", *mobile_number_is_here); int * home_number_is_here = mobile_number_is_here + 1; *home_number_is_here = 1; printf("Modified home number: %d\n", *home_number_is_here); delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Die Daten in der Struktur wurden gelesen und geändert</em> </p><br><h2 id="privatnye-funkcii">  Private Funktionen </h2><br><p>  Funktionen, die standardmäßig extern ( <code>extern</code> ) sind, sind in der gesamten sogenannten <code>translation unit</code> sichtbar.  Mit anderen Worten, wenn mehrere Dateien zu einer Objektdatei zusammengefasst werden, kann jede dieser Dateien von jeder anderen Datei aus auf jede Funktion zugreifen.  Wenn Sie beim Erstellen einer Funktion das <code>static</code> "static" verwenden, wird die Sichtbarkeit auf die Datei beschränkt, in der sie definiert wurde. Um die Privatsphäre der Funktion zu gewährleisten, müssen Sie daher mehrere Schritte ausführen: </p><br><ul><li>  Die Funktion muss entweder in der Quelldatei (.c) oder in der entsprechenden Header-Datei (.h) als statisch ( <code>static</code> ) deklariert werden. </li><li>  Die Funktionsdefinition muss sich in einer separaten Quelldatei befinden. </li></ul><br><p>  In diesem Beispiel wurde die statische Funktion <code>print_numbers()</code> in der Datei "private_funct.c" definiert.  Übrigens ruft die Funktion <code>delete_contact()</code> erfolgreich <code>print_numbers()</code> da sie sich in derselben Datei befinden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } static void print_numbers( struct Contact * some_contact ) { printf("Mobile number: %d, ", some_contact-&gt;mobile_number); printf("home number = %d\n", some_contact-&gt;home_number); } void delete_contact( struct Contact * some_contact ) { print_numbers(some_contact); free(some_contact); }</span></span></span></span></code> </pre> <br><p>  In der entsprechenden Header-Datei "private_funct.h" wurde <code>print_numbers()</code> als statische Funktion deklariert. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H struct Contact; struct Contact * create_contact(); static void print_numbers( struct Contact * some_contact ); void delete_contact( struct Contact * my_points ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_FUNCT_H */</span></span></span></span></code> </pre> <br><p>  Das Hauptprogramm "main.c" ruft erfolgreich indirekt <code>delete_contact()</code> über <code>delete_contact()</code> , da sich beide Funktionen im selben Dokument befinden.  Ein Versuch, <code>print_numbers()</code> vom Hauptprogramm aus <code>print_numbers()</code> Fehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // print_numbers( Tony ); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-funkciyam">  Zugriff auf private Funktionen </h2><br><p>  Es ist <code>print_numbers()</code> vom Hauptprogramm aus <code>print_numbers()</code> .  Dazu können Sie das Schlüsselwort <code>goto</code> oder einen Zeiger auf eine private Funktion in <code>main</code> .  Beide Methoden erfordern Änderungen entweder in der Quelldatei „private_funct.c“ oder direkt im Hauptteil der Funktion.  Da diese Methoden die Kapselung nicht umgehen und aufheben, gehen sie über den Rahmen dieses Artikels hinaus. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Die Kapselung existiert außerhalb der OOP-Sprachen.  Moderne OOP-Sprachen machen die Kapselung bequem und natürlich.  Es gibt viele Möglichkeiten, die Kapselung zu umgehen, und das Vermeiden fragwürdiger Praktiken hilft, sie sowohl in C als auch in C ++ beizubehalten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444602/">https://habr.com/ru/post/de444602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444592/index.html">Das US-Militär plant die Verwendung eines neuen Exoskeletttyps</a></li>
<li><a href="../de444594/index.html">Big o</a></li>
<li><a href="../de444596/index.html">Jodid: Mozilla Interactive Science Editor</a></li>
<li><a href="../de444598/index.html">Die CD ist 40 Jahre alt und er ist tot (oder?)</a></li>
<li><a href="../de444600/index.html">Rückblick auf 14 kopflose cm 2019</a></li>
<li><a href="../de444610/index.html">Statistik und Überwachung von PHP-Skripten in Echtzeit. ClickHouse und Grafana helfen Pinba</a></li>
<li><a href="../de444612/index.html">Makroschaden für C ++ - Code</a></li>
<li><a href="../de444614/index.html">Die ganze Geschichte von Linux. Teil II: Unternehmen Höhen und Tiefen</a></li>
<li><a href="../de444616/index.html">Erstellen Sie Ihren eigenen Android Voice Recorder mit Kotlin</a></li>
<li><a href="../de444620/index.html">Verwenden von Linux-Kernel-Sequenzdateien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>