<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üßöüèø üò™ Kapselung in C ++ und C. üè¥ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üññüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Definition 


 Die Kapselung ist eine Reihe von Tools zur Steuerung des Zugriffs auf Daten oder Methoden, die diese Daten verwalten. Eine detaillierte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kapselung in C ++ und C.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444602/"><p><img src="https://habrastorage.org/webt/uq/da/c9/uqdac9e3znu_dgoypeekipj7so8.png"></p><br><h1 id="opredelenie">  Definition </h1><br><p>  Die Kapselung ist eine Reihe von Tools zur Steuerung des Zugriffs auf Daten oder Methoden, die diese Daten verwalten.  Eine detaillierte Definition des Begriffs ‚ÄûEinkapselung‚Äú finden Sie in meiner vorherigen Ver√∂ffentlichung auf dem Habr√© unter diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> .  Dieser Artikel konzentriert sich auf Kapselungsbeispiele in C ++ und C. </p><br><h1 id="inkapsulyaciya-v-si">  Kapselung in C ++ </h1><br><p> Standardm√§√üig sind in einer Klasse ( <code>class</code> ) Daten und Methoden privat ( <code>private</code> ).  Sie k√∂nnen nur von der Klasse gelesen und ge√§ndert werden, zu der sie geh√∂ren.  Die Zugriffsebene kann mit den entsprechenden Schl√ºsselw√∂rtern ge√§ndert werden, die C ++ bereitstellt. </p><br><p>  In C ++ sind mehrere Qualifizierer verf√ºgbar, die den Datenzugriff wie folgt √§ndern: </p><a name="habracut"></a><br><ul><li>  √∂ffentliche Daten stehen allen zur Verf√ºgung; </li><li>  gesch√ºtzt ( <code>protected</code> ) - nur f√ºr Klassen- und Kinderklassen verf√ºgbar; </li><li>  privat - <code>private</code> - nur f√ºr die Klasse verf√ºgbar, zu der sie geh√∂ren. </li></ul><br><p>  Der K√ºrze halber werden in den Beispielen nur zwei Ebenen (privat und √∂ffentlich) hervorgehoben. </p><br><h2 id="primer-inkapsulyacii">  Verkapselungsbeispiel </h2><br><p>  In der <code>Contact</code> Klasse kann √ºber das Hauptprogramm auf √∂ffentliche Variablen und Methoden zugegriffen werden.  Private Variablen und Methoden k√∂nnen nur von der Klasse selbst gelesen, aufgerufen oder ge√§ndert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; int main() { Contact Tony; Tony.print_numbers(); // cout &lt;&lt; Tony.mobile_number &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Der Versuch, die private Variable <code>mobile_number</code> aus dem Hauptprogramm ( <code>main</code> ) zu drucken oder zu √§ndern, f√ºhrt zu einem Kompilierungsfehler, da der Zugriff auf private Daten in der Klasse eingeschr√§nkt ist. </p><br><h2 id="narushenie-inkapsulyacii-s-druzyami-horoshaya-praktika">  Verkapselungsverletzung mit Freunden (Gute Praxis) </h2><br><p>  In C ++ gibt es ein Schl√ºsselwort "Freund", mit dem Sie Ausnahmen zu den allgemeinen Regeln f√ºr den Zugriff auf Daten hinzuf√ºgen k√∂nnen.  Wenn eine Funktion oder Klasse als Freund der <code>Contact</code> Klasse bezeichnet wird, erhalten sie freien Zugriff auf gesch√ºtzte oder private Daten. </p><br><p>  Es gibt zwei Grundregeln der Freundschaft - Freundschaft wird nicht vererbt und ist nicht gegenseitig.  Auch die Anwesenheit von ‚ÄûFreunden‚Äú √§ndert nichts an der Datensicherheit - private Daten bleiben mit Ausnahme von ‚ÄûFreund‚Äú privat. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } // Declaring a global 'friend' function friend void print_numbers( Contact some_contact ); }; void print_numbers( Contact some_contact ) { cout &lt;&lt; "Mobile number: " &lt;&lt; some_contact.mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; some_contact.home_number &lt;&lt; endl; } int main() { Contact Tony; print_numbers(Tony); return 0; }</span></span></span></span></code> </pre> <br><p>  In diesem Beispiel ist die Funktion <code>print_numbers()</code> eine normale Funktion und keine Methode der <code>Contact</code> Klasse.  Das Deklarieren der Funktion <code>print_numbers()</code> "Freund" der <code>Contact</code> Klasse ist der einzige Grund, <code>print_numbers()</code> Funktion <code>print_numbers()</code> Zugriff auf private Daten hat.  Wenn Sie die Zeile mit der Definition eines Freundes entfernen, wird der Code nicht kompiliert. </p><br><p>  <em>Hinweis</em> : Es ist besser, Freunde nicht zu missbrauchen.  Das Hinzuf√ºgen eines Freundes sollte als Ausnahme und nicht als allgemeine Praxis betrachtet werden. </p><br><h2 id="narushenie-inkapsulyacii-s-preobrazovaniem-tipov-i-ukazatelyami-plohaya-praktika">  Kapselungsverletzung mit Typkonvertierung und Zeigern (schlechte Praxis) </h2><br><p>  Zun√§chst ist anzumerken, dass die Verwendung von Zeigern und die Typkonvertierung auf diese Weise eine schlechte Idee ist.  Diese Methode garantiert nicht den Empfang der erforderlichen Daten.  Es ist schlecht gelesen und schlecht gepflegt.  Trotzdem existiert er. </p><br><p>  C ++ hat viele Tools von C geerbt, von denen eines <code>typecasting</code> .  Standardm√§√üig sind alle Variablen und Methoden in der Klasse privat.  Gleichzeitig ist die Standardstufe des Datenzugriffs in der Struktur ( <code>struct</code> ) √∂ffentlich.  Es ist m√∂glich, eine Struktur oder eine vollst√§ndig √∂ffentliche Klasse zu erstellen, in der sich die Daten identisch mit den Daten in der <code>Contact</code> , und mithilfe der Typkonvertierung auf private Daten zuzugreifen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; struct Contact_struct { int mobile_number; int home_number; }; int main() { Contact Tony; Contact_struct * structured_Tony; Tony.print_numbers(); structured_Tony = (Contact_struct *) &amp; Tony; structured_Tony-&gt;mobile_number = 20; structured_Tony-&gt;home_number = 30; Tony.print_numbers(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Private Daten wurden aufgrund der Typkonvertierung gelesen und ge√§ndert</em> </p><br><h1 id="inkapsulyaciya-v-si-1">  C-Einkapselung </h1><br><p>  Die Kapselung wird traditionell als eines der wichtigsten OOP-Prinzipien angesehen.  Dies schr√§nkt jedoch die Verwendung dieses Prinzips in prozedural ausgerichteten Sprachen nicht ein.  In C wird die Kapselung trotz des Fehlens der Schl√ºsselw√∂rter "privat" und "√∂ffentlich" lange Zeit verwendet. </p><br><h2 id="privatnye-peremennye">  Private Variablen </h2><br><p>  Im Zusammenhang mit der Kapselung k√∂nnen alle Daten in C standardm√§√üig als √∂ffentlich betrachtet werden.  Die Zugriffsebene auf Variablen in Strukturen ( <code>struct</code> ) kann in private ge√§ndert werden, wenn ihre Definition vom Hauptprogramm isoliert ist.  Der gew√ºnschte Effekt kann durch die Verwendung separater Header- (Header, .h) und Quelldateien (Source, .c) erzielt werden. </p><br><p>  In diesem Beispiel wurde die Struktur in einer separaten Quelldatei ‚Äûprivate_var.c‚Äú definiert.  Da das Initialisieren der Struktur in C das Zuweisen und Freigeben von Speicher erfordert, wurden mehrere Hilfsfunktionen hinzugef√ºgt. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } void delete_contact( struct Contact * some_contact ) { free(some_contact); }</span></span></span></span></code> </pre> <br><p>  In der entsprechenden Header-Datei "private_var.h" wurde die <code>Contact</code> deklariert, ihr Inhalt blieb jedoch f√ºr das Hauptprogramm verborgen. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_VAR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_VAR struct Contact; struct Contact * create_contact(); void delete_contact( struct Contact * some_contact ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_VAR */</span></span></span></span></code> </pre> <br><p>  Daher ist f√ºr "main.c" der Inhalt der Struktur unbekannt, und Versuche, private Daten zu lesen oder zu √§ndern, f√ºhren zu einem Kompilierungsfehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // printf( "Mobile number: %d\n", Tony-&gt;mobile_number); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-peremennym-s-ukazatelyami">  Zugriff auf private Variablen mit Zeigern </h2><br><p>  Die Typkonvertierung kann verwendet werden, um die Kapselung sowohl in C als auch in C ++ zu √ºberwinden. Dieser Ansatz wurde jedoch bereits beschrieben.  In dem Wissen, dass die Daten in der Struktur in der Reihenfolge ihrer Deklaration angeordnet sind, sind Zeiger und Arithmetik von Zeigern geeignet, um das Ziel zu erreichen. </p><br><p>  Der Zugriff auf Variablen in der Struktur ist begrenzt.  Es werden jedoch nur Variablen ausgeblendet, nicht der Speicher, in dem die Daten gespeichert sind.  Zeiger k√∂nnen als Referenz auf die Speicheradresse betrachtet werden, und wenn dieser Speicher dem Programm zur Verf√ºgung steht, k√∂nnen die in diesem Speicher gespeicherten Daten gelesen und ge√§ndert werden.  Wenn der Zeiger dem Speicher zugewiesen ist, in dem die Struktur ihre Daten speichert, k√∂nnen sie gelesen werden.  Bei Verwendung derselben Strukturdefinition (dieselben ".c" - und ".h" -Dateien) und der ge√§nderten "main.c" -Datei wurde die Zugriffsbeschr√§nkung √ºberwunden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); int * mobile_number_is_here = (int *)Tony; printf("Mobile number: %d\n", *mobile_number_is_here); int * home_number_is_here = mobile_number_is_here + 1; *home_number_is_here = 1; printf("Modified home number: %d\n", *home_number_is_here); delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Die Daten in der Struktur wurden gelesen und ge√§ndert</em> </p><br><h2 id="privatnye-funkcii">  Private Funktionen </h2><br><p>  Funktionen, die standardm√§√üig extern ( <code>extern</code> ) sind, sind in der gesamten sogenannten <code>translation unit</code> sichtbar.  Mit anderen Worten, wenn mehrere Dateien zu einer Objektdatei zusammengefasst werden, kann jede dieser Dateien von jeder anderen Datei aus auf jede Funktion zugreifen.  Wenn Sie beim Erstellen einer Funktion das <code>static</code> "static" verwenden, wird die Sichtbarkeit auf die Datei beschr√§nkt, in der sie definiert wurde. Um die Privatsph√§re der Funktion zu gew√§hrleisten, m√ºssen Sie daher mehrere Schritte ausf√ºhren: </p><br><ul><li>  Die Funktion muss entweder in der Quelldatei (.c) oder in der entsprechenden Header-Datei (.h) als statisch ( <code>static</code> ) deklariert werden. </li><li>  Die Funktionsdefinition muss sich in einer separaten Quelldatei befinden. </li></ul><br><p>  In diesem Beispiel wurde die statische Funktion <code>print_numbers()</code> in der Datei "private_funct.c" definiert.  √úbrigens ruft die Funktion <code>delete_contact()</code> erfolgreich <code>print_numbers()</code> da sie sich in derselben Datei befinden. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } static void print_numbers( struct Contact * some_contact ) { printf("Mobile number: %d, ", some_contact-&gt;mobile_number); printf("home number = %d\n", some_contact-&gt;home_number); } void delete_contact( struct Contact * some_contact ) { print_numbers(some_contact); free(some_contact); }</span></span></span></span></code> </pre> <br><p>  In der entsprechenden Header-Datei "private_funct.h" wurde <code>print_numbers()</code> als statische Funktion deklariert. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H struct Contact; struct Contact * create_contact(); static void print_numbers( struct Contact * some_contact ); void delete_contact( struct Contact * my_points ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_FUNCT_H */</span></span></span></span></code> </pre> <br><p>  Das Hauptprogramm "main.c" ruft erfolgreich indirekt <code>delete_contact()</code> √ºber <code>delete_contact()</code> , da sich beide Funktionen im selben Dokument befinden.  Ein Versuch, <code>print_numbers()</code> vom Hauptprogramm aus <code>print_numbers()</code> Fehler. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // print_numbers( Tony ); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-funkciyam">  Zugriff auf private Funktionen </h2><br><p>  Es ist <code>print_numbers()</code> vom Hauptprogramm aus <code>print_numbers()</code> .  Dazu k√∂nnen Sie das Schl√ºsselwort <code>goto</code> oder einen Zeiger auf eine private Funktion in <code>main</code> .  Beide Methoden erfordern √Ñnderungen entweder in der Quelldatei ‚Äûprivate_funct.c‚Äú oder direkt im Hauptteil der Funktion.  Da diese Methoden die Kapselung nicht umgehen und aufheben, gehen sie √ºber den Rahmen dieses Artikels hinaus. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Die Kapselung existiert au√üerhalb der OOP-Sprachen.  Moderne OOP-Sprachen machen die Kapselung bequem und nat√ºrlich.  Es gibt viele M√∂glichkeiten, die Kapselung zu umgehen, und das Vermeiden fragw√ºrdiger Praktiken hilft, sie sowohl in C als auch in C ++ beizubehalten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444602/">https://habr.com/ru/post/de444602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444592/index.html">Das US-Milit√§r plant die Verwendung eines neuen Exoskeletttyps</a></li>
<li><a href="../de444594/index.html">Big o</a></li>
<li><a href="../de444596/index.html">Jodid: Mozilla Interactive Science Editor</a></li>
<li><a href="../de444598/index.html">Die CD ist 40 Jahre alt und er ist tot (oder?)</a></li>
<li><a href="../de444600/index.html">R√ºckblick auf 14 kopflose cm 2019</a></li>
<li><a href="../de444610/index.html">Statistik und √úberwachung von PHP-Skripten in Echtzeit. ClickHouse und Grafana helfen Pinba</a></li>
<li><a href="../de444612/index.html">Makroschaden f√ºr C ++ - Code</a></li>
<li><a href="../de444614/index.html">Die ganze Geschichte von Linux. Teil II: Unternehmen H√∂hen und Tiefen</a></li>
<li><a href="../de444616/index.html">Erstellen Sie Ihren eigenen Android Voice Recorder mit Kotlin</a></li>
<li><a href="../de444620/index.html">Verwenden von Linux-Kernel-Sequenzdateien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>