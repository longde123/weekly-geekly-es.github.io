<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏼 💯 🏣 Laravel缓存：基础知识以及提示和技巧 🔺 👴🏽 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="缓存技术使您可以创建更多可扩展的应用程序，将某些查询的结果存储在快速的内存中。 但是，实施不正确的缓存会大大降低用户对应用程序的印象。 本文包含一些有关缓存的基本概念，从过去的几个项目中学到的各种规则和禁忌。 
 不要使用缓存。 


 您的项目速度很快，没有性能问题吗？ 
 不用缓存了。 认真地:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laravel缓存：基础知识以及提示和技巧</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p> 缓存技术使您可以创建更多可扩展的应用程序，将某些查询的结果存储在快速的内存中。 但是，实施不正确的缓存会大大降低用户对应用程序的印象。 本文包含一些有关缓存的基本概念，从过去的几个项目中学到的各种规则和禁忌。 </p><br><h2 id="ne-ispolzuyte-keshirovanie"> 不要使用缓存。 </h2><br><p> 您的项目速度很快，没有性能问题吗？ <br> 不用缓存了。 认真地:) </p><br><p> 这将极大地复杂化从数据库进行的读取操作，而没有任何好处。 </p><br><p>没错，Mohamed Said在本文开头进行了一些计算，并证明了在某些情况下，优化应用程序数毫秒可以为您的AWS账户节省大量资金。 因此，如果您的项目预计节省的资金超过1.86美元，那么缓存可能是个好主意。 </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet"> 如何运作？ </h2><br><p>当应用程序想要从数据库中获取某些数据（例如，通过其ID的Post实体）时，它会针对这种情况生成一个唯一的缓存键（ <code>'post_' . $id</code>非常合适），并尝试通过此键在快速键值存储（内存缓存， redis或其他）。 如果存在该值，则应用程序将使用它。 如果没有，它将从数据库中获取它，并通过此密钥存储在缓存中以备将来使用。 </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p> 永远不要将此值保留在缓存中，因为可以更新此Post实体，但是应用程序将始终接收旧的缓存值。 <br> 因此，缓存功能通常会询问该值应存储在什么时间。 </p><br><p> 在此时间到期后，memcache或redis将“忘记”它，应用程序将从数据库中获取新的价值。 </p><br><p> 一个例子： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p> 在这里，我将Post实体放置在缓存中15分钟（自5.8版开始，laravel在该参数中使用秒，然后是分钟）。 对于这种情况， <code>Cache</code>门面也有一个方便的<code>remember</code>方法。 此代码与上一个代码完全相同： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  Laravel文档中有一个“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">缓存”一章，</a>其中介绍了如何为应用程序和主要功能安装必要的驱动程序。 </p><br><h2 id="dannye-v-keshe"> 快取资料 </h2><br><p> 所有标准Laravel驱动程序都将数据存储为字符串。 当我们要求您缓存Eloquent模型的实例时，它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">serialize</a>函数从对象中获取字符串。 当我们从缓存中获取对象时，反<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">序列化</a>功能将其还原为对象状态。 </p><br><p> 几乎所有数据都可以缓存。 数字，字符串，数组，对象（如果可以正确序列化，请参见前面的链接中的功能说明）。 </p><br><p> 雄辩的实体和集合可以轻松地进行缓存，并且是Laravel应用程序缓存中最受欢迎的值。 但是，其他类型的使用也很广泛。  <code>Cache::increment</code>方法在实现各种计数器时很流行。 另外，当开发人员在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">竞争竞争条件</a>时， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">原子锁</a>非常有用。 </p><br><h2 id="chto-keshirovat"> 要缓存什么？ </h2><br><p> 缓存的第一个候选对象是经常执行的请求，但是其执行计划并非最简单。 最好的例子是主页上的前5条文章或最新新闻。 缓存这些值可以大大提高主页的性能。 </p><br><p> 通常，使用<code>Model::find($id)</code>通过id来获取实体非常快，但是如果此表负载了很多更新，插入和删除查询，则减少选择查询的数量将使数据库得到很好的喘息。 每次将加载具有<code>hasMany</code>关系的实体也是缓存的理想选择。 当我从事一个每天有10+百万访客的项目时，我们几乎缓存了所有选择请求。 </p><br><h2 id="invalidaciya-kesha"> 缓存失效 </h2><br><p> 指定时间后的密钥衰减有助于更新缓存中的数据，但这不会立即发生。 用户可以更改数据，但是一段时间后，他将继续在应用程序中看到它们的旧版本。 关于我过去的项目之一的常规对话： </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p> 这种行为对用户来说非常不便，而且当我们快速更新时，很明显的决定就是从缓存中删除旧数据。 这个过程称为残疾。 对于<code>"post_%id%"</code>类的简单键， <code>"post_%id%"</code>不是很困难。 </p><br><p> 雄辩的事件会有所帮助，或者如果您的应用程序生成特殊事件（如<code>PostPublished</code>或<code>UserBanned</code>它甚至会更加简单。 口才事件示例。 首先，您需要创建事件类。 为了方便起见，我将为它们使用一个抽象类： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p> 当然，根据PSR-4，每个类都必须位于自己的文件中。 设置Post Eloquent类（使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">文档</a> ）： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p> 为这些事件创建一个侦听器： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p> 每次更新或删除Post实体后，此代码都会删除缓存的值。 无效的实体列表（例如，排名前5位的文章或突发新闻）将更加复杂。 我看到了三种策略： </p><br><h3 id="strategiya-ne-invalidiruem"> 不要禁用策略 </h3><br><p> 只是不要触摸这些值。 通常，这不会带来任何问题。 没关系，新新闻稍后会出现在后者的列表中（当然，如果这不是一个大新闻门户）。 但是对于某些项目，在这些列表中拥有新数据确实很重要。 </p><br><h3 id="strategiya-nayti-i-obezvredit"> 查找和分散策略 </h3><br><p> 每次更新发布时，都可以尝试在缓存列表中找到它，如果存在，请删除此缓存值。 </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p> 看起来很丑，但是行得通。 </p><br><h3 id="strategiya-hranit-id"> 策略“商店ID” </h3><br><p> 如果列表中项目的顺序不重要，则仅条目的ID可以存储在缓存中。 接收到ID之后，您可以创建形式为<code>'post_'.$id</code>的键列表，并使用<code>Cache::many</code>方法获取所有值，该方法在一个请求中从缓存中获取很多值（也称为多获取）。 </p><br><p> 缓存无效并不是徒劳的， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">这是编程</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">两个困难</a>之一，在某些情况下非常困难。 </p><br><h2 id="keshirovanie-otnosheniy"> 关系缓存 </h2><br><p> 缓存具有关系的实体需要更多的关注。 </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p> 此代码执行两个<code>SELECT</code>查询。 通过<code>id</code>获取实体，通过<code>post_id</code>获取评论。 我们实现缓存： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p> 第一个请求已缓存，第二个未缓存。 当缓存驱动程序将“发布”写入缓存时， <code>comments</code>尚未加载。 如果我们也想缓存它们，那么我们必须手动加载它们： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p> 现在都缓存了这两个请求，但是每次添加注释时，我们都必须使<code>'post_'.$id</code>的值无效。 它不是很有效，因此最好单独存储注释缓存： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p> 有时，本质和态度彼此紧密联系在一起，并始终在一起使用（按细节顺序排列，将出版物翻译成所需的语言）。 在这种情况下，将它们存储在一个缓存中是很正常的。 </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya"> 缓存键的唯一事实来源 </h2><br><p> 如果项目实现了无效，则至少在两个位置生成高速缓存密钥：用于调用<code>Cache::get</code> / <code>Cache::remember</code> / <code>Cache::remember</code>以及用于调用<code>Cache::forget</code> 。 我已经遇到过这样的情况，即在一个地方而不是在另一个地方更改了此密钥，并且残障中断了。 在这种情况下，通常的建议是使用常量，但是缓存键是动态生成的，因此我使用特殊的类来生成键： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p> 为了更好的可读性，还可以将键生存期呈现为常量。  900或15 * 60会增加阅读代码时的认知负担。 </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi"> 不要在写操作中使用缓存 </h2><br><p> 在实现写操作（例如更改发布的标题或文本）时，很容易使用<code>getPost</code>编写的<code>getPost</code>方法： </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p> 请不要这样做。 即使正确完成了无效，缓存中的值也可能已过时。 竞态条件较小且发布会丢失其他用户所做的更改。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">乐观锁</a>将至少有助于避免丢失更改，但是错误请求的数量会大大增加。 </p><br><p> 最好的解决方案是对读写操作使用完全不同的实体选择逻辑（Hello，CQRS）。 在写操作中，您始终需要从数据库中选择最新值。 并且不要忘记重要数据的锁定（乐观或悲观）。 </p><br><p> 我认为这对于介绍性文章就足够了。 缓存是一个非常复杂且冗长的主题，为开发人员带来了陷阱，但是有时性能的提高会胜过所有的困难。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463495/">https://habr.com/ru/post/zh-CN463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463481/index.html">WMS的离散数学：压缩单元格中货物的算法（第1部分）</a></li>
<li><a href="../zh-CN463483/index.html">文档协作，更新的企业聊天和移动应用程序：Zextras Suite 3.0的新增功能</a></li>
<li><a href="../zh-CN463489/index.html">重金属撒谎：实际上，重音乐对其粉丝的健康有积极影响</a></li>
<li><a href="../zh-CN463491/index.html">《合金装备》的奇异英语翻译故事</a></li>
<li><a href="../zh-CN463493/index.html">您的小型存储库中有更多站点统计信息</a></li>
<li><a href="../zh-CN463497/index.html">股票效率计算器和出错的5个原因</a></li>
<li><a href="../zh-CN463499/index.html">舒适的办公室-有助于工作或干扰和分散注意力？ Sidenis，Alternativa Games和FunBox将回答</a></li>
<li><a href="../zh-CN463503/index.html">为什么现代Web开发如此复杂？ 第一部分</a></li>
<li><a href="../zh-CN463505/index.html">为什么系统管理员应成为DevOps工程师</a></li>
<li><a href="../zh-CN463507/index.html">肾脏是出路</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>