<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèº üçê üôèüèº Kriptografi di Jawa ü§∂üèø üíáüèø üßïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel "Java Cryptography" oleh Jakob Jenkov. 


 Publikasi ini adalah terjemahan dari artikel Kriptogra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kriptografi di Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444764/"><p> Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Java Cryptography"</a> oleh Jakob Jenkov. </p><br><p>  Publikasi ini adalah terjemahan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kriptografi Java</a> pertama dari serangkaian artikel untuk pemula yang ingin mempelajari dasar-dasar kriptografi di Jawa. </p><a name="habracut"></a><br><h2 id="oglavlenie">  Daftar isi: </h2><br><ol><li>  Kriptografi Jawa </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sandi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pesan pesan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mac</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tanda tangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keypair</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keygenerator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KeyPairGenerator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keystore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keytool</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sertifikat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pabrik Sertifikat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CertPath</a> </li></ol><br><h1 id="java-cryptography">  Kriptografi Jawa </h1><br><p>  <strong>Java Cryptography API</strong> menyediakan kemampuan untuk mengenkripsi dan mendekripsi data dalam java, serta mengelola kunci, tanda tangan dan mengotentikasi (mengotentikasi) pesan, menghitung hash kriptografi dan banyak lagi. </p><br><p>  Artikel ini menjelaskan dasar-dasar cara menggunakan Java Cryptography API untuk melakukan berbagai tugas yang memerlukan enkripsi aman. </p><br><p>  Artikel ini tidak menjelaskan dasar-dasar teori kriptografi.  Anda harus melihat informasi ini di tempat lain. </p><br><h2 id="rasshirenie-kriptografii-java">  Ekstensi Kriptografi Java </h2><br><p>  API kriptografi Java disediakan oleh apa yang disebut <strong>Java Cryptography Extension</strong> (JCE).  JCE telah lama menjadi bagian dari platform Java.  Awalnya, JCE dipisahkan dari Jawa karena pembatasan ekspor pada teknologi enkripsi di Amerika Serikat.  Oleh karena itu, algoritma enkripsi terkuat tidak termasuk dalam platform Java standar.  Algoritme enkripsi yang lebih kuat ini dapat diterapkan jika perusahaan Anda berlokasi di AS, tetapi dalam kasus lain Anda harus menggunakan algoritma yang lebih lemah atau menerapkan algoritma enkripsi Anda sendiri dan menghubungkannya ke JCE. </p><br><p>  Sejak 2017, aturan untuk mengekspor algoritma enkripsi di Amerika Serikat telah dilonggarkan secara signifikan, dan di sebagian besar dunia Anda dapat menggunakan standar enkripsi internasional melalui Java JCE. </p><br><p>  Arsitektur Kriptografi Jawa </p><br><p>  <strong>Java Cryptography Architecture (JCA)</strong> adalah nama dari desain API kriptografi internal di Jawa.  JCA terstruktur di sekitar beberapa kelas inti dan antarmuka tujuan umum.  Fungsi sebenarnya dari antarmuka ini disediakan oleh pemasok.  Dengan demikian, Anda dapat menggunakan kelas Cipher untuk mengenkripsi dan mendekripsi beberapa data, tetapi implementasi spesifik dari cipher (algoritma enkripsi) tergantung pada penyedia tertentu yang digunakan. </p><br><p>  Anda juga dapat menerapkan dan menghubungkan penyedia Anda sendiri, tetapi Anda harus berhati-hati dengan ini.  Mengimplementasikan enkripsi dengan benar tanpa lubang keamanan itu sulit!  Jika Anda tidak tahu apa yang Anda lakukan, Anda mungkin lebih baik menggunakan penyedia Java bawaan atau menggunakan penyedia tepercaya seperti Bouncy Castle. </p><br><h3 id="osnovnye-klassy-i-interfeysy">  Kelas dan antarmuka utama </h3><br><p>  API Java Cryptography terdiri dari paket-paket Java berikut: </p><br><ul><li>  keamanan java </li><li>  java.security.cert </li><li>  java.security.spec </li><li>  java.security.interfaces </li><li>  javax.crypto </li><li>  javax.crypto.spec </li><li>  javax.crypto.interfaces </li></ul><br><p>  Kelas utama dan antarmuka dari paket ini: </p><br><ul><li>  Penyedia </li><li>  SecureRandom </li><li>  Sandi </li><li>  Pesan pesan </li><li>  Tanda tangan </li><li>  Mac </li><li>  Parameter Algoritma </li><li>  AlgorithmParameterGenerator </li><li>  Pabrik kunci </li><li>  SecretKeyFactory </li><li>  KeyPairGenerator </li><li>  Keygenerator </li><li>  Kesepakatan kunci </li><li>  Keystore </li><li>  Pabrik Sertifikat </li><li>  CertPathBuilder </li><li>  CertPathValidator </li><li>  CertStore </li></ul><br><h3 id="provider-postavschik-kriptografii">  Penyedia </h3><br><p>  Kelas Provider (java.security.Provider) adalah kelas pusat di Java crypto API.  Untuk menggunakan Java crypto API, Anda harus menginstal penyedia kriptografi.  Java SDK hadir dengan penyedia kriptografinya sendiri.  Kecuali Anda secara eksplisit mengatur penyedia kriptografi, penyedia default akan digunakan.  Namun, penyedia kriptografi ini mungkin tidak mendukung algoritma enkripsi yang ingin Anda gunakan.  Karena itu, Anda mungkin harus menginstal penyedia kriptografi Anda sendiri. </p><br><p>  Salah satu penyedia kriptografi paling populer untuk Java crypto API disebut Bouncy Castle.  Berikut adalah contoh di mana BouncyCastleProvider ditetapkan sebagai penyedia kriptografi: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.bouncycastle.jce.provider.BouncyCastleProvider; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.security.Security; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProviderExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Security.addProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BouncyCastleProvider()); } }</code> </pre> <br><h3 id="cipher-shifr">  Sandi </h3><br><p>  Kelas Cipher (javax.crypto.Cipher) mewakili algoritma kriptografi.  Sebuah cipher dapat digunakan baik untuk enkripsi maupun untuk mendekripsi data.  Kelas Cipher dijelaskan secara lebih rinci di bagian berikut, dengan deskripsi singkat di bawah ini. </p><br><p>  Membuat instance kelas cipher yang menggunakan algoritma enkripsi AES untuk penggunaan internal: </p><br><pre> <code class="java hljs">Cipher cipher = Cipher.getInstance(<span class="hljs-string"><span class="hljs-string">"AES/CBC/PKCS5Padding"</span></span>);</code> </pre> <br><p>  Metode <em>Cipher.getInstance (...)</em> menerima string yang menentukan algoritma enkripsi mana yang akan digunakan, serta beberapa parameter algoritma lainnya. <br>  Dalam contoh di atas: </p><br><ul><li>  AES - algoritma enkripsi </li><li>  CBC adalah mode di mana algoritma AES dapat bekerja. </li><li>  PKCS5Padding adalah bagaimana algoritma AES harus menangani byte data terakhir untuk enkripsi.  Apa sebenarnya artinya ini, lihat di manual kriptografi secara keseluruhan, dan tidak di artikel ini. </li></ul><br><h4 id="inicializaciya-shifra">  Inisialisasi sandi </h4><br><p>  Sebelum menggunakan contoh sandi, Anda harus menginisialisasi.  Cipher instance diinisialisasi dengan memanggil metode <em>init ()</em> .  Metode <em>init ()</em> mengambil dua parameter: </p><br><ul><li>  Mode - Enkripsi / Dekripsi </li><li>  Kunci </li></ul><br><p>  Parameter pertama menunjukkan mode operasi instance cipher: untuk mengenkripsi atau mendekripsi data.  Parameter kedua menunjukkan kunci mana yang mereka gunakan untuk mengenkripsi atau mendekripsi data. </p><br><p>  Contoh: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); cipher.init(Cipher.ENCRYPT_MODE, key);</code> </pre><br><p>  Harap dicatat bahwa metode pembuatan kunci dalam contoh ini tidak aman dan tidak boleh digunakan dalam praktik.  Artikel ini di bagian berikut akan menjelaskan cara membuat kunci lebih aman. </p><br><p>  Untuk menginisialisasi instance cipher untuk mendekripsi data, Anda harus menggunakan Cipher.DECRYPT_MODE, misalnya: </p><br><pre> <code class="java hljs">cipher.init(Cipher.DECRYPT_MODE, key);</code> </pre> <br><h4 id="shifrovanie-ili-deshifrovanie-dannyh">  Enkripsi atau Dekripsi Data </h4><br><p>  Setelah menginisialisasi sandi, Anda dapat mulai mengenkripsi atau mendekripsi data dengan memanggil metode <em>pembaruan ()</em> atau <em>doFinal ()</em> .  Metode <em>pembaruan ()</em> digunakan jika Anda mengenkripsi atau mendekripsi data.  Metode <em>doFinal ()</em> dipanggil saat Anda mengenkripsi potongan data terakhir atau jika blok data yang Anda lewati ke <em>doFinal ()</em> adalah satu set data untuk enkripsi. </p><br><p>  Contoh enkripsi data menggunakan metode <em>doFinal ()</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] plainText = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] cipherText = cipher.doFinal(plainText);</code> </pre> <br><p>  Untuk mendekripsi data, Anda harus meneruskan ciphertext (data) ke metode <em>doFinal ()</em> atau <em>doUpdate ()</em> . </p><br><h3 id="keys-klyuchi">  Kunci </h3><br><p>  Untuk mengenkripsi atau mendekripsi data, Anda memerlukan kunci.  Ada dua jenis kunci, tergantung pada jenis algoritma enkripsi apa yang digunakan: </p><br><ul><li>  Kunci simetris </li><li>  Kunci asimetris </li></ul><br><p>  Kunci simetris digunakan untuk algoritma enkripsi simetris.  Algoritma enkripsi simetris menggunakan kunci yang sama untuk enkripsi dan dekripsi. <br>  Kunci asimetris digunakan untuk algoritma enkripsi asimetris.  Algoritma enkripsi asimetris menggunakan satu kunci untuk enkripsi dan yang lainnya untuk dekripsi.  Algoritma enkripsi kunci publik dan pribadi adalah contoh dari algoritma enkripsi asimetris. </p><br><p>  Entah bagaimana, pihak yang perlu mendekripsi data harus mengetahui kunci yang diperlukan untuk mendekripsi data.  Jika decryptor bukan merupakan pihak dalam enkripsi data, kedua pihak harus menyetujui kunci atau bertukar kunci.  Ini disebut pertukaran kunci. </p><br><h4 id="bezopasnost-klyucha">  Keamanan Kunci </h4><br><p>  Kunci harus sulit ditebak sehingga penyerang tidak dapat dengan mudah mengambil kunci enkripsi.  Dalam contoh dari bagian sebelumnya pada kelas Cipher, kunci yang sangat sederhana, kode keras digunakan.  Dalam praktiknya, ini tidak layak dilakukan.  Jika kunci para pihak mudah ditebak, penyerang akan dapat mendekripsi data yang dienkripsi dan, mungkin, membuat pesan palsu sendiri.  Penting untuk membuat kunci yang sulit ditebak.  Jadi, kuncinya harus terdiri dari byte acak.  Semakin banyak byte acak, semakin sulit untuk menebak, karena ada lebih banyak kemungkinan kombinasi. </p><br><h4 id="generaciya-klyucha">  Generasi kunci </h4><br><p>  Untuk menghasilkan kunci enkripsi acak, Anda bisa menggunakan kelas Java KeyGenerator.  KeyGenerator akan dijelaskan secara lebih rinci dalam bab-bab berikut, berikut adalah contoh kecil penggunaannya di sini: </p><br><pre> <code class="java hljs">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"AES"</span></span>); SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyBitSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; keyGenerator.init(keyBitSize, secureRandom); SecretKey secretKey = keyGenerator.generateKey();</code> </pre> <br><p>  Contoh SecretKey yang dihasilkan dapat diteruskan ke metode <em>Cipher.init ()</em> , misalnya seperti ini: </p><br><pre> <code class="java hljs">cipher.init(Cipher.ENCRYPT_MODE, secretKey);</code> </pre> <br><h4 id="generaciya-pary-klyuchey">  Generasi pasangan kunci </h4><br><p>  Algoritma enkripsi asimetris menggunakan pasangan kunci yang terdiri dari kunci publik dan kunci pribadi untuk mengenkripsi dan mendekripsi data.  Untuk membuat pasangan kunci asimetris, Anda dapat menggunakan KeyPairGenerator (java.security.KeyPairGenerator).  KeyPairGenerator akan dijelaskan secara lebih rinci dalam bab-bab berikut, di bawah ini adalah contoh sederhana menggunakan Java KeyPairGenerator: </p><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair();</code> </pre> <br><h4 id="hranilische-klyuchey--key-store">  Toko Kunci </h4><br><p>  Java KeyStore adalah database yang dapat berisi kunci.  Java KeyStore diwakili oleh kelas KeyStore (java.security.KeyStore).  Keystore dapat berisi kunci dari jenis berikut: </p><br><ul><li>  Kunci pribadi </li><li>  Kunci dan sertifikat publik (Kunci publik + sertifikat) </li><li>  Kunci rahasia </li></ul><br><p>  Kunci privat dan publik digunakan dalam enkripsi asimetris.  Kunci publik mungkin memiliki sertifikat terkait.  Sertifikat adalah dokumen yang membuktikan identitas seseorang, organisasi, atau perangkat yang mengklaim memiliki kunci publik. </p><br><p>  Sertifikat biasanya ditandatangani secara digital oleh pihak yang bersandar sebagai bukti. <br>  Kunci privat digunakan dalam enkripsi simetris. Kelas KeyStore cukup kompleks, itulah sebabnya ia dijelaskan lebih rinci nanti dalam bab terpisah tentang Java KeyStore. </p><br><h4 id="instrument-upravleniya-klyuchami-keytool">  Alat Manajemen Kunci (Keytool) </h4><br><p>  Java Keytool adalah alat baris perintah yang dapat bekerja dengan file Java KeyStore.  Keytool dapat menghasilkan pasangan kunci dalam file KeyStore, sertifikat ekspor dan sertifikat impor ke KeyStore dan beberapa fungsi lainnya.  Keytool hadir dengan instalasi Java.  Keytool dijelaskan secara lebih rinci nanti dalam bab terpisah tentang Java Keytool. </p><br><h3 id="daydzhest-soobscheniya-messagedigest">  Pesan Intisari </h3><br><p>  Ketika Anda menerima data terenkripsi dari sisi lain, dapatkah Anda yakin bahwa tidak ada yang mengubah data terenkripsi dalam perjalanan ke Anda? </p><br><p>  Biasanya, solusinya adalah menghitung intisari pesan dari data sebelum mengenkripsi, kemudian mengenkripsi data dan intisari pesan, dan mengirimkannya melalui jaringan.  Intisari pesan adalah nilai hash yang dihitung berdasarkan data pesan.  Jika setidaknya satu byte diubah dalam data terenkripsi, intisari pesan yang dihitung dari data juga akan berubah. </p><br><p>  Saat Anda menerima data terenkripsi, Anda mendekripsi, menghitung intisari pesan darinya, dan membandingkan intisari pesan yang dihitung dengan intisari dari pesan yang dikirim bersama dengan data terenkripsi.  Jika dua pesan dicerna sama, ada probabilitas tinggi (tetapi tidak 100%) bahwa data belum diubah. </p><br><p>  Java MessageDigest (java.security.MessageDigest) dapat digunakan untuk menghitung intisari pesan.  Untuk membuat instance MessageDigest, metode <em>MessageDigest.getInstance ()</em> dipanggil.  Ada beberapa algoritma intisari pesan yang berbeda.  Anda perlu menentukan algoritma mana yang ingin Anda gunakan saat membuat instance MessageDigest.  Bekerja dengan MessageDigest akan dijelaskan lebih terinci di bab Java MessageDigest. </p><br><h4 id="kratkoe-vvedenie-v-klass-messagedigest">  Pengantar singkat ke kelas MessageDigest: </h4><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>);</code> </pre> <br><p>  Contoh ini membuat instance MessageDigest yang menggunakan algoritma hashing kriptografi internal SHA-256 untuk menghitung intisari pesan. </p><br><p>  Untuk menghitung intisari pesan dari beberapa data, Anda memanggil metode <em>update ()</em> atau <em>digest ()</em> .  Metode <em>pembaruan ()</em> dapat dipanggil beberapa kali, dan intisari pesan diperbarui di dalam objek.  Ketika Anda telah melewati semua data yang ingin Anda sertakan dalam intisari pesan, Anda memanggil <em>intisari ()</em> dan mengambil ringkasan intisari pesan. </p><br><p>  Contoh <em>pembaruan</em> panggilan <em>()</em> beberapa kali, diikuti dengan panggilan untuk <em>dicerna ()</em> : </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); messageDigest.update(data1); messageDigest.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest();</code> </pre> <br><p>  Anda juga dapat memanggil <em>digest ()</em> sekali, meneruskan semua data untuk menghitung intisari pesan.  Contoh: </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest(data1);</code> </pre> <br><h3 id="kod-autentifikacii-soobscheniya-mac">  Kode Otentikasi Pesan (MAC) </h3><br><p>  Kelas Java Mac digunakan untuk membuat MAC (Message Authentication Code) dari pesan.  MAC mirip dengan intisari pesan, tetapi menggunakan kunci tambahan untuk mengenkripsi intisari pesan.  Hanya memiliki data sumber dan kunci, Anda dapat memeriksa MAC.  Jadi, MAC adalah cara yang lebih aman untuk melindungi blok data dari modifikasi daripada intisari pesan.  Kelas Mac dijelaskan secara lebih rinci di bab Java Mac, diikuti oleh pengantar singkat. </p><br><p>  Contoh Java Mac dibuat dengan memanggil metode <em>Mac.getInstance ()</em> , dengan memasukkan nama algoritma yang digunakan sebagai parameter.  Begini tampilannya: </p><br><pre> <code class="java hljs">Mac mac = Mac.getInstance(<span class="hljs-string"><span class="hljs-string">"HmacSHA256"</span></span>);</code> </pre> <br><p>  Sebelum Anda membuat MAC dari data, Anda harus menginisialisasi instance Mac dengan kunci.  Berikut adalah contoh menginisialisasi instance Mac dengan kunci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> ,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); mac.init(key);</code> </pre> <br><p>  Setelah menginisialisasi instance Mac, Anda dapat menghitung MAC dari data dengan memanggil metode <em>update ()</em> dan <em>doFinal ()</em> .  Jika Anda memiliki semua data untuk menghitung MAC, Anda dapat segera memanggil metode <em>doFinal ()</em> .  Begini tampilannya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); mac.update(data); mac.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] macBytes = mac.doFinal();</code> </pre> <br><h3 id="podpis-signature">  Tanda tangan </h3><br><p>  Kelas Signature (java.security.Signature) digunakan untuk menandatangani data secara digital.  Ketika data ditandatangani, tanda tangan digital dibuat dari data ini.  Dengan demikian, tanda tangan dipisahkan dari data. </p><br><p>  Tanda tangan digital dibuat dengan membuat intisari pesan (hash) dari data dan mengenkripsi intisari pesan ini dengan kunci pribadi perangkat, orang atau organisasi yang harus menandatangani data.  Intisari pesan terenkripsi disebut tanda tangan digital. </p><br><p>  Untuk membuat turunan dari Signature, metode <em>Signature.getInstance (...)</em> dipanggil: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>);</code> </pre> <br><h4 id="podpis-dannyh">  Tanda tangan data </h4><br><p>  Untuk menandatangani data, Anda harus menginisialisasi instance tanda tangan dalam mode tanda tangan dengan memanggil metode initSign (...), meneruskan kunci pribadi untuk menandatangani data.  Contoh menginisialisasi instance tanda tangan dalam mode tanda tangan: </p><br><pre> <code class="java hljs">signature.initSign(keyPair.getPrivate(), secureRandom);</code> </pre> <br><p>  Setelah menginisialisasi instance tanda tangan, ini dapat digunakan untuk menandatangani data.  Ini dilakukan dengan memanggil metode update (), meneruskan data tanda tangan sebagai parameter.  Anda dapat memanggil metode pembaruan () beberapa kali untuk melengkapi data untuk membuat tanda tangan.  Setelah semua data diteruskan ke metode pembaruan (), metode tanda () dipanggil untuk mendapatkan tanda tangan digital.  Begini tampilannya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign();</code> </pre> <br><h4 id="proverka-podpisi">  Verifikasi Tanda Tangan </h4><br><p>  Untuk memverifikasi tanda tangan, Anda perlu menginisialisasi instance tanda tangan dalam mode verifikasi dengan memanggil metode <em>initVerify (...)</em> , dengan memasukkan sebagai parameter kunci publik yang digunakan untuk memverifikasi tanda tangan.  Contoh menginisialisasi instance tanda tangan dalam mode verifikasi terlihat seperti ini: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initVerify(keyPair.getPublic());</code> </pre> <br><p>  Setelah inisialisasi dalam mode verifikasi, data yang ditandatangani dikirim ke metode <em>pembaruan ()</em> .  Panggilan ke metode <em>verifikasi ()</em> mengembalikan <em>benar</em> atau <em>salah</em> tergantung pada apakah tanda tangan dapat diverifikasi atau tidak.  Berikut ini adalah verifikasi tanda tangan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature2.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature);</code> </pre> <br><h4 id="polnyy-primer-podpisi-i-proverki">  Contoh Tanda Tangan dan Verifikasi Lengkap </h4><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair(); Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initSign(keyPair.getPrivate(), secureRandom); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign(); Signature signature2 = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature2.initVerify(keyPair.getPublic()); signature2.update(data); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature); System.out.println(<span class="hljs-string"><span class="hljs-string">"verified = "</span></span> + verified);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444764/">https://habr.com/ru/post/id444764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444752/index.html">Sejarah SXSW: Bagaimana Semuanya Dimulai</a></li>
<li><a href="../id444756/index.html">DARPA akan mengembangkan mesin nuklir roket</a></li>
<li><a href="../id444758/index.html">Perbedaan teknis sistem BI (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../id444760/index.html">Mesin CNC dari apa yang terbaring di garasi</a></li>
<li><a href="../id444762/index.html">CSTroN - monitor buatan sendiri pada matriks CSTN vintage dengan input-VGA dan papan kontrol FPGA</a></li>
<li><a href="../id444766/index.html">Karyawan Facebook memiliki akses ke kata sandi pengguna Facebook dan Instagram</a></li>
<li><a href="../id444768/index.html">Mengurangi ketergantungan pada data yang ditandai untuk jaringan pertikaian generatif</a></li>
<li><a href="../id444770/index.html">Bagaimana kami mencari kebocoran data di SimilarWeb</a></li>
<li><a href="../id444774/index.html">Kesalahan dengan migrasi ru-RU lokal di Google Chrome dan cara menghilangkannya</a></li>
<li><a href="../id444776/index.html">Jangan takut untuk mencoba, atau Bagaimana saya menjadi programmer pada usia di atas 18 tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>