<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€âœˆï¸ ğŸ‘¨ğŸ¿â€ğŸ¨ âœğŸ¾ PHP asinkron dan kisah satu sepeda ğŸ‘©ğŸ½â€ğŸ’» ğŸ™ğŸ½ ğŸ¦’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah rilis PHP7, menjadi mungkin untuk menulis aplikasi berumur panjang dengan biaya yang relatif rendah. Untuk programmer, proyek-proyek seperti p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP asinkron dan kisah satu sepeda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451916/"><p> Setelah rilis PHP7, menjadi mungkin untuk menulis aplikasi berumur panjang dengan biaya yang relatif rendah.  Untuk programmer, proyek-proyek seperti <code>prooph</code> , <code>broadway</code> , <code>prooph</code> , <code>messenger</code> telah tersedia, penulis yang mengambil solusi untuk masalah yang paling umum.  Tetapi bagaimana jika Anda mengambil langkah kecil ke depan, mempelajari pertanyaan itu? </p><br><p>  Mari kita coba mencari tahu nasib sepeda lain, yang memungkinkan Anda untuk mengimplementasikan aplikasi Publikasikan / Berlangganan. </p><a name="habracut"></a><br><p>  Untuk memulainya, kami akan mencoba meninjau tren saat ini secara singkat di dunia PHP, serta melihat sekilas operasi asinkron. </p><br><h3 id="php-sozdan-chtoby-umirat">  PHP dibuat untuk mati </h3><br><p>  Untuk waktu yang lama, PHP terutama digunakan dalam alur kerja permintaan / respons.  Dari sudut pandang pengembang, ini cukup mudah, karena tidak perlu khawatir tentang kebocoran memori, memonitor koneksi. </p><br><p>  Semua pertanyaan akan dieksekusi dalam isolasi satu sama lain, sumber daya yang digunakan akan dibebaskan, dan koneksi, misalnya, ke database akan ditutup ketika proses selesai. </p><br><p>  Sebagai contoh, Anda dapat mengambil aplikasi CRUD biasa yang ditulis berdasarkan kerangka kerja Symfony.  Untuk membaca dari database dan mengembalikan JSON, perlu melakukan sejumlah langkah (untuk menghemat ruang dan waktu, tidak termasuk langkah-langkah untuk menghasilkan / menjalankan opcode): </p><br><ul><li>  Analisis konfigurasi; </li><li>  Kompilasi kontainer; </li><li>  Meminta Routing </li><li>  Pemenuhan; </li><li>  Rendering hasilnya. </li></ul><br><p>  Seperti dalam kasus PHP (menggunakan akselerator), kerangka kerja secara aktif menggunakan caching (beberapa tugas tidak akan selesai pada permintaan berikutnya), serta inisialisasi tertunda.  Dimulai dengan versi 7.4, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preload</a> akan tersedia, yang selanjutnya akan mengoptimalkan inisialisasi aplikasi. </p><br><p>  Namun, tidak mungkin untuk sepenuhnya menghapus semua biaya overhead untuk inisialisasi. </p><br><h3 id="pomozhem-php-vyzhit">  Mari kita bantu PHP bertahan hidup </h3><br><p>  Solusi untuk masalah ini terlihat sangat sederhana: jika Anda menjalankan aplikasi setiap kali terlalu mahal, Anda perlu menginisialisasi sekali dan kemudian hanya mengirimkan permintaan ke sana, mengendalikan eksekusi mereka. </p><br><p>  Ada proyek dalam ekosistem PHP seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">php-pm</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RoadRunner</a> .  Keduanya secara konseptual melakukan hal yang sama: </p><br><ul><li>  Proses induk dibuat yang bertindak sebagai pengawas; </li><li>  Kumpulan proses anak dibuat; </li><li>  Ketika permintaan diterima, master mengambil proses dari kumpulan dan meneruskan permintaan itu.  Klien tertunda pada saat ini; </li><li>  Setelah tugas selesai, master mengembalikan hasilnya ke klien, dan proses anak dikirim kembali ke kumpulan. </li></ul><br><p>  Jika ada proses anak yang mati, supervisor membuatnya lagi dan menambahkannya ke kolam.  Kami membuat daemon dari aplikasi kami dengan satu tujuan tunggal: untuk menghapus overhead inisialisasi, secara signifikan meningkatkan kecepatan pemrosesan permintaan.  Ini adalah cara yang paling mudah untuk meningkatkan produktivitas, tetapi bukan satu-satunya. </p><br><blockquote>  Catatan: <br>  banyak contoh dari seri "ambil ReactPHP dan percepat Laravel N kali" berjalan di jaringan.  Penting untuk memahami perbedaan antara melakukan demonisasi (dan, sebagai hasilnya, menghemat waktu saat bootstrap aplikasi) dan multitasking. <br>  Saat menggunakan php-pm atau roadrunner, kode Anda tidak menjadi non-pemblokiran.  Anda cukup menghemat waktu pada inisialisasi. <br>  Membandingkan php-pm, roadrunner dan ReactPHP / Amp / Swoole secara definisi salah. </blockquote><br><h5 id="php-i-io">  PHP dan I / O </h5><br><p>  Interaksi dengan I / O di PHP secara default dieksekusi dalam mode blocking.  Ini berarti bahwa jika kami menjalankan permintaan untuk memperbarui informasi dalam tabel, aliran eksekusi akan berhenti menunggu jawaban dari database.  Semakin banyak panggilan seperti itu dalam proses memproses permintaan, semakin lama sumber daya server idle.  Memang, dalam proses pemrosesan permintaan, kita perlu pergi ke database beberapa kali, menulis sesuatu ke log, dan mengembalikan hasilnya kepada klien, pada akhirnya - juga operasi pemblokiran. </p><br><blockquote>  Bayangkan Anda adalah operator call center dan Anda perlu menelepon 50 pelanggan dalam satu jam. <br>  Anda menekan nomor pertama, dan nomor itu sedang sibuk (pelanggan membahas melalui telepon seri terakhir dari Game of Thrones dan apa seri yang digulirkan ke dalamnya). <br>  Dan sekarang Anda sedang duduk dan berusaha meraihnya sebelum kemenangan.  Waktu terus berjalan, shift hampir berakhir.  Setelah kehilangan 40 menit untuk mencapai pelanggan pertama, Anda melewatkan kesempatan untuk menghubungi orang lain dan diterima secara alami dari bos. <br>  Tetapi Anda dapat melakukan sebaliknya: jangan menunggu sampai pelanggan pertama bebas dan segera setelah Anda mendengar bunyi bip, tutup telepon dan mulailah memutar nomor berikutnya.  Anda dapat kembali ke yang pertama sedikit kemudian. <br>  Dengan pendekatan ini, peluang menelepon jumlah maksimum orang sangat meningkat, dan kecepatan pekerjaan Anda tidak bergantung pada tugas paling lambat. </blockquote><p>  Kode yang tidak memblokir utas eksekusi (tidak menggunakan pemblokiran panggilan I / O, serta fungsi seperti <code>sleep()</code> ), disebut asinkron. </p><br><p>  Mari kita kembali ke aplikasi Symfony CRUD kami.  Hampir tidak mungkin untuk membuatnya bekerja dalam mode asinkron karena banyaknya penggunaan fungsi pemblokiran: semua bekerja dengan konfigurasi, cache, logging, rendering respon, interaksi dengan database. </p><br><p>  Tetapi ini semua adalah konvensi, mari kita coba melempar Symfony dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amp</a> , yang menyediakan implementasi Event Loop (termasuk sejumlah binder), Janji dan Coroutine, sebagai ceri pada kue untuk menyelesaikan masalah kita. </p><br><p>  Janji adalah salah satu cara untuk mengatur kode asinkron.  Sebagai contoh, kita perlu mengakses beberapa sumber daya http. </p><br><p>  Kami membuat objek permintaan dan meneruskannya ke transportasi, yang dijanjikan Promise kepada kami berisi keadaan saat ini.  Ada tiga kemungkinan status: </p><br><ul><li>  Berhasil: permintaan kami berhasil diselesaikan; </li><li>  Kesalahan: selama eksekusi permintaan, terjadi kesalahan (misalnya, server mengembalikan respons 500); </li><li>  Menunggu: Pemrosesan permintaan belum dimulai. </li></ul><br><p>  Setiap Janji memiliki satu metode (dalam contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janji</a> diurai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh Amp</a> ) - <code>onResolve()</code> , di mana fungsi panggilan balik dengan dua argumen dilewatkan </p><br><pre> <code class="php hljs">$promise-&gt;onResolve( <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(?/Throwable $throwable, $result)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> !== $throwable) { <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> } );</code> </pre> <br><p>  Setelah kami menerima Janji, muncul pertanyaan: siapa yang akan memantau statusnya dan memberi tahu kami tentang perubahan status? </p><br><p>  Untuk ini, Event Loop digunakan. </p><br><p>  Intinya, Perulangan Kejadian adalah penjadwal yang memantau eksekusi.  Segera setelah tugas selesai (tidak peduli bagaimana), callable yang kami berikan kepada Promise akan dipanggil. </p><br><p>  Sedangkan untuk nuansa, saya akan merekomendasikan membaca artikel dari Nikita Popov: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multitasking kooperatif menggunakan coroutine</a> .  Ini akan membantu untuk memberikan kejelasan tentang apa yang terjadi dan di mana generatornya. </p><br><p>  Berbekal pengetahuan baru, mari kita coba kembali ke tugas rendering JSON kami. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/amphp/">Contoh</a> memproses permintaan http yang masuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/amphp/">amphp / http-server</a> . <br>  Segera setelah kami menerima permintaan, pembacaan asinkron dari database dilakukan (kami mendapatkan Janji) dan setelah selesai pengguna akan menerima JSON yang didambakan, dibentuk berdasarkan data yang diterima. </p><br><blockquote>  Jika kita perlu mendengarkan satu port dari beberapa proses, kita dapat melihat ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amphp / cluster</a> </blockquote><p>  Perbedaan utama adalah bahwa satu proses tunggal dapat melayani beberapa permintaan sekaligus karena fakta bahwa utas eksekusi tidak diblokir.  Klien akan menerima jawabannya ketika pembacaan dari database selesai, dan sementara tidak ada jawaban, Anda dapat mulai melayani permintaan berikutnya. </p><br><h3 id="divnyy-mir-asinhronnogo-php">  Dunia asinkron PHP yang luar biasa </h3><br><blockquote>  Penafian <br>  Asynchronous PHP dianggap dalam konteks eksotik dan tidak dianggap sesuatu yang sehat / normal.  Pada dasarnya, mereka akan menunggu untuk tertawa dalam gaya "ambil GO / Kotlin, bodoh", dll.  Saya tidak akan mengatakan bahwa orang-orang ini salah, tetapi ... </blockquote><p>  Ada sejumlah proyek yang membantu menulis kode PHP yang tidak menghalangi.  Dalam kerangka artikel ini, saya tidak akan sepenuhnya menganalisis semua pro dan kontra, tetapi saya akan mencoba untuk memeriksa masing-masing secara dangkal. </p><br><h5 id="swoolehttpswwwswoolecouk">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swoole</a> </h5><br><p>  Kerangka kerja asinkron yang ditulis berbeda dengan yang lain dalam C dan dikirim sebagai ekstensi ke PHP.  Ia mungkin memiliki indikator kinerja terbaik saat ini. </p><br><p>  Ada implementasi saluran, corutin dan hal-hal lezat lainnya, tetapi ia memiliki 1 minus besar - dokumentasi.  Meskipun sebagian dalam bahasa Inggris, menurut saya itu tidak terlalu detail, dan apinya sendiri tidak terlalu jelas. </p><br><p>  Sedangkan untuk komunitas, itu juga tidak semua sederhana dan tidak ambigu.  Secara pribadi, saya tidak tahu satu pun orang hidup yang menggunakan Swoole dalam pertempuran.  Mungkin saya akan mengatasi ketakutan saya dan pindah ke dia, tetapi ini tidak akan terjadi dalam waktu dekat. </p><br><p>  Untuk minus, Anda juga dapat menambahkan bahwa untuk berkontribusi ke proyek (menggunakan permintaan tarik) dengan perubahan apa pun juga sulit jika Anda tidak tahu C di tingkat yang tepat. </p><br><h5 id="workermanhttpsgithubcomwalkorworkerman">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Workerman</a> </h5><br><p>  Jika kehilangan kecepatan untuk kompetitornya (berbicara tentang Swoole), maka itu tidak terlalu terlihat dan perbedaan dalam sejumlah skenario dapat diabaikan. </p><br><p>  Ini memiliki integrasi dengan ReactPHP, yang pada gilirannya memperluas jumlah implementasi masalah infrastruktur.  Untuk menghemat ruang, saya akan menjelaskan kontra bersama dengan ReactPHP. </p><br><h5 id="reactphphttpsreactphporg">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactPHP</a> </h5><br><p>  Plus termasuk komunitas yang cukup besar dan sejumlah besar contoh.  Kontra mulai muncul dalam proses penggunaan - ini adalah konsep Janji. <br>  Jika Anda perlu melakukan beberapa operasi asinkron, kode berubah menjadi tempat sampah tak berujung lalu (di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh koneksi sederhana ke RabbiqMQ</a> tanpa membuat pertukaran / antrian dan pengikat mereka). </p><br><p>  Dengan beberapa perbaikan dengan file (dianggap norma), Anda bisa mendapatkan implementasi coroutine, yang akan membantu menyingkirkan Promise hell. </p><br><p>  Tanpa proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">recoilphp / recoil,</a> menggunakan ReactPHP, menurut saya, tidak mungkin dalam aplikasi yang waras. </p><br><p>  Selain itu, selain yang lainnya, orang merasa bahwa perkembangannya telah sangat melambat.  Tidak cukup, misalnya, kerja normal dengan PostgreSQL. </p><br><h5 id="amphttpsamphporgamp">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amp</a> </h5><br><p>  Menurut pendapat saya, opsi terbaik yang ada saat ini. <br>  Selain Janji yang biasa, ada implementasi Coroutine, yang sangat memudahkan proses pengembangan dan kode terlihat paling akrab bagi programmer PHP. </p><br><p>  Pengembang terus-menerus menambah dan meningkatkan proyek, dengan umpan balik juga tidak ada masalah. </p><br><p>  Sayangnya, dengan semua kelebihan kerangka kerja, komunitasnya relatif kecil, tetapi pada saat yang sama ada implementasi, misalnya bekerja dengan PostgreSQL, serta semua hal-hal dasar (sistem file, klien http, DNS, dll). </p><br><p>  Saya masih tidak begitu mengerti nasib proyek ext-async, tetapi orang-orang tetap melakukannya.  Apa yang akan terjadi pada ini dalam versi ke-3, waktu akan memberi tahu. </p><br><h3 id="pristupaem-k-realizacii">  Memulai </h3><br><p>  Jadi, kami menyortir bagian teoretis sedikit, saatnya untuk melanjutkan berlatih dan mengisi benjolan. </p><br><p>  Pertama, kami sedikit memformalkan persyaratan: </p><br><ul><li>  Pesan asinkron (konsep <code>message</code> itu sendiri dapat dibagi menjadi 2 jenis) <br><ul><li>  <code>command</code> : menunjukkan kebutuhan untuk menyelesaikan tugas.  Tidak mengembalikan hasil (setidaknya dalam kasus komunikasi asinkron); </li><li>  <code>event</code> : melaporkan setiap perubahan status (misalnya, sebagai hasil dari suatu perintah). </li></ul></li><li>  Format non-blocking untuk bekerja dengan I / O; </li><li>  Kemampuan untuk dengan mudah meningkatkan jumlah prosesor; </li><li>  Kemampuan menulis penangan pesan dalam bahasa apa pun. </li></ul><br><blockquote>  Pesan apa pun pada dasarnya adalah struktur sederhana dan hanya dibagikan oleh semantik.  Penamaan pesan sangat penting dari sudut pandang memahami jenis dan tujuan (meskipun hal ini diabaikan dalam contoh). </blockquote><p>  Untuk daftar persyaratan, implementasi sederhana dari pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Publikasikan / Berlangganan</a> paling cocok. <br>  Untuk memastikan eksekusi terdistribusi, kami akan menggunakan RabbitMQ sebagai broker pesan. </p><br><p>  Prototipe ini ditulis menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactPHP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bunny,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DoctrineDBAL</a> . <br>  Pembaca yang penuh perhatian mungkin memperhatikan bahwa Dbal menggunakan panggilan pemblokiran pdo / mysqli secara internal, tetapi pada tahap saat ini ini tidak terlalu penting, karena Anda harus memahami apa yang harus terjadi pada akhirnya. </p><br><p>  Salah satu masalah adalah kurangnya perpustakaan untuk bekerja dengan PostgreSQL.  Ada beberapa konsep, tetapi ini tidak cukup untuk pekerjaan penuh (lebih lanjut tentang ini di bawah). </p><br><p>  Setelah penelitian singkat, ReactPHP dihilangkan untuk Amp, karena relatif sederhana dan sangat aktif berkembang. </p><br><h5 id="rabbitmq-transport">  Transportasi RabbitMQ </h5><br><p>  Tetapi dengan semua kelebihan Amp, ada 1 masalah: Amp tidak memiliki driver untuk RabbitMQ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelinci</a> hanya mendukung ReactPHP). </p><br><p>  Secara teori, Amp memungkinkan Anda untuk menggunakan Janji dari pesaing.  Tampaknya semuanya harus sederhana, tetapi ReactPHP menggunakan Event Loop untuk bekerja dengan soket di perpustakaan. <br>  Pada satu titik waktu, jelas, dua Event Loops yang berbeda tidak dapat dimulai, jadi saya tidak dapat menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adapt ()</a> . </p><br><p>  Sayangnya, kualitas kode dalam kelinci meninggalkan banyak yang harus diinginkan dan tidak mungkin untuk mengganti satu implementasi dengan yang lain.  Agar tidak menghentikan pekerjaan, diputuskan untuk menulis ulang perpustakaan sedikit sehingga berfungsi dengan Amp dan tidak mengarah ke menghalangi aliran eksekusi. </p><br><p>  Adaptasi ini terlihat sangat menakutkan, sepanjang waktu saya sangat malu akan hal itu, tetapi yang paling penting, itu berhasil.  Nah, karena tidak ada yang lebih permanen daripada sementara, adaptor tetap mengantisipasi seseorang yang tidak terlalu malas untuk berurusan dengan implementasi pengemudi. </p><br><p>  Dan orang seperti itu ditemukan.  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHPinnacle</a> , antara lain, menyediakan implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adaptor yang</a> dirancang untuk Amp. </p><br><blockquote>  Nama penulisnya adalah Anton Shabovta, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan berbicara tentang asynchronous php</a> dalam kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia</a> dan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengembangkan driver</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP di masa depan</a> . </blockquote><br><h5 id="postgresql">  PostgreSQL </h5><br><p>  Fitur kedua dari karya ini adalah interaksi dengan database.  Dalam kondisi PHP "tradisional", semuanya sederhana: kami memiliki koneksi dan semua permintaan dieksekusi secara berurutan. </p><br><p>  Dalam kasus eksekusi asinkron, kita harus dapat secara bersamaan menjalankan beberapa permintaan (misalnya, 3 transaksi).  Agar dapat melakukan ini, implementasi kumpulan koneksi diperlukan. </p><br><p>  Mekanisme kerjanya cukup sederhana: </p><br><ul><li>  kami membuka koneksi <em>N</em> saat startup (atau menunda inisialisasi, bukan intinya); </li><li>  jika perlu, kami mengambil koneksi dari kolam, memastikan bahwa tidak ada orang lain yang dapat menggunakannya; </li><li>  Kami mengeksekusi permintaan dan menghancurkan koneksi atau mengembalikannya ke kolam (lebih disukai). </li></ul><br><p>  Pertama, ini memungkinkan kita untuk memulai beberapa transaksi sekaligus, dan kedua, mempercepat pekerjaan karena kehadiran koneksi yang sudah terbuka.  Amp memiliki komponen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amphp / postgres</a> .  Dia mengurus koneksi: memonitor jumlah mereka, seumur hidup, dan semua ini tanpa menghalangi aliran eksekusi. </p><br><p>  Ngomong-ngomong, saat menggunakan, misalnya, ReactPHP, Anda harus mengimplementasikannya sendiri jika Anda ingin bekerja dengan database. </p><br><h5 id="mutex">  Mutex </h5><br><p>  Untuk operasi aplikasi yang efektif dan, yang paling penting, yang tepat, perlu untuk mengimplementasikan sesuatu yang mirip dengan mutex.  Kita dapat membedakan 3 skenario untuk penggunaannya: </p><br><ul><li>  Dalam kerangka satu proses, mekanisme memori yang sederhana cocok tanpa kelebihan; </li><li>  Jika kita ingin memberikan penguncian dalam beberapa proses, maka kita dapat menggunakan sistem file (tentu saja, dalam mode non-pemblokiran); </li><li>  Jika dalam konteks beberapa server, maka Anda sudah perlu memikirkan sesuatu seperti Zookeeper. </li></ul><br><p>  Mutex diperlukan untuk menyelesaikan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kondisi ras</a> .  Bagaimanapun, kita tidak tahu (dan kita tidak bisa tahu) dalam urutan apa tugas kita akan dilakukan, tetapi bagaimanapun kita harus memastikan integritas data. </p><br><h5 id="logirovaniekonteksty">  Logging / Konteks </h5><br><p>  Untuk penebangan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monolog</a> sudah menjadi standar, tetapi dengan beberapa peringatan: kita tidak dapat menggunakan penangan bawaan, karena akan mengarah pada kunci. <br>  Untuk menulis ke stdOut, Anda dapat mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amphp / log</a> , atau menulis pesan sederhana yang dikirim ke Graylog. </p><br><p>  Karena pada satu saat waktu, kami dapat memproses banyak tugas, dan saat merekam log, Anda perlu memahami dalam konteks apa data ditulis.  Selama percobaan, diputuskan untuk membuat <code>trace_id</code> ( <code>trace_id</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terdistribusi</a> ).  Intinya adalah bahwa seluruh rantai panggilan harus disertai oleh pengenal pass-through yang dapat dilacak.  Selain itu, pada saat menerima pesan, <code>package_id</code> dihasilkan, yang menunjukkan dengan tepat pesan yang diterima. </p><br><p>  Dengan demikian, menggunakan kedua pengidentifikasi, kita dapat dengan mudah melacak apa yang dirujuk catatan tertentu.  Masalahnya adalah bahwa dalam PHP tradisional semua catatan yang kita dapatkan di log terutama dalam urutan di mana mereka ditulis.  Dalam kasus eksekusi asinkron, tidak ada pola dalam urutan entri. </p><br><h5 id="terminating">  Mengakhiri </h5><br><p>  Lain dari nuansa pengembangan asinkron adalah mengendalikan shutdown daemon kita.  Jika Anda hanya mematikan proses, maka semua tugas yang sedang berjalan tidak akan selesai dan data akan hilang. Dalam pendekatan yang biasa, ada masalah seperti itu, tetapi tidak begitu hebat, karena hanya satu tugas yang dilakukan pada satu waktu. </p><br><p>  Untuk menyelesaikan eksekusi dengan benar, kita perlu: </p><br><ul><li>  Berhenti berlangganan dari antrian.  Dengan kata lain, buatlah mustahil untuk menerima pesan baru; </li><li>  Selesaikan semua tugas yang tersisa (tunggu untuk menyelesaikan janji); </li><li>  Dan hanya setelah itu selesai skrip. </li></ul><br><h5 id="utechki-otladka">  Kebocoran, debugging </h5><br><p>  Bertentangan dengan kepercayaan umum, dalam PHP modern tidaklah begitu mudah untuk menghadapi situasi di mana kebocoran memori terjadi.  Perlu untuk melakukan sesuatu yang benar-benar salah. </p><br><p>  Namun, pernah berhadapan dengan ini, tetapi karena kecerobohan dangkal.  Selama implementasi detak jantung, timer baru ditambahkan setiap 40 detik untuk menanyakan koneksi.  Tidak sulit menebak bahwa setelah beberapa waktu penggunaan memori mulai merayap dan cukup cepat. </p><br><p>  Selain itu, antara lain, ia menulis sebuah pengamat sederhana yang secara opsional akan mulai setiap 10 menit dan memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gc_collect_cycles ()</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gc_mem_caches ()</a> . <br>  Tetapi pemaksaan awal pemulung bukanlah sesuatu yang perlu dan mendasar. </p><br><p>  Agar dapat terus melihat penggunaan memori, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemoryUsageProcessor</a> standar telah ditambahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencatatan</a> . </p><br><p>  Jika Anda mendapatkan gagasan bahwa Event Loop memblokir sesuatu, ini juga dapat dengan mudah diperiksa: cukup sambungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LoopBlockWatcher</a> . </p><br><p>  Tetapi Anda perlu memastikan bahwa pengamat ini tidak memulai di lingkungan produksi.  Fitur ini digunakan secara eksklusif selama pengembangan. </p><br><h3 id="rezultaty">  Hasil </h3><br><p>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">php-service-bus</a> ,    Message Based . </p><br><p>    ,         : </p><br><pre> <code class="plaintext hljs">composer create-project php-service-bus/skeleton pub-sub-example cd pub-sub-example docker-compose up --build -d</code> </pre> <br><p>   ,      ,   . </p><br><p>   <code>/bin/consumer</code>   ,    . <br>   <code>/src</code>  3 : <code>Ping</code>   ; <code>Pong</code> :    ; <code>PingService</code> : ,   . <br>     <code>PingService</code> ,      2 : </p><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@CommandHandler</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ping $command, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $context-&gt;delivery(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pong()); } <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@EventListener</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenPong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pong $event, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $context-&gt;logContextMessage(<span class="hljs-string"><span class="hljs-string">'Pong message received'</span></span>); }</code> </pre> <br><ul><li> <code>handle</code>    (        1 ).      <code>@CommandHandler</code> ; <br><ul><li>   Promise ,        RabbitMQ (   <code>delivery()</code> ).       ,   RabbitMQ    . </li></ul></li><li> <code>whenPong</code> â€”   <code>Pong</code> .            .     <code>@EventListener</code> ; <br><blockquote>  ,     â€”   . , , ,     .     php-service-bus  , ,            . <br></blockquote></li></ul><br><p>     2 : ,   (  )  .          ,     ,     (, ). </p><br><p>     <code>Ping</code> ,      <code>Pong</code> .     . </p><br><p>    ,       RabbitMQ: </p><br><pre> <code class="plaintext hljs">tools/ping</code> </pre> <br><p>    ,  php-service-bus     ,  Message based . </p><br><p> Ping\Pong,    â€” ,  ,  <code>Hello, world</code>       . </p><br><p>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p>     - ,    , , Saga pattern (Process manager)        . </p><br><h3 id="nu-i-kak-zhe-ne-pomeryatsya">       </h3><br><p>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  symfony/messenger</a> . </p><br><p>    ,      ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451916/">https://habr.com/ru/post/id451916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451902/index.html">Kamp Pengembang Microsoft Azure Rusia</a></li>
<li><a href="../id451904/index.html">Terkadang lebih banyak lebih sedikit. Ketika penurunan beban menyebabkan peningkatan penundaan</a></li>
<li><a href="../id451906/index.html">Exchange Vulnerability: Cara Mendeteksi Peningkatan Privilege ke Administrator Domain</a></li>
<li><a href="../id451908/index.html">Sejarah komputer: malam di Yandex Museum</a></li>
<li><a href="../id451912/index.html">Jaringan saraf mendalam MuseNet menulis musik</a></li>
<li><a href="../id451918/index.html">Untuk pertanyaan TI</a></li>
<li><a href="../id451920/index.html">Optimalkan penyimpanan email di Zimbra Collaboration Suite</a></li>
<li><a href="../id451922/index.html">Aritmatika titik tetap dalam C ++</a></li>
<li><a href="../id451926/index.html">Tentang kode-hidup setelah 130 aliran</a></li>
<li><a href="../id451928/index.html">Cara mengatur analitik web pada halaman AMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>