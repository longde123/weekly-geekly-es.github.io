<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•® ‚õèÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèæ Jarum dalam tumpukan sesi, atau bytecode ekspresi reguler üêù üíö ü§≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="17 miliar acara, 60 juta sesi pengguna, dan sejumlah besar tanggal virtual terjadi di Badoo setiap hari. Setiap acara disimpan dengan rapi dalam datab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jarum dalam tumpukan sesi, atau bytecode ekspresi reguler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433054/"><p><img src="https://habrastorage.org/webt/kz/rl/nu/kzrlnugblhii_j4jrsqzdk9fsgo.jpeg"></p><br><p>  17 miliar acara, 60 juta sesi pengguna, dan sejumlah besar tanggal virtual terjadi di Badoo setiap hari.  Setiap acara disimpan dengan rapi dalam database relasional untuk analisis selanjutnya dalam SQL dan seterusnya. </p><br><p>  Basis data transaksional terdistribusi modern dengan puluhan terabyte data - keajaiban teknik yang nyata.  Tetapi SQL, sebagai perwujudan aljabar relasional dalam sebagian besar implementasi standar, belum memungkinkan kami untuk merumuskan pertanyaan dalam hal tupel yang dipesan. </p><br><p>  Dalam artikel terakhir dalam seri pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">virtual</a> , saya akan berbicara tentang pendekatan alternatif untuk menemukan sesi yang menarik - mesin ekspresi reguler ( <a href="">Pig Match</a> ), yang didefinisikan untuk urutan kejadian. </p><br><p>  Mesin virtual, bytecode, dan kompiler sudah termasuk gratis! </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Satu, Pengantar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Dua, Mengoptimalkan</a> <br>  Bagian Tiga, diterapkan (saat ini) </p><br><h1 id="o-sobytiyah-i-sessiyah">  Tentang acara dan sesi </h1><br><p>  Misalkan kita sudah memiliki gudang data yang memungkinkan Anda untuk dengan cepat dan berurutan melihat acara dari setiap sesi pengguna. </p><br><p> Kami ingin menemukan sesi dengan permintaan seperti "hitung semua sesi di mana ada acara yang ditentukan selanjutnya", "temukan bagian dari sesi yang dijelaskan oleh pola tertentu", "kembalikan bagian sesi yang terjadi setelah pola yang diberikan" atau "hitung berapa banyak sesi yang mencapai bagian tertentu templat. "  Ini dapat berguna untuk berbagai jenis analisis: mencari sesi yang mencurigakan, analisis saluran, dll. </p><br><p>  Entri yang diinginkan bagaimanapun harus dijelaskan.  Dalam bentuknya yang paling sederhana, tugas ini mirip dengan menemukan substring dalam teks;  kami ingin memiliki alat yang lebih kuat - ekspresi reguler.  Implementasi modern dari mesin ekspresi reguler paling sering menggunakan (coba tebak!) Mesin virtual. </p><br><p>  Pembuatan mesin virtual kecil untuk sesi pencocokan dengan ekspresi reguler akan dibahas di bawah ini.  Tapi pertama-tama, kami akan mengklarifikasi definisi. </p><br><p>  <em>Suatu peristiwa</em> terdiri dari jenis peristiwa, waktu, konteks, dan satu set atribut yang spesifik untuk setiap jenis. </p><br><p>  <em>Jenis</em> dan <em>konteks</em> setiap peristiwa adalah bilangan bulat dari daftar yang telah ditentukan.  Jika semuanya jelas dengan jenis acara, maka konteksnya, misalnya, jumlah layar tempat peristiwa yang diberikan terjadi. </p><br><p>  <em>Atribut</em> peristiwa adalah bilangan bulat arbitrer yang artinya ditentukan oleh jenis peristiwa.  Suatu peristiwa mungkin tidak memiliki atribut, atau mungkin ada beberapa. </p><br><p>  <em>Sesi</em> adalah urutan peristiwa yang diurutkan berdasarkan waktu. </p><br><p>  Tapi mari kita turun ke bisnis.  Dengungan itu, seperti kata mereka, mereda, dan aku naik ke atas panggung. </p><br><h1 id="sravnivaem-po-bumazhke">  Bandingkan di selembar kertas </h1><br><p><img src="https://habrastorage.org/webt/gu/ec/dw/guecdwuc3rhjl1oc6cvuk-4ec9k.jpeg"></p><br><p>  Fitur dari mesin virtual ini adalah kepasifan sehubungan dengan peristiwa input.  Kami tidak ingin menyimpan seluruh sesi dalam memori dan memungkinkan mesin virtual untuk beralih secara independen dari satu acara ke acara lainnya.  Sebagai gantinya, kami akan memberi makan acara dari sesi ke mesin virtual satu per satu. </p><br><p>  Mari mendefinisikan fungsi antarmuka: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">matcher *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *matcher)</span></span></span></span>;</code> </pre> <br><p>  Jika semuanya jelas dengan fungsi matcher_create dan matcher_destroy, maka matcher_accept layak dikomentari.  Fungsi matcher_accept menerima mesin virtual dan peristiwa berikutnya (32 bit, di mana 16 bit untuk jenis acara dan 16 bit untuk konteks), dan mengembalikan kode yang menjelaskan apa yang harus dilakukan oleh kode pengguna selanjutnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { <span class="hljs-comment"><span class="hljs-comment">//       MATCH_NEXT, //    ,      MATCH_OK, //       ,      MATCH_FAIL, //     MATCH_ERROR, } match_result;</span></span></code> </pre><br><p>  Opcode mesin virtual: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { <span class="hljs-comment"><span class="hljs-comment">//  ,      OP_ABORT, //      ( -  ) OP_NAME, //     ( -  ) OP_SCREEN, //    OP_NEXT, //    OP_MATCH, } matcher_opcode;</span></span></code> </pre><br><p>  Loop utama mesin virtual: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP() \ (*m-&gt;ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG() \ ((void)(m-&gt;ip += 2), (m-&gt;ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + m-&gt;ip[-1]) for (;;) { uint8_t instruction = NEXT_OP(); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(); if (event_name(next_event) != name) return MATCH_FAIL; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(); if (event_screen(next_event) != screen) return MATCH_FAIL; break; } case OP_NEXT:{ return MATCH_NEXT; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre> <br><p>  Dalam versi sederhana ini, mesin virtual kami secara berurutan cocok dengan pola yang dijelaskan oleh bytecode dengan peristiwa yang masuk.  Dengan demikian, ini bukan perbandingan singkat dari <em>awalan</em> dua baris: templat yang diinginkan dan jalur input. </p><br><p>  Awalan adalah awalan, tetapi kami ingin menemukan pola yang diinginkan tidak hanya di awal, tetapi juga di tempat sewenang-wenang dalam sesi.  Solusi naif adalah memulai kembali pencocokan dari setiap acara sesi.  Tapi ini menyiratkan tampilan ganda dari masing-masing peristiwa dan makan bayi algoritmik. </p><br><p>  <a href="">Contoh</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama dalam</a> seri, pada dasarnya, mensimulasikan memulai kembali pertandingan menggunakan rollback (pengulangan bahasa Inggris).  Kode dalam contoh terlihat, tentu saja, lebih ramping daripada yang diberikan di sini, tetapi masalahnya belum hilang: masing-masing acara harus diperiksa berkali-kali. </p><br><p>  Anda tidak bisa hidup seperti itu. </p><br><h1 id="ya-esche-raz-ya-i-snova-ya">  Aku, aku lagi dan aku lagi </h1><br><p><img src="https://habrastorage.org/webt/bq/ue/gt/bquegtp3mpd4rxv65f1fk-svdjk.jpeg"></p><br><p>  Sekali lagi marilah kita menguraikan masalah: kita harus mencocokkan templat dengan peristiwa yang masuk, mulai dari masing-masing peristiwa yang memulai perbandingan baru.  Jadi mengapa kita tidak melakukan itu saja?  Biarkan mesin virtual berjalan pada acara yang masuk dalam beberapa utas! </p><br><p>  Untuk melakukan ini, kita perlu mendapatkan entitas baru - aliran.  Setiap utas menyimpan satu penunjuk - ke instruksi saat ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher_thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; } matcher_thread;</code> </pre><br><p>  Tentu, sekarang di mesin virtual itu sendiri kita tidak akan menyimpan pointer eksplisit.  Itu akan diganti oleh dua daftar utas (lebih banyak tentangnya di bawah): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytecode; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the current event */</span></span> matcher_thread current_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> current_thread_num; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the event to follow */</span></span> matcher_thread next_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> next_thread_num; } matcher;</code> </pre><br><p>  Dan inilah loop utama yang diperbarui: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP(thread) \ (*(thread).ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG(thread) \ ((void)((thread).ip += 2), ((thread).ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + (thread).ip[-1]) /*         - */ add_current_thread(m, initial_thread(m)); //         for (size_t thread_i = 0; thread_i &lt; m-&gt;current_thread_num; thread_i++ ) { matcher_thread current_thread = m-&gt;current_threads[thread_i]; bool thread_done = false; while (!thread_done) { uint8_t instruction = NEXT_OP(current_thread); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(current_thread); //  ,      ,    //     next_threads,    if (event_name(next_event) != name) thread_done = true; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(current_thread); if (event_screen(next_event) != screen) thread_done = true; break; } case OP_NEXT:{ //    , ..      // next_threads add_next_thread(m, current_thread); thread_done = true; break; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } } /*      ,    */ swap_current_and_next(m); return MATCH_NEXT; #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre><br><p>  Pada setiap acara yang diterima, pertama-tama kita menambahkan utas baru ke daftar current_threads, memeriksa templat dari awal, setelah itu kita mulai melintasi daftar current_threads, mengikuti setiap penunjuk dengan mengikuti instruksi. </p><br><p>  Jika instruksi NEXT ditemukan, maka utas ditempatkan dalam daftar next_threads, yaitu, ia menunggu acara berikutnya diterima. </p><br><p>  Jika pola utas tidak cocok dengan acara yang diterima, maka utas seperti itu tidak ditambahkan ke daftar next_threads. </p><br><p>  Instruksi MATCH segera keluar dari fungsi, melaporkan kode kembali yang polanya cocok dengan sesi. </p><br><p>  Setelah selesai merangkak dari daftar aliran, daftar saat ini dan selanjutnya ditukar. </p><br><p>  Sebenarnya itu saja.  Kita dapat mengatakan bahwa kita benar-benar melakukan apa yang kita inginkan: pada saat yang sama kita memeriksa beberapa templat, meluncurkan satu proses pencocokan baru untuk setiap acara sesi. </p><br><h1 id="mnozhestvennye-lichnosti-i-vetvleniya-v-shablonah">  Banyak Identitas dan Cabang di Templat </h1><br><p><img src="https://habrastorage.org/webt/8l/gv/-e/8lgv-e5bp1xhv0ksukeacrhasaq.jpeg"></p><br><p>  Mencari templat yang menggambarkan urutan kejadian linear, tentu saja, berguna, tetapi kami ingin mendapatkan ekspresi reguler yang lengkap.  Dan aliran yang kita buat pada tahap sebelumnya juga berguna di sini. </p><br><p>  Misalkan kita ingin menemukan urutan dua atau tiga peristiwa yang menarik bagi kita, sesuatu seperti ekspresi reguler pada baris: "a? Bc".  Dalam urutan ini, simbol "a" adalah opsional.  Bagaimana cara mengekspresikannya dalam bytecode?  Mudah! </p><br><p>  Kita dapat memulai <em>dua</em> utas, satu utas untuk setiap kasus: dengan simbol "a" dan tanpa itu.  Untuk melakukan ini, kami memperkenalkan instruksi tambahan (dari addr1 jenis SPLIT, addr2), yang memulai dua utas dari alamat yang ditentukan.  Selain SPLIT, JUMP juga berguna bagi kami, yang hanya melanjutkan eksekusi dengan instruksi yang ditentukan dalam argumen langsung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { OP_ABORT, OP_NAME, OP_SCREEN, OP_NEXT, <span class="hljs-comment"><span class="hljs-comment">//     OP_JUMP, //         OP_SPLIT, OP_MATCH, //     OP_NUMBER_OF_OPS, } matcher_opcode;</span></span></code> </pre> <br><p>  Pengulangan itu sendiri dan petunjuk lainnya tidak berubah - kami hanya memperkenalkan dua penangan baru: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... case OP_JUMP:{ /*   ,      */ uint16_t offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, offset)); break; } case OP_SPLIT:{ /*        */ uint16_t left_offset = NEXT_ARG(current_thread); uint16_t right_offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, left_offset)); add_current_thread(m, create_thread(m, right_offset)); break; } // ...</span></span></code> </pre><br><p>  Perhatikan bahwa instruksi menambahkan utas ke daftar saat ini, yaitu, mereka terus bekerja dalam konteks acara saat ini.  Thread di mana cabang terjadi tidak masuk ke daftar utas berikut. </p><br><p>  Hal yang paling mengejutkan dalam mesin virtual ekspresi reguler ini adalah bahwa utas kami dan pasangan instruksi ini cukup untuk mengekspresikan hampir semua konstruksi yang diterima secara umum saat mencocokkan string. </p><br><h1 id="regulyarnye-vyrazheniya-na-sobytiyah">  Ekspresi reguler pada acara </h1><br><p>  Sekarang kita memiliki mesin dan alat virtual yang sesuai untuk itu, kita sebenarnya dapat menangani sintaks untuk ekspresi reguler kita. </p><br><p>  Pencatatan opcode secara manual untuk program yang lebih serius dengan cepat hilang.  Terakhir kali saya tidak melakukan parser lengkap, tetapi pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">true-grue</a> menunjukkan kemampuan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">raddsl-</a> nya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan bahasa</a> mini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PigletC</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagai</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> .  Saya sangat terkesan dengan singkatnya kode sehingga dengan bantuan raddsl saya menulis sebuah kompiler kecil ekspresi reguler string dalam seratus atau dua ratus dalam Python.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompiler</a> dan instruksi penggunaannya ada di GitHub.  Hasil kompiler dalam bahasa assembly dipahami oleh utilitas yang membaca dua file (sebuah program untuk mesin virtual dan daftar acara sesi untuk verifikasi). </p><br><p>  Untuk memulainya, kami membatasi diri pada jenis dan konteks acara.  Jenis acara dilambangkan dengan satu angka;  jika Anda perlu menentukan konteks, tentukan melalui titik dua.  Contoh paling sederhana: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13" # ,     13 NEXT NAME 13 MATCH</code> </pre> <br><p>  Sekarang contoh dengan konteks: </p><br><pre> <code class="plaintext hljs">python regexp/regexp.py "13:12" #  13,  12 NEXT NAME 13 SCREEN 12 MATCH</code> </pre> <br><p>  Acara yang berturut-turut harus dipisahkan entah bagaimana (misalnya, oleh spasi): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13 11 10:9" 08:40:52 NEXT NAME 13 NEXT NAME 11 NEXT NAME 10 SCREEN 9 MATCH</code> </pre> <br><p>  Template lebih menarik: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "12|13" SPLIT L0 L1 L0: NEXT NAME 12 JUMP L2 L1: NEXT NAME 13 L2: MATCH</code> </pre> <br><p>  Perhatikan garis yang diakhiri dengan tanda titik dua.  Ini adalah tag.  Instruksi SPLIT membuat dua utas yang melanjutkan eksekusi dari label L0 dan L1, dan JUMP pada akhir cabang pertama dari eksekusi cukup melanjutkan ke akhir cabang. </p><br><p>  Anda dapat memilih antara rantai ekspresi lebih benar dengan mengelompokkan berikutnya dalam tanda kurung: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "(1 2 3)|4" SPLIT L0 L1 L0: NEXT NAME 1 NEXT NAME 2 NEXT NAME 3 JUMP L2 L1: NEXT NAME 4 L2: MATCH</code> </pre> <br><p>  Peristiwa sewenang-wenang ditunjukkan oleh sebuah titik: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py ". 1" NEXT NEXT NAME 1 MATCH</code> </pre> <br><p>  Jika kami ingin menunjukkan bahwa selanjutnya adalah opsional, maka kami memberikan tanda tanya setelahnya: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1 2 3? 4" NEXT NAME 1 NEXT NAME 2 SPLIT L0 L1 L0: NEXT NAME 3 L1: NEXT NAME 4 MATCH</code> </pre> <br><p>  Tentu saja, beberapa pengulangan reguler (plus atau tanda bintang) juga umum dalam ekspresi reguler: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1+ 2" L0: NEXT NAME 1 SPLIT L0 L1 L1: NEXT NAME 2 MATCH</code> </pre> <br><p>  Di sini kita cukup menjalankan instruksi SPLIT berkali-kali, memulai utas baru pada setiap siklus. </p><br><p>  Demikian pula dengan tanda bintang: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1* 2" L0: SPLIT L1 L2 L1: NEXT NAME 1 JUMP L0 L2: NEXT NAME 2 MATCH</code> </pre> <br><p><img src="https://habrastorage.org/webt/g-/ud/3s/g-ud3s00i4ccyhf4lp5huusjlyu.jpeg"></p><br><h1 id="perspektiva">  Perspektif </h1><br><p>  Ekstensi lain ke mesin virtual yang dijelaskan mungkin berguna. </p><br><p>  Misalnya, dapat dengan mudah diperluas dengan memeriksa atribut acara.  Untuk sistem nyata, saya kira menggunakan sintaksis seperti "1: 2 {3: 4, 5:&gt; 3}", yang berarti: event 1 dalam konteks 2 dengan atribut 3 memiliki nilai 4 dan nilai atribut 5 lebih besar dari 3. Atribut di sini Anda bisa meneruskannya dalam array ke fungsi matcher_accept. </p><br><p>  Jika Anda juga melewatkan interval waktu antara peristiwa ke matcher_accept, maka Anda dapat menambahkan sintaks ke bahasa templat yang memungkinkan Anda untuk melewatkan waktu di antara acara: "1 mindelta (120) 2", yang berarti: peristiwa 1, maka intervalnya setidaknya 120 detik, peristiwa 2 Dikombinasikan dengan mempertahankan urutan, ini memungkinkan Anda untuk mengumpulkan informasi tentang perilaku pengguna antara dua peristiwa berikutnya. </p><br><p>  Hal-hal berguna lainnya yang relatif mudah ditambahkan adalah: menjaga urutan ekspresi reguler, memisahkan tanda bintang dan operator tanda plus dan serakah, dan sebagainya.  Dalam hal teori automata, mesin virtual kami adalah robot hingga nondeterministic, untuk implementasi yang tidak sulit untuk melakukan hal-hal seperti itu. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Sistem kami dikembangkan untuk antarmuka pengguna yang cepat, oleh karena itu mesin penyimpanan sesi ditulis sendiri dan dioptimalkan secara khusus untuk bagian melalui semua sesi.  Semua milyaran peristiwa yang dipecah dalam sesi diperiksa terhadap pola dalam hitungan detik pada satu server. </p><br><p>  Jika kecepatannya tidak terlalu penting bagi Anda, maka sistem yang serupa dapat dirancang sebagai ekstensi untuk beberapa sistem penyimpanan data yang lebih standar seperti database relasional tradisional atau sistem file terdistribusi. </p><br><p>  By the way, dalam versi terbaru dari <a href="">standar SQL</a> fitur yang mirip dengan yang dijelaskan dalam artikel telah muncul, dan database individu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vertica</a> ) telah menerapkannya.  Yandex ClickHouse, pada gilirannya, mengimplementasikan bahasa seperti SQL-nya sendiri, tetapi juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi yang serupa</a> . </p><br><p>  Mengalihkan perhatian dari kejadian dan ekspresi reguler, saya ingin mengulangi bahwa penerapan mesin virtual jauh lebih luas daripada yang terlihat pada pandangan pertama.  Teknik ini cocok dan banyak digunakan dalam semua kasus ketika ada kebutuhan untuk secara jelas membedakan antara primitif bahwa mesin sistem memahami dan subsistem "depan", yaitu, misalnya, beberapa DSL atau bahasa pemrograman. </p><br><p>  Ini menyimpulkan serangkaian artikel tentang berbagai penggunaan penerjemah bytecode dan mesin virtual.  Saya harap para pembaca Habr menyukai serial ini dan, tentu saja, saya akan dengan senang hati menjawab pertanyaan apa pun tentang topik ini. </p><br><h1 id="neformalnyy-spisok-literatury">  Referensi Informal </h1><br><p>  Penerjemah bytecode untuk bahasa pemrograman adalah topik khusus, dan hanya ada sedikit literatur tentangnya.  Secara pribadi, saya menyukai buku Ian Craig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> Virtual Machines, meskipun tidak menggambarkan implementasi penerjemah sebagai mesin abstrak - model matematika yang mendasari berbagai bahasa pemrograman. </p><br><p>  Dalam arti yang lebih luas, buku lain dikhususkan untuk mesin virtual - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Mesin Virtual: Platform Fleksibel untuk Sistem dan Proses"</a> ("Mesin Virtual: Platform Serbaguna untuk Sistem dan Proses").  Ini adalah pengantar berbagai aplikasi virtualisasi, yang mencakup virtualisasi bahasa, proses, dan arsitektur komputer secara umum. </p><br><p>  Aspek praktis dari pengembangan mesin ekspresi reguler jarang dibahas dalam literatur kompiler populer.  Pig Match dan contoh dari artikel pertama didasarkan pada ide-ide dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel yang</a> luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> Russ Cox, salah satu pengembang mesin Google RE2. </p><br><p>  Teori ekspresi reguler disajikan dalam semua buku teks akademik tentang kompiler.  Merupakan kebiasaan untuk merujuk pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Buku Naga" yang</a> terkenal, tetapi saya akan merekomendasikan mulai dengan tautan di atas. </p><br><p>  Saat mengerjakan artikel ini, saya pertama kali menggunakan sistem yang menarik untuk pengembangan kompiler cepat untuk Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">raddsl</a> , yang menjadi milik pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">true-grue</a> (terima kasih, Peter!).  Jika Anda dihadapkan dengan tugas membuat prototipe bahasa atau dengan cepat mengembangkan semacam DSL, Anda harus memperhatikannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433054/">https://habr.com/ru/post/id433054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433044/index.html">Kode sumber OpenJDK mengandung terlalu banyak kata-kata umpatan</a></li>
<li><a href="../id433046/index.html">Seluruh kebenaran tentang RTOS. Artikel # 25. Saluran Data: Pengantar dan Layanan Dasar</a></li>
<li><a href="../id433048/index.html">Bagaimana 2019 akan mengubah toko-toko Rusia</a></li>
<li><a href="../id433050/index.html">Dari perancang pesawat hingga programmer dalam satu tahun, atau bagaimana menjadi Jedi</a></li>
<li><a href="../id433052/index.html">snap & flatpack - tragedi komunitas</a></li>
<li><a href="../id433056/index.html">Kementerian Komunikasi memperketat aturan untuk perangkat lunak dengan elemen yang berasal dari luar negeri</a></li>
<li><a href="../id433058/index.html">Quintet sebagai entitas dasar untuk menggambarkan area subjek</a></li>
<li><a href="../id433060/index.html">Kenapa saya tidak percaya microbenchmark</a></li>
<li><a href="../id433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Bandingkan Kamera CCTV</a></li>
<li><a href="../id433064/index.html">Manajemen insiden: "Anda tidak bisa menyerah" atau seni menempatkan koma</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>