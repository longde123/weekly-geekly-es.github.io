<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎾 🧑🏾‍🤝‍🧑🏻 🍒 Lamentando a ausência em C ++ de uma estática completa se ou ... 👩‍🍳 🔜 👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... como preencher uma classe de modelo com conteúdos diferentes, dependendo dos valores dos parâmetros do modelo? 


 Era uma vez, por algum tempo, q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lamentando a ausência em C ++ de uma estática completa se ou ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449122/"><p> <strong>... como preencher uma classe de modelo com conteúdos diferentes, dependendo dos valores dos parâmetros do modelo?</strong> </p><br><p> Era uma vez, por algum tempo, que a linguagem D começou a ser feita como "o C ++ correto", levando em conta a experiência adquirida em C ++.  Com o tempo, D se tornou uma linguagem menos complexa e mais expressiva que o C ++.  E o C ++ já começou a espionar D. Por exemplo, apareceu no C ++ 17 <code>if constexpr</code> , na minha opinião, é um empréstimo direto de D, cujo protótipo era <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">D-shny estático se</a> . </p><br><p>  Infelizmente, <code>if constexpr</code> no C ++ não tem o mesmo poder que o <code>static if</code> no D. Há <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">razões para isso</a> , mas ainda existem casos em que você só pode se arrepender de que <code>if constexpr</code> no C ++ não permite controlar o conteúdo do C + + classe.  Eu gostaria de falar sobre um desses casos. </p><br><p>  Falaremos sobre como criar uma classe de modelo, cujo conteúdo (isto é, a composição dos métodos e a lógica de alguns dos métodos) mudaria dependendo de quais parâmetros foram passados ​​para essa classe de modelo.  Um exemplo é retirado da vida real, da experiência de desenvolver uma <a href="">nova versão do SObjectizer</a> . </p><br><h1 id="zadacha-kotoruyu-trebuetsya-reshit">  A tarefa a ser resolvida </h1><br><p>  É necessário criar uma versão inteligente do "ponteiro inteligente" para armazenar objetos de mensagem.  Para que você possa escrever algo como: </p><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;my_message&gt; msg{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message{...} }; send(target, msg); send(another_target, msg);</code> </pre> <br><p>  O truque dessa classe <code>message_holder_t</code> é que existem três fatores importantes a serem considerados. </p><br><h2 id="ot-chego-otnasledovan-tip-soobscheniya">  Qual é o tipo de mensagem herdada? </h2><br><p>  Os tipos de mensagens que parametrizam <code>message_holder_t</code> são divididos em dois grupos.  O primeiro grupo são mensagens herdadas do tipo base especial <code>message_t</code> .  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so5_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; so5_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  Nesse caso, o message_holder_t dentro de si deve conter apenas um ponteiro para um objeto desse tipo.  O mesmo ponteiro deve ser retornado nos métodos getter.  Ou seja, para o caso do herdeiro de <code>message_t</code> deve haver algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;M&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg.get(); } };</code> </pre> <br><p>  O segundo grupo são mensagens de tipos arbitrários de usuários que não são herdadas de <code>message_t</code> .  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; user_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  Instâncias desses tipos no SObjectizer não são enviadas por si mesmas, mas são incluídas em um wrapper especial, <code>user_type_message_t&lt;M&gt;</code> , que já é herdado de <code>message_t</code> .  Portanto, para esses tipos, <code>message_holder_t</code> deve conter um ponteiro para <code>user_type_message_t&lt;M&gt;</code> dentro dele, e os métodos getter devem retornar um ponteiro para M: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">user_type_message_t</span></span>&lt;M&gt;&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(m_msg-&gt;m_payload); } };</code> </pre> <br><h2 id="immutabelnost-ili-mutabelnost-soobscheniy">  Imunidade ou mutabilidade das mensagens </h2><br><p>  O segundo fator é a divisão das mensagens em imutável e mutável.  Se a mensagem é imutável (e, por padrão, é imutável), os métodos getter devem retornar um ponteiro constante para a mensagem.  E se mutável, os getters devem retornar um ponteiro não constante.  I.e.  deve ser algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-comment"><span class="hljs-comment">//  . const int a = msg1-&gt;a_; // OK. msg1-&gt;a_ = 0; //     ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg2{...}; //  . const int a = msg2-&gt;a_; // OK. msg2-&gt;a_ = 0; // OK.</span></span></code> </pre> <br><h2 id="shared_ptr-vs-unique_ptr">  shared_ptr vs unique_ptr </h2><br><p>  O terceiro fator é a lógica do comportamento de <code>message_holder_t</code> como um ponteiro inteligente.  Uma vez que ele deve se comportar como <code>std::shared_ptr</code> , ou seja,  Você pode ter vários message_holders referindo-se à mesma instância de mensagem.  E uma vez que ele deve se comportar como <code>std::unique_ptr</code> , ou seja,  apenas uma instância message_holder pode se referir a uma instância de mensagem. </p><br><p>  Por padrão, o comportamento do <code>message_holder_t</code> deve depender da mutabilidade / imutabilidade da mensagem.  I.e.  com mensagens imutáveis, <code>message_holder_t</code> deve se comportar como <code>std::shared_ptr</code> e com <code>std::unique_ptr</code> mutáveis ​​como <code>std::unique_ptr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg2 = msg; <span class="hljs-comment"><span class="hljs-comment">// OK. message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg3{...}; message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg4 = msg3; // !  ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg5 = std::move(msg3); // OK.</span></span></code> </pre> <br><p>  Mas a vida é uma coisa complicada, então você também deve poder definir manualmente o comportamento do <code>message_holder_t</code> .  Para que você possa criar message_holder para uma mensagem imutável que se comporte como unique_ptr.  E para que você possa criar message_holder para uma mensagem mutável que se comporte como shared_ptr: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> unique_so5_message = so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; so5_message, so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique&gt;; unique_so5_message msg1{...}; unique_so5_message msg2 = msg1; <span class="hljs-comment"><span class="hljs-comment">// !  ! unique_so5_message msg3 = std::move(msg); // OK,   msg3. using shared_user_messsage = so_5::message_holder_t&lt; so_5::mutable_msg&lt;user_message&gt;, so_5::message_ownership_t::shared&gt;; shared_user_message msg4{...}; shared_user_message msg5 = msg4; // OK.</span></span></code> </pre> <br><p>  Assim, quando <code>message_holder_t</code> funciona como shared_ptr, ele deve ter o conjunto usual de construtores e operadores de atribuição: copiar e mover.  Além disso, deve haver um método constante <code>make_reference</code> , que retorna uma cópia do ponteiro armazenado em <code>message_holder_t</code> . </p><br><p>  Mas quando <code>message_holder_t</code> funciona como unique_ptr, o construtor e o operador de cópia devem ser proibidos.  E o método <code>make_reference</code> deve <code>make_reference</code> <em>o</em> ponteiro do objeto <code>message_holder_t</code> : depois de chamar <code>make_reference</code> <code>message_holder_t</code> original deve permanecer vazio. </p><br><h2 id="chut-bolee-formalno">  Um pouco mais formal </h2><br><p>  Então, você precisa criar uma classe de modelo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected&gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> {...};</code> </pre> <br><p>  quais: </p><br><ul><li>  o interior deve ser armazenado <code>intrusive_ptr_t&lt;M&gt;</code> ou <code>intrusive_ptr&lt;user_type_message_t&lt;M&gt;&gt;</code> dependendo de M ser herdado de <code>message_t</code> ; </li><li>  Os métodos getter devem retornar <code>const M*</code> ou <code>M*</code> dependendo da mutabilidade / imutabilidade da mensagem; </li><li>  deve haver um conjunto completo de construtores e operadores de copiar / mover, ou apenas um operador construtor e de mover; </li><li>  O método <code>make_reference()</code> deve retornar uma cópia do intrusive_ptr armazenado ou pegar o valor de intrusive_ptr e deixar o <code>message_holder_t</code> original vazio.  No primeiro caso, <code>make_reference()</code> deve ser constante, no segundo método não constante. </li></ul><br><p>  Os dois últimos itens da lista são determinados pelo parâmetro Ownership (bem como a mutabilidade da mensagem se a <code>autodetected</code> usada para a propriedade). </p><br><h1 id="kak-eto-bylo-resheno">  Como foi decidido </h1><br><p>  Nesta seção, consideraremos todos os componentes que compõem a solução final.  Bem, a solução resultante em si.  Os fragmentos de código limpos de todos os detalhes de distração serão mostrados.  Se alguém estiver interessado no código real, você pode vê-lo <a href="">aqui</a> . </p><br><h2 id="disclaimer">  Isenção de responsabilidade </h2><br><p>  A solução mostrada abaixo não finge ser bonita, ideal ou um modelo.  Foi encontrado, implementado, testado e documentado em pouco tempo, sob pressão de prazos.  Talvez se houvesse mais tempo e mais se empenhasse na busca de uma solução <del>  jovem </del>  sensato e conhecedor do desenvolvedor de C ++ moderno, ele se tornaria mais compacto, mais simples e mais compreensível.  Mas, como se viu, aconteceu ... "Não atire no pianista", em geral. </p><br><h2 id="posledovatelnost-shagov-i-uzhe-gotovaya-shablonnaya-magiya">  Sequência de etapas e magia de modelo pronta </h2><br><p>  Portanto, precisamos ter uma classe com vários conjuntos de métodos.  O conteúdo desses kits deve vir de algum lugar.  De onde </p><br><p>  Em D, poderíamos usar <code>static if</code> e definir diferentes partes da classe, dependendo das diferentes condições.  Em alguns Ruby, podemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">misturar métodos em nossa classe usando o método include</a> .  Mas estamos em C ++, onde até agora nossas possibilidades são muito limitadas: podemos definir um método / atributo diretamente dentro da classe, ou podemos herdar o método / atributo de alguma classe base. </p><br><p>  Não podemos definir métodos / atributos diferentes dentro da classe, dependendo de alguma condição, porque  C ++ <code>if constexpr</code> não for D <code>static if</code> .  Consequentemente, apenas a herança permanece. </p><br><blockquote>  <strong>Upd.</strong>  Como sugerido nos comentários, devo falar com mais cuidado aqui.  Como o C ++ possui SFINAE, podemos ativar / desativar a visibilidade de métodos individuais na classe via SFINAE (ou seja, obter um efeito semelhante ao <code>static if</code> ).  Mas essa abordagem tem duas falhas sérias, na minha opinião,.  Primeiramente, se esses métodos não forem 1-2-3, mas 4-5 ou mais, é tedioso formatar cada um deles usando SFINAE, e isso afeta a legibilidade do código.  Em segundo lugar, o SFINAE não nos ajuda a adicionar / remover atributos de classe (campos). </blockquote><p>  Em C ++, podemos definir várias classes base das quais herdaremos <code>message_holder_t</code> .  E a escolha de uma ou outra classe base já será feita dependendo dos valores dos parâmetros do modelo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: condicional</a> . </p><br><p>  Mas o truque é que precisamos não apenas de um conjunto de classes base, mas de uma pequena cadeia de herança.  No início, haverá uma classe que determinará a funcionalidade geral que será necessária em qualquer caso.  A seguir, serão apresentadas as classes base que determinarão a lógica do comportamento do "ponteiro inteligente".  E então haverá uma classe que determina os getters necessários.  Nesta ordem, consideraremos as classes implementadas. </p><br><p>  Nossa tarefa é simplificada pelo fato de o SObjectizer já possuir uma mágica de modelo pronta <a href="">que determina se uma mensagem é herdada de message_t</a> , bem como <a href="">meios para verificar a mutabilidade da mensagem</a> .  Portanto, na implementação, simplesmente usaremos essa mágica pronta e não nos aprofundaremos nos detalhes de seu trabalho. </p><br><h2 id="obschaya-baza-dlya-hraneniya-ukazatelya">  Base de armazenamento comum do ponteiro </h2><br><p>  Vamos começar com um tipo de base comum que armazena o intrusive_ptr correspondente e também fornece um conjunto comum de métodos que qualquer uma das implementações <code>message_holder_t</code> precisa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_message_holder_impl_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = Payload; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = Envelope; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; msg ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_msg.reset(); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } };</code> </pre> <br><p>  Esta classe de modelo possui dois parâmetros.  O primeiro, Payload, define o tipo que os métodos getter devem usar.  Enquanto o segundo, Envelope, define o tipo para intrusive_ptr.  No caso em que o tipo de mensagem é herdado de <code>message_t</code> esses dois parâmetros terão o mesmo valor.  Mas se a mensagem não for herdada de <code>message_t</code> , o tipo de mensagem será usado como Carga útil e <code>user_type_message_t&lt;Payload&gt;</code> será <code>user_type_message_t&lt;Payload&gt;</code> como Envelope. </p><br><p>  Eu acho que basicamente o conteúdo desta aula não levanta questões.  Mas duas coisas devem ser anotadas separadamente. </p><br><p>  Em primeiro lugar, o ponteiro em si, ou seja,  o atributo m_msg é definido na seção protegida para que os herdeiros das classes tenham acesso a ele. </p><br><p>  Em segundo lugar, para esta classe, o próprio compilador gera todos os construtores necessários e operadores de copiar / mover.  E no nível desta classe, ainda não proibimos nada. </p><br><h2 id="otdelnye-bazy-dlya-shared_ptr--i-unique_ptr-povedeniya">  Bases separadas para o comportamento shared_ptr e unique_ptr </h2><br><p>  Portanto, temos uma classe que armazena um ponteiro para uma mensagem.  Agora podemos definir seus herdeiros, que se comportarão como shared_ptr ou unique_ptr. </p><br><p>  Vamos começar com o caso do comportamento shared_ptr, porque  aqui está o menor código: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg; } };</code> </pre> <br><p>  Nada complicado: herdar de <code>basic_message_holder_impl_t</code> , herdar todos os seus construtores e definir uma implementação simples e não destrutiva de <code>make_reference()</code> . </p><br><p>  Para o caso de unique_ptr-behavior, o código é maior, embora não haja nada complicado: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unique_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg) }; } };</code> </pre> <br><p>  Novamente, herdamos de <code>basic_message_holder_impl_t</code> e herdamos os construtores que precisamos dele (este é o construtor padrão e o construtor de inicialização).  Mas, ao mesmo tempo, definimos os construtores e os operadores de copiar / mover de acordo com a lógica unique_ptr: proibimos a cópia, implementamos a movimentação. </p><br><p>  Também temos um método destrutivo <code>make_reference()</code> . </p><br><p>  Isso é tudo, na verdade.  Resta apenas realizar a escolha entre essas duas classes base ... </p><br><h3 id="vybor-mezhdu-shared_ptr--i-unique_ptr-povedeniem">  Escolhendo entre o comportamento shared_ptr e unique_ptr </h3><br><p>  Para escolher entre o comportamento shared_ptr e unique_ptr, você precisa da seguinte metafunção (metafunction porque "funciona" com tipos em tempo de compilação): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( !is_signal&lt;Msg&gt;::value, <span class="hljs-string"><span class="hljs-string">"Signals can't be used with message_holder"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> P = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> E = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == message_mutability_traits&lt;Msg&gt;::mutability, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared == Ownership, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt; &gt;; };</code> </pre> <br><p>  Essa metafunção aceita os dois parâmetros da lista de parâmetros <code>message_holder_t</code> e, como resultado (ou seja, a definição de um <code>type</code> aninhado), "retorna" o tipo do qual deve ser herdado.  I.e.  <code>shared_message_holder_impl_t</code> ou <code>unique_message_holder_impl_t</code> . </p><br><p>  Dentro da definição de <code>impl_selector</code> você pode ver traços da mágica mencionada acima e sobre os quais não analisamos: <code>message_payload_type&lt;Msg&gt;::payload_type</code> , <code>message_payload_type&lt;Msg&gt;::envelope_type</code> e <code>message_mutability_traits&lt;Msg&gt;::mutability</code> . </p><br><p>  E para usar a função <code>impl_selector</code> foi mais fácil, definiremos um nome mais curto para ela: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> impl_selector&lt;Msg, Ownership&gt;::type;</code> </pre> <br><h2 id="baza-dlya-getter-ov">  Base para getters </h2><br><p>  Portanto, já temos a oportunidade de selecionar uma base que contém um ponteiro e define o comportamento de um "ponteiro inteligente".  Agora precisamos fornecer a essa base os métodos getter.  Por que precisamos de uma classe simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Return_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_accessors_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Base::Base; [[nodiscard]] <span class="hljs-function"><span class="hljs-function">Return_Type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_ptr( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg ); } [[nodiscard]] Return_Type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] Return_Type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } };</code> </pre> <br><p>  Esta é uma classe de modelo que depende de dois parâmetros, mas seu significado é completamente diferente.  O parâmetro Base será o resultado da <code>impl_selector</code> impl_selector mostrada acima.  I.e.  como o parâmetro Base, a classe base é definida da qual herdar. </p><br><p>  É importante observar que, se a herança vier de <code>unique_message_holder_impl_t</code> , para a qual o construtor e o operador de cópia são proibidos, o compilador não poderá gerar o construtor e o operador de cópia para o <code>msg_accessors_t</code> .  É disso que precisamos. </p><br><p>  O tipo da mensagem, o ponteiro / link ao qual será retornado pelos getters, atuará como o parâmetro Return_Type.  O truque é que, para uma mensagem imutável do tipo <code>Msg</code> o parâmetro Return_Type será definido como <code>const Msg</code> .  Enquanto que para uma mensagem mutável do tipo <code>Msg</code> parâmetro Return_Type terá o valor <code>Msg</code> .  Assim, o método <code>get()</code> retornará <code>const Msg*</code> para mensagens imutáveis ​​e apenas <code>Msg*</code> para mensagens mutáveis. </p><br><p>  Usando a função livre <code>get_ptr()</code> resolvemos o problema de trabalhar com mensagens que não são herdadas de <code>message_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> msg.get(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">user_type_message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(msg-&gt;m_payload); }</code> </pre> <br><p>  I.e.  se a mensagem não for herdada de <code>message_t</code> e armazenada como <code>user_type_message_t&lt;Msg&gt;</code> , a segunda sobrecarga será chamada.  E se for herdado, então a primeira sobrecarga. </p><br><h3 id="vybor-konkretnoy-bazy-dlya-getter-ov">  Escolhendo uma base específica para getters </h3><br><p>  Portanto, o modelo <code>msg_accessors_t</code> requer dois parâmetros.  O primeiro é calculado pela <code>impl_selector</code> impl_selector.  Mas, para formar um tipo de base específico a partir de <code>msg_accessors_t</code> , precisamos determinar o valor do segundo parâmetro.  Mais uma meta-função é destinada a isso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accessor_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == Mutability, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type&gt; &gt;; };</code> </pre> <br><p>  Você só pode prestar atenção ao cálculo do parâmetro Return_Type.  Um daqueles poucos casos em que const leste é útil;) </p><br><p>  Bem, para aumentar a legibilidade do código a seguir, uma opção mais compacta para trabalhar com ele: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> accessor_selector&lt;Mutability, Base&gt;::type;</code> </pre> <br><h2 id="itogovyy-naslednik-message_holder_t">  Sucessor final message_holder_t </h2><br><p>  Agora você pode ver o que <code>message_holder_t</code> , para a implementação da qual todas essas classes base e metafunções foram necessárias (parte dos métodos para construir uma instância da mensagem armazenada em message_holder são removidos da implementação): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type::base_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.message_reference(), b.message_reference() ); } };</code> </pre> <br><p>  De fato, tudo o que analisamos acima era necessário para registrar essa "chamada" de duas metafunções: </p><br><pre> <code class="cpp hljs">details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;</code> </pre> <br><p>  Porque  essa não é a primeira opção, mas, como resultado da simplificação e redução do código, posso dizer que formas compactas de metafunções reduzem bastante a quantidade de código e aumentam sua compreensibilidade (se é geralmente apropriado falar aqui sobre compreensibilidade). </p><br><h1 id="a-chto-bylo-by-esli-by">  E o que aconteceria se ... </h1><br><p>  Mas se em C ++ <code>if constexpr</code> fosse tão poderoso quanto <code>static if</code> em D, você poderia escrever algo como: </p><br><div class="spoiler">  <b class="spoiler_title">Versão hipotética com mais avançado se constexpr</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability = details::message_mutability_traits&lt;Msg&gt;::mutability; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Actual_Ownership = (<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique == Ownership || (<span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::mutable_msg == Mutability &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership)) ? <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique : <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> getter_return_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_msg == Mutability, payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, payload_type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; mf ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mf) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::unique == Actual_Ownership )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.m_msg, b.m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-function">getter_return_type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_const_ptr( m_msg ); } [[nodiscard]] getter_return_type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] getter_return_type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::shared == Actual_Ownership)</span></span></span><span class="hljs-function"> </span></span>{ [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m_msg) }; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; m_msg; };</code> </pre> </div></div><br><p>   ,     .       C++ :( <br> (  C++      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ). </p><br><p>  ,       ,             ++.   ,  ,  ,           .   ,        <code>message_holder_t</code> .         ,             ,      <code>if constexpr</code> . </p><br><h1 id="zaklyuchenie">  Conclusão </h1><br><p>   ,         C++. ,     .  ,    ,          . </p><br><p>                ,           . </p><br><p>   ,   ,   ++   ,   .      ,    . , ,            .  ,    .   C++98/03        ,     C++11       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449122/">https://habr.com/ru/post/pt449122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449110/index.html">Corrigido um erro relacionado à incapacidade de usar o alfabeto cirílico nos nomes das pastas IMAP</a></li>
<li><a href="../pt449112/index.html">Nós nos aposentamos - discutimos gadgets de áudio populares que já estão "desatualizados"</a></li>
<li><a href="../pt449114/index.html">Reagir em λambda</a></li>
<li><a href="../pt449118/index.html">Pílula do Demônio do Kremlin</a></li>
<li><a href="../pt449120/index.html">De barba, de óculos escuros e de perfil: situações difíceis para a visão computacional</a></li>
<li><a href="../pt449124/index.html">Tão difícil de encontrar, fácil de perder e impossível de emitir</a></li>
<li><a href="../pt449128/index.html">Principais empresas de desenvolvimento de jogos do mundo</a></li>
<li><a href="../pt449132/index.html">Os 17 principais plugins do Android Studio</a></li>
<li><a href="../pt449134/index.html">Zoo afl</a></li>
<li><a href="../pt449138/index.html">5 razões para o crypto-hat Por que as pessoas de TI não gostam de bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>