<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“³ ğŸ¤ ğŸ‘¨â€âš–ï¸ Buat batas-batas peta yang dibuat secara prosedural ğŸ¤¸ğŸ½ ğŸ’’ ğŸ’¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner terus bekerja pada gim yang dihasilkan secara prosedural dan sekarang telah memutuskan untuk mengatasi masalah merancang perbatasan peta....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat batas-batas peta yang dibuat secara prosedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="gambar"></div><br>  <i>Scott Turner terus bekerja pada gim yang dihasilkan secara prosedural dan sekarang telah memutuskan untuk mengatasi masalah merancang perbatasan peta.</i>  <i>Untuk melakukan ini, ia harus menyelesaikan beberapa masalah sulit dan bahkan membuat bahasanya sendiri untuk menggambarkan batasan.</i> <br><br>  Borders tetap merupakan elemen penting dari kartu fantasi, yang telah ada dalam daftar saya selama beberapa waktu.  Peta fungsional biasanya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">garis perbatasan yang</a> sederhana, tetapi peta fantasi dan peta abad pertengahan, di mana mantan sering meminjam ide, memiliki batas yang cukup bijaksana dan artistik.  Batas-batas ini memperjelas bahwa peta itu sengaja dibuat fantastis, dan memberi penonton rasa heran. <br><br>  Saat ini ada beberapa cara sederhana untuk menggambar batas di gim <b>Dragons Abound</b> saya.  Dia dapat menggambar garis tunggal atau ganda di sekeliling peta dan menambahkan elemen sederhana di sudut-sudutnya, seperti pada gambar-gambar ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  Gim ini juga dapat menambahkan bidang di bagian bawah perbatasan untuk nama peta.  Ada beberapa variasi bidang ini di <b>Dragons Abound</b> , termasuk elemen kompleks seperti kepala sekrup palsu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Ada variabilitas di bidang nama ini, tetapi semuanya dibuat secara manual. <br><br>  Salah satu aspek yang menarik dari batasan kartu fantasi adalah bahwa keduanya kreatif dan templat.  Seringkali mereka terdiri dari sejumlah kecil elemen sederhana yang digabungkan dalam berbagai cara untuk menciptakan hasil yang unik.  Seperti biasa, langkah pertama ketika bekerja dengan topik baru bagi saya adalah mempelajari kumpulan contoh peta, membuat katalog jenis elemen perbatasan, dan mempelajari penampilan mereka. <br><a name="habracut"></a><br>  Batas paling sederhana adalah satu garis di sepanjang tepi peta dan menunjukkan batasnya.  Seperti yang saya katakan di atas, ini juga disebut "garis bingkai": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  Ada juga variasi dengan lokasi perbatasan dalam peta.  Dalam versi ini, peta mencapai tepi gambar, tetapi perbatasan membuat batas virtual di dalam gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Ini dapat dilakukan dengan semua jenis perbatasan, tetapi biasanya hanya digunakan dengan perbatasan sederhana seperti perbatasan bingkai. <br><br>  Konsep desain kartu fantasi yang populer adalah untuk mensimulasikan seolah-olah mereka digambar di atas perkamen lama yang sobek.  Kadang-kadang ini diwujudkan dengan menggambar perbatasan sebagai tepi kasar kertas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Berikut ini contoh yang lebih canggih: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  Dalam pengalaman saya, metode ini menjadi kurang populer karena alat digital mulai digunakan.  Jika Anda ingin kartu tersebut terlihat seperti perkamen lama yang sobek, maka lebih mudah untuk menerapkan tekstur perkamen itu daripada menggambarnya dengan tangan. <br><br>  Alat paling ampuh dalam membuat batas peta adalah pengulangan.  Dalam kasus paling sederhana, cukup untuk mengulang satu baris untuk membuat dua baris: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Anda dapat menambahkan minat pada peta dengan memvariasikan gaya elemen yang diulang, dalam hal ini dengan menggabungkan satu garis tebal dengan satu garis tipis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Tergantung pada elemennya, berbagai variasi gaya dimungkinkan.  Dalam contoh ini, garis berulang, tetapi warnanya berubah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Untuk membuat pola yang lebih kompleks, Anda dapat menggunakan "repeatability berulang".  Perbatasan ini terdiri dari sekitar lima garis tunggal dengan lebar dan jarak yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Perbatasan ini mengulang garis, tetapi memisahkannya sehingga terlihat seperti dua batas tipis yang terpisah.  Pada bagian posting ini saya tidak akan berbicara tentang pemrosesan sudut, tetapi sudut yang berbeda untuk kedua garis juga membantu menciptakan perbedaan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  Apakah ini dua baris, empat, atau enam?  Saya pikir itu semua tergantung pada bagaimana Anda menggambar mereka! <br><br>  Elemen stylization lainnya adalah mengisi ruang antara elemen dengan warna, pola atau tekstur.  Dalam contoh ini, batas menjadi lebih menarik karena warna aksen mengisi antara dua garis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Berikut adalah contoh bagaimana perbatasan diisi dengan pola: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  Juga, elemen dapat ditata sehingga mereka terlihat tiga dimensi.  Berikut adalah peta di mana perbatasan diarsir sehingga terlihat banyak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  Di peta ini, perbatasan diarsir agar terlihat tiga dimensi, dan ini dikombinasikan dengan lokasi perbatasan di dalam tepi peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Elemen perbatasan umum lainnya adalah skala dalam bentuk garis-garis multi-warna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Garis-garis ini membentuk kisi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kisi kartografi</a> ).  Pada peta nyata, skala membantu menentukan jarak, tetapi pada peta fantasi itu terutama merupakan elemen dekoratif. <br><br>  Garis-garis ini biasanya digambar hitam dan putih, tetapi terkadang merah atau warna lain ditambahkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Elemen ini juga dapat dikombinasikan dengan yang lain, seperti dalam contoh ini dengan garis dan skala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Contoh ini agak tidak biasa.  Biasanya skala (jika ada) adalah elemen terdalam dari perbatasan. <br><br>  Pada peta ini, ada skala yang berbeda dengan resolusi yang berbeda (serta catatan rahasia yang aneh!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (Di Reddit, pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AbouBenAdhem</a> memberi tahu saya bahwa tanda rahasia adalah angka 48 dan 47 ditulis dalam huruf Babel. Selain itu, "skala dengan resolusi berbeda" memiliki enam divisi yang dibagi menjadi sepuluh divisi yang lebih kecil, yang sesuai dengan sistem angka heksadesimal Babilonia. Saya menunjukkan sumber peta, tetapi ada terlalu banyak potongan kecil di posting ini, jadi saya tidak repot. Namun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta ini</a> dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thomas Ray</a> untuk penulis S.E. Boleyn, jadi, mungkin, aksi dalam buku-bukunya terjadi di rombongan Babel.) <br><br>  Selain garis dan skala, elemen yang paling umum adalah pola geometris berulang.  Seringkali terdiri dari bagian-bagian seperti lingkaran, belah ketupat dan persegi panjang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Elemen geometris, seperti garis, dapat diarsir untuk membuatnya terlihat tiga dimensi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Batas-batas kompleks dapat dibuat dengan menggabungkan elemen-elemen ini dengan cara yang berbeda.  Berikut adalah batas yang menggabungkan garis, pola geometris, dan skala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Contoh yang ditunjukkan di atas adalah kartu digital, tetapi, tentu saja, hal yang sama dapat dilakukan dengan kartu tulisan tangan.  Berikut adalah contoh pola geometris sederhana yang dibuat dengan tangan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Elemen-elemen ini juga dapat dikombinasikan secara fleksibel dalam banyak cara.  Berikut adalah pola geometris yang dikombinasikan dengan "tepi kasar": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  Dalam contoh yang ditunjukkan di atas, pola geometris cukup sederhana.  Tetapi Anda dapat membuat pola yang sangat kompleks dengan menggabungkan elemen geometris dasar dengan cara yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Elemen populer lainnya dari pola tersebut adalah tenun atau simpul Celtic: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Berikut ini adalah batas anyaman yang lebih kompleks yang mengandung warna, skala, dan elemen lainnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Pada peta ini, tenun dikombinasikan dengan elemen tepi yang kasar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  Selain pola geometris dan tenun, setiap pola yang berulang dapat menjadi bagian dari batas kartu.  Berikut adalah contoh menggunakan bentuk menyerupai panah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Dan berikut ini adalah contoh dengan pola gelombang berulang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  Dan akhirnya, rune atau elemen lain dari alfabet fantasi kadang-kadang ditambahkan ke tepi kartu fantasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Contoh di atas diambil dari peta fantasi modern, tetapi di sini adalah contoh peta historis (abad ke-18) dengan garis dan pola yang digambar tangan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Tentu saja, Anda dapat menemukan contoh peta dengan banyak elemen lain di perbatasan.  Beberapa yang paling indah benar-benar digambar tangan dan memiliki dekorasi yang dibuat sedemikian rupa sehingga mereka dapat melampaui kartu itu sendiri ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">World of Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  Perlu juga sedikit dibicarakan tentang <i>simetri</i> .  Seperti pengulangan, simetri adalah alat yang ampuh, dan batas peta biasanya simetris atau memiliki elemen simetris. <br><br>  Banyak batas peta simetris dari dalam ke luar, seperti dalam contoh ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Di sini, perbatasan terdiri dari beberapa garis dengan dan tanpa isian, tetapi dari luar ke dalam itu idealnya diulang relatif ke pusat perbatasan. <br><br>  Dalam contoh yang lebih kompleks ini, perbatasan simetris, dengan pengecualian garis-garis hitam dan putih berselang-seling: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Karena menduplikasi skala tidak masuk akal, sering dianggap sebagai elemen yang terpisah, bahkan jika sisa perbatasan simetris. <br><br>  Selain simetri internal-eksternal, batas seringkali simetris sepanjang.  Beberapa perbatasan bergambar mungkin memiliki desain sederhana yang membentang sepanjang panjang tepi peta, tetapi dalam kebanyakan kasus polanya cukup pendek dan berulang, mengisi perbatasan dari satu sudut ke sudut lain: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Perhatikan bahwa dalam contoh ini polanya berisi elemen yang tidak simetris (dari kiri ke kanan), tetapi pola umum simetris dan berulang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Satu pengecualian penting untuk aturan ini adalah batas diisi dengan rune atau karakter alfabet.  Seringkali mereka berubah menjadi unik, seolah-olah beberapa pesan panjang ditulis di sepanjang perbatasan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Tentu saja, ada banyak contoh elemen peta perbatasan yang belum saya pertimbangkan di sini, tetapi kami sudah memiliki titik referensi yang baik.  Di beberapa bagian selanjutnya, saya akan mengembangkan beberapa fungsi di <b>Dragons Abound</b> untuk mendeskripsikan, menampilkan, dan secara prosedural menghasilkan batas peta yang mirip dengan contoh-contoh ini.  Pada bagian kedua, kita akan mulai dengan mengatur bahasa untuk menggambarkan perbatasan peta. <br><br><h2>  Bagian 2 </h2><br>  Pada bagian ini, saya akan membuat versi awal Bahasa Deskripsi Perbatasan Peta (MBDL). <br><br>  Mengapa menghabiskan waktu membuat bahasa deskripsi batas peta?  Pertama, ini akan menjadi tujuan generasi prosedural saya.  Nanti saya akan menulis algoritma untuk membuat batas peta baru, dan output dari algoritma ini akan menjadi deskripsi perbatasan baru di MBDL.  Kedua, MBDL akan berfungsi sebagai representasi tekstual dari batas-batas peta.  Secara khusus, saya harus bisa menyelamatkan dan menggunakan kembali batas-batas saya.  Untuk melakukan ini, saya memerlukan notasi teks yang dapat ditulis dan digunakan untuk membuat ulang batas peta. <br><br>  Saya akan mulai membuat MBDL dengan mendefinisikan elemen paling sederhana: baris.  Garis memiliki warna dan lebar.  Oleh karena itu, di MBDL saya akan menyajikan baris dalam formulir ini: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Berikut beberapa contoh (maaf untuk keterampilan Photoshop saya): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  Urutan elemen dirender dari luar ke dalam (*), jadi kami berasumsi bahwa ini adalah perbatasan di atas peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Lihatlah contoh kedua - garis dengan batas direpresentasikan sebagai tiga elemen garis terpisah. <br><br>  <i>(* Menggambar dari luar ke dalam adalah pilihan yang sewenang-wenang - sepertinya bagi saya itu lebih alami daripada merender dari dalam ke luar. Sayangnya, ternyata kemudian, ada alasan bagus untuk bekerja di arah yang berlawanan. Segera saya akan memberi tahu Anda tentang hal itu, tetapi semuanya tertinggal di pos. - lama, karena akan membutuhkan banyak waktu untuk mengulang semua ilustrasi)</i> <br><br>  Dengan mudah, ruang dapat direpresentasikan sebagai garis tanpa warna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Tetapi akan lebih visual untuk memiliki elemen ruang vertikal spesifik: <br><br><blockquote>  VS (lebar) </blockquote><br>  Elemen sederhana berikut adalah bentuk geometris: garis, rhombus, dan elips.  Diasumsikan bahwa garis-garis tersebut membentang di atas seluruh panjang perbatasan, sehingga tidak memiliki panjang yang ditentukan secara eksplisit.  Tetapi angka geometris tidak dapat memenuhi seluruh garis, oleh karena itu, selain lebar (*), masing-masing harus memiliki panjang, warna garis besar, garis besar lebar dan warna isi: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* Saya menerima bahwa saya akan mempertimbangkan lebar dalam arah dari luar ke dalam, dan panjangnya diukur di sepanjang perbatasan.) <br><br>  Berikut adalah contoh bentuk geometris sederhana: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Agar elemen-elemen ini memenuhi seluruh panjang perbatasan, mereka harus diulang.  Untuk menunjukkan grup elemen yang akan diulang untuk mengisi panjang perbatasan, saya menggunakan tanda kurung: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Berikut adalah contoh pola berulang persegi panjang dan rhombus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Kadang-kadang saya membutuhkan ruang (horizontal) antara elemen-elemen dari pola berulang.  Meskipun Anda dapat menggunakan elemen tanpa warna untuk membuat ruang, akan lebih pintar dan nyaman untuk memiliki elemen ruang horizontal: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  Fungsi terakhir yang diperlukan untuk iterasi pertama MBDL adalah kemampuan untuk menumpuk elemen di atas satu sama lain.  Berikut ini contoh perbatasan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  Cara termudah untuk menggambarkannya adalah garis kuning lebar di bawah pola atas.  Anda dapat menerapkan ini dengan cara yang berbeda (misalnya, ruang vertikal negatif), tetapi saya memutuskan untuk menggunakan kurung kurawal untuk menunjukkan urutan elemen ke dalam: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  Bahkan, entri ini memberitahu Anda untuk mengingat di mana pola itu berasal dari luar ke dalam ketika memasuki tanda kurung, dan kemudian kembali ke titik ini ketika meninggalkan tanda kurung.  Kurung juga dapat dianggap sebagai deskripsi elemen yang menempati ruang vertikal.  Oleh karena itu, batas yang ditunjukkan di atas dapat digambarkan sebagai berikut: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Kami menggambar garis hitam, memperbaiki di mana kita berada, menggambar garis kuning, dan kemudian kembali ke posisi yang sebelumnya diperbaiki, turun sedikit ke bawah, menggambar pola persegi panjang dan belah ketupat, turun sedikit ke bawah, dan kemudian tarik garis hitam lain. <br><br>  Masih banyak yang harus dilakukan di MBDL, tetapi ini cukup untuk menggambarkan banyak batasan peta.  Langkah selanjutnya adalah mengubah deskripsi batas pada MBDL ke perbatasan itu sendiri.  Ini mirip dengan mengubah representasi tertulis dari program komputer (seperti Javascript) ke dalam pelaksanaan program ini.  Tahap pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis leksikal (parsing)</a> bahasa - transformasi teks sumber menjadi perbatasan nyata peta atau menjadi semacam bentuk peralihan, yang lebih mudah dikonversi menjadi perbatasan. <br><br>  Parsing adalah bidang ilmu komputer yang cukup banyak dipelajari.  Memilah bahasa tidaklah sederhana, tetapi dalam kasus kami, bagus (*) bahwa MBDL adalah tata bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bebas konteks</a> .  Tata bahasa bebas konteks diuraikan dengan cukup mudah, dan ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat parsing Javascript</a> untuk mereka.  Saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nearley.js</a> , yang tampaknya cukup matang dan (lebih penting) alat yang terdokumentasi dengan baik. <br><br>  <i>(* Ini bukan hanya keberuntungan, saya memastikan bahwa bahasa itu bebas konteks.)</i> <br><br>  Saya tidak akan memperkenalkan Anda dengan tata bahasa bebas konteks, tetapi sintaks Nearley cukup sederhana dan Anda harus memahami artinya tanpa masalah.  Grammar Nearley terdiri dari seperangkat aturan.  Setiap aturan memiliki karakter di sebelah kiri, panah, dan bagian kanan aturan, yang dapat berupa urutan karakter dan non-karakter, serta berbagai opsi yang dipisahkan oleh "|"  (atau): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> â€œ <b>L"</b></code> </blockquote> <br>  Masing-masing aturan mengatakan bahwa sisi kiri dapat diganti dengan salah satu opsi di sisi kanan.  Artinya, aturan pertama mengatakan bahwa perbatasan adalah elemen, atau elemen, diikuti oleh perbatasan lain.  Yang itu sendiri bisa menjadi elemen, atau elemen yang diikuti oleh perbatasan, dan sebagainya.  Aturan kedua mengatakan bahwa elemen hanya bisa berupa string "L".  Artinya, bersama-sama aturan ini sesuai dengan batas-batas tersebut: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  dan tidak sesuai dengan batas-batas tersebut: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  Omong-omong, jika Anda ingin bereksperimen dengan tata bahasa ini (atau yang lain) di Nearley, maka ada kotak pasir online untuk ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Anda dapat memasukkan tata bahasa dan menguji kasus untuk melihat apa yang cocok dan tidak cocok. <br><br>  Berikut adalah definisi garis primitif yang lebih lengkap: <br><br><blockquote> <code><b>@builtin â€œnumber.ne" <br> @builtin â€œstring.ne" <br> border -&gt; element | element border <br> element -&gt; â€œL(" decimal â€œ," dqstring â€œ)"</b></code> </blockquote> <br>  Nearley memiliki beberapa elemen bawaan yang umum, dan angka adalah salah satunya.  Oleh karena itu, saya dapat menggunakannya untuk mengenali lebar numerik suatu garis primitif.  Untuk pengenalan warna, saya menggunakan elemen bawaan lainnya dan memungkinkan penggunaan string apa pun dalam tanda kutip ganda. <br><br>  Akan lebih baik untuk menambahkan spasi di antara karakter yang berbeda, jadi mari kita lakukan.  Nearley mendukung kelas karakter dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RBNF</a> untuk "nol atau lebih" sesuatu dengan ": *", jadi saya dapat menggunakan ini untuk menentukan "nol atau lebih banyak ruang" dan menempelkannya di mana saja untuk memungkinkan spasi dalam deskripsi: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  Namun, penggunaan WS di seluruh membuat sulit untuk membaca tata bahasa, jadi saya akan meninggalkan mereka, tetapi bayangkan bahwa mereka. <br><br>  Elemen juga bisa berupa ruang vertikal: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Ini sesuai dengan batas-batas tersebut <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Berikutnya adalah primitif strip, belah ketupat dan elips. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Itu akan cocok dengan elemen tersebut <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Perhatikan bahwa primitif geometris bukan "elemen" karena mereka tidak bisa sendirian di tingkat atas. Mereka harus dilampirkan dalam suatu pola.) <br><br>  Saya juga membutuhkan ruang horizontal primitif: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Sekarang saya akan menambahkan pola (ulangi) operasi.  Ini adalah urutan satu atau lebih elemen di dalam tanda kurung siku.  Saya akan menggunakan operator RBNF ": +", yang di sini berarti "satu atau lebih." <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Perhatikan bahwa polanya hanya dapat diisi dengan primitif geometris.  Kita tidak bisa, misalnya, menempatkan garis di dalam suatu pola.  Elemen pola sekarang akan cocok dengan sesuatu seperti ini. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  Bagian terakhir bahasa adalah operator overlay.  Ini adalah sejumlah elemen di dalam kawat gigi. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  yang memungkinkan kami untuk melakukan hal berikut: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Perhatikan bahwa tidak seperti operator pengulangan, operator overlay dapat digunakan secara internal.) <br><br>  Setelah membersihkan deskripsi dan menambahkan spasi ke tempat-tempat yang diperlukan, kami mendapatkan tata bahasa MBDL berikut: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Jadi, MBDL sekarang didefinisikan dan kami telah membuat tata bahasa.  Ini dapat digunakan dengan Nearley untuk mengenali string bahasa.  Sebelum mempelajari MBDL / Nearley, saya ingin mengimplementasikan primitif yang digunakan dalam MBDL sehingga batas yang dijelaskan pada MBDL dapat ditampilkan.  Ini akan kita lakukan di bagian selanjutnya. <br><br><h2>  Bagian 3 </h2><br>  Sekarang kita akan mulai menerapkan rendering primitif sendiri.  (Pada titik ini, saya tidak perlu mengikat parser ke primitif rendering. Untuk pengujian, saya hanya akan memanggil mereka secara manual.) <br><br>  Mari kita mulai dengan garis primitif.  Ingat bagaimana tampilannya: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  Selain lebar dan warna, ada parameter implisit di sini - jarak dari tepi luar peta.  (Saya menarik batas dari tepi peta ke luar. Perhatikan bahwa kita mulai dari yang berbeda!) Seharusnya tidak menunjuk ke MBDL, karena ini dapat dilacak oleh penerjemah yang menjalankan MBDL untuk menggambar perbatasan.  Namun, ini harus menjadi input untuk semua rendering primitif sehingga mereka tahu di mana menggambarnya.  Saya akan memanggil parameter ini diimbangi. <br><br>  Jika saya hanya perlu menggambar perbatasan di bagian atas peta, maka garis primitif akan sangat mudah diterapkan.  Namun, pada kenyataannya, saya perlu menggambar dari atas.  bawah, kiri dan kanan.  (Mungkin suatu hari nanti saya akan menyadari batas miring atau melengkung, tetapi untuk sekarang kita akan mematuhi batas persegi panjang standar.) Selain itu, panjang dan lokasi elemen garis tergantung pada ukuran peta (serta pada offset).  Karena itu, sebagai parameter, saya memerlukan semua data ini. <br><br>  Setelah menetapkan semua parameter ini, cukup membuat garis primitif dan menggunakannya untuk menggambar garis di sekitar peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Perhatikan bahwa saya menggunakan berbagai fungsi <b>Dragons Abound</b> untuk menggambar garis "tulisan tangan".) Mari kita coba membuat perbatasan yang lebih kompleks: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  Ini terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Cukup bagus.  Perhatikan bahwa ada tempat-tempat di mana garis-garis hitam dan garis emas tidak cukup sejajar karena fluktuasi.  Jika saya ingin menghilangkan bintik-bintik ini, maka Anda cukup mengurangi jumlah osilasi. <br><br>  Menerapkan primitif ruang vertikal cukup sederhana;  itu hanya melakukan kenaikan offset.  Mari tambahkan sedikit ruang: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Saat menggambar garis, sudut bisa diwujudkan dengan menggambar antara offset dan gambar sepanjang peta searah jarum jam.  Tetapi secara umum, saya perlu menerapkan pemotongan di setiap sisi perbatasan peta untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koneksi sudut dengan bevel</a> .  Ini akan diperlukan untuk membuat batas dengan pola yang disatukan dengan benar di sudut, dan dalam kasus umum akan menghilangkan kebutuhan untuk menggambar elemen dengan tepi pada sudut yang seharusnya diperlukan.  (*) <br><br>  <i>(Catatan: seperti yang akan dikatakan di bagian berikut, seiring waktu saya menolak untuk menggunakan daerah pemotongan ketika menerapkan sudut. Alasan utama adalah untuk membuat sudut yang kompleks, misalnya, offset persegi:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>area pemotongan semakin kompleks diperlukan.</i>  <i>Juga, seiring waktu, saya menemukan cara yang lebih baik untuk bekerja dengan pola di sudut-sudut.</i>  <i>Alih-alih mengembalikan dan menulis ulang bagian artikel ini, saya memutuskan untuk meninggalkannya untuk menggambarkan proses â€œkreativitasâ€.)</i> <br><br>  Gagasan utamanya adalah memotong setiap perbatasan secara diagonal dan membuat empat area terpotong di mana masing-masing sisi perbatasan akan digambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Saat memotong, semua yang digambar di area terkait akan terpotong pada sudut yang diinginkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Sayangnya, ini menciptakan celah kecil di sepanjang garis diagonal, mungkin karena browser berperforma tidak sempurna di sepanjang tepi yang terpotong.  Tes menunjukkan bahwa latar belakang bersinar melalui celah antara kedua tepi.  Itu mungkin untuk memperbaikinya dengan sedikit memperluas salah satu topeng (setengah pixel tampaknya sudah cukup), tetapi ini kadang-kadang tidak menyelesaikan masalah. <br><br>  Selanjutnya Anda perlu menerapkan bentuk geometris.  Tidak seperti garis, mereka diulang dalam pola, mengisi sisi perbatasan peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Seseorang akan menggambar pola ini dari kiri ke kanan, menggambar persegi panjang, belah ketupat, dan kemudian mengulangi yang sama sampai seluruh perbatasan dipenuhi.  Oleh karena itu, ini juga dapat diterapkan dalam program dengan menggambar pola di sepanjang perbatasan.  Namun, akan lebih mudah untuk menggambar semua persegi panjang, dan kemudian semua belah ketupat.  Ini akan cukup hanya dengan menggambar di sepanjang perbatasan sosok geometris yang sama pada interval.  Dan sangat nyaman bahwa setiap elemen memiliki interval yang sama.  Tentu saja, seseorang tidak akan melakukan itu, karena terlalu sulit untuk mengatur unsur-unsur di tempat yang tepat, tetapi ini bukan masalah bagi program. <br><br>  Artinya, prosedur untuk menggambar bentuk geometris sederhana memerlukan parameter di mana semua dimensi dan warna gambar ditransfer (yaitu lebar, panjang, ketebalan garis, warna garis dan isi), serta posisi awal (yang karena alasan yang akan segera menjadi jelas, Saya akan mempertimbangkan pusat gambar), interval ruang horizontal untuk transisi antara pengulangan, dan jumlah pengulangan.  Juga akan mudah untuk menunjukkan arah pengulangan dalam bentuk vektor [dx, dy], sehingga kita dapat melakukan pengulangan dari kiri ke kanan, dari kanan ke kiri, atas atau bawah, cukup mengubah vektor dan titik awal.  Gabungkan semuanya dan dapatkan potongan bentuk berulang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  Menggunakan kode ini beberapa kali dan rendering dengan offset yang sama, saya dapat menggabungkan garis-garis hitam dan putih untuk membuat skala peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Sebelum saya mulai mencari tahu cara menerapkan semua ini pada batas sebenarnya peta, mari kita terapkan fungsi yang sama untuk elips dan belah ketupat. <br><br>  Belah ketupat hanya persegi panjang dengan simpul yang diputar, jadi Anda hanya perlu melakukan sedikit perubahan pada kode.  Ternyata saya masih belum memiliki kode siap pakai untuk merender elips, tetapi sangat mudah untuk mengambil tampilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parametrik elips</a> dan membuat fungsi yang memberi saya poin elips: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Berikut adalah contoh (dibuat secara manual) yang menggunakan fitur yang diimplementasikan di atas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  Untuk sejumlah kecil kode, itu terlihat cukup bagus! <br><br>  Sekarang mari kita pecahkan kasus perbatasan yang rumit dengan elemen berulang: sudut. <br><br>  Jika ada perbatasan dengan elemen berulang, ada beberapa cara untuk menyelesaikan masalah dengan sudut.  Yang pertama adalah menyesuaikan pengulangan sehingga mereka dieksekusi di sudut tanpa pernikahan yang nyata: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Pilihan lain adalah menghentikan pengulangan di suatu tempat dekat sudut di kedua sisi.  Ini sering dilakukan jika polanya tidak mudah "diputar" di sudut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Opsi terakhir adalah menutup pola dengan beberapa hiasan sudut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Suatu hari nanti saya akan sampai ke dekorasi sudut, tetapi untuk sekarang kita akan menggunakan opsi pertama.  Bagaimana membuat pola garis-garis atau lingkaran â€œberputarâ€ di sudut-sudut peta tanpa celah? <br><br>  Gagasan utamanya adalah menempatkan elemen pola tepat di sudut sehingga setengahnya berada di satu sisi peta dan yang lainnya berada di sisi yang berdekatan.  Dalam contoh ini, lingkaran tepat di sudut dan dapat ditarik dari segala arah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Dalam kasus lain, elemen setengah ditarik ke satu arah, dan setengah di sisi lain, tetapi ujungnya bertepatan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Dalam hal ini, garis putih digambar di kedua sisi, tetapi terhubung di sudut tanpa celah. <br><br>  Ada dua aspek yang perlu dipertimbangkan ketika menempatkan elemen di sudut. <br><br>  Pertama, elemen sudut akan dibagi dan dicerminkan relatif terhadap melewati diagonal melalui pusat elemen.  Elemen dengan simetri radial, misalnya, kuadrat, lingkaran, dan bintang, tidak akan mengubah bentuknya.  Elemen tanpa simetri radial, misalnya, persegi panjang dan belah ketupat, akan berubah bentuk ketika mirroring relatif terhadap diagonal. <br><br>  Kedua, agar elemen sudut dari kedua sisi terhubung dengan benar, harus ada jumlah elemen (*) integer di kedua sisi peta.  Mereka tidak harus memiliki angka yang sama, tetapi harus ada bilangan bulat elemen di kedua sisi.  Jika sejumlah pola fraksional terkandung di satu sisi, maka dari satu sisi pola tidak akan bertepatan dengan sisi yang berdekatan. <br><br>  <i>(* Dalam beberapa kasus, misalnya, dengan garis-garis panjang, pengulangan parsial dapat terjadi dengan pengulangan penuh dan elemen-elemen akan tetap selaras. Namun, elemen sudut yang dihasilkan akan asimetris dan panjangnya berbeda dari elemen yang sama di sisi peta. Contohnya bisa dilihat di sini:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Balok putih skala terjadi dengan pengulangan parsial yang berbeda dan sebagai hasilnya elemen bergeser relatif ke pusat diperoleh.</i>  <i>Untuk skala peta, ini tidak selalu terjadi, karena menunjukkan jarak absolut dan tidak harus simetris.</i>  <i>Tetapi untuk pola dekoratif, ini biasanya terlihat buruk.)</i> <br><br>  Berikut adalah contoh yang menunjukkan bagaimana jumlah pengulangan integer dipangkas tepat di sudut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Jika Anda melakukan hal yang sama dari keempat sisi, maka sudut-sudutnya akan bertepatan dan polanya akan terletak di sepanjang garis perbatasan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Setelah pemeriksaan cermat, Anda akan melihat bahwa pola tidak terjadi persis di sudut-sudut.  Setengah lingkaran di setiap sudut diambil dari masing-masing sisi, dan dua bagian ini ditarik secara terpisah dengan tangan, oleh karena itu mereka tidak sempurna.  Tapi sekarang mereka cukup dekat dengan ini. <br><br>  Jadi, kita dapat mewujudkan koneksi sempurna dari pola di sudut-sudut, memilih jumlah pengulangan integer untuk setiap sisi.  Namun, solusi untuk masalah ini adalah nontrivial. <br><br>  Pertama, misalkan kita tahu bahwa sisi adalah 866 piksel, dan kami ingin mengulang elemen 43 kali.  Maka elemen harus diulang setiap 20,14 piksel.  Bagaimana kita menetapkan panjang elemen tertentu (dan dalam kasus umum, pola elemen)?  Pada contoh di atas, saya menambahkan ruang ekstra di antara lingkaran.  Tetapi jika pada awalnya lingkaran saling bersentuhan, maka ini akan mengubah polanya.  Mungkin ada baiknya merentangkan lingkaran sehingga mereka terus saling menyentuh? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Sekarang elemen-elemennya bersentuhan, tetapi lingkarannya telah berubah menjadi elips dan sudut-sudutnya memiliki bentuk yang aneh.  (Ingat, saya katakan bahwa elemen tanpa simetri radial berubah bentuk ketika dipantulkan relatif ke sudut? Untuk garis, ini tidak akan menjadi masalah besar.) Atau, mungkin, ada baiknya mengompresi semua elemen sehingga mereka saling menyentuh dan pas dalam panjang yang sesuai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Tetapi untuk menyadari hal ini, kita perlu membuat elemen-elemennya jauh lebih kecil dari aslinya.  Tidak satu pun dari opsi ini yang tampak sempurna. <br><br>  Masalah kedua terjadi ketika sisi-sisi kartu memiliki ukuran yang berbeda.  Sekarang kita perlu memecahkan masalah menemukan jumlah pengulangan integer yang cocok untuk kedua belah pihak.  Akan ideal untuk menemukan satu solusi yang cocok untuk kedua sisi.  Tetapi saya tidak ingin melakukan ini dengan mengorbankan terlalu banyak perubahan pola.  Mungkin lebih baik untuk membuat pola yang sedikit berbeda di kedua sisi jika keduanya cukup dekat dengan pola aslinya. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan akhirnya, masalah ketiga muncul ketika saya menggunakan fungsi menumpangkan beberapa elemen satu sama lain: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak ingin membuat perubahan pada pola yang akan menghancurkan hubungan antar elemen. </font><font style="vertical-align: inherit;">Saya pikir dengan penskalaan yang tepat, rasio secara keseluruhan akan tetap ada, tetapi saya perlu menguji ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas yang menarik, bukan? </font><font style="vertical-align: inherit;">Sejauh ini saya tidak punya solusi berkualitas tinggi untuknya. </font><font style="vertical-align: inherit;">Mungkin mereka akan muncul nanti!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 4 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami telah menerapkan primitif untuk menggambar garis dan bentuk geometris. Saya mulai bekerja menggunakan bentuk berulang untuk mengisi perbatasan dan berbicara tentang kesulitan menempatkan pola sewenang-wenang di perbatasan peta sehingga mereka pas di sudut-sudut. Masalah utama adalah bahwa dalam kasus umum, Anda harus membuat polanya lebih panjang (atau lebih pendek) agar pas. Pilihan untuk mengubah panjang pola - menambah atau menghapus spasi, mengubah panjang elemen pola - menyebabkan berbagai perubahan dalam pola itu sendiri. Tampaknya tugas memilih pola dari beberapa elemen sangat sulit!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya menemukan tugas-tugas yang tampaknya tanpa kompromi, saya ingin memulai dengan menerapkan versi sederhana. Tugas yang gagal seringkali dapat diselesaikan dengan berulang kali memecahkan masalah "sederhana" sampai hasilnya cukup baik. Dan kadang-kadang implementasi versi sederhana memberikan beberapa pemahaman yang menyederhanakan solusi dari masalah yang lebih kompleks. Jika tidak menjadi lebih baik dan masalahnya tetap tidak stabil, maka setidaknya kita akan memiliki versi yang disederhanakan yang masih bisa berguna, meskipun tidak cukup seperti seharusnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah adalah mengubah panjang pola dengan menambahkan panjang tanpa mengubah apa pun dalam pola. </font><font style="vertical-align: inherit;">Pada dasarnya, ini menambahkan ruang kosong ke ujung pola. </font><font style="vertical-align: inherit;">(Catatan: lebih baik mendistribusikan ruang kosong di antara semua elemen dalam pola.) Perlu mempertimbangkan bahwa solusi seperti itu hanya dapat memperpanjang pola. </font><font style="vertical-align: inherit;">Kami selalu dapat menambahkan ruang kosong ke pola, tetapi tidak dapat menerimanya jika perlu - mungkin tidak akan ada lagi ruang kosong di dalam pola! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan pendekatan ini, algoritma lokasi pola di sisi kartu akan sangat sederhana:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagilah panjang sisi kartu dengan panjang pola dan bulatkan ke bawah untuk menentukan jumlah pengulangan pola yang sesuai di sisi itu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak antara elemen dalam kasus ini akan sama dengan panjang sisi dibagi dengan jumlah pengulangan. </font><font style="vertical-align: inherit;">(Ini adalah yang terdekat dengan lokasi asli, mengingat kami hanya dapat menambah ruang.)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gambarlah pola di sepanjang sisi, dengan mempertimbangkan jarak yang dihitung. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sulit untuk menerapkan sistem ini. </font><font style="vertical-align: inherit;">Sudut-sudut yang keras kepala tidak mau bertepatan. </font><font style="vertical-align: inherit;">Butuh waktu terlalu lama bagi saya untuk menyadari bahwa ketika peta tidak persegi, saya tidak dapat menggambar area pemotongan untuk empat sisi dari pusat peta, karena ini menciptakan sudut pemotongan yang tidak sama dengan 45 derajat. </font><font style="vertical-align: inherit;">Faktanya, area pemotongan harus menyerupai bagian belakang amplop:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya menemukan ini, algoritma mulai bekerja tanpa masalah. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Tapi jangan lupa catatan sebelumnya bahwa seiring waktu saya meninggalkan area pemotongan!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah contoh dengan rasio sekitar 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada skala ini, cukup sulit untuk diperhatikan, tetapi sudut-sudutnya terhubung dengan benar dan hanya ada sedikit perbedaan visual antara kedua sisi. </font><font style="vertical-align: inherit;">Dalam hal ini, algoritma untuk menyelaraskan pola hanya perlu memasukkan piksel fraksional, sehingga tidak terlihat oleh mata, terutama karena kontur lingkaran tumpang tindih oleh piksel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah contoh lain dengan garis-garis:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah bagian atas dari batas bujur sangkar. </font><font style="vertical-align: inherit;">Berikut adalah perbatasan yang sama pada peta yang lebih persegi:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini Anda dapat melihat bahwa di sisi kartu terdapat celah visual yang lebih besar di antara kedua band. </font><font style="vertical-align: inherit;">Algoritme tidak boleh memasukkan ruang lebih dari panjang satu elemen penuh; </font><font style="vertical-align: inherit;">oleh karena itu, kasus terburuk terjadi ketika kita memiliki elemen panjang dan sisi pendek yang sedikit berbeda dari ukuran yang sesuai. </font><font style="vertical-align: inherit;">Tetapi dalam kebanyakan kasus praktis, penyelarasan tidak terlalu berbahaya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah contoh dengan pola beberapa elemen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini garis-garis saling bertumpuk: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat bahwa karena penyelarasan yang sama dilakukan untuk setiap elemen, garis-garis tetap terpusat relatif satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menyarankan bahwa solusi yang baik untuk menempatkan pola di sisi peta akan sulit, tetapi pendekatan yang sangat sederhana dengan mendistribusikan elemen pola secara merata untuk mengisi ruang yang diinginkan bekerja dengan baik untuk banyak pola. Ini adalah pengingat bagi kita semua: tidak perlu berasumsi bahwa keputusan harus rumit; mungkin lebih mudah dari yang Anda pikirkan! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, solusi ini tidak berfungsi untuk pola dengan elemen sentuh, misalnya untuk skala peta. Dalam hal ini, menambahkan ruang menggeser elemen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan lain untuk memperpanjang pola, yang saya sebutkan di atas, adalah meregangkan elemen individu dari pola. </font><font style="vertical-align: inherit;">Ini cocok untuk sesuatu seperti pola skala, tetapi akan terlihat buruk dalam pola dengan elemen simetris, karena peregangan akan membuatnya asimetris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi opsi dengan peregangan ternyata lebih sulit daripada yang saya harapkan, terutama karena saya harus meregangkan elemen pada tepi yang berbeda dari peta dengan ukuran yang berbeda (karena peta mungkin bukan persegi tetapi persegi panjang), dan juga secara dinamis mengubah pengaturan elemen berdasarkan yang baru diregangkan. ukuran. </font><font style="vertical-align: inherit;">Tetapi setelah beberapa jam saya berhasil mencapai ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang saya memiliki semua fitur yang diperlukan untuk menggambar perbatasan peta (walaupun elemen perbatasan itu sendiri dibuat secara manual): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya mengubah gambar menjadi skala abu-abu, karena saya tidak ingin repot dengan pemilihan warna, dan kartu itu sendiri agak membosankan, tetapi sebagai bukti konsep, perbatasan terlihat cukup cantik. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 5 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian 2, saya mengembangkan tata bahasa Map Border Description Language (MBDL), dan di bagian 3 dan 4, saya menerapkan prosedur untuk mengeksekusi semua primitif bahasa. </font><font style="vertical-align: inherit;">Sekarang saya akan bekerja untuk menghubungkan bagian-bagian ini sehingga saya dapat menggambarkan perbatasan pada MBDL dan menggambarnya di peta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Bagian 3, saya menulis tata bahasa MBDL sehingga berfungsi dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Parsing Tool</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tata bahasa yang sudah selesai terlihat seperti ini:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, saat berhasil mengurai aturan menggunakan Nearley, aturan mengembalikan array yang berisi semua elemen yang sesuai dengan sisi kanan aturan. </font><font style="vertical-align: inherit;">Misalnya kalau aturan</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cocok dengan string </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maka Nearley akan kembali </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array dengan nilai tunggal adalah string "A" yang sesuai dengan sisi kanan aturan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang dikembalikan Nearley ketika elemen diuraikan menggunakan aturan ini?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada tiga bagian di sisi kanan aturan, sehingga akan mengembalikan array dengan tiga nilai. </font><font style="vertical-align: inherit;">Nilai pertama akan menjadi yang mengembalikan aturan untuk WS, nilai kedua akan menjadi yang akan mengembalikan aturan untuk desimal, dan nilai ketiga akan menjadi yang akan mengembalikan aturan untuk WS. </font><font style="vertical-align: inherit;">Jika, menggunakan aturan di atas, saya akan menguraikan "57", maka hasilnya adalah sebagai berikut:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil akhir parsing Nearley adalah array array yang bersarang, yang merupakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pohon sintaksis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam beberapa kasus, pohon sintaks adalah representasi yang sangat berguna, dalam kasus lain, tidak cukup. Di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , misalnya, pohon seperti itu tidak terlalu berguna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, aturan Nearley dapat mengesampingkan perilaku standar dan mengembalikan apa pun yang mereka inginkan. Faktanya, aturan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (built-in) </font><font style="vertical-align: inherit;">tidak mengembalikan daftar digit, ia mengembalikan nomor Javascript yang setara, yang dalam banyak kasus jauh lebih berguna, yaitu, nilai balik aturan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki bentuk:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan Nearley mendefinisikan kembali perilaku standar dengan menambahkan post-prosesor ke aturan, mengambil array standar dan menggantinya dengan apa yang Anda butuhkan. Postprocessor hanyalah kode Javascript di dalam tanda kurung khusus di akhir aturan. Misalnya, dalam aturan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">saya tidak pernah tertarik pada ruang yang memungkinkan di kedua sisi nomor. Oleh karena itu, akan lebih mudah jika aturan hanya mengembalikan angka, dan bukan array dari tiga elemen. Berikut adalah post-prosesor yang melakukan tugas ini:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Post-prosesor ini mengambil hasil standar (array tiga elemen yang ditunjukkan di atas) dan menggantinya dengan elemen kedua array, yang merupakan nomor Javascript dari aturan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jadi sekarang aturan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan bilangan real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini dapat digunakan untuk memproses bahasa yang masuk menjadi bahasa perantara, yang lebih mudah untuk digunakan. </font><font style="vertical-align: inherit;">Sebagai contoh, saya bisa menggunakan tata bahasa Nearley untuk mengubah string MBDL menjadi array struktur Javascript, yang masing-masing mewakili primitif yang diidentifikasi oleh bidang "op". </font><font style="vertical-align: inherit;">Aturan untuk garis primitif akan terlihat seperti ini:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artinya, hasil parsing "L (13, black)" akan menjadi struktur Javascript: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menambahkan post-processing yang sesuai, hasilnya dikembalikan dari tata bahasa dapat menjadi urutan (array) dari struktur operasi untuk baris yang masuk. </font><font style="vertical-align: inherit;">Artinya, hasil parsing string</font></font><br><br><blockquote> <code><b>L( 415, â€œblack") <br> VS(5) <br> [B(1, 2, â€œblack", 3, â€œwhite") HS(5) E(1, 2, â€œblack", 3, â€œwhite")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang jauh lebih mudah untuk diproses untuk membuat perbatasan peta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, Anda mungkin memiliki pertanyaan - jika fase pasca-pemrosesan aturan Nearley dapat berisi Javascript apa pun, lalu mengapa tidak melewati tampilan perantara dan cukup menggambar batas peta tepat selama pasca-pemrosesan? </font><font style="vertical-align: inherit;">Untuk banyak tugas, pendekatan ini ideal. </font><font style="vertical-align: inherit;">Saya memutuskan untuk tidak menggunakannya karena beberapa alasan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, di MBDL ada beberapa (*) komponen yang tidak dapat dieksekusi selama proses parsing. Sebagai contoh, kita tidak dapat menggambar elemen geometris berulang (strip atau belah ketupat) selama proses parsing, karena kita perlu mengetahui informasi dari elemen lain dalam pola yang sama. Secara khusus, kita perlu mengetahui panjang total pola untuk memahami sejauh mana kita perlu mengatur pengulangan setiap elemen individu. Artinya, elemen pola masih harus membuat representasi menengah dari semua elemen geometris. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Ada komponen lain dengan keterbatasan serupa yang belum saya bicarakan.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, Javascript di Nearley tertanam dalam aturan, jadi kami tidak akan dapat meneruskan informasi tambahan ke Javascript, kecuali untuk variabel global. Misalnya, untuk menggambar perbatasan, saya perlu tahu ukuran peta, empat area pemotongan yang digunakan, dll. Walaupun saya dapat menambahkan kode yang membuat informasi ini tersedia untuk pasca-prosesor Nearley, itu akan sedikit berantakan dan mungkin sulit untuk mempertahankan kode tersebut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena alasan ini, saya menguraikan representasi perantara, yang kemudian dieksekusi untuk membuat perbatasan peta itu sendiri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah selanjutnya adalah mengembangkan juru bahasa yang menerima representasi perantara dari MBDL dan menjalankannya untuk menghasilkan batas peta. Ini tidak terlalu sulit untuk dilakukan. Pada dasarnya, tugasnya adalah mengatur kondisi awal (misalnya, menghasilkan daerah pemotongan untuk empat sisi peta) dan beralih pada urutan struktur representasi perantara dengan masing-masing yang mengeksekusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa momen yang licin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, saya harus beralih dari rendering dari dalam ke menggambar dari dalam ke luar. Alasannya adalah karena saya ingin sebagian besar perbatasan tidak tumpang tindih peta, jadi saya perlu menggambar perbatasan sehingga garis tepi bagian dalam bertepatan dengan tepi peta. Jika saya menggambar dari luar ke dalam, maka saya perlu tahu lebar perbatasan sebelum saya mulai menggambar sehingga perbatasan tidak tumpang tindih peta. Jika saya menggambar dari dalam ke luar, saya baru mulai dari tepi peta dan menggambar. Ini juga memungkinkan Anda untuk memaksakan batas pada peta secara opsional; mulai saja perbatasan dengan ruang vertikal negatif (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin sulit lainnya adalah pola berulang. </font><font style="vertical-align: inherit;">Untuk menggambar pola berulang, saya perlu melihat semua elemen pola dan menentukan yang terluas, karena akan mengatur lebar keseluruhan pola. </font><font style="vertical-align: inherit;">Saya juga perlu melihat dan melacak panjang pola sehingga saya tahu berapa jauh jarak yang tersisa sebelum setiap pengulangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah contoh perbatasan yang agak rumit yang saya gunakan untuk menguji juru bahasa:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya pikir itu mungkin (perlu?) Untuk melampirkannya untuk pengujian ke parser, tetapi untuk perbatasan ini saya baru saja membuat tampilan perantara secara manual: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya membuat tampilan ini melalui coba-coba. Bagaimanapun, interpreter bekerja! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai langkah terakhir, izinkan saya menggunakan pengurai untuk membuat tampilan perantara dari versi MBDL. Tidak ada banyak yang bisa saya tunjukkan di sini: Saya harus memperbaiki beberapa nama bidang, tetapi jika tidak, kodenya berfungsi dengan baik. Untuk perbatasan, saya menggunakan versi MBDL yang sedikit berbeda:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia menggambar perbatasan yang sama, tetapi dengan cara yang sedikit berbeda. </font><font style="vertical-align: inherit;">Saya juga mengubah sintaks untuk overlay, menggantikan tanda kurung dengan kurung kurawal sehingga lebih berbeda dari sintaks lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menunjukkan mengapa saya ingin menggambar dari dalam ke luar, dan tidak hanya secara otomatis menempatkan perbatasan di luar peta, saya dapat menambahkan ruang vertikal negatif ke awal perbatasan ini untuk memindahkan skala peta di dalam tepi peta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang saya memiliki sebagian besar infrastruktur yang diperlukan untuk pembuatan batas peta prosedural: bahasa deskripsi batas, pengurai bahasa, dan prosedur untuk melakukan representasi perantara. </font><font style="vertical-align: inherit;">Tetap hanya berurusan dengan bagian yang sulit - generasi prosedural!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 6 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang seluruh MBDL telah diimplementasikan, saya bermaksud melanjutkan ke generasi prosedural perbatasan peta, tetapi saya belum yakin bagaimana saya ingin melakukan ini, karena saya akan sedikit berlama-lama dan menerapkan beberapa fitur MBDL lebih banyak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam diskusi pertama tentang pemrosesan sudut dengan pola, saya berbicara tentang beberapa pendekatan berbeda. Pada akhirnya, saya menyadari sudut miring, tetapi ada pilihan kedua: hentikan pola di dekat sudut, seperti dalam contoh berikut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi semacam itu sering digunakan ketika pola perbatasan adalah semacam angka asimetris, rune, atau sesuatu yang tidak dapat diputar 90 derajat, sambil mempertahankan perataan. Tetapi jelas bahwa ini akan bekerja dengan bentuk geometris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini mungkin opsi yang Anda pilih sebelum membuat perbatasan, tetapi Anda dapat menambahkan sedikit fleksibilitas jika Anda mengaktifkannya dari satu bagian perbatasan dan menggunakan sudut miring di sisi lainnya. Untuk melakukan ini, saya harus menambahkan perintah baru ke MBDL. Saya menduga bahwa opsi lain mungkin muncul untuk bagian perbatasan yang berbeda, jadi saya akan menambahkan perintah opsi umum:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Di sini sekali lagi, untuk kejelasan, kami menghilangkan spasi dan beberapa detail lainnya.) Sejauh ini, satu-satunya pilihan adalah "MITER" untuk sudut miring dan "STOPPED" untuk berhenti di dekat sudut. </font><font style="vertical-align: inherit;">Jika tidak ada nilai yang dikirimkan STOPPED, maka program menghentikan pola pada jarak yang masuk akal dari sudut. </font><font style="vertical-align: inherit;">Jika nilai ditransmisikan, pola berhenti pada jarak itu dari sudut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika sudut STOPPED digunakan, maka saya berhenti menggambar pola sudut jauh dari sudut.</font></font> Begini tampilannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini, saya menggunakan opsi MITER untuk pola skala hitam dan putih, sehingga mencerminkan sehubungan dengan sudut. </font><font style="vertical-align: inherit;">Untuk pola lingkaran merah dan kotak hitam di dalam garis emas (dan untuk pola lingkaran di luar perbatasan), saya menggunakan STOPPED. </font><font style="vertical-align: inherit;">Anda dapat melihat bahwa kedua pola ini berakhir dekat sudut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada beberapa masalah. Pertama, kita melihat bahwa di sebelah kiri elemen terdekat ke sudut adalah kotak hitam, dan di atas adalah lingkaran merah. Itu terjadi karena sudut dekat awal pengulangan di satu sisi dan di dekat akhir pengulangan di sisi lain. Tapi itu terlihat aneh. Akan lebih baik jika sudutnya simetris, bahkan jika untuk ini kita harus menambahkan elemen lain ke akhir pola. Kedua, Anda dapat melihat bahwa pola di luar perbatasan (setengah lingkaran dan titik-titik hitam) juga berakhir dalam satu pengulangan ke sudut. Tetapi karena panjang pengulangan ini jauh lebih kecil dari panjang lingkaran merah / kotak hitam, mereka berakhir di tempat yang berbeda. Mungkin akan lebih baik jika semua pola berhenti pada jarak yang sama dari sudut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memperbaiki masalah pertama, Anda perlu menambahkan pengulangan lain dari elemen pertama dari pola di akhir setiap sisi perbatasan. </font><font style="vertical-align: inherit;">Tapi sebenarnya ini sedikit lebih rumit, karena saya bisa menggunakan offset horizontal negatif di dalam pola untuk tumpang tindih beberapa elemen (seperti yang dilakukan di sini). </font><font style="vertical-align: inherit;">Anda juga perlu menambahkan pengulangan ke elemen pola mana pun yang memiliki titik awal yang sama dengan elemen pertama.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang polanya simetris dengan memperhatikan sudut dan terlihat jauh lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, saya perlu melacak pola STOPPED terpanjang dan menghentikan setiap pola STOPPED pada jarak ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang pola lingkaran putih lebih disisihkan, tetapi masih belum selaras dengan pola lingkaran merah. </font></font> Mengapa<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini terjadi karena pola lingkaran putih lebih jauh dari tepi peta, dan perbatasan lebih panjang daripada di mana pola lingkaran merah digambar. </font><font style="vertical-align: inherit;">Untuk memperbaiki masalah ini, Anda perlu memindahkan pola juga dan mempertimbangkan offsetnya relatif ke tepi peta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang semuanya tertata dengan indah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan kedua untuk sudut adalah offset kuadrat di sudut, misalnya ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan jauh lebih sulit untuk menerapkan ini! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, tata bahasa opsi ini sederhana dan menggunakan opcode Opsi:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angka menunjukkan ukuran perpindahan kuadrat untuk elemen di tepi peta; </font><font style="vertical-align: inherit;">Elemen dengan offset yang berbeda harus disejajarkan. </font><font style="vertical-align: inherit;">Jika tidak ada angka, program memilih ukuran offset yang sesuai. </font><font style="vertical-align: inherit;">Menekan angka akan menonaktifkan offset persegi. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk membuat batas di mana beberapa elemen menggunakan offset kotak, sementara yang lain tidak, seperti di perbatasan ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal pertama yang saya sadari adalah bahwa saya akan membutuhkan area pemotongan tambahan karena saya menggunakan pemotongan untuk memproses tempat-tempat di mana perbatasan berubah arah. </font><font style="vertical-align: inherit;">SQOFFSET akan membutuhkan area pemotongan yang lebih kompleks; </font><font style="vertical-align: inherit;">Anda juga akan membutuhkan area terpisah untuk item yang berbeda saat Anda mengaktifkan dan menonaktifkan SQOFFSET. </font><font style="vertical-align: inherit;">Mengingat bahwa area pemotongan menambah artefak yang tidak diinginkan, sepertinya ini terlalu banyak pekerjaan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya mengerjakan pola yang dapat dihentikan di atas, saya menerapkan pengisian pola asimetris untuk menambahkan pengulangan dari satu ujung pola. Saya juga menyadari bahwa ini akan menghilangkan kebutuhan sudut miring. Saya hanya akan menggambar semua pola di sepanjang perbatasan searah jarum jam, mulai pola di satu sudut dan berakhir di dekat sudut berikutnya. Ini akan memungkinkan saya untuk menyingkirkan area pemotongan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal terpenting dalam cara baru bekerja dengan sudut ini adalah bahwa elemen pertama dari pola tidak lagi â€œdibagiâ€ menjadi dua sisi. Jika Anda melihat pola skala hitam dan putih pada peta di atas, Anda dapat melihat bahwa ada persegi panjang putih yang melewati sudut. Sekarang persegi panjang putih akan berbatasan dengan sudut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta digambar dengan dua cara, tetapi ini bukan masalah yang sangat besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai permulaan, saya menerapkan offset untuk garis. </font><font style="vertical-align: inherit;">Untuk melakukan ini, cukup mengubah garis relatif ke sudut yang sesuai:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang dapat Anda pahami, saya dapat menggabungkan sudut dengan offset dan sudut reguler, seperti pada peta di atas: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, memutar pola di tikungan lebih sulit. </font><font style="vertical-align: inherit;">Gagasan umum adalah menggambar dari satu sudut ke sudut yang lain, dan seterusnya sepanjang perbatasan, sampai kita kembali ke awal. </font><font style="vertical-align: inherit;">Secara teoritis cukup untuk hanya menggambar pola horizontal dan vertikal, dan semuanya harus selaras indah; </font><font style="vertical-align: inherit;">sebenarnya melacak semua ini cukup suram. </font><font style="vertical-align: inherit;">Sebenarnya, saya harus menulis ulang kode sepenuhnya dua kali dan menulis banyak kertas, tetapi saya tidak akan membicarakan hal ini secara terperinci. </font><font style="vertical-align: inherit;">Tunjukkan saja hasilnya:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilusi optik yang menjengkelkan muncul di sudut-sudut - elemen sudut tampaknya tidak terpusat lebih dekat ke bagian luar sudut. </font><font style="vertical-align: inherit;">Sebenarnya, ini tidak benar, tetapi tampaknya begitu, karena lebih dekat ke bagian dalam sudut ada ruang yang lebih kosong secara visual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena segmen sudut offset cukup pendek, sangat mudah untuk membuat pola nonequilibrium di sudut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkadang terlihat sangat jelek. </font><font style="vertical-align: inherit;">Itu mengingatkan saya pada lelucon lama:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasien: "Dokter, ketika saya melakukan ini, itu menyakitkan saya." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokter: "Kalau begitu jangan lakukan itu!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu, saya akan berusaha untuk tidak melakukannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya saya tidak akan menggambar skala peta di sepanjang sudut offset, tetapi jika saya membutuhkannya, saya akan perlu menggunakan opsi yang merentangkan pola sehingga skala peta cocok ke sudut tanpa kesenjangan antara persegi panjang:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat bahwa sebagai hasilnya, ukuran persegi panjang skala sangat bervariasi. </font><font style="vertical-align: inherit;">Artinya, ini bukan pilihan yang sangat baik. </font><font style="vertical-align: inherit;">(Ngomong-ngomong, sudut offset juga memiliki bug dalam pola lingkaran. Kemudian saya memperbaikinya, tetapi seperti yang saya katakan, sangat sulit untuk melakukannya.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika polanya terlalu besar untuk masuk ke segmen sudut offset, maka algoritme menyerah begitu saja:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang jauh dari ideal, tetapi, seperti yang saya katakan di atas, "Kalau begitu jangan lakukan itu." </font><font style="vertical-align: inherit;">(Sebenarnya tidak terlalu sulit untuk menambahkan fungsi kompresi atau peregangan jika saya membutuhkannya.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang terjadi jika saya menggunakan kedua sudut offset dan opsi yang menghentikan pola di depan sudut? </font><font style="vertical-align: inherit;">Dalam hal ini, saya hanya berhenti tidak jauh dari sudut offset:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menurut saya ini adalah keputusan yang logis. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444190/">https://habr.com/ru/post/id444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444178/index.html">9 tips untuk membuat game indie dari satu pengembang</a></li>
<li><a href="../id444182/index.html">Pergi kondisi dan keanehan mereka</a></li>
<li><a href="../id444184/index.html">Tentang prospek pusat data pra-rakitan</a></li>
<li><a href="../id444186/index.html">Bergetar 1.2. Apa yang baru?</a></li>
<li><a href="../id444188/index.html">CG Pods - TWS Headphones Yang Bisa</a></li>
<li><a href="../id444192/index.html">Manajemen API Mitap - Pengalaman IBM, Google, Yandex, dan Leroy Merlin - Catatan Tersedia</a></li>
<li><a href="../id444198/index.html">Sinkronisasi batas Dropbox: sekarang hanya 3 perangkat</a></li>
<li><a href="../id444200/index.html">Sesi Pemecahan Masalah</a></li>
<li><a href="../id444204/index.html">Memperkenalkan Pengujian dengan Python. Bagian 3</a></li>
<li><a href="../id444206/index.html">27 Maret, Moskow - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>