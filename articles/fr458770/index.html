<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 👩🏾‍🤝‍👨🏻 ⏮️ Toute la vérité sur RTOS. Article # 29. Interruptions dans Nucleus SE 🍣 👨‍🚀 🏇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tous les microprocesseurs et microcontrôleurs modernes contiennent une sorte de mécanisme d'interruption. Ces mécanismes sont nécessaires pour fournir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 29. Interruptions dans Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Tous les microprocesseurs et microcontrôleurs modernes contiennent une sorte de mécanisme d'interruption.  Ces mécanismes sont nécessaires pour fournir la réactivité requise par de nombreuses applications.  Bien sûr, la réactivité et la prévisibilité sont le principal objectif lors de l'utilisation de RTOS, mais en même temps, ils sont opposés.  L'utilisation d'interruptions peut perturber l'intégrité du système d'exploitation en temps réel.  Ce problème et sa solution ont été mentionnés dans l'un des articles précédents (# 4 et # 6).  Dans cet article, nous examinerons la stratégie de gestion des interruptions utilisée dans Nucleus SE.  Dans tous les cas, les interruptions ne sont PAS contrôlées par Nucleus SE: elles sont traitées lorsqu'elles se produisent en fonction de la priorité et des vecteurs de la manière habituelle.  Leur temps d'exécution est simplement «volé» au temps disponible dans le code de l'application principale et de l'ordonnanceur.  De toute évidence, il s'ensuit que tous les gestionnaires d'interruptions doivent être simples, courts et rapides. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Articles précédents de la série:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minuteries logicielles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heure système</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de données: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'événements: services d'assistance et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'événements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de mémoire: services et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de mémoire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données de tâche et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches: configuration et introduction à l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalités avancées et préservation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et déploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br></div></div><br><h2>  Interruptions régulières et contrôlées </h2><br>  Nucleus SE propose deux façons de gérer les interruptions: «native» ou «régulière» (Native), dans lesquelles les interruptions n'ont rien de spécial et ont dans une certaine mesure une interaction limitée avec le système d'exploitation (au moins lors de l'utilisation du planificateur de priorité), et « Géré, dans lequel vous pouvez accéder à un nombre beaucoup plus élevé d'appels d'API à partir du gestionnaire d'interruption. <br><br>  À l'aide des macros d'E / S, le gestionnaire d'interruption Nucleus SE peut être utilisé en mode standard ou géré. <br><br><h3>  Interruptions du personnel </h3><br>  Les interruptions de personnel de Nucleus SE sont le gestionnaire d'interruption standard et peuvent être considérées comme "non gérées".  Ils sont généralement utilisés lorsqu'une interruption peut survenir à une fréquence élevée et nécessite un traitement avec une faible utilisation des ressources informatiques.  Un tel gestionnaire est probablement écrit en C, car de nombreux compilateurs intégrés modernes prennent en charge le développement de gestionnaires d'interruptions à l'aide du mot-clé interruption.  Seules les informations contextuelles que le compilateur juge nécessaires sont stockées.  Cela conduit à des limitations importantes sur ce que les gestionnaires d'interruption standard peuvent faire, ce que nous verrons bientôt. <br><br>  Pour créer un gestionnaire d'interruption régulier dans Nucleus SE, il suffit d'écrire simplement un gestionnaire d'interruption régulier, y compris en appelant la macro <b>NUSE_NISR_Enter ()</b> au début et en appelant <b>NUSE_NISR_Exit ()</b> à la fin.  Ces macros sont définies dans le fichier <b>nuse_types.</b>  h et définissez la variable globale <b>NUSE_Task_State</b> sur <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Interruptions guidées </h3><br>  Si vous avez besoin de plus de flexibilité pour les opérations du gestionnaire d'interruptions, les interruptions gérées par Nucleus SE peuvent être la solution.  La principale différence par rapport à l'interruption standard est le maintien du contexte.  Au lieu de permettre au compilateur d'enregistrer plusieurs registres sur la pile, une interruption contrôlée enregistre le contexte entier de la tâche (dans son propre bloc de contexte) à l'entrée.  Le contexte de la tâche en cours est ensuite restauré à partir du bloc de contexte en sortie.  Cela permet de modifier la tâche en cours grâce au travail du code du gestionnaire d'interruption, ce qui est possible lors de l'utilisation du planificateur de priorité.  Une description complète de la préservation et de la restauration du contexte dans Nucleus SE a été fournie dans un article précédent ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 10</a> ). <br><br>  Évidemment, la pleine conservation du contexte entraîne une augmentation de l'utilisation des ressources informatiques par rapport au stockage de plusieurs registres sur la pile, ce qui se produit lors d'une interruption standard.  Ce prix doit être payé pour une flexibilité supplémentaire, et c'est la raison pour laquelle un choix d'approche de gestion des interruptions est proposé. <br><br>  Une interruption gérée est <b>générée à</b> l'aide de la macro <b>NUSE_MANAGED_ISR ()</b> décrite dans <b>nuse_types.h</b> .  Cette macro crée une fonction qui contient les actions suivantes: <br><br><ul><li>  maintenir le contexte de la tâche; </li><li>  Affectation de <b>NUSE_Task_State à</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  code de fonction du gestionnaire d'interruption fourni par l'utilisateur; </li><li>  restaurer <b>NUSE_Task_State</b> à son état précédent; </li><li>  restaurer le contexte de la tâche. </li></ul><br>  La macro prend deux paramètres: le nom d'interruption utilisé comme nom de fonction pour le gestionnaire généré et le nom de la fonction qui contient la logique utilisateur pour le gestionnaire d'interruption. <br><br><h3>  Appels API du gestionnaire d'interruption </h3><br>  L'ensemble des fonctions API pouvant être appelées à partir d'un gestionnaire d'interruption standard ou géré dépend du planificateur utilisé.  De manière générale, l'utilisation du planificateur de priorité offre de nombreuses options pour accéder au planificateur via un appel de fonction API, ce qui est difficile lors de l'utilisation du gestionnaire d'interruption standard. <br><br>  <b><i>Appels d'API au gestionnaire d'interruption standard lors de l'utilisation du planificateur de priorité</i></b> <br><br>  Lorsque vous utilisez le planificateur de priorité, un nombre limité d'appels de fonction API à partir du gestionnaire d'interruption standard sont autorisés.  Cette limitation est le résultat de la flexibilité de l'API Nucleus SE: de nombreux appels peuvent rendre la tâche prête et le planificateur peut ne pas être appelé par le gestionnaire d'interruption standard (car le contexte de la tâche n'est pas enregistré).  La désactivation des verrous de tâche offre encore plus de flexibilité. <br><br>  Les appels d'API suivants sont toujours autorisés: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Cependant, seul <b>NUSE_Signals_Send () leur</b> est utile, car il fournit un moyen pratique d'indiquer à la tâche qu'une action est requise. <br><br>  Si le verrou est désactivé, c'est-à-dire que les tâches ne peuvent pas être mises dans un état prêt par de nombreux appels d'API, des appels d'API supplémentaires deviennent disponibles: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Certains appels d'API sont toujours inaccessibles aux gestionnaires d'interruption standard, car ils nécessiteront inévitablement le travail d'un planificateur: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Appels d'API au gestionnaire d'interruption géré ou au gestionnaire d'interruption standard lors de l'utilisation d'un planificateur autre que le planificateur prioritaire</i></b> <br><br>  De nombreuses autres fonctions API peuvent être appelées à partir du gestionnaire d'interruption lors de l'utilisation des planificateurs Run to Completion, Round Robin ou Time Slice.  Si un planificateur de priorité est utilisé, les gestionnaires d'interruption gérés ont un ensemble de fonctions similaire.  En effet, les appels sont autorisés, ce qui peut conduire à planifier une autre tâche.  Cette fonctionnalité est fournie par le code <b>NUSE_Reschedule ()</b> , qui détecte le contexte d'appel dans le gestionnaire d'interruption et supprime le changement de contexte (lui permettant de se produire à la fin du gestionnaire d'interruption).  Une analyse complète du travail de l'ordonnanceur a été donnée dans l'un des articles précédents ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 9</a> ). <br><br>  La principale exigence est que les appels d'API à l'intérieur du gestionnaire d'interruptions ne doivent pas conduire à une suspension de la tâche en cours, par exemple, en attendant de libérer une ressource. <br><br>  En d'autres termes, ces appels doivent être effectués avec l' <b>option de</b> pause <b>NUSE_NO_SUSPEND</b> . <br><br>  Dans cet esprit, les appels d'API suivants peuvent être utilisés: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Certains appels sont toujours interdits, car ils se rapportent directement à la tâche en cours: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Gestionnaire d'interruption d'horloge en temps réel </h2><br>  Le gestionnaire d'interruption RTC (Real Time Clock) est le seul gestionnaire d'interruption complet dans Nucleus SE.  En plus de fournir toutes les fonctionnalités nécessaires à la gestion du temps dans Nucleus SE, il sert également d'exemple d'écriture d'un gestionnaire d'interruption géré. <br><br><h3>  Opérations du gestionnaire d'interruption RTC </h3><br>  Les fonctions fournies par le gestionnaire d'interruption RTC ont été répertoriées dans l'un des articles précédents, qui traitaient du vaste sujet de l'heure système dans Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 27</a> ).  La fonctionnalité décrite est facultative selon la configuration de l'application. <br><br><div class="spoiler">  <b class="spoiler_title">Voici le code complet du gestionnaire d'interruption RTC.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Ensuite, nous examinons quatre principaux domaines de fonctionnalité pour le gestionnaire d'interruption RTC. <br><br>  <b><i>Minuteries</i></b> <br>  Si les temporisateurs d'application sont configurés, le gestionnaire d'interruption passe en boucle pour traiter chaque temporisateur en diminuant son compteur de 1. Si le temporisateur termine le comptage (c'est-à-dire que le compteur atteint 0), deux actions sont possibles: <br><br><ul><li>  si le gestionnaire de fin de temporisation est configuré et que le temporisateur a un pointeur de fonction correct (non <b>NULL</b> ) (dans <b>NUSE_Timer_Expiration_Routine_Address []</b> ), le gestionnaire est exécuté en prenant un paramètre de <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  si le temporisateur est configuré pour s'initialiser après la fin (c'est-à-dire que <b>NUSE_Timer_Reschedule_Time []</b> a une valeur non nulle), le temporisateur se recharge avec cette valeur. </li></ul><br>  Les temporisateurs d'application ont été décrits en détail dans un article précédent (# 28). <br><br>  <b><i>Horloge système</i></b> <br>  Si un temporisateur système est configuré, la valeur de <b>NUSE_Tick_Cloc</b> k augmente simplement de 1. Plus d'informations peuvent être trouvées dans l'article # 28. <br><br>  <b><i>Suspendre une tâche (veille de tâche)</i></b> <br>  Si la prise en charge des tâches de pause est activée (c'est-à-dire que l'API <b>NUSE_Task_Sleep ()</b> est configuré), le compteur de délai d'attente de chaque tâche (la valeur dans <b>NUSE_Task_Timeout_Counter []</b> ) est vérifié, et s'il n'est pas égal à zéro, diminue de 1. S'il atteint zéro, la tâche correspondante reprend. . <br><br>  <b><i>Planification des tranches de temps</i></b> <br>  Si un planificateur de tranche de temps est utilisé, le compteur du planificateur ( <b>NUSE_Time_Slice_Ticks</b> ) est décrémenté.  S'il atteint zéro, l'ordonnanceur est appelé.  L'appel à <b>NUSE_Reschedule ()</b> est responsable de la réinitialisation du compteur. <br><br><h3>  Interruption contrôlée </h3><br>  Il est nécessaire d'expliquer pourquoi le gestionnaire d'interruption RTC est contrôlable, car dans certaines circonstances, l'utilisateur peut décider de le réécrire en tant qu'interruption standard pour réduire l'utilisation des ressources informatiques.  Par exemple, si une seule fonction d'heure système est utilisée (c'est-à-dire qu'il n'y a pas de temporisation d'application, pas de suspension de tâche et pas de planificateur de tranche horaire), une interruption régulière fonctionnera.  Une interruption guidée est requise dans les cas suivants: <br><br><ul><li>  si des temporisateurs sont utilisés et que des gestionnaires pour leur exécution sont configurés, car ces gestionnaires peuvent effectuer des appels API (à partir du contexte d'interruption), ce qui entraînera une nouvelle planification.  Ils ont les mêmes limitations que les appels d'API effectués à partir de gestionnaires d'interruptions (voir plus haut dans cet article); </li><li>  si un planificateur de priorité est utilisé, l'achèvement d'une suspension de tâche peut nécessiter de réveiller une tâche avec une priorité plus élevée; </li><li>  si le planificateur de tranche de temps est utilisé, il sera appelé à partir du gestionnaire d'interruption RTC, par conséquent, une interruption contrôlée est requise. </li></ul><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Étant donné que la mise en œuvre des interruptions Nucleus SE est très différente de Nucleus RTOS, vous ne devez pas vous attendre à une compatibilité à cet égard.  Nucleus RTOS a un schéma d'interruption standard / bas niveau / haut niveau, qui est un peu comme le schéma d'interruption standard / contrôlé dans Nucleus SE. <br><br><h3>  Gestionnaires d'interruption de bas et de haut niveau </h3><br>  <b><i>Gestionnaires d'interruption de bas niveau</i></b> <br>  Un routage de service d'interruption de bas niveau (LISR) est exécuté de la même manière qu'un gestionnaire ordinaire, y compris en utilisant la pile actuelle.  Nucleus RTOS maintient le contexte jusqu'à ce que le gestionnaire d'interruption de bas niveau soit appelé et restaure le contexte une fois le gestionnaire terminé.  Par conséquent, un gestionnaire d'interruption de bas niveau peut être écrit en C et peut appeler d'autres gestionnaires en C. Cependant, seuls quelques services Nucleus RTOS sont disponibles pour le gestionnaire de bas niveau.  Si la gestion des interruptions nécessite des services Nucleus RTOS supplémentaires, vous devez activer un gestionnaire d'interruption de haut niveau.  Nucleus RTOS prend en charge l'utilisation de plusieurs gestionnaires d'interruption de bas niveau. <br><br>  <b><i>Gestionnaire d'interruption de haut niveau</i></b> <br>  Les routines de service d'interruption de haut niveau (HISR) sont créées et supprimées dynamiquement.  Chaque processeur de haut niveau possède son propre espace de pile et sa propre unité de contrôle.  La mémoire est allouée par l'application.  Et, bien sûr, un gestionnaire d'interruption de haut niveau doit être créé avant qu'un gestionnaire d'interruption de bas niveau puisse l'activer. <br><br>  Étant donné que le gestionnaire d'interruption de haut niveau possède sa propre pile et unité de contrôle, il peut être temporairement bloqué s'il essaie d'accéder à la structure de données Nucleus RTOS actuellement utilisée. <br><br>  Il existe trois niveaux de priorité disponibles pour un gestionnaire d'interruption de haut niveau.  Si un gestionnaire de niveau supérieur avec une priorité plus élevée est activé pendant le travail d'un gestionnaire avec une priorité inférieure, un gestionnaire avec une priorité inférieure sera exécuté à la fin de la tâche.  Les gestionnaires d'interruption de haut niveau avec la même priorité sont exécutés dans l'ordre où ils sont activés.  Tous les gestionnaires d'interruption de haut niveau activés doivent être terminés avant de continuer à planifier des tâches en mode normal. <br><br><h3>  L'utilitaire Nucleus RTOS API appelle à une interruption </h3><br>  Nucleus RTOS dispose de plusieurs appels API pour prendre en charge les interruptions.  Aucun d'eux n'est implémenté dans Nucleus SE. <br><br>  Pour les interruptions standard, les appels d'API fournissent les fonctions suivantes: <br><br><ul><li>  contrôle (activation / désactivation) de l'interruption (localement et globalement); </li><li>  définir le vecteur d'interruption. </li></ul><br>  Pour les interruptions de bas niveau: <br><br><ul><li>  enregistrer un gestionnaire d'interruption de bas niveau dans le noyau. </li></ul><br>  Pour les interruptions de haut niveau: <br><br><ul><li>  création / suppression d'interruptions de haut niveau; </li><li>  activation d'interruption de haut niveau; </li><li>  obtenir le nombre d'interruptions de haut niveau dans l'application (pour le moment); </li><li>  obtenir des pointeurs pour contrôler les unités de toutes les interruptions de haut niveau; </li><li>  obtenir des pointeurs pour contrôler les unités de l'interruption de haut niveau actuelle; </li><li>  Obtenir des informations d'interruption de haut niveau. </li></ul><br>  <b><i>Contrôle global des interruptions</i></b> <br><br>  Cet appel active ou désactive les interruptions quelle que soit la tâche.  Par conséquent, l'interruption désactivée par cet appel le restera jusqu'à ce qu'elle soit activée en réutilisant cet appel. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Paramètres: <br><br>  <b>new_level</b> - un nouveau niveau d'interruption pour le système.  Il peut toujours prendre les valeurs <b>NU_DISABLE_INTERRUPTS</b> (désactive toutes les interruptions) et <b>NU_ENABLE_INTERRUPTS</b> (active toutes les interruptions).  D'autres valeurs peuvent être disponibles selon l'architecture. <br><br>  Valeur de retour: <br><br>  Cet appel de service renvoie le niveau précédent d'interruptions activées. <br><br>  <b><i>Contrôle d'interruption local</i></b> <br><br>  Cet appel de service vous permet d'activer ou de désactiver des interruptions en fonction de la tâche.  Cet appel modifie le registre d'état à la valeur spécifiée.  Le registre d'état sera retourné à la valeur spécifiée par le dernier appel à <b>NU_Control_Interrupts () la</b> prochaine fois que le contexte sera modifié. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Paramètres: <br><br>  <b>new_level</b> - un nouveau niveau d'interruption pour la tâche en cours.  Il peut toujours prendre les valeurs <b>NU_DISABLE_INTERRUPTS</b> (désactive toutes les interruptions) et <b>NU_ENABLE_INTERRUPTS</b> (active toutes les interruptions).  D'autres valeurs peuvent être disponibles selon l'architecture. <br><br>  Valeur de retour: <br>  Cet appel de service renvoie le niveau précédent d'interruptions activées. <br><br>  <b><i>Définition du vecteur d'interruption</i></b> <br><br>  Cette surcharge remplace le vecteur d'interruption spécifié par le vecteur contrôlé par le gestionnaire d'interruption. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Paramètres: <br><br>  <b>vecteur</b> - <b>vecteur d'</b> interruption pour lequel l'interruption sera enregistrée; <br>  <b>new</b> est le gestionnaire d'interruption écrit pour le vecteur. <br><br>  Valeur de retour: <br><br>  Cet appel d'utilitaire renvoie un pointeur sur le gestionnaire d'interruption précédemment enregistré pour le vecteur d'interruption. <br><br>  <b><i>Journalisation des interruptions de bas niveau</i></b> <br><br>  Cette surcharge appelle la fonction du gestionnaire d'interruption de bas niveau avec le vecteur d'interruption.  Le contexte système est automatiquement enregistré avant l'appel du gestionnaire d'interruption de bas niveau spécifié et restauré une fois le gestionnaire d'interruption terminé. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Paramètres: <br><br>  <b>vecteur</b> - <b>vecteur d'</b> interruption pour lequel l'interruption sera enregistrée; <br>  <b>lisr_entry</b> - la fonction qui sera enregistrée pour le vecteur, la valeur <b>NU_NULL effacera</b> le vecteur; <br>  <b>old_lisr</b> est une fonction précédemment enregistrée pour le vecteur spécifié. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_VECTOR</b> - vecteur invalide; <br>  <b>NU_NOT_Rector</b> - au moment où le vecteur n'est pas enregistré, car le <b>désenregistrement a</b> été spécifié dans l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - Le nombre maximal de gestionnaires d'interruption de bas niveau enregistrés a été atteint. <br><br>  <b><i>Création d'un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire crée un gestionnaire d'interruption de haut niveau. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Paramètres: <br><br>  <b>hisr</b> - un pointeur vers un bloc de contrôle fourni par l'utilisateur pour un gestionnaire d'interruption de haut niveau; <br>  <b>nom</b> - pointeur vers un <b>nom</b> à 7 caractères pour un gestionnaire d'interruption de haut niveau avec un zéro de fin; <br>  <b>hisr_entry</b> - le point d'entrée de la fonction de gestionnaire d'interruption de haut niveau; <br>  <b>priorité</b> - il existe trois priorités pour les gestionnaires d'interruption de haut niveau (0-2);  la priorité 0 est la plus élevée; <br>  <b>stack_pointer</b> - pointeur vers la zone de pile du gestionnaire d'interruption de haut niveau; <br>  <b>stack_size</b> - le nombre d'octets dans la pile du gestionnaire d'interruption de haut niveau. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_HISR</b> - un pointeur nul vers l'unité de contrôle du gestionnaire d'interruption de haut niveau ( <b>NULL</b> ) ou l'unité de contrôle est déjà en cours d'utilisation; <br>  <b>NU_INVALID_ENTRY</b> - un pointeur nul vers le point d'entrée d'un gestionnaire d'interruption de haut niveau ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - priorité incorrecte pour un gestionnaire d'interruption de haut niveau; <br>  <b>NU_INVALID_MEMORY</b> - pointeur de pile invalide; <br>  <b>NU_INVALID_SIZE</b> - la taille de la pile est trop petite. <br><br>  <b><i>Suppression d'un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire supprime le gestionnaire d'interruption de haut niveau précédemment créé. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Paramètres: <br><br>  <b>hisr</b> est un pointeur sur le bloc de contrôle du gestionnaire d'interruption de haut niveau fourni par l'utilisateur. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_HISR</b> - Pointeur <b>non valide</b> vers un gestionnaire d'interruption de haut niveau. <br><br>  <b><i>Activation d'un gestionnaire d'interruption de haut niveau</i></b> <br><br>  Cet appel d'utilitaire active un gestionnaire d'interruption de haut niveau.  Si le gestionnaire d'interruption de haut niveau spécifié est en cours d'exécution, la demande d'activation n'est pas exécutée jusqu'à ce que le gestionnaire cesse de fonctionner.  Un gestionnaire d'interruption de haut niveau est exécuté une fois pour chaque demande d'activation. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Paramètres: <br><br>  <b>hisr</b> est un pointeur sur le bloc de contrôle d'un gestionnaire d'interruption de haut niveau. <br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_HISR</b> - pointeur non valide vers l'unité de contrôle d'un gestionnaire d'interruption de haut niveau. <br><br>  <b><i>Obtention du nombre de gestionnaires d'interruption de haut niveau dans un système</i></b> <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau installés.  Tous les gestionnaires d'interruption de haut niveau créés sont considérés comme installés.  Les gestionnaires d'interruption de haut niveau à distance ne sont pas considérés comme installés. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau installés dans le système. <br><br>  <b><i>Obtenir des pointeurs pour contrôler les blocs de gestionnaires d'interruption de haut niveau</i></b> <br><br>  Cet appel de service forme une liste séquentielle de pointeurs vers tous les gestionnaires d'interruption de haut niveau installés dans le système. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Paramètres: <br><br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_HISR</b> ;  ce tableau sera rempli de pointeurs vers les gestionnaires d'interruption de haut niveau installés dans le système; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs <b>NU_HISR</b> pouvant être placés dans le tableau;  il est généralement égal à la taille du tableau <b>pointer_list</b> . <br><br>  Valeur de retour: <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau actifs dans le système. <br><br>  <b><i>Obtention d'un pointeur vers le gestionnaire d'interruption de haut niveau actuel</i></b> <br>  Cet appel d'utilitaire renvoie un pointeur sur le gestionnaire d'interruption de haut niveau en cours d'exécution. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Cet appel de service renvoie un pointeur vers l'unité de contrôle du gestionnaire d'interruption de haut niveau en cours d'exécution.  Si un gestionnaire d'interruption non de haut niveau appelle cette fonction, <b>NU_NULL est</b> renvoyé. <br><br>  <b><i>Obtention d'informations sur un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire renvoie diverses informations sur le gestionnaire d'interruption de haut niveau spécifié. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Paramètres: <br><br>  <b>hisr</b> - un pointeur vers un gestionnaire d'interruption de haut niveau; <br>  <b>nom</b> - pointeur vers la région à 8 caractères pour le nom du gestionnaire d'interruption de haut niveau, y compris le zéro de fin; <br>  <b>schedule_count</b> - pointeur sur une variable pour le nombre total de fois que ce gestionnaire d'interruption de haut niveau a été planifié; <br>  <b>priorité</b> - un pointeur sur une variable pour stocker la priorité d'un gestionnaire d'interruption de haut niveau; <br>  <b>stack_base</b> - pointeur vers un pointeur pour stocker le pointeur d'origine dans la pile;  il s'agit du même pointeur qui a été transmis lors de la création du gestionnaire d'interruption de haut niveau; <br>  <b>stack_size</b> - un pointeur vers une variable pour stocker la taille totale de la pile d'un gestionnaire d'interruption de haut niveau; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un pointeur vers une variable pour stocker la quantité minimale d'espace de pile disponible détectée lors de l'exécution d'un gestionnaire d'interruption de haut niveau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur de retour: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - l'appel s'est terminé avec succès; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pointeur non valide vers un gestionnaire d'interruption de haut niveau.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appels API des gestionnaires d'interruption </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appel d'API à partir de gestionnaires d'interruption de bas niveau Un gestionnaire d'interruption de bas niveau</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut utiliser que les fonctionnalités Nucleus RTOS suivantes:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels de service API à partir de gestionnaires d'interruption de haut niveau Les gestionnaires d'interruption de</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haut niveau ont accès à la plupart des fonctions Nucleus RTOS, à l'exception des fonctions à pause automatique, puisqu'un gestionnaire d'interruption de haut niveau ne peut pas suspendre la fonction Nucleus RTOS, le paramètre doit toujours être</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le prochain article de cette série couvrira les procédures d'initialisation et de démarrage de Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> À propos de l'auteur:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, passant la plupart de son temps sur le firmware. </font><font style="vertical-align: inherit;">Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware. </font><font style="vertical-align: inherit;">Vit au Royaume-Uni. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professionnel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458770/">https://habr.com/ru/post/fr458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458758/index.html">La splendeur et la pauvreté de la littérature traduite</a></li>
<li><a href="../fr458760/index.html">L'exposition de Las Vegas s'adresse aux développeurs d'électronique et non aux consommateurs. Un rapport de la conférence Design Automation</a></li>
<li><a href="../fr458764/index.html">Pratiques de base agiles pour les équipes techniques et non techniques en 2019</a></li>
<li><a href="../fr458766/index.html">IronPython du côté du mal: comment nous avons découvert une cyberattaque sur les services publics dans un pays européen</a></li>
<li><a href="../fr458768/index.html">5-6 raisons de venir à GolangConf</a></li>
<li><a href="../fr458774/index.html">SGBD fonctionnel</a></li>
<li><a href="../fr458778/index.html">Satellite 6.5 Reporting Engine: quoi et pourquoi</a></li>
<li><a href="../fr458782/index.html">Adaptation de programmes pour ZX Spectrum à TR-DOS par des moyens modernes. 3e partie</a></li>
<li><a href="../fr458784/index.html">Diffuser des projets et des bibliothèques d'Altium Designer vers PADS Professional</a></li>
<li><a href="../fr458786/index.html">Les gardiens de jeux vidéo gardent la culture du jeu étape par étape</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>