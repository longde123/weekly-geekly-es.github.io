<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òëÔ∏è üë©üèæ‚Äçü§ù‚Äçüë®üèª ‚èÆÔ∏è Toute la v√©rit√© sur RTOS. Article # 29. Interruptions dans Nucleus SE üç£ üë®‚ÄçüöÄ üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tous les microprocesseurs et microcontr√¥leurs modernes contiennent une sorte de m√©canisme d'interruption. Ces m√©canismes sont n√©cessaires pour fournir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la v√©rit√© sur RTOS. Article # 29. Interruptions dans Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Tous les microprocesseurs et microcontr√¥leurs modernes contiennent une sorte de m√©canisme d'interruption.  Ces m√©canismes sont n√©cessaires pour fournir la r√©activit√© requise par de nombreuses applications.  Bien s√ªr, la r√©activit√© et la pr√©visibilit√© sont le principal objectif lors de l'utilisation de RTOS, mais en m√™me temps, ils sont oppos√©s.  L'utilisation d'interruptions peut perturber l'int√©grit√© du syst√®me d'exploitation en temps r√©el.  Ce probl√®me et sa solution ont √©t√© mentionn√©s dans l'un des articles pr√©c√©dents (# 4 et # 6).  Dans cet article, nous examinerons la strat√©gie de gestion des interruptions utilis√©e dans Nucleus SE.  Dans tous les cas, les interruptions ne sont PAS contr√¥l√©es par Nucleus SE: elles sont trait√©es lorsqu'elles se produisent en fonction de la priorit√© et des vecteurs de la mani√®re habituelle.  Leur temps d'ex√©cution est simplement ¬´vol√©¬ª au temps disponible dans le code de l'application principale et de l'ordonnanceur.  De toute √©vidence, il s'ensuit que tous les gestionnaires d'interruptions doivent √™tre simples, courts et rapides. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Articles pr√©c√©dents de la s√©rie:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minuteries logicielles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heure syst√®me</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de donn√©es: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'√©v√©nements: services d'assistance et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'√©v√©nements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de m√©moire: services et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de m√©moire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de donn√©es de t√¢che et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches: configuration et introduction √† l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalit√©s avanc√©es et pr√©servation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: impl√©mentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et d√©ploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps r√©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br></div></div><br><h2>  Interruptions r√©guli√®res et contr√¥l√©es </h2><br>  Nucleus SE propose deux fa√ßons de g√©rer les interruptions: ¬´native¬ª ou ¬´r√©guli√®re¬ª (Native), dans lesquelles les interruptions n'ont rien de sp√©cial et ont dans une certaine mesure une interaction limit√©e avec le syst√®me d'exploitation (au moins lors de l'utilisation du planificateur de priorit√©), et ¬´ G√©r√©, dans lequel vous pouvez acc√©der √† un nombre beaucoup plus √©lev√© d'appels d'API √† partir du gestionnaire d'interruption. <br><br>  √Ä l'aide des macros d'E / S, le gestionnaire d'interruption Nucleus SE peut √™tre utilis√© en mode standard ou g√©r√©. <br><br><h3>  Interruptions du personnel </h3><br>  Les interruptions de personnel de Nucleus SE sont le gestionnaire d'interruption standard et peuvent √™tre consid√©r√©es comme "non g√©r√©es".  Ils sont g√©n√©ralement utilis√©s lorsqu'une interruption peut survenir √† une fr√©quence √©lev√©e et n√©cessite un traitement avec une faible utilisation des ressources informatiques.  Un tel gestionnaire est probablement √©crit en C, car de nombreux compilateurs int√©gr√©s modernes prennent en charge le d√©veloppement de gestionnaires d'interruptions √† l'aide du mot-cl√© interruption.  Seules les informations contextuelles que le compilateur juge n√©cessaires sont stock√©es.  Cela conduit √† des limitations importantes sur ce que les gestionnaires d'interruption standard peuvent faire, ce que nous verrons bient√¥t. <br><br>  Pour cr√©er un gestionnaire d'interruption r√©gulier dans Nucleus SE, il suffit d'√©crire simplement un gestionnaire d'interruption r√©gulier, y compris en appelant la macro <b>NUSE_NISR_Enter ()</b> au d√©but et en appelant <b>NUSE_NISR_Exit ()</b> √† la fin.  Ces macros sont d√©finies dans le fichier <b>nuse_types.</b>  h et d√©finissez la variable globale <b>NUSE_Task_State</b> sur <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Interruptions guid√©es </h3><br>  Si vous avez besoin de plus de flexibilit√© pour les op√©rations du gestionnaire d'interruptions, les interruptions g√©r√©es par Nucleus SE peuvent √™tre la solution.  La principale diff√©rence par rapport √† l'interruption standard est le maintien du contexte.  Au lieu de permettre au compilateur d'enregistrer plusieurs registres sur la pile, une interruption contr√¥l√©e enregistre le contexte entier de la t√¢che (dans son propre bloc de contexte) √† l'entr√©e.  Le contexte de la t√¢che en cours est ensuite restaur√© √† partir du bloc de contexte en sortie.  Cela permet de modifier la t√¢che en cours gr√¢ce au travail du code du gestionnaire d'interruption, ce qui est possible lors de l'utilisation du planificateur de priorit√©.  Une description compl√®te de la pr√©servation et de la restauration du contexte dans Nucleus SE a √©t√© fournie dans un article pr√©c√©dent ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 10</a> ). <br><br>  √âvidemment, la pleine conservation du contexte entra√Æne une augmentation de l'utilisation des ressources informatiques par rapport au stockage de plusieurs registres sur la pile, ce qui se produit lors d'une interruption standard.  Ce prix doit √™tre pay√© pour une flexibilit√© suppl√©mentaire, et c'est la raison pour laquelle un choix d'approche de gestion des interruptions est propos√©. <br><br>  Une interruption g√©r√©e est <b>g√©n√©r√©e √†</b> l'aide de la macro <b>NUSE_MANAGED_ISR ()</b> d√©crite dans <b>nuse_types.h</b> .  Cette macro cr√©e une fonction qui contient les actions suivantes: <br><br><ul><li>  maintenir le contexte de la t√¢che; </li><li>  Affectation de <b>NUSE_Task_State √†</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  code de fonction du gestionnaire d'interruption fourni par l'utilisateur; </li><li>  restaurer <b>NUSE_Task_State</b> √† son √©tat pr√©c√©dent; </li><li>  restaurer le contexte de la t√¢che. </li></ul><br>  La macro prend deux param√®tres: le nom d'interruption utilis√© comme nom de fonction pour le gestionnaire g√©n√©r√© et le nom de la fonction qui contient la logique utilisateur pour le gestionnaire d'interruption. <br><br><h3>  Appels API du gestionnaire d'interruption </h3><br>  L'ensemble des fonctions API pouvant √™tre appel√©es √† partir d'un gestionnaire d'interruption standard ou g√©r√© d√©pend du planificateur utilis√©.  De mani√®re g√©n√©rale, l'utilisation du planificateur de priorit√© offre de nombreuses options pour acc√©der au planificateur via un appel de fonction API, ce qui est difficile lors de l'utilisation du gestionnaire d'interruption standard. <br><br>  <b><i>Appels d'API au gestionnaire d'interruption standard lors de l'utilisation du planificateur de priorit√©</i></b> <br><br>  Lorsque vous utilisez le planificateur de priorit√©, un nombre limit√© d'appels de fonction API √† partir du gestionnaire d'interruption standard sont autoris√©s.  Cette limitation est le r√©sultat de la flexibilit√© de l'API Nucleus SE: de nombreux appels peuvent rendre la t√¢che pr√™te et le planificateur peut ne pas √™tre appel√© par le gestionnaire d'interruption standard (car le contexte de la t√¢che n'est pas enregistr√©).  La d√©sactivation des verrous de t√¢che offre encore plus de flexibilit√©. <br><br>  Les appels d'API suivants sont toujours autoris√©s: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Cependant, seul <b>NUSE_Signals_Send () leur</b> est utile, car il fournit un moyen pratique d'indiquer √† la t√¢che qu'une action est requise. <br><br>  Si le verrou est d√©sactiv√©, c'est-√†-dire que les t√¢ches ne peuvent pas √™tre mises dans un √©tat pr√™t par de nombreux appels d'API, des appels d'API suppl√©mentaires deviennent disponibles: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Certains appels d'API sont toujours inaccessibles aux gestionnaires d'interruption standard, car ils n√©cessiteront in√©vitablement le travail d'un planificateur: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Appels d'API au gestionnaire d'interruption g√©r√© ou au gestionnaire d'interruption standard lors de l'utilisation d'un planificateur autre que le planificateur prioritaire</i></b> <br><br>  De nombreuses autres fonctions API peuvent √™tre appel√©es √† partir du gestionnaire d'interruption lors de l'utilisation des planificateurs Run to Completion, Round Robin ou Time Slice.  Si un planificateur de priorit√© est utilis√©, les gestionnaires d'interruption g√©r√©s ont un ensemble de fonctions similaire.  En effet, les appels sont autoris√©s, ce qui peut conduire √† planifier une autre t√¢che.  Cette fonctionnalit√© est fournie par le code <b>NUSE_Reschedule ()</b> , qui d√©tecte le contexte d'appel dans le gestionnaire d'interruption et supprime le changement de contexte (lui permettant de se produire √† la fin du gestionnaire d'interruption).  Une analyse compl√®te du travail de l'ordonnanceur a √©t√© donn√©e dans l'un des articles pr√©c√©dents ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 9</a> ). <br><br>  La principale exigence est que les appels d'API √† l'int√©rieur du gestionnaire d'interruptions ne doivent pas conduire √† une suspension de la t√¢che en cours, par exemple, en attendant de lib√©rer une ressource. <br><br>  En d'autres termes, ces appels doivent √™tre effectu√©s avec l' <b>option de</b> pause <b>NUSE_NO_SUSPEND</b> . <br><br>  Dans cet esprit, les appels d'API suivants peuvent √™tre utilis√©s: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Certains appels sont toujours interdits, car ils se rapportent directement √† la t√¢che en cours: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Gestionnaire d'interruption d'horloge en temps r√©el </h2><br>  Le gestionnaire d'interruption RTC (Real Time Clock) est le seul gestionnaire d'interruption complet dans Nucleus SE.  En plus de fournir toutes les fonctionnalit√©s n√©cessaires √† la gestion du temps dans Nucleus SE, il sert √©galement d'exemple d'√©criture d'un gestionnaire d'interruption g√©r√©. <br><br><h3>  Op√©rations du gestionnaire d'interruption RTC </h3><br>  Les fonctions fournies par le gestionnaire d'interruption RTC ont √©t√© r√©pertori√©es dans l'un des articles pr√©c√©dents, qui traitaient du vaste sujet de l'heure syst√®me dans Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 27</a> ).  La fonctionnalit√© d√©crite est facultative selon la configuration de l'application. <br><br><div class="spoiler">  <b class="spoiler_title">Voici le code complet du gestionnaire d'interruption RTC.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Ensuite, nous examinons quatre principaux domaines de fonctionnalit√© pour le gestionnaire d'interruption RTC. <br><br>  <b><i>Minuteries</i></b> <br>  Si les temporisateurs d'application sont configur√©s, le gestionnaire d'interruption passe en boucle pour traiter chaque temporisateur en diminuant son compteur de 1. Si le temporisateur termine le comptage (c'est-√†-dire que le compteur atteint 0), deux actions sont possibles: <br><br><ul><li>  si le gestionnaire de fin de temporisation est configur√© et que le temporisateur a un pointeur de fonction correct (non <b>NULL</b> ) (dans <b>NUSE_Timer_Expiration_Routine_Address []</b> ), le gestionnaire est ex√©cut√© en prenant un param√®tre de <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  si le temporisateur est configur√© pour s'initialiser apr√®s la fin (c'est-√†-dire que <b>NUSE_Timer_Reschedule_Time []</b> a une valeur non nulle), le temporisateur se recharge avec cette valeur. </li></ul><br>  Les temporisateurs d'application ont √©t√© d√©crits en d√©tail dans un article pr√©c√©dent (# 28). <br><br>  <b><i>Horloge syst√®me</i></b> <br>  Si un temporisateur syst√®me est configur√©, la valeur de <b>NUSE_Tick_Cloc</b> k augmente simplement de 1. Plus d'informations peuvent √™tre trouv√©es dans l'article # 28. <br><br>  <b><i>Suspendre une t√¢che (veille de t√¢che)</i></b> <br>  Si la prise en charge des t√¢ches de pause est activ√©e (c'est-√†-dire que l'API <b>NUSE_Task_Sleep ()</b> est configur√©), le compteur de d√©lai d'attente de chaque t√¢che (la valeur dans <b>NUSE_Task_Timeout_Counter []</b> ) est v√©rifi√©, et s'il n'est pas √©gal √† z√©ro, diminue de 1. S'il atteint z√©ro, la t√¢che correspondante reprend. . <br><br>  <b><i>Planification des tranches de temps</i></b> <br>  Si un planificateur de tranche de temps est utilis√©, le compteur du planificateur ( <b>NUSE_Time_Slice_Ticks</b> ) est d√©cr√©ment√©.  S'il atteint z√©ro, l'ordonnanceur est appel√©.  L'appel √† <b>NUSE_Reschedule ()</b> est responsable de la r√©initialisation du compteur. <br><br><h3>  Interruption contr√¥l√©e </h3><br>  Il est n√©cessaire d'expliquer pourquoi le gestionnaire d'interruption RTC est contr√¥lable, car dans certaines circonstances, l'utilisateur peut d√©cider de le r√©√©crire en tant qu'interruption standard pour r√©duire l'utilisation des ressources informatiques.  Par exemple, si une seule fonction d'heure syst√®me est utilis√©e (c'est-√†-dire qu'il n'y a pas de temporisation d'application, pas de suspension de t√¢che et pas de planificateur de tranche horaire), une interruption r√©guli√®re fonctionnera.  Une interruption guid√©e est requise dans les cas suivants: <br><br><ul><li>  si des temporisateurs sont utilis√©s et que des gestionnaires pour leur ex√©cution sont configur√©s, car ces gestionnaires peuvent effectuer des appels API (√† partir du contexte d'interruption), ce qui entra√Ænera une nouvelle planification.  Ils ont les m√™mes limitations que les appels d'API effectu√©s √† partir de gestionnaires d'interruptions (voir plus haut dans cet article); </li><li>  si un planificateur de priorit√© est utilis√©, l'ach√®vement d'une suspension de t√¢che peut n√©cessiter de r√©veiller une t√¢che avec une priorit√© plus √©lev√©e; </li><li>  si le planificateur de tranche de temps est utilis√©, il sera appel√© √† partir du gestionnaire d'interruption RTC, par cons√©quent, une interruption contr√¥l√©e est requise. </li></ul><br><h2>  Compatible avec Nucleus RTOS </h2><br>  √âtant donn√© que la mise en ≈ìuvre des interruptions Nucleus SE est tr√®s diff√©rente de Nucleus RTOS, vous ne devez pas vous attendre √† une compatibilit√© √† cet √©gard.  Nucleus RTOS a un sch√©ma d'interruption standard / bas niveau / haut niveau, qui est un peu comme le sch√©ma d'interruption standard / contr√¥l√© dans Nucleus SE. <br><br><h3>  Gestionnaires d'interruption de bas et de haut niveau </h3><br>  <b><i>Gestionnaires d'interruption de bas niveau</i></b> <br>  Un routage de service d'interruption de bas niveau (LISR) est ex√©cut√© de la m√™me mani√®re qu'un gestionnaire ordinaire, y compris en utilisant la pile actuelle.  Nucleus RTOS maintient le contexte jusqu'√† ce que le gestionnaire d'interruption de bas niveau soit appel√© et restaure le contexte une fois le gestionnaire termin√©.  Par cons√©quent, un gestionnaire d'interruption de bas niveau peut √™tre √©crit en C et peut appeler d'autres gestionnaires en C. Cependant, seuls quelques services Nucleus RTOS sont disponibles pour le gestionnaire de bas niveau.  Si la gestion des interruptions n√©cessite des services Nucleus RTOS suppl√©mentaires, vous devez activer un gestionnaire d'interruption de haut niveau.  Nucleus RTOS prend en charge l'utilisation de plusieurs gestionnaires d'interruption de bas niveau. <br><br>  <b><i>Gestionnaire d'interruption de haut niveau</i></b> <br>  Les routines de service d'interruption de haut niveau (HISR) sont cr√©√©es et supprim√©es dynamiquement.  Chaque processeur de haut niveau poss√®de son propre espace de pile et sa propre unit√© de contr√¥le.  La m√©moire est allou√©e par l'application.  Et, bien s√ªr, un gestionnaire d'interruption de haut niveau doit √™tre cr√©√© avant qu'un gestionnaire d'interruption de bas niveau puisse l'activer. <br><br>  √âtant donn√© que le gestionnaire d'interruption de haut niveau poss√®de sa propre pile et unit√© de contr√¥le, il peut √™tre temporairement bloqu√© s'il essaie d'acc√©der √† la structure de donn√©es Nucleus RTOS actuellement utilis√©e. <br><br>  Il existe trois niveaux de priorit√© disponibles pour un gestionnaire d'interruption de haut niveau.  Si un gestionnaire de niveau sup√©rieur avec une priorit√© plus √©lev√©e est activ√© pendant le travail d'un gestionnaire avec une priorit√© inf√©rieure, un gestionnaire avec une priorit√© inf√©rieure sera ex√©cut√© √† la fin de la t√¢che.  Les gestionnaires d'interruption de haut niveau avec la m√™me priorit√© sont ex√©cut√©s dans l'ordre o√π ils sont activ√©s.  Tous les gestionnaires d'interruption de haut niveau activ√©s doivent √™tre termin√©s avant de continuer √† planifier des t√¢ches en mode normal. <br><br><h3>  L'utilitaire Nucleus RTOS API appelle √† une interruption </h3><br>  Nucleus RTOS dispose de plusieurs appels API pour prendre en charge les interruptions.  Aucun d'eux n'est impl√©ment√© dans Nucleus SE. <br><br>  Pour les interruptions standard, les appels d'API fournissent les fonctions suivantes: <br><br><ul><li>  contr√¥le (activation / d√©sactivation) de l'interruption (localement et globalement); </li><li>  d√©finir le vecteur d'interruption. </li></ul><br>  Pour les interruptions de bas niveau: <br><br><ul><li>  enregistrer un gestionnaire d'interruption de bas niveau dans le noyau. </li></ul><br>  Pour les interruptions de haut niveau: <br><br><ul><li>  cr√©ation / suppression d'interruptions de haut niveau; </li><li>  activation d'interruption de haut niveau; </li><li>  obtenir le nombre d'interruptions de haut niveau dans l'application (pour le moment); </li><li>  obtenir des pointeurs pour contr√¥ler les unit√©s de toutes les interruptions de haut niveau; </li><li>  obtenir des pointeurs pour contr√¥ler les unit√©s de l'interruption de haut niveau actuelle; </li><li>  Obtenir des informations d'interruption de haut niveau. </li></ul><br>  <b><i>Contr√¥le global des interruptions</i></b> <br><br>  Cet appel active ou d√©sactive les interruptions quelle que soit la t√¢che.  Par cons√©quent, l'interruption d√©sactiv√©e par cet appel le restera jusqu'√† ce qu'elle soit activ√©e en r√©utilisant cet appel. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Param√®tres: <br><br>  <b>new_level</b> - un nouveau niveau d'interruption pour le syst√®me.  Il peut toujours prendre les valeurs <b>NU_DISABLE_INTERRUPTS</b> (d√©sactive toutes les interruptions) et <b>NU_ENABLE_INTERRUPTS</b> (active toutes les interruptions).  D'autres valeurs peuvent √™tre disponibles selon l'architecture. <br><br>  Valeur de retour: <br><br>  Cet appel de service renvoie le niveau pr√©c√©dent d'interruptions activ√©es. <br><br>  <b><i>Contr√¥le d'interruption local</i></b> <br><br>  Cet appel de service vous permet d'activer ou de d√©sactiver des interruptions en fonction de la t√¢che.  Cet appel modifie le registre d'√©tat √† la valeur sp√©cifi√©e.  Le registre d'√©tat sera retourn√© √† la valeur sp√©cifi√©e par le dernier appel √† <b>NU_Control_Interrupts () la</b> prochaine fois que le contexte sera modifi√©. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Param√®tres: <br><br>  <b>new_level</b> - un nouveau niveau d'interruption pour la t√¢che en cours.  Il peut toujours prendre les valeurs <b>NU_DISABLE_INTERRUPTS</b> (d√©sactive toutes les interruptions) et <b>NU_ENABLE_INTERRUPTS</b> (active toutes les interruptions).  D'autres valeurs peuvent √™tre disponibles selon l'architecture. <br><br>  Valeur de retour: <br>  Cet appel de service renvoie le niveau pr√©c√©dent d'interruptions activ√©es. <br><br>  <b><i>D√©finition du vecteur d'interruption</i></b> <br><br>  Cette surcharge remplace le vecteur d'interruption sp√©cifi√© par le vecteur contr√¥l√© par le gestionnaire d'interruption. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Param√®tres: <br><br>  <b>vecteur</b> - <b>vecteur d'</b> interruption pour lequel l'interruption sera enregistr√©e; <br>  <b>new</b> est le gestionnaire d'interruption √©crit pour le vecteur. <br><br>  Valeur de retour: <br><br>  Cet appel d'utilitaire renvoie un pointeur sur le gestionnaire d'interruption pr√©c√©demment enregistr√© pour le vecteur d'interruption. <br><br>  <b><i>Journalisation des interruptions de bas niveau</i></b> <br><br>  Cette surcharge appelle la fonction du gestionnaire d'interruption de bas niveau avec le vecteur d'interruption.  Le contexte syst√®me est automatiquement enregistr√© avant l'appel du gestionnaire d'interruption de bas niveau sp√©cifi√© et restaur√© une fois le gestionnaire d'interruption termin√©. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Param√®tres: <br><br>  <b>vecteur</b> - <b>vecteur d'</b> interruption pour lequel l'interruption sera enregistr√©e; <br>  <b>lisr_entry</b> - la fonction qui sera enregistr√©e pour le vecteur, la valeur <b>NU_NULL effacera</b> le vecteur; <br>  <b>old_lisr</b> est une fonction pr√©c√©demment enregistr√©e pour le vecteur sp√©cifi√©. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_VECTOR</b> - vecteur invalide; <br>  <b>NU_NOT_Rector</b> - au moment o√π le vecteur n'est pas enregistr√©, car le <b>d√©senregistrement a</b> √©t√© sp√©cifi√© dans l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - Le nombre maximal de gestionnaires d'interruption de bas niveau enregistr√©s a √©t√© atteint. <br><br>  <b><i>Cr√©ation d'un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire cr√©e un gestionnaire d'interruption de haut niveau. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Param√®tres: <br><br>  <b>hisr</b> - un pointeur vers un bloc de contr√¥le fourni par l'utilisateur pour un gestionnaire d'interruption de haut niveau; <br>  <b>nom</b> - pointeur vers un <b>nom</b> √† 7 caract√®res pour un gestionnaire d'interruption de haut niveau avec un z√©ro de fin; <br>  <b>hisr_entry</b> - le point d'entr√©e de la fonction de gestionnaire d'interruption de haut niveau; <br>  <b>priorit√©</b> - il existe trois priorit√©s pour les gestionnaires d'interruption de haut niveau (0-2);  la priorit√© 0 est la plus √©lev√©e; <br>  <b>stack_pointer</b> - pointeur vers la zone de pile du gestionnaire d'interruption de haut niveau; <br>  <b>stack_size</b> - le nombre d'octets dans la pile du gestionnaire d'interruption de haut niveau. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_HISR</b> - un pointeur nul vers l'unit√© de contr√¥le du gestionnaire d'interruption de haut niveau ( <b>NULL</b> ) ou l'unit√© de contr√¥le est d√©j√† en cours d'utilisation; <br>  <b>NU_INVALID_ENTRY</b> - un pointeur nul vers le point d'entr√©e d'un gestionnaire d'interruption de haut niveau ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - priorit√© incorrecte pour un gestionnaire d'interruption de haut niveau; <br>  <b>NU_INVALID_MEMORY</b> - pointeur de pile invalide; <br>  <b>NU_INVALID_SIZE</b> - la taille de la pile est trop petite. <br><br>  <b><i>Suppression d'un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire supprime le gestionnaire d'interruption de haut niveau pr√©c√©demment cr√©√©. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Param√®tres: <br><br>  <b>hisr</b> est un pointeur sur le bloc de contr√¥le du gestionnaire d'interruption de haut niveau fourni par l'utilisateur. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_HISR</b> - Pointeur <b>non valide</b> vers un gestionnaire d'interruption de haut niveau. <br><br>  <b><i>Activation d'un gestionnaire d'interruption de haut niveau</i></b> <br><br>  Cet appel d'utilitaire active un gestionnaire d'interruption de haut niveau.  Si le gestionnaire d'interruption de haut niveau sp√©cifi√© est en cours d'ex√©cution, la demande d'activation n'est pas ex√©cut√©e jusqu'√† ce que le gestionnaire cesse de fonctionner.  Un gestionnaire d'interruption de haut niveau est ex√©cut√© une fois pour chaque demande d'activation. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Param√®tres: <br><br>  <b>hisr</b> est un pointeur sur le bloc de contr√¥le d'un gestionnaire d'interruption de haut niveau. <br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_HISR</b> - pointeur non valide vers l'unit√© de contr√¥le d'un gestionnaire d'interruption de haut niveau. <br><br>  <b><i>Obtention du nombre de gestionnaires d'interruption de haut niveau dans un syst√®me</i></b> <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau install√©s.  Tous les gestionnaires d'interruption de haut niveau cr√©√©s sont consid√©r√©s comme install√©s.  Les gestionnaires d'interruption de haut niveau √† distance ne sont pas consid√©r√©s comme install√©s. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Param√®tres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau install√©s dans le syst√®me. <br><br>  <b><i>Obtenir des pointeurs pour contr√¥ler les blocs de gestionnaires d'interruption de haut niveau</i></b> <br><br>  Cet appel de service forme une liste s√©quentielle de pointeurs vers tous les gestionnaires d'interruption de haut niveau install√©s dans le syst√®me. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Param√®tres: <br><br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_HISR</b> ;  ce tableau sera rempli de pointeurs vers les gestionnaires d'interruption de haut niveau install√©s dans le syst√®me; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs <b>NU_HISR</b> pouvant √™tre plac√©s dans le tableau;  il est g√©n√©ralement √©gal √† la taille du tableau <b>pointer_list</b> . <br><br>  Valeur de retour: <br>  Cet appel d'utilitaire renvoie le nombre de gestionnaires d'interruption de haut niveau actifs dans le syst√®me. <br><br>  <b><i>Obtention d'un pointeur vers le gestionnaire d'interruption de haut niveau actuel</i></b> <br>  Cet appel d'utilitaire renvoie un pointeur sur le gestionnaire d'interruption de haut niveau en cours d'ex√©cution. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Param√®tres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Cet appel de service renvoie un pointeur vers l'unit√© de contr√¥le du gestionnaire d'interruption de haut niveau en cours d'ex√©cution.  Si un gestionnaire d'interruption non de haut niveau appelle cette fonction, <b>NU_NULL est</b> renvoy√©. <br><br>  <b><i>Obtention d'informations sur un gestionnaire d'interruption de haut niveau</i></b> <br>  Cet appel d'utilitaire renvoie diverses informations sur le gestionnaire d'interruption de haut niveau sp√©cifi√©. <br><br>  Prototype d'appel de service: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Param√®tres: <br><br>  <b>hisr</b> - un pointeur vers un gestionnaire d'interruption de haut niveau; <br>  <b>nom</b> - pointeur vers la r√©gion √† 8 caract√®res pour le nom du gestionnaire d'interruption de haut niveau, y compris le z√©ro de fin; <br>  <b>schedule_count</b> - pointeur sur une variable pour le nombre total de fois que ce gestionnaire d'interruption de haut niveau a √©t√© planifi√©; <br>  <b>priorit√©</b> - un pointeur sur une variable pour stocker la priorit√© d'un gestionnaire d'interruption de haut niveau; <br>  <b>stack_base</b> - pointeur vers un pointeur pour stocker le pointeur d'origine dans la pile;  il s'agit du m√™me pointeur qui a √©t√© transmis lors de la cr√©ation du gestionnaire d'interruption de haut niveau; <br>  <b>stack_size</b> - un pointeur vers une variable pour stocker la taille totale de la pile d'un gestionnaire d'interruption de haut niveau; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un pointeur vers une variable pour stocker la quantit√© minimale d'espace de pile disponible d√©tect√©e lors de l'ex√©cution d'un gestionnaire d'interruption de haut niveau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur de retour: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - l'appel s'est termin√© avec succ√®s; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pointeur non valide vers un gestionnaire d'interruption de haut niveau.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appels API des gestionnaires d'interruption </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appel d'API √† partir de gestionnaires d'interruption de bas niveau Un gestionnaire d'interruption de bas niveau</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut utiliser que les fonctionnalit√©s Nucleus RTOS suivantes:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels de service API √† partir de gestionnaires d'interruption de haut niveau Les gestionnaires d'interruption de</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haut niveau ont acc√®s √† la plupart des fonctions Nucleus RTOS, √† l'exception des fonctions √† pause automatique, puisqu'un gestionnaire d'interruption de haut niveau ne peut pas suspendre la fonction Nucleus RTOS, le param√®tre doit toujours √™tre</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le prochain article de cette s√©rie couvrira les proc√©dures d'initialisation et de d√©marrage de Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä propos de l'auteur:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls travaille dans l'industrie √©lectronique depuis plus de trente ans, passant la plupart de son temps sur le firmware. </font><font style="vertical-align: inherit;">Il est maintenant ing√©nieur firmware chez Mentor Embedded (une division de Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls intervient souvent lors de conf√©rences et s√©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware. </font><font style="vertical-align: inherit;">Vit au Royaume-Uni. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professionnel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458770/">https://habr.com/ru/post/fr458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458758/index.html">La splendeur et la pauvret√© de la litt√©rature traduite</a></li>
<li><a href="../fr458760/index.html">L'exposition de Las Vegas s'adresse aux d√©veloppeurs d'√©lectronique et non aux consommateurs. Un rapport de la conf√©rence Design Automation</a></li>
<li><a href="../fr458764/index.html">Pratiques de base agiles pour les √©quipes techniques et non techniques en 2019</a></li>
<li><a href="../fr458766/index.html">IronPython du c√¥t√© du mal: comment nous avons d√©couvert une cyberattaque sur les services publics dans un pays europ√©en</a></li>
<li><a href="../fr458768/index.html">5-6 raisons de venir √† GolangConf</a></li>
<li><a href="../fr458774/index.html">SGBD fonctionnel</a></li>
<li><a href="../fr458778/index.html">Satellite 6.5 Reporting Engine: quoi et pourquoi</a></li>
<li><a href="../fr458782/index.html">Adaptation de programmes pour ZX Spectrum √† TR-DOS par des moyens modernes. 3e partie</a></li>
<li><a href="../fr458784/index.html">Diffuser des projets et des biblioth√®ques d'Altium Designer vers PADS Professional</a></li>
<li><a href="../fr458786/index.html">Les gardiens de jeux vid√©o gardent la culture du jeu √©tape par √©tape</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>