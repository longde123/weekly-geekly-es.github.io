<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆙 🖱️ 🌗 使用Python分析加密货币市场 😖 👳🏿 🚵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="比特币市场表现如何？ 加密货币价格突然上涨和下跌的原因是什么？ 在山寨币市场之间存在紧密不可分割的联系，还是它们彼此之间基本独立？ 我们如何预测未来会发生什么？ 



 加密货币推理的信息分析方法 
 推理和理论中充斥着有关比特币和以太坊等加密货币的文章。 数以百计的自封为专家而论的趋势，他们相信...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Python分析加密货币市场</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/406363/">  <i>比特币市场表现如何？</i>  <i>加密货币价格突然上涨和下跌的原因是什么？</i>  <i>在山寨币市场之间存在紧密不可分割的联系，还是它们彼此之间基本独立？</i>  <i>我们如何预测未来会发生什么？</i> <br><br><img src="https://habrastorage.org/web/74a/6d8/70f/74a6d870fa77478e950c47b297fe13c8.jpg" alt="图片"><br><br><h3> 加密货币推理的信息分析方法 </h3><br> 推理和理论中充斥着有关比特币和以太坊等加密货币的文章。 数以百计的自封为专家而论的趋势，他们相信很快就会显示出来。 许多此类分析肯定缺乏可以支持某些陈述的数据和统计形式的坚实基础。 <br><br> 本文的目的是提供使用Python进行加密货币分析的简单介绍。 在其中，我们将逐步介绍一个简单的Python脚本，用于接收，分析和可视化各种加密货币上的数据。 在工作过程中，我们将发现动荡市场行为的有趣趋势，并找出其中发生了什么变化。 <br><a name="habracut"></a><br> <a href=""><img src="https://habrastorage.org/web/8f9/37a/f50/8f937af50b104ff585b4571e1ae923a1.png" alt="图片"></a> <br><br> 这篇文章不会专门解释什么是加密货币（如果您需要这样的解释，我会建议您进行出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评论</a> ）。 不会讨论哪种特定货币的价值会上升或下降。 取而代之的是，该指南将重点关注获得粗略原始数据并查找隐藏在数字层下的历史记录。 <br><br><h3> 阶段1.我们装备了实验室 </h3><br> 本指南适用于各种爱好者，工程师和数据处理专业人员，无论其专业水平如何。 从这些技能中，您将只需要基本的Python理解和配置项目所需的最低命令行技能。 <br><br> 已完成工作的完整版本及其所有结果都可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处获得</a> 。 <br><br><h4>  1.1安装Anaconda </h4><br> 从头开始安装此项目的依赖关系的最简单方法是使用Anaconda，这是一个python生态系统和依赖关系管理器，其中包含用于处理数据和分析它们的所有必要软件包。 <br><br> 要安装Anaconda，建议您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的官方说明。 <br><br>  <i>如果您是高级用户，而Anaconda不符合您的喜好，则无需安装它。</i>  <i>在这种情况下，我认为您在安装必要的依赖项时不需要帮助，您可以直接进入第二阶段。</i> <br><br><h4>  1.2在Anaconda中设置项目环境 </h4> <br> 一旦安装了Anaconda，我们将希望创建一个新的环境来组织依赖项的工作。 <br><br> 输入命令<code>conda create --name cryptocurrency-analysis python=3</code>为我们的项目创建一个新的Anaconda环境。 <br><br> 接下来，输入<code>source activate cryptocurrency-analysis</code>和（在Linux / macOS上）或<code>activate cryptocurrency-analysis</code> （在Windows上）以激活环境。 <br><br> 最后， <code>conda install numpy pandas nb_conda jupyter plotly quandl</code>在环境中安装必要的依赖项。 此过程可能需要几分钟。 <br><br>  <i>我们为什么要使用环境？</i>  <i>如果计划同时使用计算机上的许多Python项目，则将依赖项（软件库和软件包）分开放置以避免冲突是很有用的。</i>  <i>在每个项目中，Anaconda都会为环境中的依赖项创建一个特殊的目录，使您可以将它们与其他项目的依赖项分开，并组织与之的工作。</i> <br><br><h4>  1.3启动Jupyter Notebook交互式笔记本 </h4><br> 安装环境和依赖项后，在控制台中键入<code>jupyter notebook</code>以启动iPython内核，并在浏览器中打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：8888 /</a>链接。 创建一个新的Python笔记本，确认其使用<code>Python [conda env:cryptocurrency-analysis]</code>内核<code>Python [conda env:cryptocurrency-analysis]</code> 。 <br><br><img src="https://habrastorage.org/web/6ff/35b/ada/6ff35badacfd44c58a1c4e3f55a3dd9f.png" alt="图片"><br><br><h4>  1.4将依赖项导入笔记本的顶部 </h4><br> 看到干净的Jupyter日志后，您首先需要导入必要的依赖项。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> quandl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime</code> </pre> <br> 此外，您必须导入Plotly并为其启用离线模式。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.offline <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.graph_objs <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.figure_factory <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ff py.init_notebook_mode(connected=True)</code> </pre> <br><h3> 第二阶段。获取比特币价格数据 </h3><br> 现在，所有设置均已完成，我们准备开始接收信息以进行分析。 首先，我们需要使用免费的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比特币API Quandl</a>请求比特币价格数据。 <br><br><h4>  2.1定义Quandl辅助函数 </h4><br> 为了帮助数据采集，我们将定义一个从Quandl下载和缓存数据集的函数。 <br><br><pre> <code class="javascript hljs">def get_quandl_data(quandl_id): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache Quandl dataseries'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> cache_path = <span class="hljs-string"><span class="hljs-string">'{}.pkl'</span></span>.format(quandl_id).replace(<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(quandl_id)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {} from Quandl'</span></span>.format(quandl_id)) df = quandl.get(quandl_id, returns=<span class="hljs-string"><span class="hljs-string">"pandas"</span></span>) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(quandl_id, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br> 为了转换下载的数据并将其保存到文件中，我们将使用<code>pickle</code> 。 这将防止每次我们运行脚本时再次下载相同的数据。 该函数将返回数据作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">熊猫</a>数据框。 如果您不熟悉数据框，则可以以功能非常强大的电子表格的形式显示它们。 <br><br><h4>  2.2我们从Kraken交易所获取价格数据 </h4><br> 首先，让我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kraken</a>交易所获取有关比特币汇率的历史数据。 <br><br><pre> <code class="javascript hljs"># Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(<span class="hljs-string"><span class="hljs-string">'BCHARTS/KRAKENUSD'</span></span>)</code> </pre> <br> 我们可以使用<code>head()</code>方法检查数据帧的前5行。 <br><br><pre> <code class="javascript hljs">btc_usd_price_kraken.head()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4c5/ee0/33f/4c5ee033ffe44eba96c137f6a3f3a828.PNG" alt="图片"></a> <br><br> 接下来，让我们生成一个简单的图形，以便快速直观地验证数据的正确性。 <br><br><pre> <code class="javascript hljs"># Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[<span class="hljs-string"><span class="hljs-string">'Weighted Price'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/934/c62/911/934c6291184b430bac5a2cd2fcfc01af.png" alt="图片"></a> <br><br> 为了可视化， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Plotly</a> 。 与更权威的python可视化库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Matplotlib）</a>相比，这是一种不太传统的方法，但是在我看来，Plotly是一个绝佳的选择，因为它允许您通过使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D3.js</a>创建完全交互式的图形<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> 结果，您无需任何设置即可在输出端获得漂亮的可视化图表。 此外，Plotly易于学习，其结果也易于插入网页中。 <br><br>  <i>当然，您应该始终记住需要将生成的可视化结果与公开可用的加密货币价格图表（例如，在Coinbase上）进行比较，以对下载数据的可靠性进行基本验证。</i> <br><br><h4>  2.3向其他BTC交易所索取价格数据 </h4><br> 您可能已经注意到此组中的差异：该图在多个位置下垂到零，尤其是在2014年底和2016年初。这些跌幅在Kraken数据集中可以找到，我们显然不希望它们反映在最终价格分析中。 <br><br> 比特币交易所的性质是，价格由供求关系决定，因此，现有的交易所都不能声称其报价反映了比特币唯一真实的“参考”价格。 为了考虑到此缺点，并消除图表上的价格跌落（很可能是由于技术或数据集错误），我们将另外从其他三个大型比特币交易所收集数据，以计算比特币的总价格指数。 <br><br> 首先，让我们将每个交易所的数据下载到数据帧字典中。 <br><br><pre> <code class="javascript hljs"># Pull pricing data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> more BTC exchanges exchanges = [<span class="hljs-string"><span class="hljs-string">'COINBASE'</span></span>,<span class="hljs-string"><span class="hljs-string">'BITSTAMP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ITBIT'</span></span>] exchange_data = {} exchange_data[<span class="hljs-string"><span class="hljs-string">'KRAKEN'</span></span>] = btc_usd_price_kraken <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> exchange <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> exchanges: exchange_code = <span class="hljs-string"><span class="hljs-string">'BCHARTS/{}USD'</span></span>.format(exchange) btc_exchange_df = get_quandl_data(exchange_code) exchange_data[exchange] = btc_exchange_df</code> </pre> <br><h4>  2.4将所有价格数据合并到一个数据框中 </h4><br> 接下来，我们将定义一个简单的函数，将每个数据帧的相似列合并为一个新的合并帧。 <br><br><pre> <code class="javascript hljs">def merge_dfs_on_column(dataframes, labels, col): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Merge a single column of each dataframe into a new combined dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> series_dict = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(dataframes)): series_dict[labels[index]] = dataframes[index][col] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pd.DataFrame(series_dict)</code> </pre> <br> 现在，让我们根据“加权价格”列组合所有数据框。 <br><br><pre> <code class="javascript hljs"># Merge the BTC price dataseries<span class="hljs-string"><span class="hljs-string">' into a single dataframe btc_usd_datasets = merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()), '</span></span>Weighted Price<span class="hljs-string"><span class="hljs-string">')</span></span></code> </pre> <br> 最后，使用<code>tail()</code>方法查看最后五行，以确保我们的工作结果看起来正常。 <br><br><pre> <code class="javascript hljs">btc_usd_datasets.tail()</code> </pre> <br><img src="https://habrastorage.org/web/dff/f3c/661/dfff3c661b494648bfc0d2675d260f40.png" alt="图片"><br><br> 价格看起来像预期的那样：处于相似的限制范围内，但是根据每个交易所的供求比率存在细微差异。 <br><br><h4>  2.5可视化价格数据集 </h4><br> 下一步的逻辑步骤是可视化结果数据集的比较。 为此，我们定义了一个辅助功能，该功能提供了使用单行命令基于数据框生成图形的功能。 <br><br><pre> <code class="javascript hljs">def df_scatter(df, title, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">''</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'linear'</span></span>, initial_hide=False): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Generate a scatter plot of the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> label_arr = list(df) series_arr = list(map(lambda col: df[col], label_arr)) layout = go.Layout( title=title, legend=dict(orientation=<span class="hljs-string"><span class="hljs-string">"h"</span></span>), xaxis=dict(type=<span class="hljs-string"><span class="hljs-string">'date'</span></span>), yaxis=dict( title=y_axis_label, showticklabels= not seperate_y_axis, type=scale ) ) y_axis_config = dict( overlaying=<span class="hljs-string"><span class="hljs-string">'y'</span></span>, showticklabels=False, type=scale ) visibility = <span class="hljs-string"><span class="hljs-string">'visible'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> initial_hide: visibility = <span class="hljs-string"><span class="hljs-string">'legendonly'</span></span> # Form Trace For Each Series trace_arr = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, series <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(series_arr): trace = go.Scatter( x=series.index, y=series, name=label_arr[index], visible=visibility ) # Add seperate axis <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the series <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seperate_y_axis: trace[<span class="hljs-string"><span class="hljs-string">'yaxis'</span></span>] = <span class="hljs-string"><span class="hljs-string">'y{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>) layout[<span class="hljs-string"><span class="hljs-string">'yaxis{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>)] = y_axis_config trace_arr.append(trace) fig = go.Figure(data=trace_arr, layout=layout) py.iplot(fig)</code> </pre> <br> 为了简洁起见，我将不详细介绍辅助功能的操作。 如果您有兴趣了解更多有关它的信息，请参阅《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">熊猫</a>与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阴谋》文档</a> 。 <br><br> 我们可以轻松地生成比特币价格数据图。 <br><br><pre> <code class="javascript hljs"># Plot all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the BTC exchange prices df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/1b5/f48/c9e/1b5f48c9ec2e4257a281ec2632dbec76.png" alt="图片"><br></a> <br><h4>  2.6整理并合并价格数据 </h4><br> 我们可以看到，尽管所有4个系列的数据的行为都大致相同，但是仍需要消除其中一些与规范的偏差。 <br><br> 让我们从帧中删除所有零值，因为我们知道比特币的价格在我们所考虑的时间段内从未为零。 <br><br><pre> <code class="javascript hljs"># Remove <span class="hljs-string"><span class="hljs-string">"0"</span></span> values btc_usd_datasets.replace(<span class="hljs-number"><span class="hljs-number">0</span></span>, np.nan, inplace=True)</code> </pre> <br> 再次构建图表后，我们得到了更整洁的曲线，没有任何急剧的下降。 <br><br><pre> <code class="javascript hljs"># Plot the revised dataframe df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/d24/960/13e/d2496013e0ca41e1acd421ff44b97cd0.png" alt="图片"></a> <br><br> 现在，我们可以根据所有交易所的数据来计算一个包含平均每日比特币价格的新列。 <br><br><pre> <code class="javascript hljs"># Calculate the average BTC price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>] = btc_usd_datasets.mean(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 此新列是我们的比特币价格指数！ 让我们绘制它以确保它看起来正常。 <br><br><pre> <code class="javascript hljs"># Plot the average BTC price btc_trace = go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/fad/289/9de/fad2899de9c14304a8964df909a9883f.png" alt="图片"></a> <br><br> 是的，看起来不错。 将来，我们将使用合并的价格序列将其他加密货币的汇率转换为美元。 <br><br><h3> 第三阶段。获取山寨币价格数据 </h3><br> 现在我们有了一个可靠的比特币价格时间序列，让我们请求一些非比特币加密货币的数据，这些数据通常被称为山寨币。 <br><br><h4>  3.1定义用于Poloniex API的辅助功能 </h4><br> 要获取山寨币数据，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Poloniex API</a> 。 两个辅助功能可以下载和缓存传递给此API的JSON数据，这将对我们有帮助。 <br><br> 首先，我们定义<code>get_json_data</code> ，它将在提供的URL上下载并缓存JSON数据。 <br><br><pre> <code class="javascript hljs">def get_json_data(json_url, cache_path): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache JSON data, return as a dataframe.'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(json_url)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {}'</span></span>.format(json_url)) df = pd.read_json(json_url) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(json_url, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br> 接下来，我们定义一个函数，该函数生成对Poloniex API的HTTP请求，然后调用<code>get_json_data</code> ，后者依次存储请求的数据。 <br><br><pre> <code class="javascript hljs">base_polo_url = <span class="hljs-string"><span class="hljs-string">'https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}'</span></span> start_date = datetime.strptime(<span class="hljs-string"><span class="hljs-string">'2015-01-01'</span></span>, <span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) # get data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the start <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2015</span></span> end_date = datetime.now() # up until today pediod = <span class="hljs-number"><span class="hljs-number">86400</span></span> # pull daily data (<span class="hljs-number"><span class="hljs-number">86</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span> seconds per day) def get_crypto_data(poloniex_pair): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Retrieve cryptocurrency data from poloniex'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> json_url = base_polo_url.format(poloniex_pair, start_date.timestamp(), end_date.timestamp(), pediod) data_df = get_json_data(json_url, poloniex_pair) data_df = data_df.set_index(<span class="hljs-string"><span class="hljs-string">'date'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_df</code> </pre> <br> 她采用一个指示加密货币对的字符串（例如BTC_ETH），并以其汇率返回包含历史数据的数据帧。 <br><br><h4>  3.2使用Poloniex下载贸易数据 </h4><br> 大多数山寨币不能直接用美元购买。 为了获得它们，人们经常购买比特币，并在交易所中将其交换为山寨币。 因此，我们下载每种硬币的BTC汇率，并使用BTC价格中的数据来计算以美元计算的山寨币的成本。 <br><br> 我们下载9种最受欢迎​​的加密货币的股票数据- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以太坊</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莱特币</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ripple</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以太坊经典</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stellar</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dashcoin</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Siacoin</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Monero</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NEM</a> 。 <br><br><pre> <code class="javascript hljs">altcoins = [<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>,<span class="hljs-string"><span class="hljs-string">'LTC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XRP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ETC'</span></span>,<span class="hljs-string"><span class="hljs-string">'STR'</span></span>,<span class="hljs-string"><span class="hljs-string">'DASH'</span></span>,<span class="hljs-string"><span class="hljs-string">'SC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XMR'</span></span>,<span class="hljs-string"><span class="hljs-string">'XEM'</span></span>] altcoin_data = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoins: coinpair = <span class="hljs-string"><span class="hljs-string">'BTC_{}'</span></span>.format(altcoin) crypto_price_df = get_crypto_data(coinpair) altcoin_data[altcoin] = crypto_price_df</code> </pre> <br> 现在，我们有一个包含9个数据框的字典，每个字典都包含有关山寨币和比特币的平均每日交易价格对的历史数据。 <br> 再次，我们将检查以太坊价格表的最后五行，以确保一切正常。 <br><br><pre> <code class="javascript hljs">altcoin_data[<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>].tail()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/632/68a/4ba/63268a4bae1e449cb5d0a336ae117236.png" alt="图片"></a> <br><br><h4>  3.3价格转换为美元 </h4><br> 现在，我们可以将价格对的数据与我们的比特币价格指数进行比较，以直接获取有关以美元表示的山寨币价值的历史数据。 <br><br><pre> <code class="javascript hljs"># Calculate USD Price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> each altcoin dataframe <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoin_data.keys(): altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>] = altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'weightedAverage'</span></span>] * btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br> 使用此代码，我们在每个山寨币的数据框中使用美元硬币价格创建了一个新列。 <br><br> 此外，我们可以重用先前定义的功能<code>merge_dfs_on_column</code>来创建一个数据框，其中包含每种加密货币的美元价格。 <br><br><pre> <code class="javascript hljs"># Merge USD price <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> each altcoin into single dataframe combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), <span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>)</code> </pre> <br> 就这样 现在，让我们还将比特币价格添加到组合数据框的最后一列。 <br><br><pre> <code class="javascript hljs"># Add BTC price to the dataframe combined_df[<span class="hljs-string"><span class="hljs-string">'BTC'</span></span>] = btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br> 现在我们有了一个框架，其中包含我们正在研究的十种加密货币的每日美元价格。 <br><br> 让我们重用先前设置的<code>df_scatter</code>函数以绘制加密货币价格变化的比较图。 <br><br><pre> <code class="javascript hljs"># Chart all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the altocoin prices df_scatter(combined_df, <span class="hljs-string"><span class="hljs-string">'Cryptocurrency Prices (USD)'</span></span>, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">'Coin Value (USD)'</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'log'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/19d/b4f/4de/19db4f4de0ad482e8c92376c67fb8ebb.png" alt="图片"></a> <br><br> 太好了！ 该图表使您可以非常清楚地评估过去几年中每种加密货币的汇率动态。 <br><br>  <i>请注意，我们使用对数纵坐标刻度，因为它使我们能够在一张图表上拟合所有货币。</i>  <i>但是，如果您愿意，可以尝试使用不同的参数值（例如<code>scale='linear'</code> ）从不同的角度查看数据。</i> <br><br><h4>  3.4相关分析 </h4><br> 您可能已经注意到，尽管加密货币汇率的价值和波动性完全不同，但它们之间似乎存在一定的相关性。 尤其是当您查看八月暴涨之后的时间间隔时，即使不同的代币也会出现微小的波动，就像同步发生一样。 <br><br> 但是，在我们可以使用统计数据进行备份之前，基于外部相似性的预示并不比简单的猜测更好。 <br><br> 我们可以使用Pandas集合中的<code>corr()</code>方法来检验我们的相关假设，并使用它来计算帧中所有列相对于彼此的Pearson相关系数。 <br><br>  <i>更正日期为8/22/2017-这部分工作已被修改。</i>  <i>现在，要计算相关系数，而不是使用绝对价格值，而是使用其每日变化的百分比值。</i> <br><br> 直接在非平稳时间序列（例如原始价格数据）之间进行相关性计算可能会导致结果有偏差。 我们将通过应用<code>pct_change()</code>方法来纠正此缺陷，该方法会将每个帧单元的值从绝对值转换为其每日变化的百分比。 <br><br> 首先，我们计算2016年的相关性。 <br><br><pre> <code class="javascript hljs"># Calculate the pearson correlation coefficients <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cryptocurrencies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">2016</span></span> combined_df_2016 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2016</span></span>] combined_df_2016.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/f11/5bd/753/f115bd7536414f45bbf6f509d5c76b25.png" alt="图片"></a> <br><br> 现在到处都是赔率。 接近1或-1的值表示时间序列之间分别存在很强的正向或反向相关性。 系数接近零意味着值不相关，并且彼此独立变化。 <br><br> 为了使结果可视化，我们需要创建另一个辅助可视化功能。 <br><br><pre> <code class="javascript hljs">def correlation_heatmap(df, title, absolute_bounds=True): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Plot a correlation heatmap for the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> heatmap = go.Heatmap( z=df.corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>).as_matrix(), x=df.columns, y=df.columns, colorbar=dict(title=<span class="hljs-string"><span class="hljs-string">'Pearson Coefficient'</span></span>), ) layout = go.Layout(title=title) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> absolute_bounds: heatmap[<span class="hljs-string"><span class="hljs-string">'zmax'</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> heatmap[<span class="hljs-string"><span class="hljs-string">'zmin'</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> fig = go.Figure(data=[heatmap], layout=layout) py.iplot(fig)</code> </pre> <br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2016.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2016"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4f5/576/1da/4f55761daa17402ea0b059fcca93df45.png" alt="图片"><br></a> <br> 图表上的深红色单元格显示出很强的相关性（每种货币显然会尽可能地与其自身建立相关性），深蓝色表示强烈的反相关性。 它们之间所有的蓝色，橙色，灰色，沙色表示不同程度的弱相关性或不存在相关性。 <br><br> 这张图告诉我们什么？ 实际上，这表明2016年各种加密货币的价格波动之间的统计显着性关系很小。 <br><br> 现在，为了检验我们的假设，即近几个月来加密货币之间的关联度越来越高，让我们使用2017年已经存在的数据重复进行同样的检验。 <br><br><pre> <code class="javascript hljs">combined_df_2017 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2017</span></span>] combined_df_2017.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/740/946/579/7409465791b8437582055aa2ec4297c8.png" alt="图片"></a> <br><br> 获得的系数表明存在更显着的相关性。 她足够强大，可以利用这一事实进行投资吗？ 绝对不是。 <br><br> 但是，我们应该注意这样一个事实，即几乎所有的加密货币作为一个整体都变得越来越相互关联。 <br><br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2017.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2017"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/0a9/fd4/de3/0a9fd4de30f446b3aeed700aaed5e377.png" alt="图片"></a> <br><br> 这是一个相当有趣的观察。 <br><br><h3> 为什么会这样呢？ </h3><br> 好问题。 我不能肯定地说。 <br><br> 首先想到的是：原因是对冲基金最近开始在加密货币市场公开交易。  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a> ] [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2</a> ]这种基金的资金量比普通交易者大得多，并且如果它们通过将其资金分散到各种加密货币中并基于独立变量对它们中的每一种使用类似的交易策略来保护自己免受风险的影响， （例如在股票市场中），那么此方法的逻辑结果可能是相关性增加的趋势的出现。 <br><br><h4> 深入分析：XRP和STR </h4><br> 例如，一种趋势间接证实了上述推理。  XRP（波纹令牌）与其他山寨币的关联最少。 但是有一个值得注意的例外-STR（Stellar代币，正式名称为“ Lumens”），其与XRP的相关系数为0.62。 <br><br> 有趣的是，Stellar和Ripple都是相当相似的金融科技平台，其活动旨在简化国际银行间支付的流程。 <br><br> 我看到一个非常现实的情况，其中一些富裕的参与者和对冲基金使用类似的策略来交易投资于Stellar和Ripple的资金，因为这些代币背后的两种服务本质上非常相似。 这个假设可以解释为什么XRP与STR的关联性比与其他加密货币的关联性大得多。 <br><br><h3> 换你了 </h3><br> 但是，这种解释很大程度上是推测性的结论。 但是也许您可以做得更好？ 我们在这项工作中奠定的基础使我们能够继续在各个方向上研究数据。 <br><br> 这里有一些想法要检查： <br><br><ul><li> 将更多加密货币的数据添加到分析中。 </li><li> 更准确地考虑相关趋势，更正相关分析的时间范围和详细程度，反之亦然（更一般而言）。 </li><li> 搜索交易量和/或用于区块链挖掘的数据集的趋势。 销售/购买比率比原始价格数据更适合预测价格波动。 </li><li> 添加股票，商品和原材料，法定货币的价格数据，以找出其中哪些资产与加密货币相关。  （但请记住一句古老的谚语：“相关还不意味着因果关系。”） </li><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Event Registry</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GDELT</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google Trends</a>量化围绕单个加密货币的炒作量。 </li><li> 使用机器学习，训练程序来分析数据以预测价格趋势。 如果有雄心壮志，您甚至可以尝试使用循环神经网络来实现。 </li><li> 使用您的分析，使用适当的API在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Poloniex</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Coinbase</a>等网站上创建自动机器人交易者。 但请注意：优化不佳的交易机器人会迅速剥夺您所有可用资金。 </li><li>  <b>分享您的发现！</b> 一般来说，比特币和其他加密货币的最大特点是，与几乎任何其他资产相比，它们的去中心化性质使它们更加自由和民主。     ,    ,   ,     -. </li></ul><br> HTML-  python-  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br> ,       ,           -  ,      ,  ,         . <br><br>    , ,  ,     - ,   .     -   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github-</a> . <br><br>     , , ,   .   ,  ,      ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="图片"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN406363/">https://habr.com/ru/post/zh-CN406363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN406345/index.html">NIMS-特定场景软件（用于实况角色扮演游戏）</a></li>
<li><a href="../zh-CN406347/index.html">FDA首次批准用于白血病的基因治疗</a></li>
<li><a href="../zh-CN406353/index.html">科学家说，猴子智力已经被错误判断了数十年</a></li>
<li><a href="../zh-CN406359/index.html">为Dota 2创建机器人的详细信息</a></li>
<li><a href="../zh-CN406361/index.html">M.SMART-9月黑客马拉松“ M. Video”：聊天机器人，人工智能和机器学习</a></li>
<li><a href="../zh-CN406365/index.html">卡巴斯基实验室因避免诉讼而向专利巨roll支付费用</a></li>
<li><a href="../zh-CN406367/index.html">佳能移动打印：可在世界任何地方打印</a></li>
<li><a href="../zh-CN406369/index.html">Aubrey de Gray访谈-人们能否活1000年以上？</a></li>
<li><a href="../zh-CN406373/index.html">特斯拉Model S行驶300,000英里</a></li>
<li><a href="../zh-CN406375/index.html">怪物，奇迹和科学的诞生</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>