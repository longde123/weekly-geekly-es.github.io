<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîù üë®üèª‚Äçüåæ üë©üèª‚Äçüåæ Mutationstests in PHP: eine qualitative Messung der Codeabdeckung üßë‚Äçü§ù‚Äçüßë üëêüèª üõï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie bewertet man die Qualit√§t von Tests? Viele verlassen sich auf die beliebteste Metrik, die allen bekannt ist - die Codeabdeckung. Dies ist jedoch e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mutationstests in PHP: eine qualitative Messung der Codeabdeckung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/462709/">  Wie bewertet man die Qualit√§t von Tests?  Viele verlassen sich auf die beliebteste Metrik, die allen bekannt ist - die Codeabdeckung.  Dies ist jedoch eine quantitative und keine qualitative Metrik.  Es zeigt, wie viel von Ihrem Code von Tests abgedeckt wird, aber nicht, wie gut diese Tests geschrieben sind. <br><br>  Eine M√∂glichkeit, dies herauszufinden, sind Mutationstests.  Mit diesem Tool, das geringf√ºgige √Ñnderungen am Quellcode vornimmt und anschlie√üend die Tests erneut ausf√ºhrt, k√∂nnen Sie nutzlose Tests und eine Abdeckung von geringer Qualit√§t identifizieren. <br><br>  Beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo PHP Meetup im M√§rz</a> sprach ich dar√ºber, wie man Mutationstests f√ºr PHP-Code organisiert und auf welche Probleme Sie sto√üen k√∂nnten.  Das Video ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar und f√ºr die Textversion willkommen bei cat. <br><br><img src="https://habrastorage.org/webt/qc/xz/fi/qcxzfinlil5-p8zjwtafifv2mqu.jpeg"><br><a name="habracut"></a><br><h2>  Was ist Mutationstest? </h2><br>  Um zu erkl√§ren, was ich meine, zeige ich Ihnen einige Beispiele.  Sie sind einfach, stellenweise √ºbertrieben und m√∂gen offensichtlich erscheinen (obwohl reale Beispiele normalerweise recht komplex sind und nicht mit den Augen gesehen werden k√∂nnen). <br><br>  Betrachten Sie die Situation: Wir haben eine elementare Funktion, die behauptet, ein Erwachsener zu sein, und es gibt einen Test, der sie testet.  Der Test hat einen dataProvider, dh er testet zwei F√§lle: Alter 17 Jahre und Alter 19 Jahre.  Ich denke, es ist f√ºr viele von Ihnen offensichtlich, dass isAdult zu 100% abgedeckt ist.  Die einzige Zeile.  Es wird durch einen Test durchgef√ºhrt.  Alles ist ganz toll. <br><br><img src="https://habrastorage.org/webt/w2/qq/ag/w2qqagnuajffn5ubmkgwnbsubpg.png"><br><br>  Bei n√§herer Betrachtung zeigt sich jedoch, dass unser Anbieter schlecht geschrieben ist und keine Randbedingungen testet: Das Alter von 18 Jahren als Randbedingung wird nicht getestet.  Sie k√∂nnen das&gt; -Zeichen durch&gt; = ersetzen, und der Test erkennt eine solche √Ñnderung nicht. <br><br>  Ein weiteres Beispiel, etwas komplizierter.  Es gibt eine Funktion, die ein einfaches Objekt erstellt, das Setter und Getter enth√§lt.  Wir haben drei Felder festgelegt, und es gibt einen Test, der √ºberpr√ºft, ob die Funktion buildPromoBlock das erwartete Objekt wirklich erfasst. <br><br><img src="https://habrastorage.org/webt/a6/mr/eq/a6mreqjphzfwflq35qxf5skwfle.png"><br><br>  Wenn Sie genau hinschauen, haben wir auch setSomething, das eine Eigenschaft auf true setzt.  Aber im Test haben wir keine solche Behauptung.  Das hei√üt, wir k√∂nnen diese Zeile aus buildPromoBlock entfernen - und unser Test wird diese √Ñnderung nicht erfassen.  Gleichzeitig haben wir eine 100% ige Abdeckung in der buildPromoBlock-Funktion, da alle drei Zeilen w√§hrend des Tests ausgef√ºhrt wurden. <br><br>  Diese beiden Beispiele f√ºhren uns zu Mutationstests. <br><br>  Bevor ich den Algorithmus zerlege, werde ich eine kurze Definition geben.  Mutationstests sind ein Mechanismus, der es uns erm√∂glicht, durch geringf√ºgige √Ñnderungen am Code die Handlungen des b√∂sen Pinocchio oder des Junior Vasya nachzuahmen, der gekommen ist und ihn gezielt zu brechen begann, die&gt; Zeichen durch &lt;, = by! = Zu ersetzen und so weiter.  F√ºr jede solche √Ñnderung, die wir f√ºr gute Zwecke vornehmen, f√ºhren wir Tests durch, die die ge√§nderte Zeile abdecken sollen. <br><br>  Wenn die Tests uns nichts gezeigt haben, wenn sie nicht gefallen sind, sind sie wahrscheinlich nicht effektiv genug.  Sie testen keine Grenzf√§lle, enthalten keine Aussagen: Vielleicht m√ºssen sie verbessert werden.  Wenn die Tests fallen, sind sie cool.  Sie sch√ºtzen wirklich vor solchen Ver√§nderungen.  Daher ist unser Code schwerer zu brechen. <br><br>  Lassen Sie uns nun den Algorithmus analysieren.  Es ist ganz einfach.  Das erste, was wir tun, um Mutationstests durchzuf√ºhren, ist, den Quellcode zu nehmen.  Als N√§chstes erhalten wir Codeabdeckung, um zu wissen, welche Tests f√ºr welche Zeichenfolge ausgef√ºhrt werden sollen.  Danach gehen wir den Quellcode durch und generieren die sogenannten Mutanten. <br><br>  Eine Mutante ist eine einzelne Code√§nderung.  Das hei√üt, wir √ºbernehmen eine bestimmte Funktion, bei der es im Vergleich ein&gt; -Zeichen gab. Wenn wir dieses Vorzeichen in&gt; = - √§ndern, erhalten wir eine Mutante.  Danach f√ºhren wir die Tests durch.  Hier ist ein Beispiel f√ºr eine Mutation (wir haben&gt; durch&gt; = ersetzt): <br><br><img src="https://habrastorage.org/webt/tu/fe/rm/tufermumemlipcqjluus2h-bzmm.png"><br><br>  In diesem Fall werden Mutationen nicht zuf√§llig, sondern nach bestimmten Regeln vorgenommen.  Die Mutationstestantwort ist idempotent.  Unabh√§ngig davon, wie oft wir Mutationstests mit demselben Code ausf√ºhren, werden dieselben Ergebnisse erzielt. <br><br>  Als letztes f√ºhren wir die Tests durch, die die mutierte Linie abdecken.  Holen Sie es aus der Abdeckung.  Es gibt nicht optimale Tools, die alle Tests steuern.  Aber ein gutes Werkzeug wird nur diejenigen vertreiben, die ben√∂tigt werden. <br><br>  Danach werten wir das Ergebnis aus.  Tests fielen - dann ist alles in Ordnung.  Wenn sie nicht gefallen sind, sind sie nicht sehr effektiv. <br><br><h2>  Metriken </h2><br>  Welche Metriken geben uns Mutationstests?  Es f√ºgt drei weitere zur Codeabdeckung hinzu, √ºber die wir jetzt sprechen werden. <br><br>  Aber zuerst analysieren wir die Terminologie. <br><br><img width="400" src="https://habrastorage.org/webt/_6/pu/yz/_6puyzoefm_yith6s0ep8yzwqao.png"><br><br>  Es gibt das Konzept der get√∂teten Mutanten: Dies sind die Mutanten, die unsere Tests ‚Äûgenagelt‚Äú haben (dh sie haben sie gefangen). <br><br><img width="400" src="https://habrastorage.org/webt/3b/7o/it/3b7oitf-byu91zv3jbooogylvna.png"><br><br>  Es gibt das Konzept der entkommenen Mutante (√ºberlebende Mutanten).  Dies sind die Mutanten, die es geschafft haben, eine Bestrafung zu vermeiden (das hei√üt, die Tests haben sie nicht gefangen). <br><br><img width="400" src="https://habrastorage.org/webt/dw/8a/ye/dw8ayeaxuwut_6rcbdchfdm0cfg.png"><br><br>  Und es gibt Konzepte, die Mutanten abdecken - eine Mutante, die von Tests abgedeckt wird, und eine nicht abgedeckte Mutante gegen√ºber, die von keinem Test abgedeckt wird (d. H. Wir haben Code, es hat Gesch√§ftslogik, wir k√∂nnen ihn √§ndern, aber keinen einzelnen Test pr√ºft nicht auf √Ñnderungen). <br><br>  Der Hauptindikator, den uns Mutationstests geben, ist der MSI (Mutation Score Indicator), das Verh√§ltnis der Anzahl der get√∂teten Mutanten zu ihrer Gesamtzahl. <br><br>  Der zweite Indikator ist die Abdeckung des Mutationscodes.  Es ist nur qualitativ, nicht quantitativ, denn es zeigt, wie viel Gesch√§ftslogik Sie brechen und regelm√§√üig tun k√∂nnen. Unsere Tests werden abgefangen. <br><br>  Und die letzte Metrik ist MSI, d. H. Ein weicherer MSI.  In diesem Fall berechnen wir den MSI nur f√ºr diejenigen Mutanten, die durch Tests abgedeckt wurden. <br><br><h2>  Probleme mit Mutationstests </h2><br>  Warum hat weniger als die H√§lfte der Programmierer von diesem Tool geh√∂rt?  Warum wird es nicht √ºberall verwendet? <br><br><h3>  Niedrige Geschwindigkeit </h3><br>  Das erste Problem (eines der Hauptprobleme) ist die Geschwindigkeit der Mutationstests.  Wenn wir im Code Dutzende von Mutationsoperatoren haben, selbst f√ºr die einfachste Klasse, k√∂nnen wir Hunderte von Mutationen generieren.  F√ºr jede Mutation m√ºssen Sie Tests durchf√ºhren.  Wenn wir beispielsweise 5.000 Unit-Tests haben, die zehn Minuten lang laufen, k√∂nnen Mutationstests Stunden dauern. <br><br>  Was kann getan werden, um dies auszugleichen?  F√ºhren Sie Tests parallel in mehreren Threads aus.  Wirf Str√∂me in mehrere Autos.  Es funktioniert. <br><br>  Der zweite Weg sind inkrementelle L√§ufe.  Es ist nicht erforderlich, jedes Mal Mutationsindikatoren f√ºr den gesamten Zweig zu z√§hlen - Sie k√∂nnen Zweigdifferenzen verwenden.  Wenn Sie Feature-Brunchs verwenden, k√∂nnen Sie dies ganz einfach tun: F√ºhren Sie Tests nur f√ºr die Dateien durch, die sich ge√§ndert haben, und sehen Sie, was im Assistenten vor sich geht, vergleichen Sie, analysieren Sie. <br><br>  Das n√§chste, was Sie tun k√∂nnen, ist das Tuning von Mutationen.  Da Mutationsoperatoren ge√§ndert werden k√∂nnen, k√∂nnen Sie bestimmte Regeln festlegen, nach denen sie funktionieren. Anschlie√üend k√∂nnen Sie einige Mutationen stoppen, wenn sie wissentlich zu Problemen f√ºhren. <br><br>  Ein wichtiger Punkt: Mutationstests sind nur f√ºr Unit-Tests geeignet.  Trotz der Tatsache, dass es f√ºr Integrationstests ausgef√ºhrt werden kann, ist dies offensichtlich eine fehlgeschlagene Idee, da Integrationstests (wie End-to-End-Tests) viel langsamer ausgef√ºhrt werden und viel mehr Code betreffen.  Sie werden einfach nie auf die Ergebnisse warten.  Grunds√§tzlich wurde dieser Mechanismus ausschlie√ülich f√ºr Unit-Tests erfunden und entwickelt. <br><br><h3>  Endlose Mutanten </h3><br>  Das zweite Problem, das bei Mutationstests auftreten kann, sind die sogenannten Endlosmutanten.  Zum Beispiel gibt es einfachen Code, eine einfache for-Schleife: <br><br><img src="https://habrastorage.org/webt/no/tr/az/notrazetuv221u41t1g8rfbkmlc.png"><br><br>  Wenn Sie i ++ durch i-- ersetzen, wird der Zyklus unendlich.  Ihr Code bleibt lange erhalten.  Und Mutationstests erzeugen ziemlich oft solche Mutationen. <br><br>  Das erste, was Sie tun k√∂nnen, ist die Mutation zu optimieren.  Offensichtlich ist es eine sehr schlechte Idee, i ++ in einer for-Schleife in i-- zu √§ndern: In 99% der F√§lle erhalten wir eine Endlosschleife.  Daher haben wir dies in unserem Tool verboten. <br><br>  Das zweite und wichtigste, was Sie vor solchen Problemen sch√ºtzt, ist das Timeout f√ºr den Lauf.  Zum Beispiel kann dieselbe PHPUnit einen Timeout-Test durchf√ºhren, unabh√§ngig davon, wo sie steckt.  PHPUnit √ºber PCNTL legt R√ºckrufe auf und berechnet die Zeit selbst.  Wenn der Test f√ºr einen bestimmten Zeitraum fehlschl√§gt, wird er einfach festgenagelt und ein solcher Fall wird als get√∂tete Mutante betrachtet, da der Code, der die Mutationen generiert hat, vom Test wirklich √ºberpr√ºft wird, wodurch das Problem wirklich erkannt wird und angezeigt wird, dass der Code nicht mehr funktionsf√§hig ist. <br><br><h3>  Identische Mutanten </h3><br>  Dieses Problem besteht in der Theorie der Mutationstests.  In der Praxis begegnen sie dem nicht sehr oft, aber Sie m√ºssen es wissen. <br><br>  Betrachten Sie ein klassisches Beispiel, das dies veranschaulicht.  Wir haben eine Multiplikation der Variablen A mit -1 und eine Division von A mit -1.  Im allgemeinen Fall f√ºhren diese Operationen zum gleichen Ergebnis.  Wir √§ndern das Vorzeichen von A. Dementsprechend haben wir eine Mutation, die es zwei Zeichen erm√∂glicht, sich untereinander zu √§ndern.  Die Logik des Programms durch eine solche Mutation wird nicht verletzt.  Tests und sollte es nicht fangen, sollte nicht fallen.  Aufgrund solcher identischen Mutanten treten einige Schwierigkeiten auf. <br><br>  Es gibt keine universelle L√∂sung - jeder l√∂st dieses Problem auf seine Weise.  Vielleicht hilft eine Art mutiertes Registrierungssystem.  Wir bei Badoo denken jetzt √ºber etwas √Ñhnliches nach, wir werden sie nachahmen. <br><br><h2>  Dies ist eine Theorie.  Was ist mit PHP? </h2><br>  Es gibt zwei bekannte Werkzeuge f√ºr Mutationstests: Humbug und Infektion.  Als ich den Artikel vorbereitete, wollte ich dar√ºber sprechen, welches besser ist, und zu dem Schluss kommen, dass dies eine Infektion ist. <br>  Aber als ich zur Humbug-Seite ging, sah ich dort Folgendes: Humbug erkl√§rte sich zugunsten der Infektion f√ºr veraltet.  Daher erwies sich ein Teil meines Artikels als bedeutungslos.  Infektion ist also ein wirklich gutes Werkzeug.  Ich muss mich bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">borNfree</a> aus Minsk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">bedanken</a> , der es geschaffen hat.  Er arbeitet wirklich cool.  Sie k√∂nnen es direkt aus der Box nehmen, durch den Komponisten legen und starten. <br><br>  Infektion hat uns sehr gut gefallen.  Wir wollten es benutzen.  Aber sie konnten aus zwei Gr√ºnden nicht.  Eine Infektion erfordert eine Codeabdeckung, um Tests f√ºr Mutanten korrekt und pr√§zise durchzuf√ºhren.  Hier haben wir zwei M√∂glichkeiten.  Wir k√∂nnen es direkt zur Laufzeit berechnen (aber wir haben 100.000 Unit-Tests).  Oder wir k√∂nnen es f√ºr den aktuellen Master berechnen (aber es dauert anderthalb Stunden, auf unserer Wolke von zehn sehr leistungsstarken Maschinen in mehreren Threads aufzubauen).  Wenn wir dies bei jedem Mutationslauf tun, wird das Tool wahrscheinlich nicht funktionieren. <br><br>  Es gibt eine Option, um das fertige zu f√ºttern, aber im PHPUnit-Format handelt es sich um eine Reihe von XML-Dateien.  Neben der Tatsache, dass sie wertvolle Informationen enthalten, ziehen sie eine Reihe von Strukturen, einige Klammern und andere Dinge.  Ich stellte mir vor, dass unsere Codeabdeckung im Allgemeinen etwa 30 GB wiegt und wir sie √ºber alle Cloud-Computer ziehen m√ºssen, die st√§ndig von der Festplatte gelesen werden.  Im Allgemeinen ist die Idee so lala. <br>  Das zweite Problem war noch bedeutender.  Wir haben eine wunderbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoftMocks-</a> Bibliothek.  Es erm√∂glicht uns, mit schwer zu testendem Legacy-Code umzugehen und erfolgreich Tests daf√ºr zu schreiben.  Wir nutzen es aktiv und werden es in naher Zukunft nicht ablehnen, obwohl wir neuen Code schreiben, damit wir keine SoftMocks ben√∂tigen.  Daher ist diese Bibliothek nicht mit Infection kompatibel, da sie fast denselben Ansatz zum Mutieren von √Ñnderungen verwendet. <br><br>  Wie funktionieren SoftMocks?  Sie fangen Dateieinschl√ºsse ab und ersetzen sie durch modifizierte, dh anstatt Klasse A auszuf√ºhren, erstellen SoftMocks Klasse A an einer anderen Stelle und verbinden eine andere anstelle der urspr√ºnglichen.  Die Infektion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verh√§lt sich</a> genauso, nur funktioniert sie √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stream_wrapper_register ()</a> , das das Gleiche tut, jedoch auf Systemebene.  Infolgedessen k√∂nnen entweder SoftMocks oder Infection f√ºr uns funktionieren.  Da SoftMocks f√ºr unsere Tests erforderlich sind, ist es sehr schwierig, diese beiden Tools zu Freunden zu machen.  Dies ist wahrscheinlich m√∂glich, aber in diesem Fall geraten wir so sehr in die Infektion, dass die Bedeutung solcher √Ñnderungen einfach verloren geht. <br><br>  Um Schwierigkeiten zu √ºberwinden, haben wir unser kleines Instrument geschrieben.  Wir haben Mutationsoperatoren von Infection ausgeliehen (sie sind cool geschrieben und sehr einfach zu bedienen).  Anstatt Mutationen √ºber stream_wrapper_register () zu starten, f√ºhren wir sie √ºber SoftMocks aus, dh wir verwenden unser Tool aus der Box.  Unser Toolza ist mit unserem internen Code-Coverage-Service befreundet.  Das hei√üt, bei Bedarf kann eine Datei oder eine Zeile abgedeckt werden, ohne dass alle Tests ausgef√ºhrt werden m√ºssen, was sehr schnell geschieht.  Es ist jedoch einfach.  Wenn Infection √ºber eine Reihe von Tools und Funktionen verf√ºgt (z. B. Start in mehreren Threads), ist dies bei uns nicht der Fall.  Wir nutzen jedoch unsere interne Infrastruktur, um diesen Mangel auszugleichen.  Zum Beispiel f√ºhren wir denselben Testlauf in mehreren Threads durch unsere Cloud aus. <br><br>  Wie nutzen wir das? <br><br>  Der erste ist ein manueller Lauf.  Dies ist das erste, was zu tun ist.  Alle Tests, die Sie schreiben, werden manuell durch Mutationstests √ºberpr√ºft.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/-5/xc/t1/-5xct1pygkkjfkxsvr8rhcf-rpc.png"><br><br>  Ich habe einen Mutationstest f√ºr eine Datei durchgef√ºhrt.  Erhielt das Ergebnis: 16 Mutanten.  Von diesen wurden 15 durch Tests get√∂tet und einer fiel mit einem Fehler.  Ich habe nicht gesagt, dass Mutationen Todesf√§lle verursachen k√∂nnen.  Wir k√∂nnen leicht etwas √§ndern: den R√ºckgabetyp ung√ºltig machen oder etwas anderes.  Dies ist m√∂glich, es wird als get√∂tete Mutante angesehen, da unser Test zu fallen beginnt. <br><br>  Trotzdem unterscheidet Infection solche Mutanten in einer separaten Kategorie, da es sich manchmal lohnt, Fehlern besondere Aufmerksamkeit zu widmen.  Es kommt vor, dass etwas Seltsames passiert - und der Mutant wird nicht ganz richtig als get√∂tet angesehen. <br><br>  Das zweite, was wir verwenden, ist der Bericht √ºber den Master.  Einmal am Tag, nachts, wenn unsere Entwicklungsinfrastruktur inaktiv ist, erstellen wir einen Bericht zur Codeabdeckung.  Danach machen wir den gleichen Mutationstestbericht.  Es sieht so aus: <br><br><img src="https://habrastorage.org/webt/gf/br/oc/gfbroc92o5cn5xe7a1q3fmwcofm.png"><br><br>  Wenn Sie sich jemals den Bericht √ºber die Codeabdeckung von PHPUnit angesehen haben, haben Sie wahrscheinlich bemerkt, dass die Benutzeroberfl√§che √§hnlich ist, da wir unser Tool analog erstellt haben.  Er berechnete einfach alle Schl√ºsselindikatoren f√ºr eine bestimmte Datei in einem Verzeichnis.  Wir haben auch bestimmte Ziele festgelegt (tats√§chlich haben wir sie von der Obergrenze genommen und noch nicht eingehalten, da wir noch nicht entschieden haben, welche Ziele von jeder Metrik geleitet werden sollen, aber sie existieren, damit es in Zukunft einfach ist, Berichte zu erstellen). <br><br>  Und das Letzte, das Wichtigste, was eine Folge der beiden anderen ist.  Programmierer sind faule Leute.  Ich bin faul: Ich mag es, wenn alles funktioniert und ich muss keine zus√§tzlichen Gesten machen.  Wir haben es so gemacht, dass, wenn ein Entwickler seine eigene Filiale pusht, die Indikatoren seiner Filiale und seines Brunch-Masters automatisch inkrementell gez√§hlt werden. <br><br><img src="https://habrastorage.org/webt/k2/i6/mu/k2i6murvfrlvwfjx-fklewrj2so.png"><br><br>  Zum Beispiel habe ich zwei Dateien ausgef√ºhrt und dieses Ergebnis erhalten.  Im Master hatte ich 548 Mutanten, 400 wurden get√∂tet. Laut einer anderen Akte - 147 gegen 63. In meinem Zweig nahm die Anzahl der Mutanten in beiden F√§llen zu.  Aber in der ersten Akte wurde der Mutant festgenagelt, und in der zweiten entkam er.  Nat√ºrlich ist der MSI-Indikator gefallen.  So etwas erm√∂glicht es sogar Menschen, die keine Zeit verschwenden m√∂chten, Mutationstests mit ihren H√§nden durchzuf√ºhren, zu sehen, was sie schlechter gemacht haben, und darauf zu achten (genau so, wie es Pr√ºfer bei der Code√ºberpr√ºfung tun). <br><br><h2>  Ergebnisse </h2><br>  Es ist immer noch schwierig, Zahlen anzugeben: Wir hatten keinen Indikator, jetzt ist er erschienen, aber es gibt nichts zu vergleichen. <br><br>  Ich kann sagen, dass Mutationstests psychologische Auswirkungen haben.  Wenn Sie anfangen, Ihre Tests durch Mutationstests durchzuf√ºhren, beginnen Sie unwillk√ºrlich, bessere Tests zu schreiben, und das Schreiben von Qualit√§tstests f√ºhrt unweigerlich zu einer √Ñnderung der Art und Weise, wie Sie Code schreiben. Sie denken, dass Sie alle F√§lle abdecken m√ºssen, die Sie brechen k√∂nnen, und beginnen damit bessere Struktur, machen es testbarer. <br><br>  Dies ist eine ausschlie√ülich subjektive Meinung.  Einige meiner Kollegen gaben jedoch ungef√§hr das gleiche Feedback: Als sie anfingen, st√§ndig Mutationstests in ihrer Arbeit zu verwenden, begannen sie, Tests besser zu schreiben, und viele sagten, dass sie anfingen, Code besser zu schreiben. <br><br><h2>  Schlussfolgerungen </h2><br>  Die Codeabdeckung ist eine wichtige Metrik, die √ºberwacht werden muss.  Dieser Indikator garantiert jedoch nichts: Er bedeutet nicht, dass Sie in Sicherheit sind. <br><br>  Mutationstests k√∂nnen dazu beitragen, Ihre Komponententests zu verbessern, und die Verfolgung der Codeabdeckung ist sinnvoll.  Es gibt bereits ein Tool f√ºr PHP. Wenn Sie also ein kleines Projekt ohne Probleme haben, versuchen Sie es noch heute. <br><br>  Beginnen Sie mindestens, indem Sie einen Mutationstest manuell ausf√ºhren.  Machen Sie diesen einfachen Schritt und sehen Sie, was es Ihnen gibt.  Ich bin sicher, es wird dir gefallen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462709/">https://habr.com/ru/post/de462709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462699/index.html">Servicegitter, "Datenebene" und "Steuerebene" (Service-Mesh-Datenebene vs. Steuerebene)</a></li>
<li><a href="../de462701/index.html">Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 2</a></li>
<li><a href="../de462703/index.html">Das ‚Äûbilligste‚Äú Drehkreuz in Russland, das √ºber ein Smartphone gesteuert wird</a></li>
<li><a href="../de462705/index.html">Top 5 Fehler in meinen ReactJS-Anwendungen</a></li>
<li><a href="../de462707/index.html">Kubernetes Starten Sie Application Developer Tools</a></li>
<li><a href="../de462717/index.html">Das Durcheinander von zwei Yokozun</a></li>
<li><a href="../de462723/index.html">Fange eine Katze mit TLA +</a></li>
<li><a href="../de462725/index.html">Trigonometrie-Trick</a></li>
<li><a href="../de462727/index.html">Joomla Digest f√ºr Juni-Juli 2019</a></li>
<li><a href="../de462729/index.html">Offener Vortragsabend √ºber narratives Design am VSBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>