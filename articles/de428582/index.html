<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìé üë©üèª‚Äçüîß üßú Vergessene Geschichte von OOP ‚úçüèæ üî¢ ü§µüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten der heute verwendeten Programmierparadigmen wurden erstmals in den 1930er Jahren mathematisch untersucht, wobei die Ideen der Lambda-Rechn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vergessene Geschichte von OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> Die meisten der heute verwendeten Programmierparadigmen wurden erstmals in den 1930er Jahren mathematisch untersucht, wobei die Ideen der Lambda-Rechnung und der Turing-Maschine verwendet wurden, die Varianten des universellen Rechenmodells sind (dies sind formalisierte Systeme, die Allzweckberechnungen durchf√ºhren k√∂nnen).  Die Church-Turing-These zeigte, dass Lambda-Kalk√ºl und Turing-Maschinen funktional gleichwertig sind.  Wir sprechen n√§mlich von der Tatsache, dass alles, was mit einer Turing-Maschine berechnet werden kann, auch mit Lambda-Kalk√ºl berechnet werden kann und umgekehrt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Es gibt ein weit verbreitetes Missverst√§ndnis, dass Turing-Maschinen alles berechnen k√∂nnen, was berechnet werden kann.  Es gibt Problemklassen (z. B. das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem des Stoppens</a> ), die nur in einigen F√§llen mit Turing-Maschinen berechnet werden k√∂nnen.  Wenn das Wort "rechnerisch" in diesem Text verwendet wird, bedeutet es "rechnerisch durch eine Turingmaschine". <br><br>  Die Lambda-Rechnung demonstriert den Ansatz, Funktionen von oben nach unten auf Berechnungen anzuwenden.  Eine Turing-Bandmaschine ist ein zwingender (schrittweiser) Ansatz f√ºr die Datenverarbeitung, der von unten nach oben implementiert wird. <br><br>  Low-Level-Programmiersprachen wie Maschinencode oder Assembler erschienen in den 1940er Jahren, und Ende der 1950er Jahre entstanden die ersten popul√§ren Hochsprachen, die sowohl funktionale als auch zwingende Ans√§tze implementierten.  Daher sind Dialekte der Lisp-Sprache immer noch weit verbreitet, darunter Clojure, Scheme, AutoLisp und so weiter.  In den f√ºnfziger Jahren erschienen Sprachen wie FORTRAN und COBOL.  Sie sind Beispiele f√ºr zwingende Hochsprachen, die noch leben.  Obwohl anzumerken ist, dass die Sprachen der C-Familie in den meisten Bereichen sowohl COBOL als auch FORTRAN ersetzten. <br><br>  Die Wurzeln der imperativen und funktionalen Programmierung liegen in der formalen Mathematik des Rechnens, sie erschienen vor digitalen Computern.  Die objektorientierte Programmierung (Object Oriented Programming, OOP) entstand sp√§ter in der Revolution der strukturellen Programmierung, die in den sechziger und siebziger Jahren des letzten Jahrhunderts stattfand. <br><br>  Das erste Objekt, das ich kannte, wurde von Ivan Sutherland in seiner schicksalhaften Anwendung Sketchpad verwendet, die zwischen 1961 und 1962 erstellt wurde und die er 1963 in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Arbeit beschrieb.  Objekte waren grafische Zeichen, die auf dem Oszilloskopbildschirm angezeigt wurden (m√∂glicherweise ist dies das erste Mal in der Geschichte der Verwendung eines grafischen Computermonitors), die die Vererbung durch dynamische Delegierte unterst√ºtzen, die Ivan Sutherland in seiner Arbeit als ‚ÄûMeister‚Äú bezeichnete.  Jedes Objekt k√∂nnte ein Master-Objekt werden, zus√§tzliche Instanzen des Objekts wurden als "Vorkommen" bezeichnet.  Dies machte das Sketchpad-System zum Besitzer der ersten der ber√ºhmten Programmiersprachen, die die Vererbung von Prototypen implementierten. <br><br>  Die erste Programmiersprache, allgemein als "objektorientiert" bekannt, war die Simula-Sprache, deren Spezifikationen 1965 entwickelt wurden.  Wie Sketchpad erm√∂glichte Silmula die Arbeit mit Objekten, umfasste jedoch auch Klassen, klassenbasierte Vererbung, Unterklassen und virtuelle Methoden. <br><br>  <i><font color="#999999">Eine virtuelle Methode ist eine Methode, die in einer Klasse definiert ist und von Unterklassen neu definiert werden soll.</font></i>  <i><font color="#999999">Mit virtuellen Methoden k√∂nnen Programme Methoden aufrufen, die zum Zeitpunkt der Kompilierung des Codes m√∂glicherweise nicht vorhanden sind, indem mithilfe des dynamischen Versands festgelegt wird, welche bestimmte Methode w√§hrend der Programmausf√ºhrung aufgerufen werden soll.</font></i>  <i><font color="#999999">JavaScript hat dynamische Typen und verwendet eine Delegierungskette, um zu bestimmen, welche Methode aufgerufen werden soll. Daher muss diese Sprache Programmierern das Konzept virtueller Methoden nicht vorstellen.</font></i>  <i><font color="#999999">Mit anderen Worten, alle Methoden in JavaScript verwenden den Versand zur Laufzeit. Daher m√ºssen Methoden in JavaScript nicht als "virtuell" deklariert werden, um diese Funktion zu unterst√ºtzen.</font></i> <br><br><h2>  <font color="#3AC1EF">Meinung des OOP-Vaters zu OOP</font> </h2><br>  <i><font color="#999999">"Ich habe den Begriff" objektorientiert "gepr√§gt und kann sagen, dass ich nicht C ++ gemeint habe."</font></i>  <i><font color="#999999">Alan Kay, OOPSLA-Konferenz, 1997.</font></i> <br><br>  Alan Kay pr√§gte den Begriff "objektorientierte Programmierung" und bezog sich dabei auf die Programmiersprache Smalltalk (1972).  Diese Sprache wurde von Alan Kay, Dan Ingles und anderen Mitarbeitern des Xerox PARC Research Center im Rahmen des Dynabook-Ger√§teprojekts entwickelt.  Smalltalk war objektorientierter als Simula.  In Smalltalk ist alles ein Objekt, einschlie√ülich Klassen, Ganzzahlen und Bl√∂cke (Abschl√ºsse).  Die anf√§ngliche Implementierung der Sprache, Smalltalk-72, war nicht in der Lage, Unterklassen zu erstellen.  Diese Funktion wurde in Smalltalk-76 angezeigt. <br><br>  W√§hrend Smalltalk Klassen und damit Unterklassen unterst√ºtzte, stellte Smalltalk diese Ideen nicht in den Vordergrund.  Es war eine funktionale Sprache, die Lisp genauso beeinflusste wie Simula.  Laut Alan Kay ist es ein Fehler, Klassen als Mechanismus zur Wiederverwendung von Code zu behandeln.  Die Programmierbranche legt gro√üen Wert auf die Erstellung von Unterklassen, die von den tats√§chlichen Vorteilen der objektorientierten Programmierung ablenken. <br><br>  JavaScript und Smalltalk haben viel gemeinsam.  Ich w√ºrde sagen, dass JavaScript Smalltalks Rache an der Welt ist, weil er die Konzepte von OOP missverstanden hat.  Beide Sprachen unterst√ºtzen die folgenden Funktionen: <br><br><ul><li>  Objekte </li><li>  Erstklassige Funktionen und Verschl√ºsse. </li><li>  Dynamische Typen. </li><li>  Sp√§te Bindung (Funktionen und Methoden k√∂nnen w√§hrend der Programmausf√ºhrung ersetzt werden). </li><li>  OOP ohne klassenbasiertes Vererbungssystem. </li></ul><br>  <i><font color="#999999">‚ÄûIch bedauere, dass ich vor langer Zeit den Begriff‚Äû Objekte ‚Äúf√ºr dieses Ph√§nomen erfunden habe, da seine Verwendung dazu f√ºhrt, dass viele Menschen einer Idee, die nicht so wichtig ist wie die Hauptidee, h√∂chste Bedeutung beimessen.</font></i>  <i><font color="#999999">Die Hauptidee ist Messaging. ‚Äú</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  In einer E-Mail- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korrespondenz von</a> 2003 stellte Alan Kay klar, was er vorhatte, als er Smalltalk "eine objektorientierte Sprache" nannte. <br><br>  <i><font color="#999999">"F√ºr mich bedeutet OOP nur Messaging, lokale Speicherung und Schutz sowie das Ausblenden des Status und das sehr sp√§te Binden."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Mit anderen Worten, gem√§√ü Alan Kays Ideen sind die wichtigsten OOP-Zutaten die folgenden: <br><br><ul><li>  Messaging </li><li>  Kapselung. </li><li>  Dynamische Verkn√ºpfung. </li></ul><br>  Es ist wichtig anzumerken, dass Alan Kay, der Mann, der den Begriff ‚ÄûOOP‚Äú erfand und in die Massen brachte, Vererbung und Polymorphismus nicht als die wichtigsten Bestandteile von OOP ansah. <br><br><h2>  <font color="#3AC1EF">Die Essenz von OOP</font> </h2><br>  Die Kombination von Messaging und Kapselung dient mehreren wichtigen Zwecken: <br><br><ul><li>  Vermeiden des gemeinsam ver√§nderlichen Status eines Objekts durch Einkapseln des Status und Isolieren anderer Objekte von lokalen √Ñnderungen seines Status.  Die einzige M√∂glichkeit, den Zustand eines anderen Objekts zu beeinflussen, besteht darin, ihn zu bitten (anstatt ihm einen Befehl zu geben), sich zu √§ndern, indem er ihm eine Nachricht sendet.  Status√§nderungen werden auf lokaler, zellularer Ebene √ºberwacht, der Status wird anderen Objekten nicht zur Verf√ºgung gestellt. </li><li>  Trennung von Objekten voneinander.  Der Absender der Nachricht ist √ºber die Messaging-API lose mit dem Empf√§nger verbunden. </li><li>  Anpassungsf√§higkeit und Widerstandsf√§higkeit gegen √Ñnderungen w√§hrend der Programmausf√ºhrung durch sp√§te Bindung.  Die Anpassung an √Ñnderungen w√§hrend der Programmausf√ºhrung bietet viele bedeutende Vorteile, die Alan Kay f√ºr OOP als sehr wichtig erachtete. </li></ul><br>  Alan Kay, der diese Ideen zum Ausdruck brachte, lie√ü sich von seinen Kenntnissen der Biologie und seinem Wissen √ºber ARPANET (dies ist eine fr√ºhe Version des Internets) inspirieren.  Wir sprechen n√§mlich von biologischen Zellen und von einzelnen Computern, die mit dem Netzwerk verbunden sind.  Schon damals stellte sich Alan Kay vor, wie Programme auf riesigen, verteilten Computern (dem Internet) ausgef√ºhrt werden, w√§hrend einzelne Computer als biologische Zellen fungieren, unabh√§ngig voneinander mit ihrem eigenen isolierten Zustand arbeiten und Daten durch Senden von Nachrichten mit anderen Computern austauschen. <br><br>  <i><font color="#999999">"Ich erkannte, dass eine Metapher f√ºr eine Zelle oder einen Computer dabei hilft, die Daten [...] loszuwerden."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Alan Kay sagte: ‚ÄûHilfe beim Entfernen der Daten‚Äú und war sich nat√ºrlich der Probleme bewusst, die durch den gemeinsam genutzten ver√§nderlichen Zustand und die starke Konnektivit√§t durch den Datenaustausch verursacht wurden.  Heute sind diese Themen weit verbreitet.  In den sp√§ten 1960er Jahren waren ARPANET-Programmierer jedoch unzufrieden mit der Notwendigkeit, vor der Entwicklung von Programmen eine Datenmodelldarstellung f√ºr ihre Programme auszuw√§hlen.  Die Entwickler wollten sich von dieser Praxis l√∂sen, da es schwieriger ist, in Zukunft etwas zu √§ndern, wenn sie sich im Voraus in das durch die Pr√§sentation der Daten festgelegte Framework hineinbewegen. <br><br>  Das Problem war, dass verschiedene Arten der Darstellung der Daten f√ºr den Zugriff auf sie unterschiedlichen Code und unterschiedliche Syntax in den zu einem bestimmten Zeitpunkt verwendeten Programmiersprachen erforderten.  Der Heilige Gral w√§re hier eine universelle M√∂glichkeit, auf Daten zuzugreifen und diese zu verwalten.  Wenn alle Daten f√ºr das Programm gleich aussehen w√ºrden, w√ºrde dies viele Probleme der Entwickler hinsichtlich der Entwicklung und Wartung von Programmen l√∂sen. <br>  Alan Kay versuchte, die Idee "loszuwerden", wonach Daten und Programme in gewissem Sinne unabh√§ngige Einheiten waren.  Sie werden in List oder Smalltalk nicht als solche betrachtet.  Es gibt keine Trennung zwischen dem, was mit Daten (mit Werten, Variablen, Datenstrukturen usw.) und Software-Konstrukten wie Funktionen gemacht werden kann.  Funktionen sind ‚Äûerstklassige B√ºrger‚Äú, und Programme d√ºrfen sich w√§hrend ihrer Ausf√ºhrung √§ndern.  Mit anderen Worten, Smalltalk hat keine besondere, privilegierte Beziehung zu Daten. <br><br>  Alan Kay betrachtete Objekte au√üerdem als algebraische Strukturen, die eindeutige, mathematisch nachweisbare Garantien f√ºr ihr Verhalten gaben. <br><br>  <i><font color="#999999">"Durch meinen mathematischen Hintergrund konnte ich verstehen, dass jedem Objekt mehrere algebraische Modelle zugeordnet sein k√∂nnen, dass es ganze Gruppen √§hnlicher Modelle geben kann und dass sie sehr, sehr n√ºtzlich sein k√∂nnen."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Es wurde bewiesen, dass dies der Fall ist, und dies bildete die Grundlage f√ºr Objekte wie Versprechen und Linsen. Dar√ºber hinaus wurde die Kategorietheorie von beiden beeinflusst. <br>  Die algebraische Natur, wie Alan Kay Objekte sah, w√ºrde es Objekten erm√∂glichen, eine formale Verifikation, ein deterministisches Verhalten und eine Verbesserung der Testbarkeit bereitzustellen, da algebraische Modelle im Wesentlichen Operationen sind, die mehreren Regeln in Form von Gleichungen folgen. <br><br>  Im Fachjargon der Programmierer sind ‚Äûalgebraische Modelle‚Äú Abstraktionen, die aus Funktionen (Operationen) erstellt wurden, die von bestimmten Regeln begleitet werden, die durch Komponententests erzwungen werden, die diese Funktionen bestehen m√ºssen (Axiome, Gleichungen). <br><br>  Diese Ideen wurden in den meisten objektorientierten Sprachen der C-Familie, einschlie√ülich C ++, Java, C # usw., seit Jahrzehnten vergessen.  Diese Ideen beginnen jedoch mit der Suche nach der R√ºckreise in neueren Versionen der am h√§ufigsten verwendeten objektorientierten Sprachen. <br><br>  Bei dieser Gelegenheit kann jemand sagen, dass die Welt der Programmierung die Vorteile der funktionalen Programmierung wieder entdeckt und rationale Argumente im Kontext objektorientierter Sprachen liefert. <br><br>  Wie fr√ºher JavaScript und Smalltalk werden die meisten modernen objektorientierten Sprachen immer mehr zum "Multi-Paradigma".  Es gibt keinen Grund, zwischen funktionaler Programmierung und OOP zu w√§hlen.  Wenn wir das historische Wesen jedes dieser Ans√§tze betrachten, sehen sie nicht nur als kompatibel, sondern auch als komplement√§re Ideen aus. <br><br>  Was ist nach den Gedanken von Alan Kay das Wichtigste in der PLO? <br><br><ul><li>  Kapselung. </li><li>  Messaging </li><li>  Dynamische Bindung (die F√§higkeit von Programmen, sich w√§hrend ihrer Ausf√ºhrung zu entwickeln und an √Ñnderungen anzupassen). </li></ul><br>  Was ist in OOP vernachl√§ssigbar? <br><br><ul><li>  Klassen. </li><li>  Klassenbasierte Vererbung. </li><li>  Besondere Beziehung zu Objekten, Funktionen oder Daten. </li><li> Schl√ºsselwort <code>new</code> . </li><li>  Polymorphismus. </li><li>  Statische Eingabe. </li><li>  Einstellung zu Klassen als ‚ÄûTypen‚Äú. </li></ul><br>  Wenn Sie Java oder C # kennen, denken Sie vielleicht, dass statische Typisierung oder Polymorphismus die wichtigsten Bestandteile von OOP sind, aber Alan Kay zieht es vor, sich mit universellen Verhaltensmustern in algebraischer Form zu befassen.  Hier ist ein Beispiel in Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Dies ist die Signatur des universellen <code>map</code> , der mit den undefinierten Typen <code>a</code> und <code>b</code> arbeitet und die Funktion von <code>a</code> nach <code>b</code> im Kontext des Funktors <code>a</code> anwendet, um den Funktor <code>b</code> zu erstellen.  "Functor" ist ein Wort aus dem mathematischen Jargon, dessen Bedeutung auf "Unterst√ºtzung der Anzeigeoperation" reduziert wird.  Wenn Sie mit der Methode <code>[].map()</code> in JavaScript vertraut sind, wissen Sie bereits, was dies bedeutet. <br><br>  Hier einige Beispiele f√ºr JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  Die <code>.map()</code> -Methode ist universell in dem Sinne, dass <code>a</code> und <code>b</code> von jedem Typ sein k√∂nnen, und diese Methode bew√§ltigt eine √§hnliche Situation ohne Probleme, da Arrays Datenstrukturen sind, die die algebraischen Gesetze von Funktoren implementieren.  Die Typen f√ºr <code>.map()</code> spielen keine Rolle, da diese Methode nicht versucht, direkt mit den entsprechenden Werten zu arbeiten.  Stattdessen wird eine Funktion verwendet, die Werte der entsprechenden Typen erwartet und zur√ºckgibt, die aus Sicht der Anwendung korrekt sind. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  Die Beziehung universeller Typen kann in Sprachen wie TypeScript schwierig korrekt und vollst√§ndig auszudr√ºcken sein, ist jedoch in dem in Haskell verwendeten Hindley-Milner-Typsystem, das h√∂here Typen (Typtypen) unterst√ºtzt, sehr einfach. <br><br>  Die meisten Typsysteme unterliegen zu starken Einschr√§nkungen, um den freien Ausdruck dynamischer und funktionaler Ideen zu erm√∂glichen, wie z. B. die Zusammensetzung von Funktionen, die freie Zusammensetzung von Objekten, die Erweiterung von Objekten w√§hrend der Programmausf√ºhrung, die Verwendung von Kombinatoren, Linsen usw.  Mit anderen Worten?  Statische Typen erschweren h√§ufig das Schreiben von Software mithilfe von Erstellungsmethoden. <br><br>  Wenn Ihr Typsystem zu viele Einschr√§nkungen aufweist (wie in TypeScript oder Java), m√ºssen Sie komplexeren Code schreiben, um dieselben Ziele zu erreichen, als wenn Sie Sprachen mit einer freieren Schreibweise verwenden.  Dies bedeutet nicht, dass die Verwendung statischer Typen eine ungl√ºckliche Idee ist oder dass alle Implementierungen statischer Typen dieselben Einschr√§nkungen aufweisen.  Zum Beispiel habe ich viel weniger Probleme beim Arbeiten mit dem System vom Typ Haskell festgestellt. <br><br>  Wenn Sie ein Fan von statischen Typen sind und nicht gegen Einschr√§nkungen sind, w√ºnsche ich Ihnen sieben Fu√ü unter dem Kiel.  Wenn Sie jedoch feststellen, dass einige der hier zum Ausdruck gebrachten Ideen schwierig umzusetzen sind, da es nicht einfach ist, Funktionen zu tippen, die durch Zusammensetzen anderer Funktionen und zusammengesetzter algebraischer Strukturen erhalten werden, geben Sie dem Typensystem und nicht der Idee die Schuld.  Fahrer m√∂gen die Annehmlichkeiten, die Rahmen-SUVs ihnen bieten, aber niemand beschwert sich, dass sie nicht fliegen.  Zum Fliegen ben√∂tigen Sie ein Fahrzeug mit mehr Freiheitsgraden. <br><br>  Wenn Einschr√§nkungen Ihren Code einfacher machen - gro√üartig!  Wenn Sie jedoch aufgrund der Einschr√§nkungen gezwungen sind, komplexeren Code zu schreiben, stimmt m√∂glicherweise etwas mit diesen Einschr√§nkungen nicht. <br><br><h2>  <font color="#3AC1EF">Was ist ein "Objekt"?</font> </h2><br>  Das Wort ‚ÄûObjekt‚Äú hat im Laufe der Zeit viele sekund√§re Bedeutungskonnotationen erhalten.  Was wir in JavaScript als "Objekte" bezeichnen, sind einfach zusammengesetzte Datentypen, ohne einen Hinweis auf die klassenbasierte Programmierung oder Alan Kays Ideen zur Nachrichten√ºbermittlung. <br><br>  In JavaScript k√∂nnen diese Objekte die Kapselung, das Weiterleiten von Nachrichten, die Trennung des Verhaltens durch Methoden und sogar den Polymorphismus mithilfe von Unterklassen unterst√ºtzen (h√§ufig auch unterst√ºtzen) (obwohl eine Delegierungskette anstelle eines typbasierten Versands verwendet wird). <br><br>  Alan Kay wollte den Unterschied zwischen dem Programm und seinen Daten beseitigen.  JavaScript erreicht dieses Ziel in gewissem Ma√üe, indem Objektmethoden an derselben Stelle platziert werden wie die Eigenschaften, in denen die Daten gespeichert sind.  Jeder Eigenschaft kann beispielsweise eine beliebige Funktion zugewiesen werden.  Sie k√∂nnen das Objektverhalten dynamisch konstruieren und den semantischen Inhalt des Objekts w√§hrend der Programmausf√ºhrung √§ndern. <br><br>  Ein Objekt ist nur eine zusammengesetzte Datenstruktur und ben√∂tigt nichts Besonderes, um als Objekt betrachtet zu werden.  Die Programmierung mit Objekten f√ºhrt jedoch nicht dazu, dass sich ein solcher Code als "objektorientiert" herausstellt, ebenso wie die Verwendung von Funktionen den Code nicht "funktionsf√§hig" macht. <br><br><h2>  <font color="#3AC1EF">OOP ist kein echtes OOP mehr</font> </h2><br>  Da das Konzept des "Objekts" in modernen Programmiersprachen viel weniger bedeutet als das, was Alan Kay meinte, verwende ich das Wort "Komponente" anstelle des Wortes "Objekt", um die Regeln dieser OOP zu beschreiben.  Viele Objekte sind direkt im Besitz von JavaScript-Code von Drittanbietern und werden von diesen gesteuert. Komponenten m√ºssen jedoch ihren eigenen Status kapseln und steuern. <br><br>  Folgendes ist echtes OOP: <br><br><ul><li>  Programmieren mit Komponenten (Alan Kay nennt sie "Objekte"). </li><li>  Der Status der Komponente muss gekapselt sein. </li><li>  F√ºr die Kommunikation zwischen Entit√§ten wird Messaging verwendet. </li><li>  Komponenten k√∂nnen zur Laufzeit hinzugef√ºgt, ge√§ndert und ersetzt werden. </li></ul><br>  Die meisten Objektverhalten k√∂nnen mithilfe algebraischer Datenstrukturen universell definiert werden.  Es besteht keine Notwendigkeit f√ºr eine Vererbung.  Komponenten k√∂nnen Verhaltensweisen aus √∂ffentlichen Funktionen wiederverwenden und Module importieren, ohne ihre Daten ver√∂ffentlichen zu m√ºssen. <br><br>  Das Bearbeiten von Objekten in JavaScript oder das Verwenden der klassenbasierten Vererbung bedeutet nicht, dass jemand an der OOP-Programmierung beteiligt ist.  Aber die Verwendung von Komponenten auf solche Weise - bedeutet.  Es ist jedoch sehr schwierig, die etablierten Begriffe loszuwerden. Vielleicht sollten wir den Begriff ‚ÄûOOP‚Äú belassen und die oben genannten ‚ÄûKomponenten‚Äú als ‚ÄûMessage Oriented Programming (MOP)‚Äú bezeichnen.  Wir werden den Begriff "MOP" unten verwenden, um √ºber nachrichtenorientierte Programmierung zu sprechen. <br><br>  Zuf√§llig wird das englische Wort "mop" als "mop" √ºbersetzt und, wie Sie wissen, zur Wiederherstellung der Ordnung verwendet. <br><br><h2>  <font color="#3AC1EF">Wie sieht ein guter MOP aus?</font> </h2><br>  Die meisten modernen Programme verf√ºgen √ºber eine Benutzeroberfl√§che (User Interface, UI), die f√ºr die Interaktion mit dem Benutzer verantwortlich ist, einen Code, der den Status der Anwendung verwaltet (Benutzerdaten), und Code, der mit dem System funktioniert oder f√ºr den Datenaustausch mit dem Netzwerk verantwortlich ist. <br><br>  Um den Betrieb jedes dieser Systeme zu unterst√ºtzen, sind m√∂glicherweise langlebige Prozesse erforderlich, z. B. Ereignis-Listener.  Hier ben√∂tigen Sie den Status der Anwendung - um Informationen √ºber Netzwerkverbindungen, den Status der Schnittstellensteuerung und die Anwendung selbst zu speichern. <br><br>  Ein guter MOP bedeutet, dass alle Systeme, die Zugriff auf den Status des anderen haben und diese direkt steuern k√∂nnen, √ºber Nachrichten miteinander interagieren.  Wenn der Benutzer auf die Schaltfl√§che "Speichern" klickt, kann die Nachricht <code>"SAVE"</code> gesendet werden.  Die Anwendungskomponente f√ºr die Statusverwaltung kann diese Nachricht interpretieren und an den Prozessor umleiten, der f√ºr die Aktualisierung aus dem Status verantwortlich ist (z. B. eine reine Reduzierungsfunktion).  M√∂glicherweise <code>"STATE_UPDATED"</code> die f√ºr die Verwaltung des Status verantwortliche Komponente nach dem Aktualisieren des Status die Nachricht <code>"STATE_UPDATED"</code> die Benutzeroberfl√§chenkomponente, die wiederum den Status interpretiert, entscheidet, welche Teile der Schnittstelle aktualisiert werden m√ºssen, und den aktualisierten Status an die Unterkomponenten weitergibt, die f√ºr die Arbeit verantwortlich sind spezifische Schnittstellenelemente. <br><br>  In der Zwischenzeit kann die f√ºr Netzwerkverbindungen verantwortliche Komponente die Verbindung des Benutzers zu einem anderen Computer im Netzwerk √ºberwachen, Nachrichten abh√∂ren und eine aktualisierte Ansicht des Status senden, um sie auf dem Remotecomputer zu speichern.  Eine solche Komponente ist f√ºr die Arbeit mit Netzwerkmechanismen verantwortlich, wei√ü, ob die Verbindung funktioniert oder nicht und so weiter. <br><br>  √Ñhnliche Anwendungssysteme sollten die Details ihrer anderen Teile nicht kennen.  Sie sollten sich nur darum k√ºmmern, ihre eigenen Probleme zu l√∂sen.  Systemkomponenten k√∂nnen als Konstruktor zerlegt und zusammengebaut werden.  Sie implementieren standardisierte Schnittstellen, was bedeutet, dass sie miteinander interagieren k√∂nnen.  Solange die bekannten Anforderungen an die Schnittstelle der Komponenten erf√ºllt sind, k√∂nnen solche Komponenten durch andere ersetzt werden, mit denselben Schnittstellen, aber dasselbe anders machen oder etwas v√∂llig anderes ausf√ºhren, dieselben Nachrichten empfangen.  Sie k√∂nnen eine Komponente auch w√§hrend der Ausf√ºhrung des Programms in eine andere √§ndern - dies wird die Arbeit nicht beeintr√§chtigen. <br><br>  Die Komponenten eines Softwaresystems m√ºssen sich nicht einmal auf demselben Computer befinden.  Das System kann dezentralisiert werden.  Der Netzwerkspeicher kann Daten in einem dezentralen Speichersystem wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPFS ablegen</a> . Dadurch ist der Benutzer unabh√§ngig vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zustand</a> eines bestimmten Computers, wodurch die Sicherheit seiner Daten gew√§hrleistet wird.  Bei diesem Ansatz werden die Daten zuverl√§ssig gespeichert und vor Eindringlingen gesch√ºtzt. <br><br>  Die PLO stand teilweise unter dem Einfluss der Ideen von ARPANET, und eines der Ziele dieses Projekts war die Schaffung eines dezentralen Netzwerks, das gegen Angriffe wie einen Atomschlag resistent ist. <br><br>  Ein gutes MOP-System kann durch ein √§hnliches Ma√ü an Stabilit√§t gekennzeichnet werden, wenn Komponenten verwendet werden, die Hot-Swapping unterst√ºtzen, w√§hrend die Anwendung ausgef√ºhrt wird.  Es kann weiterhin funktionieren, wenn der Benutzer von einem Mobiltelefon aus damit arbeitet und aufgrund der Tatsache, dass es den Tunnel betreten hat, keine Netzabdeckung mehr hat.  Wenn ein Hurrikan die Stromversorgung eines der Rechenzentren unterbricht, in denen sich seine Server befinden, funktioniert er auch weiterhin. <br><br>  Es ist Zeit f√ºr die Software-Welt, sich von einem erfolglosen klassenbasierten Vererbungsexperiment zu befreien und die mathematischen und wissenschaftlichen Prinzipien zu √ºbernehmen, die bei OOP an vorderster Front standen. <br><br>  Es ist Zeit f√ºr uns Entwickler, flexiblere, stabilere und sch√∂nere Programme mit einer harmonischen Kombination aus MOP und funktionaler Programmierung zu erstellen. <br>  √úbrigens wird das Akronym "MOP" bereits verwendet, das "Monitoring Oriented Programming" beschreibt, aber dieses Konzept wird im Gegensatz zu OOP einfach leise verschwinden. <br><br>  Lassen Sie sich daher nicht entmutigen, wenn der Begriff ‚ÄûMOP‚Äú nicht wie ein Wort aus dem Jargon der Programmierer aussieht.  R√§umen Sie einfach Ihren OOP mit den oben genannten MOP-Prinzipien auf. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428582/">https://habr.com/ru/post/de428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428572/index.html">Komponenten h√∂herer Ordnung reagieren</a></li>
<li><a href="../de428574/index.html">Bringen Sie die Unternehmenskommunikation mit Zextras Chat auf die n√§chste Ebene</a></li>
<li><a href="../de428576/index.html">[Lesezeichen] PDF-Version des Node.js-Tutorials und neuer JavaScript-Anleitung</a></li>
<li><a href="../de428578/index.html">Erste Schritte mit der Suche im Ruhezustand</a></li>
<li><a href="../de428580/index.html">Guter Kommunikationsleitfaden</a></li>
<li><a href="../de428588/index.html">Zusammenfassung der IT-Ereignisse im November (Teil zwei)</a></li>
<li><a href="../de428590/index.html">Mikrointeraktionen und Mikroaufforderungen in der Schnittstelle</a></li>
<li><a href="../de428592/index.html">Stellen Sie keine "effektiven Manager" mehr ein. Sie sind nicht nur nutzlos, sondern auch sch√§dlich</a></li>
<li><a href="../de428596/index.html">Elon Musk entlie√ü Starlink-Satelliten-Internet-Projektmanager wegen Nichteinhaltung der Fristen</a></li>
<li><a href="../de428598/index.html">Tiefe neuronale Netze f√ºr die automatische Anrufbewertung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>