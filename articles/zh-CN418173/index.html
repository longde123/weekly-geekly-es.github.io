<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏽 🎹 ❣️ 神经网络的往返或文本分析中自动编码器使用的回顾 🌓 👩‍❤️‍💋‍👩 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们已经在公司博客的第一篇文章中写到了用于检测可转让借款的算法的工作原理。 该文章中只有几段专门讨论比较文本的主题，尽管该想法值得更详细的描述。 但是，正如您所知，尽管一个人确实愿意，但不能立即说出一切。 为了向这个话题和我们称之为“ 自动编码器 ”的网络体系结构致敬， Oleg_Bakhteev和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神经网络的往返或文本分析中自动编码器使用的回顾</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/antiplagiat/blog/418173/">我们已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公司博客的第一篇文章中</a>写到了用于检测可转让借款的算法的工作原理。 该文章中只有几段专门讨论比较文本的主题，尽管该想法值得更详细的描述。 但是，正如您所知，尽管一个人确实愿意，但不能立即说出一切。 为了向这个话题和我们称之为“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">自动编码器</a> ”的网络体系结构致敬， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Oleg_Bakhteev</a>和我写了这篇评论。 <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br> 资料来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NLP深度学习（无魔术）</a> <br><br> 正如我们在那篇文章中提到的，文本的比较是“语义的”-我们没有比较文本片段本身，而是比较了与它们相对应的向量。 这些向量是通过训练神经网络而获得的，该神经网络将任意长度的文本片段显示为较大但固定尺寸的向量。 如何获得这种映射以及如何教导网络产生期望的结果是一个单独的问题，下面将对此进行讨论。 <br><a name="habracut"></a><br><h1> 什么是自动编码器？ </h1><br> 形式上，神经网络称为自动编码器（或自动编码器），它训练以恢复在网络输入处接收到的对象。 <br><img src="https://habrastorage.org/webt/jy/jw/ip/jyjwipnzwzlyidenzeovey3jba4.png"><br> 自动编码器由两部分组成：一个编码器<b>f</b> ，它将样本<b>X</b>编码为其内部表示<b>H</b> ；一个解码器<b>g</b> ，还原原始样本。 因此，自动编码器尝试将每个样本对象的还原版本与原始对象组合在一起。 <br><br> 训练自动编码器时，以下功能被最小化： <br><img src="https://habrastorage.org/webt/9f/ay/cm/9faycmmbldgcxvehefjrurcusyq.png"><br><br> 其中<b>r</b>代表原始对象的还原版本： <br><img src="https://habrastorage.org/webt/zf/oe/oi/zfoeoiwfxnrscvv0n5cv4keku5k.png"><br><br> 考虑<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blog.keras.io中</a>提供的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ： <br><img src="https://habrastorage.org/webt/lw/wp/i_/lwwpi_kn0wyrduexhkqyrg9jttk.png"><br> 网络接收对象<b>x</b>作为输入（在我们的示例中为数字2）。 <br><br> 我们的网络将此对象编码为隐藏状态。 然后，根据潜在状态，恢复对象<b>r的</b>重建，该重建应类似于x。 如我们所见，还原的图像（右侧）变得更加模糊。 可以通过以下事实来解释这一点：我们试图仅在对象的最重要标志处保留隐藏的视图，因此对象将丢失而被恢复。 <br><br> 自动编码器模型是根据电话损坏的原理进行训练的，其中一个人（编码器）将信息<b>（x</b> ）传输给第二个人（解码器<b>）</b> ，然后他又将其告知第三个人<b>（r（x））</b> 。 <br><br> 这种自动编码器的主要目的之一是减小源空间的尺寸。 当我们处理自动编码器时，神经网络训练过程本身使自动编码器记住对象的主要特征，从而可以更轻松地恢复原始样本对象。 <br><br> 在这里，我们可以用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主成分法进行</a>类比：这是一种减小维数的方法，其结果是将样本投影到该样本方差最大的子空间上。 <br><br> 的确，自动编码器是主成分方法的概括：在我们只考虑线性模型的情况下，自动编码器和主成分方法给出相同的矢量表示。 当我们考虑将更复杂的模型（例如多层完全连接的神经网络）作为编码器和解码器时，就会出现这种差异。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用神经网络减少数据的维数一</a>文中提供了一个比较主成分方法和自动编码器的示例： <br><img src="https://habrastorage.org/webt/bj/ap/hq/bjaphq8tpjla39pbn2djsrm84y4.png"><br><br> 在此，说明自动编码器的训练结果和用于采样人脸图像的主要成分方法。 第一行显示了来自对照样本的人的面孔，即 来自样本的特殊延期部分，该部分在学习过程中未被算法使用。 在第二行和第三行分别是从自动编码器和主成分方法的隐藏状态恢复的相同尺寸的图像。 在这里，您可以清楚地看到自动编码器的效果。 <br><br> 在同一篇文章中，另一个说明性示例：比较自动编码器和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LSA</a>方法的结果以进行信息检索。 与主成分方法一样，LSA方法是一种经典的机器学习方法，通常用于与自然语言处理有关的任务中。 <br><img src="https://habrastorage.org/webt/di/h5/j3/dih5j3wsflfohomgzzrjo9e6n7k.png"><br> 该图显示了使用自动编码器和LSA方法获得的多个文档的2D投影。 颜色表示文档的主题。 可以看出，自动编码器的投影按主题很好地分解了文档，而LSA产生的噪声更大。 <br><br> 自动<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编码器的</a>另一个重要应用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是网络预训练</a> 。 当优化的网络足够深时，将使用网络预训练。 在这种情况下，“从头开始”训练网络可能非常困难，因此，首先将整个网络表示为编码器链。 <br><br> 预训练算法非常简单：对于每一层，我们训练自己的自动编码器，然后将下一个编码器的输出同时设置为下一个网络层的输入。 最终的模型由一系列编码器组成，这些编码器经过训练可急于保存对象的最重要特征，每个特征都位于其自己的层上。 预训练方案如下： <br><img src="https://habrastorage.org/webt/yy/mc/ui/yymcuigpqgegoa_7gwndzfxulia.png"><br> 资料来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">psyyz10.github.io</a> <br><br> 这种结构称为堆叠式自动编码器，通常用作“超频”以进一步训练完整的深度网络模型。 进行神经网络训练的动机是深层神经网络是非凸函数：在训练网络的过程中，参数优化可能会“卡在”局部最小值中。 贪婪的网络参数预训练可以让您找到最终训练的良好起点，从而避免出现此类局部最小值。 <br><br> 当然，我们没有考虑所有可能的结构，因为有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">稀疏自动编码器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">降噪自动编码器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">压缩自动编码器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重构压缩自动编码器</a> 。 它们通过使用各种错误函数和惩罚项而彼此不同。 我们认为，所有这些体系结构都应单独审查。 在本文中，我们首先展示了自动编码器的一般概念以及使用自动编码器解决的特定文本分析任务。 <br><br><h2> 它如何在文本中起作用？ </h2><br> 现在我们来看将自动编码器用于文本分析任务的特定示例。 我们对应用程序的两面都感兴趣-两种用于获取内部表示的模型，以及将这些内部表示作为属性使用，例如，在进一步的分类问题中。 关于该主题的文章最常涉及情感分析或措辞检测等任务，但也有一些著作描述了使用自动编码器比较不同语言的文本或进行机器翻译。 <br><br> 在文本分析任务中，对象通常是句子，即 有序的单词序列。 因此，自动编码器恰好接收该单词序列，或者更确切地说，从某些先前训练的模型中获取这些单词的矢量表示。 什么是单词的向量表示形式，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a> ，已在Habré上进行了足够详细的考虑。 因此，以单词序列作为输入的自动编码器必须根据任务训练整个句子的一些内部表示形式，这些内部表示形式对我们来说很重要。 在文本分析问题中，我们需要将句子映射到向量，以便它们在某种距离函数的意义上很接近，通常是余弦量度： <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br> 资料来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NLP深度学习（无魔术）</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Richard Socher</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最早</a>在文本分析中成功使用自动编码器的作者之一。 <br><br> 在他的文章中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动态池化和展开递归自动编码器的释义检测中，</a>他描述了一种新的自动编码结构-展开递归自动编码器（展开RAE）（请参见下图）。 <br><img src="https://habrastorage.org/webt/zn/va/o9/znvao90juxs6ywwmm5ywwe6nrdm.png"><br> 展开中的RAE <br><br> 假定句子结构由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">句法分析器</a>定义。 考虑了最简单的结构-二叉树的结构。 这样的树由叶子（片段的词，内部节点（分支节点）），短语和终极顶点组成。 以单词序列（x <sub>1</sub> ，x <sub>2</sub> ，x <sub>3</sub> ）作为输入（在此示例中为单词的三个向量表示），自动编码器在这种情况下从右到左依次将句子单词的向量表示编码为搭配的向量表示，然后再转换为向量整个报价的介绍。 具体而言，在此示例中，我们首先将向量x <sub>2</sub>和x <sub>3连接起来</sub> ，然后将它们乘以尺寸为<i>hidden×2visible</i>的矩阵<i>W <sub>e</sub></i> ，其中<i>hidden</i>是隐藏内部表示形式的大小， <i>visible</i>是词向量的维数。 因此，我们减小尺寸，然后使用tanh函数添加非线性。 第一步，我们得到了短语两个单词<i>x <sub>2</sub></i>和<i>x <sub>3</sub></i>的隐藏矢量表示： <i>h <sub>1</sub></i> = <i>tanh⁡（W <sub>e</sub> [x <sub>2</sub> ，x <sub>3</sub> ] + b <sub>e</sub> ）</i> 。 在第二个步骤中，我们将其与剩余的单词<i>h <sub>2</sub></i> = <i>tanh⁡（W <sub>e</sub> [h <sub>1</sub> ，x <sub>1</sub> ] + b <sub>e</sub> ）</i>合并，并获得整个句子<i>h <sub>2</sub></i>的向量表示。 如上所述，在自动编码器的定义中，我们需要最小化对象及其还原版本之间的错误。 在我们的情况下，这些都是单词。 因此，在接收到整个句子<i>h <sub>2</sub></i>的最终向量表示之后，我们将解码其还原后的版本（x <sub>1</sub> '，x <sub>2</sub> '，x <sub>3</sub> '）。 此处的解码器与编码器的工作原理相同，只是参数矩阵和移位向量不同： <i>W <sub>d</sub></i>和<i>b <sub>d</sub></i> 。 <br><br> 使用二叉树的结构，您可以将任意长度的句子编码为固定维数的向量-我们始终使用相同的参数<i>W <sub>e</sub></i>矩阵组合一对相同维数的向量。 在非二叉树的情况下，如果我们要组合两个以上的单词-3，4，... n，则只需要提前初始化矩阵，在这种情况下，矩阵将只是<i>隐藏</i>维<i>×不可见</i>维。 <br><br> 值得注意的是，在本文中，训练有素的短语矢量表示不仅用于解决分类问题-还是改写了两个句子。 还显示了搜索最近邻居的实验数据-仅基于接收到的要约向量，搜索样本中最接近它的向量，其含义是： <br><br><img src="https://habrastorage.org/webt/d6/pv/ae/d6pvaevnd18k2ouizgs3t9k0xbk.png"><br><br> 但是，没有人打扰我们使用其他网络体系结构进行编码和解码，以将单词顺序组合为句子。 <br><br> 这是NIPS 2017文章- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反卷积段落表示学习</a>的示例： <br><img src="https://habrastorage.org/webt/g9/u7/0m/g9u70mec8rpyrbnxuqtnflyxcfo.png"><br><br> 我们看到，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">卷积神经网络</a>将样本<b>X</b>编码为隐藏表示<b>h</b> ，并且解码器以相同的原理工作。 <br><br> 或者这是“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">跳过思想向量”</a>文章中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GRU-GRU</a>的示例。 <br><br> 这里一个有趣的功能是该模型可以处理三元组句子：（ <i>s <sub>i-1</sub> ，s <sub>i</sub> ，s <sub>i +1</sub></i> ）。 句子<i>s <sub>i</sub></i>使用标准GRU公式编码，并且解码器使用内部表示信息<i><sub>si</sub></i>尝试也使用GRU解码<i>s <sub>i-1</sub></i>和<i>s <sub>i +1</sub></i> 。 <br><br><img src="https://habrastorage.org/webt/ed/od/-r/edod-radj66y43mbsgu31zxo7nu.png"><br><br> 这种情况下的操作原理类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">神经网络机器翻译</a>的标准模型，该模型根据编码器-解码器方案工作。 但是，这里我们没有两种语言，我们将一种语言的短语提交给编码单元的输入，然后尝试恢复它。 在学习过程中，一些内部质量函数会最小化（这并不总是一个重构错误），然后，如果需要，将预训练向量用作另一个问题的特征。 <br><br> 另一篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">名为《统计机器翻译的双语对应递归自动编码器》的</a>论文提出了一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对机器翻译</a>有新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">见解</a>的体系结构。 首先，对于两种语言，分别训练递归自动编码器（根据上述原理-引入了Unfolding RAE）。 然后，在它们之间，训练第三种自动编码器-两种语言之间的映射。 这样的体系结构具有明显的优势-当将不同语言的文本显示在一个公共的隐藏空间中时，我们可以在不使用机器翻译作为中间步骤的情况下进行比较。 <br><br><img src="https://habrastorage.org/webt/tj/rq/un/tjrqunxjtnbgsivzz7iohnm8ibs.png"><br><br> 关于文本片段的自动编码器的训练通常可以在有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">排名训练的</a>文章中找到。 同样，我们正在训练排名质量的最终功能这一事实很重要，我们首先要对自动编码器进行预训练，以更好地初始化提交给网络输入的请求和响应的向量。 <br><br><img src="https://habrastorage.org/webt/5t/a1/qn/5ta1qnx9gqzl9dypb0t4nhgcjtg.jpeg"><br><br> 而且，当然，我们不能不提及“ <a href="">变分自动编码器</a> ”或<a href="">VAE</a>作为生成模型。 当然，最好只是看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一下Yandex的演讲内容</a> 。 我们只要说以下话就足够了：如果要从常规自动编码器的隐藏空间<i>生成</i>对象，则这种生成的质量会很低，因为我们对隐藏变量的分布一无所知。 但是您可以立即训练自动编码器生成，并引入分布假设。 <br><br> 然后，使用VAE，您可以从此隐藏空间生成文本，例如，文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“从连续空间生成句子”</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“混合卷积变分自动编码器用于文本生成”一文的作者</a> 。 <br><br>  VAE的生成属性在比较不同语言的文本的任务中也能很好地发挥作用- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">诱导跨语言单词嵌入的变体自动编码方法就是</a>一个很好的例子。 <br><br> 最后，我们要作一个小的预测。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表征学习</a> -准确地使用VAE进行内部表征培训，尤其是与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成对抗网络</a>结合使用，是近年来发展最快的方法之一-至少可以通过最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ICLR 2018</a>顶级机器学习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">会议</a>上文章中最常见的主题来判断和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ICML 2018</a> 。 这是很合逻辑的-因为它的使用有助于提高许多任务的质量，而不仅仅是与文本有关。 但这是完全不同的评论的主题... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418173/">https://habr.com/ru/post/zh-CN418173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418163/index.html">生产测试：Netflix Chaos自动化平台</a></li>
<li><a href="../zh-CN418165/index.html">Quasar，Sobaken和Vermin：揭示正在进行的网络间谍活动的细节</a></li>
<li><a href="../zh-CN418167/index.html">ScadaPy：添加IEC 60870-5-104协议</a></li>
<li><a href="../zh-CN418169/index.html">Veeam可用性控制台2.0 Update 1中有哪些新增功能？</a></li>
<li><a href="../zh-CN418171/index.html">如果用户在网站上执行的转换很少，那么要依靠什么指标？</a></li>
<li><a href="../zh-CN418177/index.html">编辑.heic图像而不会丢失颜色</a></li>
<li><a href="../zh-CN418183/index.html">语音分析在商业中的应用</a></li>
<li><a href="../zh-CN418185/index.html">验尸故事：我们如何扭转汉西托</a></li>
<li><a href="../zh-CN418187/index.html">在美国，他们建议使用Amazon集线器替换所有库。 公众很愤慨</a></li>
<li><a href="../zh-CN418189/index.html">宙斯的继承人：为什么IcedID木马对银行客户有害</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>