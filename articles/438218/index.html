<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üë®‚Äçüë®‚Äçüëß‚Äçüëß ‚ôäÔ∏è OpenSceneGraph: manejo de eventos üêù üë©üèø‚Äçüî¨ üñïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Una de las caracter√≠sticas del lenguaje C ++ por el que a menudo es criticado es la falta de un mecanismo de procesamiento de eventos e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: manejo de eventos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438218/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Una de las caracter√≠sticas del lenguaje C ++ por el que a menudo es criticado es la falta de un mecanismo de procesamiento de eventos en el est√°ndar.  Mientras tanto, este mecanismo es una de las principales formas de interacci√≥n de algunos componentes de software con otros componentes de software y hardware, y se implementa a nivel de un sistema operativo espec√≠fico.  Naturalmente, cada plataforma tiene sus propios matices de implementaci√≥n del mecanismo descrito. <br><br>  En relaci√≥n con todo lo anterior, cuando se desarrolla en C ++, existe la necesidad de implementar el procesamiento de eventos de una forma u otra, resuelto mediante el uso de bibliotecas y marcos de terceros.  El conocido marco Qt proporciona un mecanismo para se√±ales y ranuras, que permite organizar la interacci√≥n de clases heredadas de QObject.  La implementaci√≥n de eventos tambi√©n est√° presente en la biblioteca boost.  Y, por supuesto, el motor OpenSceneGraph no podr√≠a prescindir de su propia "bicicleta", cuya aplicaci√≥n se discutir√° en el art√≠culo. <br><a name="habracut"></a><br>  OSG es una biblioteca gr√°fica abstracta.  Por un lado, hace un resumen de la interfaz de procedimiento de OpenGL, proporcionando al desarrollador un conjunto de clases que encapsulan toda la mec√°nica de la API de OpneGL.  Por otro lado, tambi√©n se extrae de una interfaz gr√°fica de usuario espec√≠fica, ya que los enfoques para su implementaci√≥n son diferentes para diferentes plataformas y tienen caracter√≠sticas incluso dentro de la misma plataforma (MFC, Qt, .Net para Windows, por ejemplo). <br><br>  Independientemente de la plataforma, desde el punto de vista de la aplicaci√≥n, la interacci√≥n del usuario con la interfaz gr√°fica se reduce a generar elementos de una secuencia de eventos que luego se procesan dentro de la aplicaci√≥n.  La mayor√≠a de los marcos gr√°ficos utilizan este enfoque, pero incluso dentro de la misma plataforma, desafortunadamente, no son compatibles entre s√≠. <br><br>  Por esta raz√≥n, OSG proporciona su propia interfaz b√°sica para manejar eventos de widgets de widgets y entradas del usuario basadas en la clase osgGA :: GUIEventHandler.  Este controlador se puede adjuntar al visor llamando al m√©todo addEventHandler () y eliminado por el m√©todo removeEventHandler ().  Naturalmente, la clase de controlador concreto debe heredarse de la clase osgGA :: GUIEventHandler, y el m√©todo handle () debe redefinirse en ella.  Este m√©todo acepta dos argumentos: osgGA :: GUIEventAdapter, que contiene la cola de eventos de la GUI y osg :: GUIActionAdepter, utilizado para comentarios.  T√≠pico en la definici√≥n es tal dise√±o <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdepter &amp;aa)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br>  El par√°metro osgGA :: GUIActionAdapter le permite al desarrollador pedirle a la GUI que tome alguna acci√≥n en respuesta al evento.  En la mayor√≠a de los casos, un espectador se ve afectado a trav√©s de este par√°metro, un puntero al que se puede obtener mediante la conversi√≥n din√°mica del puntero <br><br><pre> <code class="cpp hljs">osgViewer::Viewer* viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><h1>  1. Manejo de eventos con teclado y mouse </h1><br>  La clase osgGA :: GUIEventAdapter () gestiona todos los tipos de eventos compatibles con OSG, proporcionando datos para establecer y recuperar sus par√°metros.  El m√©todo getEventType () devuelve el evento GUI actual contenido en la cola de eventos.  Cada vez, anulando el m√©todo handle () del controlador, al llamar a estos m√©todos, debe usar este captador para recibir el evento y determinar su tipo. <br><br>  La siguiente tabla describe todos los eventos disponibles. <br><br><table><thead><tr><th>  Tipo de evento </th><th>  Descripci√≥n </th><th>  M√©todos de adquisici√≥n de eventos. </th></tr></thead><tbody><tr><td>  PULSAR / LIBERAR / DOBLECLICK </td><td>  Haga clic / suelte y haga doble clic con el mouse </td><td>  getX (), getY (): obtiene la posici√≥n del cursor.  getButton (): c√≥digo del bot√≥n presionado (LEFT_MOUSE_BUTTON, RIGHT_MOUSE_BUTTON, MIDDLE_MOUSE_BUTTON </td></tr><tr><td>  Scrol </td><td>  Ruedas de desplazamiento del mouse </td><td>  getScrollingMotion (): devuelve SCROOL_UP, SCROLL_DOWN, SCROLL_LEFT, SCROLL_RIGHT </td></tr><tr><td>  Arrastre </td><td>  Arrastre del mouse </td><td>  getX (), getY () - posici√≥n del cursor;  getButtonMask () - valores similares a getButton () </td></tr><tr><td>  MOVER </td><td>  Movimiento del mouse </td><td>  getX (), getY () - posici√≥n del cursor </td></tr><tr><td>  KEYDOWN / KEYUP </td><td>  Presionando / soltando una tecla en un teclado </td><td>  getKey (): c√≥digo ASCII de la tecla presionada o el valor del enumerador Key_Symbol (por ejemplo, KEY_BackSpace) </td></tr><tr><td>  MARCO </td><td>  Evento generado al representar un marco </td><td>  sin entrada </td></tr><tr><td>  Usuario </td><td>  Evento definido por el usuario </td><td>  getUserDataPointer (): devuelve un puntero a un b√∫fer de datos de usuario (el b√∫fer est√° controlado por un puntero inteligente) </td></tr></tbody></table><br>  Tambi√©n hay un m√©todo getModKeyMask () para obtener informaci√≥n sobre la tecla modificadora presionada (devuelve valores de la forma MODKEY_CTRL, MODKEY_SHIFT, MODKEY_ALT, etc.), que le permite procesar combinaciones de teclas que usan modificadores <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ea.getModKeyMask() == osgGA::GUIEventAdapter::MODKEY_CTRL) { <span class="hljs-comment"><span class="hljs-comment">//    Ctrl }</span></span></code> </pre><br>  Tenga en cuenta que los m√©todos de establecimiento como setX (), setY (), setEventType (), etc.  no se utiliza en el controlador handle ().  El sistema de ventanas gr√°ficas de bajo nivel OSG las llama para poner en cola el evento. <br><br><h1>  2. Controlamos cessna desde el teclado </h1><br>  Ya sabemos c√≥mo transformar objetos de escena a trav√©s de las clases osg :: MatrixTransform.  Examinamos varios tipos de animaciones usando las clases osg :: AnimationPath y osg :: Animation.  Pero para la interactividad de una aplicaci√≥n (por ejemplo, un juego), la animaci√≥n y las transformaciones claramente no son suficientes.  El siguiente paso es controlar la posici√≥n de los objetos en el escenario desde los dispositivos de entrada del usuario.  Tratemos de fijar la gesti√≥n a nuestra querida cessna. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de teclado</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ModelController : public osgGA::GUIEventHandler { public: ModelController( osg::MatrixTransform *node ) : _model(node) {} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool ModelController::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (void) aa; if (!_model.valid()) return false; osg::Matrix matrix = _model-&gt;getMatrix(); switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: switch (ea.getKey()) { case 'a': case 'A': matrix *= osg::Matrix::rotate(-0.1, osg::Z_AXIS); break; case 'd': case 'D': matrix *= osg::Matrix::rotate( 0.1, osg::Z_AXIS); break; case 'w': case 'W': matrix *= osg::Matrix::rotate(-0.1, osg::X_AXIS); break; case 's': case 'S': matrix *= osg::Matrix::rotate( 0.1, osg::X_AXIS); break; default: break; } _model-&gt;setMatrix(matrix); break; default: break; } return true; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(mt.get()); osg::ref_ptr&lt;ModelController&gt; mcontrol = new ModelController(mt.get()); osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get()); viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(0.0f, -100.0f, 0.0f), osg::Vec3(), osg::Z_AXIS ); viewer.getCamera()-&gt;setAllowEventFocus(false); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Para resolver este problema, escribimos una clase de controlador de eventos de entrada <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelController</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelController( osg::MatrixTransform *node ) : _model(node) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; };</code> </pre><br>  Al construir esta clase, como par√°metro, se pasa un puntero al nodo de transformaci√≥n, sobre el cual actuaremos en el controlador.  El m√©todo del controlador handle () en s√≠ mismo se redefine de la siguiente manera <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ModelController::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) aa; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_model.valid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; osg::Matrix matrix = _model-&gt;getMatrix(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::KEYDOWN: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getKey()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'D'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'w'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'W'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'s'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'S'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } _model-&gt;setMatrix(matrix); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Entre los detalles esenciales de su implementaci√≥n, debe tenerse en cuenta que primero debemos obtener la matriz de transformaci√≥n del nodo que controlamos <br><br><pre> <code class="cpp hljs">osg::Matrix matrix = _model-&gt;getMatrix();</code> </pre><br>  A continuaci√≥n, dos instrucciones switch () anidadas analizan el tipo de evento (pulsaci√≥n de tecla) y el c√≥digo de la tecla presionada.  Dependiendo del c√≥digo de la tecla presionada, la matriz de transformaci√≥n actual se multiplica por una matriz de rotaci√≥n adicional alrededor del eje correspondiente <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  - Gire el avi√≥n en √°ngulos de gui√±ada de -0.1 radianes cuando presione la tecla "A". <br><br>  Despu√©s de procesar las pulsaciones del teclado, no olvide aplicar una nueva matriz de transformaci√≥n al nodo de transformaci√≥n. <br><br><pre> <code class="cpp hljs">_model-&gt;setMatrix(matrix);</code> </pre><br>  En la funci√≥n main (), cargue el modelo de avi√≥n y cree un nodo de transformaci√≥n principal para √©l, agregando el subgrafo resultante al nodo ra√≠z de la escena <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(mt.get());</code> </pre><br>  Crear e inicializar manejador de entrada de usuario <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;ModelController&gt; mcontrol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelController(mt.get());</code> </pre><br>  Cree un visor agregando nuestro controlador <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get());</code> </pre><br>  Configurar la matriz de vista de la c√°mara <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-100.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(), osg::Z_AXIS );</code> </pre><br>  Prohibir que la c√°mara reciba eventos de dispositivos de entrada <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setAllowEventFocus(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Si esto no se hace, entonces el controlador que cuelga de la c√°mara interceptar√° de forma predeterminada todas las entradas del usuario e interferir√° con nuestro controlador.  Configuramos los datos de la escena para el espectador y los ejecutamos <br><br><pre> <code class="cpp hljs">viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Ahora, despu√©s de lanzar el programa, podremos controlar la orientaci√≥n de la aeronave en el espacio presionando las teclas A, D, W y S. <br><br><img src="https://habrastorage.org/webt/a0/gu/od/a0guoddsokpfkthvefo07tfn1h4.gif"><br><br>  Una pregunta interesante es qu√© debe devolver el m√©todo handle () al salir de √©l.  Si se devuelve verdadero, entonces indicamos OSG, entonces ya hemos procesado eventos de entrada y no se necesita m√°s procesamiento.  La mayor√≠a de las veces, este comportamiento no nos conviene, por lo que es una buena pr√°ctica devolver falso del controlador para no interrumpir el procesamiento de eventos por otros controladores si est√°n conectados a otros nodos en la escena. <br><br><h1>  3. Uso de visitantes en el procesamiento de eventos. </h1><br>  De manera similar a c√≥mo se implementa al atravesar un gr√°fico de escena al actualizarlo, OSG admite devoluciones de llamada para manejar eventos que pueden asociarse con nodos y objetos geom√©tricos.  Para esto, se utilizan las llamadas a setEventCallback () y addEventCallback (), que toman como par√°metro un puntero al elemento secundario osg :: NodeCallback.  Para recibir eventos en el operador operator (), podemos convertir el puntero que se le pas√≥ al visitante del sitio en un puntero a osgGA :: EventVisitor, por ejemplo, de esta manera <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/EventVisitor&gt; ... void operator()( osg::Node *node, osg::NodeVisitor *nv ) { std::list&lt;osg::ref_ptr&lt;osgGA::GUIEventAdapter&gt;&gt; events; osgGA::EventVisitor *ev = dynamic_cast&lt;osgGA::EventVisitor *&gt;(nv); if (ev) { events = ev-&gt;getEvents(); //       } }</span></span></span></span></code> </pre><br><h1>  4. Creaci√≥n y procesamiento de eventos personalizados. </h1><br>  OSG utiliza una cola de eventos internos (FIFO).  Los eventos al comienzo de la cola se procesan y eliminan de ella.  Los eventos reci√©n generados se colocan al final de la cola.  El m√©todo handle () de cada controlador de eventos se ejecutar√° tantas veces como haya eventos en la cola.  La cola de eventos se describe mediante la clase osgGA :: EventQueue, que, entre otras cosas, le permite colocar un evento en la cola en cualquier momento llamando al m√©todo addEvent ().  El argumento de este m√©todo es un puntero a osgGA :: GUIEventAdapter, que se puede establecer en un comportamiento espec√≠fico utilizando los m√©todos setEventType (), etc. <br><br>  Uno de los m√©todos de la clase osgGA :: EventQueue es userEvent (), que establece un evento personalizado al asociarlo con los datos del usuario, un puntero al que se le pasa como par√°metro.  Estos datos se pueden usar para representar cualquier evento personalizado. <br><br>  No se puede crear una instancia propia de la cola de eventos.  Esta instancia ya se ha creado y adjuntado a la instancia del espectador, por lo que solo puede obtener un puntero a este singleton <br><br><pre> <code class="cpp hljs">viewer.getEventQueue()-&gt;userEvent(data);</code> </pre><br>  Los datos de usuario son un objeto del heredero de osg :: Referenced, es decir, puede crear un puntero inteligente para ellos. <br><br>  Cuando se recibe un evento personalizado, el desarrollador puede extraer datos de √©l llamando al m√©todo getUserData () y procesarlo como mejor le parezca. <br><br><h1>  5. Implementaci√≥n del temporizador de usuario </h1><br>  Muchas bibliotecas y marcos que implementan la GUI proporcionan un desarrollador de clase para implementar temporizadores que generan un evento despu√©s de un cierto intervalo de tiempo.  OSG no contiene medios regulares para implementar temporizadores, as√≠ que intentemos implementar alg√∫n tipo de temporizador por nuestra cuenta, utilizando la interfaz para crear eventos personalizados. <br><br>  ¬øEn qu√© podemos confiar al resolver este problema?  Para un determinado evento peri√≥dico que el render genera constantemente, por ejemplo, en FRAME, el evento de dibujar el siguiente fotograma.  Para esto usamos el mismo ejemplo al cambiar el modelo de cessna de normal a quemado. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de temporizador</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct TimerInfo : public osg::Referenced { TimerInfo(unsigned int c) : _count(c) {} unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class TimerHandler : public osgGA::GUIEventHandler { public: TimerHandler(osg::Switch *sw, unsigned int interval = 1000) : _switch(sw) , _count(0) , _startTime(0.0) , _interval(interval) , _time(0) { } virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::Switch&gt; _switch; unsigned int _count; double _startTime; unsigned int _interval; unsigned int _time; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool TimerHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = dynamic_cast&lt;osgViewer::Viewer *&gt;(&amp;aa); if (!viewer) break; double time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); unsigned int delta = static_cast&lt;unsigned int&gt;( (time - _startTime) * 1000.0); _startTime = time; if ( (_count &gt;= _interval) || (_time == 0) ) { viewer-&gt;getEventQueue()-&gt;userEvent(new TimerInfo(_time)); _count = 0; } _count += delta; _time += delta; break; } case osgGA::GUIEventAdapter::USER: if (_switch.valid()) { const TimerInfo *ti = dynamic_cast&lt;const TimerInfo *&gt;(ea.getUserData()); std::cout &lt;&lt; "Timer event at: " &lt;&lt; ti-&gt;_count &lt;&lt; std::endl; _switch-&gt;setValue(0, !_switch-&gt;getValue(0)); _switch-&gt;setValue(1, !_switch-&gt;getValue(1)); } break; default: break; } return false; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.addEventHandler(new TimerHandler(root.get(), 1000)); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Primero, determinemos el formato de los datos enviados en el mensaje del usuario, defini√©ndolo como una estructura <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Referenced { TimerInfo(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) : _count(c) {} <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br>  El par√°metro _count contendr√° el n√∫mero entero de milisegundos que transcurrieron desde el momento en que se inici√≥ el programa hasta que se recibi√≥ el siguiente evento del temporizador.  La estructura hereda de la clase osg :: Referenced para poder controlarla mediante punteros inteligentes OSG.  Ahora crea un controlador de eventos <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TimerHandler(osg::Switch *sw, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval = <span class="hljs-number"><span class="hljs-number">1000</span></span>) : _switch(sw) , _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) , _startTime(<span class="hljs-number"><span class="hljs-number">0.0</span></span>) , _interval(interval) , _time(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::Switch&gt; _switch; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _startTime; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _interval; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _time; };</code> </pre><br>  Este controlador tiene varios miembros protegidos espec√≠ficos.  La variable _switch indica un nodo que cambia los modelos de aeronave;  _count: la cuenta regresiva relativa del tiempo transcurrido desde la √∫ltima generaci√≥n del evento del temporizador, sirve para contar los intervalos de tiempo;  _startTime: una variable temporal para almacenar la cuenta regresiva anterior, realizada por el espectador;  _time: el tiempo total de funcionamiento del programa en milisegundos.  El constructor de la clase acepta un nodo de conmutaci√≥n como par√°metro y, opcionalmente, el intervalo de tiempo requerido para que funcione el temporizador de conmutaci√≥n. <br><br>  En esta clase, anulamos el m√©todo handle () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> TimerHandler::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!viewer) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); _startTime = time; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _count += delta; _time += delta; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Aqu√≠ analizamos el tipo de mensaje recibido.  Si es FRAME, se realizan las siguientes acciones: <br><ol><li>  Consigue un puntero para el espectador <br></li></ol><br><pre> <code class="cpp hljs">osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><ol><li>  Al recibir el puntero correcto, lea el tiempo transcurrido desde que comenz√≥ el programa <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime();</code> </pre><br>  calcular la cantidad de tiempo dedicado a renderizar un marco en milisegundos <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  y recuerda el recuento de tiempo actual <br><br><pre> <code class="cpp hljs">_startTime = time;</code> </pre><br>  Si el valor del contador _count excedi√≥ el intervalo de tiempo requerido (o esta es la primera llamada cuando _time a√∫n es cero), colocamos el mensaje de usuario en la cola, pasando la estructura anterior el tiempo del programa en milisegundos.  El contador _count se restablece a cero <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Independientemente del valor de _count, debemos aumentarlo y _time por la cantidad de retraso requerido para dibujar un marco <br><br><pre> <code class="cpp hljs">_count += delta; _time += delta;</code> </pre><br>  As√≠ es como se generar√° el evento del temporizador.  El manejo de eventos se implementa de la siguiente manera <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Aqu√≠ verificamos la validez del puntero al nodo de conmutaci√≥n, restamos los datos del evento, desde la estructura TimerInfo, mostramos el contenido de la estructura en la pantalla y cambiamos el estado del nodo. <br><br>  El c√≥digo en la funci√≥n main () es similar al c√≥digo en los dos ejemplos de cambio anteriores, con la diferencia de que en este caso colgamos un controlador de eventos en el visor <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerHandler(root.get(), <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre><br>  pasar el puntero al nodo ra√≠z y el intervalo de conmutaci√≥n requerido en milisegundos al constructor del controlador.  Ejecutando el ejemplo, veremos que los modelos cambian a intervalos de un segundo, y en la consola encontramos la salida de los tiempos en que ocurri√≥ el cambio <br><br><pre> <code class="plaintext hljs">Timer event at: 0 Timer event at: 1000 Timer event at: 2009 Timer event at: 3017 Timer event at: 4025 Timer event at: 5033</code> </pre><br>  Se puede generar un evento personalizado en cualquier momento durante la ejecuci√≥n del programa, y ‚Äã‚Äãno solo cuando se recibe el evento FRAME, y esto proporciona un mecanismo muy flexible para el intercambio de datos entre partes del programa, permite procesar se√±ales de dispositivos de entrada no est√°ndar, como joysticks o guantes VR, por ejemplo. <br><br>  <i>Continuar√° ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438218/">https://habr.com/ru/post/438218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438204/index.html">Dispositivo compilador r√°pido. Parte 1</a></li>
<li><a href="../438206/index.html">26 recomendaciones para usar el tipo var en Java</a></li>
<li><a href="../438210/index.html">Civilizaci√≥n de Springs, 2/5</a></li>
<li><a href="../438212/index.html">Prueba de concepto: c√≥mo verificar la implementaci√≥n de ML vale la pena</a></li>
<li><a href="../438214/index.html">Las nuevas empresas tecnol√≥gicas de EE. UU. Enfrentar√°n nuevos controles gubernamentales en 2019</a></li>
<li><a href="../438224/index.html">Barrio del gobierno. Piloto</a></li>
<li><a href="../438226/index.html">Solucionar problemas de instalaci√≥n de .NET Framework 3.5 en Windows 8 en una red con WSUS</a></li>
<li><a href="../438228/index.html">¬øOrden√≥ gafas de video transparentes con HDMI y USB-C? Conoce: Epson Moverio BT-35E</a></li>
<li><a href="../438230/index.html">Traducci√≥n "Prepare sus aplicaciones para los requisitos de 64 bits"</a></li>
<li><a href="../438234/index.html">Resumen de eventos de TI de febrero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>