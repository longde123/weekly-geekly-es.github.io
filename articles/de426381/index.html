<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíª üåè üî≠ Wie man Python-Funktionen noch besser macht ü§° ü§±üèΩ üö∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tats√§chlich spiegelt der Titel dieses wunderbaren Artikels von Jeff Knapp, Autor von " Writing Idiomatic Python ", seine Essenz voll und ganz wider. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Python-Funktionen noch besser macht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426381/">  Tats√§chlich spiegelt der Titel dieses wunderbaren Artikels von Jeff Knapp, Autor von " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Writing Idiomatic Python</a> ", seine Essenz voll und ganz wider.  Lesen Sie sorgf√§ltig und z√∂gern Sie nicht zu kommentieren. <br><br>  Da wir den wichtigen Begriff wirklich nicht in lateinischen Buchstaben im Text belassen wollten, erlaubten wir uns, das Wort "docstring" als "docstring" zu √ºbersetzen, nachdem wir diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begriff</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehreren</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen entdeckt hatten</a> . <br><a name="habracut"></a><br>  In Python ist wie in den meisten modernen Programmiersprachen eine Funktion die Hauptmethode zum Abstrahieren und Einkapseln.  Sie als Entwickler haben wahrscheinlich bereits Hunderte von Funktionen geschrieben.  Aber Funktionen zu Funktionen - Zwietracht.  Wenn Sie "schlechte" Funktionen schreiben, wirkt sich dies au√üerdem sofort auf die Lesbarkeit und Unterst√ºtzung Ihres Codes aus.  Was ist also eine ‚Äûschlechte‚Äú Funktion und was noch wichtiger ist, wie man sie zu einer ‚Äûguten‚Äú macht? <br><br><h3>  Aktualisieren Sie das Thema </h3><br>  Die Mathematik ist voll von Funktionen, es ist jedoch schwierig, sie abzurufen.  Kehren wir also zu unserer Lieblingsdisziplin zur√ºck: der Analyse.  Sie haben wahrscheinlich Formeln wie <code>f(x) = 2x + 3</code> .  Dies ist eine Funktion namens <code>f</code> , die ein Argument <code>x</code> annimmt und dann zweimal <code>x + 3</code> "zur√ºckgibt".  Obwohl es den Funktionen, die wir in Python gewohnt sind, nicht allzu √§hnlich ist, ist es dem folgenden Code v√∂llig √§hnlich: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Funktionen gibt es in der Mathematik schon lange, aber in der Informatik sind sie vollst√§ndig transformiert.  Diese Kraft ist jedoch nicht umsonst gegeben: Sie m√ºssen verschiedene Fallstricke √ºberwinden.  Lassen Sie uns diskutieren, was eine "gute" Funktion sein sollte und welche "Schnickschnack" typisch f√ºr Funktionen sind, f√ºr die m√∂glicherweise ein Refactoring erforderlich ist. <br><br><h3>  Geheimnisse guter Funktion </h3><br>  Was unterscheidet eine ‚Äûgute‚Äú Python-Funktion von einer mittelm√§√üigen?  Sie werden √ºberrascht sein, wie viele Interpretationen das Wort ‚Äûgut‚Äú zul√§sst.  Als Teil dieses Artikels werde ich die Python-Funktion als "gut" betrachten, wenn sie die <i>meisten</i> Elemente in der folgenden Liste erf√ºllt (manchmal ist es nicht m√∂glich, alle Elemente f√ºr eine bestimmte Funktion zu vervollst√§ndigen): <br><br><ul><li>  Es ist klar benannt </li><li>  Entspricht dem Grundsatz der alleinigen Pflicht </li><li>  Enth√§lt Dock </li><li>  Gibt den Wert zur√ºck </li><li>  Besteht aus nicht mehr als 50 Zeilen </li><li>  Sie ist idempotent und wenn m√∂glich rein </li></ul><br>  F√ºr viele von Ihnen m√∂gen diese Anforderungen √ºberm√§√üig hart erscheinen.  Ich verspreche jedoch: Wenn Ihre Funktionen diesen Regeln entsprechen, werden sie so sch√∂n, dass sie sogar ein Einhorn mit einer Tr√§ne durchbohren.  Im Folgenden werde ich jedem der Elemente der obigen Liste einen Abschnitt widmen, und dann werde ich die Geschichte vervollst√§ndigen, indem ich erz√§hle, wie sie miteinander harmonieren und dabei helfen, gute Funktionen zu schaffen. <br><br>  <b>Benennen</b> <br><br>  Hier ist mein Lieblingszitat zu diesem Thema, das oft f√§lschlicherweise Donald zugeschrieben wird, aber tats√§chlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phil Carleton geh√∂rt</a> : <br><blockquote>  Die Informatik hat zwei Herausforderungen: die Ung√ºltigmachung des Caches und die Benennung. </blockquote>  Egal wie albern es klingt, das Benennen ist wirklich eine knifflige Sache.  Hier ist ein Beispiel f√ºr einen "schlechten" Funktionsnamen: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_knn_from_df</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Jetzt kommen mir fast √ºberall schlechte Namen vor, aber dieses Beispiel stammt aus dem Bereich der Datenwissenschaft (genauer gesagt maschinelles Lernen), wo Praktiker normalerweise Code in ein Jupyter-Notizbuch schreiben und dann versuchen, aus diesen Zellen ein verdauliches Programm zusammenzustellen. <br><br>  Das erste Problem mit dem Namen dieser Funktion besteht darin, dass Abk√ºrzungen verwendet werden.  <b>Es ist besser, vollst√§ndige englische W√∂rter zu verwenden, als Abk√ºrzungen und nicht bekannte Abk√ºrzungen</b> .  Der einzige Grund, warum ich die W√∂rter k√ºrzen m√∂chte, besteht darin, keine Zeit damit zu verschwenden, zu viel Text <i>einzugeben. Jeder moderne Editor verf√ºgt jedoch √ºber eine Autovervollst√§ndigungsfunktion</i> , sodass Sie den vollst√§ndigen Namen der Funktion nur einmal eingeben m√ºssen.  Die Abk√ºrzung ist ein Problem, da sie h√§ufig f√ºr einen Themenbereich spezifisch ist.  Im obigen Code bedeutet <code>knn</code> "K-n√§chste Nachbarn" und <code>df</code> "DataFrame", eine Datenstruktur, die √ºblicherweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas-</a> Bibliothek verwendet wird.  Wenn ein Programmierer, der diese Abk√ºrzungen nicht kennt, den Code liest, versteht er fast nichts im Funktionsnamen. <br><br>  Der Name dieser Funktion weist zwei weitere kleinere M√§ngel auf.  Erstens ist das Wort <code>"get"</code> √ºberfl√ºssig.  Bei den meisten kompetent benannten Funktionen ist sofort klar, dass diese Funktion etwas zur√ºckgibt, was sich speziell im Namen widerspiegelt.  Das <code>from_d</code> f-Element wird ebenfalls nicht ben√∂tigt.  Entweder im Funktionsdock oder (wenn es sich an der Peripherie befindet) in der Typanmerkung wird der Typ des Parameters beschrieben, wenn diese Informationen <i>nicht bereits aus dem Parameternamen ersichtlich sind</i> . <br><br>  Wie benennen wir diese Funktion um?  Nur: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k_nearest_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataframe)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Jetzt versteht sogar ein Laie, was in dieser Funktion berechnet wird, und der Parametername <code>(dataframe)</code> l√§sst keinen Zweifel daran, welches Argument an ihn √ºbergeben werden soll. <br><br><h3>  Alleinige Verantwortung </h3><br>  Bei der Entwicklung der Idee von Bob Martin werde ich sagen, dass das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der alleinigen Verantwortung</a> f√ºr Funktionen gilt, die nicht weniger als Klassen und Module sind (√ºber die Herr Martin urspr√ºnglich geschrieben hat).  Nach diesem Prinzip (in unserem Fall) sollte eine Funktion eine einzige Verantwortung haben.  Das hei√üt, sie muss eine und nur eine Sache tun.  Einer der zwingendsten Gr√ºnde daf√ºr: Wenn eine Funktion nur eines tut, muss sie im einzigen Fall neu geschrieben werden: Wenn genau dies auf eine neue Weise getan werden muss.  Es wird auch klar, wann eine Funktion gel√∂scht werden kann;  Wenn wir bei √Ñnderungen an einer anderen Stelle verstehen, dass die alleinige Pflicht einer Funktion nicht mehr relevant ist, werden wir sie einfach los. <br><br>  Es ist besser, ein Beispiel zu geben.  Hier ist eine Funktion, die mehr als eine ‚ÄûSache‚Äú macht: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list_of_numbers)</span></span></span><span class="hljs-function">:</span></span> sum = sum(list_of_numbers) mean = statistics.mean(list_of_numbers) median = statistics.median(list_of_numbers) mode = statistics.mode(list_of_numbers) print(<span class="hljs-string"><span class="hljs-string">'-----------------Stats-----------------'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'SUM: {}'</span></span>.format(sum) print(<span class="hljs-string"><span class="hljs-string">'MEAN: {}'</span></span>.format(mean) print(<span class="hljs-string"><span class="hljs-string">'MEDIAN: {}'</span></span>.format(median) print(<span class="hljs-string"><span class="hljs-string">'MODE: {}'</span></span>.format(mode)</code> </pre> <br>  Zwei: Berechnet eine Reihe von Statistiken f√ºr eine Liste von Zahlen und zeigt sie in <code>STDOUT</code> .  Eine Funktion verst√∂√üt gegen eine Regel: Es muss einen bestimmten Grund geben, warum sie m√∂glicherweise ge√§ndert werden muss.  In diesem Fall gibt es zwei offensichtliche Gr√ºnde, warum dies erforderlich ist: Entweder m√ºssen Sie neue oder andere Statistiken berechnen oder Sie m√ºssen das Ausgabeformat √§ndern.  Daher ist es besser, diese Funktion in Form von zwei separaten Funktionen neu zu schreiben: Eine f√ºhrt Berechnungen durch und gibt ihre Ergebnisse zur√ºck, die andere empf√§ngt diese Ergebnisse und zeigt sie in der Konsole an.  <i>Eine Funktion (oder besser gesagt, sie hat zwei Verantwortlichkeiten) mit Innereien gibt das Wort <b>und</b> seinen Namen an</i> . <br><br>  Diese Trennung vereinfacht auch das Testen der Funktion erheblich und erm√∂glicht es Ihnen, sie nicht nur in zwei Funktionen innerhalb desselben Moduls aufzuteilen, sondern diese beiden Funktionen gegebenenfalls auch in v√∂llig unterschiedliche Module zu trennen.  Dies tr√§gt weiter zu saubereren Tests bei und vereinfacht die Codeunterst√ºtzung. <br><br>  In der Tat sind Funktionen, die genau zwei Dinge ausf√ºhren, selten.  H√§ufiger sto√üen Sie auf Funktionen, die viel, viel mehr Operationen ausf√ºhren.  Aus Gr√ºnden der Lesbarkeit und Testbarkeit sollten solche "Multi-Station" -Funktionen wiederum in Single-Tasking unterteilt werden, von denen jede einen einzelnen Aspekt der Arbeit enth√§lt. <br><br><h3>  Docstrings </h3><br>  Es scheint, dass jeder wei√ü, dass es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP-8-</a> Dokument gibt, das Empfehlungen zum Stil des Python-Codes enth√§lt, aber es gibt viel weniger Leute unter uns, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP-257 kennen</a> , in denen dieselben Empfehlungen f√ºr Dockstrings gegeben werden.  Um den Inhalt von PEP-257 nicht noch einmal zu erz√§hlen, sende ich Sie selbst zu diesem Dokument - lesen Sie in Ihrer Freizeit.  Seine Hauptideen sind jedoch wie folgt: <br><br><ul><li>  Jede Funktion ben√∂tigt eine Dokumentzeichenfolge. </li><li>  Es sollte Grammatik und Zeichensetzung beachten;  schreibe vollst√§ndige S√§tze </li><li>  Die Dokumentzeichenfolge beginnt mit einer kurzen (in einem Satz) Beschreibung der Funktionsweise der Funktion. </li><li>  Die Dokumentzeichenfolge ist eher in einem vorschreibenden als in einem beschreibenden Stil formuliert </li></ul><br>  All diese Punkte sind beim Schreiben von Funktionen leicht zu befolgen.  Das Schreiben von Docstrings sollte zur Gewohnheit werden und Sie sollten versuchen, sie zu schreiben, bevor Sie mit dem Code der Funktion selbst fortfahren.  Wenn Sie keine eindeutige Dokumentzeichenfolge schreiben k√∂nnen, die die Funktion beschreibt, ist dies ein guter Grund, dar√ºber nachzudenken, warum Sie diese Funktion schreiben. <br><br><h3>  R√ºckgabewerte </h3><br>  Funktionen k√∂nnen (und <i>sollten</i> ) als kleine eigenst√§ndige Programme interpretiert werden.  Sie nehmen einige Eingaben in Form von Parametern vor und geben das Ergebnis zur√ºck.  Parameter sind nat√ºrlich optional.  <i>R√ºckgabewerte sind jedoch aus Sicht der internen Struktur von Python erforderlich</i> .  Wenn Sie sogar versuchen, eine Funktion zu schreiben, die keinen Wert zur√ºckgibt, k√∂nnen Sie dies nicht.  Wenn die Funktion nicht einmal Werte zur√ºckgibt, "zwingt" der Python-Interpreter sie, <code>None</code> .  Glaubst du nicht?  Probieren Sie es selbst aus: <br><br><pre> <code class="python hljs">‚ùØ python3 Python <span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (default, Jul <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>) [Clang <span class="hljs-number"><span class="hljs-number">9.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (clang<span class="hljs-number"><span class="hljs-number">-902.0</span></span><span class="hljs-number"><span class="hljs-number">.39</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>)] on darwin Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> ... print(a + b) ... &gt;&gt;&gt; b = add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; b &gt;&gt;&gt; b <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, ist der Wert von <code>b</code> im Wesentlichen <code>None</code> .  Selbst wenn Sie eine Funktion ohne return-Anweisung schreiben, gibt sie dennoch etwas zur√ºck.  Und das sollte es auch.  Das ist doch ein kleines Programm, oder?  Wie n√ºtzlich sind Programme, aus denen keine Schlussfolgerung gezogen werden kann - und daher ist es unm√∂glich zu beurteilen, ob dieses Programm korrekt ausgef√ºhrt wurde?  Aber am wichtigsten ist, wie werden Sie ein solches Programm <i>testen</i> ? <br><br>  Ich habe nicht einmal Angst, Folgendes zu sagen: Jede Funktion sollte einen n√ºtzlichen Wert zur√ºckgeben, zumindest aus Gr√ºnden der Testbarkeit.  Der Code, den ich schreibe, sollte getestet werden (dies wird nicht besprochen).  Stellen Sie sich vor, wie ungeschickt das Testen der obigen <code>add</code> Funktion <code>add</code> kann (Hinweis: Sie m√ºssen die Eingabe / Ausgabe umleiten, danach wird bald alles schief gehen).  Dar√ºber hinaus k√∂nnen wir durch die R√ºckgabe eines Werts Methoden verketten und daher Code wie folgt schreiben: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'foo.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.strip().lower().endswith(<span class="hljs-string"><span class="hljs-string">'cat'</span></span>): <span class="hljs-comment"><span class="hljs-comment"># ...     - </span></span></code> </pre> <br>  String <code>if line.strip().lower().endswith('cat'):</code> weil jede der String-Methoden ( <code>strip()</code> , <code>lower()</code> , <code>endswith()</code> ) als Ergebnis des Aufrufs der Funktion einen String zur√ºckgibt. <br><br>  Hier sind einige h√§ufige Gr√ºnde, die ein Programmierer Ihnen geben kann, wenn er erkl√§rt, warum eine von ihm geschriebene Funktion keinen Wert zur√ºckgibt: <br><blockquote>  ‚ÄûEs ist nur [eine Art Operation, die sich auf die Eingabe / Ausgabe bezieht, zum Beispiel das Speichern eines Werts in einer Datenbank].  Hier kann ich nichts N√ºtzliches zur√ºckgeben. ‚Äú </blockquote>  Ich stimme nicht zu.  Die Funktion kann True zur√ºckgeben, wenn der Vorgang erfolgreich abgeschlossen wurde. <br><blockquote>  "Hier √§ndern wir einen der verf√ºgbaren Parameter und verwenden ihn als Referenzparameter." </blockquote>  Hier sind zwei Punkte.  Geben Sie zun√§chst Ihr Bestes, um dies nicht zu tun.  Zweitens ist es bestenfalls √ºberraschend und im schlimmsten Fall einfach gef√§hrlich, eine Funktion mit einer Art Argument zu versehen, nur um herauszufinden, dass sie sich ge√§ndert hat.  Versuchen Sie stattdessen, wie bei Zeichenfolgenmethoden, eine neue Instanz des Parameters zur√ºckzugeben, die bereits die darauf angewendeten √Ñnderungen widerspiegelt.  Auch wenn dies nicht m√∂glich ist, k√∂nnen Sie, da das Erstellen einer Kopie eines Parameters mit √ºberm√§√üigen Kosten verbunden ist, auf die oben vorgeschlagene Option " <code>True</code> wenn der Vorgang erfolgreich abgeschlossen wurde" zur√ºcksetzen. <br><blockquote>  ‚ÄûIch muss mehrere Werte zur√ºckgeben.  Es gibt keinen einzigen Wert, dessen R√ºckgabe in diesem Fall ratsam w√§re. ‚Äú </blockquote>  Dieses Argument ist etwas weit hergeholt, aber ich habe es geh√∂rt.  Die Antwort ist nat√ºrlich genau das, was der Autor tun wollte - wusste aber nicht wie: <i>Verwenden Sie ein Tupel, um mehrere Werte zur√ºckzugeben</i> . <br><br>  Schlie√ülich ist das st√§rkste Argument, dass es auf jeden Fall besser ist, einen n√ºtzlichen Wert zur√ºckzugeben, dass der Aufrufer diese Werte immer zu Recht ignorieren kann.  Kurz gesagt, die R√ºckgabe eines Werts aus einer Funktion ist mit ziemlicher Sicherheit eine gute Idee, und es ist h√∂chst unwahrscheinlich, dass wir auf diese Weise etwas besch√§digen, selbst in den vorhandenen Codebasen. <br><br><h3>  Funktionsl√§nge </h3><br>  Ich habe mehr als einmal zugegeben, dass ich ziemlich dumm bin.  Ich kann ungef√§hr drei Dinge gleichzeitig in meinem Kopf behalten.  Wenn Sie mich die 200-Zeilen-Funktion lesen lassen und fragen, was sie bewirkt, werde ich sie wahrscheinlich mindestens 10 Sekunden lang anstarren.  <b>Die L√§nge einer Funktion wirkt sich direkt auf ihre Lesbarkeit und damit auf ihre Unterst√ºtzung aus</b> .  Versuchen Sie daher, Ihre Funktionen kurz zu halten.  50 Zeilen - ein Wert, der vollst√§ndig von der Decke genommen wurde, aber mir vern√ºnftig erscheint.  (Ich hoffe), dass die meisten Funktionen, die Sie gerade schreiben, viel k√ºrzer sind. <br><br>  Wenn eine Funktion dem Prinzip der alleinigen Verantwortung entspricht, ist sie wahrscheinlich kurz genug.  Wenn es unten liest oder idempotent ist (wir werden dar√ºber sprechen) - dann wird es wahrscheinlich auch kurz werden.  All diese Ideen werden harmonisch miteinander kombiniert und tragen dazu bei, guten, sauberen Code zu schreiben. <br><br>  Was tun, wenn Ihre Funktion zu lang ist?  <b>REFACTOR!</b>  Sie m√ºssen wahrscheinlich die ganze Zeit Refactoring durchf√ºhren, auch wenn Sie den Begriff nicht kennen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring</a> √§ndert einfach die Struktur eines Programms, ohne dessen Verhalten zu √§ndern.  Daher ist das Extrahieren mehrerer Codezeilen aus einer langen Funktion und deren Umwandlung in eine unabh√§ngige Funktion eine der Arten des Refactorings.  Es stellt sich heraus, dass dies auch der h√§ufigste und schnellste Weg ist, um lange Funktionen produktiv zu verk√ºrzen.  Da Sie diesen neuen Funktionen entsprechende Namen geben, ist der resultierende Code viel einfacher zu lesen.  Ich habe ein ganzes Buch √ºber Refactoring geschrieben (eigentlich mache ich das die ganze Zeit), daher werde ich hier nicht auf Details eingehen.  Wenn Sie eine zu lange Funktion haben, sollten Sie sie umgestalten. <br><br><h3>  Idempotenz und funktionelle Sauberkeit </h3><br>  Der Titel dieses Abschnitts mag ein wenig einsch√ºchternd wirken, aber konzeptionell ist der Abschnitt einfach.  Eine idempotente Funktion mit denselben Argumenten gibt immer denselben Wert zur√ºck, unabh√§ngig davon, wie oft sie aufgerufen wird.  Das Ergebnis h√§ngt nicht von nicht lokalen Variablen, der Variabilit√§t von Argumenten oder von Daten ab, die aus Eingabe- / Ausgabestreams stammen.  Die folgende Funktion <code>add_three(number)</code> ist idempotent: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Unabh√§ngig davon, wie oft wir <code>add_three(7)</code> aufrufen, <code>add_three(7)</code> die Antwort immer 10. Ein anderer Fall ist eine Funktion, die nicht idempotent ist: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" 3 + ,  ."""</span></span> number = int(input(<span class="hljs-string"><span class="hljs-string">'Enter a number: '</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Diese offen erfundene Funktion ist nicht idempotent, da der R√ºckgabewert der Funktion von der Eingabe / Ausgabe abh√§ngt, n√§mlich von der vom Benutzer eingegebenen Nummer.  Bei unterschiedlichen Aufrufen von <code>add_three()</code> R√ºckgabewerte nat√ºrlich unterschiedlich.  Wenn wir diese Funktion zweimal aufrufen, kann der Benutzer im ersten Fall 3 und im zweiten - 7 <code>add_three()</code> , und dann <code>add_three()</code> zwei Aufrufe von <code>add_three()</code> 6 bzw. 10 zur√ºck. <br><br>  Au√üerhalb der Programmierung gibt es auch Beispiele f√ºr Idempotenz - zum Beispiel ist der Aufw√§rtsknopf des Aufzugs nach diesem Prinzip ausgelegt.  Durch erstmaliges Dr√ºcken ‚Äûbenachrichtigen‚Äú wir den Aufzug, dass wir hochfahren m√∂chten.  Da die Taste idempotent ist, passiert nichts Schlimmes, egal wie oft Sie sie sp√§ter dr√ºcken.  Das Ergebnis wird immer das gleiche sein. <br><br><h3>  Warum Idempotenz so wichtig ist </h3><br>  Testbarkeit und Usability-Unterst√ºtzung.  Idempotente Funktionen sind einfach zu testen, da sie in jedem Fall garantiert dasselbe Ergebnis liefern, wenn Sie sie mit denselben Argumenten aufrufen.  Beim Testen muss √ºberpr√ºft werden, ob die Funktion bei einer Vielzahl von Aufrufen immer den erwarteten Wert zur√ºckgibt.  Dar√ºber hinaus sind diese Tests schnell: Die Testgeschwindigkeit ist ein wichtiges Thema, das bei Unit-Tests h√§ufig √ºbersehen wird.  Und Refactoring bei der Arbeit mit idempotenten Funktionen ist im Allgemeinen ein einfacher Weg.  Es spielt keine Rolle, wie Sie den Code au√üerhalb der Funktion √§ndern - das Ergebnis des Aufrufs mit denselben Argumenten ist immer dasselbe. <br><br><h3>  Was ist eine "reine" Funktion? </h3><br>  In der funktionalen Programmierung gilt eine Funktion als rein, wenn sie <i>erstens</i> idempotent ist und <i>zweitens</i> die beobachteten <b>Nebenwirkungen</b> nicht verursacht.  Vergessen Sie nicht: Eine Funktion ist idempotent, wenn sie immer das gleiche Ergebnis mit einem bestimmten Satz von Argumenten zur√ºckgibt.  Dies bedeutet jedoch nicht, dass die Funktion keine Auswirkungen auf andere Komponenten haben kann, z. B. nicht lokale Variablen oder Eingabe- / Ausgabestreams.  Wenn beispielsweise die idempotente Version der obigen Funktion <code>add_three(number)</code> das Ergebnis an die Konsole ausgibt und erst dann <code>add_three(number)</code> , wird es weiterhin als idempotent betrachtet, da diese Zugriffsoperation beim Zugriff auf den Eingabe- / Ausgabestream keinen Einfluss auf den zur√ºckgegebenen Wert hat von der Funktion.  Der Aufruf von <code>print()</code> ist nur ein <i>Nebeneffekt</i> : Die Interaktion mit dem Rest des Programms oder Systems als solchem ‚Äã‚Äãerfolgt zusammen mit dem R√ºckgabewert. <br><br>  Lassen Sie uns unser Beispiel ein wenig mit <code>add_three(number)</code> .  Sie k√∂nnen den folgenden Code schreiben, um festzustellen, wie oft <code>add_three(number)</code> aufgerufen wurde: <br><br><pre> <code class="python hljs">add_three_calls = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> add_three_calls print(<span class="hljs-string"><span class="hljs-string">f'Returning </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{number + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">'</span></span>) add_three_calls += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""",     *add_three*."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_three_calls</code> </pre> <br>  Jetzt f√ºhren wir die Ausgabe an die Konsole aus (dies ist ein Nebeneffekt) und √§ndern die nicht lokale Variable (ein weiterer Nebeneffekt). Da jedoch keiner dieser Werte den von der Funktion zur√ºckgegebenen Wert beeinflusst, ist er ohnehin idempotent. <br><br>  Reine Funktion hat keine Nebenwirkungen.  Es verwendet nicht nur keine "externen Daten" bei der Berechnung des Werts, sondern interagiert nicht mit dem Rest des Programms / Systems, sondern berechnet nur den angegebenen Wert und gibt ihn zur√ºck.  Obwohl unsere neue Definition von <code>add_three(number)</code> idempotent bleibt, ist diese Funktion daher nicht mehr rein. <br><br>  In reinen Funktionen gibt es keine Protokollierungsanweisungen oder <code>print()</code> -Aufrufe.  W√§hrend der Arbeit greifen sie nicht auf die Datenbank zu und verwenden keine Internetverbindungen.  Greifen Sie nicht auf nicht lokale Variablen zu oder √§ndern Sie sie nicht.  <b>Und rufen Sie keine anderen nicht reinen Funktionen auf</b> . <br><br>  Kurz gesagt, sie haben keine ‚Äûschreckliche Fernwirkung‚Äú, wie es die Worte von Einstein ausdr√ºcken (aber im Kontext der Informatik, nicht der Physik).  Sie ver√§ndern den Rest des Programms oder Systems in keiner Weise.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">imperativen Programmierung</a> (was Sie tun, wenn Sie Code in Python schreiben) sind solche Funktionen am sichersten.  Sie sind bekannt f√ºr ihre Testbarkeit und einfache Unterst√ºtzung.  Da sie idempotent sind, ist das Testen solcher Funktionen garantiert so schnell wie das Ausf√ºhren.  Die Tests selbst sind ebenfalls einfach: Sie m√ºssen keine Verbindung zur Datenbank herstellen oder externe Ressourcen simulieren, die Erstkonfiguration des Codes vorbereiten und am Ende der Arbeit nichts mehr bereinigen. <br><br>  Ehrlich gesagt sind Idempotenz und Sauberkeit sehr w√ºnschenswert, aber nicht erforderlich.  ,         ,     ,     . , ,  ,    ,         .  ,        ,           . <br><br><h3>  Fazit </h3><br>  Das ist alles. ,     ‚Äì   .          . ,   .    ‚Äì    !          . ,  ,   ,       ¬´ ¬ª.     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426381/">https://habr.com/ru/post/de426381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426371/index.html">Audio Digest: 17 Materialien und praktische Anleitungen zum Thema professionelle Akustik</a></li>
<li><a href="../de426373/index.html">Funktionen in der Konsole erstellen. Teil 1</a></li>
<li><a href="../de426375/index.html">Technologieanalyse: Wo soll mit der Arbeit an der Patentlandschaft begonnen werden?</a></li>
<li><a href="../de426377/index.html">Spiel mit Mathe-Diagrammen anstelle von Diagrammen</a></li>
<li><a href="../de426379/index.html">Illusionen los</a></li>
<li><a href="../de426385/index.html">Warum sollten Sie kein akademisches Englisch lernen?</a></li>
<li><a href="../de426387/index.html">Grafik in Julia. Seltsame Muster, die Reflexion eines Dreiecks von einer geraden Linie und die Konstruktion der Normalen einer kugelf√∂rmigen Katze im Vakuum</a></li>
<li><a href="../de426389/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 334 (7.-14. Oktober 2018)</a></li>
<li><a href="../de426391/index.html">PHP Digest Nr. 141 (1. - 15. Oktober 2018)</a></li>
<li><a href="../de426395/index.html">Zum Zeitpunkt des Kaufs wird eine Geb√ºhr f√ºr Waren aus ausl√§ndischen Online-Shops erhoben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>