<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 🌏 🔭 Wie man Python-Funktionen noch besser macht 🤡 🤱🏽 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tatsächlich spiegelt der Titel dieses wunderbaren Artikels von Jeff Knapp, Autor von " Writing Idiomatic Python ", seine Essenz voll und ganz wider. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Python-Funktionen noch besser macht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426381/">  Tatsächlich spiegelt der Titel dieses wunderbaren Artikels von Jeff Knapp, Autor von " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Writing Idiomatic Python</a> ", seine Essenz voll und ganz wider.  Lesen Sie sorgfältig und zögern Sie nicht zu kommentieren. <br><br>  Da wir den wichtigen Begriff wirklich nicht in lateinischen Buchstaben im Text belassen wollten, erlaubten wir uns, das Wort "docstring" als "docstring" zu übersetzen, nachdem wir diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begriff</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehreren</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen entdeckt hatten</a> . <br><a name="habracut"></a><br>  In Python ist wie in den meisten modernen Programmiersprachen eine Funktion die Hauptmethode zum Abstrahieren und Einkapseln.  Sie als Entwickler haben wahrscheinlich bereits Hunderte von Funktionen geschrieben.  Aber Funktionen zu Funktionen - Zwietracht.  Wenn Sie "schlechte" Funktionen schreiben, wirkt sich dies außerdem sofort auf die Lesbarkeit und Unterstützung Ihres Codes aus.  Was ist also eine „schlechte“ Funktion und was noch wichtiger ist, wie man sie zu einer „guten“ macht? <br><br><h3>  Aktualisieren Sie das Thema </h3><br>  Die Mathematik ist voll von Funktionen, es ist jedoch schwierig, sie abzurufen.  Kehren wir also zu unserer Lieblingsdisziplin zurück: der Analyse.  Sie haben wahrscheinlich Formeln wie <code>f(x) = 2x + 3</code> .  Dies ist eine Funktion namens <code>f</code> , die ein Argument <code>x</code> annimmt und dann zweimal <code>x + 3</code> "zurückgibt".  Obwohl es den Funktionen, die wir in Python gewohnt sind, nicht allzu ähnlich ist, ist es dem folgenden Code völlig ähnlich: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Funktionen gibt es in der Mathematik schon lange, aber in der Informatik sind sie vollständig transformiert.  Diese Kraft ist jedoch nicht umsonst gegeben: Sie müssen verschiedene Fallstricke überwinden.  Lassen Sie uns diskutieren, was eine "gute" Funktion sein sollte und welche "Schnickschnack" typisch für Funktionen sind, für die möglicherweise ein Refactoring erforderlich ist. <br><br><h3>  Geheimnisse guter Funktion </h3><br>  Was unterscheidet eine „gute“ Python-Funktion von einer mittelmäßigen?  Sie werden überrascht sein, wie viele Interpretationen das Wort „gut“ zulässt.  Als Teil dieses Artikels werde ich die Python-Funktion als "gut" betrachten, wenn sie die <i>meisten</i> Elemente in der folgenden Liste erfüllt (manchmal ist es nicht möglich, alle Elemente für eine bestimmte Funktion zu vervollständigen): <br><br><ul><li>  Es ist klar benannt </li><li>  Entspricht dem Grundsatz der alleinigen Pflicht </li><li>  Enthält Dock </li><li>  Gibt den Wert zurück </li><li>  Besteht aus nicht mehr als 50 Zeilen </li><li>  Sie ist idempotent und wenn möglich rein </li></ul><br>  Für viele von Ihnen mögen diese Anforderungen übermäßig hart erscheinen.  Ich verspreche jedoch: Wenn Ihre Funktionen diesen Regeln entsprechen, werden sie so schön, dass sie sogar ein Einhorn mit einer Träne durchbohren.  Im Folgenden werde ich jedem der Elemente der obigen Liste einen Abschnitt widmen, und dann werde ich die Geschichte vervollständigen, indem ich erzähle, wie sie miteinander harmonieren und dabei helfen, gute Funktionen zu schaffen. <br><br>  <b>Benennen</b> <br><br>  Hier ist mein Lieblingszitat zu diesem Thema, das oft fälschlicherweise Donald zugeschrieben wird, aber tatsächlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phil Carleton gehört</a> : <br><blockquote>  Die Informatik hat zwei Herausforderungen: die Ungültigmachung des Caches und die Benennung. </blockquote>  Egal wie albern es klingt, das Benennen ist wirklich eine knifflige Sache.  Hier ist ein Beispiel für einen "schlechten" Funktionsnamen: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_knn_from_df</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Jetzt kommen mir fast überall schlechte Namen vor, aber dieses Beispiel stammt aus dem Bereich der Datenwissenschaft (genauer gesagt maschinelles Lernen), wo Praktiker normalerweise Code in ein Jupyter-Notizbuch schreiben und dann versuchen, aus diesen Zellen ein verdauliches Programm zusammenzustellen. <br><br>  Das erste Problem mit dem Namen dieser Funktion besteht darin, dass Abkürzungen verwendet werden.  <b>Es ist besser, vollständige englische Wörter zu verwenden, als Abkürzungen und nicht bekannte Abkürzungen</b> .  Der einzige Grund, warum ich die Wörter kürzen möchte, besteht darin, keine Zeit damit zu verschwenden, zu viel Text <i>einzugeben. Jeder moderne Editor verfügt jedoch über eine Autovervollständigungsfunktion</i> , sodass Sie den vollständigen Namen der Funktion nur einmal eingeben müssen.  Die Abkürzung ist ein Problem, da sie häufig für einen Themenbereich spezifisch ist.  Im obigen Code bedeutet <code>knn</code> "K-nächste Nachbarn" und <code>df</code> "DataFrame", eine Datenstruktur, die üblicherweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas-</a> Bibliothek verwendet wird.  Wenn ein Programmierer, der diese Abkürzungen nicht kennt, den Code liest, versteht er fast nichts im Funktionsnamen. <br><br>  Der Name dieser Funktion weist zwei weitere kleinere Mängel auf.  Erstens ist das Wort <code>"get"</code> überflüssig.  Bei den meisten kompetent benannten Funktionen ist sofort klar, dass diese Funktion etwas zurückgibt, was sich speziell im Namen widerspiegelt.  Das <code>from_d</code> f-Element wird ebenfalls nicht benötigt.  Entweder im Funktionsdock oder (wenn es sich an der Peripherie befindet) in der Typanmerkung wird der Typ des Parameters beschrieben, wenn diese Informationen <i>nicht bereits aus dem Parameternamen ersichtlich sind</i> . <br><br>  Wie benennen wir diese Funktion um?  Nur: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k_nearest_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataframe)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Jetzt versteht sogar ein Laie, was in dieser Funktion berechnet wird, und der Parametername <code>(dataframe)</code> lässt keinen Zweifel daran, welches Argument an ihn übergeben werden soll. <br><br><h3>  Alleinige Verantwortung </h3><br>  Bei der Entwicklung der Idee von Bob Martin werde ich sagen, dass das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der alleinigen Verantwortung</a> für Funktionen gilt, die nicht weniger als Klassen und Module sind (über die Herr Martin ursprünglich geschrieben hat).  Nach diesem Prinzip (in unserem Fall) sollte eine Funktion eine einzige Verantwortung haben.  Das heißt, sie muss eine und nur eine Sache tun.  Einer der zwingendsten Gründe dafür: Wenn eine Funktion nur eines tut, muss sie im einzigen Fall neu geschrieben werden: Wenn genau dies auf eine neue Weise getan werden muss.  Es wird auch klar, wann eine Funktion gelöscht werden kann;  Wenn wir bei Änderungen an einer anderen Stelle verstehen, dass die alleinige Pflicht einer Funktion nicht mehr relevant ist, werden wir sie einfach los. <br><br>  Es ist besser, ein Beispiel zu geben.  Hier ist eine Funktion, die mehr als eine „Sache“ macht: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list_of_numbers)</span></span></span><span class="hljs-function">:</span></span> sum = sum(list_of_numbers) mean = statistics.mean(list_of_numbers) median = statistics.median(list_of_numbers) mode = statistics.mode(list_of_numbers) print(<span class="hljs-string"><span class="hljs-string">'-----------------Stats-----------------'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'SUM: {}'</span></span>.format(sum) print(<span class="hljs-string"><span class="hljs-string">'MEAN: {}'</span></span>.format(mean) print(<span class="hljs-string"><span class="hljs-string">'MEDIAN: {}'</span></span>.format(median) print(<span class="hljs-string"><span class="hljs-string">'MODE: {}'</span></span>.format(mode)</code> </pre> <br>  Zwei: Berechnet eine Reihe von Statistiken für eine Liste von Zahlen und zeigt sie in <code>STDOUT</code> .  Eine Funktion verstößt gegen eine Regel: Es muss einen bestimmten Grund geben, warum sie möglicherweise geändert werden muss.  In diesem Fall gibt es zwei offensichtliche Gründe, warum dies erforderlich ist: Entweder müssen Sie neue oder andere Statistiken berechnen oder Sie müssen das Ausgabeformat ändern.  Daher ist es besser, diese Funktion in Form von zwei separaten Funktionen neu zu schreiben: Eine führt Berechnungen durch und gibt ihre Ergebnisse zurück, die andere empfängt diese Ergebnisse und zeigt sie in der Konsole an.  <i>Eine Funktion (oder besser gesagt, sie hat zwei Verantwortlichkeiten) mit Innereien gibt das Wort <b>und</b> seinen Namen an</i> . <br><br>  Diese Trennung vereinfacht auch das Testen der Funktion erheblich und ermöglicht es Ihnen, sie nicht nur in zwei Funktionen innerhalb desselben Moduls aufzuteilen, sondern diese beiden Funktionen gegebenenfalls auch in völlig unterschiedliche Module zu trennen.  Dies trägt weiter zu saubereren Tests bei und vereinfacht die Codeunterstützung. <br><br>  In der Tat sind Funktionen, die genau zwei Dinge ausführen, selten.  Häufiger stoßen Sie auf Funktionen, die viel, viel mehr Operationen ausführen.  Aus Gründen der Lesbarkeit und Testbarkeit sollten solche "Multi-Station" -Funktionen wiederum in Single-Tasking unterteilt werden, von denen jede einen einzelnen Aspekt der Arbeit enthält. <br><br><h3>  Docstrings </h3><br>  Es scheint, dass jeder weiß, dass es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP-8-</a> Dokument gibt, das Empfehlungen zum Stil des Python-Codes enthält, aber es gibt viel weniger Leute unter uns, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP-257 kennen</a> , in denen dieselben Empfehlungen für Dockstrings gegeben werden.  Um den Inhalt von PEP-257 nicht noch einmal zu erzählen, sende ich Sie selbst zu diesem Dokument - lesen Sie in Ihrer Freizeit.  Seine Hauptideen sind jedoch wie folgt: <br><br><ul><li>  Jede Funktion benötigt eine Dokumentzeichenfolge. </li><li>  Es sollte Grammatik und Zeichensetzung beachten;  schreibe vollständige Sätze </li><li>  Die Dokumentzeichenfolge beginnt mit einer kurzen (in einem Satz) Beschreibung der Funktionsweise der Funktion. </li><li>  Die Dokumentzeichenfolge ist eher in einem vorschreibenden als in einem beschreibenden Stil formuliert </li></ul><br>  All diese Punkte sind beim Schreiben von Funktionen leicht zu befolgen.  Das Schreiben von Docstrings sollte zur Gewohnheit werden und Sie sollten versuchen, sie zu schreiben, bevor Sie mit dem Code der Funktion selbst fortfahren.  Wenn Sie keine eindeutige Dokumentzeichenfolge schreiben können, die die Funktion beschreibt, ist dies ein guter Grund, darüber nachzudenken, warum Sie diese Funktion schreiben. <br><br><h3>  Rückgabewerte </h3><br>  Funktionen können (und <i>sollten</i> ) als kleine eigenständige Programme interpretiert werden.  Sie nehmen einige Eingaben in Form von Parametern vor und geben das Ergebnis zurück.  Parameter sind natürlich optional.  <i>Rückgabewerte sind jedoch aus Sicht der internen Struktur von Python erforderlich</i> .  Wenn Sie sogar versuchen, eine Funktion zu schreiben, die keinen Wert zurückgibt, können Sie dies nicht.  Wenn die Funktion nicht einmal Werte zurückgibt, "zwingt" der Python-Interpreter sie, <code>None</code> .  Glaubst du nicht?  Probieren Sie es selbst aus: <br><br><pre> <code class="python hljs">❯ python3 Python <span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (default, Jul <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>) [Clang <span class="hljs-number"><span class="hljs-number">9.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (clang<span class="hljs-number"><span class="hljs-number">-902.0</span></span><span class="hljs-number"><span class="hljs-number">.39</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>)] on darwin Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> ... print(a + b) ... &gt;&gt;&gt; b = add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; b &gt;&gt;&gt; b <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Wie Sie sehen können, ist der Wert von <code>b</code> im Wesentlichen <code>None</code> .  Selbst wenn Sie eine Funktion ohne return-Anweisung schreiben, gibt sie dennoch etwas zurück.  Und das sollte es auch.  Das ist doch ein kleines Programm, oder?  Wie nützlich sind Programme, aus denen keine Schlussfolgerung gezogen werden kann - und daher ist es unmöglich zu beurteilen, ob dieses Programm korrekt ausgeführt wurde?  Aber am wichtigsten ist, wie werden Sie ein solches Programm <i>testen</i> ? <br><br>  Ich habe nicht einmal Angst, Folgendes zu sagen: Jede Funktion sollte einen nützlichen Wert zurückgeben, zumindest aus Gründen der Testbarkeit.  Der Code, den ich schreibe, sollte getestet werden (dies wird nicht besprochen).  Stellen Sie sich vor, wie ungeschickt das Testen der obigen <code>add</code> Funktion <code>add</code> kann (Hinweis: Sie müssen die Eingabe / Ausgabe umleiten, danach wird bald alles schief gehen).  Darüber hinaus können wir durch die Rückgabe eines Werts Methoden verketten und daher Code wie folgt schreiben: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'foo.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.strip().lower().endswith(<span class="hljs-string"><span class="hljs-string">'cat'</span></span>): <span class="hljs-comment"><span class="hljs-comment"># ...     - </span></span></code> </pre> <br>  String <code>if line.strip().lower().endswith('cat'):</code> weil jede der String-Methoden ( <code>strip()</code> , <code>lower()</code> , <code>endswith()</code> ) als Ergebnis des Aufrufs der Funktion einen String zurückgibt. <br><br>  Hier sind einige häufige Gründe, die ein Programmierer Ihnen geben kann, wenn er erklärt, warum eine von ihm geschriebene Funktion keinen Wert zurückgibt: <br><blockquote>  „Es ist nur [eine Art Operation, die sich auf die Eingabe / Ausgabe bezieht, zum Beispiel das Speichern eines Werts in einer Datenbank].  Hier kann ich nichts Nützliches zurückgeben. “ </blockquote>  Ich stimme nicht zu.  Die Funktion kann True zurückgeben, wenn der Vorgang erfolgreich abgeschlossen wurde. <br><blockquote>  "Hier ändern wir einen der verfügbaren Parameter und verwenden ihn als Referenzparameter." </blockquote>  Hier sind zwei Punkte.  Geben Sie zunächst Ihr Bestes, um dies nicht zu tun.  Zweitens ist es bestenfalls überraschend und im schlimmsten Fall einfach gefährlich, eine Funktion mit einer Art Argument zu versehen, nur um herauszufinden, dass sie sich geändert hat.  Versuchen Sie stattdessen, wie bei Zeichenfolgenmethoden, eine neue Instanz des Parameters zurückzugeben, die bereits die darauf angewendeten Änderungen widerspiegelt.  Auch wenn dies nicht möglich ist, können Sie, da das Erstellen einer Kopie eines Parameters mit übermäßigen Kosten verbunden ist, auf die oben vorgeschlagene Option " <code>True</code> wenn der Vorgang erfolgreich abgeschlossen wurde" zurücksetzen. <br><blockquote>  „Ich muss mehrere Werte zurückgeben.  Es gibt keinen einzigen Wert, dessen Rückgabe in diesem Fall ratsam wäre. “ </blockquote>  Dieses Argument ist etwas weit hergeholt, aber ich habe es gehört.  Die Antwort ist natürlich genau das, was der Autor tun wollte - wusste aber nicht wie: <i>Verwenden Sie ein Tupel, um mehrere Werte zurückzugeben</i> . <br><br>  Schließlich ist das stärkste Argument, dass es auf jeden Fall besser ist, einen nützlichen Wert zurückzugeben, dass der Aufrufer diese Werte immer zu Recht ignorieren kann.  Kurz gesagt, die Rückgabe eines Werts aus einer Funktion ist mit ziemlicher Sicherheit eine gute Idee, und es ist höchst unwahrscheinlich, dass wir auf diese Weise etwas beschädigen, selbst in den vorhandenen Codebasen. <br><br><h3>  Funktionslänge </h3><br>  Ich habe mehr als einmal zugegeben, dass ich ziemlich dumm bin.  Ich kann ungefähr drei Dinge gleichzeitig in meinem Kopf behalten.  Wenn Sie mich die 200-Zeilen-Funktion lesen lassen und fragen, was sie bewirkt, werde ich sie wahrscheinlich mindestens 10 Sekunden lang anstarren.  <b>Die Länge einer Funktion wirkt sich direkt auf ihre Lesbarkeit und damit auf ihre Unterstützung aus</b> .  Versuchen Sie daher, Ihre Funktionen kurz zu halten.  50 Zeilen - ein Wert, der vollständig von der Decke genommen wurde, aber mir vernünftig erscheint.  (Ich hoffe), dass die meisten Funktionen, die Sie gerade schreiben, viel kürzer sind. <br><br>  Wenn eine Funktion dem Prinzip der alleinigen Verantwortung entspricht, ist sie wahrscheinlich kurz genug.  Wenn es unten liest oder idempotent ist (wir werden darüber sprechen) - dann wird es wahrscheinlich auch kurz werden.  All diese Ideen werden harmonisch miteinander kombiniert und tragen dazu bei, guten, sauberen Code zu schreiben. <br><br>  Was tun, wenn Ihre Funktion zu lang ist?  <b>REFACTOR!</b>  Sie müssen wahrscheinlich die ganze Zeit Refactoring durchführen, auch wenn Sie den Begriff nicht kennen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring</a> ändert einfach die Struktur eines Programms, ohne dessen Verhalten zu ändern.  Daher ist das Extrahieren mehrerer Codezeilen aus einer langen Funktion und deren Umwandlung in eine unabhängige Funktion eine der Arten des Refactorings.  Es stellt sich heraus, dass dies auch der häufigste und schnellste Weg ist, um lange Funktionen produktiv zu verkürzen.  Da Sie diesen neuen Funktionen entsprechende Namen geben, ist der resultierende Code viel einfacher zu lesen.  Ich habe ein ganzes Buch über Refactoring geschrieben (eigentlich mache ich das die ganze Zeit), daher werde ich hier nicht auf Details eingehen.  Wenn Sie eine zu lange Funktion haben, sollten Sie sie umgestalten. <br><br><h3>  Idempotenz und funktionelle Sauberkeit </h3><br>  Der Titel dieses Abschnitts mag ein wenig einschüchternd wirken, aber konzeptionell ist der Abschnitt einfach.  Eine idempotente Funktion mit denselben Argumenten gibt immer denselben Wert zurück, unabhängig davon, wie oft sie aufgerufen wird.  Das Ergebnis hängt nicht von nicht lokalen Variablen, der Variabilität von Argumenten oder von Daten ab, die aus Eingabe- / Ausgabestreams stammen.  Die folgende Funktion <code>add_three(number)</code> ist idempotent: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Unabhängig davon, wie oft wir <code>add_three(7)</code> aufrufen, <code>add_three(7)</code> die Antwort immer 10. Ein anderer Fall ist eine Funktion, die nicht idempotent ist: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" 3 + ,  ."""</span></span> number = int(input(<span class="hljs-string"><span class="hljs-string">'Enter a number: '</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Diese offen erfundene Funktion ist nicht idempotent, da der Rückgabewert der Funktion von der Eingabe / Ausgabe abhängt, nämlich von der vom Benutzer eingegebenen Nummer.  Bei unterschiedlichen Aufrufen von <code>add_three()</code> Rückgabewerte natürlich unterschiedlich.  Wenn wir diese Funktion zweimal aufrufen, kann der Benutzer im ersten Fall 3 und im zweiten - 7 <code>add_three()</code> , und dann <code>add_three()</code> zwei Aufrufe von <code>add_three()</code> 6 bzw. 10 zurück. <br><br>  Außerhalb der Programmierung gibt es auch Beispiele für Idempotenz - zum Beispiel ist der Aufwärtsknopf des Aufzugs nach diesem Prinzip ausgelegt.  Durch erstmaliges Drücken „benachrichtigen“ wir den Aufzug, dass wir hochfahren möchten.  Da die Taste idempotent ist, passiert nichts Schlimmes, egal wie oft Sie sie später drücken.  Das Ergebnis wird immer das gleiche sein. <br><br><h3>  Warum Idempotenz so wichtig ist </h3><br>  Testbarkeit und Usability-Unterstützung.  Idempotente Funktionen sind einfach zu testen, da sie in jedem Fall garantiert dasselbe Ergebnis liefern, wenn Sie sie mit denselben Argumenten aufrufen.  Beim Testen muss überprüft werden, ob die Funktion bei einer Vielzahl von Aufrufen immer den erwarteten Wert zurückgibt.  Darüber hinaus sind diese Tests schnell: Die Testgeschwindigkeit ist ein wichtiges Thema, das bei Unit-Tests häufig übersehen wird.  Und Refactoring bei der Arbeit mit idempotenten Funktionen ist im Allgemeinen ein einfacher Weg.  Es spielt keine Rolle, wie Sie den Code außerhalb der Funktion ändern - das Ergebnis des Aufrufs mit denselben Argumenten ist immer dasselbe. <br><br><h3>  Was ist eine "reine" Funktion? </h3><br>  In der funktionalen Programmierung gilt eine Funktion als rein, wenn sie <i>erstens</i> idempotent ist und <i>zweitens</i> die beobachteten <b>Nebenwirkungen</b> nicht verursacht.  Vergessen Sie nicht: Eine Funktion ist idempotent, wenn sie immer das gleiche Ergebnis mit einem bestimmten Satz von Argumenten zurückgibt.  Dies bedeutet jedoch nicht, dass die Funktion keine Auswirkungen auf andere Komponenten haben kann, z. B. nicht lokale Variablen oder Eingabe- / Ausgabestreams.  Wenn beispielsweise die idempotente Version der obigen Funktion <code>add_three(number)</code> das Ergebnis an die Konsole ausgibt und erst dann <code>add_three(number)</code> , wird es weiterhin als idempotent betrachtet, da diese Zugriffsoperation beim Zugriff auf den Eingabe- / Ausgabestream keinen Einfluss auf den zurückgegebenen Wert hat von der Funktion.  Der Aufruf von <code>print()</code> ist nur ein <i>Nebeneffekt</i> : Die Interaktion mit dem Rest des Programms oder Systems als solchem ​​erfolgt zusammen mit dem Rückgabewert. <br><br>  Lassen Sie uns unser Beispiel ein wenig mit <code>add_three(number)</code> .  Sie können den folgenden Code schreiben, um festzustellen, wie oft <code>add_three(number)</code> aufgerufen wurde: <br><br><pre> <code class="python hljs">add_three_calls = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> add_three_calls print(<span class="hljs-string"><span class="hljs-string">f'Returning </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{number + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">'</span></span>) add_three_calls += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""",     *add_three*."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_three_calls</code> </pre> <br>  Jetzt führen wir die Ausgabe an die Konsole aus (dies ist ein Nebeneffekt) und ändern die nicht lokale Variable (ein weiterer Nebeneffekt). Da jedoch keiner dieser Werte den von der Funktion zurückgegebenen Wert beeinflusst, ist er ohnehin idempotent. <br><br>  Reine Funktion hat keine Nebenwirkungen.  Es verwendet nicht nur keine "externen Daten" bei der Berechnung des Werts, sondern interagiert nicht mit dem Rest des Programms / Systems, sondern berechnet nur den angegebenen Wert und gibt ihn zurück.  Obwohl unsere neue Definition von <code>add_three(number)</code> idempotent bleibt, ist diese Funktion daher nicht mehr rein. <br><br>  In reinen Funktionen gibt es keine Protokollierungsanweisungen oder <code>print()</code> -Aufrufe.  Während der Arbeit greifen sie nicht auf die Datenbank zu und verwenden keine Internetverbindungen.  Greifen Sie nicht auf nicht lokale Variablen zu oder ändern Sie sie nicht.  <b>Und rufen Sie keine anderen nicht reinen Funktionen auf</b> . <br><br>  Kurz gesagt, sie haben keine „schreckliche Fernwirkung“, wie es die Worte von Einstein ausdrücken (aber im Kontext der Informatik, nicht der Physik).  Sie verändern den Rest des Programms oder Systems in keiner Weise.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">imperativen Programmierung</a> (was Sie tun, wenn Sie Code in Python schreiben) sind solche Funktionen am sichersten.  Sie sind bekannt für ihre Testbarkeit und einfache Unterstützung.  Da sie idempotent sind, ist das Testen solcher Funktionen garantiert so schnell wie das Ausführen.  Die Tests selbst sind ebenfalls einfach: Sie müssen keine Verbindung zur Datenbank herstellen oder externe Ressourcen simulieren, die Erstkonfiguration des Codes vorbereiten und am Ende der Arbeit nichts mehr bereinigen. <br><br>  Ehrlich gesagt sind Idempotenz und Sauberkeit sehr wünschenswert, aber nicht erforderlich.  ,         ,     ,     . , ,  ,    ,         .  ,        ,           . <br><br><h3>  Fazit </h3><br>  Das ist alles. ,     –   .          . ,   .    –    !          . ,  ,   ,       « ».     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426381/">https://habr.com/ru/post/de426381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426371/index.html">Audio Digest: 17 Materialien und praktische Anleitungen zum Thema professionelle Akustik</a></li>
<li><a href="../de426373/index.html">Funktionen in der Konsole erstellen. Teil 1</a></li>
<li><a href="../de426375/index.html">Technologieanalyse: Wo soll mit der Arbeit an der Patentlandschaft begonnen werden?</a></li>
<li><a href="../de426377/index.html">Spiel mit Mathe-Diagrammen anstelle von Diagrammen</a></li>
<li><a href="../de426379/index.html">Illusionen los</a></li>
<li><a href="../de426385/index.html">Warum sollten Sie kein akademisches Englisch lernen?</a></li>
<li><a href="../de426387/index.html">Grafik in Julia. Seltsame Muster, die Reflexion eines Dreiecks von einer geraden Linie und die Konstruktion der Normalen einer kugelförmigen Katze im Vakuum</a></li>
<li><a href="../de426389/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 334 (7.-14. Oktober 2018)</a></li>
<li><a href="../de426391/index.html">PHP Digest Nr. 141 (1. - 15. Oktober 2018)</a></li>
<li><a href="../de426395/index.html">Zum Zeitpunkt des Kaufs wird eine Gebühr für Waren aus ausländischen Online-Shops erhoben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>