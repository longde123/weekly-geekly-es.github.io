<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏲️ 🤱 😢 TDDx2, BDD, DDD, FDD, MDD, dan PDD, atau apa pun yang ingin Anda ketahui tentang Pengembangan Didorong 🥌 📌 🛫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Melihat melalui artikel tentang desain perangkat lunak, saya terus-menerus bertemu dengan awan singkatan yang belum pernah terjadi sebelumnya dan prak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDDx2, BDD, DDD, FDD, MDD, dan PDD, atau apa pun yang ingin Anda ketahui tentang Pengembangan Didorong</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459620/"><p>  Melihat melalui artikel tentang desain perangkat lunak, saya terus-menerus bertemu dengan awan singkatan yang belum pernah terjadi sebelumnya dan praktik pengembangan yang disebutkan dengan santai. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8v/ge/gp/8vgegpum3fifmxfni0u_ysms0to.jpeg"></div><br><ul><li>  <strong>TDD</strong> - well, semua orang tahu itu, pertama kita menulis tes, dan kemudian sisa kode. </li><li>  <strong>BDD</strong> adalah sesuatu yang akrab, semacam tes juga, tetapi tes khusus. </li><li>  <strong>TDD</strong> - Lagi?  Jadi, hentikan, ini bukan soal tes sama sekali.  Tetapi mengapa itu disebut sama? </li><li>  <strong>DDD</strong> - konteks terikat, bahasa di mana-mana, domain ... </li><li>  <strong>Fdd</strong> </li><li>  <strong>MDD</strong> - Serius, Berbasis Grafik? </li><li>  <strong>PDD</strong> - ... </li></ul><br><p>  Pendekatan pengembangan dibagi oleh kompleksitas, bidang aplikasi dan tujuan. <br>  Saya pikir waktunya telah tiba untuk mencari tahu mengapa mereka dibutuhkan, mengapa ada begitu banyak dari mereka, dan bagaimana mereka dapat berguna bagi kita. </p><br><p>  Kita akan mulai berkenalan dengan mereka dari yang paling sederhana sampai yang paling kompleks, pertimbangkan contoh penggunaan dan pro dan kontra dari masing-masing. </p><a name="habracut"></a><br><h1 id="tdd---test-driven-development">  TDD - Pengembangan Berbasis Tes </h1><br><p>  <strong>TDD</strong> adalah metodologi pengembangan perangkat lunak yang didasarkan pada siklus pengembangan singkat yang berulang: awalnya tes ditulis yang mencakup perubahan yang diinginkan, kemudian kode program ditulis yang mengimplementasikan perilaku sistem yang diinginkan dan memungkinkan Anda lulus tes tertulis.  Kemudian kode tertulis di refactored dengan pengujian pengujian yang konstan. </p><br><p>  Kedengarannya sederhana dan jelas.  Banyak yang akrab dengan pendekatan pengembangan ini, dan bahkan Paman Bob sendiri secara aktif mempromosikannya. </p><br><blockquote>  TDD dianggap sebagai bentuk konstruksi aplikasi yang tepat.  Filosofi pengembangan yang digerakkan oleh tes adalah bahwa tes Anda adalah spesifikasi tentang bagaimana program Anda harus bersikap.  Jika Anda menganggap suite tes Anda sebagai bagian wajib dari proses build, jika tes Anda gagal, program tidak membangun karena itu salah.  Tentu saja, batasannya adalah bahwa kebenaran program Anda hanya didefinisikan sebagai kelengkapan tes Anda.  Namun, penelitian telah menunjukkan bahwa pengembangan berdasarkan pengujian dapat mengurangi kesalahan hingga 40-80% dalam produksi. </blockquote><p>  Ketika Anda mulai menggunakan TDD, Anda mungkin merasa berjalan lebih lambat dari biasanya.  Ini karena Anda akan bekerja di luar "zona nyaman", dan ini cukup normal. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/uc/s_/t5ucs_g6howdrtrlnmarn6zv1ag.png"></div><br><p>  Setelah Anda merasa bahwa tes menulis telah menjadi bagian yang sederhana dan alami dari alur kerja, bahwa Anda tidak perlu lagi berpikir tentang menggunakan TDD saat mengerjakan proyek, Anda menyadari bahwa TDD telah mengalir ke dalam pekerjaan Anda. </p><br><p>  Metodologi ini memungkinkan kita untuk mencapai pembuatan aplikasi yang cocok untuk pengujian otomatis dan cakupan kode yang sangat baik dengan tes, karena TK diterjemahkan ke dalam bahasa tes otomatis, yaitu, segala sesuatu yang harus dilakukan program diperiksa.  TDD juga sering menyederhanakan implementasi perangkat lunak: redundansi implementasi dihilangkan - jika suatu komponen lulus tes, maka itu dianggap siap. </p><br><p>  Arsitektur produk perangkat lunak yang dikembangkan dengan cara ini biasanya lebih baik (dalam aplikasi yang cocok untuk pengujian otomatis, tanggung jawab antara komponen biasanya didistribusikan dengan sangat baik, dan prosedur kompleks yang dilakukan didekomposisi menjadi banyak yang sederhana).  Stabilitas aplikasi yang dikembangkan melalui pengujian lebih tinggi karena fakta bahwa semua fungsi dasar program dicakup oleh tes dan kinerjanya terus diperiksa.  Menyertai proyek-proyek di mana semuanya atau hampir semuanya diuji sangat tinggi - pengembang mungkin tidak takut untuk membuat perubahan pada kode, jika terjadi kesalahan, hasil pengujian otomatis akan menginformasikan tentang hal ini. </p><br><p>  Anda dapat mempelajari lebih lanjut tentang prinsip-prinsip TDD dengan membaca buku Kent Beck, Extreme Programming, Development through Testing. </p><br><h2 id="tdd---type-driven-development">  TDD - Pengembangan Berbasis Tipe </h2><br><p>  Tipe Driven Development disingkat juga pengembangan melalui pengujian, jadi biasanya nama lengkap ditulis. </p><br><p>  Ketika mengembangkan berdasarkan tipe, tipe data dan tipe tanda tangan Anda adalah spesifikasi program.  Jenis juga berfungsi sebagai bentuk dokumentasi yang dijamin akan diperbarui. </p><br><p>  Jenisnya adalah titik kontrol kecil, karena itu, kami mendapatkan banyak tes mini di seluruh aplikasi kami.  Selain itu, biaya pembuatan jenis minimal dan memperbarui mereka tidak diperlukan, karena mereka adalah bagian dari basis kode. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/7h/y5/ue7hy5tcox8zmj5hngev707m994.jpeg"></div><br><p>  Pengembangan menurut jenis adalah metode lain yang baik untuk membangun aplikasi.  Seperti pengembangan berbasis tes, pengembangan berbasis tipe dapat meningkatkan kepercayaan Anda pada kode Anda dan menghemat waktu Anda saat membuat perubahan pada basis kode besar. </p><br><p>  Dari minusnya, hanya meningkatnya kompleksitas bahasa dengan pengetikan dinamis.  Misalnya, untuk JavaScript pendekatan ini lebih sulit diterapkan daripada untuk TypeScript. </p><br><p>  Pada habr ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus tentang mengetik. </p><br><h2 id="bdd---behaviour-driven-development">  BDD - Pengembangan Berbasis Perilaku </h2><br><p>  Karena beberapa kesamaan metodologis, TDD (Test Driven Development) dan BDD (Behavior Driven Development) sering bingung bahkan oleh para profesional.  Apa bedanya?  Konsep kedua pendekatan itu serupa, tes pertama dilakukan dan baru kemudian pengembangan dimulai, tetapi tujuannya sama sekali berbeda.  TDD lebih lanjut tentang pemrograman dan pengujian pada tingkat implementasi teknis produk, ketika pengujian dibuat oleh pengembang sendiri.  <strong>BDD melibatkan penguji atau analis yang menggambarkan skrip yang ditentukan pengguna dalam bahasa alami</strong> - jika boleh saya katakan demikian, dalam bahasa bisnis. </p><br><blockquote>  BDD - pengembangan berbasis perilaku adalah pengembangan berbasis perilaku.  Orang tertentu (atau orang) menulis deskripsi formulir "sebagai pengguna yang saya inginkan ketika tombol mulai ditekan maka menu ditampilkan seperti pada gambar" (ada kata kunci yang disorot khusus).  Programmer telah lama menulis alat khusus yang menerjemahkan deskripsi seperti itu ke dalam tes (kadang-kadang benar-benar transparan bagi programmer).  Dan kemudian pengembangan klasik dengan tes. </blockquote><p>  Jika Anda mencatat nama-nama tes dalam bentuk kalimat dan menggunakan kosakata domain bisnis untuk menulis nama metode, dokumentasi yang dibuat menjadi jelas bagi pelanggan, analis, dan penguji. </p><br><p>  Teks skrip ditulis dalam bentuk tertentu. </p><br><blockquote>  Memiliki (kurang lebih Diberikan - diberikan) beberapa konteks, <br><br>  Ketika (catat kapan) suatu peristiwa terjadi, <br><br>  Kemudian (kurang-lebih Lalu) periksa hasilnya. </blockquote><p>  Sesuatu seperti ini mungkin terjadi: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/dq/zd/padqzdoeivthlm1ii0qe65htcoe.png"></div><br><p>  Atau contoh lain dalam bahasa Rusia: </p><br><blockquote>  Skenario 1: Ada uang di akun + <br><br>  <strong>Memiliki</strong> akun dengan uang <br><br>  <strong>Dan</strong> kartu yang valid <br><br>  <strong>Dan</strong> ATM dengan uang tunai <br><br>  <strong>Ketika seorang</strong> pelanggan meminta uang tunai <br><br>  <strong>Kemudian</strong> pastikan akun itu didebit <br><br>  <strong>Dan</strong> pastikan uang tunai dikeluarkan <br><br>  <strong>Dan</strong> pastikan kartunya dikembalikan </blockquote><p>  Pendekatan BDD, bersama dengan praktik-praktik rekayasa, memungkinkan kami untuk meninggalkan dokumentasi lama yang berisi informasi yang tidak relevan, dan menerima dokumentasi baru dengan cepat, menyimpannya dengan proyek, yang membawa analis dan penguji lebih dekat ke kode. </p><br><p>  BDD lebih merupakan proses yang tujuannya adalah untuk mengurangi biaya penerapan fitur baru.  Bahkan pada awal pengembangan, kami mendapatkan artefak penting.  Misalnya, dokumentasi yang dapat dimengerti untuk didukung.  Dokumentasi ini memberikan peluang bagi semua pihak yang berkepentingan untuk membentuk pemahaman mereka tentang skenario perilaku produk dan pengguna yang harus diimplementasikan selama iterasi pengembangan.  Dengan pendekatan BDD, kami juga menurunkan ambang batas bagi anggota baru untuk memasuki proyek. </p><br><h3 id="v-chem-preimuschestvo-bdd">  Apa keuntungan BDD? </h3><br><ul><li>  Tes yang dapat dibaca untuk non-programmer. </li><li>  Mereka mudah diubah.  Mereka sering ditulis dalam bahasa Inggris yang hampir murni. </li><li>  Mereka dapat ditulis oleh pemilik produk atau pihak lain yang berkepentingan. </li><li>  Hasil tes lebih manusiawi. </li><li>  Tes tidak tergantung pada bahasa pemrograman target.  Migrasi ke bahasa lain sangat disederhanakan. </li></ul><br><h3 id="minusy">  Cons: </h3><br><p>  Tetapi pendekatan ini memiliki kelemahan - pendekatan ini panjang dan mahal.  BDD tidak nyaman bahkan jika memerlukan keterlibatan spesialis pengujian yang sudah pada tahap pengembangan persyaratan, dan ini memperpanjang siklus pengembangan. </p><br><p>  Jalan keluar dari situasi ini mungkin adalah pilihan kerangka BDD yang cocok dan proses pembangunan yang dibangun dengan benar. </p><br><p>  Baca lebih lanjut tentang BDD di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Banyak yang sudah lama memahami bahwa pengujian adalah semacam obat mujarab untuk semua penyakit, tetapi apakah benar demikian?  Tentu saja, kode yang diuji secara menyeluruh berfungsi lebih stabil dan dapat diprediksi, tetapi pengujian tidak menyelamatkan kita dari masalah dan kesalahan pada tahap desain dan pengaturan tugas.  Pendekatan pengembangan berikut dapat membantu Anda dalam hal ini. </p><br><h2 id="ddd---domain-driven-design">  DDD - Desain Berbasis Domain </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/yv/qy/r2yvqyh9gninztlb6_k0paa6pjm.png"></div><br><p>  Desain yang berorientasi pada subjek bukanlah teknologi atau metodologi tertentu.  DDD adalah seperangkat aturan yang memungkinkan Anda untuk membuat keputusan desain yang tepat.  Pendekatan ini secara signifikan dapat mempercepat proses mendesain perangkat lunak dalam domain yang tidak dikenal. </p><br><blockquote>  <strong>Desain berorientasi subjek</strong> (lebih jarang berorientasi pada masalah, Bahasa Inggris. Desain berbasis domain, DDD) adalah seperangkat prinsip dan skema yang bertujuan untuk menciptakan sistem objek yang optimal.  Proses pengembangan bermuara pada pembuatan abstraksi perangkat lunak, yang disebut model domain.  Model-model ini termasuk logika bisnis yang membangun hubungan antara kondisi aktual area aplikasi produk dan kode. </blockquote><p>  Pendekatan DDD sangat berguna dalam situasi di mana pengembang bukan spesialis di bidang produk yang dikembangkan.  Sebagai contoh: seorang programmer tidak dapat mengetahui semua bidang di mana diperlukan untuk membuat perangkat lunak, tetapi dengan bantuan representasi struktur yang benar, melalui pendekatan berorientasi subjek, ia dapat dengan mudah merancang aplikasi berdasarkan poin-poin utama dan pengetahuan ruang kerja. </p><br><p>  Dalam artikel ini saya mencoba menyampaikan esensi dari setiap pendekatan untuk pengembangan perangkat lunak, tetapi tentang DDD Anda dapat menulis lebih dari satu artikel dan membahas semua nuansa dalam beberapa paragraf, itu tidak akan berhasil bagi saya.  Karena itu, ketika menjelaskan, saya akan memberikan tautan jelas ke sumber yang paling layak. </p><br><p>  Tujuan utama Desain Berbasis Domain adalah untuk memerangi kompleksitas proses bisnis, otomasi dan penerapannya dalam kode.  "Domain" diterjemahkan sebagai "domain", dan pengembangan dan desain dalam kerangka pendekatan ini didorong menjauh dari domain. </p><br><p>  Konsep kunci dalam DDD adalah bahasa di mana-mana.  Bahasa di mana-mana mempromosikan komunikasi yang transparan antara peserta proyek.  Dia bukan satu dalam arti bahwa dia adalah satu untuk semua kesempatan.  Justru sebaliknya.  Semua peserta berkomunikasi di dalamnya, semua diskusi berlangsung dalam satu bahasa, dan semua artefak harus disajikan dalam satu bahasa, yaitu mulai dari TK, dan diakhiri dengan kode. </p><br><p>  Konsep selanjutnya adalah "model domain".  Model ini adalah daftar istilah dari bahasa di mana-mana.  Baik model domain dan bahasa di mana-mana dibatasi oleh konteks yang oleh Desain Domain-Driven disebut konteks terbatas.  Dia membatasi model domain sedemikian rupa sehingga semua konsep di dalamnya tidak ambigu, dan semua orang mengerti apa yang dipertaruhkan. </p><br><p>  Contoh: ambil entitas "orang" dan letakkan dalam konteks "berbicara di depan umum".  Dalam konteks ini, menurut DDD, ia menjadi pembicara atau pembicara.  Dan dalam konteks "keluarga" - suami atau saudara. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fr/ol/pb/frolpb6kxzrufs8nxfspbnjbhnm.jpeg"></div><br><p>  Sekarang tentang kodenya.  Penting bahwa kode Anda dibaca seperti buku, bahwa kode itu sederhana dan dapat dimengerti oleh semua orang yang berbicara dalam bahasa umum proyek.  Apa yang saya maksud </p><br><p>  Jika dalam bahasa proyek Anda menggunakan ungkapan "produk telah ditambahkan", maka opsi berikut ini bukan DDD: </p><br><blockquote>  var product = Produk baru ('apel') <br><br>  product.save () </blockquote><p>  Mengapa  Kode mengatakan bahwa kami menciptakan produk dengan cara yang aneh dan menyimpannya.  Bagaimana cara menambahkan produk?  Perlu <strong>menambahkannya</strong> .  Ini adalah kode DDD: </p><br><blockquote>  Product :: add ('apple'); </blockquote><br><h3 id="arhitektura">  Arsitektur: </h3><br><p>  Dari sudut pandang Desain Berbasis Domain, tidak terlalu masalah arsitektur apa yang Anda pilih.  Desain Berbasis Domain bukan tentang itu; Desain Berbasis Domain adalah tentang bahasa dan komunikasi. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/u1/xk/yru1xky15pmztnac5w504au08rk.png"></div><br><p>  Tetapi DDD hampir tidak mungkin tanpa arsitektur proyek yang bersih, karena ketika menambahkan fungsionalitas baru atau mengubah yang lama, Anda perlu mencoba mempertahankan fleksibilitas dan transparansi basis kode.  Anda dapat membaca tentang port, adaptor, dan arsitektur bawang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> bagus.  Gambar di atas hanya dari itu. </p><br><p>  Ada juga artikel tentang DDD yang saya sangat sarankan baca dengan seksama - di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h3 id="chto-zhe-nam-eto-daet-v-itoge">  Apa yang ini memberi kita pada akhirnya: </h3><br><ul><li>  hampir semua anggota tim dapat membaca kode proyek; </li><li>  pernyataan tugas menjadi lebih eksplisit; </li><li>  bug dalam logika bisnis menjadi lebih mudah dicari; </li><li>  Jauh lebih mudah bagi spesialis QA untuk memindai kode dan menemukan kesalahan logis dan bug. </li></ul><br><h3 id="minusy-1">  Cons: </h3><br><ul><li>  Diperlukan pengembang yang berkualitas tinggi, terutama pada awal proyek; </li><li>  tidak semua pelanggan bersedia membuat biaya seperti itu, DDD perlu dipelajari oleh semua peserta dalam proses pengembangan. </li></ul><br><h2 id="fdd---features-driven-development">  FDD - Pengembangan Fitur Didorong </h2><br><p>  FDD - Metodologi ini (secara singkat disebut sebagai FDD) dikembangkan oleh Jeff De Luca dan guru yang diakui di bidang teknologi berorientasi objek, Peter Coad.  FDD adalah upaya untuk menggabungkan teknik yang paling dikenal dalam industri pengembangan perangkat lunak yang mengambil sebagai dasar fungsi penting (properti) dari perangkat lunak yang dikembangkan untuk pelanggan.  Tujuan utama metodologi ini adalah untuk mengembangkan perangkat lunak yang nyata dan berfungsi secara sistematis tepat waktu. </p><br><p>  Seperti metodologi adaptif lainnya, ini berfokus pada iterasi pendek, yang masing-masing berfungsi untuk mengerjakan bagian tertentu dari fungsionalitas sistem.  Menurut FDD, satu iterasi berlangsung dua minggu.  FDD memiliki lima proses.  Tiga yang pertama dari mereka berhubungan dengan dimulainya proyek: </p><br><ul><li>  pengembangan model umum; </li><li>  menyusun daftar properti sistem yang diperlukan; </li><li>  merencanakan pekerjaan di setiap properti; </li><li>  desain setiap properti; </li><li>  pembangunan setiap properti. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/pn/-7/ybpn-73k8zvpmk-qudlqwxg9-oa.jpeg"></div><br><p>  Dua langkah terakhir harus dilakukan selama setiap iterasi.  Selain itu, setiap proses dibagi menjadi tugas dan memiliki kriteria verifikasi. </p><br><p>  Mari kita bahas setiap item dengan lebih detail. </p><br><p>  <strong>Pengembangan model umum.</strong> </p><br><p>  Pengembangan dimulai dengan analisis luasnya jangkauan tugas yang ada dan konteks sistem.  Selanjutnya, untuk setiap area yang disimulasikan, analisis yang lebih rinci dibuat.  Deskripsi awal dikompilasi dalam kelompok-kelompok kecil dan diserahkan untuk diskusi lebih lanjut dan evaluasi ahli.  Setelah salah satu model yang diusulkan atau kombinasinya menjadi model untuk area tertentu.  Model masing-masing area tugas digabungkan menjadi model akhir yang umum, yang dapat berubah selama pekerjaan. </p><br><p>  <strong>Daftar Fitur</strong> </p><br><p>  Informasi yang dikumpulkan selama pembangunan model umum digunakan untuk menyusun daftar fungsi.  Fungsi digabungkan menjadi apa yang disebut "domain" (domain bahasa Inggris), dan mereka, pada gilirannya, dibagi menjadi sub-wilayah (area subjek bahasa Inggris) sesuai dengan atribut fungsional. </p><br><p>  Setiap subdomain berhubungan dengan proses bisnis tertentu, dan langkah-langkahnya menjadi daftar fungsi (properti).  Fungsi disajikan dalam bentuk "action - result - object", misalnya, "periksa kata sandi pengguna".  Pengembangan setiap fungsi harus tidak lebih dari 2 minggu, jika tidak tugas tersebut harus diuraikan menjadi iterasi yang lebih kecil.  Daftar properti di FDD sama dengan simpanan produk di SCRUM. </p><br><p>  <strong>Properti (Fungsi) Rencana</strong> </p><br><p>  Tahap berikutnya adalah distribusi fungsi di antara programmer atau tim terkemuka. </p><br><p>  <strong>Desain Fitur</strong> </p><br><p>  Paket desain dibuat untuk setiap properti.  Programmer pemimpin menguraikan sekelompok kecil properti untuk pengembangan dalam waktu dua minggu.  Setelah itu, diagram urutan terperinci untuk setiap properti dibiarkan, menentukan model umum.  Selanjutnya tertulis "rintisan" kelas dan metode.  Pada titik ini, kita harus fokus pada desain produk perangkat lunak. </p><br><p>  <strong>Implementasi fungsi</strong> </p><br><p>  Kami menulis kode, menghapus bertopik, menguji. </p><br><p>  Setelah properti telah diuji dan dimasukkan ke dalam produk, kami mengambil properti prioritas berikutnya, mengulangi siklus desain / implementasi. </p><br><p>  Total, sebagai hasilnya, kita mendapatkan: </p><br><ul><li>  dokumentasi properti sistem; </li><li>  desain yang cermat; </li><li>  lebih mudah untuk mengevaluasi tugas-tugas kecil; </li><li>  tes difokuskan pada tugas bisnis; </li><li>  proses pembuatan produk yang canggih; </li><li>  Siklus pengembangan berulang pendek memungkinkan Anda untuk dengan cepat meningkatkan fungsionalitas dan mengurangi kesalahan. </li></ul><br><p>  Cons: </p><br><ul><li>  FDD lebih cocok untuk proyek besar.  Tim pengembangan kecil tidak akan dapat merasakan semua manfaat dari pendekatan ini; </li><li>  biaya implementasi dan pelatihan yang signifikan. </li></ul><br><h2 id="mdd---model-driven-development">  MDD - Pengembangan Berbasis Model </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/wi/ys/-dwiysxakx7fo4tlanhlqkb4f0e.png"></div><br><p>  Baru-baru ini, banyak perhatian telah diberikan dalam publikasi untuk topik arsitektur dan pengembangan berdasarkan model MDA (Model Driven Architecture) dan MDD (Model Driven Development).  Tanpa merinci, kami hanya menyoroti poin-poin penting. </p><br><blockquote>  Pengembangan model-driven adalah gaya pengembangan perangkat lunak di mana model menjadi artefak pengembangan utama dari mana kode dan artefak lainnya dihasilkan. </blockquote><p>   ,         ,        . </p><br><p>   MDD —  ,          .   -              . </p><br><p>       .            .      ,     ,       .  MDD   —     ,        ,      . </p><br><p>      «»,            .                (    ). </p><br><p>  MDD   ‑       .          ,      ,  .      MDD-,      .        Unified Modeling Language – UML 2.0. </p><br><p>   Object Management Group (OMG)      : </p><br><ul><li> c      ,     ; </li><li>       - ; </li><li> ,         . </li></ul><br><p>    MDD,    , —   .                  . </p><br><p> <strong>   :</strong> </p><br><ul><li>      (Minimum Viable Product)  ; </li><li>   :   ,  ,  ; </li><li>   ; </li><li>       . </li></ul><br><p> <strong>:</strong> </p><br><ul><li>   MMD     ,   Rational Software Architect, Simulink  Sirius; </li><li>       ; </li><li>       . </li></ul><br><h2 id="pdd---panic-driven-development"> PDD — Panic Driven Development </h2><br><p>     agile ,      PDD.    ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k8/cd/li/k8cdliqmqwpouf0q_jdktotmyqu.jpeg"></div><br><h3 id="novye-zadachi-prioritetnee-staryh">    . </h3><br><p>  ,       ,       .        . ,         ?       ,           . </p><br><h3 id="pishite-stolko-koda-skolko-nuzhno-chtoby-reshit-problemu">   ,  ,   . </h3><br><p>     .      .    UX    .        ?   ,      .   ,  . </p><br><h3 id="testy-dolzhny-pisatsya-v-konce">     . </h3><br><p>  ,   ,      ,     .  ,    .      .     ,     . </p><br><h3 id="dovertes-svoemu-instinktu">   . </h3><br><p>  —  .     .   .  .  .    . </p><br><h3 id="process-gibok">  . </h3><br><p>  ,   ,     , —      ,     .     . ,    ,     ,    . </p><br><h3 id="eto-process-upravlyaemyy-menedzherom">  ,  . </h3><br><p>    ,         .           .     ,         ,   . </p><br><h3 id="plyusy-podhoda">  : </h3><br><ul><li>   ; </li><li> ; </li><li>  ,  -   . </li></ul><br><h3 id="minusy-2"> : </h3><br><ul><li> <strong>        </strong> . </li></ul><br><p> PDD   , ,  ,      . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  agile  .       ,      ,      . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya harap banyak dari Anda telah mempelajari sesuatu yang baru tentang praktik Pembangunan Berbasiskan, dan sekarang, bertemu langsung dengan singkatan DDD, BDD, MDD, Anda tidak akan mengalami kebingungan, atau Anda mungkin ingin mencobanya dalam praktik. </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459620/">https://habr.com/ru/post/id459620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459610/index.html">Router berbahaya ini: peretasan paling besar dari peralatan jaringan baru-baru ini dan metode perlindungan</a></li>
<li><a href="../id459612/index.html">Bagaimana Qualcomm merobek industri ponsel selama hampir 20 tahun berturut-turut</a></li>
<li><a href="../id459614/index.html">Bebek robot mengaduk sawah</a></li>
<li><a href="../id459616/index.html">MIPT membuka program master lanjutan pertama Rusia dalam Ilmu Komputer dan Rekayasa Perangkat Lunak</a></li>
<li><a href="../id459618/index.html">Beberapa fitur komposisi buruh pelabuhan yang kurang dikenal</a></li>
<li><a href="../id459622/index.html">Karena game untuk Sega Saturn ditulis pada tahun 1995</a></li>
<li><a href="../id459624/index.html">Drone militer</a></li>
<li><a href="../id459626/index.html">Windows Notification Facility: permukaan serangan paling tidak berdokumen</a></li>
<li><a href="../id459628/index.html">Open Invention Network memiliki lebih dari tiga ribu pemegang lisensi - apa artinya untuk perangkat lunak open source</a></li>
<li><a href="../id459630/index.html">Tic Tac Toe Bagian 2: Stateless Undo / Redo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>