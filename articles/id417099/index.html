<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüë¶ üòª üßòüèø Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 2 üéÆ ü§ë üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ringkasan bagian sebelumnya 
 Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Ya - ya, dengan moto ini saya bergegas ke medan pertempuran." width="300" height="350" align="left"><h3>  Ringkasan bagian sebelumnya </h3><br>  Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menulis implementasi sendiri dari pustaka C ++ 11 standar di atas pustaka C ++ 98 / C ++ 03 yang disertakan dengan kompiler. <br><br>  Selain file header standar <b>type_traits</b> , <b>utas</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h</b> ditambahkan <b>yang</b> mengimplementasikan <i>std :: nullptr_t</i> dan <b>core.h di</b> mana makro yang terkait dengan <b>fungsionalitas yang bergantung pada</b> kompiler ditambahkan, serta memperluas pustaka standar. <br><br>  Tautan ke GitHub dengan hasil untuk hari ini untuk yang tidak sabar dan yang bukan pembaca: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komitmen dan kritik yang membangun dipersilahkan</a></b> </blockquote><a name="habracut"></a><br><h4>  Daftar isi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 1. Viam supervadet vadens</a> <br>  <b>Bab 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 3. Menemukan implementasi nullptr yang sempurna</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1 Kita mulai dari yang kecil</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2 Tentang berapa banyak kesalahan ajaib yang dikompilasi oleh log untuk kita</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3 Pointer dan semuanya</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.4 Apa lagi yang diperlukan untuk pustaka templat</a> <br>  Bab 5 <br>  ... <br><br><h3>  Bab 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Setelah semua kode disisir sedikit dan dibagi dengan header "standar" menjadi <b>stdex namespace yang</b> terpisah <b>,</b> saya melanjutkan untuk mengisi <b>type_traits</b> , <b>nullptr.h</b> dan sepanjang <b>core.h yang</b> sama, yang berisi makro untuk menentukan versi standar yang digunakan oleh kompiler dan mendukungnya <b>Nullptr</b> <b>asli</b> , <b>char16_t</b> , <b>char32_t</b> dan <b>static_assert</b> . <br><br>  Secara teori, semuanya sederhana - menurut standar C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(klausa 14.8),</a> makro <b>__cplusplus</b> harus ditentukan oleh kompiler dan sesuai dengan versi standar yang didukung: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  oleh karena itu, kode untuk menentukan ketersediaan dukungan adalah sepele: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="gambar" width="300" height="250" align="left">  Bahkan, tidak semuanya begitu sederhana dan sekarang kruk yang menarik dengan menyapu dimulai. <br><br>  Pertama, tidak semua, atau lebih tepatnya tidak ada, dari penyusun tidak menerapkan standar berikutnya sepenuhnya dan segera.  Misalnya, dalam Visual Studio 2013 <b>constexpr tidak</b> ada <b>untuk waktu yang</b> sangat lama, sementara itu diklaim mendukung C ++ 11 - dengan peringatan bahwa implementasinya tidak lengkap.  Yaitu, <b>otomatis</b> - tolong, <b>static_assert</b> - sama mudahnya (bahkan dari MS VS sebelumnya), tetapi <b>constexpr</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> .  Kedua, tidak semua kompiler (dan ini bahkan lebih mengejutkan) dengan benar mengekspos definisi ini dan memperbaruinya tepat waktu.  Tiba-tiba, dalam kompiler yang sama, Visual Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mengubah versi</a> <b>definisi</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">__cplusplus</a> dari versi pertama kompiler, meskipun dukungan penuh untuk C ++ 11 telah lama diumumkan (yang juga tidak benar, yang mana ada sinar ketidakpuasan yang terpisah - segera setelah percakapan tiba pada fungsi spesifik dari "baru" "11 pengembang standar segera mengatakan bahwa tidak ada preprosesor C99, tidak ada" fitur "lainnya.  Dan situasinya diperburuk oleh fakta bahwa oleh penyusun standar diizinkan untuk menetapkan definisi ini berbeda dari nilai-nilai di atas, jika mereka tidak sepenuhnya memenuhi standar yang dinyatakan.  Akan logis untuk mengasumsikan, misalnya, pengembangan definisi untuk makro yang diberikan (dengan pengenalan fungsi baru, menambah angka yang tersembunyi di balik definisi ini): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Tetapi pada saat yang sama, tidak ada kompiler populer utama yang "usang" dengan fitur ini. <br><br>  Karena semua ini (saya tidak takut dengan kata ini), sekarang untuk setiap kompiler non-standar Anda harus menulis cek khusus Anda sendiri untuk mengetahui standar C ++ dan sejauh mana mendukungnya.  Berita baiknya adalah kita perlu mempelajari beberapa fungsi kompiler agar berfungsi dengan benar.  Pertama, kita sekarang menambahkan versi memeriksa Visual Studio melalui makro <b>_MSC_VER</b> , unik untuk kompiler ini.  Karena di gudang kompiler yang didukung saya ada juga C ++ Borland Builder 6.0, yang pengembangnya, pada gilirannya, sangat tertarik untuk menjaga kompatibilitas dengan Visual Studio (termasuk "fitur" dan bug), maka tiba-tiba ada makro ini juga.  Untuk kompiler yang kompatibel dengan dentang, ada <b>__has_feature</b> makro non-standar <b>(</b> fitur_name <b>)</b> , yang memungkinkan Anda untuk mengetahui apakah kompiler mendukung fungsi ini atau itu.  Akibatnya, kode ini meningkat ke: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Ingin menjangkau lebih banyak kompiler?  Kami menambahkan cek untuk Codegear C ++ Builder, yang merupakan pewaris Borland (dalam manifestasi terburuknya, tetapi lebih lanjut tentang itu nanti): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Perlu juga dicatat bahwa karena Visual Studio telah mengimplementasikan dukungan <b>nullptr</b> dari versi kompiler <b>_MSC_VER 1600</b> , serta tipe <b>bawaan char16_t</b> dan <b>char32_t</b> , kita perlu menangani ini dengan benar.  Beberapa cek lagi ditambahkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Pada saat yang sama, kami akan memeriksa dukungan C ++ 98, karena untuk kompiler tanpa itu tidak akan ada beberapa file header dari perpustakaan standar, dan kami tidak dapat memverifikasi tidak adanya mereka menggunakan kompiler. <br><br><div class="spoiler">  <b class="spoiler_title">Opsi lengkap</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Dan sekarang konfigurasi yang beraneka ragam dari boost mulai muncul dalam ingatan saya di mana banyak pengembang pekerja keras menulis semua makro yang bergantung pada kompiler ini dan membuat peta tentang apa yang didukung dan apa yang bukan oleh kompiler spesifik dari versi tertentu, dari mana saya pribadi merasa tidak nyaman, Saya ingin tidak pernah melihatnya atau menyentuhnya lagi.  Tetapi kabar baiknya adalah Anda bisa berhenti di situ.  Setidaknya ini cukup bagi saya untuk mendukung kompiler paling populer, tetapi jika Anda menemukan ketidaktepatan atau ingin menambahkan kompiler lain, saya akan dengan senang hati menerima permintaan tarik. <br><br>  Sebuah pencapaian hebat dibandingkan dengan peningkatan, saya percaya bahwa memungkinkan untuk menjaga penyebaran makro yang bergantung pada kompiler dalam kode, yang membuat kode lebih bersih dan lebih mudah untuk dipahami, dan juga tidak menumpuk puluhan file konfigurasi untuk setiap OS dan untuk setiap kompiler.  Kami akan berbicara tentang kelemahan dari pendekatan ini sedikit kemudian. <br><br>  Pada tahap ini, kita sudah dapat mulai menghubungkan fungsionalitas yang hilang dari 11 standar, dan hal pertama yang kami perkenalkan adalah <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  Kami mendefinisikan struktur <i>StaticAssertion</i> , yang akan mengambil nilai Boolean sebagai parameter templat - akan ada kondisi kami, jika tidak terpenuhi (ekspresi <b>salah</b> ), kesalahan akan terjadi dalam kompilasi templat yang tidak ditentukan.  Dan struktur boneka lain untuk menerima <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  dan sihir makro lebih lanjut <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  penggunaan: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Perbedaan penting antara implementasi saya dan <a href="">standar</a> adalah bahwa tidak ada kata kunci yang berlebihan <u>tanpa</u> memberi tahu pengguna.  Hal ini disebabkan oleh fakta bahwa dalam C ++ tidak mungkin untuk mendefinisikan beberapa definisi dengan jumlah argumen yang berbeda tetapi satu nama, dan implementasi tanpa pesan jauh lebih tidak berguna daripada opsi yang dipilih.  Fitur ini mengarah pada fakta bahwa pada dasarnya <b>STATIC_ASSERT</b> dalam implementasi saya adalah versi yang sudah ditambahkan di C ++ 11. </blockquote>  Mari kita lihat apa yang terjadi.  Sebagai hasil dari memeriksa versi <b>__cplusplus</b> dan makro kompiler non-standar, kami memiliki informasi yang cukup tentang dukungan C ++ 11 (dan karenanya <b>static_assert</b> ), diungkapkan oleh <b>definisi</b> _STDEX_NATIVE_CPP11_SUPPORT.  Oleh karena itu, jika makro ini didefinisikan, kita cukup menggunakan <b>static_assert</b> standar: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Harap perhatikan bahwa parameter kedua makro <b>STATIC_ASSERT</b> sama sekali bukan <b>string literal,</b> dan karenanya menggunakan operator preprocessor <b>#</b> kami akan mengonversi parameter <i>pesan</i> menjadi string untuk transmisi ke <b>static_assert</b> standar. </blockquote>  Jika kami tidak memiliki dukungan dari kompiler, maka kami melanjutkan ke implementasi kami.  Untuk memulainya, kami akan mendeklarasikan macro tambahan untuk string "gluing" (operator preprocessor <b>##</b> hanya bertanggung jawab untuk ini). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  Saya secara khusus tidak menggunakan secara sederhana <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> agar dapat meneruskan hasil dari makro <b>CONCATENATE yang</b> sama sebagai argumen ke <i>arg1</i> dan <i>arg2</i> . </blockquote>  Selanjutnya, kami mendeklarasikan struktur dengan nama cantik __static_assertion_at_line_ {nomor baris} (makro <b>__LINE__</b> juga ditentukan oleh standar dan harus diperluas ke nomor baris yang dipanggil), dan di dalam struktur ini kami menambahkan bidang jenis <i>StaticAssertion kami</i> dengan nama STATIC_ASSERTION_FAILED_AT_LINE _ {_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ pesan kesalahan dari makro panggilan}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Dengan</i> parameter templat di <i>StaticAssertion,</i> kami meneruskan ekspresi yang dicentang di <b>STATIC_ASSERT</b> , yang mengarahkannya ke <b>bool</b> .  Akhirnya, untuk menghindari membuat variabel lokal dan nol-overhead memeriksa kondisi pengguna, alias dideklarasikan untuk tipe <i>StaticAssertionTest &lt;sizeof ({nama struktur yang dinyatakan di atas})</i> dengan nama __static_assertion_test_at_line_ {nomor baris}. <br><br>  Semua keindahan dengan penamaan diperlukan hanya untuk membuatnya jelas dari kesalahan kompilasi bahwa ini adalah hasil yang tegas, dan bukan hanya kesalahan, tetapi juga untuk menampilkan pesan kesalahan yang ditetapkan untuk pernyataan ini.  Trik <b>sizeof</b> diperlukan untuk memaksa kompiler untuk membuat <i>instance</i> kelas template <i>StaticAssertion</i> , yang ada di dalam struktur yang baru saja dinyatakan, dan dengan demikian memeriksa kondisi yang dilewati untuk menegaskan. <br><br><div class="spoiler">  <b class="spoiler_title">STATIC_ASSERT hasil</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: kesalahan: bidang 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' memiliki jenis 'stdex :: detail :: StaticAssertion &lt;false&gt;' yang tidak lengkap <br>  25:36: note: dalam definisi makro 'CONCATENATE2' <br>  23:36: catatan: dalam ekspansi makro 'CONCATENATE1' <br>  30:67: note: dalam ekspansi makro 'CONCATENATE' <br>  24:36: note: dalam ekspansi makro 'CONCATENATE2' <br>  23:36: catatan: dalam ekspansi makro 'CONCATENATE1' <br>  30:79: note: dalam ekspansi makro 'CONCATENATE' <br>  24:36: note: dalam ekspansi makro 'CONCATENATE2' <br>  23:36: catatan: dalam ekspansi makro 'CONCATENATE1' <br>  30:91: note: dalam ekspansi makro 'CONCATENATE' <br>  36: 3: note: dalam perluasan makro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [C ++ Error] stdex_test.cpp (36): E2450 Struktur tidak terdefinisi 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [C ++ Kesalahan] stdex_test.cpp (36): E2449 Ukuran 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' tidak diketahui atau nol <br>  [C ++ Error] stdex_test.cpp (36): E2450 Struktur tidak terdefinisi 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Kesalahan c2079 </blockquote><br></div></div><br>  "Trik" kedua yang ingin saya miliki, sementara <u>hilang</u> dari standar adalah <b>countof</b> - menghitung jumlah elemen dalam array.  Sishers sangat suka mendeklarasikan makro ini melalui sizeof (arr) / sizeof (arr [0]), tetapi kita akan melangkah lebih jauh. <br><br><h3>  hitungan </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Untuk kompiler dengan dukungan <b>constexpr</b> , <b>kami akan</b> mendeklarasikan versi constexpr dari template ini (yang sama sekali tidak diperlukan, untuk semua standar, implementasi melalui template <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> sudah <i>cukup</i> ), untuk sisanya kami memperkenalkan versi melalui fungsi template <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> .  Visual Studio di sini sekali lagi dibedakan dengan adanya implementasi <b>_countof</b> di file header <b>stdlib.h</b> . <br><br>  Fungsi <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> terlihat mengintimidasi dan <i>mencari</i> tahu apa yang dilakukannya cukup rumit.  Jika Anda melihat lebih dekat, Anda dapat memahami bahwa dibutuhkan array elemen tipe template <i>T</i> dan ukuran <i>N</i> sebagai satu-satunya argumen - dengan demikian, dalam hal mentransfer tipe elemen lain (bukan array), kami mendapatkan kesalahan kompilasi, yang pasti menyenangkan.  Melihat lebih dekat, Anda dapat mengetahui (dengan susah payah) bahwa ia mengembalikan array elemen <b>char</b> ukuran <i>N.</i>  Pertanyaannya adalah, mengapa kita membutuhkan semua ini?  Di sinilah operator <b>sizeof</b> ikut <b>bermain</b> dan kemampuan uniknya untuk bekerja pada waktu kompilasi.  Ukuran panggilan <b>(</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> menentukan ukuran array elemen <b>char yang</b> dikembalikan oleh fungsi, dan karena <b>sizeof</b> standar <b>(char)</b> == 1, ini adalah jumlah elemen <i>N</i> dalam array asli.  Elegan, cantik, dan sepenuhnya gratis. <br><br><h3>  selamanya </h3><br>  Makro pembantu kecil lain yang saya gunakan di mana pun loop tak terbatas diperlukan <b>selamanya</b> .  Ini didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Sintaksis contoh untuk mendefinisikan loop infinite eksplisit: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Makro ini digunakan hanya untuk secara eksplisit mendefinisikan loop tak terbatas dan dimasukkan dalam perpustakaan hanya untuk alasan "tambahkan gula sintaksis".  Di masa depan, saya mengusulkan untuk menggantinya dengan opsional melalui mendefinisikan makro plug-in <b>SELAMANYA</b> .  Apa yang luar biasa dalam cuplikan kode di atas dari pustaka adalah makro <b>PERINGATAN yang</b> sama yang menghasilkan pesan peringatan di semua kompiler jika makro <b>selamanya</b> telah ditentukan oleh pengguna.  Ini menggunakan makro <b>__LINE__</b> standar yang sudah dikenal dan makro <b>__FILE__</b> standar, yang dikonversi menjadi string dengan nama file sumber saat ini. <br><br><h3>  stdex_assert </h3><br>  Untuk menerapkan <b>asert</b> dalam runtime, <b>stdex_assert</b> makro diperkenalkan sebagai: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  Saya tidak akan mengatakan bahwa saya sangat bangga dengan implementasi ini (itu akan berubah di masa depan), tetapi teknik yang menarik telah digunakan di sini yang ingin saya perhatikan.  Untuk menyembunyikan pemeriksaan dari ruang lingkup kode aplikasi, konstruk <b>do</b> <i>{}</i> <b>while (false)</b> digunakan, yang akan dieksekusi, yang jelas sekali dan pada saat yang sama tidak akan memperkenalkan kode "layanan" dalam kode aplikasi umum.  Teknik ini cukup berguna dan digunakan di beberapa tempat lain di perpustakaan. <br><br>  Jika tidak, implementasinya sangat mirip dengan pernyataan standar - dengan makro <b>NDEBUG</b> tertentu, yang biasanya dibuat oleh kompiler dalam rilis build, menegaskan tidak melakukan apa-apa, jika tidak maka program akan terganggu dengan output pesan ke aliran kesalahan standar jika kondisi tegas tidak terpenuhi. <br><br><h3>  kecuali </h3><br>  Untuk fungsi yang tidak membuang pengecualian, kata kunci <b>noexcept</b> telah diperkenalkan dalam standar baru.  Ini juga cukup sederhana dan tanpa rasa sakit untuk diterapkan melalui makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Namun, perlu dipahami bahwa dengan standar <b>noexcept</b> dapat mengambil nilai <b>bool</b> , dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat digunakan</a> untuk menentukan pada waktu kompilasi bahwa ekspresi yang diteruskan tidak membuang pengecualian.  Fungsionalitas ini tidak dapat diimplementasikan tanpa dukungan kompiler, dan oleh karena itu hanya ada <b>stdex_noexcept</b> "stripped down" di perpustakaan. <br><br>  Akhir bab kedua.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab ketiga</a> akan berbicara tentang seluk-beluk implementasi nullptr, mengapa berbeda untuk kompiler yang berbeda, serta pengembangan type_traits, dan apa bug lain dalam kompiler yang saya temui selama pengembangannya. <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417099/">https://habr.com/ru/post/id417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417087/index.html">HPE Digitize 2018: acara dan siaran langsung</a></li>
<li><a href="../id417089/index.html">Komputer kuantum: satu foton untuk memerintah semua</a></li>
<li><a href="../id417091/index.html">Buat shader air kartun untuk web. Bagian 3</a></li>
<li><a href="../id417093/index.html">Sakelar sentuh dengan Modbus: mengapa diperlukan dan bagaimana menerapkannya di apartemen pintar</a></li>
<li><a href="../id417097/index.html">Pemrograman JavaScript</a></li>
<li><a href="../id417101/index.html">Definisi Ready - Yang Kami Lupa Memberitahu Tentang</a></li>
<li><a href="../id417103/index.html">Spark SQL. Sedikit tentang pengoptimal permintaan</a></li>
<li><a href="../id417105/index.html">Mencetak pada printer 3D. Pengalaman Rahasia 3Dtool</a></li>
<li><a href="../id417107/index.html">Pembuat game sementara True: learn () tentang pemrograman gamedev, masalah VR, dan simulasi ML</a></li>
<li><a href="../id417109/index.html">Richard Hamming: Bab 10. Teori Pengkodean - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>