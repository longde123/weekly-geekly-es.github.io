<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘© ğŸ¥• Apa yang Anda, penutupan dalam JavaScript? ğŸ§œğŸ» ğŸ“³ ğŸ”µ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan mencoba menganalisis secara terperinci mekanisme untuk menerapkan penutupan dalam JavaScript. Untuk ini, saya akan mengguna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang Anda, penutupan dalam JavaScript?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459166/">  Pada artikel ini saya akan mencoba menganalisis secara terperinci mekanisme untuk menerapkan penutupan dalam JavaScript.  Untuk ini, saya akan menggunakan browser Chrome. <br><br>  Mari kita mulai dengan definisi: <br><blockquote>  <b>Penutupan</b> adalah fungsi yang merujuk variabel independen (gratis).  Dengan kata lain, fungsi yang didefinisikan dalam penutupan 'mengingat' lingkungan di mana ia dibuat. </blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> <br><br>  Jika ada sesuatu yang tidak jelas bagi Anda dalam definisi ini, itu tidak menakutkan.  Baca terus. <br><br>  Saya sangat yakin bahwa memahami sesuatu lebih mudah dan lebih cepat dengan contoh-contoh spesifik. <br><br>  Oleh karena itu, saya sarankan mengambil sepotong kode dan berjalan bersama penerjemah dari awal hingga akhir dalam langkah-langkah dan memilah apa yang terjadi. <br><br>  Jadi mari kita mulai: <br><br><img src="https://habrastorage.org/webt/o_/pi/wo/o_piwoknty0bjixs4sv8ohsw9am.png"><br>  <i>Gambar 1</i> <br><a name="habracut"></a><br>  Kami berada dalam konteks panggilan global, Global (alias Window di browser) dan kami melihat bahwa fungsi utama sudah ada dalam konteks saat ini dan siap untuk bekerja. <br><br><img src="https://habrastorage.org/webt/-i/2i/vv/-i2ivvoyp8qo-f0hq0xf1oezoqu.png"><br>  <i>Gambar 2</i> <br><br>  Ini terjadi karena semua Deklarasi Fungsi (selanjutnya disebut FD) selalu naik dalam konteks apa pun, segera diinisialisasi dan siap untuk bekerja.  Hal yang sama terjadi dengan variabel yang dideklarasikan melalui var, hanya nilainya yang diinisialisasi sebagai tidak terdefinisi. <br><br>  Penting juga dipahami bahwa JavaScript juga "memunculkan" variabel-variabel yang dideklarasikan melalui let dan const.  Satu-satunya perbedaan adalah bahwa itu tidak menginisialisasi mereka sebagai var atau FD.  Oleh karena itu, ketika kami mencoba mengaksesnya sebelum inisialisasi, kami mendapatkan Kesalahan Referensi. <br><br>  Juga, pada intinya kita melihat properti yang disembunyikan secara internal <b>[[Cakupan]]</b> - ini adalah daftar konteks eksternal di mana main memiliki akses.  Dalam kasus kami, Global ada di sana, karena main diluncurkan dalam konteks global. <br><br>  Fakta bahwa dalam JavaScript inisialisasi referensi ke lingkungan eksternal terjadi pada saat fungsi dibuat, dan bukan pada saat eksekusi, menunjukkan bahwa JS adalah bahasa dengan cakupan statis.  Dan itu penting. <br><br>  Silakan: <br><br><img src="https://habrastorage.org/webt/_h/0w/qx/_h0wqxn3kdigr1j-mry8pvdt2fm.png"><br>  <i>Gambar 3</i> <br><cut></cut><br>  Kami pergi ke fungsi utama dan hal pertama yang menarik perhatian Anda adalah objek Lokal (dalam spesifikasi - localEnv).  Di sana kita melihat <b>a</b> , karena variabel ini dideklarasikan melalui <b>var</b> dan itu 'muncul', yah, dan menurut tradisi kita melihat ketiga FD (foo, bar, baz).  Sekarang mari kita cari tahu dari mana semua itu berasal. <br><br>  Ketika konteks apa pun dimulai, operasi abstrak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NewDeclarativeEnvironment diluncurkan</a> , yang memungkinkan Anda untuk menginisialisasi <b>LexicalEnvironment</b> (selanjutnya LE) dan <b>VariableEnvironment</b> .  Juga, <b>NewDeclarativeEnvironment</b> mengambil 1 argumen - LE eksternal, untuk membuat [[Cakupan]] yang kita bicarakan di atas.  LE adalah API yang memungkinkan kita untuk menentukan hubungan antara pengidentifikasi dan variabel individual, fungsi.  LE terdiri dari 2 komponen: <br><br><ol><li>  <b>Catatan Lingkungan</b> - catatan lingkungan yang memungkinkan Anda untuk menentukan hubungan antara pengidentifikasi dan apa yang tersedia bagi kami dalam konteks panggilan saat ini </li><li>  Tautan ke LE eksternal.  Setiap fungsi memiliki properti <b>[[Cakupan]]</b> internal ketika dibuat <b>.</b> </li></ol><br>  VariableEnvironment - paling sering sama dengan LE.  Perbedaan antara keduanya adalah bahwa nilai VariableEnvironment tidak pernah berubah, dan LE dapat berubah selama eksekusi kode.  Untuk menyederhanakan pemahaman lebih lanjut, saya mengusulkan untuk menggabungkan komponen ini menjadi satu - LE. <br><br>  Juga di Local saat ini ada ini karena fakta bahwa <b>ThisBinding disebut</b> - ini juga merupakan metode abstrak yang menginisialisasi ini dalam konteks saat ini. <br><br>  Tentu saja, setiap FD segera menerima [[Cakupan]]: <br><br><img src="https://habrastorage.org/webt/nz/_t/ap/nz_tapg-wc5fulmh7wtsviyxus8.png"><br><a name="pic4"></a>  <i>Gambar 4</i> <br><br>  Kita melihat bahwa semua FD yang diterima di [[Cakupan]] array [Penutupan utama, Global], yang logis. <br><cut></cut><br>  Juga pada gambar yang kita lihat <b>Call Stack</b> - ini adalah struktur data yang bekerja berdasarkan prinsip LIFO - bertahan lebih dulu.  Karena JavaScript adalah utas tunggal, hanya satu konteks yang dapat dieksekusi pada satu waktu.  Dalam kasus kami, ini adalah konteks fungsi utama.  Setiap panggilan fungsi baru menciptakan konteks baru, yang ditumpuk. <br><br>  Di atas tumpukan selalu menjadi konteks eksekusi saat ini.  Setelah fungsi selesai dieksekusi dan penerjemah keluar, konteks panggilan dihapus dari tumpukan.  Itu saja yang perlu kita ketahui tentang Call Stack di artikel ini :) <br><br>  Kami merangkum apa yang terjadi dalam konteks saat ini: <br><br><ul><li>  Pada saat pembuatan, utama diterima [[Cakupan]] dengan tautan ke lingkungan eksternal </li><li>  Juru bahasa memasuki tubuh fungsi utama </li><li>  Call Stack menjadikan konteks eksekusi sebagai utama </li><li>  Ini diinisialisasi </li><li>  Inisialisasi LE </li></ul><br>  Bahkan, bagian tersulit sudah usai.  Kami melanjutkan ke langkah selanjutnya dalam kode: <br><br>  Sekarang kita perlu memanggil baz untuk mendapatkan hasilnya. <br><br><img src="https://habrastorage.org/webt/m4/0x/-i/m40x-if0h9mshfrsqxqv27wgbaw.png"><br><a name="pic5"></a>  <i>Gambar 5</i> <br><br>  Konteks panggilan baz baru telah ditambahkan ke Call Stack.  Kita melihat bahwa objek Penutupan baru telah muncul.  Di sini kita mendapatkan apa yang tersedia bagi kita dari [[Cakupan]].  Jadi kita sampai pada intinya.  Ini adalah penutupannya.  Seperti yang Anda lihat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar 4,</a> Penutupan (utama) masuk pertama dalam daftar konteks 'cadangan' di baz.  Sekali lagi tidak ada sihir. <br><br>  Mari kita panggil foo: <br><br><img src="https://habrastorage.org/webt/ln/nd/yg/lnndygmqufofzebonalpko5ro3s.png"><br>  <i>Gambar 6</i> <br><br>  Penting untuk mengetahui bahwa di mana pun kami memanggil foo, itu akan selalu mengikuti pengidentifikasi yang tidak ditentukan dalam rantai [[Cakupan]] -nya.  Yaitu, di main dan kemudian di Global, jika tidak ditemukan di main. <br><br>  Setelah mengeksekusi foo, dia mengembalikan nilainya, dan konteksnya melompat keluar dari Call Stack. <br>  Kami meneruskan panggilan ke fungsi bilah.  Dalam konteks eksekusi bar, ada variabel dengan nama yang sama dengan variabel di LE foo - <b>a</b> .  Tapi, seperti yang sudah Anda tebak, ini tidak memengaruhi apa pun.  foo masih akan mengambil nilai dari [[Cakupan]] nya. <br><blockquote>  Tempat panggilan tidak memengaruhi Lingkup, hanya tempat penciptaan </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">logachyova</a> <br><br><img src="https://habrastorage.org/webt/lx/oe/er/lxoeer85v0udg9ivlztvi6qr8yw.png"><br>  <i>Gambar 7</i> <br><br>  Akibatnya, baz akan mengembalikan 300 dan akan dikeluarkan dari Call Stack.  Kemudian hal yang sama akan terjadi dengan konteks utama, fragmen kode kita akan selesai dieksekusi. <br><br>  Kami merangkum: <br><br><ul><li>  Selama pembuatan fungsi, <b>[[Cakupan]] diatur</b> .  Ini sangat penting untuk memahami penutupan, karena penerjemah segera mengikuti tautan ini ketika mencari nilai </li><li>  Kemudian, ketika fungsi ini dipanggil, konteks eksekusi aktif dibuat, yang ditempatkan di Call Stack </li><li>  Penjilidan ini dijalankan dan ini diatur untuk konteks saat ini </li><li>  LE diinisialisasi, dan semua argumen fungsi, variabel dideklarasikan melalui var dan FD menjadi tersedia.  Selanjutnya, jika ada variabel yang dideklarasikan melalui let atau const, mereka juga ditambahkan ke LE </li><li>  Jika penerjemah tidak menemukan pengidentifikasi dalam konteks saat ini, maka <b>[[Cakupan]]</b> digunakan untuk pencarian lebih lanjut, yang diurutkan semua pada gilirannya.  Jika nilainya ditemukan, maka tautannya jatuh ke objek Penutupan khusus.  Pada saat yang sama, untuk setiap konteks yang ditutup saat ini, <b>Penutupan</b> terpisah dibuat dengan variabel yang diperlukan </li><li>  Jika nilai tidak ditemukan dalam Lingkup apa pun, termasuk Global, ReferenceError dikembalikan. </li></ul><br>  Itu saja! <br><br>  Saya harap artikel ini bermanfaat bagi Anda dan sekarang Anda mengerti bagaimana mekanisme penguncian dalam JavaScript bekerja. <br><br>  Sampai jumpa :) Dan sampai jumpa.  Suka dan berlangganan ke saluran saya :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459166/">https://habr.com/ru/post/id459166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459154/index.html">Jaringan untuk usaha kecil menggunakan peralatan Cisco. Bagian 1</a></li>
<li><a href="../id459156/index.html">VNIITE planet keseluruhan: bagaimana di Uni Soviet mereka datang dengan sistem "rumah pintar"</a></li>
<li><a href="../id459158/index.html">Bagaimana Artefak Menjadi Kegagalan Terbesar Katup</a></li>
<li><a href="../id459160/index.html">Bagaimana Anda memilih produk di toko?</a></li>
<li><a href="../id459162/index.html">"Untuk memenangkan kejuaraan, tim harus bernafas berbarengan." Wawancara dengan Pelatih ICPC Lokakarya Moskow</a></li>
<li><a href="../id459168/index.html">Bepergian Windows Defender dengan murah dan ceria: sesi meterpreter via python</a></li>
<li><a href="../id459172/index.html">13 Perpustakaan Scala Teratas untuk Analisis Data</a></li>
<li><a href="../id459174/index.html">Referensi Sumber Acara Rx</a></li>
<li><a href="../id459176/index.html">Catu daya tegangan tinggi yang stabil untuk PMT</a></li>
<li><a href="../id459180/index.html">TheOutloud - Suara dan bagikan artikel dan cerita favorit Anda. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>