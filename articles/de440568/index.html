<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•å üßöüèΩ üìá Wir schreiben eine Lernanwendung in Go und Javascript, um die tats√§chlichen Aktienrenditen zu bewerten. Teil 2 - Testen des Backends üîõ üë≠ ‚òØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil des Artikels haben wir einen kleinen Webserver geschrieben, der das Backend f√ºr unser Informationssystem darstellt. Dieser Teil war nic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben eine Lernanwendung in Go und Javascript, um die tats√§chlichen Aktienrenditen zu bewerten. Teil 2 - Testen des Backends</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440568/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des</a> Artikels haben wir einen kleinen Webserver geschrieben, der das Backend f√ºr unser Informationssystem darstellt.  Dieser Teil war nicht besonders interessant, obwohl er die Verwendung der Schnittstelle und eine der Methoden f√ºr die Arbeit mit Goroutinen demonstrierte.  Sowohl das als auch ein anderes k√∂nnen f√ºr Anf√§nger interessant sein. <br><br>  Der zweite Teil ist viel interessanter und n√ºtzlicher, da darin Unit-Tests sowohl f√ºr den Server selbst als auch f√ºr das Bibliothekspaket geschrieben werden, das das Data Warehouse implementiert.  Fangen wir an. <br><br><img src="https://habrastorage.org/webt/wt/j2/bu/wtj2bu3mbxf_4pj0a_7lypsprcm.jpeg"><br>  <i>Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a></i> <br><a name="habracut"></a><br>  Ich m√∂chte Sie daran erinnern, dass unsere Anwendung aus einem ausf√ºhrbaren Modul (Webserver, API), einem Speichermodul (Entit√§tsdatenstrukturen, Vertragsschnittstelle f√ºr Speicheranbieter) und Speicheranbietermodulen besteht (in unserem Beispiel gibt es nur ein Modul, das die Speicherschnittstelle ausf√ºhrt Daten im Speicher). <br><br>  Wir werden das ausf√ºhrbare Modul und die Speicherimplementierung testen.  Das Vertragsmodul enth√§lt keinen Code, der getestet werden k√∂nnte.  Es gibt nur Typdeklarationen. <br>  Zum Testen verwenden wir nur die Funktionen der Standardbibliothek - Test- und httptest-Pakete.  Meiner Meinung nach sind sie v√∂llig ausreichend, obwohl es viele verschiedene Test-Frameworks gibt.  Schau sie dir an, vielleicht wirst du sie m√∂gen.  Aus meiner Sicht ben√∂tigen Programme auf Go nicht wirklich die Frameworks (verschiedener Art), die derzeit existieren.  Dies ist kein Javascript f√ºr Sie, das im dritten Teil des Artikels behandelt wird. <br><br>  Zun√§chst ein paar Worte zur Testmethode, die ich f√ºr Go-Programme verwende. <br><br>  <b>Erstens</b> muss ich sagen, dass ich Go wirklich mag, nur weil es den Programmierer nicht in ein starres Framework treibt.  Obwohl einige Entwickler fairerweise gerne in das Framework des vorherigen PL einsteigen.  Sagen wir, der gleiche Rob Pike sagte, dass er kein Problem beim Kopieren des Codes gesehen habe, wenn das einfacher w√§re.  Ein solches Kopieren und Einf√ºgen ist sogar in der Standardbibliothek enthalten.  Anstatt das Paket zu importieren, kopierte einer der Autoren der Sprache einfach den Text einer Funktion (Unicode-√úberpr√ºfung).  In diesem Test wird das Unicode-Paket importiert, sodass alles in Ordnung ist. <br><br>  √úbrigens kann in diesem Sinne (im Sinne der Sprachflexibilit√§t) beim Schreiben von Tests eine interessante Technik verwendet werden.  Das Fazit lautet: Wir wissen, dass Schnittstellenvertr√§ge in Go implizit ausgef√ºhrt werden.  Das hei√üt, wir k√∂nnen einen Typ deklarieren, Methoden daf√ºr schreiben und eine Art Vertrag ausf√ºhren.  Vielleicht sogar ohne es zu wissen.  Dies ist bekannt und verstanden.  Dies funktioniert jedoch auch in die entgegengesetzte Richtung.  Wenn der Autor eines Moduls keine Schnittstelle geschrieben hat, die uns helfen w√ºrde, einen Stub zum Testen unseres Pakets zu erstellen, k√∂nnen wir die Schnittstelle in unserem Test deklarieren, die in einem Paket eines Drittanbieters ausgef√ºhrt wird.  Eine fruchtbare Idee, obwohl sie in unserer Trainingsanwendung nicht n√ºtzlich ist. <br><br>  <b>Zweitens</b> ein paar Worte zum Zeitpunkt des Schreibens der Tests.  Wie jeder wei√ü, gibt es unterschiedliche Meinungen dar√ºber, wann Unit-Tests zu schreiben sind.  Die Hauptideen sind wie folgt: <br><br><ul><li>  Wir schreiben Tests, bevor wir Code (TDD) schreiben.  So verstehen wir die Aufgabe besser und legen Qualit√§tskriterien fest. </li><li>  Wir schreiben Tests beim Schreiben von Code oder sogar etwas sp√§ter (wir werden dieses inkrementelle Prototyping ber√ºcksichtigen). </li><li>  Wir werden sp√§ter Tests schreiben, wenn Zeit ist.  Und das ist kein Scherz.  Manchmal sind die Bedingungen so, dass physisch keine Zeit bleibt. </li></ul><br>  Ich glaube nicht, dass es zu diesem Thema die einzig richtige Meinung gibt.  Ich werde meine teilen und die Leser bitten, in den Kommentaren zu kommentieren.  Meine Meinung ist folgende: <br><br><ul><li>  Die Entwicklung freistehender Pakete auf TDD vereinfacht die Angelegenheit erheblich, insbesondere wenn das Starten der Anwendung zur √úberpr√ºfung ein ressourcenintensiver Prozess ist.  Zum Beispiel habe ich k√ºrzlich ein GPS / GLONASS-Fahrzeug√ºberwachungssystem entwickelt.  Treiberpakete f√ºr Protokolle k√∂nnen nur durch Tests entwickelt werden, da das Starten und manuelle √úberpr√ºfen einer Anwendung das Warten auf Daten von Trackern erfordert, was √§u√üerst unpraktisch ist.  F√ºr Tests nahm ich Proben von Datenpaketen, zeichnete sie in Tabellentests auf und startete den Server erst, wenn die Treiber bereit waren. </li><li>  Wenn die Codestruktur nicht klar ist, versuche ich zuerst, einen minimal funktionierenden Prototyp zu erstellen.  Dann schreibe ich Tests oder poliere zuerst den Code ein wenig und dann nur die Tests. </li><li>  F√ºr ausf√ºhrbare Module schreibe ich zuerst einen Prototyp.  Tests sp√§ter.  Ich teste den offensichtlichen ausf√ºhrbaren Code √ºberhaupt nicht (Sie k√∂nnen den Start des http-Servers von main in eine separate Funktion eingeben und im Test aufrufen, aber warum die Standardbibliothek testen?) </li></ul><br>  Auf dieser Grundlage wurde in unserer Schulungsanwendung der RAM-Speicheranbieter durch Tests geschrieben.  Die ausf√ºhrbare Serverdatei wurde √ºber einen Prototyp erstellt. <br><br>  Beginnen wir mit den Tests zur Implementierung des Repositorys. <br><br>  Im Repository haben wir die Factory-Methode New (), die einen Zeiger auf eine Instanz des Speichertyps zur√ºckgibt.  Es gibt auch Methoden zum Abrufen von Securities () - Anf√ºhrungszeichen, zum Hinzuf√ºgen von Papier zur Add () - Liste und zum Initialisieren des Speichers mit Daten vom Mosbirzh InitData () - Server. <br><br>  Testen des Konstruktors (OOP-Begriffe werden frei und informell verwendet. In voller √úbereinstimmung mit der Position von OOP in Go). <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestNew(t *testing.T) { //   - memoryStorage := New() //     var s *Storage //         .   if reflect.TypeOf(memoryStorage) != reflect.TypeOf(s) { t.Errorf(" :  %v,   %v", reflect.TypeOf(memoryStorage), reflect.TypeOf(s)) } //     t.Logf("\n%+v\n\n", memoryStorage) }</span></span></code> </pre> <br>  In diesem Test wurde ohne besonderen Bedarf gezeigt, dass der einzige Weg in Go, um den Typ einer Variablen zu √ºberpr√ºfen, die Reflexion ist (Reflect.TypeOf (memoryStorage)).  Eine √úberbeanspruchung dieses Moduls wird nicht empfohlen.  Die Herausforderungen sind schwer und √ºberhaupt nicht wert.  Was ist in diesem Test au√üer dem Fehlen eines Fehlers noch zu √ºberpr√ºfen? <br><br>  Als n√§chstes testen wir den Eingang von Angeboten und das Hinzuf√ºgen von Papier.  Diese Tests duplizieren sich teilweise gegenseitig, dies ist jedoch nicht kritisch (im Test zum Hinzuf√ºgen von Papier wird die Methode zum Einholen von Angeboten zur √úberpr√ºfung aufgerufen).  Im Allgemeinen schreibe ich manchmal einen Test f√ºr alle CRUD-Operationen f√ºr eine bestimmte Entit√§t.  Das hei√üt, im Test erstelle ich eine Entit√§t, lese sie, √§ndere sie, lese sie erneut, l√∂sche sie, lese sie erneut.  Nicht sehr elegant, aber offensichtliche M√§ngel sind nicht sichtbar. <br><br>  Angebotstest. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestSecurities(t *testing.T) { //     var s *Storage //    ss, err := s.Securities() if err != nil { t.Error(err) } //     t.Logf("\n%+v\n\n", ss) } }</span></span></code> </pre> <br>  Hier ist alles ziemlich offensichtlich. <br><br>  Testen Sie nun, um Papier hinzuzuf√ºgen.  In diesem Test verwenden wir f√ºr Bildungszwecke (ohne wirklichen Bedarf) eine sehr praktische Tischtesttechnik.  Das Wesentliche ist wie folgt: Wir erstellen ein Array unbenannter Strukturen, von denen jede die Eingabedaten f√ºr den Test und das erwartete Ergebnis enth√§lt.  In unserem Fall legen wir ein Wertpapier vor, das hinzugef√ºgt werden soll. Das Ergebnis ist die Anzahl der Wertpapiere im Tresor (Array-L√§nge).  Als n√§chstes f√ºhren wir einen Test f√ºr jedes Element des Arrays von Strukturen durch (rufen Sie die Testmethode mit den Eingabedaten des Elements auf) und vergleichen das Ergebnis mit dem Ergebnisfeld des aktuellen Elements.  Es stellt sich so etwas heraus. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestAdd(t *testing.T) { //     var s *Storage var security = storage.Security{ ID: "MSFT", } //   var tt = []struct { s storage.Security //   length int //   () }{ { s: security, length: 1, }, { s: security, length: 2, }, } var ss []storage.Security // tc - test case, tt - table tests for _, tc := range tt { //    err := s.Add(security) if err != nil { t.Error(err) } ss, err = s.Securities() if err != nil { t.Error(err) } if len(ss) != tc.length { t.Errorf("  :  %d,   %d", len(ss), tc.length) } } //     t.Logf("\n%+v\n\n", ss) }</span></span></code> </pre> <br>  Nun, ein Test f√ºr die Dateninitialisierungsfunktion. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestInitData(t *testing.T) { //     var s *Storage //    err := s.InitData() if err != nil { t.Error(err) } ss, err := s.Securities() if err != nil { t.Error(err) } if len(ss) &lt; 1 { t.Errorf(" :  %d,   '&gt; 1'", len(ss)) } //     t.Logf("\n%+v\n\n", ss[0]) }</span></span></code> </pre> <br>  Als Ergebnis einer erfolgreichen Testausf√ºhrung erhalten wir: <b>17.595s Abdeckung: 86,0% der Anweisungen.</b> <br><br>  Man kann sagen, dass es sch√∂n w√§re, wenn eine separate Bibliothek eine 100% ige Abdeckung erhalten w√ºrde, aber speziell hier sind erfolglose Ausf√ºhrungspfade (Fehler in Funktionen) aufgrund der Implementierungsfunktionen √ºberhaupt nicht m√∂glich - alles ist im Speicher, wir sind nirgendwo verbunden, wir sind von nichts abh√§ngig.  Es gibt eine formelle Fehlerbehandlung, da ein Schnittstellenvertrag bewirkt, dass der Fehler zur√ºckgegeben wird und der Linter ihn ben√∂tigt. <br><br>  Fahren wir mit dem Testen des ausf√ºhrbaren Pakets fort - des Webservers.  Hier muss gesagt werden, dass das "net / http / httptest" -Paket speziell zum Testen von http-Anforderungshandlern entwickelt wurde, da der Webserver eine Super-Standard-Konstruktion in Go-Programmen ist.  Sie k√∂nnen einen Webserver simulieren, einen Anforderungshandler ausf√ºhren und die Antwort des Webservers in einer speziellen Struktur aufzeichnen.  Wir werden es benutzen, es ist sehr einfach, sicher wird es Ihnen gefallen. <br><br>  Gleichzeitig gibt es eine Meinung (und nicht nur meine), dass ein solcher Test f√ºr ein reales Arbeitssystem m√∂glicherweise nicht sehr relevant ist.  Grunds√§tzlich k√∂nnen Sie einen echten Server starten und in Tests echte Verbindungshandler aufrufen. <br><br>  Es stimmt, es gibt eine andere Meinung (und nicht nur meine), dass es gut ist, Gesch√§ftslogik von Systemen zur Manipulation realer Daten zu isolieren. <br><br>  In diesem Sinne k√∂nnen wir sagen, dass wir Unit-Tests schreiben, keine Integrationstests, an denen andere Pakete und Services beteiligt sind.  Obwohl ich hier auch der Meinung bin, dass eine bestimmte Go-Flexibilit√§t es Ihnen erm√∂glicht, sich nicht auf Begriffe zu konzentrieren und die Tests zu schreiben, die f√ºr Ihre Aufgaben am besten geeignet sind.  Lassen Sie mich ein Beispiel geben: F√ºr Tests von API-Anforderungshandlern habe ich eine vereinfachte Kopie der Datenbank auf einem realen Server im Netzwerk erstellt, mit einem kleinen Datensatz initialisiert und Tests f√ºr reale Daten ausgef√ºhrt.  Dieser Ansatz ist jedoch sehr situativ. <br><br>  Zur√ºck zu den Tests unseres Webservers.  Um Tests zu schreiben, die vom tats√§chlichen Speicher unabh√§ngig sind, m√ºssen wir einen Stub-Speicher entwickeln.  Dies ist √ºberhaupt nicht schwierig, da wir mit dem Repository √ºber die Schnittstelle arbeiten (siehe den ersten Teil).  Wir m√ºssen lediglich einen eigenen Datentyp deklarieren und die Methoden des Speicherschnittstellenvertrags daf√ºr implementieren, auch bei leeren Daten.  So etwas wie das: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    -    type stub int //      var securities []storage.Security //    // ******************************* //     // InitData      func (s *stub) InitData() (err error) { //   -   var security = storage.Security{ ID: "MSFT", Name: "Microsoft", IssueDate: 1514764800, // 01/01/2018 } var quote = storage.Quote{ SecurityID: "MSFT", Num: 0, TimeStamp: 1514764800, Price: 100, } security.Quotes = append(security.Quotes, quote) securities = append(securities, security) return err } // Securities      func (s *stub) Securities() (data []storage.Security, err error) { return securities, err } //   // *****************</span></span></code> </pre> <br>  Jetzt k√∂nnen wir unseren Speicher mit einem Stub initialisieren.  Wie kann man das machen?  Zum Initialisieren der Testumgebung in Go einer nicht sehr alten Version wurde eine Funktion hinzugef√ºgt: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *testing.M)</span></span></span></span></code> </pre> <br>  Mit dieser Funktion k√∂nnen Sie alle Tests initialisieren und ausf√ºhren.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    -   func TestMain(m *testing.M) { //     -    db = new(stub) //   () db.InitData() //     os.Exit(m.Run()) }</span></span></code> </pre> <br>  Jetzt k√∂nnen wir Tests f√ºr API-Anforderungshandler schreiben.  Wir haben zwei API-Endpunkte, zwei Handler und daher zwei Tests.  Sie sind sehr √§hnlich, also hier ist der erste von ihnen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestSecuritiesHandler(t *testing.T) { //     req, err := http.NewRequest(http.MethodGet, "/api/v1/securities", nil) if err != nil { t.Fatal(err) } // ResponseRecorder    rr := httptest.NewRecorder() handler := http.HandlerFunc(securitiesHandler) //       handler.ServeHTTP(rr, req) //  HTTP-  if rr.Code != http.StatusOK { t.Errorf(" :  %v,   %v", rr.Code, http.StatusOK) } //  ()     json    var ss []storage.Security err = json.NewDecoder(rr.Body).Decode(&amp;ss) if err != nil { t.Fatal(err) } //       t.Logf("\n%+v\n\n", ss) }</span></span></code> </pre> <br>  Der Kern des Tests besteht darin, eine http-Anforderung zu erstellen, eine Struktur zum Aufzeichnen der Serverantwort zu definieren, den Anforderungshandler zu starten und den Antworttext zu dekodieren (json in die Struktur).  Aus Gr√ºnden der √úbersichtlichkeit drucken wir die Antwort aus. <br><br>  Es stellt sich heraus wie: <br><blockquote>  === RUN TestSecuritiesHandler <br>  0xc00005e3e0 <br>  - PASS: TestSecuritiesHandler (0,00s) <br>  c: \ Benutzer \ dtsp \ YandexDisk \ go \ src \ moex_etf \ server \ server_test.go: 96: <br>  [{ID: MSFT Name: Microsoft IssueDate: 1514764800 Quotes: [{SecurityID: MSFT Num: 0 TimeStamp: 1514764800 Price: 100}]}] <br><br>  Pass <br>  ok moex_etf / server 0.307s <br>  Erfolg: Tests bestanden. </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-</a> Code. <br><br>  Im n√§chsten, letzten Teil des Artikels werden wir eine Webanwendung entwickeln, mit der Diagramme der realen Aktienrenditen von ETFs der Moskauer B√∂rse angezeigt werden k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440568/">https://habr.com/ru/post/de440568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440558/index.html">Technologie, die Quantennetzwerke n√§her bringt</a></li>
<li><a href="../de440560/index.html">Alexander Belokrylov und Dmitry Chuyko √ºber Liberica JDK auf jug.msk.ru</a></li>
<li><a href="../de440562/index.html">Windows Phone - ALLES, es ist immer wieder</a></li>
<li><a href="../de440564/index.html">GPT-2 neuronales Netzwerk von OpenAI. Schnellstart</a></li>
<li><a href="../de440566/index.html">Ungehindert beschleunigen oder SIMD kennenlernen</a></li>
<li><a href="../de440570/index.html">Reflektierende Schattenkarten: Teil 2 - Implementierung</a></li>
<li><a href="../de440574/index.html">Russischer AI Cup 2018, Geschichte 9 Pl√§tze</a></li>
<li><a href="../de440576/index.html">Wichtige √Ñnderungen an CTE in PostgreSQL 12</a></li>
<li><a href="../de440582/index.html">Werden Elektroautos auf den Grund des Autokonzerns gezogen?</a></li>
<li><a href="../de440584/index.html">Was ist los mit dem Raspberry Pi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>