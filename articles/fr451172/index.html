<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛵 👩🏽‍🤝‍👨🏼 👩‍❤️‍👩 Julia: fonctions et structures en tant que fonctions 🏦 👨🏼‍🎓 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgré le fait que le concept de Julia manque de programmation orientée objet «classique» avec des classes et des méthodes, le langage fournit des out...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia: fonctions et structures en tant que fonctions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451172/">  Malgré le fait que le concept de Julia manque de programmation orientée objet «classique» avec des classes et des méthodes, le langage fournit des outils d'abstraction, un rôle clé dans lequel sont joués le système de types et les éléments de la programmation fonctionnelle.  Examinons le deuxième point plus en détail. <br><a name="habracut"></a><br>  Le concept de fonctions dans Julia est probablement le plus similaire aux langages de la famille Lisp (pour être plus précis, les branches Lisp-1), et les fonctions peuvent être considérées à trois niveaux: en tant que sous-programmes, en tant qu'abstractions à une certaine séquence d'actions, et en tant que données représentant cette abstraction . <br><br><h3>  Niveau 1. Fonctionne comme des routines </h3><br>  L'attribution de sous-programmes et l'attribution de leurs propres noms se poursuivent depuis la préhistoire, lorsque Fortran était considéré comme un langage de haut niveau et que C n'était pas encore là. <br><br>  En ce sens, les produits Julia sont standard.  La «caractéristique» peut être appelée le fait que syntaxiquement il n'y a pas de division en procédures et fonctions.  Que la sous-routine soit appelée pour obtenir une valeur ou simplement pour effectuer une action sur les données, elle est appelée fonction. <br><br>  La définition d'une fonction commence par le mot clé <code>function</code> , suivie d'une liste d'arguments, d'une séquence de commandes entre crochets, et le mot <code>end</code> termine la définition: <br><br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" sum_all(collection) Sum all elements of a collection and return the result """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum_all(collection) sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> collection sum += collection <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sum <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  La syntaxe se distingue par le comportement hérité de Lisp: pour un retour "normal" d'une valeur d'une fonction, le mot <code>return</code> pas nécessaire: la valeur de la dernière expression calculée avant <code>end</code> retournée.  Dans l'exemple ci-dessus, la valeur de la <code>sum</code> variable sera retournée.  Ainsi, <code>return</code> peut être utilisé comme marqueur du comportement spécial d'une fonction: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> safe_division(number, divisor) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> number / divisor <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#    function safe_division1(number, divisor) if divisor == 0 0 #             else number / divisor end end</span></span></code> </pre><br>  Pour les fonctions avec une définition courte, il existe une syntaxe raccourcie similaire à une notation mathématique.  Ainsi, le calcul de la longueur de l'hypoténuse le long de la longueur des jambes peut être défini comme suit: <br><br><pre> <code class="julia hljs">hypotenuse(a, b) = sqrt(a^<span class="hljs-number"><span class="hljs-number">2</span></span> + b^<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  La division «sûre» utilisant l'opérateur ternaire peut s'écrire comme suit: <br><br><pre> <code class="julia hljs">safe_division(number, divisor) = divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : number / divisor</code> </pre><br>  Comme vous pouvez le voir, il n'est pas nécessaire de spécifier des types pour les arguments de fonction.  Étant donné le fonctionnement du compilateur Julia JIT, le typage canard n'entraînera pas toujours de mauvaises performances. <br><br>  Comme j'ai essayé de le démontrer dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> , le compilateur Julia peut déduire le type du résultat de retour par les types d'arguments d'entrée.  Par conséquent, par exemple, la fonction <code>safe_division</code> nécessite une modification minimale pour un fonctionnement rapide: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> safe_division(number, divisor) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero(number / divisor) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> number / divisor <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Maintenant, si les types des deux arguments sont connus au stade de la compilation, le type du résultat renvoyé est également affiché sans ambiguïté, car  la fonction <code>zero(x)</code> renvoie une valeur nulle du même type que son argument (et divisée par zéro, selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IEEE 754</a> , a une valeur parfaitement représentable au format de nombres à virgule flottante). <br><br>  Les fonctions peuvent avoir un nombre fixe d'arguments positionnels, des arguments positionnels avec des valeurs par défaut, des arguments nommés et un nombre variable d'arguments.  Syntaxe: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#    function hello(name) println("Hello, ", name) end #      #           function greeting_d(name, greeting = "Hello") println(greeting, ", ", name) end #       #          #       function greeting_kw(name; greeting = "Hello") println(greeting, ", ", name) end #  greeting   ,        function greeting_oblkw(name; greeting) println(greeting, ", ", name) end #      #  ,   ,      names function greeting_nary(greeting, names...) print(greeting) for name in names print(", ", name) end print('\n') end julia&gt; hello("world") Hello, world julia&gt; greeting_d("world") Hello, world julia&gt; greeting_d("Mr. Smith", "How do you do") How do you do, Mr. Smith julia&gt; greeting_kw("Mr. Smith") Hello, Mr. Smith julia&gt; greeting_kw("mom", greeting = "Hi") Hi, mom julia&gt; greeting_oblkw("world") ERROR: UndefKeywordError: keyword argument greeting not assigned Stacktrace: [1] greeting_oblkw(::String) at ./REPL[23]:3 [2] top-level scope at none:0 julia&gt; greeting_oblkw("mom", greeting = "Hi") Hi, mom julia&gt; greeting_nary("Hi", "mom", "dad", "everyone") Hi, mom, dad, everyone</span></span></code> </pre><br><h3>  Niveau 2. Fonctionne comme données </h3><br>  Le nom de la fonction peut être utilisé non seulement dans les appels directs, mais aussi comme identifiant auquel est associée la procédure d'obtention de la valeur.  Par exemple: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f_x_x(fn, x) fn(x, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; f_x_x(+, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment"># +(3, 3) = 3+3 = 6 julia&gt; f_x_x(*, 3) 9 # *(3, 3) = 9 julia&gt; f_x_x(^, 3) 27 # ^(3, 3) = 3^3 = 27 julia&gt; f_x_x(log, 3) 1.0 # log(3, 3) = 1</span></span></code> </pre><br>  Les fonctions "classiques" qui prennent un argument fonctionnel sont <code>map</code> , <code>reduce</code> et <code>filter</code> . <br><br>  <code>map(f, x...)</code> applique la fonction <code>f</code> aux valeurs de tous les éléments de <code>x</code> (ou des tuples d'i-éléments) et retourne les résultats comme une nouvelle collection: <br><br><pre> <code class="julia hljs">julia&gt; map(cos, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>]) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5000000000000001</span></span> <span class="hljs-number"><span class="hljs-number">6.123233995736766e-17</span></span> -<span class="hljs-number"><span class="hljs-number">0.4999999999999998</span></span> -<span class="hljs-number"><span class="hljs-number">1.0</span></span> julia&gt; map(+, (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  <code>reduce(f, x; init_val)</code> "réduit" la collection à une seule valeur, "étendant" la chaîne <code>f(f(...f(f(init_val, x[1]), x[2])...), x[end])</code> : <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> myreduce(fn, values, init_val) accum = init_val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values accum = fn(accum, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> accum <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Puisqu'il n'est pas vraiment déterminé dans quel ordre le tableau passera pendant la réduction, ou si <code>fn(accum, x)</code> ou <code>fn(x, accum)</code> sera <code>fn(x, accum)</code> , la réduction ne donnera un résultat prévisible qu'avec des opérateurs commutatifs ou associatifs, tels que l'addition ou la multiplication. <br><br>  <code>filter(predicate, x)</code> renvoie un tableau d'éléments <code>x</code> qui satisfont le prédicat de <code>predicate</code> : <br><br><pre> <code class="julia hljs">julia&gt; filter(isodd, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> julia&gt; filter(iszero, [[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-literal"><span class="hljs-literal">im</span></span>]) <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-literal"><span class="hljs-literal">im</span></span></code> </pre><br>  L'utilisation de fonctions d'ordre supérieur pour les opérations sur les tableaux au lieu d'écrire une boucle présente plusieurs avantages: <br><br><ol><li>  le code se raccourcit </li><li>  <code>map()</code> ou <code>reduce()</code> montre la <i>sémantique de</i> l'opération en cours, alors vous devez toujours comprendre la sémantique de ce qui se passe dans la boucle </li><li>  <code>map()</code> permet au compilateur de comprendre que les opérations sur les éléments du tableau sont indépendantes des données, ce qui permet d'appliquer des optimisations supplémentaires </li></ol><br><h3>  Niveau 3. Fonctionne comme abstractions </h3><br>  Souvent dans <code>map()</code> ou <code>filter()</code> vous devez utiliser une fonction à laquelle aucun nom n'a été attribué.  Dans ce cas, Julia vous permet d'exprimer l' <i>abstraction des</i> opérations sur l'argument, sans entrer votre propre nom pour cette séquence.  Une telle abstraction est appelée <i>une fonction anonyme</i> , ou une <i>fonction lambda</i> (car dans la tradition mathématique, ces fonctions sont désignées par la lettre lambda).  La syntaxe de cette vue est: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   square(x) = x^2 #   x -&gt; x^2 #   hypot(a, b) = sqrt(x^2 + y^2) #   -    ,    , #              (x, y) -&gt; sqrt(x^2 + y^2) #   fortytwo() = 42 #   () -&gt; 42 julia&gt; map(i -&gt; map(x -&gt; x^i, 1:5), 1:5) 5-element Array{Array{Int64,1},1}: [1, 2, 3, 4, 5] [1, 4, 9, 16, 25] [1, 8, 27, 64, 125] [1, 16, 81, 256, 625] [1, 32, 243, 1024, 3125]</span></span></code> </pre><br>  Les fonctions nommées et anonymes peuvent être affectées à des variables et renvoyées sous forme de valeurs: <br><br><pre> <code class="julia hljs">julia&gt; double_squared = x -&gt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * x)^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#17 (generic function with 1 method) julia&gt; double_squared(5) 100</span></span></code> </pre><br><h3>  Portée variable et fermetures lexicales </h3><br>  Normalement, ils essaient d'écrire des fonctions de telle manière que toutes les données nécessaires au calcul soient obtenues par des arguments formels, c'est-à-dire  tout nom de variable apparaissant dans le corps est soit le nom des arguments formels, soit le nom des variables introduites dans le corps de la fonction. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> normal(x, y) z = x + y x + y * z <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> strange(x, y) x + y * z <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  À propos de la fonction <code>normal()</code> , nous pouvons dire que dans son corps tous les noms de variables sont <i>liés</i> , c'est-à-dire  si nous partout (y compris la liste d'arguments) remplaçons «x» par «m» (ou tout autre identifiant), «y» par «n» et «z» par «sum_of_m_and_n», la signification de l'expression ne changera pas.  Dans la fonction <code>strange()</code> , le nom z n'est <i>pas lié</i> , c'est-à-dire  a) la signification peut changer si ce nom est remplacé par un autre, et b) l'exactitude de la fonction dépend du fait qu'une variable portant le nom «z» a été définie au moment de l'appel de la fonction. <br><br>  De manière générale, la fonction <code>normal()</code> n'est pas aussi propre: <br><br><ol><li>  Que se passe-t-il si une variable nommée z est définie en dehors de la fonction? </li><li>  En fait, les caractères + et * sont également des identificateurs indépendants. </li></ol><br>  Avec le point 2, rien ne peut être fait que d'être d'accord - il est logique que les définitions de toutes les fonctions utilisées dans le système existent, et nous espérons que leur véritable sens correspond à nos attentes. <br><br>  Le point 1 est moins évident qu'il n'y paraît.  Le fait est que la réponse dépend de l'endroit où la fonction est définie.  S'il est défini globalement, alors <code>z</code> à <code>normal()</code> intérieur de <code>normal()</code> sera une variable locale, c'est-à-dire  même s'il existe une variable globale <code>z</code> sa valeur ne sera pas écrasée.  Si la définition de la fonction est à l'intérieur du bloc de code, alors s'il existe une définition antérieure de <code>z</code> dans ce bloc, ce sera la valeur de la variable externe qui sera modifiée. <br><br>  Si le corps de la fonction contient le nom d'une variable externe, ce nom est associé à la valeur qui existait dans l'environnement dans lequel la fonction a été créée.  Si la fonction elle-même est exportée de cet environnement (par exemple, si elle est renvoyée d'une autre fonction en tant que valeur), alors elle «capture» la variable de l'environnement interne, qui n'est plus accessible dans le nouvel environnement.  C'est ce qu'on appelle la fermeture lexicale. <br><br>  Les fermetures sont principalement utiles dans deux situations: lorsque vous devez créer une fonction en fonction des paramètres donnés et lorsque vous avez besoin d'une fonction ayant un état interne. <br><br>  Considérez la situation avec une fonction qui encapsule un état interne: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f_with_counter(fn) call_count = <span class="hljs-number"><span class="hljs-number">0</span></span> ncalls() = call_count <span class="hljs-comment"><span class="hljs-comment"># invoke()  ,     #    ,  ncalls() function invoke(args...) call_count += 1 fn(args...) end #         # call_count     , #   invoke()  call_count()        (call = invoke, call_count = ncalls) end julia&gt; abscount = f_with_counter(abs) (call = getfield(Main, Symbol("#invoke#22")){typeof(abs)}(abs, Core.Box(0)), call_count = getfield(Main, Symbol("#ncalls#21"))(Core.Box(0))) julia&gt; abscount.call_count() 0 julia&gt; abscount.call(-20) 20 julia&gt; abscount.call_count() 1 julia&gt; abscount.call(im) 1.0 julia&gt; abscount.call_count() 2</span></span></code> </pre><br><h4>  Etude de cas: tous les mêmes polynômes </h4><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> la présentation des polynômes en tant que structures est considérée.  En particulier, l'une des structures de stockage est une liste de coefficients, en commençant par les plus jeunes.  Pour calculer le polynôme <code>p</code> au point <code>x</code> proposé d'appeler la fonction <code>evpoly(p, x)</code> , qui calcule le polynôme selon le schéma de Horner. <br><br><div class="spoiler">  <b class="spoiler_title">Code pleine définition</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> AbstractPolynomial <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form --- Polynomial(v::T) where T&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}) Construct a `Polynomial` from the list of the coefficients. The coefficients are assumed to go from power 0 in the ascending order. If an empty collection is provided, the constructor returns a zero polynomial. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) coeff = isempty(v) ? (<span class="hljs-number"><span class="hljs-number">0.0</span></span>,) : tuple([<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v]...) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new(length(coeff)-<span class="hljs-number"><span class="hljs-number">1</span></span>, coeff) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form --- InterpPolynomial(xsample::Vector{&lt;:Real}, fsample::Vector{&lt;:Real}) Construct an `InterpPolynomial` from a vector of points `xsample` and corresponding function values `fsample`. All values in `xsample` must be distinct. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> InterpPolynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> xval::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(xsample::X, fsample::F) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {X&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}, F&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !allunique(xsample) throw(<span class="hljs-built_in"><span class="hljs-built_in">DomainError</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot interpolate with duplicate X points"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> N = length(xsample) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length(fsample) != N throw(<span class="hljs-built_in"><span class="hljs-built_in">DomainError</span></span>(<span class="hljs-string"><span class="hljs-string">"Lengths of X and F are not the same"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> coeff = [<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fsample] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>:N <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>:(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) coeff[i] = (coeff[j] - coeff[i]) / (xsample[j] - xsample[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> new(N-<span class="hljs-number"><span class="hljs-number">1</span></span>, ntuple(i -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(xsample[i]), N), tuple(coeff...)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} InterpPolynomial(xsample, map(fn, xsample)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::Polynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = p.coeff[idx] + z * ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::InterpPolynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[p.degree+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = ans * (z - p.xval[idx]) + p.coeff[idx] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.:+(p1::Polynomial, p2::Polynomial) <span class="hljs-comment"><span class="hljs-comment">#    ,      deg = max(p1.degree, p2.degree) coeff = zeros(deg+1) coeff[1:p1.degree+1] .+= p1.coeff coeff[1:p2.degree+1] .+= p2.coeff Polynomial(coeff) end function Base.:+(p1::InterpPolynomial, p2::InterpPolynomial) xmax = max(p1.xval..., p2.xval...) xmin = min(p1.xval..., p2.xval...) deg = max(p1.degree, p2.degree) #         #       xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * π / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * π / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::InterpPolynomial, p2::Polynomial) xmax = max(p1.xval...) xmin = min(p1.xval...) deg = max(p1.degree, p2.degree) xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * π / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * π / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::Polynomial, p2::InterpPolynomial) p2 + p1 end</span></span></code> </pre><br></div></div><br>  La représentation d'un polynôme sous la forme d'une structure ne correspond pas entièrement à sa compréhension intuitive en tant que fonction mathématique.  Mais en renvoyant la valeur fonctionnelle, les polynômes peuvent également être spécifiés directement en tant que fonctions.  C'était donc: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ≡ 0 coeff = isempty(v) ? (0.0,) : tuple([Float64(x) for x in v]...) #   -   new #  -    return new(length(coeff)-1, coeff) end end """ evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """ function evpoly(p::Polynomial, z::Real) ans = p.coeff[end] for idx = p.degree:-1:1 ans = p.coeff[idx] + z * ans end return ans end</span></span></code> </pre><br>  Nous transformons cette définition en une fonction qui prend un tableau / tuple de coefficients et renvoie la fonction réelle qui calcule le polynôme: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial_as_closure(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ≡ 0 if isempty(v) return x::Real -&gt; 0.0 end coeff = tuple(map(float, v)...) degree = length(coeff) - 1 function evpoly(z::Real) ans = coeff[end] for idx = degree:-1:1 ans = coeff[idx] + z * ans end return ans end evpoly end julia&gt; p = Polynomial_as_closure((0, 1, 1)) # x² + x (::getfield(Main, Symbol("#evpoly#28")){Tuple{Float64,Float64,Float64},Int64}) (generic function with 1 method) julia&gt; p(1) # ,    evpoly()! 2.0 julia&gt; p(11) 132.0</span></span></code> </pre><br>  De même, vous pouvez écrire une fonction pour le polynôme d'interpolation. <br><br>  Une question importante: y avait-il quelque chose qui était perdu dans la nouvelle définition de la définition précédente?  Malheureusement, oui - définir le polynôme comme une structure a donné des indications pour le compilateur, et pour nous, la capacité de surcharger les opérateurs arithmétiques pour cette structure.  Hélas, Julia ne prévoit pas les fonctions d'un système de type aussi puissant. <br><br>  Heureusement, dans ce cas, nous pouvons prendre le meilleur des deux mondes, car Julia vous permet de créer des structures appelables.  C'est-à-dire  Vous pouvez spécifier un polynôme comme structure, mais pouvoir l'appeler comme fonction!  Aux définitions des structures de l'article précédent, il suffit d'ajouter: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (p::Polynomial)(z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) evpoly(p, z) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (p::InterpPolynomial)(z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) evpoly(p, z) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  À l'aide d'arguments fonctionnels, vous pouvez également ajouter un constructeur externe d'un polynôme d'interpolation pour une certaine fonction construite à partir d'un ensemble de points: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} InterpPolynomial(xsample, map(fn, xsample)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Nous vérifions la définition</b> <div class="spoiler_text"><pre> <code class="julia hljs">julia&gt; psin = InterpPolynomial(sin, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>*<span class="hljs-literal"><span class="hljs-literal">π</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-literal"><span class="hljs-literal">π</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#   InterpPolynomial(4, (0.0, 0.5235987755982988, 1.5707963267948966, 2.6179938779914944, 3.141592653589793), (0.0, 0.954929658551372, -0.30396355092701327, -0.05805276197975913, 0.036957536116863636)) julia&gt; pcos = InterpPolynomial(cos, [0, π/6, π/2, 5*π/6, π]) #   InterpPolynomial(4, (0.0, 0.5235987755982988, 1.5707963267948966, 2.6179938779914944, 3.141592653589793), (1.0, -0.2558726308373678, -0.36358673785585766, 0.1388799037738005, 5.300924469105863e-17)) julia&gt; psum = pcos + psin InterpPolynomial(4, (3.141592653589793, 2.5416018461576297, 1.5707963267948966, 0.5999908074321635, 0.0), (-1.0, -1.2354929267138448, 0.03888175053443867, 0.1969326657535598, 0.03695753611686364)) julia&gt; for x = range(0, π, length = 20) println("Error at x = ", x, ": ", abs(psum(x) - (sin(x) + cos(x)))) end Error at x = 0.0: 0.0 Error at x = 0.3490658503988659: 0.002748366490382681 Error at x = 0.6981317007977318: 0.0031870524474437723 Error at x = 1.0471975511965976: 0.006538414090220712 Error at x = 1.3962634015954636: 0.0033647273630357244 Error at x = 1.7453292519943295: 0.003570894863996865 Error at x = 2.0943951023931953: 0.007820939854677023 Error at x = 2.443460952792061: 0.004305934583281101 Error at x = 2.792526803190927: 0.00420977797025246 Error at x = 3.141592653589793: 1.1102230246251565e-16</span></span></code> </pre><br></div></div><br><h4>  Conclusion </h4><br>  Les opportunités empruntées à la programmation fonctionnelle dans Julia donnent un langage plus expressif par rapport à un style purement impératif.  La représentation des structures sous forme de fonctions est un moyen d'enregistrement plus pratique et naturel des concepts mathématiques. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451172/">https://habr.com/ru/post/fr451172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451160/index.html">Apache Kafka et le streaming avec Spark Streaming</a></li>
<li><a href="../fr451162/index.html">Correction d'erreurs - Constantes physiques dans les versions actuelles et nouvelles du système international d'unités (SI)</a></li>
<li><a href="../fr451164/index.html">Vous cherchez un espace de stationnement gratuit avec Python</a></li>
<li><a href="../fr451166/index.html">Qu'offriront les nouveaux référentiels pour les systèmes AI et MO?</a></li>
<li><a href="../fr451170/index.html">Jeff Bezos a annoncé son intention de conquérir la lune</a></li>
<li><a href="../fr451174/index.html">Adaptation de programmes pour ZX Spectrum à TR-DOS par des moyens modernes. Partie 1</a></li>
<li><a href="../fr451176/index.html">Nouvelles du monde d'OpenStreetMap n ° 458 (23/04/2019 - 09/09/2019)</a></li>
<li><a href="../fr451178/index.html">Essai de collision de l'atterrissage du parachute de l'équipage du dragon</a></li>
<li><a href="../fr451180/index.html">PCB remplace deux moteurs linéaires</a></li>
<li><a href="../fr451182/index.html">Comment les tailles des tableaux C sont devenues une partie de l'interface binaire de la bibliothèque</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>