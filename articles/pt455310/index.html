<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã ü•ú ‚è¨ Ataques em canais de desvio: agora n√£o apenas os PCs, mas tamb√©m os smartphones est√£o sob ataque (revis√£o anal√≠tica) üßöüèº üò± üßò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Embora os dispositivos m√≥veis sejam cada vez mais demandados e os ataques aos canais de desvio de mem√≥ria de cache (a seguir denominados ataques de ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ataques em canais de desvio: agora n√£o apenas os PCs, mas tamb√©m os smartphones est√£o sob ataque (revis√£o anal√≠tica)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455310/"><p>  Embora os dispositivos m√≥veis sejam cada vez mais demandados e os ataques aos canais de desvio de mem√≥ria de cache (a seguir denominados ataques de cache) sejam uma maneira poderosa de quebrar os eletr√¥nicos modernos dos microprocessadores, at√© 2016, havia apenas algumas publica√ß√µes sobre a aplicabilidade desses ataques a smartphones .  Al√©m disso, essas primeiras publica√ß√µes limitaram-se a considerar ataques √† tabela AES e n√£o abordaram m√©todos mais modernos de ataques internucleares: Prime + Probe [6], Flush + Reload [6], Evict + Reload [7], Flush + Flush [8], Rowhammer [ 9]  Al√©m disso, at√© 2016, acreditava-se que ataques de cache internuclear s√≥ podiam ser realizados nas plataformas Intel e AMD, mas recentemente eles tamb√©m foram realizados em plataformas ARM (em smartphones e outros dispositivos m√≥veis).  [6] </p><br><p>  Nos √∫ltimos anos, houve um aumento no interesse de especialistas em seguran√ßa cibern√©tica - para armazenar em cache ataques a smartphones.  Este artigo √© uma revis√£o anal√≠tica das principais descobertas nessa √°rea para o per√≠odo de 2015 a 2017. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Hist√≥ria dos canais de deriva√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Por que ataques de cache no ARM s√£o t√£o √∫nicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Variedades de ataques de cache</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - Despejar + tempo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - Sonda + Prime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - Liberar + recarregar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - Despejar + Recarregar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - Flush + Flush</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- - AnC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Efeito Rowhammer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Desduplica√ß√£o de mem√≥ria do sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Pseudo-isolamento do kernel do sistema operacional</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Canais ocultos internucleares e interprocessadores</a> </p><br><p><img src="https://habrastorage.org/webt/ys/jo/7g/ysjo7gybyvqu-okdlkrkilqrnrw.jpeg"></p><a name="habracut"></a><br><p>  Quanto aos ataques de cache nas tabelas AES, embora j√° se saiba h√° algum tempo que esses ataques s√£o <em>poss√≠veis</em> , a implementa√ß√£o vulner√°vel das tabelas AES ainda √© usada como o padr√£o de fato;  inclusive em modernos dispositivos criptografados incorporados, como cart√µes SIM.  Por exemplo, redes 3G / 4G usam o algoritmo de autentica√ß√£o AES MILENAGE.  Seu compromisso permite clonar cart√µes USIM e escutar conversas.  T.O.  os ataques de cache nos canais de desvio s√£o relevantes para os cart√µes SIM (usados ‚Äã‚Äãpara acessar a rede 2G) e cart√µes USIM (usados ‚Äã‚Äãpara acessar redes 3G / 4G).  Em 2015, foi descrito o ‚Äúataque de energia diferencial‚Äù (DPA) - um ataque que recupera chaves de criptografia (usadas pelo algoritmo MILENAGE) e outros segredos do cart√£o USIM em apenas alguns minutos.  [3] </p><br><a name="a1"></a><br><h1 id="istoriya-obhodnyh-kanalov">  Hist√≥ria dos canais de desvio </h1><br><ul><li>  √Ä medida que a complexidade do software aumenta e o n√∫mero de prote√ß√µes avan√ßadas de software, a invas√£o do sistema no n√≠vel do hardware, em particular o uso de ataques de cache nos canais de desvio, est√° se tornando uma alternativa cada vez mais atraente.  Esses ataques s√£o baseados em vulnerabilidades encontradas na arquitetura de mem√≥ria do processador.  [4] </li><li>  Em 1985, foi introduzida a tecnologia de leitura de informa√ß√µes em v√≠deos - medindo a interfer√™ncia eletromagn√©tica induzida por eles [10].  Com base nessa tecnologia, em 2014 foi desenvolvido um keylogger - constru√≠do com base em um smartphone e antena de r√°dio.  [12] </li><li>  Em 1996, foi demonstrado que, medindo cuidadosamente a quantidade de tempo gasto executando opera√ß√µes com chaves privadas, v√°rios sistemas criptogr√°ficos, como a cifra DES, podem ser invadidos.  Em 2016, foi demonstrado pela primeira vez o ataque aos canais de desvio em um dispositivo de criptografia usando criptografia el√≠ptica avan√ßada;  durante o ataque, a chave secreta de descriptografia foi extra√≠da do dispositivo de destino localizado em outra sala.  [13] </li><li>  Em 1997, o "m√©todo de distor√ß√£o diferencial" (DFA) foi introduzido - um ataque que usa v√°rios modelos de micro-falhas, bem como v√°rios m√©todos de an√°lise criptogr√°fica;  restaurar configura√ß√µes secretas de cart√µes inteligentes e outros dispositivos protegidos contra acesso n√£o autorizado.  [11] Tendo acesso f√≠sico ao dispositivo, voc√™ pode alterar a tens√£o de alimenta√ß√£o, a frequ√™ncia do sinal do rel√≥gio;  ou condi√ß√µes ambientais (temperatura, etc.) - para danificar o cart√£o inteligente.  Al√©m disso, o mau funcionamento do equipamento pode ser acionado - mesmo pela interven√ß√£o do software;  e, portanto, isso pode ser feito no modo de acesso remoto. </li><li>  Em 2014, foi demonstrado um ataque a desvios de cache;  esse ataque usa vazamentos de informa√ß√µes causadas pela diferen√ßa no tempo de acesso aos dados, dependendo se eles est√£o no cache ou n√£o;  assim  esse ataque deixa claro em quais dados o c√≥digo sob investiga√ß√£o operou recentemente.  Durante esse ataque, uma recupera√ß√£o completa das chaves AES foi demonstrada.  [9] Um pouco mais tarde, em 2015, foi mostrado que os canais de desvio de cache podem ser usados ‚Äã‚Äãn√£o apenas para atacar sistemas criptogr√°ficos, mas tamb√©m para coletar informa√ß√µes sobre pressionamentos de tecla.  [14] </li><li>  Em 2014, foi demonstrado que o acesso √† mesma c√©lula de mem√≥ria em alta frequ√™ncia pode provocar troca espont√¢nea de bits nos chips DRAM (efeito Rowhammer).  [9] Como a DRAM √© dimensionada para o menor tamanho, n√£o √© f√°cil impedir a interfer√™ncia el√©trica entre c√©lulas individuais.  √â por isso que a ativa√ß√£o de uma determinada linha da mem√≥ria leva √† distor√ß√£o dos dados nas linhas adjacentes. </li><li>  Em 2015, foi demonstrado que o efeito Rowhammer pode ser usado para elevar privil√©gios ao superusu√°rio.  [15] No mesmo ano, foi demonstrado que a troca espont√¢nea de bits pode ser acionada mesmo com o c√≥digo Java carregado no site.  [7] Inicialmente, esse cen√°rio foi implementado apenas para sistemas Intel e AMD usando m√≥dulos DDR3 e DDR4.  [16, 17] No entanto, em 2016, esse ataque tamb√©m foi demonstrado nas plataformas ARM.  [1] No mesmo ano, foi demonstrado que ataques de cache tamb√©m podem ser usados ‚Äã‚Äãpara monitorar a atividade de cache no TrustZone.  [1] </li><li>  Em 2016, foi realizada a "engenharia reversa" para as fun√ß√µes de endere√ßamento DRAM comumente usadas em smartphones modernos.  Como resultado, foram descobertas maneiras adicionais de alternar bits dispon√≠veis para implementa√ß√£o em milh√µes de dispositivos Android, sem a necessidade de trabalhar no modo privilegiado.  [1] </li><li>  Em 2016, o ataque no √∫ltimo n√≠vel do cache do processador ARM foi demonstrado pela primeira vez.  Esse ataque pode ser implementado para ataques de cache internuclear e entre processos nos canais de desvio.  [1] </li></ul><br><a name="a2"></a><br><h1 id="chem-tak-unikalny-kesh-ataki-na-arm">  Por que os ataques de cache no ARM s√£o t√£o √∫nicos </h1><br><ul><li>  M√©todos de ataque, como Flush + Reload e Flush + Flush - use a instru√ß√£o de redefini√ß√£o de privil√©gio x86 clflush para remover uma linha de dados do cache.  No entanto, com exce√ß√£o dos processadores ARMv8-A, as plataformas ARM n√£o possuem instru√ß√µes de redefini√ß√£o de cache sem privil√©gios;  e, portanto, em 2016, um m√©todo indireto de extrus√£o de cache foi proposto usando o efeito Rowhammer.  [1] </li><li>  Para realizar um ataque bem-sucedido ao cache, s√£o necess√°rias informa√ß√µes como o tempo exato do ciclo de acesso a uma c√©lula de mem√≥ria.  Os ataques anteriores ao cache usavam contadores de desempenho do sistema para esses fins, mas esse m√©todo √© ineficiente, pois esses contadores nos processadores ARM est√£o dispon√≠veis apenas no modo privilegiado.  No entanto, em 2016, foram propostas tr√™s fontes alternativas de sincroniza√ß√£o, incluindo as dispon√≠veis no modo n√£o privilegiado.  [1] Um deles √© o lan√ßamento de um fluxo de sincroniza√ß√£o paralelo, que incrementa continuamente uma vari√°vel global.  Ao ler o valor dessa vari√°vel, um invasor pode medir o tempo de ciclo do acesso a uma c√©lula de mem√≥ria. </li><li>  Al√©m disso, o chamado.  pol√≠tica de substitui√ß√£o pseudo-aleat√≥ria, como resultado do qual a exclus√£o do cache √© menos previs√≠vel do que nos processadores Intel e AMD.  No entanto, em 2016, um ataque de cache eficaz foi demonstrado mesmo em condi√ß√µes t√£o barulhentas - para tr√™s smartphones: ‚ÄúOnePlus One‚Äù (usa ‚ÄúSnapdragon 801 SoC‚Äù com processador ‚ÄúKrait 400‚Äù da arquitetura ARMv7-A), ‚ÄúAlcatel One Touch Pop 2 ‚Äù(usa o‚Äú Snapdragon 410 SoC ‚Äùcom o processador‚Äú CortexA53 ‚Äùda arquitetura ARMv8-A),‚Äú Samsung Galaxy S6 ‚Äù(usa o‚Äú Samsung Exynos 7 Octa 7420 SoC ‚Äùcom dois conjuntos de processadores‚Äú ARMv8-A ‚Äù).  [1] </li></ul><br><a name="a3"></a><br><h1 id="raznovidnosti-kesh-atak">  Variedades de ataques de cache </h1><br><ul><li>  Em geral, um ataque de cache nos canais de deriva√ß√£o pode ser dividido em tr√™s est√°gios: 1) identifica√ß√£o do sinal microarquitetural ‚Äúinfiltrando‚Äù do sistema eletr√¥nico ‚Äúcom vazamento‚Äù;  Exemplos t√≠picos desses sinais microarquiteturais com vazamentos s√£o o consumo de energia e a radia√ß√£o eletromagn√©tica de circuitos integrados.  [2, 3];  2) monitoramento e an√°lise desse sinal durante a opera√ß√£o do sistema;  3) a identifica√ß√£o do sinal microarquitetural das diferen√ßas de padr√£o.  [2] <a name="a31"></a></li><li>  <strong>Despejar + tempo.</strong>  A id√©ia b√°sica √© determinar quais conjuntos de cache o programa v√≠tima est√° acessando.  Algoritmo: 1) mede o tempo de execu√ß√£o do programa da v√≠tima;  2) deslocar uma certa parte do cache;  3) medir o tempo de execu√ß√£o do programa v√≠tima novamente.  Usando a diferen√ßa de hor√°rio entre as duas dimens√µes, √© poss√≠vel determinar quanto tempo uma certa parte do cache foi usada pela v√≠tima em tempo de execu√ß√£o.  Em 2010, um tipo poderoso de ataque baseado no Evict + Time foi demonstrado - contra o AES no OpenSSL;  sem a necessidade de textos abertos e criptografados.  [18, 19] <a name="a32"></a></li><li>  <strong>Prime + Probe.</strong>  Esse m√©todo - como o anterior - permite que um invasor determine quais conjuntos de cache o programa v√≠tima est√° acessando.  Algoritmo: 1) preenche uma certa parte do cache;  2) transferir o controle para o programa da v√≠tima;  3) determine qual parte do cache completo ainda nos pertence.  Isso pode ser feito medindo o tempo de acesso aos endere√ßos que o invasor usou para preencher o cache no primeiro est√°gio.  T.O.  se o programa v√≠tima usar endere√ßos mapeados para as mesmas √°reas do cache que o invasor, for√ßar√° os dados do invasor a sair do cache;  e um invasor pode rastrear isso no terceiro est√°gio.  Em [19], um ataque usando esse mecanismo foi demonstrado - no OpenSSL AES e no Linux dm-crypt.  Em 2015 [20], foi demonstrado como, usando o Prime + Probe, voc√™ pode montar o canal secreto internuclear e entre m√°quinas e atacar ElGamal no GnuPG.  No mesmo ano, foi demonstrado um ataque bem-sucedido √† implementa√ß√£o do OpenSSL AES na nuvem.  [21] <a name="a33"></a></li><li>  <strong>Liberar + Recarregar.</strong>  Em 2011 [22], foi mostrado como o clflush pode ser usado para atacar o AES.  Clflush √© usado para empurrar uma c√©lula de mem√≥ria rastreada para fora do cache;  seguido por verificar se essa c√©lula foi recarregada no cache ap√≥s o programa v√≠tima executar um pequeno n√∫mero de instru√ß√µes.  Algoritmo: 1) Projete um bin√°rio (por exemplo, um objeto compartilhado) em seu espa√ßo de endere√ßo (usando uma chamada de sistema apropriada, como mmap);  2) expulsa a linha do cache (c√≥digo ou dados) do cache;  3) transferir o controle para o programa da v√≠tima;  4) verifique se esta linha de cache (da cl√°usula 2) foi carregada pelo programa v√≠tima (essa verifica√ß√£o √© realizada medindo o tempo de acesso √† c√©lula de mem√≥ria).  Em 2014, a restaura√ß√£o completa da chave secreta do AES na m√°quina virtual VMWare foi demonstrada atrav√©s de um ataque de cache Flush + Reload.  [23] No mesmo ano, usando o mesmo ataque, foi demonstrada a restaura√ß√£o da chave secreta do algoritmo OpenSSL ECDSA (algoritmo de assinatura digital baseado em curvas el√≠pticas).  [24] Em 2015, atrav√©s do ataque Flush + Reload, o mecanismo do sistema de ‚Äúdesduplica√ß√£o de mem√≥ria‚Äù foi comprometido;  como resultado, a possibilidade de comunica√ß√£o n√£o autorizada entre m√°quinas virtuais em execu√ß√£o em uma m√°quina f√≠sica comum.  [25] No mesmo ano, foi demonstrado como usar Flush + Reload para obter informa√ß√µes sobre quais bibliotecas criptogr√°ficas s√£o usadas por v√°rias m√°quinas virtuais em execu√ß√£o em uma m√°quina f√≠sica comum.  [26] Em 2015, tamb√©m foi demonstrado que, al√©m de atacar sistemas criptogr√°ficos, o m√©todo Flush + Reload tamb√©m pode ser usado para um keylogger.  [14] <a name="a34"></a></li><li>  <strong>Despejar + Recarregar.</strong>  Foi introduzido em 2015 [14].  Usa Flush + Reload para extrus√£o - em vez de instru√ß√µes de extrus√£o.  Embora esse ataque n√£o fa√ßa sentido para o x86 (como o clflush n√£o precisa de privil√©gios), √© muito relevante para os processadores ARM (j√° que essa instru√ß√£o est√° dispon√≠vel apenas no modo privilegiado).  A ess√™ncia do Evict + Reload √© que, para espremer a c√©lula desejada do cache, enchemos o cache com um grande n√∫mero de endere√ßos interconectados, como resultado do qual o mecanismo respons√°vel pela exclus√£o decide espremer a c√©lula de cache que precisamos.  Al√©m disso, em 2016, foi demonstrado que uma estrat√©gia preventiva eficiente e r√°pida pode iniciar a troca espont√¢nea de bits em linhas adjacentes dos m√≥dulos DRAM (como resultado do acesso m√∫ltiplo √† mesma linha de mem√≥ria) usando applets escritos em JavaScript.  [24] Assim  ataques de cache n√£o dependem mais de instru√ß√µes privilegiadas de limpeza de cache, como clflush. <a name="a35"></a></li><li>  <strong>Flush + Flush.</strong>  Os ataques Flush + Reload e Prime + Probe causam v√°rios acessos ao cache, cuja dura√ß√£o pode ser medida (atrav√©s dos contadores de desempenho do sistema).  O ataque Flush + Flush, lan√ßado em 2015, √© precisamente baseado nessas observa√ß√µes.  [8] O ataque √© quase o mesmo que Flush + Reload.  Um objeto de arquivo bin√°rio ou dividido √© mapeado para o espa√ßo de endere√ßo do invasor.  A c√©lula de mem√≥ria √© for√ßada a sair do cache e o controle √© transferido para o programa v√≠tima.  No entanto, em vez do est√°gio de reinicializa√ß√£o, onde a c√©lula que estamos observando est√° sendo acessada, ela √© novamente substitu√≠da;  sem causar erros, em compara√ß√£o com Flush + Reload ou Prime + Probe.  T.O.  √â f√°cil saber se um local de mem√≥ria est√° armazenado em cache ou n√£o. <a name="a36"></a></li><li>  <strong>AnC.</strong>  Esta √© uma modifica√ß√£o mais recente do ataque de cache "Evict + Time", lan√ßado em 2017.  [4] Uma caracter√≠stica distintiva do AnC √© que esse ataque de cache depende da an√°lise de tabelas de p√°ginas em cache, usadas na maioria dos processadores modernos (Intel, AMD, ARM).  [4] Hoje, no cora√ß√£o de qualquer processador est√° uma "unidade de gerenciamento de mem√≥ria" (MMU), que simplifica o gerenciamento da mem√≥ria f√≠sica dispon√≠vel - atrav√©s de sua virtualiza√ß√£o;  para uso subseq√ºente por v√°rios processos.  A MMU usa a estrutura de dados da "tabela de p√°ginas" para mapear c√©lulas de mem√≥ria f√≠sica e virtual.  Tabelas de p√°ginas √© um alvo atraente para ataques de hardware.  Por exemplo, altern√¢ncia espont√¢nea de apenas um bit (causado pelo efeito Rowhammer) na "tabela de p√°ginas" - pode ser suficiente para o invasor obter controle sobre o endere√ßo f√≠sico da mem√≥ria √† qual ele n√£o deve receber acesso;  e isso pode ser suficiente para obter privil√©gios de superusu√°rio.  [4] </li></ul><br><a name="a4"></a><br><h1 id="effekt-rowhammer">  Efeito Rowhammer </h1><br><ul><li>  Um chip DRAM separado tem uma capacidade pequena e, portanto, v√°rios microcircuitos s√£o conectados juntos em uma placa - para formar os chamados  S√©rie DRAM.  Um m√≥dulo de mem√≥ria DRAM pode conter uma ou mais linhas DRAM.  Um chip DRAM consiste em uma matriz bidimensional de c√©lulas.  Cada c√©lula DRAM √© um capacitor;  0 e 1 s√£o o estado carregado ou descarregado do capacitor.  Cada c√©lula da grade √© conectada a uma c√©lula vizinha por fio.  Se alguma c√©lula estiver ativada, a tens√£o ser√° aplicada ao capacitor e a todos os outros capacitores da mesma linha.  Como as c√©lulas de mem√≥ria se tornam cada vez menores e mais pr√≥ximas umas das outras √† medida que o progresso tecnol√≥gico, a interfer√™ncia causada pela ativa√ß√£o de uma linha de mem√≥ria freq√ºentemente afeta as cargas de capacitores das linhas adjacentes.  Em 2014, foi demonstrado [9] que o acesso frequente √† mesma c√©lula de mem√≥ria DRAM leva ao efeito Rowhammer - comuta√ß√£o espont√¢nea de bits.  Este efeito pode ser usado para aumentar privil√©gios (por exemplo, para sair da caixa de prote√ß√£o de seguran√ßa [15]);  ele pode ser implementado, entre outras coisas, como resultado da execu√ß√£o de c√≥digo JavaScript n√£o privilegiado localizado no site. </li><li>  Para "entupir" uma c√©lula de mem√≥ria espec√≠fica, um invasor precisa encontrar dois endere√ßos no mesmo banco DRAM - mas em linhas diferentes.  Certos bits de endere√ßo s√£o usados ‚Äã‚Äãpara selecionar a linha, canal e banco da localiza√ß√£o da mem√≥ria.  No entanto, como a fun√ß√£o de amostragem funciona n√£o est√° documentada.  Portanto, em 2015 [27] foi introduzido um mecanismo para a automa√ß√£o completa da engenharia reversa da fun√ß√£o correspondente;  usando o fato de que "conflitos de string" levam a um aumento no tempo de acesso √† mem√≥ria.  A ess√™ncia da abordagem usada √© procurar endere√ßos mapeados para o mesmo banco DRAM, mas em uma linha diferente;  medindo repetidamente o tempo de acesso a dois endere√ßos aleat√≥rios.  Para alguns pares de endere√ßos, o tempo de acesso √© maior que para outros - isso significa que eles pertencem a linhas diferentes, mas ao mesmo banco.  Em seguida, esses endere√ßos s√£o agrupados em conjuntos com o mesmo canal, linha e banco.  Esses endere√ßos identificados s√£o ent√£o usados ‚Äã‚Äãpara reconstruir a fun√ß√£o de endere√ßamento - gerando todas as fun√ß√µes lineares e aplicando-as a todos os endere√ßos de um subconjunto selecionado arbitrariamente.  T.O.  Como o espa√ßo de pesquisa √© pequeno, a for√ßa bruta √© muito eficaz aqui.  [1] </li><li>  As primeiras implementa√ß√µes de ataques usando o efeito Rowhammer se baseavam em m√©todos probabil√≠sticos (devido aos quais uma falha n√£o planejada do sistema poderia ocorrer durante o ataque);  ou fun√ß√µes especializadas de gerenciamento de mem√≥ria: desduplica√ß√£o de mem√≥ria, paravirtualiza√ß√£o de MMU, interface de mapa de p√°gina.  No entanto, essas fun√ß√µes em dispositivos modernos ou n√£o est√£o dispon√≠veis ou desativadas por motivos de seguran√ßa.  [30] </li><li>  Portanto, em 2016, o ataque do Drammer foi introduzido - livre das desvantagens e limita√ß√µes listadas.  Ele depende apenas dos recursos atuais dos sistemas operacionais modernos, dispon√≠veis sem direitos de superusu√°rio.  Em particular, o comportamento previs√≠vel do subsistema de distribui√ß√£o da mem√≥ria f√≠sica.  Essa previsibilidade √© usada para obter a distribui√ß√£o da mem√≥ria f√≠sica (na qual os dados confidenciais ser√£o processados, como tabelas de p√°ginas da mem√≥ria) em um local vulner√°vel da mem√≥ria f√≠sica escolhida pelo invasor.  A t√©cnica correspondente de "massagear a mem√≥ria" foi chamada de Phys Feng Shui.  Para demonstrar a operacionalidade do ataque Drammer, √© fornecida uma implementa√ß√£o de explora√ß√£o que fornece acesso ao diret√≥rio raiz de um dispositivo Android.  Essa explora√ß√£o pode ser iniciada por qualquer aplicativo sem permiss√£o especial;  e sem explorar nenhuma vulnerabilidade de software.  [30] </li><li>  T.O.    Drammer  ,      Rowhammer       (   Intel  AMD),      (  ARM-);   ,           . [30] </li><li>  2016     ¬´ ¬ª Flip Feng Shui (FFS) ‚Äì     Rowhammer,            ;       ;         .     FFS    ,    Ubuntu/Debian. [31] </li><li>  2017   ,   MLC NAND  -,      SSD-, ‚Äì   ,   Rowhammer.            .      ‚Äì    . [5] </li></ul><br><a name="a5"></a><br><h1 id="dedublikaciya-sistemnoy-pamyati">    </h1><br><ul><li>   -          ;       .      ,    ;          .  [1] </li><li>   ( ) ‚Äì    ,      ,             .          (      ‚Äì   ,     ).   ,        ‚Äì         ,        .                  ‚Äì      .  [1] </li><li>   ‚Äì          ;        Windows 8.1  10.          ‚Äì    ,     ¬´  ¬ª.       ‚Äì          .      ,        ,      .  ,      ¬´ ¬ª,         ,     . ,      ,      ,       . [35] </li><li>  2016   ,          ‚Äì        .      . -,  ,        , ‚Äì       ;        (,  64- ). -,  ,      ,      ,         . -,  ,            ,     -  ‚Äì         . [35] </li><li>           ,    JavaScript-    Microsoft Edge ‚Äì            .            ;      .  ,    - ngnix  ,      ,     :             ,      . [35] </li><li> ..           .      ,    ,          . [35] </li></ul><br><a name="a6"></a><br><h1 id="psevdoizolyaciya-yadra-operacionnoy-sistemy">     </h1><br><ul><li> ASLR (   )    (    )       .   ¬´¬ª       ,     .  ,    ¬´ ¬ª   ,                .      ,     ASLR ‚Äì -  . [33] </li><li>   2016       ASLR      32-  64-  Linux,      ¬´ ¬ª.      ,          ,     ‚Äì      .        . .. ASLR     . [33] </li><li>      ASLR ‚Äì      ,     ,   .. ¬´- ¬ª (ROP).  ,   ,      ,  ,        .           . [37] </li><li>   2017      KAISER,    ,          .     ,     , ‚Äì      ,     . [37]  , KAISER      BTB (  ),   2016 . [36] </li><li>  2016        (BTB). BTB-   30    .       -,    BTB, ‚Äì     .       ,    30- ,    ‚Äì        .     ,        ,      . BTB-         .          ,   Intel Skylake (Intel Skylake i7-6700K),         .     . [36] </li><li>   2017   ,  ,              -     . [34] </li></ul><br><a name="a7"></a><br><h1 id="mezhyadernye-i-mezhprocessornye-skrytye-kanaly">      </h1><br><ul><li>       .    -        ‚Äì    ,     .   ,              . [29] </li><li> -        - ‚Äì   ;  Flush+Reload, Evict+Reload  Flush+Flush.             -    .      ¬´¬ª    ¬´ ¬ª.    Android     ,        , ‚Äì        ;     (.  [28]). ..     . </li><li>       ,         -  .      ‚Äì        . ,  -    ,   ,   ,  .  [1]     ;      ;   ¬´ ¬ª  ¬´ ¬ª,      ;     .  -  TCP   . </li><li>  2017          ,    SSH,      (45 /);               .   SSH-,    ,   ,    telnet-. [29] </li><li>  2015           ,         .              ‚Äì       (    ,       ),                .            . [32] </li><li>      ,       .     . -,            ;       ,      ; ..        ,      . -,         (       ). [32] </li><li> ,       ,               (16 ).  ,   ¬´ ¬ª   Intel Xeon (    8 )  12,5/.         5   4 . [32] </li><li>   2015          ,           .  ,            ,            ‚Äì        . [32] </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em 2016, foi introduzida uma nova implementa√ß√£o do canal oculto no Android, que funciona 250 vezes mais r√°pido do que qualquer outra implementa√ß√£o proposta anteriormente. </font></font> [1] </li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliografia</font></font></b> <div class="spoiler_text"><p> <strong>1.</strong> <em>Moritz Lipp, Daniel Gruss.</em>  ARMageddon: ataques de cache em dispositivos m√≥veis // Anais do 25¬∫ Simp√≥sio de Seguran√ßa da USENIX.  2016. pp.  549-564. <br>  <strong>2.</strong> <em>Robert Callan.</em>  Metodologia pr√°tica para medir o sinal de canal lateral dispon√≠vel ao atacante para eventos em n√≠vel de instru√ß√£o // 47¬∫ Simp√≥sio Anual Internacional de Microarquitetura da IEEE / ACM (MICRO), p√°ginas 242-254, dezembro de 2014. <br>  <strong>3.</strong> <em>Junrong Liu.</em>  Pequenos ajustes n√£o ajudam: An√°lise de pot√™ncia diferencial de implementa√ß√µes MILENAGE em cart√µes USIM 3G / 4G.  BlackHat 2015. <br>  <strong>4.</strong> <em>Herbert Bos, Ben Gras.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cache de tabela de p√°gina de hardware de engenharia reversa usando ataques de canal lateral na MMU</a> .  2017. <br>  <strong>5.</strong> <em>Yu Cai, Saugata Ghose.</em>  Vulnerabilidades na programa√ß√£o de mem√≥ria flash MLC NAND: t√©cnicas de an√°lise experimental, explora√ß√£o e mitiga√ß√£o // 23¬∫ Simp√≥sio IEEE sobre arquitetura de computadores de alto desempenho, Sess√£o industrial, fevereiro de 2017. <br>  <strong>6.</strong> <em>Falkner Katrina.</em>  Flush + Reload: Um ataque de canal lateral de cache L3 de alta resolu√ß√£o e baixo n√≠vel de ru√≠do // Anais do 23¬∫ Simp√≥sio de Seguran√ßa da USENIX.  2014. pp.  719-732. <br>  <strong>7.</strong> <em>Gruss Daniel, Maurice Clementine M angard, Stefan.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rowhammer.js: um ataque remoto induzido por software em JavaScript</a> .  2016. <br>  <strong>8.</strong> <em>Gruss Daniel, Wagner Klaus.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flush + Flush: um ataque de cache de √∫ltimo n√≠vel mais furtivo</a> .  2015. <br>  <strong>9.</strong> <em>Kim Yoongu, Daly Ross.</em>  Lan√ßando bits na mem√≥ria sem acess√°-los: um estudo experimental de erros de perturba√ß√£o de DRAM // Processo do 41¬∫ Simp√≥sio Anual Internacional de Arquitetura de Computadores.  Piscataway, NJ, EUA: IEEE Press, 2012 (ISCA '14). <br>  <strong>10.</strong> <em>Eck Wim.</em>  Radia√ß√£o eletromagn√©tica das unidades de exibi√ß√£o de v√≠deo: um risco de espionagem?  // Computadores e seguran√ßa.  N√£o.  4, 1985. pp.  269-286. <br>  <strong>11.</strong> <em>Biham Eli, Shamir Adi.</em>  An√°lise diferencial de falhas do sistema de criptografia de chave secreta // Avan√ßos na criptografia - CRYPTO '97 Bd.  1294 <br>  <strong>12.</strong> <em>Callan Robert, Zajic Alenka.</em>  Metodologia pr√°tica para medir o sinal de canal lateral dispon√≠vel para o atacante para eventos em n√≠vel de instru√ß√£o // Anais do 47¬∫ Simp√≥sio Anual Internacional de Microarquitetura do IEEE / ACM.  2014. pp.  242-254. <br>  <strong>13.</strong> <em>Genkin Daniel.</em>  Extra√ß√£o de chave ECDH por ataques eletromagn√©ticos de baixa largura de banda em PCs // Cryptology ePrint Archive, Relat√≥rio 2016/129. <br>  <strong>14.</strong> <em>Gruss Daniel.</em>  Ataques de modelo de cache: Automatizando ataques em caches de √∫ltimo n√≠vel inclusivos // Anais do 24¬∫ Simp√≥sio de Seguran√ßa USENIX.  2015. pp.  897-912. <br>  <strong>15.</strong> <em>Marca maritima.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Explorando o bug do DRAM rowhammer para obter privil√©gios de kernel</a> .  2015. <br>  <strong>16.</strong> <em>Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rowhammer bitflips no Skylake com DDR4</a> .  2016. <br>  <strong>17.</strong> <em>Mark Lanteigne.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o Rowhammer pode ser usado para explorar fraquezas no hardware do computador</a> .  2016. <br>  <strong>18.</strong> <em>Osvik Dag, Shamir Adi.</em>  Ataques de cache e contramedidas: o caso da AES // T√≥picos em Criptologia.  2005. pp.  1-20. <br>  <strong>19.</strong> <em>Tromer Eran, Osvik Dag.</em>  Ataques de cache eficientes no AES e contramedidas // Journal of Cryptology.  23 (1), 2010. pp.  37-71. <br>  <strong>20.</strong> <em>Liu Fangfei, Yarom, Yuval.</em>  Os ataques de canal lateral do cache de √∫ltimo n√≠vel s√£o pr√°ticos // Anais do Simp√≥sio IEEE de Seguran√ßa e Privacidade Bd.  2015. pp.  605-622. <br>  <strong>21.</strong> <em>Eisenbarth Thomas.</em>  Um ataque de cache compartilhado que funciona em n√∫cleos e desafia o VM Sandboxing - e seu aplicativo no Simp√≥sio AES // IEEE sobre seguran√ßa e privacidade.  2015. <br>  <strong>22.</strong> <em>Gullasch David, Bangerter Endre.</em>  Jogos em cache - Trazendo ataques de cache baseados em acesso ao AES para a pr√°tica // Procedimentos do Simp√≥sio IEEE sobre seguran√ßa e privacidade.  2011. pp.  490-505. <br>  <strong>23.</strong> <em>Irazoqui Gorka, Inci Mehmet.</em>  Espere um pouco!  Um ataque r√°pido entre VMs no AES // Notas de aula em Ci√™ncia da Computa√ß√£o Bd.  2014. pp.  299-319. <br>  <strong>24.</strong> <em>Yarom Yuval, Benger Naomi.</em>  Recuperando nonces do OpenSSL ECDSA usando o ataque de canal lateral do Flush + Reload Cache // Cryptology ePrint Archive, Relat√≥rio 2014/140 (2014). <br>  <strong>25.</strong> <em>Gulmezoglu Berk, Inci Mehmet.</em>  Um ataque de descarga + recarga mais r√°pido e realista na AES // Anais do 6¬∫ workshop internacional sobre an√°lise construtiva de canais laterais e design seguro.  2015. pp.  111-126. <br>  <strong>26.</strong> <em>Irazoqui Gorka, Inc. Mehmet.</em>  Conhe√ßa o seu vizinho: detec√ß√£o de biblioteca de criptografia na nuvem // Procedimentos das tecnologias de aprimoramento da privacidade.  2015. pp.  25-40. <br>  <strong>27.</strong> <em>Pessl Peter, Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Engenharia reversa Endere√ßamento e explora√ß√£o de DRAM da Intel</a> .  2015. <br>  <strong>28.</strong> <em>Marforio Claudio, Ritzdorf Hubert.</em>  An√°lise da comunica√ß√£o entre aplicativos em conluio em smartphones modernos // Anais da 28¬™ Confer√™ncia Anual de Aplica√ß√µes de Seguran√ßa em Computadores.  2012. pp.  51-60. <br>  <strong>29.</strong> <em>Clementine Maurice, Manuel Webe.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° do outro lado: SSH sobre canais secretos de cache robusto na nuvem</a> .  2017. <br>  <strong>30.</strong> <em>Victor van der Veen, Lindorfer.</em>  Drammer: Ataques determin√≠sticos de Rowhammer em plataformas m√≥veis // Anais da Confer√™ncia ACM SIGSAC de 2016 sobre seguran√ßa de computadores e comunica√ß√µes.  2016. pp.  1675-1689. <br>  <strong>31.</strong> <em>Kaveh Razavi, Ben Gras.</em>  Flip Feng Shui: martelando uma agulha na pilha de software // Anais do 25¬∫ Simp√≥sio de Seguran√ßa da USENIX.  2016. pp.  1-18. <br>  <strong>32.</strong> <em>Ramya Jayaram Masti, Devendra Rai.</em>  Canais encobertos t√©rmicos em plataformas multin√∫cleo // Anais do 24¬∫ Simp√≥sio de Seguran√ßa USENIX.  2015. pp.  865-880. <br>  <strong>33.</strong> <em>Angelos Oikonomopoulos.</em>  Cutucando Buracos em Ocultar Informa√ß√µes // Anais do 25¬∫ Simp√≥sio de Seguran√ßa USENIX.  2016. pp.  121-138. <br>  <strong>34.</strong> <em>Koen Koning.</em>  N√£o h√° necessidade de se esconder: proteger regi√µes seguras em hardware de commodities // Anais da d√©cima segunda confer√™ncia europeia de sistemas de computadores.  2017. pp.  437-452. <br>  <strong>35.</strong> <em>Erik Bosman.</em>  Dedup Est Machina: Desduplica√ß√£o de mem√≥ria como vetor de explora√ß√£o avan√ßada // Anais do Simp√≥sio IEEE de seguran√ßa e privacidade.  2016. pp.  987-1004. <br>  <strong>36.</strong> <em>Evtyushkin, D., Ponomarev, D.</em> Salte sobre o ASLR: Atacando os preditores do ramo para contornar o ASLR // Anais do 49¬∫ Simp√≥sio Internacional de Microarquitetura.  2016. pp.  1-13. <br>  <strong>37.</strong> <em>Daniel Gruss, Moritz Lipp.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KASLR est√° morto: viva o KASLR</a> .  2017. </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455310/">https://habr.com/ru/post/pt455310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455292/index.html">Como aumentar 4 vezes o tempo de execu√ß√£o de dispositivos com alimenta√ß√£o autom√°tica</a></li>
<li><a href="../pt455294/index.html">Guia: como escolher uma bicicleta el√©trica usando o Twitter como exemplo - falando sobre quadros</a></li>
<li><a href="../pt455302/index.html">Estrutura da API Golang</a></li>
<li><a href="../pt455306/index.html">Respostas √†s suas perguntas sobre por que voc√™ precisa de um editor para publicar um livro</a></li>
<li><a href="../pt455308/index.html">Lugar promissor</a></li>
<li><a href="../pt455312/index.html">Adicionador completo de um bit em chips incomuns</a></li>
<li><a href="../pt455314/index.html">O que √© uma rede de servi√ßos</a></li>
<li><a href="../pt455316/index.html">Modificamos a pilha Bluetooth para melhorar o som em fones de ouvido sem codecs AAC, aptX e LDAC</a></li>
<li><a href="../pt455318/index.html">Quais s√£o as √°reas de aplica√ß√£o da impress√£o 3D?</a></li>
<li><a href="../pt455319/index.html">Artista 3D de fluxo de trabalho. Como n√£o se afogar em uma tonelada de informa√ß√µes. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>