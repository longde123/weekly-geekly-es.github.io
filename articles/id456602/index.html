<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♿️ 🔩 🌐 Panduan untuk Menerapkan Langganan yang Dapat Diperbarui Secara Otomatis di Aplikasi iOS 🦅 🙍🏽 ◾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Denis, saya sedang mengembangkan Apphud , layanan untuk analisis langganan yang dapat diperbarui secara otomatis dalam aplika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan untuk Menerapkan Langganan yang Dapat Diperbarui Secara Otomatis di Aplikasi iOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="gambar"></p><br><p>  Halo semuanya!  Nama saya Denis, saya sedang mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apphud</a> , layanan untuk analisis langganan yang dapat diperbarui secara otomatis dalam aplikasi iOS. </p><br><p>  Dalam artikel ini, saya akan memberi tahu Anda cara mengkonfigurasi, menerapkan, dan memvalidasi langganan yang dapat diperbarui secara otomatis di iOS 12 dan iOS 13. Sebagai bonus, saya akan berbicara tentang poin dan jebakan halus yang tidak semua pengembang pertimbangkan. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Siapkan langganan di App Store Connect </h2><br><p>  Jika Anda sudah memiliki Bundle ID dan aplikasi yang dibuat, maka Anda dapat melewati langkah-langkah ini.  Jika Anda membuat aplikasi untuk pertama kalinya, maka lakukan hal berikut: </p><br><p>  Anda harus membuat <em>ID Bundel eksplisit (ID Aplikasi)</em> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Portal Pengembang Apple</a> .  Dengan halaman yang disebut <em>Sertifikat, Identifiers &amp; Profil</em> terbuka, buka tab <em>Identifiers</em> .  Pada Juni 2019, Apple akhirnya memperbarui tata letak portal sesuai dengan ASC (kependekan dari App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="Desain baru untuk Portal Pengembang Apple pada 2019"><br>  <em>Desain baru untuk Portal Pengembang Apple pada 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> ID Bundel eksplisit biasanya ditentukan dalam gaya domain ( <code>com.apphud.subscriptionstest</code> ).  Di bagian <em>Kemampuan</em> , Anda akan melihat bahwa tanda centang di sebelah <em>Pembelian Dalam Aplikasi</em> sudah dicentang.  Setelah membuat <em>Bundel ID</em> ( <em>ID</em> <em>Aplikasi</em> ), pergi ke App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Pengguna uji (pengguna Sandbox) </h3><br><p>  Untuk menguji pembelian di masa mendatang, Anda harus membuat pengguna uji.  Untuk melakukan ini, buka ASC di tab <em>Pengguna dan Akses</em> , lalu ke <em>Penguji Sandbox.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Formulir Pembuatan Kotak Pasir Pengguna"><br>  <em>Formulir Pembuatan Kotak Pasir Pengguna</em> </p><br><blockquote>  Saat membuat tester, Anda dapat menentukan data yang tidak ada, yang paling penting, jangan lupa email dan kata sandi! </blockquote><p>  Saya akan berbicara tentang cara menguji pembelian dengan kredensial pengujian di dekat akhir artikel. </p><br><p>  Langkah penting lainnya adalah menyiapkan kontrak dan data bank di bagian “ <em>Perjanjian, pajak, dan operasi perbankan</em> ”.  Jika Anda tidak memiliki perjanjian untuk aplikasi berbayar, maka Anda tidak akan dapat menguji langganan yang dapat diperpanjang secara otomatis! </p><br><p>  Setelah itu, Anda dapat membuat aplikasi baru di App Store Connect.  Tentukan nama unik dan pilih <em>ID Bundel</em> Anda sebagai <em>ID</em> paket. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="ID Paket adalah ID Bundel Anda"><br>  <em>ID Paket adalah ID Bundel Anda</em> </p><br><p>  Segera setelah membuat aplikasi, buka tab <em>Fitur.</em> </p><br><blockquote>  Jika Anda sudah membuat aplikasi, maka Anda dapat terus membaca dari sini. </blockquote><p>  Proses pembuatan langganan yang dapat diperpanjang secara otomatis terdiri dari beberapa tahap: </p><br><p>  <strong>1. Buat pengidentifikasi berlangganan dan buat <em>grup berlangganan</em> .</strong>  Grup berlangganan adalah kumpulan langganan dengan periode dan harga berbeda, tetapi yang membuka fungsionalitas yang sama dalam aplikasi.  Selain itu, dalam grup berlangganan, Anda hanya dapat mengaktifkan periode uji coba gratis satu kali, dan hanya satu langganan yang dapat aktif.  Jika Anda ingin aplikasi Anda memiliki dua langganan yang berbeda secara bersamaan, maka Anda harus membuat dua grup langganan. </p><br><p>  <strong>2. Mengisi data berlangganan: durasi, nama tampilan di App Store (jangan bingung hanya dengan nama) dan deskripsi.</strong>  Jika Anda menambahkan langganan pertama ke grup, Anda harus menunjukkan nama tampilan grup langganan.  Ingatlah untuk lebih sering menyimpan perubahan Anda, ASC dapat membeku kapan saja dan berhenti merespons. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Halaman pembicaraan"><br>  <em>Layar Berlangganan</em> </p><br><p>  <strong>3. Mengisi harga berlangganan.</strong>  Ada dua tahap: menciptakan harga dan penawaran khusus.  Tunjukkan harga riil dalam mata uang apa pun, secara otomatis dihitung ulang untuk semua negara lain.  Penawaran pengantar: di sini Anda dapat menawarkan periode uji coba gratis atau diskon prabayar kepada pengguna.  Promosi muncul di App Store baru-baru ini pada tahun 2019: promosi memungkinkan Anda untuk menawarkan diskon khusus kepada pengguna yang telah berhenti berlangganan dan yang ingin Anda kembalikan. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  Generasi Kunci Rahasia Bersama </h3><br><p>  Pada halaman dengan daftar semua langganan yang Anda buat, Anda akan melihat tombol <em>Shared untuk</em> tombol <em>aplikasi</em> .  Ini adalah jalur khusus yang diperlukan untuk memvalidasi cek di aplikasi iOS.  Kami perlu memvalidasi cek untuk menentukan status langganan. </p><br><p>  Kunci yang dibagi dapat terdiri dari dua jenis: kunci unik untuk aplikasi Anda atau satu kunci untuk akun Anda.  Penting: dalam keadaan apa pun jangan membuat ulang kunci jika Anda sudah memiliki aplikasi di App Store, jika tidak, pengguna tidak akan dapat memvalidasi cek dan aplikasi Anda akan berhenti berfungsi seperti yang diharapkan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="Dalam contoh ini, dibuat tiga grup langganan dan 3 langganan tahunan."><br>  <em>Dalam contoh ini, tiga grup langganan dan 3 langganan tahunan dibuat.</em> </p><br><p>  Salin ID dari semua langganan Anda dan kunci bersama, ini akan berguna nanti dalam kode. </p><br><h2 id="programmnaya-chast">  Bagian perangkat lunak </h2><br><p>  Mari kita turun ke bagian praktis.  Apa yang diperlukan untuk membuat manajer belanja yang lengkap?  Minimal, hal-hal berikut harus diterapkan: </p><br><ol><li><p>  Checkout </p><br></li><li><p>  Periksa Status Langganan </p><br></li><li><p>  Periksa pembaruan </p><br></li><li><p>  Pemulihan transaksi (jangan bingung dengan memperbarui cek!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Checkout </h3><br><p>  Seluruh proses pembelian dapat dibagi menjadi 2 tahap: menerima produk (kelas <code>SKProduct</code> ) dan menginisialisasi proses pembelian (kelas <code>SKPayment</code> ).  Pertama-tama, kita harus menentukan delegasi protokol <code>SKPaymentTransactionObserver</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  Notifikasi <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> digunakan untuk memperbarui UI dalam suatu aplikasi. </p><br><p>  Selanjutnya, kami menulis metode untuk menginisialisasi pembelian: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  Delegasi <code>SKPaymentTransactionObserver</code> terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  Setelah berhasil berlangganan, metode delegasi disebut di mana transaksi memiliki status yang <code>purchased</code> . </p><br><p>  Tetapi bagaimana cara menentukan tanggal kedaluwarsa berlangganan?  Untuk melakukan ini, buat permintaan terpisah ke Apple. </p><br><h3 id="proverka-statusa-podpiski">  Periksa Status Langganan </h3><br><p>  Pemeriksaan divalidasi menggunakan permintaan POST <code>verifyReceipt</code> ke Apple, kami mengirimkan cek terenkripsi sebagai string yang di-encode base64 sebagai parameter, dan sebagai respons kami menerima cek yang sama dalam format JSON.  Dalam array, key <code>latest_receipt_info</code> akan mencantumkan semua transaksi dari setiap periode langganan, termasuk periode uji coba.  Kami hanya dapat menguraikan jawabannya dan mendapatkan tanggal kedaluwarsa saat ini untuk setiap produk. </p><br><blockquote>  Di WWDC 2017, mereka menambahkan kemampuan untuk hanya menerima cek saat ini untuk setiap langganan menggunakan kunci <code>exclude-old-transactions</code> dalam permintaan <code>verifyReceipt</code> . </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  Di awal metode, Anda dapat melihat bahwa ada cek untuk keberadaan salinan cek lokal.  Pemeriksaan lokal mungkin tidak ada, misalnya, jika aplikasi diinstal melalui iTunes.  Jika tidak ada pemeriksaan, kami tidak dapat menjalankan permintaan <code>verifyReceipt</code> .  Pertama-tama kita perlu mendapatkan cek lokal saat ini, dan kemudian mencoba memvalidasinya lagi.  Memperbarui cek dilakukan menggunakan kelas <code>SKReceiptRefreshRequest</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>Periksa pembaruan</strong> diimplementasikan dalam fungsi <code>refreshReceipt()</code> .  Jika pemeriksaan berhasil diperbarui, metode delegasi <code>requestDidFinish(_ request : SKRequest)</code> dipanggil, yang memanggil metode <code>refreshSubscriptionsStatus</code> . </p><br><p>  Bagaimana penguraian informasi pembelian diterapkan?  Kami dikembalikan objek JSON di mana ada array transaksi bersarang (dengan kunci <code>latest_receipt_info</code> ).  Kami pergi melalui array, dapatkan tanggal kedaluwarsa menggunakan kunci <code>expires_date</code> dan simpan jika tanggal ini belum tiba. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  Saya memberikan contoh sederhana tentang cara mengekstrak tanggal kedaluwarsa berlangganan saat ini.  Tidak ada penanganan kesalahan dan, misalnya, tidak ada pemeriksaan untuk pengembalian pembelian ( <em>tanggal pembatalan</em> ditambahkan). </p><br><p>  Untuk menentukan apakah langganan aktif atau tidak, cukup bandingkan tanggal saat ini dengan tanggal dari <em>Default Pengguna</em> berdasarkan kunci produk.  Jika tidak ada atau kurang dari tanggal saat ini, maka langganan dianggap tidak aktif. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  Pemulihan transaksi dilakukan dalam satu baris <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  Fungsi ini mengembalikan semua transaksi yang telah diselesaikan dengan memanggil metode delegasi, <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  Apa perbedaan antara memperbarui cek dari pemulihan transaksi? </h3><br><p>  Kedua metode membantu memulihkan data pembelian Anda.  Tetapi apa perbedaan mereka?  Ada tabel indah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video wwdc</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Tabel perbedaan dua cara untuk mengembalikan pembelian dari WWDC"><br>  <em>Tabel perbedaan dua cara untuk mengembalikan pembelian dari WWDC</em> </p><br><p>  Dalam kebanyakan kasus, Anda hanya perlu menggunakan <code>SKReceiptRefreshRequest()</code> , karena kami hanya tertarik menerima cek untuk perhitungan selanjutnya dari tanggal kedaluwarsa. </p><br><p>  Dalam hal langganan yang dapat diperpanjang secara otomatis, transaksi itu sendiri tidak menarik bagi kami, jadi cukup menggunakan pembaruan cek saja.  Namun, ada beberapa kasus ketika Anda perlu menggunakan metode pemulihan transaksi: jika aplikasi Anda mengunduh konten setelah pembelian (konten yang diinangi Apple) atau jika Anda masih mendukung versi di bawah iOS 7. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Pengujian Belanja (Pengujian Kotak Pasir) </h3><br><p>  Sebelumnya, untuk menguji pembelian, Anda harus masuk dari App Store di pengaturan iPhone Anda.  Ini sangat merepotkan (misalnya, seluruh Perpustakaan Musik Apple telah dihapus).  Namun, ini tidak perlu dilakukan sekarang: akun kotak pasir sekarang ada secara terpisah dari akun utama. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  Proses pembelian serupa dibandingkan dengan pembelian nyata di App Store, tetapi ada beberapa poin: </p><br><ul><li><p>  Anda akan selalu perlu memasukkan kata sandi masuk melalui jendela sistem.  Pembelian menggunakan ID Sentuh / ID Wajah masih belum didukung. </p><br></li><li><p>  Jika, setelah memasukkan login dan kata sandi dengan benar, sistem berulang kali meminta kata sandi login, <em>klik "Batal"</em> , perkecil aplikasi, lalu coba lagi.  Itu terlihat seperti omong kosong, tetapi bekerja untuk banyak orang.  Tetapi kadang-kadang setelah entri kata sandi kedua proses masih berjalan. </p><br></li><li><p>  Anda tidak akan dapat menguji proses berhenti berlangganan dengan cara apa pun. </p><br></li><li><p>  Durasi periode berlangganan jauh lebih rendah daripada yang sebenarnya.  Dan mereka diperbarui tidak lebih dari 6 kali sehari. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Durasi aktual </th><th>  Durasi tes </th></tr></thead><tbody><tr><td>  1 minggu </td><td>  3 menit </td></tr><tr><td>  1 bulan </td><td>  5 menit </td></tr><tr><td>  2 bulan </td><td>  10 menit </td></tr><tr><td>  3 bulan </td><td>  15 menit </td></tr><tr><td>  6 bulan </td><td>  30 menit </td></tr><tr><td>  1 tahun </td><td>  1 jam </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  Apa yang baru di StoreKit di iOS 13? </h3><br><p>  Yang baru - hanya kelas <code>SKStorefront</code> , yang memberikan informasi tentang negara mana pengguna terdaftar di App Store.  Ini mungkin berguna bagi para pengembang yang menggunakan langganan yang berbeda untuk negara yang berbeda.  Sebelumnya, semua orang diperiksa oleh geolokasi atau berdasarkan wilayah perangkat, tetapi ini tidak memberikan hasil yang akurat.  Sekarang sangat mudah untuk mengetahui negara di App Store: <code>SKPaymentQueue.default().storefront?.countryCode</code> .  Delegasi metode juga ditambahkan jika negara di App Store berubah selama proses pembelian.  Dalam hal ini, Anda dapat melanjutkan atau membatalkan proses pembelian sendiri. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Jebakan saat bekerja dengan langganan </h2><br><ul><li>  Memeriksa cek langsung dari perangkat tidak direkomendasikan oleh Apple.  Mereka berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> beberapa kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di WWDC</a> (dari 5:50) dan ini ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Ini tidak aman karena penyerang dapat mencegat data menggunakan serangan man-in-the-middle.  Cara yang benar untuk memeriksa cek adalah validasi lokal baik menggunakan server Anda. </li><li>  Ada masalah dengan memeriksa tanggal kedaluwarsa.  Jika Anda tidak menggunakan server Anda, maka waktu sistem pada perangkat dapat diubah menjadi yang lebih lama, dan kemudian kode kami akan memberikan hasil yang salah - langganan akan dianggap aktif.  Jika ini tidak cocok untuk Anda, maka Anda dapat menggunakan layanan apa pun yang mengeluarkan waktu dunia yang akurat. </li><li>  Tidak semua pengguna dapat memiliki uji coba gratis.  Pengguna dapat menginstal ulang aplikasi setelah beberapa waktu, dan aplikasi akan menunjukkan bahwa uji coba tersedia seperti biasa.  Ini akan benar untuk memperbarui cek, memvalidasi itu dan memeriksa di JSON ketersediaan uji coba untuk pengguna ini.  Banyak yang tidak. </li><li>  Jika pengguna meminta pengembalian dana, maka <code>cancellation_date</code> akan ditambahkan ke langganan JSON, tetapi <code>expires_date</code> akan tetap tidak berubah.  Oleh karena itu, penting untuk selalu memeriksa keberadaan bidang <code>cancellation_date</code> , yang lebih disukai daripada <code>expires_date</code> . </li><li>  Tidak perlu memperbarui cek setiap kali aplikasi diluncurkan, karena, pertama, ini tidak ada gunanya, dan kedua, kemungkinan besar pengguna akan diberikan jendela entri kata sandi dari Apple ID.  Layak memperbarui cek, misalnya, ketika pengguna sendiri mengklik tombol restore shopping. </li><li>  Bagaimana cara menentukan pada titik mana perlu memvalidasi cek untuk mendapatkan tanggal kedaluwarsa berlangganan saat ini?  Anda dapat memvalidasi cek di setiap awal, atau hanya di akhir berlangganan.  Namun, jika Anda memeriksa cek hanya di akhir berlangganan, pengguna yang telah mengeluarkan pengembalian dana akan dapat menggunakan aplikasi Anda secara gratis hingga akhir periode. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Semoga artikel ini bermanfaat bagi Anda.  Saya mencoba untuk menambahkan tidak hanya kode, tetapi juga untuk menjelaskan titik-titik halus dalam pengembangan.  Kode kelas lengkap dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kelas ini akan sangat berguna untuk berkenalan dengan pengembang pemula dan mereka yang ingin mempelajari lebih lanjut tentang bagaimana semuanya bekerja.  Untuk aplikasi langsung, disarankan untuk menggunakan solusi yang lebih serius, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SwiftyStoreKit</a> . </p><br><blockquote>  Ingin menerapkan langganan di aplikasi iOS Anda dalam 10 menit?  Integrasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apphud</a> dan: <br><ul><li>  Lakukan pembelian hanya menggunakan satu metode; </li><li>  secara otomatis melacak status langganan setiap pengguna; </li><li>  Integrasikan Penawaran Langganan dengan mudah </li><li>  kirim acara berlangganan ke Amplitude, Mixpanel, Slack dan Telegram dengan mempertimbangkan mata uang lokal pengguna; </li><li>  mengurangi tingkat Churn dalam aplikasi dan mengembalikan pengguna yang tidak berlangganan. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456602/">https://habr.com/ru/post/id456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456580/index.html">Masa Depan Otonomi yang Mandiri</a></li>
<li><a href="../id456582/index.html">Mengapa Internet masih online?</a></li>
<li><a href="../id456594/index.html">2 menit dengan goyangan pohon Webpack dan ekspor kembali</a></li>
<li><a href="../id456596/index.html">Mikrobiota. Bagaimana cara kerja pengujian?</a></li>
<li><a href="../id456600/index.html">Resep Nginx: otorisasi LDAP dengan captcha</a></li>
<li><a href="../id456604/index.html">Bagaimana kami mengotomatiskan toko online besar dan mulai mencocokkan produk secara otomatis</a></li>
<li><a href="../id456606/index.html">Berita dari dunia OpenStreetMap No. 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../id456608/index.html">Southbridge di Chelyabinsk dan Bitrix di Kubernetes</a></li>
<li><a href="../id456610/index.html">Jangan menekan dan tidak menyetujui</a></li>
<li><a href="../id456612/index.html">Salah satu dari ratusan cara untuk mempublikasikan beberapa proyek produksi pada satu server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>