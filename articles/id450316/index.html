<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš ğŸ§™ğŸ¼ ğŸ† TDD: metodologi pengembangan yang mengubah hidup saya ğŸ§šğŸ¼ ğŸ”ï¸ ğŸ‘‹ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pukul 07.15 pagi Dukungan teknis kami dibanjiri dengan pekerjaan. Selamat Pagi Amerika baru saja berbicara tentang kami dan banyak dari mereka yang me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDD: metodologi pengembangan yang mengubah hidup saya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/450316/">  Pukul 07.15 pagi  Dukungan teknis kami dibanjiri dengan pekerjaan.  Selamat Pagi Amerika baru saja berbicara tentang kami dan banyak dari mereka yang mengunjungi situs kami untuk pertama kalinya mengalami kesalahan. <br><br>  Kami benar-benar terburu-buru.  Kami, saat ini, sebelum kehilangan kesempatan untuk mengubah pengunjung sumber daya menjadi pengguna baru, akan meluncurkan paket perbaikan.  Salah satu pengembang menyiapkan sesuatu.  Dia pikir ini akan membantu mengatasi masalah tersebut.  Kami menempatkan tautan ke versi program yang diperbarui, yang belum mulai diproduksi, ke obrolan perusahaan, dan kami meminta semua orang untuk mengujinya.  Itu berhasil! <br><br>  Insinyur heroik kami menjalankan skrip untuk menyebarkan sistem dan setelah beberapa menit pembaruan berjalan ke pertempuran.  Tiba-tiba, jumlah panggilan dukungan teknis berlipat ganda.  Perbaikan mendesak kami memecahkan sesuatu, para pengembang mengambil menyalahkan git, dan para insinyur memutar kembali sistem ke keadaan sebelumnya pada waktu itu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/715/f8a/020/715f8a020e1adfe61cb65c6b6bccb191.jpg" alt="gambar"></a> <br><br>  Penulis materi, terjemahan yang kami terbitkan hari ini, percaya bahwa semua ini bisa dihindari berkat TDD. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mengapa saya menggunakan TDD?</font> </h2><br>  Saya belum pernah berada dalam situasi seperti ini sejak lama.  Dan bukan karena pengembang berhenti membuat kesalahan.  Faktanya adalah bahwa selama bertahun-tahun sekarang, di setiap tim yang saya pimpin dan pengaruhi, metodologi TDD diterapkan.  Kesalahan, tentu saja, masih terjadi, tetapi penetrasi ke dalam produksi masalah yang dapat "merobohkan" proyek telah menurun hampir nol, meskipun frekuensi pembaruan perangkat lunak dan jumlah tugas yang perlu diselesaikan selama pembaruan telah tumbuh secara eksponensial sejak saat itu ketika sesuatu terjadi yang saya bicarakan di awal. <br><br>  Ketika seseorang bertanya kepada saya mengapa dia harus menghubungi TDD, saya menceritakan kisah ini kepadanya, dan saya dapat mengingat selusin lagi kasus serupa.  Salah satu alasan paling penting mengapa saya beralih ke TDD adalah bahwa metodologi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan</a> cakupan tes dengan kode, yang menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan</a> produksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">40-80% lebih sedikit</a> .  Inilah yang paling saya sukai tentang TDD.  Ini menghilangkan segunung masalah dari pundak pengembang. <br><br>  Selain itu, perlu dicatat bahwa TDD menyelamatkan pengembang dari rasa takut membuat perubahan pada kode. <br><br>  Dalam proyek-proyek yang saya ikuti, set modul otomatis dan tes fungsional hampir setiap hari mencegah kode masuk ke produksi, yang secara serius dapat mengganggu pekerjaan proyek-proyek ini.  Sebagai contoh, sekarang saya melihat 10 pembaruan perpustakaan otomatis yang dibuat minggu lalu, sehingga sebelum merilisnya tanpa menggunakan TDD, saya takut mereka akan merusak sesuatu. <br><br>  Semua pembaruan ini secara otomatis diintegrasikan ke dalam kode, dan sudah digunakan dalam produksi.  Saya tidak memeriksa salah satu dari mereka secara manual, dan tidak khawatir sama sekali bahwa mereka dapat berdampak buruk pada proyek.  Pada saat yang sama, untuk memberikan contoh ini, saya tidak perlu berpikir panjang.  Saya baru saja membuka GitHub, melihat merger baru-baru ini, dan melihat apa yang saya bicarakan.  Tugas yang sebelumnya diselesaikan secara manual (atau, lebih buruk lagi, masalah yang diabaikan) sekarang adalah proses latar belakang otomatis.  Anda dapat mencoba melakukan sesuatu yang serupa tanpa cakupan kode yang baik dengan tes, tetapi saya tidak akan merekomendasikan melakukan ini. <br><br><h2>  <font color="#3AC1EF">Apa itu TDD?</font> </h2><br>  TDD adalah singkatan dari Test Driven Development.  Proses yang diterapkan dengan menerapkan metodologi ini sangat sederhana: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b62/856/b6eb62856a3b14b0c661e94ed12cc6b8.png"></div><br>  <i><font color="#999999">Tes mendeteksi kesalahan, tes berhasil diselesaikan, refactoring dilakukan</font></i> <br><br>  Berikut adalah prinsip dasar untuk menggunakan TDD: <br><br><ol><li>  Sebelum menulis kode implementasi untuk beberapa fitur, mereka menulis tes yang memungkinkan Anda untuk memeriksa apakah kode implementasi masa depan ini berfungsi atau tidak.  Sebelum melanjutkan ke langkah berikutnya, tes dimulai dan diyakinkan bahwa ia melakukan kesalahan.  Berkat ini, Anda dapat yakin bahwa tes tidak menghasilkan hasil positif palsu, itu adalah semacam tes dari tes itu sendiri. </li><li>  Mereka menciptakan implementasi peluang dan memastikan bahwa ia lulus ujian dengan sukses. </li><li>  Lakukan, jika perlu, kode refactoring.  Refactoring, di hadapan tes yang dapat menunjukkan kepada pengembang apakah sistem itu bekerja dengan benar atau salah, menanamkan kepercayaan pada pengembang dalam tindakannya. </li></ol><br><h2>  <font color="#3AC1EF">Bagaimana TDD membantu menghemat waktu yang dibutuhkan untuk mengembangkan program?</font> </h2><br>  Pada pandangan pertama, mungkin terlihat bahwa tes menulis berarti peningkatan yang signifikan dalam jumlah kode proyek, dan bahwa semua ini membutuhkan banyak waktu ekstra dari pengembang.  Dalam kasus saya, pada awalnya, semuanya hanya itu, dan saya mencoba memahami bagaimana, pada prinsipnya, mungkin untuk menulis kode yang dapat diuji, dan bagaimana menambahkan tes ke kode yang telah ditulis. <br><br>  TDD dicirikan oleh kurva belajar tertentu, dan sementara pemula naik sepanjang kurva ini, waktu yang dibutuhkan untuk pengembangan dapat meningkat sebesar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">15-35%</a> .  Seringkali inilah yang terjadi.  Tetapi di suatu tempat sekitar 2 tahun setelah dimulainya penggunaan TDD, sesuatu yang luar biasa mulai terjadi.  Yaitu, misalnya, saya mulai, dengan penulisan awal tes unit, pemrograman lebih cepat dari sebelumnya ketika TDD tidak digunakan. <br><br>  Beberapa tahun yang lalu, saya menerapkan, dalam sistem klien, kemampuan untuk bekerja dengan potongan-potongan klip video.  Yaitu, intinya adalah memungkinkan untuk memungkinkan pengguna untuk menunjukkan awal dan akhir fragmen rekaman, dan menerima tautan ke sana, yang memungkinkan untuk merujuk ke tempat tertentu dalam klip, dan bukan ke seluruh klip. <br><br>  Saya tidak bekerja.  Pemain mencapai ujung fragmen dan terus memainkannya, tetapi saya tidak tahu mengapa ini terjadi. <br><br>  Saya pikir masalahnya adalah menghubungkan pendengar acara dengan tidak tepat.  Kode saya terlihat seperti ini: <br><br><pre><code class="plaintext hljs">video.addEventListener('timeupdate', () =&gt; {  if (video.currentTime &gt;= clip.stopTime) {    video.pause();  } });</code> </pre> <br>  Proses menemukan masalah tampak seperti ini: membuat perubahan, kompilasi, me-reboot, mengklik, menunggu ... Urutan tindakan ini diulangi berulang-ulang. <br><br>  Untuk memeriksa setiap perubahan yang dimasukkan ke dalam proyek, perlu waktu hampir satu menit untuk dihabiskan, dan saya mengalami banyak sekali pilihan untuk menyelesaikan masalah (kebanyakan dari mereka 2-3 kali). <br><br>  Mungkin saya membuat kesalahan dalam kata kunci waktu <code>timeupdate</code> ?  Apakah saya memahami fitur bekerja dengan API dengan benar?  Apakah panggilan <code>video.pause()</code> ?  Saya membuat perubahan pada kode, menambahkan <code>console.log()</code> , kembali ke browser, mengklik tombol <code></code> , mengklik posisi yang terletak di ujung fragmen yang dipilih, dan kemudian dengan sabar menunggu sampai klip itu diputar sepenuhnya.  Masuk ke dalam konstruksi <code>if</code> tidak mengarah ke apa pun.  Itu tampak seperti petunjuk tentang kemungkinan masalah.  Saya menyalin kata <code>timeupdate</code> dari dokumentasi API untuk benar-benar yakin bahwa saya tidak membuat kesalahan ketika memasukkannya.  Saya memuat kembali halaman itu, klik lagi, tunggu lagi.  Dan lagi, program ini menolak untuk bekerja dengan benar. <br><br>  Saya akhirnya meletakkan <code>console.log()</code> luar blok <code>if</code> .  "Itu tidak akan membantu," pikirku.  Pada akhirnya, <code>if</code> itu sangat sederhana sehingga saya tidak tahu cara mengejanya dengan salah.  Tetapi masuk dalam kasus ini berhasil.  Saya tersedak kopi.  "Apa-apaan itu!?"  Saya pikir. <br><blockquote>  Hukum debugging Murphy.  Tempat program yang tidak pernah Anda uji, karena Anda sangat yakin bahwa itu tidak dapat mengandung kesalahan, akan berubah menjadi tempat di mana Anda akan menemukan kesalahan setelah, setelah benar-benar kelelahan, Anda akan membuat perubahan ke tempat ini hanya karena bahwa mereka telah mencoba semua yang dapat mereka pikirkan. </blockquote><br>  Saya menetapkan breakpoint dalam program untuk memahami apa yang terjadi.  Saya menjelajahi arti <code>clip.stopTime</code> .  Yang mengejutkan saya, itu tidak <code>undefined</code> .  Mengapa  Saya melihat kode lagi.  Ketika pengguna memilih waktu akhir fragmen, program menempatkan penanda untuk akhir fragmen di tempat yang tepat, tetapi tidak menetapkan nilai <code>clip.stopTime</code> .  "Saya seorang idiot yang luar biasa," saya berpikir, "Saya tidak boleh diizinkan masuk ke komputer sampai akhir hidup saya." <br><br>  Saya tidak melupakan ini dan bertahun-tahun kemudian.  Dan semuanya - berkat sensasi yang saya alami, masih menemukan kesalahan.  Anda mungkin tahu apa yang saya bicarakan.  Dengan semua ini terjadi.  Dan, mungkin, semua orang akan dapat mengenali diri mereka sendiri dalam meme ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/e2d/01c/703e2d01c140fba62e25914e340bad97.png"></div><br>  <i><font color="#999999">Ini adalah bagaimana saya terlihat ketika saya memprogram</font></i> <br><br>  Jika saya menulis program itu hari ini, saya akan mulai mengerjakannya seperti ini: <br><br><pre> <code class="plaintext hljs">describe('clipReducer/setClipStopTime', async assert =&gt; { const stopTime = 5; const clipState = {   startTime: 2,   stopTime: Infinity }; assert({   given: 'clip stop time',   should: 'set clip stop time in state',   actual: clipReducer(clipState, setClipStopTime(stopTime)),   expected: { ...clipState, stopTime } }); });</code> </pre> <br>  Ada perasaan bahwa ada lebih banyak kode daripada di baris ini: <br><br><pre> <code class="plaintext hljs">clip.stopTime = video.currentTime</code> </pre> <br>  Tapi itulah intinya.  Kode ini bertindak sebagai spesifikasi.  Ini adalah dokumentasi dan bukti bahwa kode berfungsi seperti yang disyaratkan oleh dokumentasi ini.  Dan, karena dokumentasi ini ada, jika saya mengubah prosedur untuk bekerja dengan marker untuk waktu akhir fragmen, saya tidak perlu khawatir tentang apakah selama pengenalan perubahan ini saya melanggar operasi yang benar dengan waktu berakhirnya klip. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ngomong</a> -ngomong, ini adalah bahan yang berguna untuk menulis unit test, sama seperti yang baru saja kita lihat. <br><br>  Intinya bukan berapa lama waktu yang diperlukan untuk memasukkan kode ini.  Intinya adalah berapa lama untuk melakukan debug jika terjadi kesalahan.  Jika kode salah, tes akan memberikan laporan kesalahan yang sangat baik.  Saya akan segera tahu bahwa masalahnya bukan pengendali acara.  Saya akan tahu bahwa itu ada di <code>setClipStopTime()</code> , atau di <code>clipReducer()</code> , di mana perubahan status diterapkan.  Berkat tes ini, saya akan tahu tentang fungsi apa yang dilakukan oleh kode, apa yang sebenarnya ditampilkan, dan apa yang diharapkan darinya.  Dan, yang lebih penting, kolega saya akan memiliki pengetahuan yang sama, yang, enam bulan setelah saya menulis kode, akan memperkenalkan fitur-fitur baru ke dalamnya. <br><br>  Memulai proyek baru, saya, sebagai salah satu hal pertama, mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip pengamat</a> yang secara otomatis menjalankan tes unit setiap kali file tertentu diubah.  Saya sering memprogram menggunakan dua monitor.  Di salah satu dari mereka, konsol pengembang dibuka, di mana hasil skrip tersebut ditampilkan, di sisi lain, antarmuka lingkungan tempat saya menulis kode ditampilkan.  Ketika saya membuat perubahan pada kode, saya biasanya, dalam 3 detik, mencari tahu apakah perubahan itu berfungsi atau tidak. <br><br>  Bagi saya, TDD jauh lebih dari sekedar asuransi.  Ini adalah kemampuan untuk secara konstan dan cepat, menerima informasi tentang status kode saya secara waktu nyata.  Hadiah instan dalam bentuk tes yang lulus, atau laporan kesalahan instan jika saya melakukan kesalahan. <br><br><h2>  <font color="#3AC1EF">Bagaimana metodologi TDD mengajari saya cara menulis kode yang lebih baik?</font> </h2><br>  Saya ingin membuat satu penerimaan, bahkan mengakui itu memalukan: Saya tidak tahu cara membuat aplikasi sebelum saya belajar TDD dan pengujian unit.  Saya tidak bisa membayangkan bagaimana saya dipekerjakan sama sekali, tetapi setelah saya mewawancarai ratusan pengembang, saya dapat dengan yakin mengatakan bahwa banyak programmer yang berada dalam situasi yang sama.  Metodologi TDD telah mengajarkan saya hampir semua yang saya tahu tentang dekomposisi dan komposisi komponen perangkat lunak yang efisien (maksud saya modul, fungsi, objek, komponen antarmuka pengguna, dll.). <br><br>  Alasan untuk ini adalah bahwa unit test memaksa programmer untuk menguji komponen secara terpisah satu sama lain dan dari subsistem I / O.  Jika modul dilengkapi dengan beberapa data input, modul tersebut harus memberikan data keluaran tertentu yang diketahui sebelumnya.  Jika tidak, tes gagal.  Jika ya, tes berhasil.  Intinya di sini adalah bahwa modul harus bekerja secara independen dari sisa aplikasi.  Jika Anda menguji logika negara, Anda harus dapat melakukan ini tanpa menampilkan apa pun di layar atau menyimpan apa pun ke database.  Jika Anda menguji pembentukan antarmuka pengguna, maka Anda harus dapat mengujinya tanpa harus memuat halaman di browser atau mengakses sumber daya jaringan. <br><br>  Antara lain, metodologi TDD mengajarkan saya bahwa hidup menjadi lebih mudah jika Anda berjuang untuk minimalis ketika mengembangkan komponen antarmuka pengguna.  Selain itu, logika bisnis dan efek samping harus diisolasi dari antarmuka pengguna.  Dari sudut pandang praktis, ini berarti bahwa jika Anda menggunakan kerangka kerja UI berbasis komponen seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React</a> atau Angular, mungkin disarankan untuk membuat komponen presentasi yang bertanggung jawab untuk menampilkan sesuatu di layar dan komponen wadah yang tidak terhubung satu sama lain dicampur. <br><br>  Komponen presentasi yang menerima properti tertentu selalu menghasilkan hasil yang sama.  Komponen seperti itu dapat dengan mudah diverifikasi menggunakan unit test.  Ini memungkinkan Anda untuk mengetahui apakah komponen berfungsi dengan benar dengan properti, dan apakah logika kondisional tertentu yang digunakan dalam pembentukan antarmuka benar.  Misalnya, ada kemungkinan bahwa komponen yang membentuk daftar tidak boleh menampilkan apa pun selain undangan untuk menambahkan elemen baru ke daftar jika daftar kosong. <br><br>  Saya tahu tentang prinsip pemisahan tanggung jawab jauh sebelum saya menguasai TDD, tetapi saya tidak tahu bagaimana berbagi tanggung jawab antara entitas yang berbeda. <br><br>  Unit testing memungkinkan saya untuk mempelajari penggunaan mokas untuk menguji sesuatu, dan kemudian saya menemukan bahwa mengolok-olok adalah tanda bahwa ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesuatu yang salah dengan kode</a> .  Itu mengejutkan saya dan benar-benar mengubah pendekatan saya terhadap komposisi perangkat lunak. <br><br>  Semua pengembangan perangkat lunak adalah komposisi: proses memecah masalah besar menjadi banyak masalah kecil, mudah dipecahkan, dan kemudian menciptakan solusi untuk masalah ini yang membentuk aplikasi.  Tuxing demi pengujian unit menunjukkan bahwa unit atom dari komposisi, pada kenyataannya, bukan atom.  Mempelajari cara menyingkirkan mok tanpa memengaruhi cakupan kode dengan tes memungkinkan saya belajar tentang cara mengidentifikasi alasan tersembunyi yang tak terhitung banyaknya untuk keterkaitan kuat entitas. <br><br>  Ini memungkinkan saya, sebagai pengembang, untuk tumbuh secara profesional.  Ini mengajari saya cara menulis kode yang lebih sederhana yang lebih mudah untuk diperluas, dipelihara, skala.  Ini berlaku untuk kompleksitas kode itu sendiri, dan untuk pengorganisasiannya dalam sistem terdistribusi besar seperti infrastruktur cloud. <br><br><h2>  <font color="#3AC1EF">Bagaimana TDD menghemat waktu tim?</font> </h2><br>  Saya sudah mengatakan bahwa TDD, di tempat pertama, mengarah pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peningkatan</a> cakupan kode dengan tes.  Alasan untuk ini adalah bahwa kita tidak mulai menulis kode untuk mengimplementasikan beberapa fitur sampai kita menulis tes yang memeriksa operasi yang benar dari kode masa depan ini.  Pertama kita menulis tes.  Lalu kami membiarkannya diakhiri dengan kesalahan.  Kemudian kami menulis kode untuk mengimplementasikan peluang.  Kami menguji kode, kami menerima pesan kesalahan, kami mencapai kelulusan tes, kami melakukan refactoring dan ulangi proses ini. <br><br>  Proses ini memungkinkan Anda untuk membuat "pagar" di mana hanya beberapa kesalahan bisa "melompat".  Perlindungan kesalahan ini memiliki efek luar biasa pada seluruh tim pengembangan.  Ini mengurangi rasa takut tim penggabungan. <br><br>  Tingkat tinggi cakupan kode dengan tes memungkinkan tim untuk menyingkirkan keinginan untuk secara manual mengontrol perubahan apa pun, bahkan kecil, dalam basis kode.  Perubahan kode menjadi bagian alami dari alur kerja. <br><br>  Menyingkirkan rasa takut membuat perubahan pada kode mirip dengan kaburnya mesin tertentu.  Jika ini tidak dilakukan, mesin pada akhirnya akan berhenti - sampai dilumasi dan dihidupkan ulang. <br><br>  Tanpa rasa takut ini, proses mengerjakan program jauh lebih tenang dari sebelumnya.  Permintaan tarik tidak ditunda sampai yang terakhir.  Sistem CI / CD akan menjalankan tes, dan jika tes gagal, itu akan menghentikan proses membuat perubahan pada kode proyek.  Pada saat yang sama, pesan kesalahan dan informasi tentang di mana mereka terjadi akan sangat sulit untuk tidak diperhatikan. <br><br>  Ini intinya. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan TDD saat mengerjakan proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450316/">https://habr.com/ru/post/id450316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450304/index.html">Carapuzik mengendarai seekor semut: 100 juta tahun myrmecophilia</a></li>
<li><a href="../id450308/index.html">Pelacakan Ray GPU dalam Persatuan - Bagian 3</a></li>
<li><a href="../id450310/index.html">Cara kerja Philips VideoWRITER. Gambar pertama dari besi, lalu sedikit kebosanan</a></li>
<li><a href="../id450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../id450314/index.html">TensorFlow untuk pemula. Bagian 1: informasi umum, menginstal perpustakaan</a></li>
<li><a href="../id450318/index.html">Pola desain dalam pengembangan JavaScript modern</a></li>
<li><a href="../id450320/index.html">Game kuantum sederhana mengungkapkan kompleksitas tertinggi alam semesta</a></li>
<li><a href="../id450322/index.html">Mengapa kita membutuhkan begitu banyak utusan?</a></li>
<li><a href="../id450324/index.html">Bagaimana Sistem Pelacakan Produktivitas Secara Otomatis Menghilangkan Karyawan Amazon</a></li>
<li><a href="../id450330/index.html">Memilih sekolah saat pindah ke AS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>