<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èØÔ∏è üöÆ ‚úîÔ∏è Entretenido C #. Cinco ejemplos de coffee breaks üïäÔ∏è üí´ üíÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu√©s de haber escrito m√°s de un art√≠culo sobre Veeam Academy , decidimos abrir una peque√±a cocina interna y ofrecerle algunos ejemplos en C # que e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entretenido C #. Cinco ejemplos de coffee breaks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/439478/">  Despu√©s de haber escrito m√°s de un art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Veeam Academy</a> , decidimos abrir una peque√±a cocina interna y ofrecerle algunos ejemplos en C # que estamos analizando con nuestros estudiantes.  Al compilarlos, nos guiamos por el hecho de que nuestra audiencia es desarrolladores novatos, pero tambi√©n puede ser interesante para los programadores experimentados mirar debajo del gato.  Nuestro objetivo es mostrar qu√© tan profundo es el agujero del conejo, al mismo tiempo que explicamos las caracter√≠sticas de la estructura interna de C #. <br><br>  Por otro lado, nos complacer√° escuchar comentarios de colegas experimentados que se√±alar√°n fallas en nuestros ejemplos o compartir√°n los suyos.  A ellos les gusta usar esas preguntas en las entrevistas, as√≠ que seguro que todos tenemos algo que contar. <br><br>  Esperamos que nuestra selecci√≥n le sea √∫til, le ayude a actualizar sus conocimientos o simplemente sonr√≠e. <br><br><img src="https://habrastorage.org/webt/wm/5l/4q/wm5l4qgp5-jl50kt_2oswu4tyu8.jpeg" alt="imagen"><br><a name="habracut"></a><br><h4>  Ejemplo 1 </h4><br>  Estructuras en C #.  Con ellos, incluso los desarrolladores experimentados a menudo tienen preguntas, que a menudo utilizan todo tipo de pruebas en l√≠nea. <br><br>  Nuestro primer ejemplo es un ejemplo de atenci√≥n plena y conocimiento de en qu√© se expande el bloque de uso.  Y tambi√©n es un tema de comunicaci√≥n durante la entrevista. <br><br>  Considera el c√≥digo: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SDummy(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (d) { Console.WriteLine(d.GetDispose()); } Console.WriteLine(d.GetDispose()); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øQu√© imprimir√° el m√©todo Main en la consola?</b> <div class="spoiler_text">  Tenga en cuenta que SDummy es una estructura que implementa la interfaz IDisposable, de modo que las variables del tipo SDummy se pueden usar en el bloque de uso. <br><br>  De acuerdo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con la especificaci√≥n del lenguaje C #, el</a> uso de instrucciones para tipos significativos en tiempo de compilaci√≥n se expande en un bloque try-finally: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(d.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)d).Dispose(); }</code> </pre><br>  Entonces, en nuestro c√≥digo, el m√©todo GetDispose () se llama dentro del bloque de uso, que devuelve el campo booleano _dispose, cuyo valor a√∫n no se ha establecido para el objeto d (solo se establece en el m√©todo Dispose (), que a√∫n no se ha llamado) y, por lo tanto, se devuelve el valor El valor predeterminado es False.  Que sigue <br><br>  Y luego lo m√°s interesante. <br>  Corriendo una l√≠nea en un bloque finalmente <br><pre> <code class="cs hljs"> ((IDisposable)d).Dispose();</code> </pre><br>  normalmente conduce al boxeo.  Esto no es dif√≠cil de ver, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (en la parte superior derecha en Resultados, primero seleccione C # y luego IL): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/b5/ix/4pb5ixpt4bwwwgrgiqeopcstdsg.jpeg" alt="imagen" width="80%"></div><br>  En este caso, el m√©todo Dispose ya est√° llamado para otro objeto, y no para el objeto d en absoluto. <br>  Ejecute nuestro programa y vea que el programa realmente muestra "False False" en la consola.  ¬øPero es as√≠ de simple?  :) <br><br>  De hecho, NO EST√Å PASANDO NING√öN EMBALAJE.  Lo que, seg√∫n Eric Lippert, se hace en aras de la optimizaci√≥n (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br>  Pero, si no hay empaque (lo que en s√≠ mismo puede parecer sorprendente), ¬øpor qu√© aparece "False False" y no "False True" en la pantalla, porque Dispose ahora deber√≠a aplicarse al mismo objeto?!? <br><br>  Y aqu√≠ no a eso! <br>  Eche un vistazo a lo que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilador de C #</a> expande nuestro programa en: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { SDummy sDummy = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(SDummy); SDummy sDummy2 = sDummy; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(sDummy.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)sDummy2).Dispose(); } Console.WriteLine(sDummy.GetDispose()); } }</code> </pre><br><br>  ¬°Hay una nueva variable sDummy2, a la que se aplica el m√©todo Dispose ()! <br>  ¬øDe d√≥nde viene esta variable oculta? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pasemos</a> a las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones nuevamente</a> : <br><blockquote>  Una declaraci√≥n de uso de la forma 'declaraci√≥n de uso (expresi√≥n)' tiene las mismas tres expansiones posibles.  En este caso, ResourceType es impl√≠citamente el tipo de tiempo de compilaci√≥n de la expresi√≥n ... La variable 'recurso' es inaccesible e invisible para la instrucci√≥n incrustada. <br></blockquote><br>  T.O.  la variable sDummy es invisible e inaccesible a la declaraci√≥n incrustada del bloque using, y todas las operaciones dentro de esta expresi√≥n se realizan con otra variable sDummy2. <br><br>  Como resultado, el m√©todo Main emite a la consola "False False" y no "False True", como creen muchos de los que encontraron este ejemplo por primera vez.  En este caso, aseg√∫rese de tener en cuenta que no hay empaquetado, sino que se crea una variable oculta adicional. <br><br>  La conclusi√≥n general es esta: los tipos de valores mutables son malvados y es mejor evitarlos. <br><br>  Un ejemplo similar se considera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Si el tema es interesante, recomendamos un vistazo. <br><br>  Me gustar√≠a agradecer especialmente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SergeyT</a> por sus valiosos comentarios sobre este ejemplo. <br><br></div></div><br><br><h4>  Ejemplo 2 </h4><br>  Los constructores y la secuencia de sus llamadas es uno de los temas principales de cualquier lenguaje de programaci√≥n orientado a objetos.  A veces, tal secuencia de llamadas puede sorprender y, lo que es peor, incluso "llenar" el programa en el momento m√°s inesperado. <br><br>  Entonces, considere la clase MyLogger: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger innerInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerInstance; } } }</code> </pre><br>  Supongamos que esta clase tiene cierta l√≥gica empresarial que necesitamos para admitir el registro (la funcionalidad no es tan importante en este momento). <br><br>  Veamos qu√© hay en nuestra clase MyLogger: <br><br><ol><li>  Constructor est√°tico especificado </li><li>  Hay un constructor privado sin par√°metros. </li><li>  Variable est√°tica cerrada innerInstance definido </li><li>  Y existe una propiedad est√°tica abierta de Instance para comunicarse con el mundo exterior </li></ol><br>  Para facilitar el an√°lisis de este ejemplo, agregamos una salida de consola simple a los constructores de la clase. <br><br>  Fuera de la clase (sin usar trucos como la reflexi√≥n) solo podemos usar la propiedad de instancia est√°tica p√∫blica, que podemos llamar as√≠: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = MyLogger.Instance; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© generar√° este programa?</b> <div class="spoiler_text">  Todos sabemos que se llama a un constructor est√°tico antes de acceder a cualquier miembro de la clase (con la excepci√≥n de las constantes).  En este caso, se inicia solo una vez dentro del dominio de la aplicaci√≥n. <br><br>  En nuestro caso, recurrimos al miembro de la clase: la propiedad Instance, que deber√≠a hacer que el constructor est√°tico se inicie primero, y luego se llamar√° al constructor de la instancia de clase.  Es decir  el programa generar√°: <br><br>  <b>Constructor de registrador est√°tico</b> <b><br></b>  <b>Constructor de registrador de instancias</b> <b><br></b> <br><br>  Sin embargo, despu√©s de iniciar el programa, llegamos a la consola: <br><br>  <b>Constructor de registrador de instancias</b> <b><br></b>  <b>Constructor de registrador est√°tico</b> <b><br></b> <br><br>  ¬øC√≥mo es eso?  El constructor de instancias funcion√≥ antes que el constructor est√°tico?!? <br>  Respuesta: s√≠! <br><br>  Y aqu√≠ est√° el por qu√©. <br><br>  El est√°ndar C # ECMA-334 establece lo siguiente para clases est√°ticas: <br><br>  <i>17.4.5.1: ‚ÄúSi existe un constructor est√°tico (¬ß17.11) en la clase, la ejecuci√≥n de los inicializadores de campo est√°tico ocurre inmediatamente antes de ejecutar ese constructor est√°tico.</i> <i><br></i>  <i>...</i> <i><br></i>  <i>17.11: ... Si una clase contiene campos est√°ticos con inicializadores, esos inicializadores se ejecutan en orden de texto inmediatamente antes de ejecutar el constructor est√°tico.</i> <br><br>  (Lo que en una traducci√≥n libre significa: si hay un constructor est√°tico en la clase, entonces la inicializaci√≥n de los campos est√°ticos comienza inmediatamente ANTES de que comience el constructor est√°tico. <br>  ... <br>  Si la clase contiene campos est√°ticos con inicializadores, dichos inicializadores se inician en el orden en el texto del programa ANTES de ejecutar el constructor est√°tico). <br><br>  En nuestro caso, el campo est√°tico innerInstance se declara junto con el inicializador, que es el constructor de la instancia de clase.  Seg√∫n el est√°ndar ECMA, el inicializador debe llamarse ANTES de llamar al constructor est√°tico.  Lo que sucede en nuestro programa: el constructor de instancias, que es el inicializador del campo est√°tico, se llama ANTES del constructor est√°tico.  De acuerdo, inesperadamente. <br><br>  Tenga en cuenta que esto solo es cierto para los inicializadores de campo est√°tico.  En general, un constructor est√°tico se llama ANTES de llamar al constructor de la instancia de clase. <br><br>  Como, por ejemplo, aqu√≠: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); } }</code> </pre><br>  Y se espera que el programa salga a la consola: <br><br>  <b>Constructor de registrador est√°tico</b> <b><br></b>  <b>Constructor de registrador de instancias</b> <b><br></b> <br></div></div><br><img src="https://habrastorage.org/webt/zr/ee/h3/zreeh3h-fqruztz8hdljydmzl1q.jpeg" alt="imagen"><br><br><h4>  Ejemplo 3 </h4><br>  Los programadores a menudo tienen que escribir funciones auxiliares (utilidades, ayudantes, etc.) para facilitarles la vida.  T√≠picamente, tales funciones son bastante simples y a menudo solo requieren unas pocas l√≠neas de c√≥digo.  Pero puedes tropezar incluso de la nada. <br><br>  Supongamos que necesitamos implementar una funci√≥n que verifique que el n√∫mero sea impar (es decir, que el n√∫mero no es divisible por 2 sin resto). <br><br>  Una implementaci√≥n podr√≠a verse as√≠: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  A primera vista, todo est√° bien y, por ejemplo, para los n√∫meros 5.7 y 11, esperamos obtener True. <br><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© devolver√° la funci√≥n isOddNumber (-5)?</b> <div class="spoiler_text">  -5 es un n√∫mero impar, pero como respuesta a nuestra funci√≥n, ¬°obtenemos Falso! <br>  Vamos a descubrir cu√°l es la raz√≥n. <br><br>  Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN</a> , lo siguiente est√° escrito sobre el resto del operador% division: <br>  "Para operandos enteros, el resultado de a% b es el valor producido por a - (a / b) * b" <br>  En nuestro caso, para a = -5, b = 2 obtenemos: <br>  -5% 2 = (-5) - ((-5) / 2) * 2 = -5 + 4 = -1 <br>  Pero -1 no siempre es igual a 1, lo que explica nuestro resultado False. <br><br>  El operador% es sensible al signo de los operandos.  Por lo tanto, para no recibir tales "sorpresas", es mejor comparar el resultado con cero, que no tiene signo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  O obtenga una funci√≥n separada para verificar la paridad e implementar la l√≥gica a trav√©s de ella: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEvenNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !isEvenNumber(i); }</code> </pre><br></div></div><br><h4>  Ejemplo 4 </h4><br>  Todos los que programaron en C #, probablemente se reunieron con LINQ, que es muy conveniente para trabajar con colecciones, crear consultas, filtrar y agregar datos ... <br><br>  No miraremos bajo el cap√≥ de LINQ.  Tal vez lo haremos en otro momento. <br><br>  Mientras tanto, considere un peque√±o ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }); Console.WriteLine(summResult);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© generar√° este c√≥digo?</b> <div class="spoiler_text">  Obtenemos en pantalla el valor de la variable summResult, que es igual al valor inicial, es decir  0. <br><br>  ¬øPor qu√© sucedi√≥ esto? <br><br>  Y debido a que la definici√≥n de una consulta LINQ y el inicio de esta consulta son dos operaciones que se realizan por separado.  Por lo tanto, la definici√≥n de una solicitud no significa su lanzamiento / ejecuci√≥n. <br><br>  La variable summResult se usa dentro de un delegado an√≥nimo en el m√©todo Select: los elementos de la matriz dataArray se ordenan secuencialmente y se agregan a la variable summResult. <br><br>  Podemos suponer que nuestro c√≥digo imprimir√° la suma de los elementos de la matriz dataArray.  Pero LINQ no funciona de esa manera. <br><br>  Considere la variable selectedData.  La palabra clave var es "az√∫car sint√°ctico", que en muchos casos reduce el tama√±o del c√≥digo del programa y mejora su legibilidad.  Y el tipo real de la variable selectedData implementa la interfaz IEnumerable.  Es decir  nuestro c√≥digo se ve as√≠: <br><br><pre> <code class="cs hljs"> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; });</code> </pre><br>  Aqu√≠ definimos la consulta (Consulta), pero la consulta en s√≠ no se inicia.  De manera similar, puede trabajar con la base de datos especificando la consulta SQL como una cadena, pero para obtener el resultado, consulte la base de datos y ejecute esta consulta expl√≠citamente. <br><br>  Es decir, hasta ahora solo hemos establecido una solicitud, pero no la hemos lanzado.  Es por eso que el valor de la variable summResult permanece sin cambios.  Se puede iniciar una consulta, por ejemplo, utilizando los m√©todos ToArray, ToList o ToDictionary: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        selectedData IEnumerable&lt;int&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; return x; }); //   selectedData selectedData.ToArray(); //    summResult Console.WriteLine(summResult);</span></span></code> </pre><br>  Este c√≥digo ya mostrar√° el valor de la variable summResult, igual a la suma de todos los elementos de la matriz dataArray, igual a 15. <br><br>  Lo descubrimos.  Y entonces, ¬øqu√© mostrar√° este programa en la pantalla? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//1 var summResult = dataArray.Sum() + dataArray.Skip(3).Take(2).Sum(); //2 var groupedData = dataArray.GroupBy(x =&gt; x).Select( //3 x =&gt; { summResult += x.Key; return x.Key; }); Console.WriteLine(summResult); //4</span></span></code> </pre><br>  La variable groupedData (l√≠nea 3) en realidad implementa la interfaz IEnumerable y esencialmente define la solicitud al origen de datos dataArray.  Esto significa que para que un delegado an√≥nimo funcione, lo que cambia el valor de la variable summResult, esta solicitud debe ejecutarse expl√≠citamente.  Pero no hay tal lanzamiento en nuestro programa.  Por lo tanto, el valor de la variable summResult se cambiar√° solo en la l√≠nea 2, y no podemos considerar todo lo dem√°s en nuestros c√°lculos. <br><br>  Entonces es f√°cil calcular el valor de la variable summResult, que es, respectivamente, 15 + 7, es decir  22) <br></div></div><br><h4>  Ejemplo 5 </h4><br>  Digamos de inmediato: no consideramos este ejemplo en nuestras conferencias en la Academia, pero a veces lo discutimos durante las pausas para el caf√© en lugar de una broma. <br><br>  A pesar de que apenas es indicativo desde el punto de vista de determinar el nivel del desarrollador, encontramos este ejemplo en varias pruebas diferentes.  Quiz√°s se usa por versatilidad, porque funciona igual en C y C ++, as√≠ como en C # y Java. <br><br>  Entonces, que haya una l√≠nea de c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">¬øCu√°l ser√° el valor de la variable i?</b> <div class="spoiler_text">  Respuesta: 1 <br><br>  Puede pensar que aqu√≠ se usa la aritm√©tica num√©rica sobre los tama√±os de cada tipo en bytes, ya que los signos "+" y "-" se encuentran de forma inesperada aqu√≠ para la conversi√≥n de tipos. <br><br>  En C #, se sabe que el tipo entero tiene 4 bytes de longitud, 8 de longitud, char 2. <br><br>  Entonces es f√°cil pensar que nuestra l√≠nea de c√≥digo ser√° equivalente a la siguiente expresi√≥n aritm√©tica: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">2</span></span>)-(<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">8</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br>  Sin embargo, esto no es as√≠.  Y para confundir y dirigir con un razonamiento tan falso, el ejemplo se puede cambiar, por ejemplo, de esta manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)-<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  Los signos "+" y "-" se utilizan en este ejemplo no como operaciones aritm√©ticas binarias, sino como operadores unarios.  Entonces, nuestra l√≠nea de c√≥digo es solo una secuencia de conversiones de tipo expl√≠cito mezcladas con llamadas a operaciones unarias, que se pueden escribir de la siguiente manera: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)( <span class="hljs-comment"><span class="hljs-comment">// call explicit operator int(char), ie char to int +( // call unary operator + (char)( // call explicit operator char(int), ie int to char -( // call unary operator - (int)( // call explicit operator int(long), ie long to int +( // call unary operator + (long)( // call explicit operator long(int), ie int to long -1 ) ) ) ) ) ) );</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/0a/wm/vn/0awmvncxvmyw1jzjgc_uavq8rf8.jpeg" alt="imagen"><br><br><h3>  ¬øInteresado en aprender en Veeam Academy? </h3><br>  Ahora hay un conjunto para la primavera intensiva en C # en San Petersburgo, e invitamos a todos a someterse a pruebas en l√≠nea en el sitio web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Veeam Academy.</a> <br><br>  El curso comienza el 18 de febrero de 2019, se extiende hasta mediados de mayo y, como siempre, ser√° completamente gratuito.  El registro para cualquier persona que quiera someterse a pruebas de ingreso ya est√° disponible en el sitio web de la Academia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">academy.veeam.ru</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vg/k6/ol/vgk6olkeyayj8hqamzvva75ycrk.jpeg" alt="imagen" width="50%"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439478/">https://habr.com/ru/post/439478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439466/index.html">La sonda en √≥rbita lunar de la NASA tom√≥ las primeras im√°genes de la estaci√≥n china Chang'e-4: dos p√≠xeles de luz</a></li>
<li><a href="../439468/index.html">Donde lleva la b√∫squeda del SCADA perfecto</a></li>
<li><a href="../439470/index.html">Alemania planea abandonar el carb√≥n en el futuro cercano</a></li>
<li><a href="../439472/index.html">Automatizaci√≥n del control de fronteras dentro de la empresa.</a></li>
<li><a href="../439476/index.html">Argot de Cockney: historia moderna y estatus social</a></li>
<li><a href="../439480/index.html">Ceder, o ¬øPor qu√© su CRM (y CRM) se ralentiza?</a></li>
<li><a href="../439482/index.html">devleads - (des) motivaci√≥n financiera</a></li>
<li><a href="../439484/index.html">Obtener datos de enumeraci√≥n en una perspectiva de Automapper</a></li>
<li><a href="../439486/index.html">Tipos de referencia .NET vs Tipos de valor. Parte 1</a></li>
<li><a href="../439488/index.html">QA Meetup Grabaci√≥n de video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>