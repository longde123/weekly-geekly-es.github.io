<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 锔  Mi rastrillo: de trapos a riquezas 锔 ｐ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 


 He estado trabajando como desarrollador front-end durante un a帽o. Mi primer proyecto fue un backend "enemigo". Sucede que este no es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mi rastrillo: de trapos a riquezas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya">  Antecedentes </h2><br><p>  He estado trabajando como desarrollador front-end durante un a帽o.  Mi primer proyecto fue un backend "enemigo".  Sucede que este no es un gran problema cuando se establece la comunicaci贸n. </p><br><p>  Pero en nuestro caso no fue as铆. </p><a name="habracut"></a><br><p>  Desarrollamos el c贸digo, que se bas贸 en el hecho de que el backend nos env铆a ciertos datos, cierta estructura y cierto formato.  Mientras que el backend consider贸 normal cambiar el contenido de las respuestas, sin previo aviso.  Como resultado, nos llev贸 horas determinar por qu茅 cierta parte del sitio dej贸 de funcionar. </p><br><p>  Nos dimos cuenta de que necesit谩bamos verificar lo que devuelve el backend antes de confiar en los datos que nos envi贸.  Creamos una tarea de investigaci贸n sobre el tema de la validaci贸n de datos desde el front-end. </p><br><p>  Este estudio me fue encargado. </p><br><p>  He hecho una lista de lo que quiero ser en la herramienta que me gustar铆a usar para la validaci贸n de datos. </p><br><p>  Los puntos de selecci贸n m谩s importantes fueron los siguientes: </p><br><ul><li>  Descripci贸n declarativa (esquema) de validaci贸n, que se transforma en una funci贸n de validaci贸n que devuelve verdadero / falso (v谩lido, no v谩lido) </li><li>  umbral de entrada bajo; </li><li> similitud de datos validados con una descripci贸n de validaci贸n; </li><li>  facilidad de integraci贸n de validaciones personalizadas; </li><li>  facilidad de integraci贸n de mensajes de error personalizados. </li></ul><br><p>  Como resultado, encontr茅 muchas bibliotecas de validaci贸n, despu茅s de haber revisado el TOP-5 (ajv, joi, roi ...).  Todos son muy buenos.  Pero me pareci贸 que para resolver el 5% de los casos complejos, condenaron el 95% de los casos m谩s comunes a ser bastante detallados y voluminosos. </p><br><p>  Por lo tanto, pens茅: 驴por qu茅 no desarrollar algo t煤 mismo que me convenga? <br>  Cuatro meses despu茅s, sali贸 la s茅ptima versi贸n de mi biblioteca de validaci贸n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> . <br>  Era una versi贸n estable, totalmente probada, 11k descargas en npm.  Lo usamos en tres proyectos en una campa帽a durante tres meses. </p><br><p>  Estos tres meses han jugado un papel muy 煤til.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Cuarteto ha</a> demostrado todas sus ventajas.  No hay problemas de datos desde el backend.  Cada vez que cambiaron la respuesta, inmediatamente arrojamos un error.  El tiempo dedicado a encontrar las causas de los errores ha disminuido dram谩ticamente.  Pr谩cticamente no quedan errores de datos. </p><br><p>  Pero tambi茅n se identificaron fallas. </p><br><p>  Por lo tanto, decid铆 analizarlos y lanzar una nueva versi贸n con correcciones de todos los errores que se cometieron durante el desarrollo. <br>  Hablar茅 sobre estos errores arquitect贸nicos y sus soluciones a continuaci贸n. </p><br><h2 id="arhitekturnye-grabli">  Rastrillo arquitect贸nico </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Stroko" - un lenguaje tipificado del esquema </h3><br><p>  Dar茅 un ejemplo de la versi贸n anterior del esquema para el objeto de la persona. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  Este esquema valida un objeto con tres propiedades: nombre - debe ser una cadena, edad - debe ser un n煤mero, enlace a una cuenta en LinkedIn - debe ser nulo (si no hay cuenta) o cadena (si hay una cuenta). </p><br><p>  Este esquema cumple con mis requisitos de legibilidad, similitud con datos validados, y creo que el umbral de entrada para aprender a escribir dichos esquemas no es alto.  Adem谩s, dicho esquema se puede escribir f谩cilmente con una definici贸n de tipo en mecanografiado: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (Como puede ver, es m谩s probable que los cambios sean cosm茅ticos) </p><br><p>  Cuando tom茅 una decisi贸n, qu茅 deber铆a usarse para las opciones de validaci贸n m谩s frecuentes (por ejemplo, las que se usaron anteriormente).  Eleg铆 usar - cadenas, por as铆 decirlo, los nombres de los validadores. </p><br><p>  Pero el problema con las cadenas es que no est谩n disponibles para el compilador o el analizador de errores.  La cadena 'n煤mero' para ellos no es muy diferente de 'numder'. </p><br><h3 id="reshenie">  Soluci贸n </h3><br><p>  La nueva versi贸n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> 8.0.0.  Decid铆 eliminar del cuarteto: el uso de cadenas como nombres de validadores dentro del esquema. </p><br><p>  El diagrama ahora se ve as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  Este cambio tiene dos grandes ventajas: </p><br><ul><li>  compiladores o analizadores de errores: podr谩n detectar que el nombre del m茅todo est谩 escrito con un error. </li><li>  L铆neas: ya no se utilizan como elemento de esquema.  Esto significa que para ellos puede seleccionar una nueva funcionalidad en la biblioteca, que se describir谩 a continuaci贸n. </li></ul><br><h3 id="podderzhka-typescript">  Soporte de TypeScript </h3><br><p>  En general, las primeras siete versiones se desarrollaron en Javascript puro.  Al cambiar a un proyecto con Typecript, era necesario adaptar de alguna manera la biblioteca.  Por lo tanto, se escribieron declaraciones de tipo para la biblioteca. </p><br><p>  Pero esto era un inconveniente: al agregar funcionalidad o al cambiar algunos elementos de la biblioteca, siempre era f谩cil olvidarse de actualizar las declaraciones de tipo. </p><br><p>  Tambi茅n hubo inconvenientes menores de este tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Cuando creamos el validador de objetos en la l铆nea (0).  Nos gustar铆a despu茅s de verificar la respuesta real del backend en la l铆nea (1) y manejar el error.  En la l铆nea (2) para que esa <code>person</code> tipo Persona.  Pero esto no sucedi贸.  Desafortunadamente, tal verificaci贸n no era un tipo de guardia. </p><br><h3 id="reshenie-1">  Soluci贸n </h3><br><p>  Decid铆 reescribir toda la biblioteca del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> en Typecript para que el compilador se ocupara de verificar la correspondencia de la biblioteca con los tipos.  En el camino, agregamos a la funci贸n que devuelve al validador compilado un par谩metro de tipo que determinar铆a qu茅 tipo de protecci贸n es este tipo de validador. </p><br><p>  Un ejemplo se ve as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Ahora en l铆nea (2) <code>person</code> es del tipo <code>Person</code> . </p><br><h3 id="chitaemost">  Legibilidad </h3><br><p>  Tambi茅n hubo dos casos en los que el c贸digo se ley贸 mal: verificar el cumplimiento de un determinado conjunto de valores (verificaciones de enumeraciones) y verificar otras propiedades del objeto. </p><br><p>  a) Verificar enumeraciones <br>  Inicialmente, hab铆a una idea, en mi opini贸n, una buena.  Lo demostraremos agregando el campo "g茅nero" a nuestro objeto. <br>  La versi贸n anterior del circuito se ve铆a as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  La opci贸n es muy legible.  Pero como de costumbre, todo sali贸 un poco fuera de lo planeado. <br>  Tener una enumeraci贸n declarada en el programa, por ejemplo, esto: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Naturalmente quiero usarlo dentro del circuito.  De modo que al cambiar uno de los valores (por ejemplo, 'masculino' -&gt; 'm', 'femenino' -&gt; 'f'), el esquema de validaci贸n tambi茅n debe cambiar. </p><br><p>  Por lo tanto, casi siempre la validaci贸n de enumeraci贸n se escribi贸 as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  Lo cual se ve bastante voluminoso. </p><br><p>  b) Validaci贸n de las propiedades residuales del objeto. </p><br><p>  Supongamos que agregamos una caracter铆stica de este tipo a nuestro objeto (puede tener campos adicionales, pero todos deben ser enlaces a redes sociales), lo que significa que deben ser <code>null</code> o una cadena. </p><br><p>  El viejo esquema se ver铆a as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  Esta entrada resalt贸 las propiedades restantes, de las que ya figuran.  Es m谩s probable que el uso de un operador de propagaci贸n confunda a una persona que quiere comprender este esquema. </p><br><h3 id="reshenie-2">  Soluci贸n </h3><br><p>  Como se describi贸 anteriormente, las cadenas ya no son parte de los esquemas de validaci贸n.  Solo quedaron tres tipos de valores de Javascript como esquema de validaci贸n.  Objeto: para describir el esquema de validaci贸n del objeto.  Matriz para la descripci贸n: varias opciones de validez.  Funci贸n (biblioteca generada o personalizada): para todas las dem谩s opciones de validaci贸n. </p><br><p>  Esta disposici贸n permiti贸 agregar funcionalidad, lo que permiti贸 aumentar la legibilidad del circuito muchas veces. </p><br><p>  De hecho, 驴qu茅 pasa si queremos comparar el valor con la cadena 'masculino'?  驴Realmente necesitamos saber algo m谩s adem谩s del valor en s铆 y la cadena 'masculino'? </p><br><p>  Por lo tanto, se decidi贸 agregar los valores de los tipos primitivos como un elemento del circuito.  Por lo tanto, cuando cumple un valor primitivo en el esquema, esto significa que este es el valor v谩lido que el validador creado de acuerdo con este esquema debe verificar.  Ser谩 mejor que d茅 un ejemplo: </p><br><p>  Si necesitamos verificar el n煤mero para la igualdad 42-mente.  Luego lo escribimos as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Veamos c贸mo esto afecta el esquema de persona (sin tener en cuenta las propiedades adicionales): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  Usando enumeraciones predefinidas, podemos reescribirlo as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  En este caso, se elimin贸 la ceremonialidad innecesaria en la forma de usar el m茅todo enum y usar el operador de propagaci贸n para insertar valores v谩lidos del objeto como par谩metros en este m茅todo. </p><br><p>  Lo que se considera un valor primitivo: n煤meros, cadenas, caracteres, <code>true</code> , <code>false</code> , <code>null</code> e <code>undefined</code> . </p><br><p>  Es decir, si necesitamos comparar el valor con ellos, simplemente usamos estos valores ellos mismos.  Y una biblioteca de validaci贸n: crear谩 un validador que compara estrictamente el valor con los especificados en el esquema. </p><br><p>  Para validar las propiedades residuales, se eligi贸 usar una propiedad especial para todos los dem谩s campos del objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Por lo tanto, el circuito parece m谩s legible.  Y m谩s como anuncios de Typecript. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  El validador est谩 relacionado con la funci贸n que lo cre贸. </h3><br><p>  En versiones anteriores, las explicaciones de error no formaban parte del validador.  Se agregaron a una matriz dentro de la funci贸n <code>v</code> . </p><br><p>  Anteriormente, para obtener una explicaci贸n de los errores de validaci贸n, ten铆a que tener un validador con usted (para verificar) yv (para obtener una explicaci贸n de invalidez).  Todo esto parec铆a lo siguiente: <br><br>  a) Agregamos explicaciones al diagrama </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  Para cualquier elemento del circuito, puede agregar una explicaci贸n del error utilizando el segundo argumento de la funci贸n del compilador v. </p><br><p>  b) Borrar la matriz de explicaci贸n </p><br><p>  Antes de la validaci贸n, era necesario borrar esta matriz global en la que se registraron todas las explicaciones durante la validaci贸n. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Validar </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  Durante esta verificaci贸n, si se detect贸 una validez, y en la etapa de creaci贸n del circuito, se le dio una explicaci贸n, esta explicaci贸n se coloca en la <code>v.explanation</code> global <code>v.explanation</code> . </p><br><p>  d) Manejo de errores </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  Como puede ver aqu铆 hay un gran problema.  Porque si queremos usar el validador no en el lugar de su creaci贸n.  Necesitaremos pasarlo no solo a los par谩metros, sino tambi茅n a la funci贸n que lo cre贸.  Porque es all铆 donde se ubica la matriz en la que se agregar谩n las explicaciones. </p><br><h3 id="reshenie-3">  Soluci贸n </h3><br><p>  Este problema se resolvi贸 de la siguiente manera: las explicaciones se convirtieron en parte de la funci贸n de validaci贸n.  Lo que se puede entender de su tipo: <br>  tipo Validator = (valor: any, explicaciones?: any []) =&gt; boolean </p><br><p>  Ahora, si necesita una explicaci贸n del error, pasa la matriz a la que desea agregar la explicaci贸n. </p><br><p>  Por lo tanto, el validador se convierte en una unidad independiente.  Tambi茅n se ha agregado un m茅todo que puede transformar la funci贸n de validaci贸n en una funci贸n que devuelve nulo si el valor es v谩lido y devuelve una matriz de explicaciones si el valor no es v谩lido. </p><br><p>  Ahora la validaci贸n con explicaciones se ve as铆: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Ep铆logo </h2><br><p>  Destaqu茅 tres premisas por las cuales tuve que reescribir todo: </p><br><ul><li>  La esperanza de que las personas no se equivoquen al escribir l铆neas </li><li>  Uso de variables globales (en este caso, v.explanation array) </li><li>  Las pruebas con peque帽os ejemplos durante el desarrollo no mostraron los problemas que surgen cuando se usan en casos realmente grandes. </li></ul><br><p>  Pero me alegro de haber realizado un an谩lisis de estos problemas, y la versi贸n lanzada ya se utiliza en nuestro proyecto.  Y espero que nos sea 煤til no menos que el anterior. </p><br><p>  Gracias a todos por leer, espero que mi experiencia les sea 煤til. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453502/">https://habr.com/ru/post/453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453484/index.html">Contador BCD de 4 bits</a></li>
<li><a href="../453486/index.html">Principios de libre mercado de EE. UU.</a></li>
<li><a href="../453490/index.html">Noticias del mundo de OpenStreetMap No. 461 (14/05/2019 - 05/05/2019)</a></li>
<li><a href="../453492/index.html">Automatizaci贸n de procesos comerciales de la empresa Trello utilizando tecnolog铆a de modelado sem谩ntico</a></li>
<li><a href="../453496/index.html">Feliz qu铆mico, colegas</a></li>
<li><a href="../453508/index.html">Hombre sin tel茅fono inteligente</a></li>
<li><a href="../453510/index.html">Todo tuyo: Tutorial sobre la creaci贸n de nuevas acciones para UiPath RPA</a></li>
<li><a href="../453512/index.html">Transferencia de estilo</a></li>
<li><a href="../453514/index.html">Gu铆a de ofertas introductorias en iOS</a></li>
<li><a href="../453516/index.html">Automatizaci贸n para los m谩s peque帽os. Parte cero Planificacion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>