<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 ✌️ 🖖 Mi rastrillo: de trapos a riquezas ☠️ 🚣🏼 🔻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 


 He estado trabajando como desarrollador front-end durante un año. Mi primer proyecto fue un backend "enemigo". Sucede que este no es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mi rastrillo: de trapos a riquezas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya">  Antecedentes </h2><br><p>  He estado trabajando como desarrollador front-end durante un año.  Mi primer proyecto fue un backend "enemigo".  Sucede que este no es un gran problema cuando se establece la comunicación. </p><br><p>  Pero en nuestro caso no fue así. </p><a name="habracut"></a><br><p>  Desarrollamos el código, que se basó en el hecho de que el backend nos envía ciertos datos, cierta estructura y cierto formato.  Mientras que el backend consideró normal cambiar el contenido de las respuestas, sin previo aviso.  Como resultado, nos llevó horas determinar por qué cierta parte del sitio dejó de funcionar. </p><br><p>  Nos dimos cuenta de que necesitábamos verificar lo que devuelve el backend antes de confiar en los datos que nos envió.  Creamos una tarea de investigación sobre el tema de la validación de datos desde el front-end. </p><br><p>  Este estudio me fue encargado. </p><br><p>  He hecho una lista de lo que quiero ser en la herramienta que me gustaría usar para la validación de datos. </p><br><p>  Los puntos de selección más importantes fueron los siguientes: </p><br><ul><li>  Descripción declarativa (esquema) de validación, que se transforma en una función de validación que devuelve verdadero / falso (válido, no válido) </li><li>  umbral de entrada bajo; </li><li> similitud de datos validados con una descripción de validación; </li><li>  facilidad de integración de validaciones personalizadas; </li><li>  facilidad de integración de mensajes de error personalizados. </li></ul><br><p>  Como resultado, encontré muchas bibliotecas de validación, después de haber revisado el TOP-5 (ajv, joi, roi ...).  Todos son muy buenos.  Pero me pareció que para resolver el 5% de los casos complejos, condenaron el 95% de los casos más comunes a ser bastante detallados y voluminosos. </p><br><p>  Por lo tanto, pensé: ¿por qué no desarrollar algo tú mismo que me convenga? <br>  Cuatro meses después, salió la séptima versión de mi biblioteca de validación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> . <br>  Era una versión estable, totalmente probada, 11k descargas en npm.  Lo usamos en tres proyectos en una campaña durante tres meses. </p><br><p>  Estos tres meses han jugado un papel muy útil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Cuarteto ha</a> demostrado todas sus ventajas.  No hay problemas de datos desde el backend.  Cada vez que cambiaron la respuesta, inmediatamente arrojamos un error.  El tiempo dedicado a encontrar las causas de los errores ha disminuido dramáticamente.  Prácticamente no quedan errores de datos. </p><br><p>  Pero también se identificaron fallas. </p><br><p>  Por lo tanto, decidí analizarlos y lanzar una nueva versión con correcciones de todos los errores que se cometieron durante el desarrollo. <br>  Hablaré sobre estos errores arquitectónicos y sus soluciones a continuación. </p><br><h2 id="arhitekturnye-grabli">  Rastrillo arquitectónico </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Stroko" - un lenguaje tipificado del esquema </h3><br><p>  Daré un ejemplo de la versión anterior del esquema para el objeto de la persona. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  Este esquema valida un objeto con tres propiedades: nombre - debe ser una cadena, edad - debe ser un número, enlace a una cuenta en LinkedIn - debe ser nulo (si no hay cuenta) o cadena (si hay una cuenta). </p><br><p>  Este esquema cumple con mis requisitos de legibilidad, similitud con datos validados, y creo que el umbral de entrada para aprender a escribir dichos esquemas no es alto.  Además, dicho esquema se puede escribir fácilmente con una definición de tipo en mecanografiado: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (Como puede ver, es más probable que los cambios sean cosméticos) </p><br><p>  Cuando tomé una decisión, qué debería usarse para las opciones de validación más frecuentes (por ejemplo, las que se usaron anteriormente).  Elegí usar - cadenas, por así decirlo, los nombres de los validadores. </p><br><p>  Pero el problema con las cadenas es que no están disponibles para el compilador o el analizador de errores.  La cadena 'número' para ellos no es muy diferente de 'numder'. </p><br><h3 id="reshenie">  Solución </h3><br><p>  La nueva versión del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> 8.0.0.  Decidí eliminar del cuarteto: el uso de cadenas como nombres de validadores dentro del esquema. </p><br><p>  El diagrama ahora se ve así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  Este cambio tiene dos grandes ventajas: </p><br><ul><li>  compiladores o analizadores de errores: podrán detectar que el nombre del método está escrito con un error. </li><li>  Líneas: ya no se utilizan como elemento de esquema.  Esto significa que para ellos puede seleccionar una nueva funcionalidad en la biblioteca, que se describirá a continuación. </li></ul><br><h3 id="podderzhka-typescript">  Soporte de TypeScript </h3><br><p>  En general, las primeras siete versiones se desarrollaron en Javascript puro.  Al cambiar a un proyecto con Typecript, era necesario adaptar de alguna manera la biblioteca.  Por lo tanto, se escribieron declaraciones de tipo para la biblioteca. </p><br><p>  Pero esto era un inconveniente: al agregar funcionalidad o al cambiar algunos elementos de la biblioteca, siempre era fácil olvidarse de actualizar las declaraciones de tipo. </p><br><p>  También hubo inconvenientes menores de este tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Cuando creamos el validador de objetos en la línea (0).  Nos gustaría después de verificar la respuesta real del backend en la línea (1) y manejar el error.  En la línea (2) para que esa <code>person</code> tipo Persona.  Pero esto no sucedió.  Desafortunadamente, tal verificación no era un tipo de guardia. </p><br><h3 id="reshenie-1">  Solución </h3><br><p>  Decidí reescribir toda la biblioteca del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">cuarteto</a> en Typecript para que el compilador se ocupara de verificar la correspondencia de la biblioteca con los tipos.  En el camino, agregamos a la función que devuelve al validador compilado un parámetro de tipo que determinaría qué tipo de protección es este tipo de validador. </p><br><p>  Un ejemplo se ve así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Ahora en línea (2) <code>person</code> es del tipo <code>Person</code> . </p><br><h3 id="chitaemost">  Legibilidad </h3><br><p>  También hubo dos casos en los que el código se leyó mal: verificar el cumplimiento de un determinado conjunto de valores (verificaciones de enumeraciones) y verificar otras propiedades del objeto. </p><br><p>  a) Verificar enumeraciones <br>  Inicialmente, había una idea, en mi opinión, una buena.  Lo demostraremos agregando el campo "género" a nuestro objeto. <br>  La versión anterior del circuito se veía así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  La opción es muy legible.  Pero como de costumbre, todo salió un poco fuera de lo planeado. <br>  Tener una enumeración declarada en el programa, por ejemplo, esto: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Naturalmente quiero usarlo dentro del circuito.  De modo que al cambiar uno de los valores (por ejemplo, 'masculino' -&gt; 'm', 'femenino' -&gt; 'f'), el esquema de validación también debe cambiar. </p><br><p>  Por lo tanto, casi siempre la validación de enumeración se escribió así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  Lo cual se ve bastante voluminoso. </p><br><p>  b) Validación de las propiedades residuales del objeto. </p><br><p>  Supongamos que agregamos una característica de este tipo a nuestro objeto (puede tener campos adicionales, pero todos deben ser enlaces a redes sociales), lo que significa que deben ser <code>null</code> o una cadena. </p><br><p>  El viejo esquema se vería así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  Esta entrada resaltó las propiedades restantes, de las que ya figuran.  Es más probable que el uso de un operador de propagación confunda a una persona que quiere comprender este esquema. </p><br><h3 id="reshenie-2">  Solución </h3><br><p>  Como se describió anteriormente, las cadenas ya no son parte de los esquemas de validación.  Solo quedaron tres tipos de valores de Javascript como esquema de validación.  Objeto: para describir el esquema de validación del objeto.  Matriz para la descripción: varias opciones de validez.  Función (biblioteca generada o personalizada): para todas las demás opciones de validación. </p><br><p>  Esta disposición permitió agregar funcionalidad, lo que permitió aumentar la legibilidad del circuito muchas veces. </p><br><p>  De hecho, ¿qué pasa si queremos comparar el valor con la cadena 'masculino'?  ¿Realmente necesitamos saber algo más además del valor en sí y la cadena 'masculino'? </p><br><p>  Por lo tanto, se decidió agregar los valores de los tipos primitivos como un elemento del circuito.  Por lo tanto, cuando cumple un valor primitivo en el esquema, esto significa que este es el valor válido que el validador creado de acuerdo con este esquema debe verificar.  Será mejor que dé un ejemplo: </p><br><p>  Si necesitamos verificar el número para la igualdad 42-mente.  Luego lo escribimos así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Veamos cómo esto afecta el esquema de persona (sin tener en cuenta las propiedades adicionales): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  Usando enumeraciones predefinidas, podemos reescribirlo así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  En este caso, se eliminó la ceremonialidad innecesaria en la forma de usar el método enum y usar el operador de propagación para insertar valores válidos del objeto como parámetros en este método. </p><br><p>  Lo que se considera un valor primitivo: números, cadenas, caracteres, <code>true</code> , <code>false</code> , <code>null</code> e <code>undefined</code> . </p><br><p>  Es decir, si necesitamos comparar el valor con ellos, simplemente usamos estos valores ellos mismos.  Y una biblioteca de validación: creará un validador que compara estrictamente el valor con los especificados en el esquema. </p><br><p>  Para validar las propiedades residuales, se eligió usar una propiedad especial para todos los demás campos del objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Por lo tanto, el circuito parece más legible.  Y más como anuncios de Typecript. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  El validador está relacionado con la función que lo creó. </h3><br><p>  En versiones anteriores, las explicaciones de error no formaban parte del validador.  Se agregaron a una matriz dentro de la función <code>v</code> . </p><br><p>  Anteriormente, para obtener una explicación de los errores de validación, tenía que tener un validador con usted (para verificar) yv (para obtener una explicación de invalidez).  Todo esto parecía lo siguiente: <br><br>  a) Agregamos explicaciones al diagrama </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  Para cualquier elemento del circuito, puede agregar una explicación del error utilizando el segundo argumento de la función del compilador v. </p><br><p>  b) Borrar la matriz de explicación </p><br><p>  Antes de la validación, era necesario borrar esta matriz global en la que se registraron todas las explicaciones durante la validación. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Validar </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  Durante esta verificación, si se detectó una validez, y en la etapa de creación del circuito, se le dio una explicación, esta explicación se coloca en la <code>v.explanation</code> global <code>v.explanation</code> . </p><br><p>  d) Manejo de errores </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  Como puede ver aquí hay un gran problema.  Porque si queremos usar el validador no en el lugar de su creación.  Necesitaremos pasarlo no solo a los parámetros, sino también a la función que lo creó.  Porque es allí donde se ubica la matriz en la que se agregarán las explicaciones. </p><br><h3 id="reshenie-3">  Solución </h3><br><p>  Este problema se resolvió de la siguiente manera: las explicaciones se convirtieron en parte de la función de validación.  Lo que se puede entender de su tipo: <br>  tipo Validator = (valor: any, explicaciones?: any []) =&gt; boolean </p><br><p>  Ahora, si necesita una explicación del error, pasa la matriz a la que desea agregar la explicación. </p><br><p>  Por lo tanto, el validador se convierte en una unidad independiente.  También se ha agregado un método que puede transformar la función de validación en una función que devuelve nulo si el valor es válido y devuelve una matriz de explicaciones si el valor no es válido. </p><br><p>  Ahora la validación con explicaciones se ve así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Epílogo </h2><br><p>  Destaqué tres premisas por las cuales tuve que reescribir todo: </p><br><ul><li>  La esperanza de que las personas no se equivoquen al escribir líneas </li><li>  Uso de variables globales (en este caso, v.explanation array) </li><li>  Las pruebas con pequeños ejemplos durante el desarrollo no mostraron los problemas que surgen cuando se usan en casos realmente grandes. </li></ul><br><p>  Pero me alegro de haber realizado un análisis de estos problemas, y la versión lanzada ya se utiliza en nuestro proyecto.  Y espero que nos sea útil no menos que el anterior. </p><br><p>  Gracias a todos por leer, espero que mi experiencia les sea útil. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453502/">https://habr.com/ru/post/453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453484/index.html">Contador BCD de 4 bits</a></li>
<li><a href="../453486/index.html">Principios de libre mercado de EE. UU.</a></li>
<li><a href="../453490/index.html">Noticias del mundo de OpenStreetMap No. 461 (14/05/2019 - 05/05/2019)</a></li>
<li><a href="../453492/index.html">Automatización de procesos comerciales de la empresa Trello utilizando tecnología de modelado semántico</a></li>
<li><a href="../453496/index.html">Feliz químico, colegas</a></li>
<li><a href="../453508/index.html">Hombre sin teléfono inteligente</a></li>
<li><a href="../453510/index.html">Todo tuyo: Tutorial sobre la creación de nuevas acciones para UiPath RPA</a></li>
<li><a href="../453512/index.html">Transferencia de estilo</a></li>
<li><a href="../453514/index.html">Guía de ofertas introductorias en iOS</a></li>
<li><a href="../453516/index.html">Automatización para los más pequeños. Parte cero Planificacion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>