<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüë® üßú üïù Singleton pla√ßant des objets dans la ROM et des variables statiques (C ++ en utilisant le microcontr√¥leur Cortex M4 comme exemple) üëåüèæ üéä üíÉüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l'article pr√©c√©dent O√π vos constantes sont stock√©es sur le microcontr√¥leur CortexM (en utilisant le compilateur C ++ IAR comme exemple) , la ques...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singleton pla√ßant des objets dans la ROM et des variables statiques (C ++ en utilisant le microcontr√¥leur Cortex M4 comme exemple)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="image"><br><br>  Dans l'article pr√©c√©dent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">O√π vos constantes sont stock√©es sur le microcontr√¥leur CortexM (en utilisant le compilateur C ++ IAR comme exemple)</a> , la question de savoir comment placer des objets constants dans la ROM a √©t√© discut√©e.  Maintenant, je veux vous dire comment vous pouvez utiliser le mod√®le de g√©n√©rateur isol√© pour cr√©er des objets dans la ROM. <br><a name="habracut"></a><br><br><h3>  Pr√©sentation </h3><br>  Beaucoup a d√©j√† √©t√© √©crit sur Singleton (ci-apr√®s d√©nomm√© Singleton) ses c√¥t√©s positifs et n√©gatifs.  Mais malgr√© ses lacunes, il poss√®de de nombreuses propri√©t√©s utiles, notamment dans le cadre du firmware des microcontr√¥leurs. <br><br>  Pour commencer, pour un logiciel de microcontr√¥leur fiable, il n'est pas recommand√© de cr√©er des objets de mani√®re dynamique, et il n'est donc pas n√©cessaire de les supprimer.  Souvent, les objets sont cr√©√©s une fois et vivent √† partir du moment o√π l'appareil est d√©marr√©, jusqu'√† ce qu'il soit √©teint.  Un tel objet peut m√™me √™tre la jambe de port √† laquelle la LED est connect√©e, il est cr√©√© une fois, et il n'ira certainement nulle part pendant que l'application est en cours d'ex√©cution, et il peut √©videmment s'agir de Singleton.  Quelqu'un devrait cr√©er de tels objets et ce pourrait √™tre Singleton. <br><br>  Singleton vous donnera √©galement la garantie que le m√™me objet d√©crivant la jambe de port ne sera pas cr√©√© deux fois s'il est soudainement utilis√© √† plusieurs endroits. <br><br>  Une autre, √† mon avis, une propri√©t√© remarquable de Singleton est sa facilit√© d'utilisation.  Par exemple, comme dans le cas du gestionnaire d'interruption, dont un exemple se trouve √† la fin de l'article.  Mais pour l'instant, nous allons traiter avec Singleton lui-m√™me. <br><br><h3>  Singleton cr√©ant des objets en RAM </h3><br>  En g√©n√©ral, beaucoup d'articles ont d√©j√† √©t√© √©crits √† leur sujet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton (Loner) ou une classe statique?</a>  ou le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de l'√¢ge de trois singleton</a> .  Par cons√©quent, je ne vais pas me concentrer sur ce qu'est Singleton et d√©crire toutes les nombreuses options pour sa mise en ≈ìuvre.  Au lieu de cela, je me concentrerai sur deux options qui peuvent √™tre utilis√©es dans le firmware. <br>  Pour commencer, je vais clarifier quelle est la diff√©rence entre le firmware du microcontr√¥leur par rapport √† l'habituel et pourquoi certaines impl√©mentations singleton pour ce logiciel sont "meilleures" que d'autres.  Certains crit√®res proviennent des exigences pour le firmware, et certains simplement de mon exp√©rience: <br><br><ul><li>  Dans le firmware, il n'est pas recommand√© de cr√©er des objets dynamiquement </li><li>  Souvent dans le firmware, un objet est cr√©√© statiquement et n'est jamais d√©truit. </li><li>  Eh bien, si l'emplacement de l'objet est connu au stade de la compilation </li></ul><br>  Sur la base de ces hypoth√®ses, nous consid√©rons deux variantes de Singleton avec des objets cr√©√©s statiquement, et probablement la plus c√©l√®bre et la plus commune est Meyers Singleton, soit dit en passant, bien qu'elle devrait √™tre s√©curis√©e pour les threads par la norme C ++, les compilateurs pour le firmware le font comme ceci (par exemple, IAR), uniquement lorsque l'option sp√©ciale est activ√©e: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br>  Il utilise une initialisation retard√©e, c'est-√†-dire  L'initialisation d'un objet ne se produit que la premi√®re fois que <code>GetInstance()</code> appel√©e; consid√©rez cette initiation dynamique. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br>  Et Singleton sans initialisation retard√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br>  Les deux singleton cr√©ent des objets dans la RAM, la diff√©rence est que pour le second, l'initialisation se produit imm√©diatement apr√®s le d√©marrage du programme et le premier est initialis√© lors du premier appel. <br><br>  Comment peuvent-ils √™tre utilis√©s dans la vraie vie.  Selon la vieille tradition, je vais essayer de le montrer en utilisant l'exemple d'une LED.  Supposons donc que nous ayons besoin de cr√©er un objet de classe <code>Led1</code> , qui n'est en fait qu'un alias de la classe <code>Pin&lt;PortA, 5&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Au cas o√π, les classes Port et Pin ressemblent √† ceci</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br>  Dans l'exemple, j'ai cr√©√© jusqu'√† 4 objets diff√©rents du m√™me type en RAM et ROM, qui fonctionnent en fait avec la m√™me sortie du port A. Ce qui n'est pas tr√®s bon ici: <br>  Eh bien, la premi√®re chose est que j'ai apparemment oubli√© que <code>GreenLed</code> et <code>Led1</code> sont du m√™me type et ont cr√©√© plusieurs objets identiques prenant de la place √† diff√©rentes adresses.  En fait, j'ai m√™me oubli√© que j'avais d√©j√† cr√©√© globalement des objets des <code>GreenLed</code> <code>Led1</code> et <code>GreenLed</code> , et les <code>GreenLed</code> √©galement cr√©√©s localement. <br><br>  Deuxi√®mement, d√©clarer g√©n√©ralement des objets globaux n'est pas le bienvenu, <br><br><div class="spoiler">  <b class="spoiler_title">Lignes directrices de programmation pour une meilleure optimisation du compilateur</b> <div class="spoiler_text">  <i>Les variables locales du module - les variables d√©clar√©es statiques - sont pr√©f√©r√©es aux</i> <i><br></i>  <i>variables globales (non statiques).</i>  <i>√âvitez √©galement de prendre l'adresse des variables statiques fr√©quemment utilis√©es.</i> <i><br></i> </div></div><br>  et les objets locaux ne sont disponibles que dans le cadre de la fonction main (). <br><br>  Par cons√©quent, nous r√©√©crivons cet exemple en utilisant Singleton: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br>  Dans ce cas, quoi que j'oublie, mes liens pointeront toujours vers le m√™me objet.  Et je peux obtenir ce lien n'importe o√π dans le programme, dans n'importe quelle m√©thode, y compris, par exemple, dans la m√©thode statique du gestionnaire d'interruption, mais plus √† ce sujet plus tard.  En toute honn√™tet√©, je dois dire que le code ne fait rien et que l'erreur dans la logique du programme n'a pas disparu.  Eh bien, voyons o√π et comment en g√©n√©ral cet objet statique cr√©√© par Singleton a √©t√© localis√© et comment il a √©t√© initialis√©? <br><br><h3>  Objet statique </h3><br>  Avant de le d√©couvrir, il serait bon de comprendre ce qu'est un objet statique. <br><br>  Si vous d√©clarez des membres de classe avec le mot cl√© statique, cela signifie que les membres de classe ne sont tout simplement pas li√©s aux instances de classe, ce sont des variables ind√©pendantes et vous pouvez acc√©der √† ces champs sans cr√©er d'objet de classe.  Rien ne menace leur vie depuis leur naissance jusqu'√† la sortie du programme. <br><br>  Lorsqu'il est utilis√© dans une d√©claration d'objet, le sp√©cificateur statique d√©termine uniquement la dur√©e de vie de l'objet.  En gros, la m√©moire d'un tel objet est allou√©e au d√©marrage du programme et lib√©r√©e √† la fin du programme; au d√©marrage, leur initialisation a √©galement lieu.  Les seules exceptions sont les objets statiques locaux qui, bien qu'ils ne ¬´meurent¬ª qu'√† la fin du programme, sont essentiellement ¬´n√©s¬ª, ou plut√¥t, sont initialis√©s la premi√®re fois qu'ils passent par leur d√©claration. <br><br><blockquote>  L'initialisation dynamique d'une variable locale avec stockage statique est effectu√©e pour la premi√®re fois lors du premier passage √† travers sa d√©claration;  une telle variable est consid√©r√©e comme initialis√©e √† l'issue de son initialisation.  Si un thread passe par une d√©claration de variable au moment de son initialisation par un autre thread, il doit attendre la fin de l'initialisation. </blockquote><br>  Dans les appels suivants, l'initialisation ne se produit pas.  Tout ce qui pr√©c√®de peut √™tre r√©duit √† une phrase, <u>une seule instance d'un objet statique peut exister.</u> <br><br>  De telles difficult√©s conduisent au fait que l'utilisation de variables et d'objets statiques locaux dans le firmware entra√Ænera une surcharge suppl√©mentaire.  Vous pouvez le v√©rifier avec un exemple simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Ici, la premi√®re fois que la fonction <code>foo()</code> est appel√©e, le compilateur doit v√©rifier que l'objet statique local <code>test1</code> n'a pas encore √©t√© initialis√© et appeler le constructeur de l'objet <code>test1</code> <code>Test1(10)</code> , et dans la deuxi√®me passe et les suivantes, il doit s'assurer que l'objet est d√©j√† initialis√© et ignorer cette √©tape. aller directement pour <code>return test</code> . <br><br>  Pour ce faire, le compilateur ajoute simplement un indicateur de protection suppl√©mentaire <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> et ins√®re le code de v√©rification.  Lors de la premi√®re d√©claration d'une variable statique, cet indicateur de protection n'est pas d√©fini et donc l'objet doit √™tre initialis√© en appelant le constructeur; lors de la prochaine passe, cet indicateur est d√©j√† d√©fini, il n'y a donc plus besoin d'initialisation et l'appel du constructeur est ignor√©.  De plus, cette v√©rification sera effectu√©e en continu dans la boucle for. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br>  Et si vous activez l'option qui vous garantira l'initialisation dans les applications multi-thread, alors il y aura encore plus de code ... (voir l'appel √† capturer et lib√©rer la ressource lors de l'initialisation est soulign√© en orange) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="image"></a> <br><br>  Ainsi, le prix d'utilisation d'une variable ou d'un objet statique dans le micrologiciel augmente √† la fois en taille de RAM et en taille de code.  Et ce fait serait bien √† garder √† l'esprit et √† consid√©rer lors du d√©veloppement. <br><br>  Un autre inconv√©nient est le fait que le drapeau de protection est n√© avec la variable statique, sa dur√©e de vie est √©gale √† la dur√©e de vie de l'objet statique, il est cr√©√© par le compilateur lui-m√™me et vous n'y avez pas acc√®s pendant le d√©veloppement.  C'est-√†-dire  si tout √† coup pour une raison <br><br><div class="spoiler">  <b class="spoiler_title">voir crash al√©atoire</b> <div class="spoiler_text">  Les causes des erreurs al√©atoires sont: (1) les particules alpha r√©sultant du processus de d√©sint√©gration, (2) les neutrons, (3) une source externe de rayonnement √©lectromagn√©tique et (4) la diaphonie interne. <br></div></div><br>  Si l'indicateur de 1 passe √† 0, l'initialisation avec la valeur initiale est √† nouveau appel√©e.  Ce n'est pas bon, et il faut aussi garder √† l'esprit.  Pour r√©sumer les variables statiques: <br><blockquote>  Pour tout objet statique (que ce soit une variable locale ou un attribut de classe), la m√©moire est allou√©e une fois et ne changera pas tout au long de l'application. <br><br>  Les variables statiques locales sont initialis√©es lors du premier passage √† travers une d√©claration de variable. <br><br>  Les attributs de classe statiques, ainsi que les variables globales statiques, sont initialis√©s imm√©diatement apr√®s le d√©marrage de l'application.  De plus, cet ordre n'est pas d√©fini </blockquote>  Revenons maintenant √† Singleton. <br><br><h3>  Singleton pla√ßant un objet dans la ROM </h3><br>  De tout ce qui pr√©c√®de, nous pouvons conclure que pour nous, Singleton Mayers peut avoir les inconv√©nients suivants: des co√ªts suppl√©mentaires de RAM et de ROM, un indicateur de s√©curit√© non contr√¥l√© et l'incapacit√© de placer un objet dans la ROM en raison de l'initialisation dynamique. <br><br>  Mais il a un merveilleux plus: vous contr√¥lez le temps d'initialisation de l'objet.  Seul le d√©veloppeur lui-m√™me appelle <code>GetInstance()</code> premi√®re fois au moment o√π il en a besoin. <br><br>  Pour se d√©barrasser des trois premi√®res lacunes, il suffit d'utiliser <br><br><div class="spoiler">  <b class="spoiler_title">Singleton sans initialisation retard√©e</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br>  Ici, bien s√ªr, il y a un autre probl√®me, nous ne pouvons pas contr√¥ler le temps d'initialisation de l'objet <code>instance</code> , et nous devons en quelque sorte fournir une initialisation tr√®s transparente.  Mais c'est un probl√®me distinct, nous ne nous attarderons pas l√†-dessus maintenant. <br><br>  Ce singleton peut √™tre repens√© de sorte que l'initialisation de l'objet soit compl√®tement statique au moment de la compilation et qu'une instance de <code>T</code> cr√©√©e dans la ROM en utilisant <code>static constexpr T instance</code> au lieu de <code>static T instance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br>  Ici, la cr√©ation et l'initialisation de l'objet seront effectu√©es par le compilateur au stade de la compilation et l'objet tombera dans le segment .readonly.  Certes, la classe elle-m√™me doit satisfaire aux r√®gles suivantes: <br><blockquote><ul><li>  L'initialisation d'un objet de cette classe doit √™tre statique.  (Le constructeur doit √™tre constexpr) </li><li>  La classe doit avoir un constructeur de copie constexpr </li><li>  Les m√©thodes de classe d'un objet de classe ne doivent pas modifier les donn√©es d'un objet de classe (toutes les m√©thodes const) </li></ul></blockquote><br>  Par exemple, cette option est tout √† fait possible: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br>  G√©nial, vous pouvez utiliser Singleton pour cr√©er des objets en ROM, mais que faire si certains objets doivent √™tre en RAM?  √âvidemment, vous devez en quelque sorte conserver deux sp√©cialisations pour Singleton, une pour les objets RAM, l'autre pour les objets en ROM.  Vous pouvez le faire en entrant, par exemple, pour tous les objets qui doivent √™tre plac√©s dans la classe de base ROM: <br><br><div class="spoiler">  <b class="spoiler_title">Sp√©cialisation pour Singleton cr√©ant des objets en ROM et RAM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br>  Dans ce cas, vous pouvez les utiliser comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br>  Comment pouvez-vous utiliser un tel Singleton dans la vraie vie. <br><br><h3>  Exemple de singleton </h3><br>  Je vais essayer de le montrer sur l'exemple de la minuterie et de la LED.  La t√¢che est simple, faire clignoter la LED sur la minuterie.  La minuterie peut √™tre r√©gl√©e. <br><br>  Le principe de fonctionnement sera le suivant, lorsque l'interruption est appel√©e, la m√©thode <code>OnInterrupt()</code> du temporisateur sera appel√©e, qui √† son tour appellera la m√©thode de commutation LED via l'interface d'abonn√©. <br><br>  √âvidemment, l'objet LED doit √™tre en ROM, car il ne sert √† rien de le cr√©er en RAM, il n'y a m√™me pas de donn√©es dedans.  En principe, je l'ai d√©j√† d√©crit ci-dessus, il suffit donc d'y ajouter l'h√©ritage de <code>RomObject</code> , de cr√©er un constructeur constexpr et d'h√©riter √©galement de l'interface pour le traitement des √©v√©nements du temporisateur. <br><br><div class="spoiler">  <b class="spoiler_title">Objet LED</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br>  Mais je cr√©erai le temporisateur sp√©cifiquement dans la RAM avec une petite lettre de voiture, je stockerai un lien vers la structure <code>TIM_TypeDef</code> , un point et le lien d'un abonn√©, et je configurerai le temporisateur dans le constructeur (bien qu'il soit possible de faire passer √©galement le temporisateur vers la ROM): <br><br><div class="spoiler">  <b class="spoiler_title">Minuterie de classe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br>  Dans cet exemple, un objet de classe <code>BlinkTimer</code> √©tait situ√© dans la RAM et un objet de classe <code>Led1</code> √©tait situ√© dans la ROM.  Aucun objet global suppl√©mentaire dans le code.  √Ä l'endroit o√π l'instance de classe est n√©cessaire, nous appelons simplement <code>GetInstance()</code> pour cette classe <br><br>  Il reste √† ajouter un gestionnaire d'interruption √† la table des vecteurs d'interruption.  Et ici, il est tr√®s pratique d'utiliser Singleton.  Dans la m√©thode statique de la classe responsable de la gestion des interruptions, vous pouvez appeler la m√©thode de l'objet encapsul√© dans Singleton. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Un peu sur la table elle-m√™me, comment tout cela fonctionne:</b> <div class="spoiler_text">  Imm√©diatement apr√®s la mise sous tension ou apr√®s une r√©initialisation, une r√©initialisation est interrompue avec le <i>nombre -8</i> , dans le tableau, il s'agit d'un √©l√©ment z√©ro, selon le signal de r√©initialisation, le programme passe au vecteur d'√©l√©ment z√©ro, o√π le pointeur vers le haut de la pile est initialis√© en premier.  Cette adresse provient de l'emplacement du segment STACK que vous avez configur√© dans les param√®tres de l'√©diteur de liens.  Imm√©diatement apr√®s l'initialisation du pointeur, acc√©dez au point d'entr√©e du programme, dans ce cas, √† l'adresse de la fonction <code>__iar_program_start</code> .  Ensuite, le code est initialis√© en initialisant vos variables globales et statiques, en initialisant le coprocesseur avec une virgule flottante, s'il √©tait inclus dans les param√®tres, etc.  Si une interruption se produit, le contr√¥leur d'interruption par le num√©ro d'interruption dans le tableau va √† l'adresse du gestionnaire d'interruption.  Dans notre cas, il s'agit d' <code>InterruptHandler::Timer2Handler</code> , qui, via Singleton, appelle la m√©thode <code>OnInterrupt()</code> de notre temporisateur de clignotement, qui, √† son tour, <code>OnTimeOut()</code> m√©thode <code>OnTimeOut()</code> la jambe de port. <br></div></div><br>  En fait, c'est tout, vous pouvez ex√©cuter le programme.  Un exemple de travail pour IAR 8.40 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">se trouve ici</a> . <br>  Un exemple plus d√©taill√© de l'utilisation de Singleton pour des objets en ROM et RAM peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouv√© ici</a> . <br><br>  Liens de documentation: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GOST R mek61508-7-02</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide de d√©veloppement C / C ++ pour EWARM</a> </li></ul><br>  PS Dans l'image du d√©but de l'article, tout de m√™me, Singleton n'est pas ROM, mais WHISKY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455477/">https://habr.com/ru/post/fr455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455467/index.html">Si vous n'√©crivez pas de programme, n'utilisez pas de langage de programmation</a></li>
<li><a href="../fr455469/index.html">√ätre une pile compl√®te et ne pas √™tre</a></li>
<li><a href="../fr455471/index.html">Traduction de l'utilisation de Google Analytics avec R (Michal Brys)</a></li>
<li><a href="../fr455473/index.html">G√©n√©riques dans TypeScript: se r√©unir</a></li>
<li><a href="../fr455475/index.html">Food Design Digest, mai 2019</a></li>
<li><a href="../fr455479/index.html">Comment nous avons impl√©ment√© la navigation de Jetpack dans une application de combat. Rapport Yandex.Food</a></li>
<li><a href="../fr455481/index.html">Trois histoires de chasse sauvage</a></li>
<li><a href="../fr455483/index.html">Artiste Ai-Da: un robot humano√Øde se pr√©pare pour sa premi√®re exposition personnelle</a></li>
<li><a href="../fr455485/index.html">Check Point Scripts - ex√©cutez des scripts directement √† partir de la Smart Console</a></li>
<li><a href="../fr455487/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 10. Changer les modes de fonctionnement du port</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>