<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔇 👍🏿 👰🏾 差距赢了。 从JetBrains翻译Kotlin编码约定文档 💱 🎐 🕡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我提请您注意JetBrains提供的Kotlin编码约定文档页面的翻译。 


 → 原始文件 


 内容： 


- 使用Intellij Idea上的样式指南 
- 项目结构 资料夹结构 源文件名 组织源文件 类结构 接口实施框架 覆盖结构 
- 资料夹结构 
- 源文件名 
- 组...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>差距赢了。 从JetBrains翻译Kotlin编码约定文档</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431990/"><p> 哈Ha！ 我提请您注意JetBrains提供的Kotlin编码约定文档页面的翻译。 </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文件</a> </p><a name="habracut"></a><br><p> 内容： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Intellij Idea上的样式指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目结构</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">资料夹结构</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源文件名</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组织源文件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类结构</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接口实施框架</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖结构</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命名规则</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能名称</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试方法名称</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">属性命名</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命名隐藏属性</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择正确的名字</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式化</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">水平空间</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">冒号</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类声明格式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修饰符</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式注释</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件注释</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能格式化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单行表达式格式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">属性格式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式化控制指令</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式化方法调用</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式化链函数调用</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格式化Lambda表达式</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文书工作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">避免不必要的构造</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用关键字单位</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分号</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字符串模式</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">惯用语言功能</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不变性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">默认参数值</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建别名[类型别名]</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda表达式中的参数命名</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Lambda表达式返回值</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带参数命名的调用方法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有条件的控制结构规则</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>if</code> vs <code>when</code></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用布尔值？</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在条件陈述中</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用循环</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">范围周期</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字符串格式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能与属性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用扩展功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用中缀函数</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工厂特色</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平台类型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>  apply</code> / <code>with</code> / <code>run</code> / <code>also</code> / <code>let</code> <code>  apply</code></a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建库的规则</a> </li></ul><br><p>  <strong>使用Intellij Idea上的样式指南</strong> </p><br><p> 要按照当前手册在Intellij Idea中应用格式设置，您需要安装Kotlin插件版本1.2.20或更高版本，请转至“设置” |“设置”。 编辑器 代码样式|  Kotlin，单击右上角的“从...设置”链接，然后从下拉菜单中选择“预定义样式” / Kotlin样式指南。 </p><br><p> 要验证您的代码是否按照建议的样式进行了格式化，请转到检查设置并启用“ Kotlin |样式问题|文件未根据项目设置进行格式化”检查。 默认情况下会启用其他验证规则，例如命名约定。 </p><br><h1 id="struktura-proekta"> 项目结构 </h1><br><h2 id="struktura-papok"> 资料夹结构 </h2><br><p> 在使用不同语言的项目中，带有Kotlin代码的文件必须与其他语言的代码位于同一文件夹中，并使用主要语言接受的相同文件结构。 例如，对于Java，文件必须根据包名称位于文件夹结构中。 </p><br><p> 在仅使用Kotlin的项目中，建议的文件夹结构为：使用文件夹来组织软件包，而跳过根目录，即 如果项目中的所有代码都在软件包“ org.example.kotlin”及其软件包中，则属于软件包“ org.example.kotlin”的源文件应位于项目的根目录中，而带有软件包“ org”的源文件应位于项目的根目录中。 example.kotlin.foo.bar“应该位于子目录” foo / bar“中，相对于项目的根目录。 </p><br><h2 id="naimenovanie-faylov-s-ishodnym-kodom"> 源文件名 </h2><br><p> 如果Kotlin文件仅包含一个类（可能与顶级声明相关），则应命名该文件以及扩展名为<code>.kt</code>的类。 如果文件包含多个类或仅具有顶级声明，请选择一个描述文件包含内容的名称并相应地命名该文件。 使用驼峰驼峰和大写首字母命名文件（例如<code>ProcessDeclarations.kt</code> ）。 </p><br><p> 文件名应描述文件中代码的作用。 也就是说，您应避免使用诸如“ Util”之类的毫无意义的单词来命名文件。 </p><br><h2 id="organizaciya-faylov-s-ishodnym-kodom"> 组织源文件 </h2><br><p> 如果这些声明在语义上紧密相关并且文件大小保持合理（不超过几百行），则欢迎在同一Kotlin源文件中放置多个声明（类，函数或顶级属性）。 </p><br><p> 特别是，在为适用于应用该类各个方面的类定义扩展功能时，请将它们放在定义了类本身的同一文件中。 当定义仅对使用此类的特定上下文有意义的扩展功能时，请将其放置在使用扩展功能的代码旁边。 不要创建仅用于存储“所有Foo扩展名”的文件。 </p><br><h2 id="struktura-klassa"> 类结构 </h2><br><p> 通常，类的内容按以下顺序排序： </p><br><ul><li> 属性声明和初始化程序块 </li><li> 二级建设者 </li><li> 方法声明 </li><li> 伴侣对象 </li></ul><br><p> 不要按字母或视觉顺序对方法声明进行排序，也不要将普通方法与扩展方法分开。 而是将逻辑连接的代码放在一起，以便从上到下阅读该类的人可以遵循发生的逻辑。 选择一个排序顺序（首先是高层代码，然后是“细节”，反之亦然），然后坚持下去。 </p><br><p> 将嵌套的类放在使用这些类的代码旁边。 如果类是供外部使用的，并且未在类内引用，则将它们放在伴随对象的末尾。 </p><br><h2 id="struktura-realizacii-interfeysov"> 接口实施框架 </h2><br><p> 在实现接口时，请保持与要实现的接口相同的结构（如有必要，将其与用于实现的其他专用方法交替使用） </p><br><h2 id="struktura-pereopredeleniy"> 覆盖结构 </h2><br><p> 重新定义总是一个接一个地放在一起。 </p><br><h1 id="pravila-naimenovaniya"> 命名规则 </h1><br><p>  Kotlin遵循与Java相同的命名约定。 特别是： </p><br><p> 小写的程序包名称，不要使用下划线（org.example.myproject）。 通常不建议使用多个单词中的名称，但是如果您需要使用多个单词，则可以将它们简单地组合在一起，也可以使用驼峰（org.examle.myProject）。 </p><br><p> 大写和对象名称以大写字母开头，并使用驼峰驼峰： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeclarationProcessor</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EmptyDeclarationProcessor : DeclarationProcessor() { ... }</code> </pre> <br><h2 id="naimenovanie-funkciy"> 功能名称 </h2><br><p> 函数，属性和局部变量的名称以小写字母开头，并且不包含下划线： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDeclarations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declarationCount = ...</code> </pre> <br><p> 例外：用于实例化类的工厂函数可能与正在创建的类具有相同的名称： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo { ... } fun Foo</span></span></span></span>(): Foo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FooImpl(...) }</code> </pre> <br><h2 id="naimenovanie-testovyh-metodov"> 测试方法名称 </h2><br><p> 在测试中（并且仅在测试中），允许使用方法名称，并在名称之间使用逗号分隔。  （请注意，Android运行时当前不支持此类方法名称。）测试代码中还允许在方法名称中使用下划线。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `ensure everything works`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensureEverythingWorks_onAndroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><h2 id="imenovanie-svoystv"> 属性命名 </h2><br><p> 常量名称（标有<code>const</code>属性，顶级属性或没有包含不可变数据的自定义<code>get</code>函数的<code>val</code>对象）必须大写，并用下划线分隔： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> MAX_COUNT = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> USER_NAME_FIELD = <span class="hljs-string"><span class="hljs-string">"UserName"</span></span></code> </pre> <br><p> 包含具有行为或可变数据的对象的顶级名称或对象属性应在驼峰中使用通用名称： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mutableCollection: MutableSet&lt;String&gt; = HashSet()</code> </pre> <br><p> 引用Singleton对象的属性名称可以使用与类声明相同的命名方式： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PersonComparator: Comparator&lt;Person&gt; = ...</code> </pre> <br><p> 对于枚举，您可以使用以大写字母写的名称，并以下划线或驼峰驼峰式开头，视使用情况而定，以大写字母开头。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ RED, GREEN }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ RedColor, GreenColor }</code> </pre> <br><blockquote><blockquote> 译者注：只是不要混合使用不同的样式。 选择一种样式并在您的设计中坚持使用。 </blockquote><br></blockquote><br><h3 id="imenovanie-skrytyh-svoystv"> 命名隐藏属性 </h3><br><p> 如果一个类具有两个在概念上相同的属性，但一个属性是公共API的一部分，另一个属性是实现的一部分，请使用下划线作为隐藏属性名称的前缀： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> _elementList = mutableListOf&lt;Element&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> elementList: List&lt;Element&gt; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = _elementList }</code> </pre> <br><h2 id="vybor-pravilnyh-naimenovaniy"> 选择正确的名字 </h2><br><p> 类名称通常是解释类是什么的名词或短语： </p><br><pre> <code class="plaintext hljs">List, PersonReader</code> </pre> <br><p> 该方法的名称通常是动词或短​​语操作，用于说明该方法的作用： </p><br><pre> <code class="plaintext hljs">close, readPersons</code> </pre> <br><p> 该名称还应指示该方法是更改​​对象还是返回新对象。 例如， <code>sort</code>是一种更改集合的排序， <code>sorted</code>是该集合的新排序副本的返回。 </p><br><p> 名称应该清楚地表明实体的用途，因此最好避免在名称中使用无意义的词（ <code>Manager</code> ， <code>Wrapper</code>等）。 </p><br><p> 在广告名称中使用首字母缩写词时，如果首字母缩写词由两个字母（ <code>IOStream</code> ）组成，请使用大写字母；否则，请使用大写字母。 如果首字母较长，则仅首字母大写（ <code>XmlFormatter</code> ， <code>HttpInputStream</code> ）。 </p><br><h1 id="formatirovanie"> 格式化 </h1><br><p> 在大多数情况下，Kotlin遵循Java格式约定。 </p><br><p> 使用4个空格缩进。 不要使用标签。 </p><br><p> 对于撑杆，将开口撑杆放置在结构开始的线的末端，将闭合撑杆放置在与开口结构水平对齐的单独线上。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elements != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> elements) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><blockquote><blockquote>  （注意：在Kotlin中，分号是可选的，因此换行很重要。语言设计涉及Java样式的花括号，如果尝试使用其他格式样式，则可能会遇到意外的代码执行行为。） </blockquote><br></blockquote><br><h2 id="gorizontalnye-probely"> 水平空间 </h2><br><p> 在二进制运算符<code>(a + b)</code>周围放置空格。 例外：请勿在“范围至”运算符<code>(0..i)</code>周围放置空格 </p><br><p> 不要在一元运算符<code>(a++)</code>周围放置空格 </p><br><p> 在关键控制词（ <code>if</code> ， <code>when</code> ， <code>for</code>和<code>while</code> ）和相应的方括号之间放置空格。 </p><br><p> 在构造函数，方法或方法的主声明中，请勿在左括号之前放置空格。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foo(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p> 切勿在<code>(</code> ， <code>[</code>或之前<code>]</code> ， <code>)</code>后面放置空格。 </p><br><p> 切勿在点周围放置空间<code>.</code> 还是运算符<code>?.</code>  ： </p><br><pre> <code class="kotlin hljs">foo.bar().filter { it &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> }.joinToString() foo?.()</code> </pre> <br><p> 在双斜杠后加一个空格<code>//</code> ： </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p> 请勿在用于指示类型参数的尖括号周围放置空格： </p><br><pre> <code class="kotlin hljs">Class Map&lt;K, V&gt; { ... }</code> </pre> <br><p> 不要在双冒号周围放置空格以指示对<code>::</code>类方法的引用： </p><br><pre> <code class="kotlin hljs">Foo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:length</span></span></span></span></code> </pre> <br><p> 不要在前面放一个空格<code>?</code> 用于标记<code>null</code> ： </p><br><pre> <code class="kotlin hljs">String?</code> </pre> <br><p> 通常，避免使用任何类型的水平对齐方式。 将标识符重命名为其他长度的名称不应影响代码的格式。 </p><br><h2 id="dvoetochie"> 冒号 </h2><br><p> 在冒号前面放置一个空格<code>:</code>在以下情况下： </p><br><ul><li> 用于将类型与超级类型分开时； </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T : Any</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><ul><li> 当委托给超类构造函数或同一个类的另一个构造函数时； </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(x) { ... } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(x) { ... }</code> </pre> <br><ul><li> 在关键字对象之后。 </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : IFoo { ... }</code> </pre> <br><p> 在<code>:</code>分隔广告及其类型时，请不要在之前放置空格。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T</code> </pre> <br><p> 始终在<code>:</code>之后放置一个空格<code>:</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T : Any</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IFoo { abstract fun foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(x) { ... } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : IFoo { ... } }</code> </pre> <br><h2 id="formatirovanie-obyavleniya-klassov"> 类声明格式 </h2><br><p> 具有几个基本构造函数参数和短名称的类可以写在一行上： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String)</code> </pre> <br><p> 具有较长名称或参数数量的类必须进行格式化，以使构造函数的每个主要参数都位于带有缩进的单独行中。 另外，右括号必须在新行上。 如果我们使用继承，则对超类的构造函数的调用或已实现接口的列表应与括号位于同一行： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String, surname: String ) : Human(id, name) { ... }</code> </pre> <br><p> 在指定接口并调用超类的构造函数时，必须首先找到超类的构造函数，然后在新行上将接口名称左对齐： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String, surname: String ) : Human(id, name), KotlinMaker { ... }</code> </pre> <br><p> 对于具有一长串超级类型的类，您需要在冒号后放置一个换行符，并将所有超级类型名称水平对齐到左侧： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFavouriteVeryLongClassHolder</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyLongHolder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFavouriteVeryLongClass</span></span></span><span class="hljs-class">&gt;</span></span>(), SomeOtherInterface, AndAnotherOne { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><p> 要在班级标题较长时清楚地将班级标题及其主体分开，请在班级标题后放置一个空行（如上例所示），或将开括号放在单独的行上： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFavouriteVeryLongClassHolder</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyLongHolder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFavouriteVeryLongClass</span></span></span><span class="hljs-class">&gt;</span></span>(), SomeOtherInterface, AndAnotherOne { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><p> 构造函数参数使用常规缩进（4个空格）。 </p><br><blockquote><blockquote> 基本原理：这可以确保在主构造函数中声明的属性具有与在类主体中声明的属性相同的缩进。 </blockquote><br></blockquote><br><h2 id="modifikatory"> 修饰符 </h2><br><p> 如果广告包含多个修饰符，请始终按以下顺序排列它们： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vararg</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span></code> </pre> <br><p> 将所有注释放在修饰符之前： </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Named(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Foo"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo: Foo</code> </pre> <br><p> 如果您不在使用库，请省略多余的修饰符（例如public）。 </p><br><h2 id="formatirovanie-annotaciy"> 格式注释 </h2><br><p> 批注通常放在附加声明的声明之前的不同行上，并具有相同的缩进： </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.PROPERTY)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonExclude</span></span></span></span></code> </pre> <br><p> 不带参数的注释可以位于一行： </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JsonExclude</span></span> <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: String</code> </pre> <br><p> 一个没有参数的注释可以和相应的声明放在同一行： </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... }</code> </pre> <br><h2 id="faylovye-annotacii"> 文件注释 </h2><br><p> 文件注释放置在文件注释（如果有）之后，在package语句之前，并以空行与软件包分开（以强调它们是针对文件而不是软件包的事实）。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** License, copyright and whatever */</span></span> <span class="hljs-meta"><span class="hljs-meta">@file:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"FooBar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> foo.bar</code> </pre> <br><h2 id="formatirovanie-funkciy"> 功能格式化 </h2><br><p> 如果方法签名不适合一行，请使用以下语法： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">longMethodName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( argument: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ArgumentType</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = defaultValue, argument2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnotherArgumentType</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: ReturnType { <span class="hljs-comment"><span class="hljs-comment">// body }</span></span></code> </pre> <br><p> 对函数参数使用常规缩进（4个空格）。 </p><br><blockquote><blockquote> 理由：与构造函数参数一致 </blockquote><br></blockquote><p> 对于由一行组成的函数，最好使用不带大括号的表达式。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-comment"><span class="hljs-comment">// bad return 1 } fun foo() = 1 // good</span></span></code> </pre> <br><h2 id="formatirovanie-odnostrochnogo-vyrazheniya"> 单行表达式格式 </h2><br><p> 如果单行函数的主体与声明不在同一行，请将=符号放在第一行。 将表达式的主体缩进4个空格。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = x.length</code> </pre> <br><h2 id="formatirovanie-svoystviya"> 属性格式 </h2><br><p> 对于简单的只读属性，最好使用单行格式： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isEmpty: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = size == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p> 对于更复杂的属性，请始终在单独的行上使用<code>get</code>和<code>set</code> ： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo: String <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { ... }</code> </pre> <br><p> 对于具有初始化的属性，如果初始化程序太长，请在等号后添加一个换行符，并为初始化字符串添加四个空格的缩进： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)</code> </pre><br><h2 id="formatirovanie-upravlyayuschiy-instrukciy"> 格式化控制指令 </h2><br><p> 如果<code>if</code>或<code>when</code>控制语句中的条件为多行，请始终在语句主体周围使用花括号。 相对于语句的开头，条件的每一行都缩进4个空格。 将条件的右括号和左花括号放在单独的一行上： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!component.isSyncing &amp;&amp; !hasAnyKotlinRuntimeInScope(module) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createKotlinNotConfiguredPanel(module) }</code> </pre> <br><blockquote><blockquote> 理由：条件主体与条件主体的整齐对齐和清晰分离 </blockquote><br></blockquote><p> 将<code>else</code> ， <code>catch</code> ， <code>finally</code>关键字以及do / while循环的<code>while</code>关键字与上一个结束大括号放在同一行： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { <span class="hljs-comment"><span class="hljs-comment">// body } else { // else part } try { // body } finally { // cleanup }</span></span></code> </pre> <br><p> 如果指令的<code>when</code>条件由几个块组成，建议使用空行将它们彼此分开： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsePropertyValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(propName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Token</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (token) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Token.ValueToken -&gt; callback.visitValue(propName, token.value) Token.LBRACE -&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } } }</span></span></code> </pre> <br><p> 将简短的<code>when</code>语句块放在没有花括号的同一行上。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (foo) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; bar() <span class="hljs-comment"><span class="hljs-comment">// good false -&gt; { baz() } // bad }</span></span></code> </pre> <br><h2 id="formatirovanie-vyzovov-metodov"> 格式化方法调用 </h2><br><p> 当使用一长串参数时，请将换行符放在括号后面。 缩进4个空格并将逻辑上相关的参数分组在一行上。 </p><br><pre> <code class="kotlin hljs">drawSquare( x = <span class="hljs-number"><span class="hljs-number">10</span></span>, y = <span class="hljs-number"><span class="hljs-number">10</span></span>, width = <span class="hljs-number"><span class="hljs-number">100</span></span>, height = <span class="hljs-number"><span class="hljs-number">100</span></span>, fill = <span class="hljs-literal"><span class="hljs-literal">true</span></span> )</code> </pre> <br><p> 在参数名称及其值之间的等号周围使用空格。 </p><br><h2 id="formatirovanie-cepochnogo-vyzova-funkciy"> 格式化链函数调用 </h2><br><p> 使用链接的呼叫时，请放入<code>.</code> 还是<code>?.</code> 换行符，在四个空格中有一个缩进： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anchor = owner ?.firstChild!! .siblings(forward = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .dropWhile { it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PsiComment || it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PsiWhiteSpace }</code> </pre> <br><p> 链中的第一个调用通常应该在其前面有一个换行符，但是如果代码可读性更好并且很有意义，通常不这样做。 </p><br><h2 id="formatirovanie-lyambda-vyrazheniy"> 格式化Lambda表达式 </h2><br><p> 在lambda表达式中，应在花括号和将参数与主体分开的箭头周围使用空格。 如果呼叫接受单个Lambda字符，则应尽可能在括号外使用它。 </p><br><pre> <code class="kotlin hljs">list.filter { it &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> }</code> </pre> <br><p> 将标签分配给lambda表达式时，请勿在标签和左括号之间留空格： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ints.forEach <span class="hljs-symbol"><span class="hljs-symbol">lit@</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p> 在多行lambda表达式中声明参数名称时，请将名称放在第一行，然后是箭头，然后在新行中将函数主体的开头： </p><br><pre> <code class="kotlin hljs">appendCommaSeparated(properties) { prop -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> propertyValue = prop.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(obj) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 如果参数列表不在一行上，请将箭头放在另一行上： </p><br><pre> <code class="kotlin hljs">foo { context: Context, environment: Env -&gt; context.configureEnv(environment) }</code> </pre> <br><h1 id="oformlenie-dokumentacii"> 文书工作 </h1><br><p> 使用多行文档时，将<code>/**</code>放在单独的行上，然后在每行之后加星号： </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This is a documentation comment * on multiple lines. */</span></span></code> </pre> <br><p> 简短的文档可以放在一行上： </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** This is a short documentation comment. */</span></span></code> </pre> <br><p> 通常，避免使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">param</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">return</a>标签。 相反，应在文档注释中直接包含参数说明和返回值，并在提及参数的地方添加参数引用。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">param</a>并仅在需要较长的描述而不符合正文含义时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">返回</a> 。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int) = ... // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int) = ...</span></span></code> </pre> <br><h1 id="izbeganie-nenuzhnyh-konstrukciy"> 避免不必要的构造 </h1><br><p>  Kotlin中的许多语法构造都是可选的，并且在开发环境中突出显示为不必要的；您不应在代码中使用它们，只是使代码“清晰”。 </p><br><h3 id="ispolzvanie-klyuchevogo-slova-unit"> 使用关键字单位 </h3><br><p> 在函数中，不应使用Unit关键字： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ": Unit" is omitted here }</span></span></code> </pre> <br><h3 id="tochka-s-zapyatoy"> 分号 </h3><br><p> 避免在任何机会都使用分号。 </p><br><h3 id="strokovye-shablony"> 字符串模式 </h3><br><p> 将简单变量插入模板字符串时，请勿使用花括号。 花括号仅用于长表达式。 </p><br><pre> <code class="kotlin hljs">println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> has </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${children.size}</span></span></span><span class="hljs-string"> children"</span></span>)</code> </pre> <br><h1 id="idiomaticheskoe-ispolzovanie-yazykovyh-osobennostey"> 惯用语言功能 </h1><br><h2 id="neizmenyaemost"> 不变性 </h2><br><p> 最好在可变数据之前使用不可变数据。 始终将局部变量和属性声明为<code>val</code> ，而不是<code>var</code> ，除非它们确实发生了变化。 </p><br><p> 始终使用不可变的集合接口（ <code>Collection</code> ， <code>List</code> ， <code>Set</code> ， <code>Map</code> ）声明不变的集合。 每次利用工厂方法创建集合时，请使用返回不可变集合的实现： </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Bad: use of mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... } // Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type val allowedValues = arrayListOf("a", "b", "c") // Good: listOf() returns List&lt;T&gt; val allowedValues = listOf("a", "b", "c")</span></span></code> </pre> <br><blockquote><blockquote>  :         . </blockquote><br></blockquote><br><h2 id="znachenie-parametrov-po-umolchaniyu">     </h2><br><p>             . </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Bad fun foo() = foo("a") fun foo(a: String) { ... } // Good fun foo(a: String = "a") { ... }</span></span></code> </pre> <br><h2 id="sozdanie-psevdonimov-type-alias">   [Type alias] </h2><br><p>           ,      ,     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> MouseClickHandler = (Any, MouseEvent) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> PersonIndex = Map&lt;String, Person&gt;</code> </pre> <br><h2 id="imenovanie-parametrov-v-lyambda-vyrazheniyah">    - </h2><br><p>  -,      ,    <code>it</code>     .   -       . </p><br><h2 id="vozvraschenie-znacheniy-iz-lyambda-vyrazheniy">    - </h2><br><p>        .    -  ,      .      ,    -   . </p><br><p>    ( <code>@</code> )     . </p><br><h2 id="vyzov-metodov-s-imenovaniem-argumentov">      </h2><br><p>    ,           ,     <code>boolean</code> ,         . </p><br><pre> <code class="kotlin hljs">drawSquare(x = <span class="hljs-number"><span class="hljs-number">10</span></span>, y = <span class="hljs-number"><span class="hljs-number">10</span></span>, width = <span class="hljs-number"><span class="hljs-number">100</span></span>, height = <span class="hljs-number"><span class="hljs-number">100</span></span>, fill = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><h2 id="pravila-dlya-upravlyayuschih-konstrukciy-s-usloviyami">       </h2><br><p>     <code>try</code> , <code>if</code>  <code>when</code> ,       <code>return</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) foo() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bar() <span class="hljs-comment"><span class="hljs-comment">//   ,    if (x) return foo() else return bar() // return when(x) { 0 -&gt; "zero" else -&gt; "nonzero" } //   ,    when(x) { 0 -&gt; return "zero" else -&gt; return "nonzero" }</span></span></code> </pre> <br><h2 id="if-protiv-when"> <code>if</code>  <code>when</code> </h2><br><p>   <code>if</code>       <code>when</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> -&gt; ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>      ,   <code>when</code> . </p><br><h2 id="ispolzovanie-znacheniy-boolean-v-uslovnyh-operatorah">   Boolean?    </h2><br><p>    <code>Boolean?</code>    ,       <code>if (value == true)</code>  <code>if (value == false)</code> ,    <code>if (value ?: false)</code>  <code>if (value != null &amp;&amp; value)</code> . </p><br><h2 id="ispolzovanie-ciklov">   </h2><br><p>       <code>filtet</code> , <code>map</code>  ..  . : <code>forEach</code> (    <code>for</code>     null  <code>forEach</code>     ) </p><br><p>     ,    ,         ,        . </p><br><h2 id="cikly-dlya-diapazonov">    </h2><br><p>  <code>until</code>     ( ): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n - <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-comment"><span class="hljs-comment">// bad for (i in 0 until n) { ... } // good</span></span></code> </pre> <br><h2 id="formatirovanie-strok">   </h2><br><p>       . </p><br><p>   <code>\n</code> escape-        . </p><br><p>      ,  <code>trimIndent</code> ,       ,  <code>trimMargin</code> ,    : </p><br><pre> <code class="kotlin hljs">assertEquals( <span class="hljs-string"><span class="hljs-string">""" Foo Bar """</span></span>.trimIndent(), value ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-string"><span class="hljs-string">"""if(a &gt; 1) { | return a |}"""</span></span>.trimMargin()</code> </pre> <br><h2 id="funkcii-protiv-svoystv">    </h2><br><p>              .    ,      ,    . </p><br><p>      : </p><br><ul><li>    </li><li>   (    ) </li><li>       ,      </li></ul><br><h2 id="ispolzovanie-funkciy-rasshireniy">    </h2><br><p>      .  ,     ,     ,      ,      .    API,     ,   .      ,           . </p><br><h2 id="ispolzovanie-infiksnyh-funkciy">    </h2><br><p>    <code>infix</code> ,       ,   .  : <code>and</code> , <code>to</code> , <code>zip</code> .  : <code>add</code> . </p><br><p>     <code>infix</code> ,     . </p><br><h2 id="funkcii-fabriki">   </h2><br><p>      ,       ,    .    ,   ,      .      ,     ,   . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromPolar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Point(...) } }</code> </pre> <br><p>       ,                   ,      . </p><br><h2 id="platformennye-tipy">   </h2><br><blockquote><blockquote>  :  ,       ,    Kotlin     <code>null</code> ,    <code>null</code> </blockquote><br></blockquote><p> <code>public</code> /,    ,     Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)</code> </pre> <br><p>   (package-level  class-level)          Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) }</code> </pre> <br><p>  ,    ,      Kotlin : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) println(name) }</code> </pre> <br><h2 id="ispolzovanie-funkciy-applywithrunalsolet">   <code>apply</code> / <code>with</code> / <code>run</code> / <code>also</code> / <code>let</code> </h2><br><p> Kotlin           .    ,  : </p><br><ul><li>               ?   ,    ,          <code>it</code> ,    <code>this</code> ( <code>also</code>  <code>let</code> ).  <code>also</code> ,       . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Context object is 'it' class Baz { var currentBar: Bar? val observable: Observable val foo = createBar().also { currentBar = it // Accessing property of Baz observable.registerCallback(it) // Passing context object as argument } } // Receiver not used in the block val foo = createBar().also { LOG.info("Bar created") } // Context object is 'this' class Baz { val foo: Bar = createBar().apply { color = RED // Accessing only properties of Bar text = "Foo" } }</span></span></code> </pre> <br><ul><li>     ?      ,  <code>apply</code>  <code>also</code> .       ,  <code>with</code> , <code>let</code>  <code>run</code> . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Return value is context object class Baz { val foo: Bar = createBar().apply { color = RED // Accessing only properties of Bar text = "Foo" } } // Return value is block result class Baz { val foo: Bar = createNetworkConnection().let { loadBar() } }</span></span></code> </pre> <br><ul><li>     null      ?   ,  <code>apply</code> , <code>let</code>  <code>run</code> .   ,  <code>with</code>  <code>also</code> . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Context object is nullable person.email?.let { sendEmail(it) } // Context object is non-null and accessible directly with(person) { println("First name: $firstName, last name: $lastName") }</span></span></code> </pre> <br><h1 id="pravila-pri-sozdanii-bibliotek">     </h1><br><p>            API: </p><br><ul><li>      (        API) </li><li>           (         ) </li><li>   KDoc   public api,   ,         / </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431990/">https://habr.com/ru/post/zh-CN431990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431978/index.html">网上商店促销：必须解决的问题</a></li>
<li><a href="../zh-CN431982/index.html">数据中的Digerati，Hakerazzi和胆固醇：关于IT Slang</a></li>
<li><a href="../zh-CN431984/index.html">基于Golang数据库的客户端生成器接口</a></li>
<li><a href="../zh-CN431986/index.html">Fuck Up的故事：我对业务的数字服务感到失望并拥有自己的业务（嗯，差不多）</a></li>
<li><a href="../zh-CN431988/index.html">当定理成为一个公理时：ONYX BOOX Euclid评估</a></li>
<li><a href="../zh-CN431992/index.html">生物识别：我们与他们之间的情况如何</a></li>
<li><a href="../zh-CN431994/index.html">讨论托管在GitHub上的项目的免费PVS-Studio许可证</a></li>
<li><a href="../zh-CN431996/index.html">Smart Engines Science Corporate（或我们如何驾车前往ICMV 2018）</a></li>
<li><a href="../zh-CN431998/index.html">认识Yandex.Phone-现在正式</a></li>
<li><a href="../zh-CN432002/index.html">Microsoft正在开发基于Chromium的浏览器，默认情况下将代替Edge发行</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>