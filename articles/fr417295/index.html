<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù£Ô∏è ‚ôìÔ∏è ü¶ñ Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 3 ‚û∞ üë®üèæ‚ÄçüöÄ üö∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©sum√© des parties pr√©c√©dentes 
 En raison de restrictions sur la capacit√© √† utiliser les compilateurs C ++ 11 et du manque d'alternativit√©, boost a v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417295/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Nous continuons l'aventure." width="300" height="350" align="left"><h3>  R√©sum√© des parties pr√©c√©dentes </h3><br>  En raison de restrictions sur la capacit√© √† utiliser les compilateurs C ++ 11 et du manque d'alternativit√©, boost a voulu √©crire sa propre impl√©mentation de la biblioth√®que C ++ 11 standard en plus de la biblioth√®que C ++ 98 / C ++ 03 fournie avec le compilateur. <br><br>  <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> ont √©t√© impl√©ment√©s et, apr√®s avoir pris en compte toutes les d√©finitions non standard et les fonctionnalit√©s du compilateur, des informations sont apparues sur la fonctionnalit√© prise en charge par le compilateur actuel.  Ceci termine la description de <b>core.h</b> , mais il ne serait pas complet sans <b>nullptr</b> . <br><br>  Lien vers GitHub avec le r√©sultat d'aujourd'hui pour les impatients et les non-lecteurs: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les engagements et les critiques constructives sont les bienvenus</a></b> </blockquote><br>  Alors continuons. <br><a name="habracut"></a><br><h4>  Table des mati√®res </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 1. Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <b>Chapitre 3. Recherche de l'impl√©mentation nullptr parfaite</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 4. Magie des mod√®les C ++</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1 On commence petit</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2 √Ä propos du nombre d'erreurs miraculeuses que le journal compile pour nous</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3 Pointeurs et tout-tout</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4 Quoi d'autre est n√©cessaire pour la biblioth√®que de mod√®les</a> <br>  Chapitre 5 <br>  ... <br><br><h3>  Chapitre 3. Recherche de l'impl√©mentation nullptr parfaite </h3><br>  Apr√®s toute l'√©pop√©e avec des macros de compilateur non standard et les ¬´merveilleuses¬ª d√©couvertes qu'elles ont pr√©sent√©es, j'ai finalement pu ajouter <b>nullptr</b> et cela a en quelque sorte r√©chauff√© mon √¢me.  Enfin, vous pouvez vous d√©barrasser de toutes ces comparaisons avec 0 ou m√™me <b>NULL</b> . <br><br><img src="https://habrastorage.org/webt/t_/jt/wb/t_jtwbjyvuah5tw2ehe-gvy0fxe.jpeg" alt="image" width="300" height="200" align="left">  La plupart des programmeurs impl√©mentent <b>nullptr</b> comme <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0</span></span></code> </pre> <br>  et cela aurait pu terminer ce chapitre.  Si vous voulez vous-m√™me <b>nullptr</b> , remplacez simplement 0 par une telle d√©finition, car c'est essentiellement tout ce qui est n√©cessaire pour un fonctionnement correct. <br><br>  N'oubliez pas de vraiment faire un ch√®que, sinon tout √† coup quelqu'un d'autre se retrouvera avec cette d√©finition: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> nullptr #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nullptr defined already"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  La directive de pr√©processeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#error produira une</a> erreur avec du texte lisible par l'homme lors de la compilation, et, oui, il s'agit d'une directive standard, dont l'utilisation est rare, mais peut √™tre trouv√©e. <br><br>  Mais dans une telle impl√©mentation, nous manquons l'un des points importants d√©crits dans la norme, √† savoir <i>std :: nullptr_t</i> - un type s√©par√©, dont une instance constante est <b>nullptr</b> .  Et les d√©veloppeurs de chrome ont √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">essay√© de</a> r√©soudre ce probl√®me (il existe maintenant un compilateur plus r√©cent et un <b>nullptr</b> normal) le d√©finissant comme une classe qui peut √™tre convertie en pointeur vers n'importe quel type.  √âtant donn√© que, selon la norme, la taille de <b>nullptr</b> doit √™tre √©gale √† la taille du pointeur vers <b>void</b> (et <b>void *</b> doit √©galement contenir n'importe quel pointeur, √† l'exception des pointeurs vers un membre de la classe), nous ¬´normalisons¬ª cette impl√©mentation en ajoutant un pointeur null inutilis√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl() { } nullptr_t_as_class_impl(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } // Make nullptr convertible to any member pointer type. template&lt;typename C, typename T&gt; operator TC::*() { return 0; } bool operator==(nullptr_t_as_class_impl) const { return true; } bool operator!=(nullptr_t_as_class_impl) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  La conversion de cette classe en n'importe quel pointeur est due √† l'op√©rateur de mod√®le du type, qui est appel√© si quelque chose est compar√© √† <b>nullptr</b> .  Autrement dit, l'expression <i>char * my_pointer;</i>  <i>if (my_pointer == nullptr)</i> sera r√©ellement converti en <i>if (my_pointer == nullptr.operator char * ())</i> , qui compare le pointeur √† 0. L'op√©rateur de second type est n√©cessaire pour convertir <b>nullptr</b> en pointeurs en membres de classe.  Et ici, Borland C ++ Builder 6.0 s'est ¬´distingu√©¬ª, qui a d√©cid√© de mani√®re inattendue que ces deux op√©rateurs sont identiques et peuvent facilement comparer des pointeurs vers un membre de la classe et des pointeurs r√©guliers, il y a donc une incertitude √† chaque fois qu'un tel <b>nullptr est</b> compar√© √† pointeur (c'est un bug, et ce n'est peut-√™tre pas seulement avec ce compilateur).  Nous √©crivons une impl√©mentation distincte pour ce cas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl1() { } nullptr_t_as_class_impl1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } bool operator==(nullptr_t_as_class_impl1) const { return true; } bool operator!=(nullptr_t_as_class_impl1) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl1 nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  Les avantages de cette vue <b>nullptr</b> sont qu'il existe d√©sormais un type distinct pour <i>std :: nullptr_t</i> .  Inconv√©nients?  La constante <b>nullptr</b> est <b>perdue</b> lors de la compilation et de la comparaison via l'op√©rateur ternaire, le compilateur ne peut pas la r√©soudre. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>* case5 = argc &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     ':'    STATIC_ASSERT(nullptr == nullptr &amp;&amp; !(nullptr != nullptr), nullptr_should_be_equal_itself); //  , nullptr     </span></span></code> </pre><br>  Et je veux "et les dames et c'est parti."  La solution ne vient √† l'esprit que d'une seule: l' <b>√©num√©ration</b> .  Les membres de l'√©num√©ration en C ++ auront leur propre type s√©par√© et seront √©galement convertis en <b>int</b> sans aucun probl√®me (et en fait ce sont des constantes enti√®res).  Cette propri√©t√© d'un membre d'√©num√©ration nous sera utile, car le 0 tr√®s ¬´sp√©cial¬ª qui est utilis√© √† la place de <b>nullptr</b> pour les pointeurs est l' <b>int</b> . Le plus courant.  Je n'ai pas vu une telle impl√©mentation de <b>nullptr</b> sur Internet, et c'est peut-√™tre aussi quelque chose de mauvais, mais je n'avais aucune id√©e pourquoi.  √âcrivons une impl√©mentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> namespace ptrdiff_detail { using namespace std; } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; struct nullptr_t_as_ulong_type { typedef unsigned long type; }; template&lt;&gt; struct nullptr_t_as_ulong_type&lt;false&gt; { typedef unsigned long type; }; template&lt;bool&gt; struct nullptr_t_as_ushort_type { typedef unsigned short type; }; template&lt;&gt; struct nullptr_t_as_ushort_type&lt;false&gt; { typedef nullptr_t_as_long_type&lt;sizeof(unsigned long) == sizeof(void*)&gt;::type type; }; template&lt;bool&gt; struct nullptr_t_as_uint_type { typedef unsigned int type; }; template&lt;&gt; struct nullptr_t_as_uint_type&lt;false&gt; { typedef nullptr_t_as_short_type&lt;sizeof(unsigned short) == sizeof(void*)&gt;::type type; }; typedef nullptr_t_as_uint_type&lt;sizeof(unsigned int) == sizeof(void*)&gt;::type nullptr_t_as_uint; enum nullptr_t_as_enum { _nullptr_val = ptrdiff_detail::ptrdiff_t(STDEX_NULL), _max_nullptr = nullptr_t_as_uint(1) &lt;&lt; (CHAR_BIT * sizeof(void*) - 1) }; typedef nullptr_t_as_enum nullptr_t; #define nullptr nullptr_t(STDEX_NULL)</span></span></span></span></code> </pre><br>  Comme vous pouvez le voir ici, un peu plus de code que de simplement d√©clarer <b>enum</b> <i>nullptr_t</i> avec le membre <i>nullptr = 0</i> .  Premi√®rement, il peut ne pas y avoir de d√©finitions <b>NULL</b> .  Il doit √™tre d√©fini dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste assez solide d'en-t√™tes standard</a> , mais comme la pratique l'a montr√©, il est pr√©f√©rable de le jouer en toute s√©curit√© et de v√©rifier cette macro.  Deuxi√®mement, la repr√©sentation de l' <b>√©num√©ration</b> en C ++ selon la norme d√©finie par l'impl√©mentation, c'est-√†-dire  le type d'√©num√©ration peut √™tre repr√©sent√© par n'importe quel type d'entier (√† condition que ces types ne puissent pas √™tre sup√©rieurs √† <b>int</b> , √† condition que les valeurs d' <b>√©num√©ration y correspondent</b> ).  Par exemple, si vous d√©clarez <i>enum test {_1, _2}, le</i> compilateur peut facilement le repr√©senter comme <b>court,</b> et alors il est fort possible que <b>sizeof (</b> <i>test</i> <b>)</b> <i>! =</i> <b>Sizeof (void *)</b> .  Pour que l'impl√©mentation <b>nullptr soit conforme</b> √† la norme, vous devez vous assurer que la taille du type que le compilateur choisit pour <i>nullptr_t_as_enum</i> correspond √† la taille du pointeur, c'est-√†-dire  essentiellement de <b>taille</b> √©gale <b>(vide *)</b> .  Pour ce faire, √† l'aide des mod√®les <i>nullptr_t_as ...</i> , s√©lectionnez un type entier qui sera √©gal √† la taille du pointeur, puis d√©finissez la valeur maximale de l'√©l√©ment dans notre √©num√©ration sur la valeur maximale de ce type entier. <br><blockquote>  Je veux faire attention √† la macro <b>CHAR_BIT</b> d√©finie dans l'en-t√™te des <b>climats</b> standard.  Cette macro est d√©finie sur le nombre de bits dans un caract√®re, c'est-√†-dire  le nombre de bits par octet sur la plateforme actuelle.  Une d√©finition <u>standard</u> utile que les d√©veloppeurs contournent sans raison en collant des huit partout, bien qu'√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains endroits dans un octet il n'y ait pas du tout 8 bits</a> . </blockquote><br>  Et une autre caract√©ristique est l'affectation de <b>NULL</b> comme valeur de l'√©l√©ment <b>enum</b> .  Certains compilateurs donnent un avertissement (et leur inqui√©tude peut √™tre comprise) sur le fait que <b>NULL est</b> affect√© au "non-indexeur".  Nous <i>retirons l'</i> <b>espace</b> de <b>noms</b> standard √† notre <i>ptrdiff_detail</i> local, afin de ne pas encombrer le reste de l'espace de noms, puis, pour calmer le compilateur, nous convertissons explicitement <b>NULL</b> en <i>std :: ptrdiff_t</i> - un autre type en quelque sorte sous-utilis√© en C ++, qui sert √† repr√©senter le r√©sultat des op√©rations arithm√©tiques (soustraction) avec des pointeurs et est g√©n√©ralement un alias de type <i>std :: size_t</i> ( <i>std :: intptr_t</i> en C ++ 11). <br><br><h4>  SFINAE </h4><br>  Ici, pour la premi√®re fois dans mon histoire, nous sommes confront√©s √† un tel ph√©nom√®ne en C ++ car l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©chec de substitution n'est pas une erreur (SFINAE)</a> .  En bref, l'essentiel est que lorsque le compilateur ¬´passe par¬ª les surcharges de fonctions appropri√©es pour un appel particulier, il doit les v√©rifier toutes et ne pas s'arr√™ter apr√®s la premi√®re d√©faillance ou apr√®s la premi√®re surcharge appropri√©e.  D'o√π son message sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ambigu√Øt√©</a> , lorsqu'il y a deux surcharges de la fonction appel√©e qui sont identiques du point de vue du compilateur, ainsi que la capacit√© du compilateur √† s√©lectionner la surcharge de fonction la plus pr√©cise pour un appel sp√©cifique avec des param√®tres sp√©cifiques.  Cette fonctionnalit√© du compilateur vous permet de faire la part du lion de tout le mod√®le ¬´magique¬ª (en passant hi <i>std :: enable_if</i> ), et c'est √©galement la base de boost et de ma biblioth√®que. <br><br>  Puisque, par cons√©quent, nous avons plusieurs impl√©mentations <b>nullptr,</b> nous utilisons SFINAE ¬´select¬ª le meilleur au stade de la compilation.  Nous d√©clarons les types ¬´oui¬ª et ¬´non¬ª pour v√©rifier la <b>taille</b> des fonctions de sonde d√©clar√©es ci-dessous. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> nullptr_detail { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _yes_type; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> padding[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_class</span></span></span><span class="hljs-class"> {</span></span>}; _yes_type _is_convertable_to_void_ptr_tester(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); _no_type _is_convertable_to_void_ptr_tester(...); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f_const)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; _yes_type _is_convertable_to_member_function_ptr_tester(dummy_class_f); _no_type _is_convertable_to_member_function_ptr_tester(...); _yes_type _is_convertable_to_const_member_function_ptr_tester(dummy_class_f_const); _no_type _is_convertable_to_const_member_function_ptr_tester(...); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yes_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">*);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(...);</span></span> }</code> </pre><br><blockquote>  Ici, nous utiliserons le m√™me principe que dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me chapitre</a> avec <b>countof</b> et sa d√©finition √† travers <b>sizeof de la</b> valeur de retour (tableau d'√©l√©ments) de la fonction mod√®le <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> . </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_void_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_void_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); };</code> </pre><br>  Que se passe-t-il ici?  Tout d'abord, le compilateur ¬´ <i>it√®re</i> ¬ª les surcharges de la fonction <i>_is_convertable_to_void_ptr_tester</i> avec un argument de type <i>T</i> et une valeur de <b>NULL</b> (la valeur ne joue pas de r√¥le, seul <b>NULL</b> doit √™tre de type- <i>T</i> ).  Il n'y a que deux surcharges - avec le type <b>void *</b> et avec la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste d'arguments variables (...)</a> .  En substituant un argument √† chacune de ces surcharges, le compilateur s√©lectionnera le premier si le type est converti en un pointeur vers <b>void</b> , et le second si le transtypage ne peut pas √™tre effectu√©.  Avec la surcharge s√©lectionn√©e par le compilateur, nous utilisons <b>sizeof pour</b> d√©terminer la taille de la valeur retourn√©e par la fonction, et comme elles sont garanties diff√©rentes ( <b>sizeof (</b> <i>_no_type</i> <b>)</b> <i>== 8</i> , <b>sizeof (</b> <i>_yes_type</i> <b>)</b> <i>== 1</i> ), nous pouvons d√©terminer la taille de la surcharge que le compilateur a d√©tect√©e et donc convertie que notre type soit <b>nul *</b> ou non. <br><br>  Nous appliquerons davantage le m√™me mod√®le de programmation afin de d√©terminer si un objet du type de notre choix pour repr√©senter <i>nullptr_t</i> est <i>converti</i> en n'importe quel pointeur (essentiellement <i>(T) (</i> <b>STDEX_NULL</b> <i>)</i> est la future d√©finition de <b>nullptr</b> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_member_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)) &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_const_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullPtrType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_ptr_tester&lt;T&gt;((NullPtrType) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, nullptr_detail::dummy_class&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = ( _is_convertable_to_void_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_any_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_member_function_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ); };</code> </pre><br>  Bien s√ªr, il n'est pas possible d'it√©rer sur tous les pointeurs imaginables et inconcevables et leurs combinaisons avec <b>des modificateurs volatils</b> et <b>const</b> , donc je me suis limit√© √† seulement ces 9 v√©rifications (deux sur les pointeurs vers les fonctions de classe, une sur le pointeur vers <b>void</b> , sept sur les pointeurs vers diff√©rents types), ce qui est assez suffisant. <br><br>  Comme mentionn√© ci-dessus, certains compilateurs (* khe-khe * ... Borland Builder 6.0 ... * khe *) ne distinguent pas les pointeurs vers un type et un membre d'une classe, nous allons donc √©crire une autre v√©rification d'aide pour ce cas afin que nous puissions ensuite s√©lectionner l'impl√©mentation souhait√©e de <i>nullptr_t</i> via la classe si besoin. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member_ptr_is_same_as_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test::*member_ptr_type)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_void_ptr_impl&lt;member_ptr_type&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl1 type; };</code> </pre><br>  Et puis il ne reste plus qu'√† v√©rifier les diff√©rentes impl√©mentations de <i>nullptr_t</i> et choisir le compilateur appropri√© pour le compilateur. <br><br><div class="spoiler">  <b class="spoiler_title">Choix de l'impl√©mentation nullptr_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_void type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int nullptr_t_as_int; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_int&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_int&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_choose_as_int&lt;as_int::_is_convertable_to_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; as_int::_equal_void_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum nullptr_t_as_enum; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _can_be_ct_constant = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;<span class="hljs-comment"><span class="hljs-comment">//_nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_enum&gt;::value; }; typedef _nullptr_choose_as_enum&lt;as_enum::_is_convertable_to_ptr == bool(true) &amp;&amp; as_enum::_equal_void_ptr == bool(true) &amp;&amp; as_enum::_can_be_ct_constant == bool(true)&gt;::type type; }; struct _nullptr_chooser { struct as_class { typedef _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type nullptr_t_as_class; static const bool _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_class&gt;::value; static const bool _can_be_ct_constant = _nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_class&gt;::value; }; typedef _nullptr_choose_as_class&lt;as_class::_equal_void_ptr == bool(true) &amp;&amp; as_class::_can_be_ct_constant == bool(true)&gt;::type type; };</span></span></code> </pre><br></div></div><br>  Tout d'abord, nous v√©rifions la possibilit√© de repr√©senter <i>nullptr_t</i> comme une classe, mais comme je n'ai pas trouv√© de compilateur universel d'une solution <i>ind√©pendante</i> , je n'ai pas trouv√© d'objet type pouvant √™tre une constante de temps de compilation (soit dit en passant, je suis ouvert aux suggestions √† ce sujet, car il est probable que cela soit possible), cette option est toujours <i>coch√©e</i> ( <i>_can_be_ct_constant est</i> toujours <b>false</b> ).  Ensuite, nous passons √† la v√©rification de la variante avec la vue √† travers l' <b>√©num√©ration</b> .  S'il n'√©tait toujours pas possible de pr√©senter (le compilateur ne peut pas pr√©senter un pointeur via <b>enum</b> ou la taille est en quelque sorte incorrecte), alors nous essayons de le repr√©senter comme un type entier (dont la taille sera √©gale √† la taille du pointeur √† <b>annuler</b> ).  Eh bien, m√™me si cela n'a pas fonctionn√©, nous s√©lectionnons une impl√©mentation du type <i>nullptr_t</i> via <b>void *</b> . <br><br>  √Ä ce stade, la majeure partie de la puissance de SFINAE en combinaison avec les mod√®les C ++ est r√©v√©l√©e, gr√¢ce √† laquelle il est possible de choisir l'impl√©mentation n√©cessaire sans recourir √† des macros d√©pendantes du compilateur, et en fait √† des macros (contrairement √† boost o√π tout cela serait <b>bourr√©</b> de <b>contr√¥les #ifdef #else # endif</b> ). <br><br>  Il ne reste plus qu'√† d√©finir un alias de type pour <i>nullptr_t</i> dans l' <b>espace de noms stdex</b> et un d√©finir pour <b>nullptr</b> (afin de se conformer √† une autre exigence standard que l'adresse <b>nullptr</b> ne peut pas √™tre prise, ainsi que d'utiliser <b>nullptr</b> comme constante de temps de compilation). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> detail::_nullptr_chooser::type <span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr (stdex::nullptr_t)(STDEX_NULL)</span></span></code> </pre><br>  La fin du troisi√®me chapitre.  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatri√®me chapitre,</a> j'arrive enfin √† type_traits et aux autres bugs des compilateurs que j'ai rencontr√©s lors du d√©veloppement. <br><br>  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417295/">https://habr.com/ru/post/fr417295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417283/index.html">Disney a pr√©sent√© son propre syst√®me d'animation capillaire HairControl</a></li>
<li><a href="../fr417285/index.html">O√π ins√©rer un guillemet dans IPv6</a></li>
<li><a href="../fr417287/index.html">"Calendrier des testeurs" pour juillet. Tests analytiques</a></li>
<li><a href="../fr417289/index.html">Journal du stagiaire: Jour 1. Stagiaire √† junior</a></li>
<li><a href="../fr417293/index.html">R√©cup√©ration de mot de passe et stockage principal dans le cloud, ou Nouveaut√©s de Zimbra 8.8.9</a></li>
<li><a href="../fr417297/index.html">Fear and Loathing Threat Intelligence or 8 TI Practical Tips</a></li>
<li><a href="../fr417299/index.html">En ligne, hors ligne et P2P: comment acheter du bitcoin en Russie</a></li>
<li><a href="../fr417301/index.html">Recette de lib√©ration en douceur: PMy Note</a></li>
<li><a href="../fr417303/index.html">Hack pour prendre en charge les boutons du casque Windows Android</a></li>
<li><a href="../fr417305/index.html">Ultima Online: un look backstage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>