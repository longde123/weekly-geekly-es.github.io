<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÑ üëì üßëüèø‚Äçü§ù‚ÄçüßëüèΩ Perangkat kompiler Swift. Bagian 2 üóÇÔ∏è üìô üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian kedua dari kisah kompiler Swift saya. Kami akan mulai mempelajari front-end, atau lebih tepatnya, bagian-bagiannya yang bertanggung jawab untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perangkat kompiler Swift. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/438664/"><img src="https://habrastorage.org/webt/gb/ll/lc/gblllcop33qw16mals99ykfevfm.png"><br><p>  Bagian kedua dari kisah kompiler Swift saya.  Kami akan mulai mempelajari front-end, atau lebih tepatnya, bagian-bagiannya yang bertanggung jawab untuk analisis awal dan analisis kode sumber. <a name="habracut"></a></p><br><p>  Bagian pertama artikel dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><cut></cut><br><h1 id="frontend">  Frontend </h1><br><img src="https://habrastorage.org/webt/ol/fm/lq/olfmlqa1vogrofwbxiikyqogyr0.png" width="500" align="left"><br><p><br clear="all"></p><br><p>  Tugas frontend adalah untuk menghasilkan representasi perantara dari kode sumber dan mentransfernya ke LLVM.  Proses ini dapat dibagi menjadi 8 langkah.  Hasil dari hampir masing-masing dapat ditampilkan dengan mengirimkan parameter khusus ke kompiler. </p><br><p>  Di bawah ini saya akan menunjukkan implementasi kompiler untuk "bahasa pemrograman" primitif yang hanya berisi "ruang lingkup" dan angka.  Satu-satunya fungsi adalah untuk menampilkan nomor (jika ada) ke konsol.  Misalnya, sebagai hasil dari eksekusi "kode" ini, angka 678 akan ditampilkan: </p><br><pre><code class="plaintext hljs">{{{678}}}</code> </pre> <br><p>  Kompiler ini hanya diperlukan untuk memudahkan Anda memahami apa yang terjadi pada tahapan yang berbeda.  Implementasi bahasa nyata, tetapi sederhana dapat dilihat pada contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kaledoscope</a> . </p><br><p>  Setiap ruang lingkup terdiri dari braket pembuka, konten, dan braket penutup.  Ini dapat ditulis seperti ini: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace open_brace ::= "{" close_brace ::= "}"</code> </pre> <br><p>  Konten mungkin memiliki cakupan, jumlah yang sama, atau tidak ada yang ditunjukkan di sini <strong>:</strong> <strong><br></strong> <br></p><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace x ::= scope | number | &lt;empty&gt; open_brace ::= "{" close_brace ::= "}"</code> </pre> <br><p>  Simbol |  berarti "atau."  Angka terdiri dari satu atau lebih digit: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace x ::= scope | number | &lt;empty&gt; open_brace ::= "{" close_brace ::= "}" number ::= digit | number digit digit :: = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code> </pre> <br><p>  Catatan semacam itu disebut bentuk Backus-Naur (BNF), dan totalitas semua aturan disebut tata bahasa atau sintaksis. </p><br><p>  Ada juga BPF yang ditingkatkan (RBNF).  Karakter khusus tambahan ditambahkan ke dalamnya, misalnya, tanda kurung untuk pengelompokan. </p><br><p>  Kurung kurawal menunjukkan pengulangan.  Catatan semacam itu berarti bahwa A kosong atau sama dengan sejumlah B: </p><br><pre> <code class="plaintext hljs">A ::= { B }</code> </pre> <br><p>  Kurung kotak digunakan untuk kejadian bersyarat.  Catatan semacam itu berarti bahwa A kosong atau sama dengan B: </p><br><pre> <code class="plaintext hljs">A ::= [B]</code> </pre> <br><p>  Menggunakan RBNF tata bahasa dari kompiler tanda kurung, Anda dapat mengubahnya menjadi bentuk ini: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace [scope | number] close_brace open_brace ::= "{" close_brace ::= "}" number ::= digit {digit} digit :: = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code> </pre> <br><p>  Selain kompiler tanda kurung, saya akan menunjukkan cara menggunakan kompiler Swift untuk mendapatkan hasil dari setiap langkah menggunakan contoh ekspresi sederhana: </p><br><pre> <code class="plaintext hljs">let x = 16</code> </pre> <br><p>  Kode ini sangat sederhana untuk membuatnya lebih mudah dimengerti.  Tata bahasa bahasa pemrograman yang sebenarnya jauh lebih rumit daripada yang di atas.  Anda dapat melihat sintaks Swift di situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">web</a> resmi. </p><br><h1 id="lexer">  Lexer </h1><br><p>  Dari sudut pandang kompiler, file kode sumber adalah aliran karakter acak, dan mungkin semacam sampah.  Oleh karena itu, langkah pertama adalah konversi karakter acak ini menjadi kata-kata yang dapat digunakan dalam bahasa pemrograman. </p><br><p>  Ini dilakukan oleh penganalisa leksikal (lexer / tokenizer).  Kata-kata yang ia cari disebut token atau token (kami tidak akan masuk ke detail yang tidak perlu dan menerima istilah ini secara sinonim).  Karena itu, proses ini juga disebut tokenization. </p><br><p>  Lexer melakukan analisis sesuai dengan sintaks bahasa.  Memindai simbol demi simbol, ia menemukan korespondensi dari kode sumber dan sisi kanan catatan, dan kemudian menghasilkan token yang sesuai dari sisi kiri. </p><br><h3 id="primer-realizacii-leksera">  Contoh implementasi Lexer </h3><br><p>  Tata bahasa memungkinkan tiga token: braket pembuka, braket penutup, dan angka.  Mereka disajikan sebagai enumerasi.  Serta daftar kemungkinan kesalahan: </p><br><pre> <code class="plaintext hljs">enum Token: CustomStringConvertible { case openBraceToken case closeBraceToken case number(Int) var description: String { switch self { case .openBraceToken: return "openBraceToken" case .closeBraceToken: return "closeBraceToken" case .number(let value): return "\(value)" } } } enum LexerError: Error { case unexpectedCharacted case invalidNumber }</code> </pre> <br><p>  Lexer sendiri menyimpan string input dan indeks karakter saat ini: </p><br><pre> <code class="plaintext hljs">class Lexer { private let string: String private var index: String.Index private var currentCharacter: Character? { return index != string.endIndex ? string[index] : nil } init(string: String) { self.string = string index = string.startIndex }</code> </pre> <br><p>  Analisis dimulai dengan memanggil metode <strong>startAnalyze ()</strong> .  Di dalamnya, sebuah metode disebut dalam satu lingkaran untuk mendapatkan token berikutnya, yang ditambahkan ke array.  Pada akhirnya - intersepsi kesalahan pengakuan: </p><br><pre> <code class="plaintext hljs">func startAnalyzing() -&gt; [Token] { var result: [Token] = [] do { while let token = try getNextToken() { result.append(token) } } catch LexerError.unexpectedCharacted { print("Unexpected character at index \(index.encodedOffset)") result = [] } catch LexerError.invalidNumber { print("Invalid number at index \(index.encodedOffset)") result = [] } catch { print("Unexpected error") result = [] } return result }</code> </pre> <br><p>  Memperoleh token terdiri dari memeriksa karakter saat ini dan memajukan indeks satu atau lebih karakter: </p><br><pre> <code class="plaintext hljs">private func getNextToken() throws -&gt; Token? { guard let character = currentCharacter else { return nil } switch character { case "{": return getOpenBrace() case "}": return getCloseBrace() default: break } if let scalar = character.unicodeScalars.first, CharacterSet.decimalDigits.contains(scalar) { return try getNumber() } throw LexerError.unexpectedCharacted } private func getOpenBrace() -&gt; Token { moveIndex() return Token.openBraceToken } private func getCloseBrace() -&gt; Token { moveIndex() return Token.closeBraceToken }</code> </pre> <br><p>  Jika digit ditemukan, maka metode <strong>getNumber () dipanggil</strong> untuk menguraikannya.  Ini hanya mengumpulkan semua digit menjadi satu baris dan mengubahnya menjadi Int: </p><br><pre> <code class="plaintext hljs">private func getNumber() throws -&gt; Token { var numberString = "" while let character = currentCharacter, let scalar = character.unicodeScalars.first, CharacterSet.decimalDigits.contains(scalar) { numberString.append(character) moveIndex() } guard let number = Int(numberString) else { throw LexerError.invalidNumber } return Token.number(number) }</code> </pre> <br><p>  Untuk memulai lexer, Anda harus memberikannya baris dengan kode sumber dan memanggil metode <strong>startAnalyze ()</strong> : </p><br><pre> <code class="plaintext hljs">let lexer = Lexer(string: "{{5678}}") let tokens = lexer.startAnalyzing()</code> </pre> <br><p>  Hasilnya memenuhi harapan: </p><br><pre> <code class="plaintext hljs">[openBraceToken, openBraceToken, 5678, closeBraceToken, closeBraceToken]</code> </pre> <br><p>  Di Swift, lexer adalah bagian dari parser, dan Anda tidak bisa mendapatkan daftar token yang sesuai dengan kode sumber. </p><br><p>  Kode Sumber: </p><br><ul><li>  <a href="">Lexer.h</a> </li><li>  <a href="">Lexer.cpp</a> </li></ul><br><h1 id="parser">  Parser </h1><br><p>  Parser melakukan parsing.  Urutan token ditransmisikan ke input, dan hasil pekerjaan adalah AST. </p><br><p>  AST adalah grafik di mana simpul adalah operator dan daun adalah operan mereka.  Misalnya, ekspresi 1 + (2 * 3) terdiri dari dua operator: penjumlahan dan perkalian.  Operan tambahan pertama adalah 1, dan yang kedua adalah hasil dari produk 2 dan 3. Kurung pengelompokan tidak digunakan dalam AST, karena tidak diperlukan.  Grafik itu sendiri menentukan operasi bersarang: </p><br><img src="https://habrastorage.org/webt/8f/s8/3f/8fs83fpfn-zhwsuwijgaxwttm2o.png" width="500" align="left"><br><p><br clear="all"></p><br><p>  Setiap node dapat diwakili, misalnya, oleh suatu struktur atau enumerasi yang mengandung elemen anak. </p><br><p>  Selama pembentukan pohon, parser memeriksa tata bahasa: apakah urutan yang benar terdiri dari "kata-kata".  Misalnya, string <strong>"{{}"</strong> akan berhasil diurai oleh lexer, tetapi tidak benar karena braket penutup kedua tidak ada. </p><br><p>  Pengurai Swift adalah pengurai menurun rekursif.  Ini berarti bahwa ia pertama kali menemukan entitas eksternal, dan kemudian secara rekursif menganalisis isinya.  Pengurai naik pertama-tama menemukan entitas yang paling bersarang, dan kemudian naik. </p><br><h3 id="primer-realizacii-parsera">  Contoh implementasi Parser </h3><br><p>  Ada sejumlah besar tipe dan implementasi parser.  Di bawah ini adalah implementasi paling sederhana dari parser descending dan ascending untuk secara jelas menunjukkan perbedaannya. </p><br><p>  Umum untuk kedua parser adalah enumerasi yang mewakili salah satu kesalahan dan simpul AST: </p><br><pre> <code class="plaintext hljs">indirect enum ASTNode: CustomStringConvertible { case brace(childNode: ASTNode?) case number(value: Int) var description: String { switch self { case let .brace(childNode?): return "brace(\(childNode.description))" case .brace(nil): return "brace(nil)" case let .number(value): return "\(value)" } } } enum ParserError: Error { case expectedOpenBrace case expectedCloseBrace case expectedNumber case expectedEndOfArray }</code> </pre> <br><h3 id="nishodyaschiy-parser">  Pengurai menurun </h3><br><p>  Parser ke bawah menyimpan array token dan indeks token saat ini: </p><br><pre> <code class="plaintext hljs">class TopDownParser { private let tokens: [Token] private var index: Int private var currentToken: Token? { return index != tokens.endIndex ? tokens[index] : nil } init(tokens: [Token]) { self.tokens = tokens index = tokens.startIndex }</code> </pre> <br><p>  Satu-satunya metode publik adalah mulai parsing.  Pertama, parsing sepasang kurung disebut.  Karena entitas root hanya bisa berupa kurung (string <strong>"{} {}"</strong> tidak diizinkan), ini sudah cukup.  Analisis lebih lanjut akan dilakukan secara rekursif.  Tetap hanya memverifikasi bahwa array token kosong dan untuk menangkap pengecualian: </p><br><pre> <code class="plaintext hljs">func startParsing() -&gt; ASTNode? { var rootNode: ASTNode? do { rootNode = try parseBraces() guard currentToken == nil else { rootNode = nil throw ParserError.expectedEndOfArray } } catch ParserError.expectedCloseBrace { print("Expected close brace at index \(index)") } catch ParserError.expectedOpenBrace { print("Expected open brace at index \(index)") } catch ParserError.expectedEndOfArray { print("Expected end of tokens array at index \(index)") } catch { print("Unexpected error") } return rootNode }</code> </pre> <br><p>  Saat parsing tanda kurung, braket pembuka dipindai terlebih dahulu, kemudian secara rekursif konten dalam pasangan (jika ada), dan pada akhirnya braket penutup. </p><br><p>  Poin penting: segera setelah parser melihat braket pembuka, ia menganggap bahwa ia telah berhasil menemukan pasangan berikutnya dan Anda dapat melanjutkan ke analisis konten.  Itu sebabnya ia beralih dari entitas eksternal ke entitas internal. </p><br><pre> <code class="plaintext hljs">private func parseBraces() throws -&gt; ASTNode? { try consumeOpenBrace() print("Pair found") let node: ASTNode? if let currentToken = self.currentToken, case .openBraceToken = currentToken { node = .brace(childNode: try parseBraces()) } else if let currentToken = self.currentToken, case let .number(value) = currentToken { node = .brace(childNode: .number(value: value)) try consumeNumber() } else { node = .brace(childNode: nil) } try consumeCloseBrace() return node }</code> </pre> <br><p>  Pemindaian terdiri dari memeriksa token dan memindahkan indeks saat ini: </p><br><pre> <code class="plaintext hljs">private func consumeOpenBrace() throws { if let currentToken = self.currentToken, case .openBraceToken = currentToken { print("Open brace found") moveIndex() } else { throw ParserError.expectedOpenBrace } }</code> </pre> <br><h3 id="voshodyaschiy-parser">  Pengurai naik </h3><br><p>  Mengimplementasikan parser hulu sedikit lebih rumit.  Dia perlu mempertahankan statusnya, setumpuk token, dan tabel konversi antar negara. </p><br><p>  Status disajikan sebagai enumerasi.  Hal ini diperlukan untuk memperhitungkan token sebelumnya dan menanggapi dengan benar penampilan yang baru.  Karena contoh ini sangat sederhana, ternyata pada kondisi pertama, parser mengurai kurung pembuka, dan pada yang kedua - kurung penutup: </p><br><pre> <code class="plaintext hljs">class BottomUpParser { private enum State { case state1 case state2 }</code> </pre> <br><p>  Parser diinisialisasi mirip dengan yang pertama.  Tidak ada tabel transisi sebagai entitas terpisah.  Demi penyederhanaan, switch akan memainkan perannya: </p><br><pre> <code class="plaintext hljs">private let tokens: [Token] private var index: Int private var state: State = .state1 private var stack: [Token] = [] private var rootNode: ASTNode? private var currentToken: Token? { return index != tokens.endIndex ? tokens[index] : nil } init(tokens: [Token]) { self.tokens = tokens index = tokens.startIndex }</code> </pre> <br><p>  Analisis juga diluncurkan menggunakan metode <strong>startParsing ()</strong> .  Di dalamnya, setiap token diproses secara bergantian, dan pada akhirnya, sebuah cek disebut bahwa stack kosong dan penguraian selesai dengan sukses: </p><br><pre> <code class="plaintext hljs">func startParsing() -&gt; ASTNode? { do { guard !tokens.isEmpty else { throw ParserError.expectedOpenBrace } while index != tokens.endIndex { try parseNextToken() moveIndex() } guard stack.isEmpty else { rootNode = nil throw ParserError.expectedCloseBrace } } catch ParserError.expectedCloseBrace { rootNode = nil print("Expected close brace at index \(index)") } catch ParserError.expectedOpenBrace { rootNode = nil print("Expected open brace at index \(index)") } catch ParserError.expectedEndOfArray { rootNode = nil print("Expected end of tokens array at index \(index)") } catch { rootNode = nil print("Unexpected error") } return rootNode }</code> </pre> <br><p>  Token in switch berikutnya diproses dengan mempertimbangkan kondisi saat ini.  Jika braket pembuka tiba dan negara adalah 1, maka ditambahkan ke tumpukan.  Jika ditutup, parser memeriksa untuk melihat apakah ada braket pembuka pada tumpukan untuknya, kemudian memindahkannya dari tumpukan dan beralih ke status 2. Transisi ke keadaan kedua juga dilakukan ketika angka ditemukan. </p><br><p>  Parser terus menghapus satu elemen dari tumpukan untuk setiap braket penutup.  Jika braket atau nomor pembuka datang pada saat ini, ini merupakan kesalahan dalam array input. </p><br><p>  Poin penting: parser ke atas menganggap bahwa mereka menemukan pasangan hanya setelah menurunkan hierarki, ia melihat braket penutup, asalkan yang membuka ada di tumpukan.  Hanya setelah itu ia akan mencari esensi yang mengandungnya, dan seterusnya ke root.  Itulah sebabnya itu disebut naik. </p><br><pre> <code class="plaintext hljs">private func parseNextToken() throws { guard let currentToken = currentToken else { return } switch (state, currentToken) { case (.state1, .openBraceToken): print("Open brace found") stack.append(.openBraceToken) case (.state1, .number(let value)): if stack.isEmpty { throw ParserError.expectedOpenBrace } else { consumeNumber(value: value) state = .state2 } case (.state1, .closeBraceToken): if stack.isEmpty { throw ParserError.expectedOpenBrace } else { consumeCloseBrace() state = .state2 } case (.state2, .closeBraceToken): if stack.isEmpty { throw ParserError.expectedEndOfArray } else { consumeCloseBrace() } case (.state2, .number), (.state2, .openBraceToken): if stack.isEmpty { throw ParserError.expectedEndOfArray } else { throw ParserError.expectedCloseBrace } } } private func consumeCloseBrace() { print("Close brace found") _ = stack.popLast() print("Pair found") if rootNode == nil { rootNode = .brace(childNode: nil) } else { rootNode = .brace(childNode: rootNode) } } private func consumeNumber(value: Int) { rootNode = .number(value: value) }</code> </pre> <br><p>  Untuk memulai kedua parser, Anda perlu mentransfer sejumlah token yang diterima dari lexer dan memanggil metode <strong>startParsing ()</strong> : </p><br><pre> <code class="plaintext hljs">let parserTD = TopDownParser(tokens: tokens) let ast1 = parserTD.startParsing() let parserBU = BottomUpParser(tokens: tokens) let ast2 = parserBU.startParsing()</code> </pre> <br><p>  Hasil untuk kedua parser itu benar: </p><br><pre> <code class="plaintext hljs">brace(brace(5678))</code> </pre> <br><h3 id="ispolzovanie-parsera-swift">  Menggunakan Swift Parser </h3><br><p>  Untuk memulai parser Swift, Anda harus meneruskan <strong>flag -dump-parse</strong> ke kompiler: </p><br><pre> <code class="plaintext hljs">swiftc -dump-parse main.swift</code> </pre> <br><p>  AST nyata memiliki struktur yang lebih kompleks daripada parser tanda kurung.  Tetapi karena kecil, Anda dapat dengan mudah mengetahuinya dan menemukan bilangan bulat 16 dan konstanta <strong>x</strong> : </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_named 'x') (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  Bentuk AST ini adalah pohon yang tidak diketik.  Oleh karena itu, konstanta x tidak memiliki tipe type = '' yang ditentukan.  Jika Anda menentukannya secara eksplisit - misalkan x: Int = 16 pohon akan berubah, tetapi jenisnya tidak akan terdaftar: <br></p><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_typed (pattern_named 'x') (type_ident (component id='Int' bind=none))) (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Header Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File implementasi Parser</a> </li></ul><br><h1 id="sema">  Sema </h1><br><p>  Pohon yang diterima dari parser benar secara tata bahasa, tetapi mungkin masih ada kesalahan di dalamnya.  Misalnya, selama parsing tidak mungkin (tidak murah) untuk menentukan bahwa variabel dideklarasikan sebelum digunakan.  Ini dilakukan oleh penganalisa semantik.  Ini berjalan melalui seluruh pohon dan menetapkan jenis ekspresi, memeriksa dukungan protokol, mensintesis inisialisasi default untuk struktur, dan banyak lagi. </p><br><h3 id="ispolzovanie-semanticheskogo-analizatora-swift">  Menggunakan penganalisis semantik Swift </h3><br><p>  Untuk memulai penganalisis semantik, gunakan <strong>flag -dump-ast</strong> : </p><br><pre> <code class="plaintext hljs">swiftc -dump-ast main.swift</code> </pre> <br><p>  Hasil dari perintah: </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_named type='Int' 'x') (call_expr implicit type='Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] nothrow arg_labels=_builtinIntegerLiteral: (constructor_ref_call_expr implicit type='(_MaxBuiltinIntegerType) -&gt; Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] nothrow (declref_expr implicit type='(Int.Type) -&gt; (_MaxBuiltinIntegerType) -&gt; Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] decl=Swift.(file).Int.init(_builtinIntegerLiteral:) function_ref=single) (type_expr implicit type='Int.Type' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] typerepr='Int')) (tuple_expr implicit type='(_builtinIntegerLiteral: Int2048)' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] names=_builtinIntegerLiteral (integer_literal_expr type='Int2048' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] value=16)))) )) (var_decl "x" type='Int' interface type='Int' access=internal let storage_kind=stored))</code> </pre> <br><p>  Konstanta memiliki tipe <strong>type = 'Int'</strong> , serta tingkat akses.  Inisialisasi konstanta sedikit lebih rumit.  Menambahkan panggilan konstruktor <strong>_builtinIntegerLiteral</strong> .  Jika Anda mewakili pohon ini sebagai kode Swift, Anda mendapatkan: </p><br><pre> <code class="plaintext hljs">internal let x: Int = Int(_builtinIntegerLiteral: 16)</code> </pre> <br><p>  Contoh berikut berisi kesalahan: </p><br><pre> <code class="plaintext hljs">let x: Bool = 16</code> </pre> <br><p>  Jika Anda meneruskannya ke parser, maka itu tidak akan mendeteksi penyimpangan: </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_typed (pattern_named 'x') (type_ident (component id='Bool' bind=none))) (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  Tetapi penganalisis semantik akan menunjukkan apa yang salah dengan kode yang diteruskan ke sana: </p><br><pre> <code class="plaintext hljs">error: cannot convert value of type 'Int' to specified type 'Bool' let x: Bool = 16</code> </pre> <br><p>  Jelas, kesalahan itu mencoba untuk menetapkan nilai tipe Int ke konstanta tipe Bool.  Swift tidak mengizinkan ini.  Terima kasih kepada penganalisa semantik. </p><br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sema</a> </li></ul><br><h1 id="clang-importer">  Importir dentang </h1><br><p>  Pada tahap ini, kita mengimpor modul Dentang dan memetakan API C dan Objective-C ke panggilan yang sesuai dari Swift. </p><br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Importir dentang</a> </li></ul><br><p>  Sekarang kami memiliki kode sumber yang telah diuraikan sepenuhnya yang telah lulus tes awal.  Tetapi sebelum beralih ke generasi IR LLVM, Anda perlu melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimasi khusus Swift.</a> </p><br><p>  Versi lengkap dari kode sumber dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438664/">https://habr.com/ru/post/id438664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438650/index.html">Roket 9M729. Beberapa kata tentang "pelanggar" Perjanjian INF</a></li>
<li><a href="../id438652/index.html">Portabelisasi IDA</a></li>
<li><a href="../id438654/index.html">OpenSceneGraph: Integrasi dengan Qt Framework</a></li>
<li><a href="../id438658/index.html">Cara belajar belajar</a></li>
<li><a href="../id438662/index.html">Hari dimana aku jatuh cinta pada bulu mata</a></li>
<li><a href="../id438666/index.html">Manajer vs Programmer</a></li>
<li><a href="../id438668/index.html">"Cari cerita yang mendorong": podcast tentang podcast, pekerjaan editorial, dan karier media</a></li>
<li><a href="../id438670/index.html">Penyerang menggunakan serangan hak cipta YouTube untuk memeras uang dari penulis</a></li>
<li><a href="../id438672/index.html">Pengkodean UTF-8 dalam nama dan kata sandi Wi-Fi (Emoji)</a></li>
<li><a href="../id438674/index.html">"Rostec" mulai menjual telepon kantor "Cruise-K" seharga 85.000 rubel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>