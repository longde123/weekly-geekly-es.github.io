<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱 👩🏽‍🏫 👩🏿‍🏭 Kisah satu animasi 🚮 💟 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu ketika perancang menelepon ujung depan dan meminta membuat "sarang laba-laba" di balik kaca berkabut. Tapi kemudian ternyata ini bukan "jaring l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kisah satu animasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450832/"> Suatu ketika perancang menelepon ujung depan dan meminta membuat "sarang laba-laba" di balik kaca berkabut.  Tapi kemudian ternyata ini bukan "jaring laba-laba", tapi kisi heksagonal, dan bukan di belakang kaca, tetapi masuk ke kejauhan, dan front-endender tidak mengenal WebGL, dan saya harus mempelajari semua animasi dalam proses menggambar.  Front-end itu adalah <b>Yuri Artyukh</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">akella</a> ). <br><br><img src="https://habrastorage.org/webt/4b/db/la/4bdblauwhfg83othzzcjlfdjzf0.jpeg"><br><br>  Yuri telah terlibat dalam penyusunan huruf untuk waktu yang lama, dan pada hari Minggu merekam aliran dengan analisis proyek nyata.  Dia bukan pro di WebGL, tidak membuat peta di atasnya, tidak menulis di assembler Web, tetapi dia suka belajar sesuatu yang baru.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontendConf</a> RIT ++, Yuri mengatakan bagaimana melakukan satu animasi dari tata letak ke pengiriman ke klien sehingga semua orang senang dan mempelajari WebGL di sepanjang jalan.  Cerita ini berasal dari perspektif orang pertama dan termasuk: Three.js, GLSL, Canvas 2D, grafik dan sedikit matematika. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Eq_rXOyOX0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Jaring laba-laba di balik kaca berkabut </h2><br>  Entah bagaimana saya duduk dan mengerjakan proyek penting.  Kemudian desainer dari studio, yang memiliki efek khusus sangat disukai, menelepon dan bertanya: "Bisakah Anda membuat sarang laba-laba, seolah-olah di balik kaca berkabut?" <br><br>  Ini, tentu saja, segera menggambarkan keseluruhan masalah.  Ternyata kemudian, "sarang laba-laba" di balik kaca berkabut adalah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  Ini adalah kotak heksagonal, tetapi untuk perancang, untuk beberapa alasan, "sarang laba-laba".  Gelas kaca - kotak ini masuk ke kejauhan  Kesulitan komunikasi.  Bayangkan betapa sulitnya menjadi seorang introvert dan membuat animasi?  Tapi saya hanya seperti itu dan ini yang saya lakukan. <br><br>  "Web" ini tidak terlihat seperti animasi, setelah itu Anda dapat menulis laporan tentang kasus yang sukses, membuka startup, mendapatkan investasi miliaran, memiliki banyak penggemar dan meluncurkan roket ke luar angkasa.  Tentang apa semua ini?  Garis coklat pada latar belakang putih-abu-abu, seolah-olah digambar oleh tikus.  Kemudian ternyata dia harus berjalan di sepanjang tepi, tetapi lebih pada nanti.  Secara umum, nama kode adalah "web di balik kaca berkabut." <br><br>  Di situs dengan animasi ini ada beberapa opsi lagi untuk "web laba-laba": pada latar belakang abu-abu di atas, pada putih di bawah.  Itu perlu untuk membuatnya interaktif sehingga merespons pergerakan mouse pengguna. <br><br>  Hal pertama yang ditanyakan oleh perancang kepada saya adalah seberapa sulit dan berapa biayanya.  Beberapa pemikiran melintas di benak saya: cara menggambar garis dan Grid seperti itu, bagaimana membuatnya tidak melambat, bagaimana cara kerjanya sama sekali.  Saya belum pernah mengalami ini sebelumnya.  Tetapi, sebagai orang yang terlibat dalam pengembangan, dia menjawab: " <i>Itu, mudah, kita akan melakukannya ..."</i> <br><br>  Saya suka terlibat dalam petualangan aneh, karena ketika saya melakukan ini, saya biasanya menderita. <br><br><blockquote>  Melalui penderitaan datanglah pertumbuhan.  Ini tidak dapat dihindari terkait dengan penderitaan - Anda tidak bisa bahagia dengan segalanya, hidup bahagia, dan pada saat yang sama berkembang secara profesional. </blockquote><br><h2>  Three.js </h2><br>  Saya segera mulai berpikir bagaimana menyelesaikan masalah.  Karena semuanya dalam 3D, saya ingat <b>Three.js</b> .  Ini adalah perpustakaan paling populer yang dibicarakan di semua konferensi.  Perpustakaan ini membuat WebGL lebih sederhana, lebih nyaman dan lebih menyenangkan daripada hanya WebGL asli. <br><br>  Three.js memiliki banyak objek siap pakai.  <b>PlaneGeometry</b> adalah objek pertama yang tampak sempurna bagi saya.  Ini adalah bidang primitif.  Perpustakaan memiliki segala macam segi enam, dodecahedron, icosahedron, silinder, tetapi ada pesawat sederhana dari banyak segitiga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/d6/zh/1bd6zhhmntwqmvhlzc6fe8pt5u8.jpeg" width="600"></div><br>  <i>Ada banyak segitiga, karena saya membutuhkan ombak yang terperinci - permukaannya harus khawatir.</i> <br><br>  Jika Anda melihat ke dalam Three.js, maka sebenarnya pesawat ini adalah objek JS sederhana dengan daftar semua koordinat titik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/4l/2s/ma4l2so6e_q2_njrkzrjsdibylu.jpeg" width="600"></div><br><br>  Dalam kasus saya, saya memiliki bidang 50x50 kotak, jadi saya membutuhkan 2601 simpul.  Mengapa 50 × 50 = 2601?  Ini matematika sekolah.  Koordinat z = 0, karena bidang, y = 1, karena ini adalah baris pertama dari simpul 50 buah, dan x berubah. <br><br>  Tetapi mengapa saya membutuhkan pesawat, apakah saya perlu menekuknya?  Hal pertama yang dapat Anda lakukan dengan array adalah melakukan operasi matematika di dalamnya.  Misalnya, buka <code>for each</code> loop dan tetapkan koordinat z ke nilai sinus koordinat x. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/4t/vx/rl4tvxjhweazbjcjjakkaxv38nw.jpeg" width="600"></div><br><br>  Ternyata sesuatu yang mirip dengan gelombang sinus, karena nilai tinggi setiap simpul akan sama dengan sinus nilai ini sepanjang sumbu x.  Untuk menyulitkan ini entah bagaimana (sekarang akan menjadi momen matematika yang sulit, bersiap-siaplah) - Saya akan menambahkan waktu ke sinus, dan kanvas ini akan bergerak, hanya karena matematika bekerja seperti ini.  Jika Anda menambahkan waktu ke koordinat x, grafik bergerak secara horizontal.  Jika untuk mengoordinasikan y - akan bergerak secara vertikal.  Saya tertarik dengan gerakan horisontal - saya ingin lautan saya khawatir. <br><br>  Perancang itu tidak berharap saya memiliki sinusoid yang merayap dari kiri ke kanan.  Dia ingin itu indah, seperti sarang laba-laba, samudra, atau apa pun yang ada di kepalanya.  Karena itu, opsi dengan sinusoid tidak cocok.  Butuh semacam keacakan.  Pesawat seharusnya tidak dapat diprediksi sebagai gelombang sinus.  Tetapi jika Anda menyebut secara acak untuk masing-masing puncak ini, maka kami mendapatkan sangat tidak terduga. <br><br>  Inti dari keacakan adalah bahwa itu acak dan independen.  Setiap simpul acak tidak bergantung pada tetangganya dengan cara apa pun.  Secara acak, tidak ada parameter yang dilewatkan, tidak peduli tentang tetangga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xi/_i/-z/xi_i-z1fxtzdkobj8rvyw5zdwum.jpeg" width="600"></div><br><br>  Hasilnya adalah kurva patah yang menyerupai laut atau web hanya dari jarak jauh.  Lebih cocok sebagai ilustrasi untuk film tentang "peretas" dan pencurian cyber. <br><br>  Jika Anda melihat secara acak dari sudut pandang setiap titik di layar, sepertinya suara putih - banyak titik putih dan hitam kecil.  Setiap titik berwarna hitam dan putih - 0 atau 1. <br><br>  Tetapi apa yang saya butuhkan untuk menciptakan lautan ombak seharusnya terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/gf/4r/kogf4rlg2l22xip6a0bnppd2oym.jpeg" width="600"></div><br>  <i>Itu menyerupai kabut, dan awan, dan gunung.</i> <br><br>  Ada fungsi acak yang mengembalikan gambar tersebut.  Mereka disebut suara atau <b>kebisingan</b> : kebisingan Simplex, kebisingan Perlin.  Perlin dalam nama noise adalah nama pencipta algoritma gradient noise, yang mengembalikan acak yang indah.  Dia menciptakannya dengan mengerjakan efek khusus dari bagian pertama film "Tron."  Algoritma matematika ini ada sebelumnya, tetapi sekarang secara aktif digunakan dalam film dan permainan. <br><br>  Ketika peta acak dihasilkan dalam "Heroes of Might and Magic III" (untuk mereka yang berusia di atas 30) atau dalam strategi., Anda biasanya dapat melihat sesuatu yang serupa.  Itu selalu fungsi yang sama yang mengembalikan suara-suara ini. <br><br>  Ada seluruh gerakan "Seni generatif".  Peserta menghasilkan karya seni, lanskap, menggunakan fungsi noise.  Misalnya, pada gambar di bawah ini, lanskap pseudo-natural dari salah satu seniman.  Tidak segera jelas apakah itu matematika atau topografi gunung.  Tugas seni Generatif adalah secara matematis menghasilkan lanskap yang tidak dapat dibedakan dari masa kini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/lw/ky/qelwkyrefwhms3hhd_gbd7azazs.jpeg" width="600"></div><br><br>  Ternyata, tidak seperti keacakan, fungsi ini mengambil parameter, karena titik harus bergantung pada tetangga terdekat.  Jika Anda menggunakan fungsi noise alih-alih keacakan yang biasa, Anda mendapatkan sesuatu seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ce/og/ti/ceogtizjdrzw3kfbrdz6n1cnqra.jpeg" width="600"></div><br>  <i>Hitam dan putih adalah tinggi: 0 adalah lembah hitam, 1 adalah puncak putih.</i>  <i>Ternyata permukaannya bergelombang.</i> <br><br>  Fungsi ini ada di semua PL karena itu hanya sebuah algoritma - sinus, cosinus, perkalian. <br><br>  Saya dapat melakukan distorsi dengan cara yang sama dengan melalui semua simpul dari objek PlaneGeometry saya, menetapkan setiap nilai ke fungsi noise: <br><br><pre> <code class="javascript hljs">geometry.vertices.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { vz = noise(vx, vy, time); });</code> </pre> <br>  Fungsi ini hanya memakan 30-40 baris, tetapi secara matematis rumit. <br><br>  Ada fungsi noise dari semua dimensi: satu dimensi, dua dimensi, tiga dimensi.  Dalam kasus saya, ini adalah noise tiga dimensi, karena tiga parameter dilewatkan ke sana.  Selain koordinat spasial bidang x dan y, saya mentransmisikan waktu - permukaan akan terus berputar, mengubah posisinya. <br><br><h2>  Three.js!  == GPU </h2><br>  Ketika saya memulai algoritme, ombak mulai bergerak.  Ketika saya melakukan sesuatu untuk Web, saya selalu mencari di profiler, dan sekarang saya juga melihat ke dalamnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/os/qg/9rosqgaqfwrqwxnnzmxhhw-1szq.jpeg" width="600"></div><br><br>  Di layar adalah satu bingkai yang ditarik oleh browser.  Bingkai ditunjukkan oleh garis putus-putus vertikal abu-abu.  Di dalam bingkai, 2/3 dari waktu ditempati oleh pelaksanaan fungsi kebisingan.  Saat Anda menghidupkan sesuatu di Web, Anda menggunakan bingkai animasi permintaan, yang berjalan setiap 16 ms, paling banter.  Frame setiap 16 ms menghitung fungsi noise untuk 2600 simpul.  Untuk setiap simpul, gerakan naik dan turun dipertimbangkan.  Pada setiap kerangka berikutnya, nilai-nilai dihitung ulang, karena permukaan harus hidup tepat waktu. <br><br>  Ternyata fungsi noise, yang berubah 2600 kali, sudah mengambil 2/3 dari frame di komputer saya.  Dan ini bukan keseluruhan kerangka.  Saat mengembangkan animasi, ini sudah merupakan bendera merah. <br><br><blockquote>  Tidak boleh ada animasi yang menempati lebih dari setengah bingkai. </blockquote><br>  Jika lebih, maka ada risiko tinggi kehilangan bingkai selama interaksi apa pun, tombol apa saja, mouseover apa pun. <br><br>  Karena itu, itu adalah bendera merah yang sulit.  Saya menyadari bahwa Three.js belum tentu WebGL.  Terlepas dari kenyataan bahwa saya tampaknya menggunakan Three.js, saya menggambar semuanya dalam 3D, itu diberikan di WebGL, saya tidak mendapatkan kinerja yang fantastis dari WebGL.  Saya hanya memiliki 2.600 simpul - ini tidak cukup untuk WebGL.  Misalnya, pada setiap peta ada ribuan objek, masing-masing terdiri dari puluhan segitiga.  Perkirakan skalanya: ratusan ribu adalah normal, tetapi hanya ada 2600 puncak. <br><br><h2>  Vertex Shader </h2><br>  Setelah masalah dengan bingkai, saya menemukan bahwa ada shader.  Hanya ada dua jenis: <br><br><ul><li>  Vertex Shader; <br></li><li>  Shader fragmen. <br></li></ul><br>  Saya tertarik pada vertex shader - Vertex Shader.  Jika kami menulis ulang animasi di atasnya, maka tampilannya akan seperti ini: <br><br><pre> <code class="javascript hljs">position.z = noise( vec3(position.x, position.y, time) );</code> </pre> <br>  <code>Position.z</code> - komponen z koordinat setiap titik dengan tipe datanya sendiri.  <code>vec3</code> menunjukkan bahwa akan ada tiga parameter. <br><br><blockquote>  Tidak ada lingkaran di shader. </blockquote><br>  Sebelum itu, dalam skrip, saya meletakkan <code>for each</code> loop, dan untuk setiap vertex, perhitungan berlangsung dalam satu loop.  Perbedaan antara shader dan non-shader adalah tidak adanya siklus. <br><br><blockquote>  Shader - inilah siklusnya. </blockquote><br>  Ini dijalankan secara paralel untuk semua simpul sekaligus.  Inilah makna, misi, chip, dan misi utamanya. <br><br>  GPU pada kartu video memiliki inti yang lebih besar, tidak seperti CPU prosesor utama.  Pada prosesor ada jauh lebih sedikit, tetapi mampu melakukan perhitungan universal lebih cepat.  Perhitungan yang sangat sederhana tersedia pada kartu video, tetapi ada banyak inti, sehingga memungkinkan Anda untuk memaralelkan banyak perhitungan.  Inilah yang biasanya terjadi pada shader.  Arti dari vertex shader adalah kebisingan akan dihitung secara paralel untuk 2600 simpul dalam shader pada kartu video. <br><br>  Jika Anda melihat profiler, tampilan animasi tidak akan berubah, tetapi akan terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/xv/et/k7xvetot_x1xphmbrtsfkifz8mc.jpeg" width="600"></div><br><br>  <b>Tidak ada yang dijalankan pada CPU sama sekali</b> .  Tentu saja, utas lain pada GPU ditambahkan di bawah ini.  Ada juga utas pada GPU, CPU, Web-pekerja, tetapi perhitungan ini akan dilakukan di utas terpisah pada kartu video. <br><br>  Tentu saja ini tidak gratis.  Kartu video di tempat kerja dipanaskan lebih dari prosesor utama.  Karenanya, sering kali ketika Anda mengunjungi situs dengan animasi yang serupa, penggemar mulai bekerja untuk Anda.  Ini karena ketika kartu video dihidupkan, itu membutuhkan pendinginan, tidak seperti sisa waktu.  Pada perangkat seluler, ini lebih penting daripada pada komputer desktop - ponsel hanya berjalan lebih cepat.  Tetapi pada saat yang sama Anda mendapatkan peningkatan kinerja, cukup radikal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/x-/zr/hhx-zrjk_c8ftrd4hjdqhohcn1a.jpeg" width="600"></div><br>  <i>Hasilnya adalah permukaan seperti itu - ini adalah perlin-noise biasa.</i>  <i>Jika Anda memulainya dan hanya mengubah waktu, gelombang dingin diperoleh.</i> <br><br>  Tapi itu belum semuanya.  Saya masih diminta untuk "jaring laba-laba" - sebuah kisi heksagonal di permukaan.  Memiliki pengalaman dalam tata letak, cara paling sederhana dan paling jelas adalah memilih fragmen yang dapat diulang.  Menariknya, untuk kotak heksagonal, tidak persegi, tetapi persegi panjang.  Jika Anda mengulangi polanya sebagai persegi panjang, Anda mendapatkan kisi.  Pustaka Three.js memungkinkan Anda untuk menampilkan png dan tidak mempelajari semua WebGL sebelumnya.  Saya memotong png dan meletakkannya di permukaan, ternyata sesuatu seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8n/gc/p0/8ngcp0pi_2s1st4ubwo8sgh8zps.jpeg" width="600"></div><br><br>  Sekilas, apa yang Anda butuhkan!  Tapi baru pada awalnya.  Ini tidak cocok untuk saya, karena animasi diperlukan untuk situs cryptocurrency - semuanya harus "mahal, kaya". <br><br>  Ketika Anda menggunakan tekstur png dan dekat dengan kamera, Anda dapat melihat bahwa tepi elemen terdekat buram.  Tidak ada perasaan bahwa gambarnya jelas.  Png tampaknya telah membentang di browser.  Masalahnya adalah bahwa di WebGL tidak ada cara untuk menggunakan tekstur vektor dalam arti kata sepenuhnya.  Jadi saya menangis, dan kemudian membaca di Internet bahwa <b>GLSL</b> menyelesaikan masalah ini. <br><br>  GLSL adalah bahasa mirip-C di mana shader ditulis.  Semua orang takut menggunakannya, karena ini adalah shader, WebGL - tidak ada yang jelas!  Tapi saya menemukan bahwa adalah mungkin untuk membuat gambar yang jelas di atasnya, dan beralih ke shader tipe kedua. <br><br><h2>  Shader fragmen </h2><br>  Shader ini melakukan hal yang sama dengan vertex.  Tetapi, jika vertex membangun permukaan polyline, melakukan perhitungan untuk setiap vertex, maka shader Fragment menghitung warna untuk setiap piksel permukaan. <br><br>  Fungsi <code>fragment shader – step(a,b)</code> paling dasar <code>fragment shader – step(a,b)</code> .  Hanya mengembalikan 0 dan 1: <br><br><ul><li>  jika a&gt; b, maka 0; <br></li><li>  jika a &lt;b, maka 1. <br></li></ul><br>  Saya membuat implementasi semu di JS untuk memperjelas betapa sederhananya fungsi ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Ketika Anda bekerja di WebGL, biasanya pada objek apa pun ada sistem koordinat.  Jika itu adalah objek kuadrat, maka sistem koordinatnya adalah primitif: titik (0,0), (0,1), (1,0), (1,1). <br><br>  Fragmen Shader dijalankan untuk setiap piksel.  Jika Vertex Shader adalah 2600 kali per frame, maka Fragment Shader dieksekusi sebanyak piksel.  Mungkin satu juta kali untuk setiap frame, jika permukaannya 1000 × 1000 px.  Kedengarannya menakutkan, tetapi hanya karena sedikit orang yang akrab dengan sumber daya kartu video di zaman kita. <br><br>  Jika Anda menggunakan fungsi langkah (a, b) dengan koordinat piksel ini, Anda dapat menjalankan fungsi langkah dengan parameter 0.4 dan meneruskan koordinat x dari setiap piksel ke setiap titik. <br><br>  Ternyata semua yang kurang dari 0,4 akan menjadi 0, segala sesuatu yang lebih besar dari 1. Di WebGL, angka dan warna adalah satu dan sama.  Setiap warna adalah satu angka.  Putih - 1, hitam - 0. Ada tiga dari mereka di RGB, tetapi masih 0.0.0 dan 1.1.1. <br><br><img src="https://habrastorage.org/webt/0g/yn/u8/0gynu8ekf6ms9lbsxses7zlnsq8.jpeg"><br><br>  Jika kita menjalankan langkah fungsi ini lebih rumit, kita menjadi putih di sebelah kiri.  Fungsi ini akan dieksekusi untuk setiap titik di layar dan akan mempertimbangkan bahwa itu adalah 0 atau 1. Ini normal, jangan khawatir tentang ini. <br><br>  Jika Anda mengalikan dua ekspresi ini, Anda mendapatkan garis putih vertikal.  Jika Anda melakukan hal yang sama pada sumbu yang berbeda, Anda bisa menggambar kotak putih: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/-m/bd/ed-mbd_kkdxv-lfxhmgk4iixr3o.jpeg" width="600"></div><br>  <i>Itu harus menjadi klimaks - kami menggambar kotak putih!</i> <br><br><blockquote>  Dengan menggunakan kombinasi hanya satu fungsi, Anda dapat menggambar apa pun yang Anda inginkan. </blockquote><br>  Jika Anda ingat, elemen-elemen pola itu miring.  Jika Anda membuat permukaan miring, yang hanya terdiri dari warna hitam dan putih, maka akan berusuk, tidak dihaluskan.  Ribbing menangkap mata Anda - itu jelek.  Untuk membuat permukaan terlihat halus untuk mata, tidak hanya piksel hitam dan putih yang diperlukan, tetapi juga abu-abu abu-abu. <br><br><h3>  Smoothstep </h3><br>  Shader memiliki fungsi smoothstep.  Itu melakukan hal yang sama seperti langkah, tetapi interpolasi antara 0 dan 1 sehingga ada gradien. <br><br><img src="https://habrastorage.org/webt/70/ie/sj/70iesjc9whr9omw98d6vgdegn7u.jpeg"><br>  <i>Dari kiri ke kanan, setelah kompresi maksimum.</i> <br><br>  Jika Anda memampatkan fungsi ini sebanyak mungkin, Anda mendapatkan garis gradien minimal.  Ini adalah apa yang Anda butuhkan untuk menghasilkan garis yang sangat halus di setiap sudut dalam shader Fragment. <br><br>  Jadi saya bisa membuat kotak putih dengan tepi yang halus.  Jika ada satu kotak putih, Anda bisa membuat 3 kotak putih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/vj/yj/mkvjyjhkpspu2gyr07ljvav8f0e.jpeg" width="600"></div><br>  <i>Kotak dapat diputar, gunakan fungsi sinus dan cosinus.</i> <br><br>  Kemudian saya harus menggunakan kertas dan daun untuk memecahkan pola saya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/a4/yz/hpa4yzizs2urt92ucauxlgwr3ny.jpeg" width="600"></div><br>  <i>Tangkapan layar dari produksi.</i> <br><br>  Di sana semuanya terhubung dengan 23 derajat multiplisitas yang berbeda, jadi tidak terlalu sulit untuk menghitung koordinat semua titik ini.  Dan kemudian Anda bisa mendapatkan pola seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wr/81/kt/wr81ktna90gxloib0ainetldwrk.jpeg" width="600"></div><br><br>  Saya menggambar satu fragmen dan mengulanginya berkali-kali.  Anda dapat dengan jelas melihat mode debug, di mana polanya berulang.  Semua fragmen dilakukan menggunakan <code>step</code> fungsi parametrik dan <code>smoothstep</code> .  Ini berarti bahwa dengan membuat satu pola untuk memiringkan pesawat, Anda dapat menghasilkan jumlah yang tidak terbatas dari pola-pola ini.  Jika di dalam fragmen kita mengubah ketebalan garis atau ukuran segi enam, maka kita mendapatkan banyak pola lainnya. <br><br>  Saya memutar parameter dan menemukan sejumlah pola yang tak terbatas.  Ini seperti "Seni generatif" - tidak jelas apa yang telah dilakukan, tetapi indah. <br><br><h3>  SDF </h3><br>  Lalu saya menemukan bahwa ada juga <b>bidang jarak yang ditandatangani - menghasilkan gambar dengan peta jarak</b> .  SDF digunakan dalam kartu atau permainan komputer untuk menggambar teks dan objek, karena optimal.  Di WebGL, sulit untuk menggambar teks dengan cara yang berbeda, terutama mulus dan diuraikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-k/il/9h/-kil9h7eyazgilry_p6tqdmqvxw.jpeg" width="600"></div><br><br>  Ini adalah format matematika yang sulit digunakan di luar WebGL.  Idenya sederhana, namun elegan dan memberi efek indah. <br><br>  Jika kita ingin menggambar bintang yang jelas, maka untuk itu kita perlu menyimpan gambar di sebelah kanan - ini adalah gambar yang dihasilkan dari gambar.  Sudah ada algoritma yang mengubah gambar yang jelas menjadi buram.  Setelah itu, dapat digunakan untuk menghasilkan versi yang jelas, tetapi pada saat yang sama kita tidak mendapatkan satu gambar, tetapi banyak.  Dari gambar yang jelas dengan ukuran yang sama, Anda bisa menghasilkan yang sama, tetapi lebih besar.  Itu akan dengan kesalahan, tetapi pendekatan ini menarik secara matematis. <br><br>  Misalnya, jika Anda mengambil gambar dengan ukuran 128 × 128 px, maka dari gambar dalam ukuran kecil Anda bisa mendapatkan gambar yang jelas beberapa kali lebih besar dari sumbernya.  Ini adalah salah satu alasan mengapa mereka menggunakan SDF - font buram sering berbobot kurang dari dalam format vektor yang dioptimalkan. <br><br>  Tentu saja ada batasannya.  Tidak mungkin untuk meningkatkan huruf hingga 1000 px, bahkan 100 px akan terlihat jelek.  Tetapi seberapa sering font dengan ukuran ini dibutuhkan? <br><br>  Shader fragmen, menggambar persegi panjang, menyebar - dengan bantuan gangguan ini, saya akhirnya berhasil menemukan permukaan yang diinginkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t1/nf/5h/t1nf5hhliercxy0q6axrs4bmosm.jpeg" width="600"></div><br><br><h2>  Kondisi baru </h2><br>  Dia memang seharusnya: menggeliat, semua elemen jelas.  Segalanya seperti yang saya inginkan, tetapi ternyata ada lebih dari itu: <br><br>  <i>- Dan biarkan dia bergerak dengan mouse dan jalan baru sedang diletakkan.</i>  <i>Dan sarang madu disorot!</i> <br><br>  Diasumsikan bahwa ketika pengguna menggerakkan mouse, ia secara metaforis membuka jalan berduri di sepanjang "sarang laba-laba" yang rusak menggunakan layanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  Tidak sulit untuk menggambarkan tugas dengan kata-kata, tetapi bagaimana cara mengimplementasikannya?  Hal pertama yang saya pikirkan - karena saya memiliki kisi heksagonal, mungkin sudah dipelajari.  Kemudian saya menemukan artikel yang menarik " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi grid heksagonal dan panduan implementasi</a> ".  Di dalamnya, penulis mengumpulkan materi selama 20 tahun.  Dia keren tanpa pertanyaan, dan artikelnya adalah ilahi bagi mereka yang gemar algoritma dan matematika.  Ini berisi banyak data menarik tentang jerat heksagonal. <br><br>  Artikel ini panjang, tetapi berisi pendekatan matematika yang menarik: bagaimana membangun sistem koordinat pada kisi heksagonal, bagaimana memberi nomor pada heksagon ini, dan kemudian merujuknya di mana ia digunakan.  Ternyata ini selalu di depan mata saya, karena di game komputer lama jaring heksagonal digunakan di mana-mana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/l5/eb/hpl5ebbnsk_y4wwpe68txgddw3a.jpeg" width="600"></div><br>  <i>Jika Anda sudah menyetel fret heksagonal - lihatlah kastil.</i>  <i>Pada tekstur lain, kisi heksagonal juga dapat ditebak.</i> <i><br><br></i> <div style="text-align:center;"> <i><img src="https://habrastorage.org/webt/pm/t3/dr/pmt3dricwm2bhfavsrk4alsb_4i.jpeg" width="600"></i> </div> <i><br></i>  <i>Dalam "Peradaban" semuanya umumnya jelas.</i> <br><br>  Sangat menarik untuk mengetahui bahwa jika Anda membuat penampang sepanjang diagonal kubus tiga dimensi, yang terdiri dari banyak kubus kecil, maka, di satu sisi, ini adalah kubus, dan di sisi lain, segi enam reguler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/or/en/yiorenlgrsykxcxcajtomaq-rf0.jpeg" width="600"></div><br><br>  Penampang kubus tiga dimensi menghasilkan kisi heksagonal dua dimensi.  Sangat menyenangkan mengetahui bahwa kubus tiga dimensi entah bagaimana terhubung dengan segi enam dua dimensi. <br><br>  Dalam artikel tersebut, termasuk, ada algoritma untuk menemukan jalur di sepanjang kisi heksagonal.  Saya harus mencari cara untuk ketinggian melalui mouse. <br><br>  Algoritma pencarian jalur sangat kompleks dan sederhana.  Yang paling primitif adalah menggambar garis di antara titik-titik dan melihat segi enam yang termasuk dalam garis ini.  Jadi ternyata seperti di masa lalu, unit berubah dari titik A ke titik B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/f1/qj/gzf1qjc4ygip7wfnbfam_x3gl1c.jpeg" width="600"></div><br>  <i>Saya membutuhkan sesuatu seperti itu.</i> <br><br>  Tapi bukan itu yang saya butuhkan.  Di sini jalan diletakkan di sepanjang segi segi enam, dan saya perlu di sepanjang tepiannya.  Saya harus menyelesaikan masalah secara berbeda. <br><br><h3>  Canvas2d </h3><br>  Mungkin ada cara yang lebih baik, tetapi cara saya lebih menarik.  Pada awalnya saya hanya menggambar <b>Canvas2D</b> untuk debug saya - langkah # 1. <br><br><img src="https://habrastorage.org/webt/c0/jb/sx/c0jbsx3mwra1bhrek7v7lsmzs6u.jpeg"><br><br>  Sebelum itu, ada WebGL, Three.js, shader, dan ini hanya Canvas2D!  Saya menggambar semua poin dari hex grid di atasnya.  Jika Anda melihat lebih dekat, ini adalah segi enam yang sama.  Kemudian saya ingat grafik yang menyimpan informasi tentang bagaimana titik-titik terhubung satu sama lain, dan menghubungkan setiap titik dengan tiga titik yang berdekatan dan mendapat grafik - langkah nomor 2. Untuk ini saya menggunakan Open Source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beautiful Graphs</a> . <br><br>  Grafik hanyalah kumpulan poin dan informasi tentang bagaimana mereka terhubung.  Mereka dipelajari dengan baik, ada banyak algoritma yang baik untuk setiap selera untuk menemukan jalur dari titik A ke titik B di dalam grafik.  Semua kartu menggunakan algoritma semacam ini. <br><br>  Itu terlihat seperti ini. <br><br><pre> <code class="javascript hljs">graph = createGraph( ); graph.addNode(..); <span class="hljs-comment"><span class="hljs-comment">// 1000 nodes graph.addLink(..); // 3000 links graph.pathFinder(Start, Finish); //0.01s</span></span></code> </pre> <br>  Kami membangun grafik, menambahkan 1000 poin dan semua koneksi di antara mereka, Selanjutnya kami melewati <code>id</code> setiap titik - yang pertama terhubung ke yang ketiga, ketiga ke kelima.  Tidak perlu menemukan apa pun, ada algoritme yang dioptimalkan dengan fungsi yang sudah jadi yang akan memungkinkan Anda menemukan jalur ini. <br><br>  Algoritma ini berjalan kurang dari satu frame.  Tentu saja, dibutuhkan semacam sumber daya, tetapi Anda tidak perlu menjalankannya setiap 16 ms, tetapi hanya ketika jalurnya berubah. <br><br>  Jadi saya bisa membangun rute ini pada langkah nomor 3. Di Canvas2D, mulai terlihat seperti ini: jalur terpendek dari titik A ke titik B - semuanya, seperti dalam kehidupan.  Pada pandangan pertama tampaknya ini bukan jalur terpendek, tetapi ternyata ada banyak jalur terpendek dari titik A ke titik B di sepanjang kisi heksagonal. <br><br>  Di WebGL, semua gambar adalah angka.  Di sana Anda dapat mentransfer tekstur di shader, misalnya, saya mencoba mentransfer png.  Tidak ada perbedaan untuk browser - dilewatkan png atau Canvas2D.  Untuk browser Canvas2D, itu sama dengan gambar yang sudah jadi, bitmap.  Karena itu, saya pertama menggambar gambar ini dalam bentuk ular.      № 4. <br><br>  Canvas2D       .     Canvas2D    ,     —        .  ,   .   ,       Canvas2D  3D,  ,       . <br><br>  , ,   WebGL     —  ,     «, »,     . <br><br> ,     ,      Canvas2D,     ,          ,    .     Canvas2D   ,         WebGL,       . <br><br><img src="https://habrastorage.org/webt/z6/uk/kv/z6ukkv00x1pzffhp1ctfd7q7tiw.jpeg"><br> <i> :  ,     ,    .</i> <br><br>   ,   --. ,    ,         «» . <br><br><h2>     ? </h2><br>    : «   ?   ?»  ,     : «,  !».    ,  .       . <br><br>   ,      WebGL. ,      .          ,     WebGL.     2  — ,    . <br><br> , ,    . ,   . <br><br><img src="https://habrastorage.org/webt/yx/0s/kk/yx0skkl_xmwk-ekewducomsgvxs.jpeg">        ,     .   ,   ,  ,     3D   —      . <br><br>   ,            .     ,   ,      . <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontendConf</a>   .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Canvas</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  RxJS</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSX  React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>    30     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .       ,  ,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450832/">https://habr.com/ru/post/id450832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450822/index.html">Kerangka kerja yang hilang</a></li>
<li><a href="../id450824/index.html">Keadaan css</a></li>
<li><a href="../id450826/index.html">Cara berbicara dengan mikrokontroler dari JS</a></li>
<li><a href="../id450828/index.html">Ketika kota tertidur ...</a></li>
<li><a href="../id450830/index.html">Nikita Dubko pada konferensi, sindrom penipu dan pelaporan</a></li>
<li><a href="../id450834/index.html">Situs parsing - dan apakah secara umum legal di Rusia?</a></li>
<li><a href="../id450836/index.html">Di rel di belakang awan: cara mencuci kaca di gedung pencakar langit</a></li>
<li><a href="../id450840/index.html">Senter terakhir sudah lelah atau Akankah flicker menyelamatkan Belarus (upd. Spinner?)</a></li>
<li><a href="../id450844/index.html">Pengantar Pemetaan Contoh</a></li>
<li><a href="../id450846/index.html">Keajaiban kemasan dari Microsoft: kernel Linux di Windows 10 dan mesin IE di dalam Chromium Edge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>