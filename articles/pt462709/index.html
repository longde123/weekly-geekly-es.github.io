<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèª üë§ ü§±üèª Teste de muta√ß√£o em PHP: uma medida qualitativa para cobertura de c√≥digo ü§π üç≠ üâë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como avaliar a qualidade dos testes? Muitos confiam na m√©trica mais popular conhecida por todos - cobertura de c√≥digo. Mas essa √© uma m√©trica quantita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de muta√ß√£o em PHP: uma medida qualitativa para cobertura de c√≥digo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/462709/">  Como avaliar a qualidade dos testes?  Muitos confiam na m√©trica mais popular conhecida por todos - cobertura de c√≥digo.  Mas essa √© uma m√©trica quantitativa, n√£o qualitativa.  Ele mostra quanto do seu c√≥digo √© coberto por testes, mas n√£o o qu√£o bem esses testes s√£o gravados. <br><br>  Uma maneira de descobrir isso √© atrav√©s do teste de muta√ß√£o.  Essa ferramenta, fazendo pequenas altera√ß√µes no c√≥digo-fonte e executando novamente os testes depois disso, permite identificar testes in√∫teis e cobertura de baixa qualidade. <br><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meetup de PHP</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo, em mar√ßo,</a> falei sobre como organizar o teste mutacional para c√≥digo PHP e quais problemas voc√™ pode encontrar.  O v√≠deo est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e, para a vers√£o em texto, seja bem-vindo ao gato. <br><br><img src="https://habrastorage.org/webt/qc/xz/fi/qcxzfinlil5-p8zjwtafifv2mqu.jpeg"><br><a name="habracut"></a><br><h2>  O que √© teste de muta√ß√£o </h2><br>  Para explicar o que quero dizer, mostrarei alguns exemplos.  Eles s√£o simples, exagerados em alguns lugares e podem parecer √≥bvios (embora exemplos reais sejam geralmente bastante complexos e n√£o possam ser vistos com os olhos). <br><br>  Considere a situa√ß√£o: temos uma fun√ß√£o elementar que afirma ser um adulto e h√° um teste que a testa.  O teste possui um dataProvider, ou seja, testa dois casos: 17 anos e 19 anos.  Para muitos de voc√™s, √© √≥bvio que o adulto tem 100% de cobertura.  A √∫nica linha.  √â realizado por um teste.  Tudo √© maravilhoso. <br><br><img src="https://habrastorage.org/webt/w2/qq/ag/w2qqagnuajffn5ubmkgwnbsubpg.png"><br><br>  Por√©m, um exame mais detalhado revela que nosso fornecedor √© mal escrito e n√£o testa condi√ß√µes de contorno: a idade de 18 anos como condi√ß√£o de contorno n√£o √© testada.  Voc√™ pode substituir o sinal&gt; por&gt; =, e o teste n√£o detectar√° essa altera√ß√£o. <br><br>  Outro exemplo, um pouco mais complicado.  Existe uma fun√ß√£o que cria algum objeto simples contendo setters e getters.  Temos tr√™s campos que definimos e h√° um teste que verifica se a fun√ß√£o buildPromoBlock realmente coleta o objeto que esperamos. <br><br><img src="https://habrastorage.org/webt/a6/mr/eq/a6mreqjphzfwflq35qxf5skwfle.png"><br><br>  Se voc√™ observar atentamente, tamb√©m definimos setSomething, que define algumas propriedades como true.  Mas no teste n√£o temos essa afirma√ß√£o.  Ou seja, podemos remover esta linha do buildPromoBlock - e nosso teste n√£o detectar√° essa altera√ß√£o.  Ao mesmo tempo, temos 100% de cobertura na fun√ß√£o buildPromoBlock, porque todas as tr√™s linhas foram executadas durante o teste. <br><br>  Esses dois exemplos nos levam ao que √© o teste de muta√ß√£o. <br><br>  Antes de desmontar o algoritmo, darei uma breve defini√ß√£o.  O teste de muta√ß√£o √© um mecanismo que nos permite, fazendo pequenas altera√ß√µes no c√≥digo, imitar as a√ß√µes do maligno Pin√≥quio ou o jovem Vasya, que veio e come√ßou a quebr√°-lo intencionalmente, substituindo os sinais&gt; por &lt;, = by! =, E assim por diante.  Para cada altera√ß√£o que fazemos para bons prop√≥sitos, executamos testes que devem cobrir a linha alterada. <br><br>  Se os testes n√£o nos mostraram nada, se n√£o ca√≠ram, provavelmente n√£o s√£o eficazes o suficiente.  Eles n√£o testam casos de fronteira, n√£o cont√™m afirma√ß√µes: talvez precisem ser melhorados.  Se os testes ca√≠rem, eles s√£o legais.  Eles realmente protegem contra essas mudan√ßas.  Portanto, nosso c√≥digo √© mais dif√≠cil de quebrar. <br><br>  Agora vamos analisar o algoritmo.  √â bem simples  A primeira coisa que fazemos para realizar o teste de muta√ß√£o √© pegar o c√≥digo fonte.  Em seguida, obtemos cobertura de c√≥digo para saber quais testes executar para qual sequ√™ncia.  Depois disso, revisamos o c√≥digo fonte e geramos os chamados mutantes. <br><br>  Um mutante √© uma altera√ß√£o de c√≥digo √∫nico.  Ou seja, assumimos uma certa fun√ß√£o em que havia um sinal&gt; em compara√ß√£o, se, alteramos esse sinal para&gt; = - e obtemos um mutante.  Depois disso, executamos os testes.  Aqui est√° um exemplo de uma muta√ß√£o (substitu√≠mos&gt; por&gt; =): <br><br><img src="https://habrastorage.org/webt/tu/fe/rm/tufermumemlipcqjluus2h-bzmm.png"><br><br>  Nesse caso, as muta√ß√µes n√£o s√£o feitas aleatoriamente, mas de acordo com certas regras.  A resposta do teste de muta√ß√£o √© idempotente.  N√£o importa quantas vezes executemos testes mutacionais no mesmo c√≥digo, ele produz os mesmos resultados. <br><br>  A √∫ltima coisa que fazemos √© executar os testes que cobrem a linha mutada.  Tire isso da cobertura.  Existem ferramentas n√£o ideais que conduzem todos os testes.  Mas uma boa ferramenta afastar√° apenas as necess√°rias. <br><br>  Depois disso, avaliamos o resultado.  Os testes ca√≠ram - ent√£o est√° tudo bem.  Se eles n√£o ca√≠ram, ent√£o eles n√£o s√£o muito eficazes. <br><br><h2>  M√©tricas </h2><br>  Quais m√©tricas os testes de muta√ß√£o nos fornecem?  Ele adiciona mais tr√™s √† cobertura do c√≥digo, sobre o qual falaremos agora. <br><br>  Mas primeiro, vamos analisar a terminologia. <br><br><img width="400" src="https://habrastorage.org/webt/_6/pu/yz/_6puyzoefm_yith6s0ep8yzwqao.png"><br><br>  Existe o conceito de mutantes mortos: esses s√£o os mutantes que nossos testes ‚Äúpregaram‚Äù (ou seja, eles os pegaram). <br><br><img width="400" src="https://habrastorage.org/webt/3b/7o/it/3b7oitf-byu91zv3jbooogylvna.png"><br><br>  Existe o conceito de mutante escapado (mutantes sobreviventes).  Estes s√£o os mutantes que conseguiram evitar a puni√ß√£o (ou seja, os testes n√£o os pegaram). <br><br><img width="400" src="https://habrastorage.org/webt/dw/8a/ye/dw8ayeaxuwut_6rcbdchfdm0cfg.png"><br><br>  E h√° conceitos cobertos de mutante - um mutante coberto por testes e um mutante descoberto oposto a ele, que n√£o √© coberto por nenhum teste (isto √©, temos c√≥digo, tem l√≥gica de neg√≥cios, podemos alter√°-lo, mas n√£o um √∫nico teste) n√£o verifica altera√ß√µes). <br><br>  O principal indicador que o teste de muta√ß√£o nos fornece √© o MSI (indicador de pontua√ß√£o na muta√ß√£o), a raz√£o entre o n√∫mero de mutantes mortos e o n√∫mero total deles. <br><br>  O segundo indicador √© a cobertura do c√≥digo de muta√ß√£o.  √â apenas qualitativo, n√£o quantitativo, porque mostra quanta l√≥gica de neg√≥cios voc√™ pode quebrar e faz isso regularmente, nossos testes s√£o capturados. <br><br>  E a √∫ltima m√©trica √© MSI coberto, isto √©, um MSI mais suave.  Nesse caso, calculamos o MSI apenas para os mutantes que foram cobertos por testes. <br><br><h2>  Problemas de teste de muta√ß√£o </h2><br>  Por que menos da metade dos programadores ouviu falar sobre essa ferramenta?  Por que n√£o √© usado em todos os lugares? <br><br><h3>  Baixa velocidade </h3><br>  O primeiro problema (um dos principais) √© a velocidade do teste de muta√ß√£o.  No c√≥digo, se tivermos dezenas de operadores de muta√ß√£o, mesmo para a classe mais simples, podemos gerar centenas de muta√ß√µes.  Para cada muta√ß√£o, voc√™ precisar√° executar testes.  Se tivermos, digamos, 5.000 testes de unidade que s√£o executados por dez minutos, o teste mutacional pode levar horas. <br><br>  O que pode ser feito para nivelar isso?  Execute testes em paralelo, em v√°rios threads.  Jogue fluxos em v√°rios carros.  Isso funciona. <br><br>  A segunda maneira √© execu√ß√µes incrementais.  N√£o h√° necessidade de contar indicadores mutacionais para toda a ramifica√ß√£o de cada vez - voc√™ pode obter diferen√ßas de ramifica√ß√£o.  Se voc√™ usar brunches de recursos, ser√° f√°cil fazer isso: execute testes apenas nos arquivos que foram alterados e veja o que est√° acontecendo no assistente, compare, analise. <br><br>  A pr√≥xima coisa que voc√™ pode fazer √© ajustar a muta√ß√£o.  Como os operadores de muta√ß√£o podem ser alterados, voc√™ pode definir certas regras pelas quais eles funcionam, e pode interromper algumas muta√ß√µes se elas conscientemente levarem a problemas. <br><br>  Um ponto importante: o teste mutacional √© adequado apenas para testes de unidade.  Apesar de poder ser executado para testes de integra√ß√£o, essa √© obviamente uma id√©ia falha, porque os testes de integra√ß√£o (como de ponta a ponta) s√£o muito mais lentos e afetam muito mais c√≥digo.  Voc√™ simplesmente nunca esperar√° pelos resultados.  Em princ√≠pio, esse mecanismo foi inventado e desenvolvido exclusivamente para testes de unidade. <br><br><h3>  Mutantes sem fim </h3><br>  O segundo problema que pode surgir com os testes de muta√ß√£o s√£o os chamados mutantes sem fim.  Por exemplo, h√° um c√≥digo simples, um loop for simples: <br><br><img src="https://habrastorage.org/webt/no/tr/az/notrazetuv221u41t1g8rfbkmlc.png"><br><br>  Se voc√™ substituir i ++ por i--, o ciclo se tornar√° infinito.  Seu c√≥digo permanecer√° por um longo tempo.  E o teste mutacional geralmente gera essas muta√ß√µes. <br><br>  A primeira coisa que voc√™ pode fazer √© ajustar a muta√ß√£o.  Obviamente, mudar o i ++ para o i-- em um loop for √© uma p√©ssima id√©ia: em 99% dos casos, acabaremos com um loop infinito.  Portanto, proibimos fazer isso em nossa ferramenta. <br><br>  A segunda e mais importante coisa que protege voc√™ de tais problemas √© o tempo limite para a execu√ß√£o.  Por exemplo, o mesmo PHPUnit tem a capacidade de concluir um teste de tempo limite, independentemente de onde estiver parado.  O PHPUnit atrav√©s do PCNTL desliga os retornos de chamada e calcula o tempo em si.  Se o teste falhar por um determinado per√≠odo, ele simplesmente √© corrigido e esse caso √© considerado um mutante morto, porque o c√≥digo que gerou as muta√ß√µes √© realmente verificado pelo teste, o que realmente captura o problema, indicando que o c√≥digo ficou inoperante. <br><br><h3>  Mutantes id√™nticos </h3><br>  Esse problema existe na teoria do teste de muta√ß√£o.  Na pr√°tica, eles n√£o o encontram com muita frequ√™ncia, mas voc√™ precisa saber sobre isso. <br><br>  Considere um exemplo cl√°ssico que ilustra isso.  Temos uma multiplica√ß√£o da vari√°vel A por -1 e divis√£o de A por -1.  No caso geral, essas opera√ß√µes levam ao mesmo resultado.  Mudamos o sinal de A. Conseq√ºentemente, temos uma muta√ß√£o que permite que dois sinais mudem entre si.  A l√≥gica do programa por essa muta√ß√£o n√£o √© violada.  Testes e n√£o deve peg√°-lo, n√£o deve cair.  Devido a esses mutantes id√™nticos, algumas dificuldades surgem. <br><br>  N√£o h√° solu√ß√£o universal - todos resolvem esse problema √† sua maneira.  Talvez algum tipo de sistema de registro de mutantes ajude.  N√≥s do Badoo estamos pensando em algo semelhante agora, vamos imit√°-los. <br><br><h2>  Isto √© uma teoria.  E o PHP? </h2><br>  Existem duas ferramentas conhecidas para testes mutacionais: Humbug e Infection.  Quando eu estava preparando o artigo, queria falar sobre qual √© o melhor e chegar √† conclus√£o de que isso √© infec√ß√£o. <br>  Mas quando fui para a p√°gina do Humbug, vi o seguinte: O Humbug se declarou obsoleto em favor da Infec√ß√£o.  Portanto, parte do meu artigo acabou sendo sem sentido.  Portanto, a infec√ß√£o √© uma ferramenta muito boa.  Devo agradecer ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">borNfree</a> de Minsk, que o criou.  Ele realmente funciona bem.  Voc√™ pode peg√°-lo diretamente da caixa, coloc√°-lo no compositor e inici√°-lo. <br><br>  N√≥s realmente gostamos de Infec√ß√£o.  N√≥s quer√≠amos us√°-lo.  Mas eles n√£o podiam por dois motivos.  A infec√ß√£o requer cobertura de c√≥digo para executar testes de mutantes correta e precisamente.  Aqui temos duas maneiras.  Podemos calcul√°-lo diretamente em tempo de execu√ß√£o (mas temos 100.000 testes de unidade).  Ou podemos calcul√°-lo para o mestre atual (mas construir em nossa nuvem de dez m√°quinas muito poderosas em v√°rios threads leva uma hora e meia).  Se fizermos isso a cada execu√ß√£o mutacional, a ferramenta provavelmente n√£o funcionar√°. <br><br>  Existe uma op√ß√£o para alimentar o final, mas no formato PHPUnit, esse √© um monte de arquivos XML.  Al√©m do fato de conterem informa√ß√µes valiosas, eles arrastam um monte de estrutura, alguns colchetes e outras coisas.  Imaginei que, em geral, nossa cobertura de c√≥digo pesaria cerca de 30 GB e precisamos arrast√°-la por todas as m√°quinas em nuvem, lidas constantemente a partir do disco.  Em geral, a id√©ia √© mais ou menos. <br>  O segundo problema foi ainda mais significativo.  Temos uma maravilhosa biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoftMocks</a> .  Ele nos permite lidar com o c√≥digo legado, dif√≠cil de testar, e escrever com √™xito testes para ele.  Estamos usando-o ativamente e n√£o o recusaremos no futuro pr√≥ximo, apesar de estarmos escrevendo um novo c√≥digo para n√£o precisar do SoftMocks.  Portanto, essa biblioteca √© incompat√≠vel com o Infection, porque eles usam quase a mesma abordagem para alterar altera√ß√µes. <br><br>  Como o SoftMocks funciona?  Eles interceptam inclus√µes de arquivos e as substituem por modificadas, ou seja, em vez de executar a classe A, os SoftMocks criam a classe A em um local diferente e conectam outra em vez da original.  A infec√ß√£o age exatamente da mesma maneira, mas funciona atrav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">stream_wrapper_register ()</a> , que faz a mesma coisa, mas no n√≠vel do sistema.  Como resultado, SoftMocks ou Infection podem funcionar para n√≥s.  Como o SoftMocks √© necess√°rio para nossos testes, √© muito dif√≠cil tornar essas duas ferramentas amigas.  Provavelmente isso √© poss√≠vel, mas, neste caso, entramos tanto em Infec√ß√£o que o significado dessas mudan√ßas √© simplesmente perdido. <br><br>  Superando dificuldades, escrevemos nosso pequeno instrumento.  Emprestamos operadores de muta√ß√£o da Infection (eles s√£o escritos de maneira legal e muito f√°ceis de usar).  Em vez de iniciar as muta√ß√µes por meio de stream_wrapper_register (), as executamos pelo SoftMocks, ou seja, usamos nossa ferramenta da caixa.  Nossa ferramenta √© amiga do nosso servi√ßo de cobertura de c√≥digo interno.  Ou seja, sob demanda, ele pode receber cobertura para um arquivo ou linha sem executar todos os testes, o que acontece muito rapidamente.  No entanto, √© simples.  Se o Infection tiver v√°rios tipos de ferramentas e recursos (por exemplo, iniciando em v√°rios threads), o nosso n√£o ter√° nada parecido.  Mas usamos nossa infraestrutura interna para compensar essa falha.  Por exemplo, executamos o mesmo teste em v√°rios segmentos atrav√©s da nossa nuvem. <br><br>  Como usamos isso? <br><br>  O primeiro √© uma execu√ß√£o manual.  Esta √© a primeira coisa a fazer.  Todos os testes que voc√™ escreve s√£o verificados manualmente pelo teste de muta√ß√£o.  Parece algo como isto: <br><br><img src="https://habrastorage.org/webt/-5/xc/t1/-5xct1pygkkjfkxsvr8rhcf-rpc.png"><br><br>  Fiz um teste de muta√ß√£o para algum arquivo.  Obteve o resultado: 16 mutantes.  Desses, 15 foram mortos por testes e um caiu com um erro.  Eu n√£o disse que muta√ß√µes podem gerar fatalidades.  Podemos facilmente mudar algo: invalidar o tipo de retorno ou outra coisa.  Isso √© poss√≠vel, √© considerado um mutante morto, porque nosso teste come√ßar√° a cair. <br><br>  No entanto, a infec√ß√£o distingue esses mutantes em uma categoria separada pelo motivo que √†s vezes vale a pena prestar aten√ß√£o especial aos erros.  Acontece que algo estranho acontece - e o mutante n√£o √© considerado corretamente morto. <br><br>  A segunda coisa que usamos √© o relat√≥rio sobre o mestre.  Uma vez por dia, √† noite, quando nossa infraestrutura de desenvolvimento est√° ociosa, geramos um relat√≥rio de cobertura de c√≥digo.  Depois disso, fazemos o mesmo relat√≥rio de teste de muta√ß√£o.  √â assim: <br><br><img src="https://habrastorage.org/webt/gf/br/oc/gfbroc92o5cn5xe7a1q3fmwcofm.png"><br><br>  Se voc√™ j√° viu o relat√≥rio sobre a cobertura de c√≥digo do PHPUnit, provavelmente percebeu que a interface √© semelhante, porque criamos nossa ferramenta por analogia.  Ele simplesmente calculou todos os principais indicadores de um arquivo espec√≠fico em um diret√≥rio.  Tamb√©m estabelecemos certas metas (na verdade, as retiramos do teto e ainda n√£o as cumprimos, pois ainda n√£o decidimos quais metas devem ser guiadas por cada m√©trica, mas elas existem para facilitar a cria√ß√£o de relat√≥rios no futuro). <br><br>  E a √∫ltima coisa, a mais importante, que √© uma consequ√™ncia das outras duas.  Programadores s√£o pessoas pregui√ßosas.  Sou pregui√ßoso: gosto de tudo para trabalhar e n√£o preciso fazer gestos extras.  Fizemos isso para que, quando um desenvolvedor forne√ßa sua pr√≥pria ramifica√ß√£o, os indicadores de sua ramifica√ß√£o e mestre de brunch sejam automaticamente contados incrementalmente. <br><br><img src="https://habrastorage.org/webt/k2/i6/mu/k2i6murvfrlvwfjx-fklewrj2so.png"><br><br>  Por exemplo, executei dois arquivos e obtive esse resultado.  No mestre, eu tinha 548 mutantes, 400 foram mortos, segundo outro arquivo - 147 contra 63. No meu ramo, o n√∫mero de mutantes nos dois casos aumentou.  Mas no primeiro arquivo, o mutante foi pregado e, no segundo, ele escapou.  Naturalmente, o indicador MSI caiu.  Isso permite que mesmo as pessoas que n√£o desejam perder tempo realizem testes mutacionais com as pr√≥prias m√£os, vejam o que fizeram pior e prestem aten√ß√£o a ele (exatamente da mesma maneira que os revisores fazem no processo de revis√£o de c√≥digo). <br><br><h2>  Resultados </h2><br>  Ainda √© dif√≠cil fornecer n√∫meros: n√£o t√≠nhamos nenhum indicador, agora ele apareceu, mas n√£o h√° nada com o que comparar. <br><br>  Posso dizer que o teste mutacional d√° em termos de efeito psicol√≥gico.  Se voc√™ come√ßa a executar seus testes atrav√©s de testes de muta√ß√£o, involuntariamente come√ßa a escrever testes melhores, e escrever testes de qualidade inevitavelmente leva a uma mudan√ßa na maneira como voc√™ escreve c√≥digo - voc√™ come√ßa a pensar que precisa cobrir todos os casos em que pode quebrar, voc√™ o inicia. melhor estrutura, torn√°-lo mais test√°vel. <br><br>  Esta √© uma opini√£o exclusivamente subjetiva.  Mas alguns de meus colegas deram o mesmo feedback: quando come√ßaram a usar constantemente testes mutacionais em seu trabalho, come√ßaram a escrever testes melhor e muitos disseram que come√ßaram a escrever melhor c√≥digo. <br><br><h2>  Conclus√µes </h2><br>  A cobertura do c√≥digo √© uma m√©trica importante que precisa ser monitorada.  Mas este indicador n√£o garante nada: n√£o significa que voc√™ est√° seguro. <br><br>  O teste de muta√ß√£o pode ajudar a melhorar seus testes de unidade e a cobertura do c√≥digo de rastreamento faz sentido.  J√° existe uma ferramenta para PHP, portanto, se voc√™ tiver um projeto pequeno sem problemas, ent√£o pegue e experimente hoje. <br><br>  Comece pelo menos executando um teste de muta√ß√£o manualmente.  D√™ este simples passo e veja o que ele oferece.  Tenho certeza que voc√™ vai gostar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462709/">https://habr.com/ru/post/pt462709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462699/index.html">Malha de servi√ßo, "Plano de dados" e "Plano de controle" (plano de dados da malha de servi√ßo x plano de controle)</a></li>
<li><a href="../pt462701/index.html">Biblioteca de gerador de c√≥digo Assembler para microcontroladores AVR. Parte 2</a></li>
<li><a href="../pt462703/index.html">A catraca ‚Äúmais barata‚Äù na R√∫ssia controlada a partir de um smartphone</a></li>
<li><a href="../pt462705/index.html">Os 5 principais erros nos meus aplicativos ReactJS</a></li>
<li><a href="../pt462707/index.html">Kubernetes lan√ßa ferramentas de desenvolvedor de aplicativos</a></li>
<li><a href="../pt462717/index.html">A disputa de dois yokozun</a></li>
<li><a href="../pt462723/index.html">Pegue um gato com TLA +</a></li>
<li><a href="../pt462725/index.html">Trigonometria</a></li>
<li><a href="../pt462727/index.html">Resumo do Joomla de junho a julho de 2019</a></li>
<li><a href="../pt462729/index.html">Noite de palestras aberta sobre design de narrativas na VSBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>