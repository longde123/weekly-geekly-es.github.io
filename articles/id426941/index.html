<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📜 🕺 🖕🏾 Tentang pertanyaan kecepatan dan mengukurnya di Arduino 👇🏾 ⛴️ 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Masalah ini muncul dalam studi kinerja Arduino ketika menjalankan berbagai perintah (lebih lanjut tentang itu di pos terpisah). Dalam perjalanan studi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang pertanyaan kecepatan dan mengukurnya di Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426941/"><img src="https://habrastorage.org/webt/kx/oe/cl/kxoecl7ngezzej1ftzcleeswzde.jpeg"><br><br>  Masalah ini muncul dalam studi kinerja Arduino ketika menjalankan berbagai perintah (lebih lanjut tentang itu di pos terpisah).  Dalam perjalanan studi, keraguan muncul tentang keteguhan waktu kerja perintah individu ketika nilai operan berubah (ternyata kemudian, tidak masuk akal) dan keputusan dibuat untuk mencoba memperkirakan waktu pelaksanaan perintah terpisah.  Untuk ini, sebuah program kecil ditulis (yang mengatakan sketsa adalah meninggalkan kelas), yang, pada pandangan pertama, mengkonfirmasi hipotesis tersebut.  Dalam kesimpulan, Anda dapat mengamati nilai 16 dan 20, tetapi kadang-kadang 28 dan bahkan 32 mikrodetik ditemukan.  Jika kami mengalikan data yang diterima dengan 16 (frekuensi clock MK), kami mendapatkan waktu eksekusi dalam siklus MK (dari 256 menjadi 512).  Sayangnya, proses berulang dari siklus program utama (dengan data awal yang sama), sambil mempertahankan gambaran keseluruhan, sudah memberikan distribusi waktu eksekusi yang berbeda, sehingga variasi waktu aktual tidak terkait dengan data awal.  Hipotesis asli dibantah, tetapi menjadi menarik, dan apa sebenarnya yang terkait dengan sebaran yang begitu signifikan. <br><a name="habracut"></a><br>  Catatan yang diperlukan - Saya mengerti betul bahwa program yang lebih canggih harus digunakan untuk mengukur waktu pelaksanaan perintah, tetapi untuk perkiraan kasar, yang akan ditunjukkan nanti sudah cukup. <br><br>  Jadi, waktu berubah, dan sangat signifikan, kami mencari penyebab fenomena ini.  Pertama-tama, kami memperhatikan banyaknya nilai yang diperoleh, lihat uraian pustaka kerja dari waktu ke waktu dan melihat bahwa 4µsec adalah kuantum pengukuran, jadi lebih baik pergi ke kuanta dan memahami bahwa kami mendapatkan 4 atau 5 (sangat sering) dan 6 atau 7 atau 8 unit (sangat jarang).  Dengan babak pertama, semuanya mudah - jika nilai yang terukur terletak antara 4 dan 5 unit, maka hamburan menjadi tak terhindarkan.  Selain itu, dengan mempertimbangkan sampel menjadi independen, kami dapat meningkatkan akurasi pengukuran dengan metode statistik, yang kami lakukan, memperoleh hasil yang dapat diterima. <br><br>  Tetapi dengan babak kedua (6,7,8) segalanya menjadi lebih buruk.  Kami menemukan bahwa pencar tidak berkorelasi dengan sumber data, yang berarti bahwa ini adalah manifestasi dari proses lain yang mempengaruhi waktu eksekusi perintah.  Perlu dicatat bahwa emisi agak jarang dan tidak menunjukkan pengaruh yang signifikan terhadap nilai rata-rata yang dihitung.  Akan mungkin untuk mengabaikan mereka sama sekali, tetapi ini bukan gaya kita.  Secara umum, selama bertahun-tahun bekerja di bidang teknik, saya menyadari bahwa Anda tidak dapat meninggalkan kesalahpahaman, tidak peduli seberapa tidak penting tampaknya, karena mereka memiliki kemampuan menjijikkan untuk memukul di belakang (baik, atau di mana pun mereka mencapai) pada saat yang paling tidak tepat. <br><br>  Kami mulai mengemukakan <b>hipotesis 1</b> - yang paling nyaman (dalam kenyamanan dan fleksibilitas itu adalah yang kedua setelah intervensi langsung dari Pencipta) - gangguan perangkat lunak, tentu saja, bukan milik saya, program saya tidak pernah gagal, tetapi perpustakaan yang terhubung (kompiler, sistem operasi, browser, dll. - gantikan yang diperlukan).  Selain itu, karena saya menjalankan program dalam emulator di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.tinkercad.com</a> , Anda masih dapat merujuk ke bug emulator dan menutup topik, karena kode sumber tidak tersedia bagi kami.  Kontra dari hipotesis ini: <br><br><ol><li>  Dari siklus ke siklus, lokasi penyimpangan berubah, yang mengisyaratkan. </li><li>  Situs ini masih mendukung AutoDesk, meskipun argumennya agak lemah. </li><li>  "Kami menerima dalil bahwa apa yang terjadi bukanlah halusinasi, kalau tidak, itu tidak akan menarik." </li></ol><br>  Asumsi berikutnya adalah pengaruh dari beberapa proses latar belakang pada hasil pengukuran.  Kami tampaknya tidak melakukan apa pun selain percaya, meskipun ... kami mengeluarkan hasilnya dalam Serial.  <b>Hipotesis 2</b> muncul - waktu output kadang-kadang (aneh seperti itu ... tapi itu terjadi) ditambahkan ke waktu eksekusi perintah.  Meskipun meragukan berapa banyak output yang ada, tapi bagaimanapun - menambahkan Flush tidak membantu, menambahkan penundaan untuk menyelesaikan output dan tidak membantu, umumnya memindahkan output dari loop - lagi pula, waktu melonjak - ini jelas bukan Serial. <br><br>  Nah, yang tersisa adalah pengaturan siklus itu sendiri (dari mana ketakutan untuk mengubah durasinya, tidak jelas) dan itu saja ... meskipun micros () tetap ada.  Maksud saya waktu eksekusi panggilan pertama dari fungsi ini dan yang kedua adalah sama dan ketika mengurangi kedua nilai ini saya mendapatkan nol, tetapi jika asumsi ini salah? <br><br>  Hipotesis 3 - kadang-kadang panggilan kedua dari penghitungan waktu memakan waktu lebih lama dari yang pertama, atau tindakan yang terkait dengan penghitungan waktu terkadang mempengaruhi hasilnya.  Kami melihat kode sumber fungsi bekerja dengan waktu (arduino-1.8.4 \ hardware \ arduino \ avr \ cores \ arduino \ wiring.c - Saya telah berulang kali menyatakan sikap saya terhadap hal-hal seperti itu, saya tidak akan mengulangi sendiri) dan kami melihat bahwa 1 kali dari 256 siklus peningkatan perangkat keras bagian yang lebih muda dari penghitung terputus untuk meningkatkan bagian yang lebih tua dari penghitung. <br><br>  Waktu eksekusi siklus kami adalah dari 4 hingga 5, sehingga kami dapat mengharapkan 170 * (4..5) / 256 = dari tiga hingga empat nilai anomali dalam segmen 170 pengukuran.  Kami melihat - terlihat sangat mirip, sebenarnya ada 4 dari mereka.  Untuk memisahkan alasan pertama dan kedua, kami membuat perhitungan dengan bagian kritis dengan gangguan terlarang.  Hasilnya tidak banyak berubah, emisi masih ada tempatnya, yang berarti bahwa waktu ekstra dibawa oleh micros ().  Di sini kita tidak dapat melakukan apa pun, meskipun kode sumber tersedia, kami tidak dapat mengubahnya - perpustakaan disertakan dalam binari.  Tentu saja, kita dapat menulis fungsi kita sendiri bekerja dengan waktu dan mengamati perilaku mereka, tetapi ada cara yang lebih sederhana. <br><br>  Karena pemrosesan "lama" dari interupsi adalah alasan yang mungkin untuk peningkatan durasi, kami mengecualikan kemungkinan terjadinya selama proses pengukuran.  Untuk melakukan ini, tunggu manifestasinya dan baru kita melakukan siklus pengukuran.  Karena gangguan terjadi jauh lebih jarang daripada siklus pengukuran kami berlangsung, kami dapat menjamin tidak adanya.  Kami menulis fragmen yang sesuai dari program (menggunakan <s>peretasan kotor dengan</s> informasi yang diekstrak dari kode sumber) dan, "ini adalah sihir jalanan", semuanya menjadi normal - kami mengukur waktu eksekusi 4 dan 5 kuanta dengan nilai rata-rata waktu eksekusi operasi tambahan dengan PT dari siklus 166 jam, yang sesuai dengan nilai yang diukur sebelumnya.  Hipotesis dapat dianggap dikonfirmasi. <br><br>  Masih ada satu pertanyaan lagi - dan apa yang butuh begitu lama dalam interupsi, apa yang diperlukan <br>  (7.8) - (5) ~ 2 quanta = * 4 = 8msec * 16 = 128 siklus prosesor?  Kami beralih ke kode sumber (yaitu, ke kode assembler yang dihasilkan oleh kompiler di godbolt.com) dan kami melihat bahwa interupsi itu sendiri dijalankan kira-kira 70 siklus, 60 di antaranya terus-menerus, dan ketika membaca ada biaya tambahan 10 siklus, total 70 ketika mencapai interupsi - kurang dari yang diterima, tetapi cukup dekat.  Kami mengaitkan perbedaan itu dengan perbedaan antara kompiler atau mode penggunaannya. <br><br>  Nah, sekarang kita dapat mengukur waktu eksekusi sebenarnya dari perintah penambahan PT dengan berbagai argumen dan memastikan bahwa itu benar-benar banyak berubah ketika mengubah argumen: dari 136 langkah untuk 0,0 menjadi 190 untuk 0,63 (angka ajaib), dan ini hanya 162 untuk 10,63.  Dengan probabilitas 99,9%, hal ini disebabkan oleh kebutuhan akan penyelarasan dan fitur implementasinya di perpustakaan khusus ini, tetapi penelitian ini jelas melampaui lingkup masalah yang dipertimbangkan. <br><br><div class="spoiler">  <b class="spoiler_title">Lampiran - teks program:</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">9600</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> t; //   <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { <span class="hljs-type"><span class="hljs-type">int</span></span> d[<span class="hljs-number"><span class="hljs-number">170</span></span>]; unsigned long <span class="hljs-type"><span class="hljs-type">time</span></span>,time1; <span class="hljs-type"><span class="hljs-type">float</span></span> dt=<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">170.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">170</span></span>; ++i) { { //       time1=micros(); long time2; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { time2=micros(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((time2 &amp; ~<span class="hljs-number"><span class="hljs-number">0xFF</span></span>) == (time1 &amp; ~<span class="hljs-number"><span class="hljs-number">0xFF</span></span>)); }; <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> time1=micros(); //   <span class="hljs-comment"><span class="hljs-comment">/* cli(); //       -   */</span></span> t=<span class="hljs-number"><span class="hljs-number">10.63</span></span>; //     t=t+dt; //   <span class="hljs-comment"><span class="hljs-comment">/* sei(); //    */</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = micros(); //   time1=<span class="hljs-type"><span class="hljs-type">time</span></span>-time1; d[i]=time1/<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Serial.print(time1); //      Serial.flush(); //     Delay(20); //    */</span></span> }; //   ,     <span class="hljs-type"><span class="hljs-type">float</span></span> sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">170</span></span>; ++i) { sum+=d[i]; <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println(d[i]); }; <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println((sum/<span class="hljs-number"><span class="hljs-number">170</span></span><span class="hljs-number"><span class="hljs-number">-2.11</span></span>)*<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">16</span></span>); //<span class="hljs-number"><span class="hljs-number">2.11</span></span> –     <span class="hljs-type"><span class="hljs-type">Serial</span></span>.flush(); //    ,     }</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426941/">https://habr.com/ru/post/id426941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426931/index.html">Cara pergi bekerja di Cote d'Azur dan mendapatkan paspor Prancis dalam 3 tahun</a></li>
<li><a href="../id426933/index.html">Desain frontend</a></li>
<li><a href="../id426935/index.html">+10 aturan kode bersih dari pengembang Angular</a></li>
<li><a href="../id426937/index.html">Anggota tubuh bionik belajar membuka bir</a></li>
<li><a href="../id426939/index.html">Mahasiswa pascasarjana menyelesaikan masalah mengkonfirmasikan komputasi kuantum</a></li>
<li><a href="../id426943/index.html">Terjemahan Rusia paling komprehensif dari Harvard Programming Course 2015 CS50 2015, gratis di YouTube</a></li>
<li><a href="../id426945/index.html">Apa yang saya sukai tentang Paul Allen</a></li>
<li><a href="../id426947/index.html">"Setan menarik saya untuk pergi bekerja di kantor" - 10 pertanyaan kepada programmer, edisi ke-9</a></li>
<li><a href="../id426949/index.html">Menciptakan Suara Catatan Jauh THX</a></li>
<li><a href="../id426951/index.html">Altium Designer: apa yang harus dilakukan jika suatu proyek menjadi rumit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>