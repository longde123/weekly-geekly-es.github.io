<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 🙅🏻 🕺🏽 Jogo de ferrugem 24 horas: experiência em desenvolvimento pessoal 🤰🏿 🛠️ 🚈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre minha experiência pessoal no desenvolvimento de um pequeno jogo no Rust. Demorou cerca de 24 horas para criar uma versão f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jogo de ferrugem 24 horas: experiência em desenvolvimento pessoal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/444364/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/019/753/9bf/0197539bf7364b198561856cd6dfd961.png" alt="imagem"></div><br>  Neste artigo, falarei sobre minha experiência pessoal no desenvolvimento de um pequeno jogo no Rust.  Demorou cerca de 24 horas para criar uma versão funcional (trabalhei principalmente à noite ou nos fins de semana).  O jogo está longe de terminar, mas acho que a experiência será útil.  Vou contar o que aprendi e algumas das observações feitas ao criar o jogo do zero. <br><a name="habracut"></a><br><blockquote>  <b>A Skillbox recomenda:</b> Curso prático de dois anos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Eu sou um desenvolvedor Web PRO"</a> . <br><br>  <b>Lembramos que:</b> <i>para todos os leitores de "Habr" - um desconto de 10.000 rublos ao se inscrever em qualquer curso Skillbox usando o código promocional "Habr".</i> </blockquote><br><h3>  Por que ferrugem? </h3><br>  Eu escolhi esse idioma porque ouvi muitas coisas boas sobre ele e vejo que ele está se tornando cada vez mais popular no campo do desenvolvimento de jogos.  Antes de escrever o jogo, eu tinha pouca experiência no desenvolvimento de aplicativos simples no Rust.  Isso foi o suficiente para sentir uma certa liberdade enquanto escrevia o jogo. <br><br><h3>  Por que exatamente o jogo e que tipo de jogo? </h3><br>  Fazer jogos é divertido!  Gostaria por mais razões, mas para projetos de “casa” escolho tópicos que não estão muito relacionados ao meu trabalho habitual.  Que tipo de jogo?  Eu queria criar algo como um simulador de tênis, que combina Cities Skylines, Zoo Tycoon, Prison Architect e o próprio tênis.  Em geral, acabou um jogo sobre uma academia de tênis, onde as pessoas vêm jogar. <br><br><h3>  Treinamento técnico </h3><br>  Eu queria usar o Rust, mas não sabia exatamente como "do zero" eu precisaria começar.  Como não queria escrever pixel shaders e usar o recurso de arrastar e soltar, estava procurando as soluções mais flexíveis. <br><br>  Encontrei recursos úteis que eu compartilho com você: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ainda estamos em jogo</a> - uma lista de elementos Rust necessários para o desenvolvimento do jogo; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust game dev subreddit;</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pixel art grátis.</a> </li></ul><br>  Eu explorei vários mecanismos de jogo Rust, eventualmente escolhendo Piston e ggez.  Me deparei com eles ao trabalhar em um projeto anterior.  No final, escolhi o ggez, porque parecia mais adequado para a implementação de um pequeno jogo 2D.  A estrutura modular do Piston é muito complexa para um desenvolvedor iniciante (ou alguém que trabalhe com o Rust pela primeira vez). <br><br><h3>  Estrutura do jogo </h3><br>  Passei um pouco de tempo pensando na arquitetura do projeto.  O primeiro passo é fazer a "terra", pessoas e quadras de tênis.  As pessoas devem se movimentar pelos tribunais e esperar.  Os jogadores devem ter habilidades que melhoram com o tempo.  Além disso, deve haver um editor que permita adicionar novas pessoas e tribunais, mas isso não é mais gratuito. <br><br>  Pensando em tudo, comecei a trabalhar. <br><br><h3>  Criação de jogos </h3><br>  <b>Início: Círculos e Abstrações</b> <br><br>  Peguei um exemplo de ggez e fiz um círculo na tela.  Incrível  Agora algumas abstrações.  Pareceu-me que é bom ignorar a ideia de um objeto de jogo.  Cada objeto deve ser renderizado e atualizado conforme indicado aqui: <br><br><pre><code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the game object trait trait GameObject { fn update(&amp;mut self, _ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt;; fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt;; } // a specific game object - Circle struct Circle { position: Point2, } impl Circle { fn new(position: Point2) -&gt; Circle { Circle { position } } } impl GameObject for Circle { fn update(&amp;mut self, _ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt; { Ok(()) } fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt; { let circle = graphics::Mesh::new_circle(ctx, graphics::DrawMode::Fill, self.position, 100.0, 2.0)?; graphics::draw(ctx, &amp;circle, na::Point2::new(0.0, 0.0), 0.0)?; Ok(()) } }</span></span></code> </pre> <br>  Esse pedaço de código me permitiu obter uma excelente lista de objetos que eu posso atualizar e renderizar em um loop igualmente excelente. <br><br><pre> <code class="rust hljs">mpl event::EventHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MainState { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Context) -&gt; GameResult&lt;()&gt; { <span class="hljs-comment"><span class="hljs-comment">// Update all objects for object in self.objects.iter_mut() { object.update(context)?; } Ok(()) } fn draw(&amp;mut self, context: &amp;mut Context) -&gt; GameResult&lt;()&gt; { graphics::clear(context); // Draw all objects for object in self.objects.iter_mut() { object.draw(context)?; } graphics::present(context); Ok(()) } }</span></span></code> </pre> <br>  main.rs é necessário porque contém todas as linhas de código.  Passei um pouco de tempo para separar os arquivos e otimizar a estrutura de diretórios.  Aqui está como tudo começou a cuidar disso: <br><br>  <i>recursos -&gt; é aqui que estão todos os ativos (imagens)</i> <i><br></i>  <i>src</i> <i><br></i>  <i>- entidades</i> <i><br></i>  <i>- game_object.rs</i> <i><br></i>  <i>- circle.rs</i> <i><br></i>  <i>- main.rs -&gt; loop principal</i> <br><br>  <b>Pessoas, pisos e imagens</b> <br><br>  O próximo passo é criar um objeto de jogo Person e carregar imagens.  Tudo deve ser baseado em azulejos de tamanho 32 * 32. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/642/4c6/65c/6424c665cb9442c5471a49d987954880.png"><br><br>  <b>Quadras de tênis</b> <br><br>  Tendo estudado a aparência das quadras de tênis, decidi fazê-las com 4 * 2 peças.  Inicialmente, era possível criar uma imagem desse tamanho ou montar 8 peças separadas.  Mas então eu percebi que apenas duas peças únicas são necessárias, e é por isso. <br><br>  No total, temos dois desses ladrilhos: 1 e 2. <br><br>  Cada seção da quadra consiste no ladrilho 1 ou no ladrilho 2. Eles podem ser organizados como de costume ou ser virados de cabeça para baixo em 180 graus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26d/de1/e6f/26dde1e6f7ec2459c89752754a048c04.png"><br><br>  <b>O principal modo de construção (montagem)</b> <br><br>  Depois que consegui obter a renderização de sites, pessoas e mapas, percebi que também era necessário um modo básico de compilação.  Foi implementado assim: quando o botão é pressionado, o objeto é selecionado e o clique o coloca no lugar certo.  Portanto, o botão 1 permite selecionar uma quadra e o botão 2 permite selecionar um jogador. <br><br>  Mas você ainda precisa se lembrar do que queremos dizer 1 e 2, então adicionei um wireframe para deixar claro qual objeto está selecionado.  Aqui está como fica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/63d/e17/e9663de17e6b402f43cab61e3905c874.gif"></div><br>  <b>Perguntas sobre arquitetura e refatoração</b> <br><br>  Agora eu tenho vários objetos de jogo: pessoas, quadras e pisos.  Mas, para que os wireframes funcionem, você precisa informar a cada entidade do objeto se os objetos estão no modo de demonstração ou se um quadro é simplesmente desenhado.  Isso não é muito conveniente. <br><br>  Pareceu-me que eu precisava repensar a arquitetura para que algumas limitações fossem reveladas: <br><br><ul><li>  a presença de uma entidade que se exibe e se atualiza é um problema, porque essa entidade não poderá "saber" o que deve renderizar - uma imagem e uma estrutura de arame; </li><li>  falta de uma ferramenta para trocar propriedades e comportamento entre entidades individuais (por exemplo, a propriedade is_build_mode ou o comportamento de renderização).  A herança poderia ser usada, embora não exista uma maneira normal de implementá-la no Rust.  O que eu realmente precisava era do layout; </li><li>  era necessária uma ferramenta para a interação de entidades entre si para designar pessoas para os tribunais; </li><li>  as próprias entidades eram uma mistura de dados e lógica, que rapidamente saíram do controle. </li></ul><br><blockquote>  <i>Fiz algumas pesquisas e descobri a arquitetura do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ECS - Entity Component System</a> , que é comumente usada em jogos.</i>  <i>Aqui estão os benefícios do ECS:</i> <i><br><br></i> <ul><li>  os dados são separados da lógica; </li><li>  layout em vez de herança; </li><li>  arquitetura orientada a dados. </li></ul></blockquote><br>  O ECS é caracterizado por três conceitos básicos: <br><br><ul><li>  entidades - o tipo de objeto ao qual o identificador se refere (pode ser um jogador, uma bola ou outra coisa); </li><li>  componentes - entidades consistem deles.  Um exemplo é um componente de renderização, layout e outros.  É um armazém de dados; </li><li>  sistemas - eles usam objetos e componentes, além de conterem comportamento e lógica baseados nesses dados.  Um exemplo é um sistema de renderização que itera sobre todas as entidades com componentes para renderização e está envolvido na renderização. </li></ul><br>  Depois de estudar, ficou claro que o ECS resolve esses problemas: <br><br><ul><li>  usar layout em vez de herança para organização do sistema de entidades; </li><li>  livrar-se de um hash de código devido a sistemas de controle; </li><li>  usando métodos como is_build_mode para armazenar a lógica do wireframe no mesmo local - no sistema de renderização. </li></ul><br>  Aqui está o que aconteceu após a implementação do ECS. <br><br>  <i>recursos -&gt; é aqui que estão todos os ativos (imagens)</i> <i><br></i>  <i>src</i> <i><br></i>  <i>- componentes</i> <i><br></i>  <i>- position.rs</i> <i><br></i>  <i>- person.rs</i> <i><br></i>  <i>- tennis_court.rs</i> <i><br></i>  <i>- floor.rs</i> <i><br></i>  <i>- wireframe.rs</i> <i><br></i>  <i>- mouse_tracked.rs</i> <i><br></i>  <i>- recursos</i> <i><br></i>  <i>- mouse.rs</i> <i><br></i>  <i>- sistemas</i> <i><br></i>  <i>- rendering.rs</i> <i><br></i>  <i>- constants.rs</i> <i><br></i>  <i>- utils.rs</i> <i><br></i>  <i>- world_factory.rs -&gt; funções da fábrica mundial</i> <i><br></i>  <i>- main.rs -&gt; loop principal</i> <br><br><h3>  Designar pessoas para os tribunais </h3><br>  O ECS tornou a vida mais fácil.  Agora eu tinha uma maneira sistemática de adicionar dados a entidades e adicionar lógica com base nesses dados.  E isso, por sua vez, tornou possível organizar a distribuição de pessoas por tribunal. <br><br>  O que eu fiz: <br><br><ul><li>  dados adicionados sobre os tribunais designados à Pessoa; </li><li>  dados adicionados sobre pessoas distribuídas ao TennisCourt; </li><li>  adicionado CourtChoosingSystem, que permite analisar pessoas e sites, encontrar tribunais disponíveis e distribuir jogadores para eles; </li><li>  adicionou o sistema PersonMovementSystem, que procura pessoas designadas para os tribunais e, se não estiverem lá, envia pessoas quando necessário. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c8e/c95/7b0c8ec951007ad4d5895716c3ca7618.gif"></div><br><h3>  Resumir </h3><br>  Eu realmente gostei de trabalhar neste jogo simples.  Além disso, estou satisfeito por ter usado o Rust para escrevê-lo, porque: <br><br><ul><li>  A ferrugem dá o que você precisa; </li><li>  ele tem excelente documentação, Rust é muito elegante; </li><li>  constância é legal; </li><li>  Você não precisa recorrer à clonagem, cópia ou outras ações semelhantes, como costumava fazer em C ++; </li><li>  As opções são muito convenientes para o trabalho, elas também lidam perfeitamente com os erros; </li><li>  se o projeto puder ser compilado, em 99% ele funcionará e exatamente como deveria.  As mensagens de erro do compilador, ao que me parece, são as melhores que eu já vi. </li></ul><br>  O desenvolvimento de jogos no Rust está apenas começando.  Mas já existe uma comunidade estável e razoavelmente grande trabalhando para abrir o Rust para todos.  Portanto, olho para o futuro da linguagem com otimismo, ansioso pelos resultados de nosso trabalho comum. <br><br><blockquote>  <b>A Skillbox recomenda:</b> <br><br><ul><li>  Curso on-line <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Profissão frontend-developer"</a> . </li><li>  Curso prático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Mobile Developer PRO"</a> . </li><li>  Curso anual prático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"PHP-developer from 0 to PRO"</a> . </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444364/">https://habr.com/ru/post/pt444364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444352/index.html">Kontur.Kampus: convidamos você para um campo de estudantes de desenvolvimento industrial gratuito perto de São Petersburgo</a></li>
<li><a href="../pt444356/index.html">Tutorial Reagir Parte 24: Segunda lição sobre formulários</a></li>
<li><a href="../pt444358/index.html">Enumerável: como gerar um valor comercial</a></li>
<li><a href="../pt444360/index.html">Injustiça Google Play como uma boa experiência de vida</a></li>
<li><a href="../pt444362/index.html">Unity e Havok trabalham em um novo mecanismo de física</a></li>
<li><a href="../pt444366/index.html">Seminário "Requisitos de segurança da informação: como as empresas podem conviver com eles"</a></li>
<li><a href="../pt444368/index.html">Acabamos de imprimir o microfone em uma impressora 3D em laboratório - e depois haverá ficção científica completa em geral</a></li>
<li><a href="../pt444370/index.html">Do que o formato Mini PCI-e é capaz?</a></li>
<li><a href="../pt444372/index.html">Orientação à máquina a longa distância usando aprendizado reforçado</a></li>
<li><a href="../pt444374/index.html">Efeito hipster: por que os não-conformistas costumam ter a mesma aparência</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>