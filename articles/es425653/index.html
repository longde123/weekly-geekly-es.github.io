<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèª üëÆ üññüèΩ Construyendo una arquitectura de microservicios en Golang y gRPC, Parte 1 üì≥ üöú üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducci√≥n a la arquitectura de microservicios 
 Parte 1 de 10 


 Adaptaci√≥n de los art√≠culos de Ewan Valentine. 


 Esta es una serie de diez part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construyendo una arquitectura de microservicios en Golang y gRPC, Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425653/"><h2 id="vvedenie-v-mikroservisnuyu-arhitekturu">  Introducci√≥n a la arquitectura de microservicios </h2><br><h4 id="chast-1-iz-10">  Parte 1 de 10 </h4><br><p>  Adaptaci√≥n de los art√≠culos de Ewan Valentine. </p><br><p>  Esta es una serie de diez partes, intentar√© escribir sobre la creaci√≥n de microservicios en Golang una vez al mes.  Usar√© protobuf y gRPC como protocolo principal de transporte. </p><br><p>  La pila que utilic√©: golang, mongodb, grpc, docker, Google Cloud, Kubernetes, NATS, CircleCI, Terraform y go-micro. </p><br><p>  ¬øPor qu√© necesito esto?  Como me llev√≥ mucho tiempo resolverlo y resolver los problemas acumulados.  Tambi√©n quer√≠a compartir con ustedes lo que aprend√≠ sobre la creaci√≥n, prueba e implementaci√≥n de microservicios en Go y otras nuevas tecnolog√≠as. </p><br><p>  En esta parte, quiero mostrar los conceptos b√°sicos y las tecnolog√≠as para construir microservicios.  Escribamos una implementaci√≥n simple.  El proyecto tendr√° las siguientes entidades: </p><br><ul><li>  carga </li><li>  inventario </li><li>  juicio </li><li>  los usuarios </li><li>  los roles </li><li>  autenticaci√≥n </li></ul><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rw/x9/gb/rwx9gbtjbpn9m44olxapvk2ecgq.jpeg"><br><p>  Para ir m√°s all√°, debe instalar Golang y las bibliotecas necesarias, as√≠ como crear un repositorio git. </p><br><h2 id="teoriya">  Teor√≠a </h2><br><h4 id="chto-takoe-mikroservisnaya-arhitektura">  ¬øQu√© es la arquitectura de microservicios? </h4><br><p>  Los microservicios a√≠slan una funcionalidad separada en un servicio, autosuficiente en t√©rminos de la funci√≥n realizada por este servicio.  Por compatibilidad con otros servicios, tiene una interfaz bien conocida y predefinida. <br>  Los microservicios se comunican entre s√≠ mediante mensajes transmitidos a trav√©s de alg√∫n intermediario, intermediario de mensajes. </p><br><img src="https://habrastorage.org/webt/tr/aq/dm/traqdmhafa_yvh0haprr05w7rgo.png"><br><p>  Gracias a la arquitectura de microservicios, la aplicaci√≥n no se puede escalar en su totalidad, sino en partes.  Por ejemplo, si el servicio de autorizaci√≥n "se contrae" con m√°s frecuencia que otros, podemos aumentar el n√∫mero de instancias.  Este concepto est√° en l√≠nea con los conceptos de computaci√≥n en la nube y contenedorizaci√≥n en general. </p><br><h4 id="pochemu-golang">  Por que golang </h4><br><p>  Los microservicios son compatibles en casi todos los idiomas, despu√©s de todo, los microservicios son un concepto, no una estructura o herramienta espec√≠fica.  Sin embargo, algunos idiomas son m√°s adecuados y, adem√°s, tienen un mejor soporte para microservicios que otros.  Un idioma con gran soporte es Golang. </p><br><h4 id="poznakomimsya-s-protobufgrpc">  Conoce a protobuf / gRPC </h4><br><p>  Como se mencion√≥ anteriormente, los microservicios se dividen en bases de c√≥digo separadas, uno de los problemas importantes asociados con los microservicios es la comunicaci√≥n.  Si tiene un monolito, simplemente puede llamar al c√≥digo directamente desde otro lugar de su programa. </p><br><p>  Para resolver el problema de comunicaci√≥n, podemos usar el enfoque REST tradicional y transferir datos en formato JSON o XML a trav√©s de HTTP.  Pero este enfoque tiene sus inconvenientes, por ejemplo, que antes de enviar un mensaje debe codificar sus datos y descodificarlos en el lado receptor.  Y esto es una sobrecarga y aumenta la complejidad del c√≥digo. </p><br><p>  ¬°Hay una soluci√≥n!  Este es el protocolo <strong>gRPC</strong> : un protocolo liviano basado en binarios que elimina la transmisi√≥n de encabezados HTTP, y esto nos ahorrar√° algunos bytes.  El futuro HTTP2 tambi√©n implica el uso de datos binarios, que nuevamente hablan a favor de gRPC.  HTTP2 permite la comunicaci√≥n bidireccional, ¬°y es incre√≠ble! </p><br><p>  GRPC tambi√©n le permite definir la interfaz de su servicio en un formato amigable: esto es&gt; <strong>protobuf</strong> . </p><br><h2 id="praktika">  Practica </h2><br><p>  Cree el archivo /project/consigment.proto. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n oficial de protobuf</a> </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre><code class="plaintext hljs">//consigment.proto syntax = "proto3"; package go.micro.srv.consignment; service ShippingService { rpc CreateConsignment(Consignment) returns (Response) {} } message Consignment { string id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { string id = 1; string customer_id = 2; string origin = 3; string user_id = 4; } message Response { bool created = 1; Consignment consignment = 2; }</code> </pre> </div></div><br><p>  Este es un ejemplo simple que contiene el servicio que desea proporcionar a otros servicios: servicio ShippingService, luego definiremos nuestros mensajes.  Protobuf es un protocolo de tipo est√°tico, y podemos crear tipos personalizados (similares a las estructuras en golang).  Aqu√≠ el contenedor est√° anidado en el lote. </p><br><p>  Instale las bibliotecas, el compilador y compile nuestro protocolo: </p><br><pre> <code class="bash hljs">$ go get -u google.golang.org/grpc $ go get -u github.com/golang/protobuf/protoc-gen-go $ sudo apt install protobuf-compiler $ mkdir consignment &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> consignment $ protoc -I=. --go_out=plugins=grpc:. consignment.proto</code> </pre> <br><p>  El resultado debe ser un archivo: </p><br><div class="spoiler">  <b class="spoiler_title">consignment.pb.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by protoc-gen-go. DO NOT EDIT. // source: consignment.proto package consignment import ( fmt "fmt" proto "github.com/golang/protobuf/proto" context "golang.org/x/net/context" grpc "google.golang.org/grpc" math "math" ) // Reference imports to suppress errors if they are not otherwise used. var _ = proto.Marshal var _ = fmt.Errorf var _ = math.Inf // This is a compile-time assertion to ensure that this generated file // is compatible with the proto package it is being compiled against. // A compilation error at this line likely means your copy of the // proto package needs to be updated. const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package type Consignment struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"` Weight int32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"` Containers []*Container `protobuf:"bytes,4,rep,name=containers,proto3" json:"containers,omitempty"` VesselId string `protobuf:"bytes,5,opt,name=vessel_id,json=vesselId,proto3" json:"vessel_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Consignment) Reset() { *m = Consignment{} } func (m *Consignment) String() string { return proto.CompactTextString(m) } func (*Consignment) ProtoMessage() {} func (*Consignment) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{0} } func (m *Consignment) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Consignment.Unmarshal(m, b) } func (m *Consignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Consignment.Marshal(b, m, deterministic) } func (m *Consignment) XXX_Merge(src proto.Message) { xxx_messageInfo_Consignment.Merge(m, src) } func (m *Consignment) XXX_Size() int { return xxx_messageInfo_Consignment.Size(m) } func (m *Consignment) XXX_DiscardUnknown() { xxx_messageInfo_Consignment.DiscardUnknown(m) } var xxx_messageInfo_Consignment proto.InternalMessageInfo func (m *Consignment) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Consignment) GetDescription() string { if m != nil { return m.Description } return "" } func (m *Consignment) GetWeight() int32 { if m != nil { return m.Weight } return 0 } func (m *Consignment) GetContainers() []*Container { if m != nil { return m.Containers } return nil } func (m *Consignment) GetVesselId() string { if m != nil { return m.VesselId } return "" } type Container struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"` Origin string `protobuf:"bytes,3,opt,name=origin,proto3" json:"origin,omitempty"` UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Container) Reset() { *m = Container{} } func (m *Container) String() string { return proto.CompactTextString(m) } func (*Container) ProtoMessage() {} func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{1} } func (m *Container) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Container.Unmarshal(m, b) } func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Container.Marshal(b, m, deterministic) } func (m *Container) XXX_Merge(src proto.Message) { xxx_messageInfo_Container.Merge(m, src) } func (m *Container) XXX_Size() int { return xxx_messageInfo_Container.Size(m) } func (m *Container) XXX_DiscardUnknown() { xxx_messageInfo_Container.DiscardUnknown(m) } var xxx_messageInfo_Container proto.InternalMessageInfo func (m *Container) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Container) GetCustomerId() string { if m != nil { return m.CustomerId } return "" } func (m *Container) GetOrigin() string { if m != nil { return m.Origin } return "" } func (m *Container) GetUserId() string { if m != nil { return m.UserId } return "" } type Response struct { Created bool `protobuf:"varint,1,opt,name=created,proto3" json:"created,omitempty"` Consignment *Consignment `protobuf:"bytes,2,opt,name=consignment,proto3" json:"consignment,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Response) Reset() { *m = Response{} } func (m *Response) String() string { return proto.CompactTextString(m) } func (*Response) ProtoMessage() {} func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{2} } func (m *Response) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Response.Unmarshal(m, b) } func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Response.Marshal(b, m, deterministic) } func (m *Response) XXX_Merge(src proto.Message) { xxx_messageInfo_Response.Merge(m, src) } func (m *Response) XXX_Size() int { return xxx_messageInfo_Response.Size(m) } func (m *Response) XXX_DiscardUnknown() { xxx_messageInfo_Response.DiscardUnknown(m) } var xxx_messageInfo_Response proto.InternalMessageInfo func (m *Response) GetCreated() bool { if m != nil { return m.Created } return false } func (m *Response) GetConsignment() *Consignment { if m != nil { return m.Consignment } return nil } func init() { proto.RegisterType((*Consignment)(nil), "Consignment") proto.RegisterType((*Container)(nil), "Container") proto.RegisterType((*Response)(nil), "Response") } func init() { proto.RegisterFile("consignment.proto", fileDescriptor_3804bf87090b51a9) } var fileDescriptor_3804bf87090b51a9 = []byte{ // 281 bytes of a gzipped FileDescriptorProto 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xbf, 0x4e, 0x33, 0x31, 0x10, 0xc4, 0xbf, 0xcb, 0xff, 0x5b, 0x7f, 0x02, 0xc5, 0x05, 0x58, 0x50, 0x70, 0xba, 0x2a, 0xa2, 0x70, 0x11, 0x9e, 0x00, 0xa5, 0x4a, 0xeb, 0xd0, 0xa3, 0x60, 0xaf, 0x2e, 0x2b, 0x11, 0xfb, 0x64, 0x3b, 0xe1, 0x75, 0x78, 0x54, 0x74, 0xbe, 0x1c, 0x18, 0x51, 0xce, 0xac, 0x67, 0xf7, 0xa7, 0x31, 0x2c, 0xb5, 0xb3, 0x81, 0x1a, 0x7b, 0x44, 0x1b, 0x65, 0xeb, 0x5d, 0x74, 0xf5, 0x67, 0x01, 0x6c, 0xf3, 0xe3, 0xf2, 0x2b, 0x18, 0x91, 0x11, 0x45, 0x55, 0xac, 0xa6, 0x6a, 0x44, 0x86, 0x57, 0xc0, 0x0c, 0x06, 0xed, 0xa9, 0x8d, 0xe4, 0xac, 0x18, 0x55, 0xc5, 0xaa, 0x54, 0xb9, 0xc5, 0x6f, 0x60, 0xf6, 0x81, 0xd4, 0x1c, 0xa2, 0x18, 0xa7, 0xd4, 0x45, 0xf1, 0x47, 0x00, 0xed, 0x6c, 0xdc, 0x93, 0x45, 0x1f, 0xc4, 0xa4, 0x1a, 0xaf, 0xd8, 0x1a, 0xe4, 0x66, 0xb0, 0x54, 0x36, 0xe5, 0xf7, 0x50, 0x9e, 0x31, 0x04, 0x7c, 0x7f, 0x25, 0x23, 0xa6, 0xe9, 0xc6, 0xa2, 0x37, 0xb6, 0xa6, 0x3e, 0x42, 0xf9, 0x9d, 0xfa, 0xc3, 0xf7, 0x00, 0x4c, 0x9f, 0x42, 0x74, 0x47, 0xf4, 0x5d, 0xb6, 0xe7, 0x83, 0xc1, 0xda, 0x9a, 0x0e, 0xcf, 0x79, 0x6a, 0xc8, 0x26, 0xbc, 0x52, 0x5d, 0x14, 0xbf, 0x85, 0xf9, 0x29, 0xf4, 0xa1, 0x49, 0x3f, 0xe8, 0xe4, 0xd6, 0xd4, 0x2f, 0xb0, 0x50, 0x18, 0x5a, 0x67, 0x03, 0x72, 0x01, 0x73, 0xed, 0x71, 0x1f, 0xb1, 0x3f, 0xb9, 0x50, 0x83, 0xe4, 0x12, 0x58, 0x56, 0x66, 0xba, 0xcb, 0xd6, 0xff, 0x65, 0x56, 0xa5, 0xca, 0x1f, 0xac, 0x9f, 0xe1, 0x7a, 0x77, 0xa0, 0xb6, 0x25, 0xdb, 0xec, 0xd0, 0x9f, 0x49, 0x23, 0x97, 0xb0, 0xdc, 0xa4, 0x6d, 0x79, 0xff, 0xbf, 0x56, 0xdc, 0x95, 0x72, 0x40, 0xa9, 0xff, 0xbd, 0xcd, 0xd2, 0x8f, 0x3d, 0x7d, 0x05, 0x00, 0x00, 0xff, 0xff, 0x84, 0x5c, 0xa4, 0x06, 0xc6, 0x01, 0x00, 0x00, } // Reference imports to suppress errors if they are not otherwise used. var _ context.Context var _ grpc.ClientConn // This is a compile-time assertion to ensure that this generated file // is compatible with the grpc package it is being compiled against. const _ = grpc.SupportPackageIsVersion4 // ShippingServiceClient is the client API for ShippingService service. // // For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream. type ShippingServiceClient interface { CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) } type shippingServiceClient struct { cc *grpc.ClientConn } func NewShippingServiceClient(cc *grpc.ClientConn) ShippingServiceClient { return &amp;shippingServiceClient{cc} } func (c *shippingServiceClient) CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) { out := new(Response) err := c.cc.Invoke(ctx, "/ShippingService/CreateConsignment", in, out, opts...) if err != nil { return nil, err } return out, nil } // ShippingServiceServer is the server API for ShippingService service. type ShippingServiceServer interface { CreateConsignment(context.Context, *Consignment) (*Response, error) } func RegisterShippingServiceServer(s *grpc.Server, srv ShippingServiceServer) { s.RegisterService(&amp;_ShippingService_serviceDesc, srv) } func _ShippingService_CreateConsignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(Consignment) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(ShippingServiceServer).CreateConsignment(ctx, in) } info := &amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: "/ShippingService/CreateConsignment", } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(ShippingServiceServer).CreateConsignment(ctx, req.(*Consignment)) } return interceptor(ctx, in, info, handler) } var _ShippingService_serviceDesc = grpc.ServiceDesc{ ServiceName: "ShippingService", HandlerType: (*ShippingServiceServer)(nil), Methods: []grpc.MethodDesc{ { MethodName: "CreateConsignment", Handler: _ShippingService_CreateConsignment_Handler, }, }, Streams: []grpc.StreamDesc{}, Metadata: "consignment.proto", }</span></span></code> </pre> <br><p>  Si, entonces algo sali√≥ mal.  Preste atenci√≥n a los argumentos -I es la ruta donde el compilador est√° buscando archivos, --go_out donde se crear√° un nuevo archivo.  Siempre hay ayuda </p><br><pre> <code class="bash hljs">$ protoc -h</code> </pre> </div></div><br><p>  Este es el c√≥digo generado autom√°ticamente por las bibliotecas gRPC / protobuf para que pueda asociar su definici√≥n de protobuf con su propio c√≥digo. </p><br><h4 id="napishem-maingo">  Escribiremos main.go </h4><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> seaport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    pbf "seaport/consignment" "golang.org/x/net/context" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ) const ( port = ":50051" ) //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) } // Repository -    , //        type Repository struct { consignments []*pbf.Consignment } //Create -    func (repo *Repository) Create(consignment *pbf.Consignment) (*pbf.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } //         //       .     //         . . type service struct { repo IRepository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pbf.Consignment) (*pbf.Response, error) { //      consignment, err := s.repo.Create(req) if err != nil { return nil, err } //   `Response`, //        return &amp;pbf.Response{Created: true, Consignment: consignment}, nil } func main() { repo := &amp;Repository{} //   gRPC    tcp lis, err := net.Listen("tcp", port) if err != nil { log.Fatalf("failed to listen: %v", err) } s := grpc.NewServer() //      gRPC,    //        //  `Response`,       pbf.RegisterShippingServiceServer(s, &amp;service{repo}) //      gRPC. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } }</span></span></code> </pre> </div></div><br><p>  Lea atentamente los comentarios que quedan en el c√≥digo.  Aparentemente, aqu√≠ estamos creando una l√≥gica de implementaci√≥n en la cual nuestros m√©todos gRPC interact√∫an usando los formatos generados, creando un nuevo servidor gRPC en el puerto 50051. Ahora nuestro servicio gRPC vivir√° all√≠. <br>  Puede ejecutar esto con <strong>$ go run main.go</strong> , pero no ver√° nada y no podr√° usarlo ... Entonces, <strong>creemos</strong> un cliente para verlo en acci√≥n. </p><br><p>  Creemos una interfaz de l√≠nea de comando que tome un archivo JSON e interact√∫e con nuestro servicio gRPC. </p><br><p>  En el directorio ra√≠z, cree un nuevo subdirectorio de <strong>$ mkdir consignment-cli</strong> .  En este directorio, cree un archivo cli.go con los siguientes contenidos: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) }</span></span></code> </pre> </div></div><br><p>  Ahora cree un lote (consignment-cli / consignment.json): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"vessel_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span> }</code> </pre> <br><p>  Ahora, si ejecuta <strong>$ go, ejecute main.go</strong> desde el paquete de <strong>puerto</strong> y luego ejecute <strong>$ go, ejecute cli.go</strong> en un panel de terminales separado.  Deber√≠a ver el mensaje "Creado: verdadero". <br>  Pero, ¬øc√≥mo podemos verificar qu√© se cre√≥ exactamente?  Actualicemos nuestro servicio utilizando el m√©todo GetConsignments para que podamos ver todos nuestros lotes creados. </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//consigment.proto syntax = "proto3"; service ShippingService{ rpc CreateConsignment(Consignment) returns (Response) {} //    rpc GetConsignments(GetRequest) returns (Response) {} } message Consignment { int32 id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { int32 id =1; string customer_id =2; string origin = 3; string user_id = 4; } //    message GetRequest {} message Response { bool created = 1; Consignment consignment = 2; //     //     repeated Consignment consignments = 3; }</span></span></code> </pre> </div></div><br><p>  Entonces, aqu√≠ creamos un nuevo m√©todo en nuestro servicio llamado <strong>GetConsignments</strong> , tambi√©n creamos un nuevo <strong>GetRequest</strong> , que a√∫n no contiene nada.  Tambi√©n agregamos un campo de lotes enviados a nuestro mensaje de respuesta.  Notar√° que el tipo aqu√≠ tiene la palabra clave repetida hasta el tipo.  Esto, como probablemente haya adivinado, simplemente significa tratar este campo como una matriz de estos tipos. </p><br><p>  No se apresure a ejecutar el programa, la implementaci√≥n de nuestros m√©todos gRPC se basa en hacer coincidir la interfaz creada por la biblioteca protobuf, debemos asegurarnos de que nuestra implementaci√≥n coincida con nuestra definici√≥n de proto. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//seaport/main.go //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) GetAll() []*pbf.Consignment } //GetAll -       func (repo *Repository) GetAll() []*pbf.Consignment { return repo.consignments } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pbf.GetRequest) (*pbf.Response, error) { consignments := s.repo.GetAll() return &amp;pbf.Response{Consignments: consignments}, nil }</span></span></code> </pre> <br><p>  Aqu√≠ hemos incluido nuestro nuevo m√©todo GetConsignments, actualizado nuestro repositorio e interfaz, respectivamente creados en la definici√≥n consignments.proto.  Si ejecuta <strong>$ go run main.go nuevamente</strong> , el programa deber√≠a funcionar nuevamente. </p><br><p>  Actualicemos nuestra herramienta cli para incluir la capacidad de llamar a este m√©todo y es posible enumerar nuestras partes: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pbf.GetRequest{}) if err != nil { log.Fatalf("    : %v", err) } for _, cns := range getAll.Consignments { fmt.Printf("Id: %v\n", cns.GetId()) fmt.Printf("Description: %v\n", cns.GetDescription()) fmt.Printf("Weight: %d\n", cns.GetWeight()) fmt.Printf("VesselId: %v\n", cns.GetVesselId()) for _, cnt := range cns.GetContainers() { fmt.Printf("\tId: %v\n", cnt.GetId()) fmt.Printf("\tUserId: %v\n", cnt.GetUserId()) fmt.Printf("\tCustomerId: %v\n", cnt.GetCustomerId()) fmt.Printf("\tOrigin: %v\n", cnt.GetOrigin()) } } }</span></span></code> </pre> </div></div><br><p>  Agregue el c√≥digo anterior a cli.go y ejecute <strong>$ go ejecute cli.go nuevamente</strong> .  El cliente ejecutar√° CreateConsignment y luego llamar√° a GetConsignments.  Y deber√≠a ver que en la lista de respuestas contiene la composici√≥n de la fiesta. </p><br><p>  Por lo tanto, tenemos el primer microservicio y cliente para interactuar con √©l usando protobuf y gRPC. </p><br><p>  La siguiente parte de esta serie incluir√° la integraci√≥n go-micro, que es una base poderosa para crear microservicios basados ‚Äã‚Äãen gRPC.  Tambi√©n crearemos nuestro segundo servicio.  Considere el trabajo de nuestros servicios en contenedores Docker, en la siguiente parte de esta serie de art√≠culos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425653/">https://habr.com/ru/post/es425653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425641/index.html">Los residentes de la ciudad canadiense han desarrollado un "servicio Uber" con autobuses, no autom√≥viles</a></li>
<li><a href="../es425643/index.html">Eventos digitales en Mosc√∫ del 8 al 14 de octubre</a></li>
<li><a href="../es425645/index.html">SpaceX y SAOCOM - 1A Nueva misi√≥n. Hecho</a></li>
<li><a href="../es425647/index.html">Prueba de IU: comprobaci√≥n del sistema a diferentes resoluciones</a></li>
<li><a href="../es425649/index.html">BDSM, Gore y la b√∫squeda del desarrollador de Drupal</a></li>
<li><a href="../es425657/index.html">La inevitabilidad del castigo, la efectividad de los controles repentinos</a></li>
<li><a href="../es425659/index.html">El dise√±o interactivo no tiene que ser complicado.</a></li>
<li><a href="../es425661/index.html">22 consejos para un desarrollador angular. Parte 1</a></li>
<li><a href="../es425663/index.html">22 consejos para un desarrollador angular. Parte 2</a></li>
<li><a href="../es425665/index.html">Git: arreglando errores y arreglando commits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>