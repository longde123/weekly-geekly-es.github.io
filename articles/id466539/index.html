<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ üì© üë®‚Äçüè≠ Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 2 ‚ÜóÔ∏è üßö üß£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian kedua dari terjemahan materi, yang dikhususkan untuk penggunaan JS-modul dalam produksi. 

  

 ‚Üí Ngomong-ngomong, in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466539/">  Hari ini kami menerbitkan bagian kedua dari terjemahan materi, yang dikhususkan untuk penggunaan JS-modul dalam produksi. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/y4/3w/bg/y43wbgvqwezj1-b0oyx882a-gne.jpeg"></a> <br><br>  ‚Üí Ngomong-ngomong, ini bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> artikel. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Impor dinamis</font> </h2><br>  Salah satu kelemahan menggunakan ekspresi impor nyata untuk memisahkan kode dan memuat modul adalah bahwa tugas bekerja dengan browser yang tidak mendukung modul ada pada pengembang. <br><br>  Dan jika Anda ingin menggunakan perintah <code>import()</code> dinamis <code>import()</code> untuk mengatur pemuatan kode malas, maka Anda, antara lain, harus berurusan dengan fakta bahwa beberapa browser, walaupun, yang paling pasti, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul dukungan</a> , masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mendukung perintah impor dinamis ()</a> (Tepi 16‚Äì18, Firefox 60‚Äì66, Safari 11, Chrome 61‚Äì63). <br><br>  Untungnya, masalah ini akan membantu kita menyelesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfill</a> kecil (sekitar 400 byte) dan sangat cepat. <br><br>  Menambahkan polyfill ini ke proyek web sangat sederhana.  Anda hanya perlu mengimpor dan menginisialisasi di titik entri utama ke aplikasi (sebelum memanggil perintah <code>import()</code> dalam kode): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dynamicImportPolyfill <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dynamic-import-polyfill'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         .   //    ,       . dynamicImportPolyfill.initialize({modulePath: '/modules/'});</span></span></code> </pre> <br>  Dan hal terakhir yang perlu dilakukan agar skema ini bekerja, adalah memberi tahu Rollup bahwa ia perlu mengganti nama perintah <code>import()</code> dinamis yang muncul dalam kode menggunakan nama yang Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pilih</a> (melalui opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">output.dynamicImportFunction</a> ).  Sebuah polyfill yang mengimplementasikan fitur impor dinamis menggunakan nama <code>__import__</code> secara default, tetapi dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikustomisasi</a> . <br><br>  Alasan Anda perlu mengganti nama <code>import()</code> adalah karena <code>import</code> adalah, dalam JavaScript, kata kunci.  Ini berarti bahwa tidak mungkin, dengan cara polyfill, untuk mengatur penggantian perintah <code>import()</code> standar <code>import()</code> dengan perintah dengan nama yang sama.  Jika Anda mencoba melakukan ini, kesalahan sintaksis akan terjadi. <br><br>  Tetapi sangat bagus bahwa Rollup mengganti nama perintah selama pembangunan proyek, karena ini berarti Anda dapat menggunakan perintah standar dalam kode sumber.  Selain itu, di masa mendatang, ketika polyfill tidak lagi diperlukan, kode sumber proyek tidak perlu ditulis ulang, mengubah untuk <code>import</code> apa yang sebelumnya disebut entah bagaimana berbeda. <br><br><h2>  <font color="#3AC1EF">Pemuatan JavaScript yang efisien</font> </h2><br>  Setiap kali Anda menggunakan pemisahan kode, tidak ada salahnya mengatur preloading semua modul yang Anda tahu akan dimuat segera (misalnya, ini semua modul di pohon dependensi dari modul utama, yang merupakan titik masuk ke proyek). <br><br>  Tetapi ketika kita memuat modul JavaScript nyata (melalui <code>&lt;script type="module"&gt;</code> dan kemudian melalui perintah <code>import</code> sesuai), kita harus menggunakan atribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modulepreload</a> alih-alih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preload yang</a> biasa, yang hanya ditujukan untuk skrip klasik. <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"modulepreload"</span></span> href=<span class="hljs-string"><span class="hljs-string">"/modules/main.XXXX.mjs"</span></span>&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-one.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-two.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-three.XXXX.mjs"&gt; &lt;!-- ... --&gt; &lt;script type="module" src="/modules/main.XXXX.mjs"&gt;&lt;/script&gt;</code> </pre> <br>  Bahkan, <code>modulepreload</code> jelas lebih baik daripada mekanisme <code>preload</code> tradisional dalam preloading modul nyata.  Faktanya adalah bahwa ketika Anda menggunakannya, bukan hanya file itu diunduh.  Selain itu, segera, di luar utas utama, mulai parsing dan kompilasi skrip.  <code>preload</code> reguler tidak dapat melakukan ini karena, selama preload, tidak tahu apakah file akan digunakan sebagai modul atau sebagai skrip biasa. <br><br>  Ini berarti bahwa memuat modul menggunakan atribut <code>modulepreload</code> seringkali lebih cepat, dan ketika modul diinisialisasi, kecil kemungkinannya untuk membuat beban berlebihan pada utas utama, yang menyebabkan masalah antarmuka. <br><br><h2>  <font color="#3AC1EF">Membuat daftar modul untuk preloading</font> </h2><br>  Fragmen input dalam objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bundel</a> Rollup berisi daftar lengkap impor di pohon dependensi statis mereka.  Akibatnya, di kait Rollup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generateBundle</a> , mudah untuk mendapatkan daftar file yang harus dimuat sebelumnya. <br><br>  Meskipun plugin dapat ditemukan di npm untuk membuat daftar modulepreload, membuat daftar yang serupa untuk setiap titik input di pohon dependensi hanya memerlukan beberapa baris kode.  Karena itu, saya lebih suka membuat daftar seperti itu secara manual, menggunakan sesuatu seperti kode ini: <br><br><pre> <code class="javascript hljs">{  generateBundle(options, bundle) {    <span class="hljs-comment"><span class="hljs-comment">//         .    const modulepreloadMap = {};    for (const [fileName, chunkInfo] of Object.entries(bundle)) {      if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) {        modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports];      }    }    //  -   ...    console.log(modulepreloadMap);  } }</span></span></code> </pre> <br>  Di sini, misalnya, adalah bagaimana saya membuat <a href="">daftar modulepreload</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">philipwalton.com</a> dan untuk <a href="">aplikasi demo</a> saya, yang akan kita bahas di bawah ini. <br><br>  Harap perhatikan bahwa meskipun atribut <code>modulepreload</code> jelas lebih baik daripada <code>preload</code> klasik untuk memuat skrip modul, ia memiliki dukungan browser terburuk (saat ini hanya Chrome yang mendukungnya).  Jika sebagian besar lalu lintas Anda tidak berasal dari Chrome, maka dalam situasi Anda mungkin masuk akal untuk menggunakan <code>preload</code> reguler alih-alih <code>preload</code> . <br><br>  Mengenai penggunaan <code>preload</code> , saya ingin memperingatkan Anda tentang sesuatu.  Faktanya adalah bahwa ketika memuat skrip menggunakan <code>preload</code> , tidak seperti <code>modulepreload</code> , skrip ini tidak masuk ke peta modul browser.  Ini berarti bahwa ada kemungkinan bahwa permintaan preload dapat dieksekusi lebih dari satu kali (misalnya, jika modul mengimpor file sebelum browser selesai melakukan preloading). <br><br><h2>  <font color="#3AC1EF">Mengapa menggunakan modul nyata dalam produksi?</font> </h2><br>  Jika Anda sudah menggunakan bundler seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpack</a> , serta jika Anda sudah menggunakan pemisahan kode dan preloading file yang sesuai (mirip dengan apa yang saya katakan), maka Anda mungkin bertanya-tanya apakah Anda harus beralih ke strategi berfokus pada penggunaan modul nyata.  Ada beberapa alasan yang membuat saya percaya bahwa Anda harus mempertimbangkan beralih ke modul.  Selain itu, saya percaya bahwa mengubah proyek menjadi modul nyata lebih baik daripada menggunakan skrip klasik dengan kode mereka sendiri yang dirancang untuk memuat modul. <br><br><h3>  <font color="#3AC1EF">‚ñç Mengurangi jumlah total kode</font> </h3><br>  Jika proyek menggunakan modul nyata, maka pengguna browser modern tidak perlu mengunduh beberapa kode tambahan yang dirancang untuk memuat modul atau untuk mengelola dependensi.  Misalnya, saat menggunakan modul nyata, Anda tidak perlu memuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mekanisme runtime dan manifes webpack</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Peningkatan kode preload</font> </h3><br>  Seperti yang disebutkan di bagian sebelumnya, menggunakan atribut <code>modulepreload</code> memungkinkan <code>modulepreload</code> untuk memuat kode dan <code>modulepreload</code> - <code>modulepreload</code> dan mengkompilasinya di luar utas utama.  Yang lainnya, dibandingkan dengan atribut <code>preload</code> , tetap sama.  Ini berarti bahwa berkat <code>modulepreload</code> halaman menjadi lebih cepat interaktif, dan yang mengurangi kemungkinan memblokir aliran utama selama interaksi pengguna. <br><br>  Akibatnya, terlepas dari ukuran apa kode aplikasi dibagi menjadi beberapa fragmen, akan jauh lebih produktif untuk mengunduh fragmen ini menggunakan perintah impor dan atribut <code>modulepreload</code> daripada memuatnya menggunakan tag <code>script</code> biasa dan atribut <code>preload</code> biasa (terutama jika tag yang sesuai dihasilkan dinamis dan ditambahkan ke DOM saat runtime). <br><br>  Dengan kata lain, bundel rollup dari beberapa kode proyek, yang terdiri dari 20 fragmen modul, akan memuat lebih cepat dari bundel proyek yang sama, terdiri dari 20 fragmen skrip klasik yang disiapkan oleh webpack (bukan karena menggunakan webpack, tetapi karena bahwa ini bukan modul nyata). <br><br><h3>  <font color="#3AC1EF">‚ñç Meningkatkan fokus kode di masa depan</font> </h3><br>  Banyak fitur baru browser yang dibangun berdasarkan modul, dan tidak didasarkan pada skrip klasik.  Ini berarti bahwa jika Anda berencana untuk menggunakan fitur-fitur ini, maka kode Anda harus disajikan dalam bentuk modul nyata.  Seharusnya bukan sesuatu yang ditranskrip dalam ES5 dan dimuat dengan cara tag <code>script</code> klasik (ini adalah masalah yang saya tulis ketika saya mencoba menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Penyimpanan KV</a> eksperimental). <br><br>  Berikut adalah beberapa fitur browser baru yang paling menarik yang berfokus secara eksklusif pada modul: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modul bawaan</a> </li><li>  <a href="">Modul HTML</a> </li><li>  <a href="">Modul CSS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modul JSON</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu impor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagi modul dengan pekerja, pekerja layanan, dan jendela dokumen</a> </li></ul><br><h2>  <font color="#3AC1EF">Dukungan Browser Legacy</font> </h2><br>  Secara global, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih dari 83% browser</a> mendukung modul JavaScript (termasuk impor dinamis), sebagai akibatnya, sebagian besar pengguna akan dapat bekerja dengan proyek yang beralih ke modul tanpa upaya khusus dari pihak pengembang proyek ini. <br><br>  Dalam hal browser yang mendukung modul tetapi tidak mendukung impor dinamis, disarankan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dynamic-import-polyfill polyfill yang</a> dijelaskan di atas.  Karena sangat kecil dan, jika mungkin, menggunakan metode <code>import()</code> berbasis browser standar, penggunaan polyfill ini hampir tidak berpengaruh pada ukuran atau kinerja proyek. <br><br>  Jika kita berbicara tentang browser yang sama sekali tidak mendukung modul, maka, untuk mengatur pekerjaan dengan mereka, Anda dapat menggunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul / nomodule</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Contoh pengoperasian</font> </h3><br>  Karena selalu lebih mudah untuk berbicara tentang kompatibilitas lintas-browser daripada mencapainya, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi demo</a> yang menggunakan teknologi yang dibahas di atas. <br><br>  Aplikasi ini berfungsi di peramban seperti Edge 18 dan Firefox ESR, yang tidak mendukung perintah <code>import()</code> dinamis <code>import()</code> .  Selain itu, ini berfungsi di browser seperti Internet Explorer 11, yang tidak mendukung modul. <br><br>  Untuk menunjukkan bahwa strategi yang dibahas di sini tidak hanya cocok untuk proyek-proyek sederhana, saya menggunakan banyak fitur dalam aplikasi ini yang dibutuhkan saat ini dalam proyek-proyek besar: <br><br><ul><li>  Transformasi kode menggunakan Babel (termasuk JSX). </li><li>  Ketergantungan umumJS (mis. Bereaksi dan bereaksi). </li><li>  Dependensi CSS. </li><li>  Hashing Sumber Daya </li><li>  Pemisahan kode </li><li>  Impor dinamis (dengan fallback sebagai polyfill). </li><li>  Implementasi pola modul / nomodule. </li></ul><br>  Kode proyek dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> (yaitu, Anda dapat melakukan fork repositori dan membangun proyek sendiri), versi demo dihosting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Glitch</a> , yang memungkinkan Anda untuk bereksperimen dengannya. <br><br>  Hal terpenting dalam proyek demo adalah <a href="">konfigurasi Rollup</a> , karena menentukan bagaimana modul yang dihasilkan dibuat. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Saya harap materi ini meyakinkan Anda tidak hanya tentang kemungkinan penerapan modul JavaScript standar dalam produksi, tetapi juga bahwa itu benar-benar dapat meningkatkan waktu pemuatan situs dan kinerjanya. <br><br>  Berikut ini adalah ikhtisar singkat tentang langkah-langkah yang perlu Anda ambil untuk mengimplementasikan modul-modul dalam proyek: <br><br><ul><li>  Gunakan bundler, di antara format output yang didukung oleh modul ES2015. </li><li>  Secara agresif mendekati pemisahan kode (jika mungkin, sampai alokasi dependensi dari <code>node_modules</code> menjadi fragmen yang terpisah). </li><li>  Preload semua modul yang ada di pohon dependensi statis Anda (menggunakan <code>modulepreload</code> ). </li><li>  Gunakan polyfill untuk browser yang tidak mendukung pernyataan <code>import()</code> dinamis <code>import()</code> . </li><li>  Gunakan pola modul / nomodule untuk mengatur pekerjaan dengan browser yang tidak mendukung modul. </li></ul><br>  Jika Anda sudah menggunakan Rollup untuk membangun proyek, saya ingin Anda mencoba apa yang saya bicarakan di sini dan pergi untuk menggunakan modul nyata dalam produksi (menggunakan pemisahan kode dan teknik impor dinamis).  Jika Anda melakukannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beri tahu saya</a> bagaimana kabar Anda.  Saya tertarik mengetahui tentang masalah dan tentang kasus-kasus sukses memperkenalkan modul. <br><br>  Sangat jelas bahwa modul adalah masa depan JavaScript.  Saya ingin melihat, dan sebaiknya segera, bagaimana alat yang kami gunakan dan perpustakaan bantu mengadopsi teknologi ini.  Saya harap materi ini setidaknya dapat membantu proses ini sedikit. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan modul JS dalam produksi? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466539/">https://habr.com/ru/post/id466539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466527/index.html">Menguji fungsionalitas pengguna situs web dengan objek halaman Capybara</a></li>
<li><a href="../id466529/index.html">Jenis Kompilasi di JVM: Mengekspos Sesi Sihir Hitam</a></li>
<li><a href="../id466533/index.html">Pastilda: hasil</a></li>
<li><a href="../id466535/index.html">Memikirkan kembali deepClone</a></li>
<li><a href="../id466537/index.html">Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 1</a></li>
<li><a href="../id466541/index.html">Menggunakan DbTool untuk Menyemai Basis Data dalam Aplikasi .NET (Core)</a></li>
<li><a href="../id466543/index.html">Pinjaman Habr Weekly # 17 / Sberbank akan disetujui oleh AI - menakutkan, beriklan di produk sumber terbuka - diragukan</a></li>
<li><a href="../id466547/index.html">Selamat Hari Programmer</a></li>
<li><a href="../id466549/index.html">Prinsip umum pengoperasian QEMU-KVM</a></li>
<li><a href="../id466551/index.html">Dalang dengan ES6 di node dan browser, atau mengapa Zora adalah kerangka uji terbaik di ceruknya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>