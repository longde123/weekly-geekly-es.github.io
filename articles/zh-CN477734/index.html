<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌈 🏆 🎙️ 使用Photos应用程序了解UICollectionViewLayout 👃🏾 🍁 🦗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我叫Nikita，我在ABBYY上使用移动SDK，并且还处理UI组件，以便在智能手机上扫描和方便地查看多页文档。 该组件由几个部分组成，可减少基于ABBYY Mobile Capture技术开发应用程序的时间。 首先，用于扫描文件的照相机； 其次，带有捕获结果的编辑器屏幕（即自动拍摄的照片...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Photos应用程序了解UICollectionViewLayout</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/477734/">哈Ha！ 我叫Nikita，我在ABBYY上使用移动SDK，并且还处理UI组件，以便在智能手机上扫描和方便地查看多页文档。 该组件由几个部分组成，可减少基于<a href="http://www.abbyy.com/ru-ru/mobile-capture-sdk/%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3D%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25B5%25D0%25BC_ui">ABBYY Mobile Capture技术</a>开发应用程序的时间。 首先，用于扫描文件的照相机； 其次，带有捕获结果的编辑器屏幕（即自动拍摄的照片）和用于校正文档边框的屏幕。 <br><br> 开发人员只需调用几个方法就足够了-现在在他的应用程序中已经有一个可以自动扫描文档的照相机。 但是，除了配置的摄像机外，您还需要为客户提供对扫描结果的便捷访问，即 自动拍照。 如果客户扫描合同或章程，则可能会有很多此类照片。 <br><br> 在这篇文章中，我将讨论在实现编辑器屏幕以及文档捕获结果过程中出现的困难。 屏幕本身是两个<code>UICollectionView</code> ，我将它们称为大小。 我将省略手动调整文档边框和文档其他工作的可能性，并且在滚动过程中我将重点介绍动画和布局功能。 在GIF下方，您可以看到最终发生了什么。 到资源库的链接将在文章的末尾。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/xs/of/r2xsofivnhzdmlxt67ld_2atq-q.gif"></div><br><br> 作为参考，我经常关注Apple系统应用程序。 当您仔细查看其应用程序的动画和其他界面解决方案时，您会开始欣赏它们对各种琐事的殷勤态度。 现在，我们将以“ <i>照片”</i>应用程序（iOS 12）为参考。 我将提请您注意此应用程序的特定功能，然后我们将尝试实现它们。 <br><a name="habracut"></a><br> 我们将介绍<code>UICollectionViewFlowLayout</code>大多数自定义<code>UICollectionViewFlowLayout</code> ，了解如何实现视差和轮播等常见技术，并讨论在插入和删除单元格时与自定义动画相关的问题。 <br><br><h2> 功能回顾 </h2><br> 要添加细节，我将在“ <i>照片”</i>应用程序中描述令我满意的具体小事情，然后以适当的顺序实现它们。 <br><br><ol><li> 大集合中的视差效果 </li><li> 少量收藏的元素居中。 </li><li> 小集合中项目的动态大小 </li><li> 放置小单元格元素的逻辑不仅取决于contentOffset，还取决于用户交互 </li><li> 用于移动和删除的自定义动画 </li><li> 更改方向时，“活动”单元格的索引不会丢失 </li></ol><br><h3>  1.视差 </h3><br> 什么是视差？ <br><blockquote> 视差滚动是计算机图形学中的一种技术，其中背景图像比前景图像移动通过相机的速度更慢，从而在2D场景中产生深度幻觉，并增加了虚拟体验的沉浸感。 </blockquote> 您会注意到，滚动时，单元格的帧移动速度快于其中的图像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/qc/7j/9uqc7jfa_e81lg-_9h6uleidmdg.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/oc/jt/nv/ocjtnvvyckaotg52-tooulyfddq.png"></div><br> 让我们开始吧！ 创建单元的子类，将UIImageView放入其中。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>()​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) addSubview(imageView) clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> imageView.snp.makeConstraints { $<span class="hljs-number"><span class="hljs-number">0</span></span>.edges.equalToSuperview() } } }</code> </pre><br> 现在，您需要了解如何移动<code>imageView</code> ，以创建视差效果。 为此，您需要在滚动过程中重新定义单元格的行为。 苹果： <br><blockquote> 避免子类化<code>UICollectionView</code> 。 集合视图几乎没有或没有它自己的外观。 而是从数据源对象中提取所有视图，并从布局对象中提取所有与布局有关的信息。 如果要尝试在三个维度上布置项目，则正确的方法是实施自定义布局，该布局设置每个单元的3D变换并正确查看。 </blockquote> 好的，让我们创建<b>布局对象</b> 。  <code>UICollectionView</code>具有属性<code>collectionViewLayout</code> ，它从中学习有关单元格位置的信息。  <code>UICollectionViewFlowLayout</code>是抽象<code>UICollectionViewLayout</code>的实现，后者是<code>collectionViewLayout</code>属性。 <br><blockquote>  <code>UICollectionViewLayout</code>正在等待有人对其进行子类化并提供适当的内容。  <code>UICollectionViewFlowLayout</code>是<code>UICollectionViewFlowLayout</code>的具体类，已实现所有四个成员，以这种方式将以网格方式排列单元。 <br></blockquote> 创建<code>UICollectionViewFlowLayout</code>的子类并覆盖其<code>layoutAttributesForElements(in:)</code> 。 该方法返回一个<code>UICollectionViewLayoutAttributes</code>数组，该数组提供有关如何显示特定单元格的信息。 <br><br> 每当<code>contentOffset</code>更改时，以及布局无效时，收集请求属性。 另外，我们将通过添加<code>parallaxValue</code>属性来创建自定义属性，该属性确定图片的帧相对于单元格的帧延迟了多少。 对于属性子类，必须<code>NSCopiyng</code>覆盖<code>NSCopiyng</code> 。 苹果： <br><blockquote> 如果您继承并实现了任何自定义布局属性，则还必须重写继承的isEqual：方法以比较属性的值。 在iOS 7和更高版本中，如果集合属性未更改，则它们不会应用布局属性。 它通过使用isEqual：方法比较旧属性对象和新属性对象来确定属性是否已更改。 因为此方法的默认实现仅检查此类的现有属性，所以您必须实现自己的方法版本以比较任何其他属性。 如果您的自定义属性都相等，请调用<code>super</code>并在实现结束时返回结果值。 <br></blockquote> 如何找出<code>parallaxValue</code> ？ 让我们计算一下您需要移动多少位置才能使其位于中心。 如果此距离大于单元格的宽度，请对其进行锤击。 否则，将此距离除以<b>单元</b>的宽度。 该距离越接近零，视差效果越弱。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallaxLayoutAttributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewLayoutAttributes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parallaxValue: <span class="hljs-type"><span class="hljs-type">CGFloat?</span></span> }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewLayout</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewFlowLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offsetBetweenCells: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">44</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldInvalidateLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forBoundsChange newBounds: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layoutAttributesClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutAttributesForElements(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect)? .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.copy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> } .compactMap(prepareAttributes) }​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(attributes: ParallaxLayoutAttributes)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = itemSize.width <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToCenter = attributes.center.x - collectionView.contentOffset.x <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relativeDistanceToCenter = (distanceToCenter - centerX) / width​ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(relativeDistanceToCenter) &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { attributes.parallaxValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> attributes.transform = .identity } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { attributes.parallaxValue = relativeDistanceToCenter attributes.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: relativeDistanceToCenter * offsetBetweenCells, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/2u/pw/f3/2upwf3rrqmsjxh-btqrm3zau7tm.png"></div><br><br><img src="https://habrastorage.org/webt/bz/x_/ol/bzx_olvusogre4usqir2uvl3uxm.png" alt="图片"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/pi/9z/fxpi9zj22hrlkywk5ptjieqq9ma.png"></div><br> 当集合收到必要的属性时，单元<b>将应用</b>它们。 可以在单元的子类中覆盖此行为。 让我们根据<code>parallaxValue</code>值<code>imageView</code> 。 但是， <code>contentMode == .aspectFit</code>的图片移位正常工作，这还不够，因为图片框与<code>clipsToBounds == true</code>框不一致，当<code>clipsToBounds == true</code>时，图像框将被裁剪。 放置一个与图像大小匹配的遮罩，并使用适当的<code>contentMode</code> ，如有必要，我们将对其进行更新。 现在一切正常！ <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutSubviews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutSubviews() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageSize = imageView.image?.size <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageRect = <span class="hljs-type"><span class="hljs-type">AVMakeRect</span></span>(aspectRatio: imageSize, insideRect: bounds)​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">UIBezierPath</span></span>(rect: imageRect) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shapeLayer = <span class="hljs-type"><span class="hljs-type">CAShapeLayer</span></span>() shapeLayer.path = path.cgPath layer.mask = shapeLayer } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layoutAttributes: UICollectionViewLayoutAttributes)</span></span></span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attrs = layoutAttributes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.apply(layoutAttributes) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parallaxValue = attrs.parallaxValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transition = -(bounds.width * <span class="hljs-number"><span class="hljs-number">0.3</span></span> * parallaxValue) imageView.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: transition, y: .zero) } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/9e/-h/j_9e-hdvix9nueitnhf0elsk80o.png"></div><br><br><h3>  2.少量收藏的元素居中 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/d9e/a78/6ccd9ea78faa45a085233d593c6feddb.gif"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c9/ld/ra/c9ldral4qoinyvhoacyfveqbwtm.png"></div><br> 这里的一切都很简单。 通过在左右两侧都设置较大的<code>inset</code> ，可以实现此效果。 左右滚动时，仅当最后一个单元格离开可见内容时才需要开始<code>bouncing</code> 。 也就是说，可见内容应等于单元格的大小。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailFlowLayout</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> farInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .zero } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (collection.bounds.width - itemSize.width) / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> insets: <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span> { <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span>(top: .zero, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: farInset, bottom: .zero, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: farInset) }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { collectionView?.contentInset = insets <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare() } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/me/ty/vvmetyazz7-6mzze8-7knxoasxw.png"></div><br><br><img src="https://habrastorage.org/webt/hr/qa/k6/hrqak6wkoeqsf7nvy8bky_tauym.jpeg" alt="图片"><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/pk/br/hepkbrq20vpteyatek3hv8pi8mg.png"></div><br><br> 有关居中的更多信息：当集合完成滚动时，布局将请求<code>contentOffset</code>停在该位置。 为此，请重写<code>targetContentOffset(forProposedContentOffset:withScrollingVelocity:)</code> 。 苹果： <br><blockquote> 如果希望滚动行为捕捉到特定边界，则可以覆盖此方法，并使用它来更改停止点。 例如，您可能使用此方法始终停止在项目之间的边界上滚动，而不是在项目中间停止。 <br></blockquote> 为了使一切变得美丽，我们将<b>始终</b>停在最近的单元格的中心。 计算最接近的单元格的中心是一件微不足道的任务，但是您需要小心并考虑<code>contentInset</code> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset, withScrollingVelocity: velocity) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellWithSpacing = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relative = (proposedContentOffset.x + collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>) / cellWithSpacing <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftIndex = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, floor(relative)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightIndex = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(ceil(relative), <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCenter = leftIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCenter = rightIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(leftCenter - proposedContentOffset.x) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rightCenter - proposedContentOffset.x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: leftCenter, y: proposedContentOffset.y) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rightCenter, y: proposedContentOffset.y) } }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/dj/ed/n4djedqhgual-kqq4o3vg-mjxay.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/0x/bj/xn/0xbjxn8vk5gxiuwvjvjklvhfusa.png"></div><br><br><h3>  3.小集合元素的动态大小 </h3><br> 如果滚动大集合，则<code>contentOffset</code>将更改为一个小集合。 而且，少量收藏品的中央单元格没有其余部分大。 边单元的大小固定，中间的边单元与其包含的图片的纵横比一致。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/c61/03e/6e3c6103e3602c9a3cbf0b7553a05386.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/8q/ma/hw8qma82pik2sus_ul5rbvu8rbm.png"></div><br> 您可以使用与视差相同的技术。 让我们为一个小集合创建一个自定义<code>UICollectionViewFlowLayout</code>并重新定义<code>prepareAttributes(attributes:</code>鉴于该小集合的布局逻辑将变得更加复杂，我们将创建一个单独的实体来存储和计算单元格几何。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dims: <span class="hljs-type"><span class="hljs-type">Dimensions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span>​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new state: State)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Cell</span></span>(indexPath: indexPath, dims: dims, state: state) } }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dimensions</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aspectRatio: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insetAsExpanded: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> `<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`: <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-type"><span class="hljs-type">State</span></span>(expanding: .zero) } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ma/im/0cmaim03nqx9dpkohrfumymr11a.png"></div><br>  <code>UICollectionViewFlowLayout</code>具有<code>collectionViewContentSize</code>属性，该属性确定可以滚动的区域的大小。 为了不使我们的生活复杂化，让我们保持其恒定不变，而与中央单元的大小无关。 为了使每个单元格具有正确的几何形状，您需要了解图片的<code>aspectRatio</code>和距<code>contentOffset</code>单元格中心的距离。 单元格越近，其<code>size.width / size.height</code>越接近<code>aspectRatio</code> 。 调整特定单元格的大小时，请使用<code>affineTransform</code>移动其余单元格（向左和向右）。 事实证明，要计算特定单元的几何形状，您需要了解邻居（可见）的属性。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from layout: ThumbnailLayout, with sideCells: [Cell])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = layout.layoutAttributesForItem(at: indexPath)​ attributes?.size = size attributes?.center = center​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translate = sideCells.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { (current, cell) -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &lt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current - cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &gt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current + cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current } attributes?.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: translate, y: .zero)​ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> additionalWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { (dims.defaultSize.height * dims.aspectRatio - dims.defaultSize.width) * state.expanding } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: dims.defaultSize.width + additionalWidth, height: dims.defaultSize.height) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> center: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(indexPath.row) * (dims.defaultSize.width + dims.inset) + dims.defaultSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: dims.defaultSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre> <br>  <code>state.expanding</code>被认为与<code>parallaxValue</code>几乎相同。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index: IndexPath, offsetX: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = <span class="hljs-type"><span class="hljs-type">Cell</span></span>( indexPath: index, dims: <span class="hljs-type"><span class="hljs-type">Cell</span></span>.<span class="hljs-type"><span class="hljs-type">Dimensions</span></span>( defaultSize: itemSize, aspectRatio: dataSource(index.row), inset: config.distanceBetween, insetAsExpanded: config.distanceBetweenFocused), state: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>)​ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attribute = cell.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: []) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellOffset = attribute.center.x - itemSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> widthWithOffset = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) &lt; widthWithOffset { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) / widthWithOffset <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.updated(by: .expand(expanding)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> ..&lt; itemsCount) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: $<span class="hljs-number"><span class="hljs-number">0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { cell(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, offsetX: offsetWithoutInsets.x) } .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: cells) } }</code> </pre> <br><br><h3>  4.放置小单元格元素的逻辑不仅取决于contentOffset，而且取决于用户交互 </h3><br> 当用户滚动浏览一个小集合时，所有单元格的大小均相同。 滚动大集合时，情况并非如此。  （ <i>请参见gif 3和5</i> ）。 让我们编写一个动画器，以更新<code>ThumbnailLayout</code>布局的属性。 动画师将自己存储<code>DisplayLink</code>并每秒调用该块60次，从而可以访问当前进度。  <code>easing functions</code>各种<code>easing functions</code>到动画制作器上很容易。 可以在文章末尾的链接上的github上查看实现。 <br><br> 让我们在<code>ThumbnailLayout</code>输入<code>expandingRate</code>属性，通过该属性<code>expanding</code>所有<code>Cell</code> <code>expanding</code>都将相乘。 事实证明， <code>expandingRate</code>表示如果特定图片居中，则它将在<code>aspectRatio</code>影响其尺寸。 使用<code>expandingRate == 0</code>所有像元的大小相同。 在一个小集合的滚动开始时，我们将运行一个动画器，该动画器将ExpandingRate设置为0，在滚动结束时，反之亦然，将其设置为1。实际上，在更新布局时，中央单元和侧面单元的大小将发生变化。 与<code>contentOffset</code>和抽搐没有<code>contentOffset</code> ！ <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollAnimation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">` </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> end }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type: <span class="hljs-type"><span class="hljs-type">Type</span></span>​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> toValue: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type == .begin ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentExpanding = thumbnails.config.expandingRate <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(currentExpanding - toValue))​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> animator = <span class="hljs-type"><span class="hljs-type">Animator</span></span>(onProgress: { current, <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rate = currentExpanding + (toValue - currentExpanding) * current <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.config.expandingRate = rate <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.invalidateLayout() }, easing: .easeInOut)​ animator.animate(duration: duration) { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> completion() } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/sy/sz/ff/syszffr_19xmccnvyw-do9lcqhy.png"></div><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollViewWillBeginDragging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollView: UIScrollView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scrollView == thumbnails.collectionView { handle(event: .beginScrolling) <span class="hljs-comment"><span class="hljs-comment">// call ScrollAnimation.run(type: .begin) } }​ func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) { if scrollView == thumbnails.collectionView &amp;&amp; !decelerate { thumbnailEndScrolling() } }​ func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) { if scrollView == thumbnails.collectionView { thumbnailEndScrolling() } }​ func thumbnailEndScrolling() { handle(event: .endScrolling) // call ScrollAnimation.run(type: .end) }</span></span></code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/v0/x7/nuv0x7phez1lg2osumphtri1wao.png"></div><br><br><h3>  5.用于移动和删除的自定义动画 </h3><br> 有很多文章讲述如何制作自定义动画来更新单元格，但在我们的情况下，它们对我们没有帮助。 文章和教程描述了如何覆盖更新后的单元格的属性。 在我们的情况下，更改已删除单元格的布局会产生副作用-相邻单元格的<code>expanding</code>会发生变化，在动画过程中，该<code>expanding</code>往往会取代已删除单元格的位置。 <br><br> 在<code>UICollectionViewFlowLayout</code>更新内容的工作方式如下。 删除/添加单元格后，将开始<code>prepare(forCollectionViewUpdates:)</code>方法，并提供一个<code>UICollectionViewUpdateItem</code>数组，该数组可告诉我们更新/删除/添加了哪些单元格的索引。 接下来，布局将调用一组方法 <br><br><pre> <code class="swift hljs">finalLayoutAttributesForDisappearingItem(at:) initialLayoutAttributesForAppearingDecorationElement(ofKind:at:)</code> </pre> <br> 和他们的朋友一起装饰/补充意见。 收到更新数据的属性后，将调用<code>finalizeCollectionViewUpdates</code> 。 苹果： <br><blockquote> 收集视图将在最后对所有更改进行动画处理之前，将此方法称为最后一步。 在用于执行所有插入，删除和移动动画的动画块中调用此方法，因此您可以根据需要使用此方法创建其他动画。 否则，您可以使用它来执行与管理布局对象的状态信息相关的所有最新任务​​。 <br></blockquote> 麻烦的是，我们只能为<b>更新的</b>单元格专门设置属性，而我们需要以不同的方式为所有单元格更改它们。 新的中心单元格应更改<code>aspectRatio</code> ，而侧面单元格应进行<code>transform</code> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/223/6ad/9e0/2236ad9e0cff5fac58a4b490570340c4.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/wa/pf/1bwapfugwecsrwjnnw3imlnviyk.png"></div><br> 在检查了删除/插入期间收集单元的默认动画的工作原理后，我们知道<code>finalizeCollectionViewUpdates</code>中的层单元包含<code>CABasicAnimation</code> ，如果您要为其余单元自定义动画，则可以在其中进行更改。 当日志显示在<code>performBatchUpdates</code>和<code>prepare(forCollectionViewUpdates:)</code> <code>prepareAttributes(attributes:)</code> <code>prepare(forCollectionViewUpdates:)</code>被调用时，情况变得更糟了，单元格的数量可能已经错误，尽管<code>collectionViewUpdates</code>尚未启动，但很难维护和理解。 该怎么办？ 您可以禁用这些内置动画！ <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare(forCollectionViewUpdates: updateItems) <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.begin() <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.setDisableActions(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) }​ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalizeCollectionViewUpdates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.commit() }</code> </pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/69/ja/x4/69jax4yhfpsjyr5jej-xxpb6pkc.png"></div><br> 配备了已经编写的动画制作器，我们将根据要求删除所有必需的动画，并在动画结束时启动<code>dataSource</code>更新。 因此，我们将在更新时简化集合的动画，因为我们自己控制何时更改单元格数。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( at indexPath: IndexPath, dataSourceUpdate: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>, completion: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) {​ <span class="hljs-type"><span class="hljs-type">DeleteAnimation</span></span>(thumbnails: thumbnails, preview: preview, index: indexPath).run { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousCount = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.itemsCount <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> previousCount == indexPath.row + <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.activeIndex = previousCount - <span class="hljs-number"><span class="hljs-number">1</span></span> } dataSourceUpdate() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.collectionView?.deleteItems(at: [indexPath]) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.preview.collectionView?.deleteItems(at: [indexPath]) completion?() } }</code> </pre> <br> 这样的动画将如何工作？ 在<code>ThumbnailLayout</code>我们存储可选的手册，这些手册可以更新特定单元格的几何形状。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailLayout</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span> = (<span class="hljs-type"><span class="hljs-type">Cell</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updates: [<span class="hljs-type"><span class="hljs-type">IndexPath</span></span>: <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span>] = [:] <span class="hljs-comment"><span class="hljs-comment">// ... override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {​ let cells = (0 ..&lt; itemsCount) .map { IndexPath(row: $0, section: 0) } .map { cell(for: $0, offsetX: offsetWithoutInsets.x) } .map { cell -&gt; Cell in if let update = self.config.updates[cell.indexPath] { return update(cell) } return cell } return cells.compactMap { $0.attributes(from: self, with: cells) } }</span></span></code> </pre> <br> 有了这样的工具，您可以对单元的几何形状进行任何操作，在动画制作器工作期间抛出更新，并在赞美中将其删除。 也有可能合并更新。 <br><br><pre> <code class="swift hljs">updates[index] = newUpdate(updates[index])</code> </pre><br> 删除动画代码非常麻烦；它位于存储库中的<i>DeleteAnimation.swift</i>文件中。 单元之间焦点切换的动画以相同的方式实现。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/d8d/ca0/001d8dca06df6b68773652760a019bf3.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/6q/bs/mi6qbskcng_u5ehyixy1q0xp_ce.png"></div><br><br><h3>  6.更改方向时，“活动”单元格的索引不会丢失 </h3><br> 即使您只是在<code>contentOffset</code>中以及在更改方向时弹出一些值，也会调用<code>scrollViewDidScroll(_ scrollView:)</code> 。 当两个集合的滚动同步时，在布局更新期间可能会出现一些问题。 以下技巧将帮助您：在布局更新中，可以将<code>scrollView.delegate</code>设置为<code>nil</code> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollSynchronizer</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> thumbnails.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> thumbnails.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br> 在更改方向时更新像元大小时，将如下所示： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhotosViewController</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewWillTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillTransition(to: size, with: coordinator)​ contentView.synchronizer.unbind() coordinator.animate(alongsideTransition: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.contentView.synchronizer.bind() } } }</code> </pre> <br> 为了在更改方向时不会丢失期望的<code>contentOffset</code> ，可以在<code>scrollView.delegate</code>更新<code>scrollView.delegate</code> 。 更改方向时，如果您覆盖了<code>shouldInvalidateLayout(forBoundsChange:)</code> ，则布局将被禁用。 更改<code>bounds</code>布局将要求澄清<code>contentOffset</code> ，以使其澄清，您需要重新定义<code>targetContentOffset(forProposedContentOffset:)</code> 。 苹果： <br><blockquote> 在布局更新期间或在布局之间转换时，集合视图将调用此方法，以使您有机会更改建议的内容偏移以在动画末尾使用。 如果动画或过渡可能导致项目以对您的设计而言并非最佳的方式放置，则可以覆盖此方法。 <br><br> 集合视图在调用<code>prepare()</code>和<code>collectionViewContentSize</code>方法之后调用此方法。 </blockquote><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> targetOffset = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layoutHandler = layoutHandler <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targetOffset } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(layoutHandler.targetIndex) / <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>( x: collectionViewContentSize.width * offset - farInset, y: targetOffset.y) }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/5r/sf/i55rsfdujvblk7om3yq2yerabhu.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ls/6w/ngls6wjfkhkajrg3706i_g11lyo.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢您的阅读！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有代码都可以在</font><a href="https://github.com/YetAnotherRzmn/PhotosApp"><font style="vertical-align: inherit;">github.com/YetAnotherRzmn/PhotosApp中</font></a><font style="vertical-align: inherit;">找到</font></font><a href="https://github.com/YetAnotherRzmn/PhotosApp"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477734/">https://habr.com/ru/post/zh-CN477734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477722/index.html">C ++中的Google样式指南。 第8部分</a></li>
<li><a href="../zh-CN477724/index.html">HR品牌habraseminar：关于人才，狩猎和内容</a></li>
<li><a href="../zh-CN477728/index.html">团队领导做什么，以免团队疲倦</a></li>
<li><a href="../zh-CN477730/index.html">ChipWhisperer：对岩浆的能量攻击</a></li>
<li><a href="../zh-CN477732/index.html">水下导航系统的手指分类错误</a></li>
<li><a href="../zh-CN477736/index.html">测试人员的路径：从“手刹”到自动化</a></li>
<li><a href="../zh-CN477738/index.html">iKassa或我们如何驯服“数字收银员”</a></li>
<li><a href="../zh-CN477740/index.html">在哪里可以用眼睛观察这架望远镜？</a></li>
<li><a href="../zh-CN477742/index.html">“你好，Checkmarx！” 如何编写对Checkmarx SAST的请求并查找很酷的漏洞</a></li>
<li><a href="../zh-CN477744/index.html">为什么专业人士有时会创建不良的应用程序？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>