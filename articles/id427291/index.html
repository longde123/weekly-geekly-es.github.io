<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§”ğŸ¿ ğŸ‘¨â€ğŸš€ ğŸ”„ Perkecil lalu lintas di Formulir Web ASP.NET, div yang dapat diklik, dan polling server berkala ğŸ‘¨ğŸ»â€ğŸŒ¾ ğŸ© ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknologi ASP.NET Web Forms lambat tapi pasti merupakan sesuatu dari masa lalu. Itu sedang digantikan oleh API Web dengan Angular 6 dan tumpukan serup...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perkecil lalu lintas di Formulir Web ASP.NET, div yang dapat diklik, dan polling server berkala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427291/">  Teknologi ASP.NET Web Forms lambat tapi pasti merupakan sesuatu dari masa lalu.  Itu sedang digantikan oleh API Web dengan Angular 6 dan tumpukan serupa.  Tapi saya mewarisi proyek di Formulir Web dengan warisan besar.  Saya punya beberapa teman yang memiliki plus atau minus situasi serupa.  Aplikasi lama yang ditulis tentang teknologi lama yang perlu dikembangkan dan dipelihara.  Formulir Web memiliki kemampuan pada PostBack untuk tidak me-refresh seluruh halaman, tetapi hanya sebagian saja.  Apa yang dibungkus dengan UpdatePanel.  Ini menambah interaktivitas, tetapi masih berfungsi cukup lambat dan menghabiskan banyak lalu lintas, karena  Setiap kali rendering berlangsung di server, dan markup yang sudah selesai diteruskan ke klien, yang perlu dimasukkan bukan div saat ini di dalam.  Omong-omong, UpdatePanel baru saja dirender dalam div, di mana kemudian markup diganti. <br><a name="habracut"></a><br>  Apa yang dapat dilakukan untuk meminimalkan lalu lintas? <br><br><ol><li> Tulis WebMetode pada halaman dan panggil dari klien menggunakan alat AJAX, ketika Anda menerima respons, ubah DOM melalui JS. <br><br>  Kelemahan dari solusi ini adalah Anda tidak dapat menentukan metode Web dalam kontrol.  Saya tidak ingin menulis semua fungsi pada halaman, terutama jika digunakan beberapa kali pada halaman yang berbeda. </li><li>  Tulis layanan asmx, dan panggil dari klien.  Ini lebih baik, tetapi dalam hal ini tidak ada koneksi eksplisit antara kontrol dan layanan.  Jumlah layanan akan tumbuh dengan peningkatan jumlah kontrol.  Selain itu, kondisi tampilan tidak akan tersedia bagi kami, yang berarti kami akan melewati parameter secara eksplisit ketika mengakses layanan, jadi kami akan melakukan validasi server dan memeriksa apakah pengguna memiliki hak untuk melakukan apa yang ia minta. </li><li>  Gunakan antarmuka ICallbackEventHandler.  Menurut saya ini adalah opsi yang cukup bagus. <br><br>  Saya akan membahasnya lebih terinci. </li></ol><br>  Hal pertama yang harus dilakukan adalah mewarisi UserControl kami dari ICallbackEventHandler dan menulis metode RaiseCallbackEvent dan GetCallbackResult.  Agak aneh bahwa ada 2 di antaranya. Yang pertama bertanggung jawab untuk menerima parameter dari klien, yang kedua bertanggung jawab untuk mengembalikan hasilnya. <br>  Akan terlihat seperti ini <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeControl</span></span> : <span class="hljs-title"><span class="hljs-title">UserControl</span></span>, <span class="hljs-title"><span class="hljs-title">ICallbackEventHandler</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta">  /// &lt;summary&gt; ///    /// &lt;/summary&gt; private Guid _someFileId; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta">  ICallbackEventHandler /// &lt;inheritdoc /&gt; public void RaiseCallbackEvent(string eventArgument) { //    try { dynamic args = JsonConvert.DeserializeObject&lt;dynamic&gt;(eventArgument); _someFileId = (Guid) args.SomeFileId; string type = (string) args.Type; } catch (Exception exc) { //  throw; } } /// &lt;inheritdoc /&gt; public string GetCallbackResult() { //  try { // -  return JsonConvert.SerializeObject(new { Action = actionName, FileId = _someFileId, }); } catch (Exception exc) { //  throw; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Itu adalah sisi server.  Sekarang klien <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeControl = { <span class="hljs-attr"><span class="hljs-attr">_successCallbackHandler</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">responseData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseData); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (data.Action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"continue"</span></span>: <span class="hljs-comment"><span class="hljs-comment">// -   break; case "success": //  -  break; case "fail": //   break; default: //   alert,     alert("      "); break; } }, _failCallbackHandler: function() { alert("      "); }, }</span></span></code> </pre><br>  Bukan itu saja.  Kita masih perlu membuat JS untuk menghubungkan semua fungsi kita. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnLoad(e); <span class="hljs-comment"><span class="hljs-comment">//   SomeControl.js,     Page.ClientScript.RegisterClientScriptInclude(Page.GetType(), "SomeControl", "/Scripts/controls/SomeControl.js?v=2.24.0"); string callbackArgument = //   //***  .***   JS   SomeControl  CallServer.       ,     ScriptManager.RegisterStartupScript(Page, Page.GetType(), "SomeControl.Initialize", $@"SomeControl.CallServer = function(someFileId) {{ let args = JSON.stringify({{ SomeFileId : someFileId, Type: '{callbackArgument}' }}); {Page.ClientScript.GetCallbackEventReference(this, "args", "SomeControl._successCallbackHandler", string.Empty, "SomeControl._failCallbackHandler", true)}; }};", true); //    ScriptManager.GetCurrent(Page)?.RegisterAsyncPostBackControl(this); }</span></span></code> </pre><br>  Ini jelas kode di belakang kendali. <br><br>  Yang paling menarik adalah pembuatan fungsi JS menggunakan metode GetCallbackEventReference. <br><br>  Kami melewati itu <br><br><ul><li>  tautan ke kendali kami </li><li>  nama variabel JS yang nilainya akan diteruskan ke server dalam metode RaiseCallbackEvent melalui eventArgument (baris di atas membuat serialisasi objek dalam JSON untuk transmisi dan benar-benar menetapkan nilai variabel args ini) </li><li>  Nama panggilan balik fungsi JS untuk sukses </li><li>  konteks eksekusi (saya tidak menggunakannya) </li><li>  nama fungsi JS callback jika terjadi kesalahan </li><li>  kami akan memvalidasi permintaan yang datang ke server menggunakan alat ASP.NET </li></ul><br>  Bagaimana semua ini akan bekerja bersama? <br><br>  Dari JS kita dapat memanggil SomeControl.CallServer, fungsi ini akan membuat argumen variabel lokal dan meneruskan kontrol ke fungsi yang akan membuat permintaan ke server melalui AJAX. <br>  Selanjutnya, kontrol diteruskan ke metode server RaiseCallbackEvent.  Semua yang ada di variabel klien args sekarang jatuh ke parameter input server eventArgument. <br>  Setelah RaiseCallbackEvent dijalankan, kontrol akan diteruskan ke GetCallbackResult. <br><br>  String yang akan kami kembalikan melalui pengembalian akan dikirim ke klien dan masuk ke parameter input dari fungsi SomeControl._successCallbackHandler, yaitu di responseData. <br>  Jika pada tahap tertentu kode server mengeluarkan Exception, maka kontrol akan ditransfer ke klien SomeControl._failCallbackHandler <br><br>  Masih perlu dikatakan tentang ViewState.  ViewState ditransfer dari klien ke server, dan itu dapat digunakan, tetapi hanya dalam mode ReadOnly, sebagai  ViewState tidak dikirim kembali ke klien. <br><br>  Desainnya membingungkan pada pandangan pertama, tetapi jika Anda melihatnya, ternyata cukup nyaman, dan lalu lintas dihemat. <br><br>  Pertanyaan kedua yang ingin saya bahas dalam artikel ini adalah div yang dapat diklik atau bagaimana Anda dapat memanggil pembaruan UpdatePanel dari sisi klien. <br><br>  Mengapa div yang dapat diklik diperlukan, bisakah Anda menggunakan &lt;asp: Button&gt;? <br>  Saya suka bahwa div dapat dibuat seperti yang saya inginkan, saya tidak dibatasi oleh tipe input = "tombol" <br><br>  Untuk implementasi perlu diwariskan dari antarmuka IPostBackEventHandler <br><br>  Dia hanya memiliki 1 metode <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaisePostBackEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventArgument</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Sekarang, seperti pada kasus sebelumnya, kita perlu membuat JS untuk memanggil metode ini <br><br>  Ini terlihat seperti ini <br><br><pre> <code class="cs hljs">Page.ClientScript.GetPostBackEventReference(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, callbackArgument)</code> </pre> <br>  callbackArgument diatur pada server dan mengubahnya pada klien tidak akan berfungsi.  Tetapi Anda selalu dapat memasukkan sesuatu ke dalam HiddenField.  Kami memiliki PostBack penuh <br><br>  Sekarang hasil dari GetPostBackEventReference dapat digantung pada onclick dari setiap div atau rentang, atau apa pun. <br><br>  Atau telepon dari JS dengan timer. <br><br>  Pastikan untuk mendaftarkan kontrol sebagai tidak sinkron (pada OnLoad kami memanggil <br><br><pre> <code class="cs hljs">ScriptManager.GetCurrent(Page)?.RegisterAsyncPostBackControl(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre>  ), jika tidak, bahkan ketika di dalam UpdatePanel, PostBack yang sinkron akan dipanggil dan seluruh halaman akan diperbarui, dan bukan hanya konten dari UpdatePanel <br><br>  Menggunakan 2 metode yang dijelaskan di atas, saya menerapkan, misalnya, skenario seperti itu. <br><br>  Pengguna mengklik tombol, permintaan kecil untuk operasi panjang (10-15 detik) dikirim ke server, pengguna menerima respons singkat, selama analisis yang skrip klien memanggil setTimeout.  Di setTimeout, fungsi dilewatkan untuk panggilan balik ke server untuk mengetahui tentang hasil operasi yang diminta sebelumnya.  Jika hasilnya siap, panggil PostBack di UpdatePanel - UpdatePanel yang ditentukan diperbarui.  Jika hasilnya belum siap, panggil setTimeout lagi. <br><br>  Semoga sukses bagi semua orang yang masih bekerja dengan Formulir Web, saya harap artikel ini akan membuat sistem Anda lebih cepat dan lebih indah, dan pengguna akan berterima kasih. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427291/">https://habr.com/ru/post/id427291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427279/index.html">CoLaboratory: Android Night #Apple</a></li>
<li><a href="../id427281/index.html">Pengembangan kelas antarmuka di C ++</a></li>
<li><a href="../id427283/index.html">Seberapa tinggi ketersediaan di Kubernetes dipastikan</a></li>
<li><a href="../id427285/index.html">Sekolah di dasar-dasar sirkuit digital: Novosibirsk - Ok, Krasnoyarsk - bersiap-siap</a></li>
<li><a href="../id427289/index.html">Pemodelan Geologi 3D, Penebangan dan Technaton dari Aramco Innovations</a></li>
<li><a href="../id427293/index.html">Pola Desain JavaScript</a></li>
<li><a href="../id427295/index.html">Fungsi Karir JavaScript</a></li>
<li><a href="../id427297/index.html">Apache Ignite + Apache Spark Data Frames: bersama-sama lebih menyenangkan</a></li>
<li><a href="../id427299/index.html">Mari kita cari yang lain untuk dikoleksi? Konstruktor 3 in 1 "Armada Lunar"</a></li>
<li><a href="../id427301/index.html">GitHub menabrak basis data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>