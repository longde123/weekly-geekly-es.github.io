<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📕 🌚 🏻 Une tâche avec un gratte-ciel et des œufs - pas la poubelle de Newton? 📠 🔻 🈚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En fait, il est le plus. Mais tout d'abord. 

 Énoncé du problème 
 Je maîtrise le python, je résous tout sur Codewars. Je rencontre une tâche bien co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une tâche avec un gratte-ciel et des œufs - pas la poubelle de Newton?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423679/">  En fait, il est le plus.  Mais tout d'abord. <br><br><h3>  Énoncé du problème </h3><br>  Je maîtrise le python, je résous tout sur Codewars.  Je rencontre une tâche bien connue concernant un gratte-ciel et des œufs.  La seule différence est que les données source ne sont pas 100 étages et 2 œufs, mais un peu plus. <br>  Compte tenu de: N œufs, M tente de les jeter, gratte-ciel sans fin. <br><br>  Définissez: le plancher maximum à partir duquel vous pouvez jeter un œuf sans casser.  Les œufs sont sphériques dans le vide et, si l'un d'eux ne casse pas, tombant, par exemple, du 99e étage, les autres résisteront également à une chute de tous les étages de moins d'un centième. <br><br>  0 &lt;= N, M &lt;= 20 000. <br>  Le temps d'exécution de deux douzaines de tests est de 12 secondes. <br><a name="habracut"></a><br><h3>  Rechercher une solution </h3><br>  Nous devons écrire une hauteur de fonction (n, m), qui renverra le numéro d'étage pour le n, m donné.  Puisqu'il sera mentionné très souvent, et à chaque fois que vous écrivez la paresse «en hauteur», puis partout, sauf pour le code, je le désignerai comme f (n, m). <br><br>  Commençons par des zéros.  Évidemment, s'il n'y a pas d'œufs ou de tentatives de les jeter, rien ne peut être déterminé et la réponse sera zéro.  <b>f (0, m) = 0, f (n, 0) = 0.</b> <br><br>  Supposons qu'il y ait un œuf et qu'il y ait 10 tentatives. Vous pouvez tout risquer et le jeter tout de suite du centième étage, mais en cas d'échec, vous ne pourrez rien déterminer d'autre, il est donc plus logique de partir du premier étage et de monter d'un étage après chaque lancer, jusqu'à ce que la tentative ou l'œuf se termine.  Le maximum où vous pouvez obtenir si l'œuf ne tombe pas est le numéro 10. 10. <b>f (1, m) = m</b> <br><br>  Prenez le deuxième œuf, essayez à nouveau 10. Maintenant, alors vous pouvez tenter votre chance avec un centième?  S'il se casse, il y aura encore une et 9 tentatives, au moins 9 étages pourront passer.  Alors peut-être devez-vous risquer non pas à partir du centième, mais à partir du dixième?  Est logique.  Ensuite, en cas de succès, 2 œufs et 9 tentatives resteront.  Par analogie, vous devez maintenant monter encore 9 étages.  Avec une série de succès - encore 8, 7, 6, 5, 4, 3, 2 et 1. Au total, nous sommes au 55e étage avec deux œufs entiers et sans essayer.  La réponse est la somme des M premiers membres de la progression arithmétique avec le premier membre 1 et l'étape 1. <b>f (2, m) = (m * m + m) / 2</b> .  Il est également clair qu'à chaque étape la fonction f (1, m) a été appelée, mais ce n'est pas encore exact. <br><br>  Continuez avec trois œufs et dix tentatives.  En cas d'échec d'un premier lancer, les étages couverts par 2 œufs et 9 tentatives seront couverts par le bas, ce qui signifie que le premier lancer doit être effectué à partir du sol f (2, 9) + 1. Ensuite, en cas de succès, nous avons 3 œufs et 9 tentatives .  Et pour la deuxième tentative, vous devez monter d'un autre f (2,8) + 1 étages.  Et ainsi de suite, jusqu'à ce qu'il reste 3 œufs et 3 tentatives sur les mains.  Et puis il est temps de se laisser distraire en considérant les cas avec N = M, quand il y a autant d'œufs qu'il y a de tentatives. <br><br><div class="spoiler">  <b class="spoiler_title">Et en même temps ceux où il y a plus d'oeufs.</b> <div class="spoiler_text">  Mais ici, tout est évident - des œufs au-delà de ceux qui se cassent ne nous seront pas utiles, même si chaque lancer est infructueux.  <b>f (n, m) = f (m, m) si n&gt; m</b> .  Et dans l'ensemble, 3 œufs, 3 lancers.  Si le premier œuf se casse, vous pouvez vérifier f (2, 2) étages en bas, et s'il ne casse pas, alors f (3,2) étages en haut, c'est-à-dire le même f (2, 2).  Total f (3, 3) = 2 * f (2, 2) + 1 = 7. Et f (4, 4), par analogie, consistera en deux f (3, 3) et un, et ce sera 15. Tous il ressemble aux puissances de deux, et nous écrivons: <b>f (m, m) = 2 ^ m - 1</b> . <br><br>  Cela ressemble à une recherche binaire dans le monde physique: nous partons de l'étage numéro 2 ^ (m-1), en cas de succès nous montons 2 ^ (m-2) étages, et en cas d'échec, nous descendons autant, et ainsi de suite, jusqu'à ce que les tentatives s'épuisent.  Dans notre cas, nous nous levons tout le temps. <br></div></div><br>  Revenons à f (3, 10).  En fait, à chaque étape, tout se résume à la somme f (2, m-1) - le nombre d'étages qui peut être déterminé en cas de défaillance, les unités et f (3, m-1) - le nombre d'étages qui peut être déterminé en cas de succès.  Et il devient clair que de l'augmentation du nombre d'œufs et de tentatives, il est peu probable que quelque chose change.  <b>f (n, m) = f (n - 1, m - 1) + 1 + f (n, m - 1)</b> .  Et c'est une formule universelle qui peut être implémentée en code. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lru_cache @lru_cache() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n,m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m**<span class="hljs-number"><span class="hljs-number">2</span></span>+m)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n&gt;=m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>+height(n,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  Bien sûr, auparavant, je suis monté sur le râteau des fonctions récursives non-mémorisation et j'ai découvert que f (10, 40) prend près de 40 secondes avec le nombre d'appels à lui-même - 97806983. Mais la mémorisation ne sauvegarde également qu'aux intervalles initiaux.  Si f (200,400) est exécuté en 0,8 seconde, alors f (200, 500) est déjà en 31 secondes.  C'est drôle que lorsque vous mesurez le temps d'exécution à l'aide de% timeit, le résultat est bien moins réel que réel.  De toute évidence, la première exécution de la fonction prend la plupart du temps, tandis que les autres utilisent simplement les résultats de sa mémorisation.  Mensonges, mensonges flagrants et statistiques. <br><br><h3>  La récursivité n'est pas nécessaire, nous regardons plus loin </h3><br>  Ainsi, dans les tests, par exemple, f (9477, 10000) apparaît, mais mon pathétique f (200, 500) ne correspond plus au bon moment.  Il existe donc une autre solution, sans récursivité, nous allons poursuivre sa recherche.  J'ai complété le code en comptant les appels de fonction avec certains paramètres afin de voir dans quoi il s'est finalement décomposé.  Pour 10 tentatives, les résultats suivants ont été obtenus: <br><br>  f (3,10) = 7+ 1 * f (2,9) + 1 * f (2,8) + 1 * f (2,7) + 1 * f (2,6) + 1 * f (2 , 5) + 1 * f (2,4) + 1 * f (2,3) + 1 * f (3,3) <br>  f (4,10) = 27+ 1 * f (2,8) + 2 * f (2,7) + 3 * f (2,6) + 4 * f (2,5) + 5 * f (2 , 4) + 6 * f (2,3) + 6 * f (3,3) + 1 * f (4,4) <br>  f (5,10) = 55+ 1 * f (2,7) + 3 * f (2,6) + 6 * f (2,5) + 10 * f (2,4) + 15 * f (2 , 3) + 15 * f (3,3) + 5 * f (4,4) + 1 * f (5,5) <br>  f (6,10) = 69+ 1 * f (2,6) + 4 * f (2,5) + 10 * f (2,4) + 20 * f (2,3) + 20 * f (3 , 3) + 10 * f (4,4) + 4 * f (5,5) + 1 * f (6,6) <br>  f (7,10) = 55+ 1 * f (2,5) + 5 * f (2,4) + 15 * f (2,3) + 15 * f (3,3) + 10 * f (4 , 4) + 6 * f (5,5) + 3 * f (6,6) + 1 * f (7,7) <br>  f (8,10) = 27+ 1 * f (2,4) + 6 * f (2,3) + 6 * f (3,3) + 5 * f (4,4) + 4 * f (5 , 5) + 3 * f (6,6) + 2 * f (7,7) + 1 * f (8,8) <br>  f (9,10) = 7+ 1 * f (2,3) + 1 * f (3,3) + 1 * f (4,4) + 1 * f (5,5) + 1 * f (6 , 6) + 1 * f (7,7) + 1 * f (8,8) + 1 * f (9,9) <br><br>  Une certaine régularité est visible: <br><br><img src="https://habrastorage.org/webt/tz/vf/gv/tzvfgvzzjnvtp4oqmb3sbgyhehk.png"><br><br>  Ces coefficients sont calculés théoriquement.  Chaque bleu est la somme du haut et de la gauche.  Et les violettes sont les mêmes bleues, seulement dans l'ordre inverse.  Vous pouvez calculer, mais c'est encore une récursivité, et j'ai été déçu.  Très probablement, beaucoup (c'est dommage que ce ne soit pas moi) ont déjà appris ces chiffres, mais pour l'instant je vais continuer l'intrigue, en suivant ma propre solution.  J'ai décidé de cracher dessus et d'aller de l'autre côté. <br><br>  Il ouvrit l'exel, construisit une assiette avec les résultats de la fonction et commença à chercher des motifs.  C3 = IF (C $ 2&gt; $ B3; 2 ^ $ B3-1; C2 + B2 + 1), où $ 2 est la ligne avec le nombre d'oeufs (1-13), $ B est la colonne avec le nombre de tentatives (1-20), C3 - cellule à l'intersection de deux œufs et d'une tentative. <br><br><img src="https://habrastorage.org/webt/da/u4/uz/dau4uz9wluuwrll54ugfiol02uq.png"><br><br>  La diagonale grise est N = M, et ici on voit clairement qu'à sa droite (pour N&gt; M) rien ne change.  On peut le voir - mais il ne peut en être autrement, car ce sont tous les résultats du travail de la formule, dans lequel il est donné que chaque cellule est égale à la somme du haut, du haut à gauche et d'une.  Mais une formule universelle où vous pouvez remplacer N et M et obtenir le numéro d'étage n'a pas été trouvée.  Spoiler: il n'existe pas.  Mais alors c'est si simple de créer ce tableau dans Excel, peut-être est-il possible de générer le même python et d'en faire glisser les réponses? <br><br><h3>  Numpy vous n'avez pas </h3><br>  Je me souviens qu'il y a NumPy, qui est juste conçu pour fonctionner avec des tableaux multidimensionnels, pourquoi ne pas l'essayer?  Pour commencer, nous avons besoin d'un tableau unidimensionnel de zéros de taille N + 1 Et d'un tableau unidimensionnel d'unités de taille N.Prenez le premier tableau de zéro à l'avant-dernier élément, ajoutez-le élément par élément avec le premier tableau du premier élément au dernier et avec un tableau d'unités.  Au tableau résultant, ajoutez zéro au début.  Répétez M fois.  L'élément numéro N du tableau résultant sera la réponse.  Les 3 premières étapes ressemblent à ceci: <br><br><img src="https://habrastorage.org/webt/4w/hf/ki/4whfkie9lt2lkiyywknshrit0h4.png"><br><br>  NumPy fonctionne si vite que je n'ai pas enregistré la table entière - chaque fois que je relis la ligne nécessaire.  Une chose - le résultat du travail sur de grands nombres était faux.  Les rangs supérieurs sont comme ceux-là, tandis que les rangs inférieurs ne le sont pas.  Voici à quoi ressemblent les erreurs arithmétiques des nombres à virgule flottante accumulées à partir de plusieurs ajouts.  Peu importe - vous pouvez changer le type du tableau en int.  Non, problème - il s'est avéré que, pour des raisons de vitesse, NumPy ne fonctionne qu'avec ses types de données, et son int, contrairement à Python int, ne peut pas dépasser 2 ^ 64-1, après quoi il déborde silencieusement et continue avec -2 ^ 64.  Et je m'attends à des nombres inférieurs à trois mille caractères.  Mais cela fonctionne très rapidement, f (9477, 10000) fonctionne sur 233 ms, il s'avère juste une sorte de non-sens à la sortie.  Je ne donnerai même pas le code, car une telle chose.  J'essaierai d'en faire un python propre. <br><br><h3>  Itéré, itéré, mais pas itéré </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y+<span class="hljs-number"><span class="hljs-number">1</span></span>, arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[n]</code> </pre> <br>  44 secondes pour calculer f (9477, 10000), c'est un peu trop.  Mais absolument sûr.  Qu'est-ce qui peut être optimisé?  Tout d'abord, il n'est pas nécessaire de tout considérer à droite de la diagonale M, M.  La seconde - pour considérer le dernier tableau dans son ensemble, pour le bien d'une cellule.  Pour cela, les deux dernières deux cellules de la précédente conviendront.  Pour calculer f (10, 20), seules ces cellules grises suffiront: <br><br><img src="https://habrastorage.org/webt/zc/zm/zg/zczmzgfzspyvo2zenqsk4p9y1jo.png"><br><br>  Et donc ça regarde dans le code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; mn: <span class="hljs-comment"><span class="hljs-comment">#    m,m arr = [0] + list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr += [arr[-1]] i+=1 arr.pop(-1) while i &lt; n or i &lt; mn: #        arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr = arr + [arr[-1]+1] if n &gt; len(arr) else [0] + arr i+=1 while i &lt; m: # ,     -  arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) i+=1 return arr[0]</span></span></code> </pre> <br>  Et qu'en pensez-vous?  f (9477, 10000) en 2 secondes!  Mais cette entrée est trop bonne, la longueur du tableau à n'importe quel stade ne dépassera pas 533 éléments (10000-9477).  Vérifions f (5477, 10000) - 11 secondes.  C'est aussi bien, mais seulement en comparaison avec 44 secondes - vingt tests avec ce temps ne passeront pas. <br><br>  Ce n'est pas ça.  Mais puisqu'il y a une tâche, alors il y a une solution, la recherche continue.  J'ai recommencé à regarder le tableau Excel.  La cellule à gauche de (m, m) est toujours une de moins.  Et la cellule à gauche de celle-ci n'est plus là, dans chaque rangée la différence devient plus grande.  La cellule en dessous (m, m) est toujours deux fois plus grande.  Et la cellule en dessous n'est plus deux fois, mais légèrement plus petite, mais pour chaque colonne différemment, plus elle est grande, plus elle est grande.  Et aussi les nombres sur une ligne au début augmentent rapidement, et après le milieu lentement.  Permettez-moi de construire un tableau des différences entre les cellules voisines, peut-être quel modèle apparaîtra là-bas? <br><br><h3>  Plus chaud </h3><br><img src="https://habrastorage.org/webt/6b/vn/we/6bvnwew8keybhtyzxprylcwir6i.png"><br><br>  Bah, des chiffres familiers!  Autrement dit, la somme N de ces nombres dans la ligne numéro M est-ce la réponse?  Certes, les compter est à peu près le même que ce que j'ai déjà fait, il est peu probable que cela accélère considérablement le travail.  Mais vous devez essayer: <br><br><div class="spoiler">  <b class="spoiler_title">f (9477, 10000): 17 secondes</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y, arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:], arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>])) + [<span class="hljs-number"><span class="hljs-number">1</span></span>] m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:n+<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ou 8, si vous ne comptez que la moitié du triangle</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(arr) &lt; n+<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    ,  n &lt;  arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr += [arr[-1]] m-=2 while m &gt; 1: arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) m-=1 if len(arr) &lt; n+1: arr += arr[::-1][1:] #  n   ,   return sum(arr[1:n+1])</span></span></code> </pre><br></div></div><br>  Pour ne pas dire qu'une solution plus optimale.  Cela fonctionne plus rapidement sur certaines données, plus lentement sur certaines.  Nous devons aller plus loin.  Quel est ce triangle avec des nombres apparus deux fois dans la solution?  C'est dommage d'admettre, mais j'ai oublié en toute sécurité les mathématiques supérieures, où le triangle doit avoir figuré, j'ai donc dû le google. <br><br><h3>  Bingo! </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le triangle de Pascal</a> , comme on l'appelle officiellement.  Tableau des coefficients binomiaux infinis.  La réponse au problème avec N œufs et M lancers est donc la somme des N premiers coefficients dans l'expansion du binôme de Newton du Mième degré, à l'exception du zéro. <br><br>  Un coefficient binomial arbitraire peut être calculé à partir des factorielles du numéro de ligne et du numéro de coefficient dans la ligne: bk = m! / (N! * (Mn!)).  Mais la meilleure partie est que vous pouvez calculer séquentiellement les nombres dans la chaîne, en connaissant son nombre et son coefficient zéro (toujours un): bk [n] = bk [n-1] * (m - n + 1) / n.  À chaque étape, le numérateur diminue d'une unité et le dénominateur augmente.  Et la solution finale concise ressemble à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> h, bk = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#      for i in range(1, n + 1): bk = bk * m // ih += bk m-=1 return h</span></span></code> </pre><br>  33 ms  au calcul de f (9477, 10000)!  Cette solution peut également être optimisée, bien que dans les gammes données et cela fonctionne bien.  Si n se trouve dans la seconde moitié du triangle, alors nous pouvons l'inverser en mn, calculer la somme des n premiers coefficients et la soustraire de 2 ^ m-2.  Si n est proche du milieu et m est impair, les calculs peuvent également être réduits: la somme de la première moitié de la ligne sera 2 ^ (m-1) -1, le dernier coefficient de la première moitié peut être calculé par factorielles, son nombre est (m-1) / 2, puis continuez à ajouter des coefficients si n est dans la moitié droite du triangle, ou soustrayez s'il est à gauche.  Si m est pair, vous ne pouvez pas compter la moitié de la ligne, mais vous pouvez trouver la somme des premiers coefficients m / 2 + 1 en calculant la moyenne par factorielle et en ajoutant la moitié à 2 ^ (m-1) -1.  Sur les données d'entrée de l'ordre de 10 ^ 6, cela réduit très sensiblement le temps d'exécution. <br><br>  Après une décision réussie, j'ai commencé à chercher les recherches de quelqu'un d'autre sur cette question, mais je n'ai trouvé que la même chose, à partir des entretiens, avec seulement deux œufs, et ce n'est pas du sport.  Internet sera incomplet sans ma décision, j'ai décidé, et le voici. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423679/">https://habr.com/ru/post/fr423679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423663/index.html">Nous écrivons un traducteur simple en Lisp - III</a></li>
<li><a href="../fr423667/index.html">L'histoire des premiers jeux vidéo à microprocesseur</a></li>
<li><a href="../fr423671/index.html">Les rivaux de Tesla reçoivent un investissement d'un milliard de dollars de l'Arabie saoudite</a></li>
<li><a href="../fr423673/index.html">Risques liés au développement de logiciels</a></li>
<li><a href="../fr423677/index.html">Pilotes Jetpack: Frankie West</a></li>
<li><a href="../fr423683/index.html">Basé sur le bon sens: développer DevOps à partir de zéro</a></li>
<li><a href="../fr423685/index.html">Concurrence PostgreSQL: pas sphérique, pas cheval, pas dans le vide</a></li>
<li><a href="../fr423687/index.html">HyperX Pulsefire FPS Pro - plus rapide, plus méchant et plus abordable</a></li>
<li><a href="../fr423689/index.html">RTOS MAX - gratuit? Nous prévoyons d'ouvrir une licence pour une utilisation commerciale gratuite</a></li>
<li><a href="../fr423693/index.html">Une autre façon d'utiliser Webpack 4 et la séparation de code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>