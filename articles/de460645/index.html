<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻 🙋🏽 ⚠️ Gutes tun, schlechtes tun: Schlechten Code mit Go schreiben, Teil 1 👨🏾‍🤝‍👨🏽 ☎️ 👩🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schlechte Tipps für einen Go-Programmierer 


 Nach Jahrzehnten der Programmierung in Java habe ich in den letzten Jahren hauptsächlich an Go gearbeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gutes tun, schlechtes tun: Schlechten Code mit Go schreiben, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Schlechte Tipps für einen Go-Programmierer</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="Bild"><br><br>  Nach Jahrzehnten der Programmierung in Java habe ich in den letzten Jahren hauptsächlich an Go gearbeitet.  Die Arbeit mit Go ist großartig, vor allem, weil der Code sehr einfach zu befolgen ist.  Java hat das C ++ - Programmiermodell vereinfacht, indem Mehrfachvererbung, manuelle Speicherverwaltung und Operatorüberladung entfernt wurden.  Go macht dasselbe und bewegt sich weiterhin in Richtung eines einfachen und verständlichen Programmierstils, wobei Vererbung und Funktionsüberladung vollständig beseitigt werden.  Einfacher Code ist lesbarer Code, und lesbarer Code ist unterstützter Code.  Und das ist großartig für das Unternehmen und meine Mitarbeiter. <br><br>  Wie in allen Kulturen hat die Softwareentwicklung ihre eigenen Legenden, Geschichten, die vom Wasserkühler nacherzählt werden.  Wir haben alle von Entwicklern gehört, die sich nicht darauf konzentrieren, ein Qualitätsprodukt zu entwickeln, sondern ihre eigene Arbeit vor Außenstehenden schützen wollen.  Sie benötigen keinen unterstützten Code, da dies bedeutet, dass andere Personen ihn verstehen und ändern können.  Ist es auf Go möglich?  Ist es möglich, Go-Code so kompliziert zu machen?  Ich werde gleich sagen - das ist keine leichte Aufgabe.  Schauen wir uns die möglichen Optionen an. <br><a name="habracut"></a><br>  Sie denken: „ <i>Wie viel können Sie Code in einer Programmiersprache korrodieren?</i>  <i>Ist es möglich, so schrecklichen Code auf Go zu schreiben, dass sein Autor im Unternehmen unverzichtbar wird?</i>  " Keine Sorge.  Als ich Student war, hatte ich ein Projekt, in dem ich den Lisp-e-Code eines anderen unterstützte, der von einem Doktoranden geschrieben wurde.  Tatsächlich gelang es ihm, Fortran-e-Code mit Lisp zu schreiben.  Der Code sah ungefähr so ​​aus: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Es gab Dutzende von Dateien mit solchem ​​Code.  Er war absolut schrecklich und absolut brillant zugleich.  Ich habe Monate damit verbracht, es herauszufinden.  Im Vergleich dazu ist das Schreiben von schlechtem Code auf Go nur ein Spucke. <br><br>  Es gibt viele verschiedene Möglichkeiten, Ihren Code nicht zu unterstützen, aber wir werden nur einige betrachten.  Um Böses zu tun, müssen Sie zuerst lernen, Gutes zu tun.  Deshalb schauen wir uns zuerst an, wie die "guten" Go-Programmierer schreiben, und dann schauen wir uns an, wie man das Gegenteil macht. <br><br><h3>  Schlechte Verpackung </h3><br>  Pakete sind ein praktisches Thema für den Einstieg.  Wie kann die Code-Organisation die Lesbarkeit beeinträchtigen? <br><br>  In Go wird der Paketname verwendet, um auf die exportierte Entität zu verweisen (z. B. " <i>fmt.Println"</i> oder " <i>http.RegisterFunc"</i> ).  Da wir den Namen des Pakets sehen können, stellen die "guten" Go-Programmierer sicher, dass dieser Name die exportierten Entitäten beschreibt.  Wir sollten keine util-Pakete haben, da Namen wie " <i>util.JSONMarshal"</i> für uns nicht funktionieren - wir brauchen " <i>json.Marshal"</i> . <br><br>  Die "guten" Go-Entwickler erstellen auch kein separates Paket für das DAO oder Modell.  Für diejenigen, die mit diesem Begriff nicht vertraut sind, ist ein DAO ein „ <i>Datenzugriffsobjekt</i> “ - eine Codeebene, die mit Ihrer Datenbank interagiert.  Ich habe für ein Unternehmen gearbeitet, in dem 6 Java-Dienste dieselbe DAO-Bibliothek importiert haben, um auf dieselbe Datenbank zuzugreifen, die sie gemeinsam genutzt haben, weil " <i>... nun, Sie wissen, Microservices sind dieselben ...</i> ". <br><br>  Wenn Sie ein separates Paket mit all Ihren DAOs haben, ist es wahrscheinlicher, dass Sie eine zirkuläre Abhängigkeit zwischen Paketen erhalten, die in Go verboten ist.  Wenn Sie über mehrere Dienste verfügen, die dieses DAO-Paket als Bibliothek verbinden, kann es auch vorkommen, dass bei einer Änderung eines Dienstes alle Ihre Dienste aktualisiert werden müssen, da sonst ein Fehler auftritt.  Dies wird als verteilter Monolith bezeichnet und ist unglaublich schwer zu aktualisieren. <br><br>  Wenn Sie wissen, wie Verpackungen funktionieren sollten und was sie noch schlimmer macht, wird es einfach, „dem Bösen zu dienen“.  Organisieren Sie Ihren Code schlecht und geben Sie Ihren Paketen schlechte Namen.  <i>Teilen Sie</i> Ihren Code in Pakete wie <i>model</i> , <i>util</i> und <i>dao auf</i> .  Wenn Sie wirklich Chaos schaffen möchten, versuchen Sie, Pakete zu Ehren Ihrer Katze oder Ihrer Lieblingsfarbe zu erstellen.  Wenn Menschen mit zyklischen Abhängigkeiten oder verteilten Monolithen konfrontiert sind, weil sie versuchen, Ihren Code zu verwenden, müssen Sie seufzen, die Augen verdrehen und ihnen sagen, dass sie einfach falsch machen ... <br><br><h3>  Unangemessene Schnittstellen </h3><br>  Nachdem alle unsere Pakete beschädigt sind, können wir zu den Schnittstellen übergehen.  Schnittstellen in Go sind nicht wie Schnittstellen in anderen Sprachen.  Die Tatsache, dass Sie nicht explizit deklarieren, dass dieser Typ die Schnittstelle implementiert, scheint zunächst unbedeutend zu sein, kehrt jedoch das Konzept der Schnittstellen vollständig um. <br><br>  In den meisten Sprachen mit abstrakten Typen wird eine Schnittstelle vor oder gleichzeitig mit der Implementierung definiert.  Sie müssen dies zumindest zum Testen tun.  Wenn Sie die Schnittstelle nicht im Voraus erstellen, können Sie sie später nicht einfügen, ohne den gesamten Code zu beschädigen, der diese Klasse verwendet.  Weil Sie es mit einem Link zur Schnittstelle anstelle eines bestimmten Typs neu schreiben müssen. <br><br>  Aus diesem Grund verfügt Java-Code häufig über gigantische Dienstschnittstellen mit vielen Methoden.  Klassen, die diese Schnittstellen implementieren, verwenden dann die benötigten Methoden und ignorieren den Rest.  Das Schreiben von Tests ist möglich, Sie fügen jedoch eine zusätzliche Abstraktionsebene hinzu. Beim Schreiben von Tests verwenden Sie häufig Tools, um Implementierungen der Methoden zu generieren, die Sie nicht benötigen. <br><br>  In Go bestimmen implizite Schnittstellen, welche Methoden Sie verwenden müssen.  Code besitzt eine Schnittstelle, nicht umgekehrt.  Selbst wenn Sie einen Typ mit vielen darin definierten Methoden verwenden, können Sie eine Schnittstelle angeben, die nur die von Ihnen benötigten Methoden enthält.  Ein anderer Code, der separate Felder desselben Typs verwendet, definiert andere Schnittstellen, die nur die erforderliche Funktionalität abdecken.  In der Regel verfügen diese Schnittstellen nur über einige Methoden. <br><br>  Dies erleichtert das Verständnis Ihres Codes, da eine Methodendeklaration nicht nur bestimmt, welche Daten benötigt werden, sondern auch genau angibt, welche Funktionen verwendet werden sollen.  Dies ist einer der Gründe, warum gute Go-Entwickler den Rat befolgen: " <i>Schnittstellen akzeptieren, Strukturen zurückgeben</i> ." <br><br>  Aber nur weil dies eine gute Praxis ist, heißt das nicht, dass Sie das tun sollten ... <br>  Der beste Weg, um Ihre Schnittstellen "böse" zu machen, besteht darin, zu den Prinzipien der Verwendung von Schnittstellen aus anderen Sprachen zurückzukehren, d. H.  Definieren Sie Schnittstellen im Voraus als Teil des aufgerufenen Codes.  Definieren Sie große Schnittstellen mit vielen Methoden, die von allen Service-Clients verwendet werden.  Es wird unklar, welche Methoden wirklich benötigt werden.  Dies verkompliziert den Code, und wie Sie wissen, ist die Komplikation der beste Freund eines „bösen“ Programmierers. <br><br><h3>  Übergeben Sie Heap-Zeiger </h3><br>  Bevor Sie erklären, was dies bedeutet, müssen Sie ein wenig philosophieren.  Wenn Sie ablenken und nachdenken, macht jedes geschriebene Programm dasselbe.  Es empfängt Daten, verarbeitet sie und sendet die verarbeiteten Daten an einen anderen Ort.  Dies gilt unabhängig davon, ob Sie ein Abrechnungssystem schreiben, HTTP-Anforderungen akzeptieren und Webseiten zurückgeben oder sogar den Joystick überprüfen, um einen Klick auf eine Schaltfläche zu verfolgen - Programme verarbeiten die Daten. <br><br>  Wenn wir die Programme auf diese Weise betrachten, ist es am wichtigsten sicherzustellen, dass wir leicht verstehen, wie die Daten konvertiert werden.  Es empfiehlt sich daher, die Daten während des Programms so lange wie möglich unverändert zu lassen.  Denn Daten, die sich nicht ändern, sind Daten, die leicht zu verfolgen sind. <br><br>  In Go haben wir Referenztypen und Werttypen.  Der Unterschied zwischen den beiden besteht darin, ob sich die Variable auf eine Kopie der Daten oder auf den Speicherort der Daten im Speicher bezieht.  Zeiger, Slices, Maps, Kanäle, Schnittstellen und Funktionen sind Referenztypen, und alles andere ist ein Werttyp.  Wenn Sie einer anderen Variablen eine Werttypvariable zuweisen, wird eine Kopie des Werts erstellt.  Durch Ändern einer Variablen wird der Wert einer anderen Variablen nicht geändert. <br><br>  Das Zuweisen einer Variablen eines Referenztyps zu einer anderen Variablen eines Referenztyps bedeutet, dass beide denselben Speicherbereich verwenden. Wenn Sie also die Daten ändern, auf die der erste zeigt, ändern Sie die Daten, auf die der zweite zeigt.  Dies gilt sowohl für lokale Variablen als auch für Funktionsparameter. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Kind Go-Entwickler möchten es einfacher machen zu verstehen, wie Daten gesammelt werden.  Sie versuchen, den Wertetyp so oft wie möglich als Parameter für Funktionen zu verwenden.  In Go gibt es keine Möglichkeit, Felder in Strukturen oder Funktionsparametern als endgültig zu markieren.  Wenn eine Funktion Wertparameter verwendet, werden durch Ändern der Parameter die Variablen in der aufrufenden Funktion nicht geändert.  Die aufgerufene Funktion kann lediglich den Wert an die aufrufende Funktion zurückgeben.  Wenn Sie also eine Struktur ausfüllen, indem Sie eine Funktion mit Wertparametern aufrufen, können Sie keine Angst haben, Daten an die Struktur zu übertragen, da Sie verstehen, woher jedes Feld in der Struktur stammt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Wie werden wir "böse"?  Sehr einfach - dieses Modell umdrehen. <br><br>  Anstatt Funktionen aufzurufen, die die gewünschten Werte zurückgeben, übergeben Sie einen Zeiger auf die Struktur in der Funktion und lassen sie Änderungen an der Struktur vornehmen.  Da jede Funktion ihre eigene Struktur hat, können Sie nur herausfinden, welche Felder sich ändern, indem Sie den gesamten Code betrachten.  Möglicherweise haben Sie auch implizite Abhängigkeiten zwischen Funktionen - die 1. Funktion überträgt die von der 2. Funktion benötigten Daten.  Aber im Code selbst gibt nichts an, dass Sie zuerst die 1. Funktion aufrufen sollten.  Wenn Sie Ihre Datenstrukturen auf diese Weise erstellen, können Sie sicher sein, dass niemand versteht, was Ihr Code tut. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Panik taucht auf </h3><br>  Jetzt fangen wir an, mit Fehlern umzugehen.  Sie denken wahrscheinlich, dass es schlecht ist, Programme zu schreiben, die Fehler zu 75% behandeln, und ich kann nicht sagen, dass Sie falsch liegen.  Go-Code wird häufig mit einer Fehlerbehandlung von Kopf bis Fuß gefüllt.  Und natürlich wäre es bequem, sie nicht so einfach zu verarbeiten.  Fehler passieren, und der Umgang mit ihnen unterscheidet Profis von Anfängern.  Eine verschwommene Fehlerbehandlung führt zu instabilen Programmen, die schwer zu debuggen und schwer zu warten sind.  Manchmal bedeutet ein "guter" Programmierer "anstrengen". <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Viele Sprachen wie C ++, Python, Ruby und Java verwenden Ausnahmen, um Fehler zu behandeln.  Wenn etwas schief geht, lösen Entwickler in diesen Sprachen eine Ausnahme aus oder erwarten, dass Code damit umgeht.  Natürlich erwartet das Programm, dass dem Client ein möglicher Fehler bekannt ist, der an einem bestimmten Ort ausgelöst wird, so dass es möglich ist, eine Ausnahme auszulösen.  Da außer (ohne Wortspiel beabsichtigt) von Java geprüften Ausnahmen nichts in der Methodensignatur in Sprachen oder Funktionen darauf hinweist, dass eine Ausnahme auftreten kann.  Woher wissen Entwickler, über welche Ausnahmen sie sich Sorgen machen müssen?  Sie haben zwei Möglichkeiten: <br><br><ul><li>  Erstens können sie den gesamten Quellcode aller Bibliotheken lesen, die ihr Code aufruft, und alle Bibliotheken, die die aufgerufenen Bibliotheken usw. aufrufen. </li><li>  Zweitens können sie der Dokumentation vertrauen.  Ich bin vielleicht voreingenommen, aber aufgrund meiner persönlichen Erfahrung kann ich der Dokumentation nicht voll vertrauen. </li></ul><br>  Also, wie bringen wir dieses Böse zum Gehen?  Natürlich Panik ( <i>Panik</i> ) und Genesung ( <i>Genesung</i> ) missbrauchen!  Die Panik ist für Situationen wie "Das Laufwerk ist heruntergefallen" oder "Die Netzwerkkarte ist explodiert" ausgelegt.  Aber nicht für solche - "jemand hat String statt int übergeben". <br><br>  Leider geben andere, "weniger aufgeklärte Entwickler" Fehler aus ihrem Code zurück.  Hier ist eine kleine Hilfsfunktion von PanicIfErr.  Verwenden Sie es, um die Fehler anderer Entwickler in Panik zu versetzen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Sie können PanicIfErr verwenden, um die Fehler anderer Personen zu verpacken und Code zu komprimieren.  Keine hässliche Fehlerbehandlung mehr!  Jeder Fehler ist jetzt eine Panik.  Es ist so produktiv! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Sie können die Wiederherstellung irgendwo näher am Anfang des Programms platzieren, möglicherweise in Ihrer eigenen <i>Middleware</i> .  Und dann sagen Sie, dass Sie nicht nur Fehler verarbeiten, sondern auch den Code eines anderen sauberer machen.  Böses durch Gutes tun ist die beste Art von Bösem. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Nebenwirkungen einstellen </h3><br>  Als nächstes werden wir einen Nebeneffekt erzeugen.  Denken Sie daran, dass der „gute“ Go-Entwickler verstehen möchte, wie die Daten das Programm durchlaufen.  Der beste Weg, um zu wissen, was die Daten durchlaufen, besteht darin, explizite Abhängigkeiten in der Anwendung einzurichten.  Selbst Entitäten, die derselben Schnittstelle entsprechen, können sich im Verhalten stark unterscheiden.  Zum Beispiel ein Code, der Daten im Speicher speichert, und ein Code, der für dieselbe Arbeit auf die Datenbank zugreift.  Es gibt jedoch Möglichkeiten, Abhängigkeiten in Go ohne explizite Aufrufe zu installieren. <br><br>  Wie viele andere Sprachen bietet Go die Möglichkeit, Code auf magische Weise auszuführen, ohne ihn direkt aufzurufen.  Wenn Sie eine Funktion namens init ohne Parameter erstellen, wird diese automatisch gestartet, wenn das Paket geladen wird.  Und um noch weiter zu verwirren: Wenn in einer Datei mehrere Funktionen mit dem Namen init oder mehrere Dateien in einem Paket vorhanden sind, werden alle gestartet. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Init-Funktionen sind häufig mit leeren Importen verbunden.  Go hat eine spezielle Methode zum Deklarieren von Importen, die wie "import _" github.com / lib / pq "aussieht.  Wenn Sie eine leere Namenskennung für ein importiertes Paket festlegen, wird die init-Methode darin ausgeführt, es werden jedoch keine der Paketkennungen angezeigt.  Bei einigen Go-Bibliotheken - wie Datenbanktreibern oder Bildformaten - müssen Sie diese laden, indem Sie den Import leerer Pakete aktivieren, um die Init-Funktion aufzurufen, damit das Paket seinen Code registrieren kann. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Und dies ist eindeutig eine „böse“ Option.  Wenn Sie die Initialisierung verwenden, liegt Code, der magisch funktioniert, vollständig außerhalb der Kontrolle des Entwicklers.  In Best Practices wird die Verwendung der Initialisierungsfunktionen nicht empfohlen. Dies sind nicht offensichtliche Funktionen, sie verwirren den Code und lassen sich leicht in der Bibliothek ausblenden. <br><br>  Mit anderen Worten, Init-Funktionen sind ideal für unsere bösen Zwecke.  Anstatt Entitäten explizit in Paketen zu konfigurieren oder zu registrieren, können Sie die Initialisierungs- und Leerimportfunktionen verwenden, um den Status Ihrer Anwendung zu konfigurieren.  In diesem Beispiel stellen wir das Konto dem Rest der Anwendung über die Registrierung zur Verfügung, und das Paket selbst wird mithilfe der Init-Funktion in der Registrierung abgelegt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Wenn Sie ein Konto verwenden möchten, fügen Sie einen leeren Import in Ihr Programm ein.  Es muss nicht der Haupt- oder verwandte Code sein - es muss nur "irgendwo" sein.  Das ist Magie! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Wenn Sie inits in Ihren Bibliotheken verwenden, um Abhängigkeiten zu konfigurieren, werden Sie sofort feststellen, dass andere Entwickler sich nicht sicher sind, wie diese Abhängigkeiten installiert wurden und wie sie geändert werden können.  Und niemand wird klüger sein als Sie. <br><br><h3>  Komplizierte Konfiguration </h3><br>  Es gibt noch viel von allem, was wir mit der Konfiguration tun können.  Wenn Sie ein "guter" Go-Entwickler sind, sollten Sie die Konfiguration vom Rest des Programms isolieren.  In der Funktion main () erhalten Sie Variablen aus der Umgebung und konvertieren sie in die Werte, die für Komponenten benötigt werden, die explizit miteinander verknüpft sind.  Ihre Komponenten wissen nichts über Konfigurationsdateien oder deren Eigenschaften.  Für einfache Komponenten legen Sie öffentliche Eigenschaften fest, und für komplexere können Sie eine Factory-Funktion erstellen, die Konfigurationsinformationen empfängt und eine korrekt konfigurierte Komponente zurückgibt. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Aber die "bösen" Entwickler wissen, dass es besser ist, die Informationen über die Konfiguration im gesamten Programm zu verteilen.  Verwenden Sie anstelle einer Funktion in einem Paket, die die Namen und Werttypen für Ihr Paket definiert, eine Funktion, die die Konfiguration unverändert verwendet und selbst konvertiert. <br><br>  Wenn dies zu "böse" erscheint, verwenden Sie die Init-Funktion, um die Eigenschaftendatei aus Ihrem Paket zu laden und die Werte selbst festzulegen.  Es mag den Anschein haben, als hätten Sie anderen Entwicklern das Leben leichter gemacht, aber Sie und ich wissen ... <br><br>  Mit der Init-Funktion können Sie neue Eigenschaften im hinteren Teil des Codes definieren, und niemand wird sie jemals finden, bis sie in Produktion gehen und alles abfällt, da etwas nicht in eine der Dutzenden von Eigenschaftendateien gelangt, die zum Ausführen benötigt werden.  Wenn Sie noch mehr "böse Macht" wollen, können Sie vorschlagen, ein Wiki zu erstellen, um alle Eigenschaften in allen Bibliotheken zu verfolgen und regelmäßig neue zu "vergessen".  Als Property Keeper sind Sie die einzige Person, die die Software ausführen kann. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Funktionsrahmen </h3><br>  Schließlich kommen wir zum Thema Frameworks vs Bibliotheken.  Der Unterschied ist sehr subtil.  Es geht nicht nur um Größe;  Sie können große Bibliotheken und kleine Frameworks haben.  Das Framework ruft Ihren Code auf, während Sie den Bibliothekscode selbst aufrufen.  Bei Frameworks müssen Sie Ihren Code auf eine bestimmte Weise schreiben, unabhängig davon, ob Sie Ihre Methoden nach bestimmten Regeln benennen oder ob sie bestimmten Schnittstellen entsprechen, oder Sie müssen Ihren Code im Framework registrieren.  Frameworks haben ihre eigenen Anforderungen für Ihren gesamten Code.  Das heißt, Frameworks befehlen Ihnen im Allgemeinen. <br><br>  Go fördert die Verwendung von Bibliotheken, da Bibliotheken verknüpft sind.  Obwohl natürlich jede Bibliothek erwartet, dass Daten in einem bestimmten Format übertragen werden, können Sie einen Verbindungscode schreiben, um die Ausgabe einer Bibliothek in eine Eingabe für eine andere umzuwandeln. <br>  Es ist schwierig, Frameworks dazu zu bringen, nahtlos zusammenzuarbeiten, da jedes Framework die vollständige Kontrolle über den Codelebenszyklus wünscht.  Oft besteht die einzige Möglichkeit, Frameworks zur Zusammenarbeit zu bringen, darin, dass die Framework-Autoren zusammenkommen und die gegenseitige Unterstützung klar organisieren.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und der beste Weg, die „bösen Frameworks“ zu nutzen, um langfristig an Macht zu gewinnen, besteht darin, ein eigenes Framework zu schreiben, das nur innerhalb des Unternehmens verwendet wird. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gegenwärtiges und zukünftiges Übel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diese Tricks gemeistert haben, werden Sie sich für immer auf den Weg des Bösen begeben. </font><font style="vertical-align: inherit;">Im zweiten Teil werde ich zeigen, wie man all dieses "Böse" einsetzt und wie man den "guten" Code korrekt in "böse" umwandelt.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460645/">https://habr.com/ru/post/de460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460633/index.html">Implementierungsdetails für RSTP und Proprietary Extended Ring Redundancy</a></li>
<li><a href="../de460635/index.html">CLRium # 6: Parallelität und Parallelität. Zwei Tage: vom Prozessor zum Async / Warten</a></li>
<li><a href="../de460637/index.html">Lichtsteuerung auf ZigBee</a></li>
<li><a href="../de460641/index.html">YouTokenToMe: Ein Tool zur schnellen Tokenisierung von Text aus dem VKontakte-Team</a></li>
<li><a href="../de460643/index.html">Gleichmäßige Verteilung der Punkte auf einer Kugel</a></li>
<li><a href="../de460647/index.html">Lösen eines Jobs mit pwnable.kr 05 - Passcode. Schreiben Sie die Prozedur-Link-Tabelle über die Sicherheitsanfälligkeit bezüglich Formatzeichenfolgen neu</a></li>
<li><a href="../de460651/index.html">Treffen der Society of Anonymous Testers: TMS, Überwachung, Überwachung der Bewertung der Suchqualität und native iOS-Tests</a></li>
<li><a href="../de460655/index.html">Wie ich Telegramm gebrochen habe</a></li>
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie über Node.js wissen müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>