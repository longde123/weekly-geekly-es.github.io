<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª üôãüèΩ ‚ö†Ô∏è Gutes tun, schlechtes tun: Schlechten Code mit Go schreiben, Teil 1 üë®üèæ‚Äçü§ù‚Äçüë®üèΩ ‚òéÔ∏è üë©üèª‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schlechte Tipps f√ºr einen Go-Programmierer 


 Nach Jahrzehnten der Programmierung in Java habe ich in den letzten Jahren haupts√§chlich an Go gearbeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gutes tun, schlechtes tun: Schlechten Code mit Go schreiben, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Schlechte Tipps f√ºr einen Go-Programmierer</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="Bild"><br><br>  Nach Jahrzehnten der Programmierung in Java habe ich in den letzten Jahren haupts√§chlich an Go gearbeitet.  Die Arbeit mit Go ist gro√üartig, vor allem, weil der Code sehr einfach zu befolgen ist.  Java hat das C ++ - Programmiermodell vereinfacht, indem Mehrfachvererbung, manuelle Speicherverwaltung und Operator√ºberladung entfernt wurden.  Go macht dasselbe und bewegt sich weiterhin in Richtung eines einfachen und verst√§ndlichen Programmierstils, wobei Vererbung und Funktions√ºberladung vollst√§ndig beseitigt werden.  Einfacher Code ist lesbarer Code, und lesbarer Code ist unterst√ºtzter Code.  Und das ist gro√üartig f√ºr das Unternehmen und meine Mitarbeiter. <br><br>  Wie in allen Kulturen hat die Softwareentwicklung ihre eigenen Legenden, Geschichten, die vom Wasserk√ºhler nacherz√§hlt werden.  Wir haben alle von Entwicklern geh√∂rt, die sich nicht darauf konzentrieren, ein Qualit√§tsprodukt zu entwickeln, sondern ihre eigene Arbeit vor Au√üenstehenden sch√ºtzen wollen.  Sie ben√∂tigen keinen unterst√ºtzten Code, da dies bedeutet, dass andere Personen ihn verstehen und √§ndern k√∂nnen.  Ist es auf Go m√∂glich?  Ist es m√∂glich, Go-Code so kompliziert zu machen?  Ich werde gleich sagen - das ist keine leichte Aufgabe.  Schauen wir uns die m√∂glichen Optionen an. <br><a name="habracut"></a><br>  Sie denken: ‚Äû <i>Wie viel k√∂nnen Sie Code in einer Programmiersprache korrodieren?</i>  <i>Ist es m√∂glich, so schrecklichen Code auf Go zu schreiben, dass sein Autor im Unternehmen unverzichtbar wird?</i>  " Keine Sorge.  Als ich Student war, hatte ich ein Projekt, in dem ich den Lisp-e-Code eines anderen unterst√ºtzte, der von einem Doktoranden geschrieben wurde.  Tats√§chlich gelang es ihm, Fortran-e-Code mit Lisp zu schreiben.  Der Code sah ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Es gab Dutzende von Dateien mit solchem ‚Äã‚ÄãCode.  Er war absolut schrecklich und absolut brillant zugleich.  Ich habe Monate damit verbracht, es herauszufinden.  Im Vergleich dazu ist das Schreiben von schlechtem Code auf Go nur ein Spucke. <br><br>  Es gibt viele verschiedene M√∂glichkeiten, Ihren Code nicht zu unterst√ºtzen, aber wir werden nur einige betrachten.  Um B√∂ses zu tun, m√ºssen Sie zuerst lernen, Gutes zu tun.  Deshalb schauen wir uns zuerst an, wie die "guten" Go-Programmierer schreiben, und dann schauen wir uns an, wie man das Gegenteil macht. <br><br><h3>  Schlechte Verpackung </h3><br>  Pakete sind ein praktisches Thema f√ºr den Einstieg.  Wie kann die Code-Organisation die Lesbarkeit beeintr√§chtigen? <br><br>  In Go wird der Paketname verwendet, um auf die exportierte Entit√§t zu verweisen (z. B. " <i>fmt.Println"</i> oder " <i>http.RegisterFunc"</i> ).  Da wir den Namen des Pakets sehen k√∂nnen, stellen die "guten" Go-Programmierer sicher, dass dieser Name die exportierten Entit√§ten beschreibt.  Wir sollten keine util-Pakete haben, da Namen wie " <i>util.JSONMarshal"</i> f√ºr uns nicht funktionieren - wir brauchen " <i>json.Marshal"</i> . <br><br>  Die "guten" Go-Entwickler erstellen auch kein separates Paket f√ºr das DAO oder Modell.  F√ºr diejenigen, die mit diesem Begriff nicht vertraut sind, ist ein DAO ein ‚Äû <i>Datenzugriffsobjekt</i> ‚Äú - eine Codeebene, die mit Ihrer Datenbank interagiert.  Ich habe f√ºr ein Unternehmen gearbeitet, in dem 6 Java-Dienste dieselbe DAO-Bibliothek importiert haben, um auf dieselbe Datenbank zuzugreifen, die sie gemeinsam genutzt haben, weil " <i>... nun, Sie wissen, Microservices sind dieselben ...</i> ". <br><br>  Wenn Sie ein separates Paket mit all Ihren DAOs haben, ist es wahrscheinlicher, dass Sie eine zirkul√§re Abh√§ngigkeit zwischen Paketen erhalten, die in Go verboten ist.  Wenn Sie √ºber mehrere Dienste verf√ºgen, die dieses DAO-Paket als Bibliothek verbinden, kann es auch vorkommen, dass bei einer √Ñnderung eines Dienstes alle Ihre Dienste aktualisiert werden m√ºssen, da sonst ein Fehler auftritt.  Dies wird als verteilter Monolith bezeichnet und ist unglaublich schwer zu aktualisieren. <br><br>  Wenn Sie wissen, wie Verpackungen funktionieren sollten und was sie noch schlimmer macht, wird es einfach, ‚Äûdem B√∂sen zu dienen‚Äú.  Organisieren Sie Ihren Code schlecht und geben Sie Ihren Paketen schlechte Namen.  <i>Teilen Sie</i> Ihren Code in Pakete wie <i>model</i> , <i>util</i> und <i>dao auf</i> .  Wenn Sie wirklich Chaos schaffen m√∂chten, versuchen Sie, Pakete zu Ehren Ihrer Katze oder Ihrer Lieblingsfarbe zu erstellen.  Wenn Menschen mit zyklischen Abh√§ngigkeiten oder verteilten Monolithen konfrontiert sind, weil sie versuchen, Ihren Code zu verwenden, m√ºssen Sie seufzen, die Augen verdrehen und ihnen sagen, dass sie einfach falsch machen ... <br><br><h3>  Unangemessene Schnittstellen </h3><br>  Nachdem alle unsere Pakete besch√§digt sind, k√∂nnen wir zu den Schnittstellen √ºbergehen.  Schnittstellen in Go sind nicht wie Schnittstellen in anderen Sprachen.  Die Tatsache, dass Sie nicht explizit deklarieren, dass dieser Typ die Schnittstelle implementiert, scheint zun√§chst unbedeutend zu sein, kehrt jedoch das Konzept der Schnittstellen vollst√§ndig um. <br><br>  In den meisten Sprachen mit abstrakten Typen wird eine Schnittstelle vor oder gleichzeitig mit der Implementierung definiert.  Sie m√ºssen dies zumindest zum Testen tun.  Wenn Sie die Schnittstelle nicht im Voraus erstellen, k√∂nnen Sie sie sp√§ter nicht einf√ºgen, ohne den gesamten Code zu besch√§digen, der diese Klasse verwendet.  Weil Sie es mit einem Link zur Schnittstelle anstelle eines bestimmten Typs neu schreiben m√ºssen. <br><br>  Aus diesem Grund verf√ºgt Java-Code h√§ufig √ºber gigantische Dienstschnittstellen mit vielen Methoden.  Klassen, die diese Schnittstellen implementieren, verwenden dann die ben√∂tigten Methoden und ignorieren den Rest.  Das Schreiben von Tests ist m√∂glich, Sie f√ºgen jedoch eine zus√§tzliche Abstraktionsebene hinzu. Beim Schreiben von Tests verwenden Sie h√§ufig Tools, um Implementierungen der Methoden zu generieren, die Sie nicht ben√∂tigen. <br><br>  In Go bestimmen implizite Schnittstellen, welche Methoden Sie verwenden m√ºssen.  Code besitzt eine Schnittstelle, nicht umgekehrt.  Selbst wenn Sie einen Typ mit vielen darin definierten Methoden verwenden, k√∂nnen Sie eine Schnittstelle angeben, die nur die von Ihnen ben√∂tigten Methoden enth√§lt.  Ein anderer Code, der separate Felder desselben Typs verwendet, definiert andere Schnittstellen, die nur die erforderliche Funktionalit√§t abdecken.  In der Regel verf√ºgen diese Schnittstellen nur √ºber einige Methoden. <br><br>  Dies erleichtert das Verst√§ndnis Ihres Codes, da eine Methodendeklaration nicht nur bestimmt, welche Daten ben√∂tigt werden, sondern auch genau angibt, welche Funktionen verwendet werden sollen.  Dies ist einer der Gr√ºnde, warum gute Go-Entwickler den Rat befolgen: " <i>Schnittstellen akzeptieren, Strukturen zur√ºckgeben</i> ." <br><br>  Aber nur weil dies eine gute Praxis ist, hei√üt das nicht, dass Sie das tun sollten ... <br>  Der beste Weg, um Ihre Schnittstellen "b√∂se" zu machen, besteht darin, zu den Prinzipien der Verwendung von Schnittstellen aus anderen Sprachen zur√ºckzukehren, d. H.  Definieren Sie Schnittstellen im Voraus als Teil des aufgerufenen Codes.  Definieren Sie gro√üe Schnittstellen mit vielen Methoden, die von allen Service-Clients verwendet werden.  Es wird unklar, welche Methoden wirklich ben√∂tigt werden.  Dies verkompliziert den Code, und wie Sie wissen, ist die Komplikation der beste Freund eines ‚Äûb√∂sen‚Äú Programmierers. <br><br><h3>  √úbergeben Sie Heap-Zeiger </h3><br>  Bevor Sie erkl√§ren, was dies bedeutet, m√ºssen Sie ein wenig philosophieren.  Wenn Sie ablenken und nachdenken, macht jedes geschriebene Programm dasselbe.  Es empf√§ngt Daten, verarbeitet sie und sendet die verarbeiteten Daten an einen anderen Ort.  Dies gilt unabh√§ngig davon, ob Sie ein Abrechnungssystem schreiben, HTTP-Anforderungen akzeptieren und Webseiten zur√ºckgeben oder sogar den Joystick √ºberpr√ºfen, um einen Klick auf eine Schaltfl√§che zu verfolgen - Programme verarbeiten die Daten. <br><br>  Wenn wir die Programme auf diese Weise betrachten, ist es am wichtigsten sicherzustellen, dass wir leicht verstehen, wie die Daten konvertiert werden.  Es empfiehlt sich daher, die Daten w√§hrend des Programms so lange wie m√∂glich unver√§ndert zu lassen.  Denn Daten, die sich nicht √§ndern, sind Daten, die leicht zu verfolgen sind. <br><br>  In Go haben wir Referenztypen und Werttypen.  Der Unterschied zwischen den beiden besteht darin, ob sich die Variable auf eine Kopie der Daten oder auf den Speicherort der Daten im Speicher bezieht.  Zeiger, Slices, Maps, Kan√§le, Schnittstellen und Funktionen sind Referenztypen, und alles andere ist ein Werttyp.  Wenn Sie einer anderen Variablen eine Werttypvariable zuweisen, wird eine Kopie des Werts erstellt.  Durch √Ñndern einer Variablen wird der Wert einer anderen Variablen nicht ge√§ndert. <br><br>  Das Zuweisen einer Variablen eines Referenztyps zu einer anderen Variablen eines Referenztyps bedeutet, dass beide denselben Speicherbereich verwenden. Wenn Sie also die Daten √§ndern, auf die der erste zeigt, √§ndern Sie die Daten, auf die der zweite zeigt.  Dies gilt sowohl f√ºr lokale Variablen als auch f√ºr Funktionsparameter. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Kind Go-Entwickler m√∂chten es einfacher machen zu verstehen, wie Daten gesammelt werden.  Sie versuchen, den Wertetyp so oft wie m√∂glich als Parameter f√ºr Funktionen zu verwenden.  In Go gibt es keine M√∂glichkeit, Felder in Strukturen oder Funktionsparametern als endg√ºltig zu markieren.  Wenn eine Funktion Wertparameter verwendet, werden durch √Ñndern der Parameter die Variablen in der aufrufenden Funktion nicht ge√§ndert.  Die aufgerufene Funktion kann lediglich den Wert an die aufrufende Funktion zur√ºckgeben.  Wenn Sie also eine Struktur ausf√ºllen, indem Sie eine Funktion mit Wertparametern aufrufen, k√∂nnen Sie keine Angst haben, Daten an die Struktur zu √ºbertragen, da Sie verstehen, woher jedes Feld in der Struktur stammt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Wie werden wir "b√∂se"?  Sehr einfach - dieses Modell umdrehen. <br><br>  Anstatt Funktionen aufzurufen, die die gew√ºnschten Werte zur√ºckgeben, √ºbergeben Sie einen Zeiger auf die Struktur in der Funktion und lassen sie √Ñnderungen an der Struktur vornehmen.  Da jede Funktion ihre eigene Struktur hat, k√∂nnen Sie nur herausfinden, welche Felder sich √§ndern, indem Sie den gesamten Code betrachten.  M√∂glicherweise haben Sie auch implizite Abh√§ngigkeiten zwischen Funktionen - die 1. Funktion √ºbertr√§gt die von der 2. Funktion ben√∂tigten Daten.  Aber im Code selbst gibt nichts an, dass Sie zuerst die 1. Funktion aufrufen sollten.  Wenn Sie Ihre Datenstrukturen auf diese Weise erstellen, k√∂nnen Sie sicher sein, dass niemand versteht, was Ihr Code tut. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Panik taucht auf </h3><br>  Jetzt fangen wir an, mit Fehlern umzugehen.  Sie denken wahrscheinlich, dass es schlecht ist, Programme zu schreiben, die Fehler zu 75% behandeln, und ich kann nicht sagen, dass Sie falsch liegen.  Go-Code wird h√§ufig mit einer Fehlerbehandlung von Kopf bis Fu√ü gef√ºllt.  Und nat√ºrlich w√§re es bequem, sie nicht so einfach zu verarbeiten.  Fehler passieren, und der Umgang mit ihnen unterscheidet Profis von Anf√§ngern.  Eine verschwommene Fehlerbehandlung f√ºhrt zu instabilen Programmen, die schwer zu debuggen und schwer zu warten sind.  Manchmal bedeutet ein "guter" Programmierer "anstrengen". <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Viele Sprachen wie C ++, Python, Ruby und Java verwenden Ausnahmen, um Fehler zu behandeln.  Wenn etwas schief geht, l√∂sen Entwickler in diesen Sprachen eine Ausnahme aus oder erwarten, dass Code damit umgeht.  Nat√ºrlich erwartet das Programm, dass dem Client ein m√∂glicher Fehler bekannt ist, der an einem bestimmten Ort ausgel√∂st wird, so dass es m√∂glich ist, eine Ausnahme auszul√∂sen.  Da au√üer (ohne Wortspiel beabsichtigt) von Java gepr√ºften Ausnahmen nichts in der Methodensignatur in Sprachen oder Funktionen darauf hinweist, dass eine Ausnahme auftreten kann.  Woher wissen Entwickler, √ºber welche Ausnahmen sie sich Sorgen machen m√ºssen?  Sie haben zwei M√∂glichkeiten: <br><br><ul><li>  Erstens k√∂nnen sie den gesamten Quellcode aller Bibliotheken lesen, die ihr Code aufruft, und alle Bibliotheken, die die aufgerufenen Bibliotheken usw. aufrufen. </li><li>  Zweitens k√∂nnen sie der Dokumentation vertrauen.  Ich bin vielleicht voreingenommen, aber aufgrund meiner pers√∂nlichen Erfahrung kann ich der Dokumentation nicht voll vertrauen. </li></ul><br>  Also, wie bringen wir dieses B√∂se zum Gehen?  Nat√ºrlich Panik ( <i>Panik</i> ) und Genesung ( <i>Genesung</i> ) missbrauchen!  Die Panik ist f√ºr Situationen wie "Das Laufwerk ist heruntergefallen" oder "Die Netzwerkkarte ist explodiert" ausgelegt.  Aber nicht f√ºr solche - "jemand hat String statt int √ºbergeben". <br><br>  Leider geben andere, "weniger aufgekl√§rte Entwickler" Fehler aus ihrem Code zur√ºck.  Hier ist eine kleine Hilfsfunktion von PanicIfErr.  Verwenden Sie es, um die Fehler anderer Entwickler in Panik zu versetzen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Sie k√∂nnen PanicIfErr verwenden, um die Fehler anderer Personen zu verpacken und Code zu komprimieren.  Keine h√§ssliche Fehlerbehandlung mehr!  Jeder Fehler ist jetzt eine Panik.  Es ist so produktiv! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Sie k√∂nnen die Wiederherstellung irgendwo n√§her am Anfang des Programms platzieren, m√∂glicherweise in Ihrer eigenen <i>Middleware</i> .  Und dann sagen Sie, dass Sie nicht nur Fehler verarbeiten, sondern auch den Code eines anderen sauberer machen.  B√∂ses durch Gutes tun ist die beste Art von B√∂sem. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Nebenwirkungen einstellen </h3><br>  Als n√§chstes werden wir einen Nebeneffekt erzeugen.  Denken Sie daran, dass der ‚Äûgute‚Äú Go-Entwickler verstehen m√∂chte, wie die Daten das Programm durchlaufen.  Der beste Weg, um zu wissen, was die Daten durchlaufen, besteht darin, explizite Abh√§ngigkeiten in der Anwendung einzurichten.  Selbst Entit√§ten, die derselben Schnittstelle entsprechen, k√∂nnen sich im Verhalten stark unterscheiden.  Zum Beispiel ein Code, der Daten im Speicher speichert, und ein Code, der f√ºr dieselbe Arbeit auf die Datenbank zugreift.  Es gibt jedoch M√∂glichkeiten, Abh√§ngigkeiten in Go ohne explizite Aufrufe zu installieren. <br><br>  Wie viele andere Sprachen bietet Go die M√∂glichkeit, Code auf magische Weise auszuf√ºhren, ohne ihn direkt aufzurufen.  Wenn Sie eine Funktion namens init ohne Parameter erstellen, wird diese automatisch gestartet, wenn das Paket geladen wird.  Und um noch weiter zu verwirren: Wenn in einer Datei mehrere Funktionen mit dem Namen init oder mehrere Dateien in einem Paket vorhanden sind, werden alle gestartet. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Init-Funktionen sind h√§ufig mit leeren Importen verbunden.  Go hat eine spezielle Methode zum Deklarieren von Importen, die wie "import _" github.com / lib / pq "aussieht.  Wenn Sie eine leere Namenskennung f√ºr ein importiertes Paket festlegen, wird die init-Methode darin ausgef√ºhrt, es werden jedoch keine der Paketkennungen angezeigt.  Bei einigen Go-Bibliotheken - wie Datenbanktreibern oder Bildformaten - m√ºssen Sie diese laden, indem Sie den Import leerer Pakete aktivieren, um die Init-Funktion aufzurufen, damit das Paket seinen Code registrieren kann. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Und dies ist eindeutig eine ‚Äûb√∂se‚Äú Option.  Wenn Sie die Initialisierung verwenden, liegt Code, der magisch funktioniert, vollst√§ndig au√üerhalb der Kontrolle des Entwicklers.  In Best Practices wird die Verwendung der Initialisierungsfunktionen nicht empfohlen. Dies sind nicht offensichtliche Funktionen, sie verwirren den Code und lassen sich leicht in der Bibliothek ausblenden. <br><br>  Mit anderen Worten, Init-Funktionen sind ideal f√ºr unsere b√∂sen Zwecke.  Anstatt Entit√§ten explizit in Paketen zu konfigurieren oder zu registrieren, k√∂nnen Sie die Initialisierungs- und Leerimportfunktionen verwenden, um den Status Ihrer Anwendung zu konfigurieren.  In diesem Beispiel stellen wir das Konto dem Rest der Anwendung √ºber die Registrierung zur Verf√ºgung, und das Paket selbst wird mithilfe der Init-Funktion in der Registrierung abgelegt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Wenn Sie ein Konto verwenden m√∂chten, f√ºgen Sie einen leeren Import in Ihr Programm ein.  Es muss nicht der Haupt- oder verwandte Code sein - es muss nur "irgendwo" sein.  Das ist Magie! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Wenn Sie inits in Ihren Bibliotheken verwenden, um Abh√§ngigkeiten zu konfigurieren, werden Sie sofort feststellen, dass andere Entwickler sich nicht sicher sind, wie diese Abh√§ngigkeiten installiert wurden und wie sie ge√§ndert werden k√∂nnen.  Und niemand wird kl√ºger sein als Sie. <br><br><h3>  Komplizierte Konfiguration </h3><br>  Es gibt noch viel von allem, was wir mit der Konfiguration tun k√∂nnen.  Wenn Sie ein "guter" Go-Entwickler sind, sollten Sie die Konfiguration vom Rest des Programms isolieren.  In der Funktion main () erhalten Sie Variablen aus der Umgebung und konvertieren sie in die Werte, die f√ºr Komponenten ben√∂tigt werden, die explizit miteinander verkn√ºpft sind.  Ihre Komponenten wissen nichts √ºber Konfigurationsdateien oder deren Eigenschaften.  F√ºr einfache Komponenten legen Sie √∂ffentliche Eigenschaften fest, und f√ºr komplexere k√∂nnen Sie eine Factory-Funktion erstellen, die Konfigurationsinformationen empf√§ngt und eine korrekt konfigurierte Komponente zur√ºckgibt. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Aber die "b√∂sen" Entwickler wissen, dass es besser ist, die Informationen √ºber die Konfiguration im gesamten Programm zu verteilen.  Verwenden Sie anstelle einer Funktion in einem Paket, die die Namen und Werttypen f√ºr Ihr Paket definiert, eine Funktion, die die Konfiguration unver√§ndert verwendet und selbst konvertiert. <br><br>  Wenn dies zu "b√∂se" erscheint, verwenden Sie die Init-Funktion, um die Eigenschaftendatei aus Ihrem Paket zu laden und die Werte selbst festzulegen.  Es mag den Anschein haben, als h√§tten Sie anderen Entwicklern das Leben leichter gemacht, aber Sie und ich wissen ... <br><br>  Mit der Init-Funktion k√∂nnen Sie neue Eigenschaften im hinteren Teil des Codes definieren, und niemand wird sie jemals finden, bis sie in Produktion gehen und alles abf√§llt, da etwas nicht in eine der Dutzenden von Eigenschaftendateien gelangt, die zum Ausf√ºhren ben√∂tigt werden.  Wenn Sie noch mehr "b√∂se Macht" wollen, k√∂nnen Sie vorschlagen, ein Wiki zu erstellen, um alle Eigenschaften in allen Bibliotheken zu verfolgen und regelm√§√üig neue zu "vergessen".  Als Property Keeper sind Sie die einzige Person, die die Software ausf√ºhren kann. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Funktionsrahmen </h3><br>  Schlie√ülich kommen wir zum Thema Frameworks vs Bibliotheken.  Der Unterschied ist sehr subtil.  Es geht nicht nur um Gr√∂√üe;  Sie k√∂nnen gro√üe Bibliotheken und kleine Frameworks haben.  Das Framework ruft Ihren Code auf, w√§hrend Sie den Bibliothekscode selbst aufrufen.  Bei Frameworks m√ºssen Sie Ihren Code auf eine bestimmte Weise schreiben, unabh√§ngig davon, ob Sie Ihre Methoden nach bestimmten Regeln benennen oder ob sie bestimmten Schnittstellen entsprechen, oder Sie m√ºssen Ihren Code im Framework registrieren.  Frameworks haben ihre eigenen Anforderungen f√ºr Ihren gesamten Code.  Das hei√üt, Frameworks befehlen Ihnen im Allgemeinen. <br><br>  Go f√∂rdert die Verwendung von Bibliotheken, da Bibliotheken verkn√ºpft sind.  Obwohl nat√ºrlich jede Bibliothek erwartet, dass Daten in einem bestimmten Format √ºbertragen werden, k√∂nnen Sie einen Verbindungscode schreiben, um die Ausgabe einer Bibliothek in eine Eingabe f√ºr eine andere umzuwandeln. <br>  Es ist schwierig, Frameworks dazu zu bringen, nahtlos zusammenzuarbeiten, da jedes Framework die vollst√§ndige Kontrolle √ºber den Codelebenszyklus w√ºnscht.  Oft besteht die einzige M√∂glichkeit, Frameworks zur Zusammenarbeit zu bringen, darin, dass die Framework-Autoren zusammenkommen und die gegenseitige Unterst√ºtzung klar organisieren.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und der beste Weg, die ‚Äûb√∂sen Frameworks‚Äú zu nutzen, um langfristig an Macht zu gewinnen, besteht darin, ein eigenes Framework zu schreiben, das nur innerhalb des Unternehmens verwendet wird. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gegenw√§rtiges und zuk√ºnftiges √úbel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diese Tricks gemeistert haben, werden Sie sich f√ºr immer auf den Weg des B√∂sen begeben. </font><font style="vertical-align: inherit;">Im zweiten Teil werde ich zeigen, wie man all dieses "B√∂se" einsetzt und wie man den "guten" Code korrekt in "b√∂se" umwandelt.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460645/">https://habr.com/ru/post/de460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460633/index.html">Implementierungsdetails f√ºr RSTP und Proprietary Extended Ring Redundancy</a></li>
<li><a href="../de460635/index.html">CLRium # 6: Parallelit√§t und Parallelit√§t. Zwei Tage: vom Prozessor zum Async / Warten</a></li>
<li><a href="../de460637/index.html">Lichtsteuerung auf ZigBee</a></li>
<li><a href="../de460641/index.html">YouTokenToMe: Ein Tool zur schnellen Tokenisierung von Text aus dem VKontakte-Team</a></li>
<li><a href="../de460643/index.html">Gleichm√§√üige Verteilung der Punkte auf einer Kugel</a></li>
<li><a href="../de460647/index.html">L√∂sen eines Jobs mit pwnable.kr 05 - Passcode. Schreiben Sie die Prozedur-Link-Tabelle √ºber die Sicherheitsanf√§lligkeit bez√ºglich Formatzeichenfolgen neu</a></li>
<li><a href="../de460651/index.html">Treffen der Society of Anonymous Testers: TMS, √úberwachung, √úberwachung der Bewertung der Suchqualit√§t und native iOS-Tests</a></li>
<li><a href="../de460655/index.html">Wie ich Telegramm gebrochen habe</a></li>
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie √ºber Node.js wissen m√ºssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>