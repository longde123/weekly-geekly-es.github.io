<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõüèΩ üßíüèø üçß Crea un juego de disparos de zombis en tercera persona con DOTS üë©üèª‚Äçüé§ üöô üç∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saludo, Khabrovsk. Como ya escribimos, enero est√° lleno de nuevos lanzamientos y hoy anunciamos un set para un nuevo curso de OTUS: "Game Developer fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea un juego de disparos de zombis en tercera persona con DOTS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484094/">  <i>Saludo, Khabrovsk.</i>  <i>Como ya escribimos, enero est√° lleno de nuevos lanzamientos y hoy anunciamos un set para un nuevo curso de OTUS: <a href="https://otus.pw/YRoY/">"Game Developer for Unity"</a> .</i>  <i>En previsi√≥n del inicio del curso, compartimos con usted la traducci√≥n de material interesante.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/o-/2d/iz/o-2diz_bo0cjb7cksohmc8zeoxc.png"><br><br><hr><blockquote>  Estamos reconstruyendo el n√∫cleo de Unity con nuestra <a href="https://unity.com/dots%3F_ga%3D2.241875339.889742683.1579017753-927430519.1579017753">pila tecnol√≥gica orientada a datos</a> .  Al igual que muchos estudios de juegos, tambi√©n vemos grandes ventajas en el uso del Sistema de componentes de entidad (ECS), el Sistema de tareas C # (Sistema de trabajos C #) y el Compilador de r√°fagas.  En Unite Copenhagen, tuvimos la oportunidad de conversar con Far North Entertainment y profundizar en c√≥mo implementan esta funcionalidad DOTS en los proyectos tradicionales de Unity. </blockquote><a name="habracut"></a>  Far North Entertainment es un estudio sueco en copropiedad de cinco amigos de ingenier√≠a.  Desde el lanzamiento de Down to Dungeon para Gear VR a principios de 2018, la compa√±√≠a ha estado trabajando en un juego que pertenece al g√©nero cl√°sico de los juegos de PC, a saber, un juego post-apocal√≠ptico en modo de supervivencia zombie.  Lo que diferencia al proyecto de los dem√°s es la cantidad de zombis que te persiguen.  La visi√≥n del equipo a este respecto atrajo a miles de zombis hambrientos que te segu√≠an en enormes hordas. <br><br>  Sin embargo, r√°pidamente se encontraron con muchos problemas de rendimiento ya en la etapa de creaci√≥n de prototipos.  Crear, morir, actualizar y animar a todo este n√∫mero de enemigos sigui√≥ siendo el principal cuello de botella, incluso despu√©s de que el equipo intentara resolver el problema con la <i>agrupaci√≥n</i> <i>oblect</i> y una <i>instancia de nimation</i> . <br><br>  Esto oblig√≥ al director t√©cnico del estudio, Andr√©s Ericsson, a centrar su atenci√≥n en DOTS y cambiar la mentalidad de orientada a objetos a orientada a datos.  "La idea clave que ayud√≥ a provocar este cambio fue que hab√≠a que dejar de pensar en objetos y jerarqu√≠as de objetos y comenzar a pensar en los datos, c√≥mo se est√°n transformando y c√≥mo acceder a ellos", dijo. .  Sus palabras significan que no es necesario construir una arquitectura de c√≥digo con la vista puesta en los objetos de la vida real de tal manera que resuelva el problema m√°s general y abstracto.  Tiene muchos consejos para aquellos que, como √©l, se enfrentan a un cambio en la visi√≥n del mundo: <br><br>  <i>‚ÄúPreg√∫ntese cu√°l es el verdadero problema que est√° tratando de resolver y qu√© datos son importantes para obtener una soluci√≥n.</i>  <i>¬øConvertir√°s el mismo conjunto de datos de la misma manera una y otra vez?</i>  <i>¬øCu√°ntos datos √∫tiles puede caber en una l√≠nea de la memoria cach√© del procesador?</i>  <i>Si realiza cambios en el c√≥digo existente, eval√∫e la cantidad de datos basura que agrega a la l√≠nea de cach√©.</i>  <i>¬øEs posible dividir los c√°lculos en varios hilos o necesito usar un solo flujo de comandos?</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QGM4feh0fRA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El equipo lleg√≥ a comprender que las entidades en el Sistema de componentes de Unity son solo identificadores de b√∫squeda en las secuencias de componentes.  Los componentes son solo datos, mientras que los sistemas contienen toda la l√≥gica y filtran entidades con una firma espec√≠fica, conocida como arquetipos.  ‚ÄúCreo que una de las ideas que nos ayud√≥ a visualizar nuestras ideas fue introducir ECS como una base de datos SQL.  Cada arquetipo es una tabla en la que cada columna es un componente, y cada fila es una entidad √∫nica.  En esencia, utiliza sistemas para crear consultas para estas tablas de arquetipos y realizar operaciones en entidades ", dice Anders. <br><br><h3>  Introduciendo DOTS </h3><br>  Para llegar a este entendimiento, estudi√≥ la documentaci√≥n para el sistema de <a href="https://docs.unity3d.com/Packages/com.unity.entities%400.1/manual/index.html%3F_ga%3D2.233150103.889742683.1579017753-927430519.1579017753">componentes</a> de la <a href="https://docs.unity3d.com/Packages/com.unity.entities%400.1/manual/index.html%3F_ga%3D2.233150103.889742683.1579017753-927430519.1579017753">entidad</a> , ejemplos de <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">ECS</a> y <a href="https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation">un ejemplo</a> que hicimos junto con Nordeus y presentamos en Unite Austin.  La informaci√≥n general sobre la arquitectura orientada a datos tambi√©n fue muy √∫til para el equipo.  "El <a href="https://www.youtube.com/watch%3Fv%3DrX0ItVEVjHc">informe de Mike Acton</a> sobre arquitectura centrada en datos con CppCon 2014 es exactamente lo que nos abri√≥ los ojos a esta forma de programaci√≥n". <br><br>  El equipo de Far North public√≥ lo que aprendieron en su <a href="http://www.farnorthentertainment.com/2019/04/10/what-we-have-been-up-to-why-ecs-is-the-way-to-gigantic-hordes/">Blog de desarrollo</a> , en septiembre de este a√±o vinieron a Copenhague para compartir sus experiencias con la transici√≥n a un enfoque orientado a datos en Unity. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yTGhg905SCs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este art√≠culo se basa en un informe, explica con m√°s detalle los detalles de su implementaci√≥n de ECS, el Sistema de tareas C # y el compilador Burst.  Far North tambi√©n comparti√≥ amablemente muchas muestras de c√≥digo de su proyecto. <br><br><h3>  Organizaci√≥n de datos de zombis </h3><br>  "El problema al que nos enfrentamos era interpolar los desplazamientos y rotaciones de miles de objetos en el lado del cliente", dice Anders.  Su enfoque inicial orientado a objetos fue crear un script <i>ZombieView</i> abstracto que heredara la clase padre gen√©rica <i>EntityView</i> .  <i>EntityView</i> es un <i>MonoBehaviour</i> conectado a un <i>GameObject</i> .  Act√∫a como una representaci√≥n visual del modelo de juego.  Cada <i>ZombieView</i> era responsable de manejar su propia interpolaci√≥n de movimiento y rotaci√≥n en su funci√≥n de <i>Actualizaci√≥n</i> . <br><br>  Esto suena normal, hasta que comprenda que cada entidad est√° ubicada en la memoria en un lugar arbitrario.  Esto significa que si est√° accediendo a miles de objetos, la CPU debe sacarlos de la memoria uno a la vez, y esto sucede extremadamente lento.  Si coloca sus datos en bloques ordenados en serie, el procesador puede almacenar en cach√© una gran cantidad de datos al mismo tiempo.  La mayor√≠a de los procesadores modernos pueden recibir aproximadamente 128 o 256 bits del cach√© en un ciclo. <br><br>  El equipo decidi√≥ convertir enemigos en DOTS con la esperanza de resolver los problemas de rendimiento del lado del cliente.  El primero en la l√≠nea fue la funci√≥n <i>Actualizar</i> en <i>ZombieView</i> .  El equipo determin√≥ qu√© partes deber√≠an dividirse en diferentes sistemas y determin√≥ los datos necesarios.  Lo primero y m√°s obvio fue la interpolaci√≥n de posiciones y giros, ya que el mundo del juego es una cuadr√≠cula bidimensional.  Dos variables flotantes son responsables de hacia d√≥nde van los zombis, y el √∫ltimo componente es la posici√≥n de destino, rastrea la posici√≥n del servidor para el enemigo. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> PositionData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Position; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HeadingData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Heading; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TargetPositionData : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 TargetPosition; }</code> </pre> <br>  El siguiente paso fue crear un arquetipo para los enemigos.  El arquetipo es un conjunto de componentes que pertenecen a una determinada entidad, en otras palabras, es la firma del componente. <br><br>  El proyecto utiliza prefabricados para determinar los arquetipos, ya que los enemigos requieren m√°s componentes, y algunos de ellos necesitan enlaces a <i>GameObject</i> .  Esto funciona para que pueda ajustar los datos de su componente en <i>ComponentDataProxy</i> , que lo convertir√° en <i>MonoBehaviour</i> , que a su vez se puede adjuntar al prefab.  Cuando crea una instancia con <i>EntityManager</i> y pasa el prefab, crea una entidad con todos los datos de los componentes que se adjuntaron al prefab.  Todos los datos de los componentes se almacenan en fragmentos de memoria de 16 kilobytes llamados <i>ArchetypeChunk</i> . <br><br>  Aqu√≠ hay una visualizaci√≥n de c√≥mo se organizar√°n los flujos de componentes en nuestro fragmento de arquetipo: <br><br><img src="https://habrastorage.org/webt/mh/cn/r9/mhcnr9qjgpsr6lkej2l0ezq0jmi.png"><br><br>  <i>"Una de las principales ventajas de los fragmentos de arquetipo es que a menudo no es necesario reasignar un mont√≥n al crear nuevos objetos, ya que la memoria ya se ha asignado de antemano.</i>  <i>Esto significa que crear entidades es escribir datos al final de los flujos de componentes dentro de fragmentos de arquetipo.</i>  <i>El √∫nico caso en el que es necesario volver a realizar la asignaci√≥n del mont√≥n es cuando se crea una entidad que no se ajusta a los bordes del fragmento.</i>  <i>En este caso, se iniciar√° la asignaci√≥n de un nuevo fragmento de un arquetipo de 16 KB de tama√±o, o si hay un fragmento vac√≠o del mismo arquetipo, puede reutilizarse.</i>  <i>Luego, los datos para los nuevos objetos se registrar√°n en los flujos de componentes del nuevo fragmento ‚Äù,</i> explica Anders. <br><br><h3>  El multihilo de tus zombies </h3><br>  Ahora que los datos estaban densamente empaquetados y colocados en la memoria de manera conveniente para el almacenamiento en cach√©, el equipo podr√≠a usar f√°cilmente el sistema de tareas C # para ejecutar su c√≥digo en varios n√∫cleos de CPU en paralelo. <br><br>  El siguiente paso fue crear un sistema que filtrara todas las entidades de todos los bloques de arquetipos que ten√≠an <i>componentes</i> <i>PositionData2D</i> , <i>HeadingData2D</i> y <i>TargetPositionData</i> . <br><br>  Para hacer esto, Anders y su equipo crearon <i>JobComponentSystem</i> y construyeron su solicitud en la funci√≥n <i>OnCreate</i> .  Se parece a esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EntityQuery m_Group; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnCreate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityQueryDesc { All = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { ComponentType.ReadWrite&lt;PositionData2D&gt;(), ComponentType.ReadWrite&lt;HeadingData2D&gt;(), ComponentType.ReadOnly&lt;TargetPositionData&gt;() }, }; m_Group = GetEntityQuery(query); }</code> </pre> <br>  El c√≥digo anuncia una solicitud que filtra todos los objetos del mundo que tienen una posici√≥n, direcci√≥n y prop√≥sito.  Luego, quer√≠an programar tareas para cada marco utilizando el sistema de tareas C # para distribuir los c√°lculos en varios flujos de trabajo. <br><br>  <i>"Lo mejor del sistema de tareas C # es que es el mismo sistema que usa Unity en su c√≥digo, por lo que no tuvimos que preocuparnos de que los hilos ejecutables se bloqueen entre s√≠, requieran los mismos n√∫cleos de procesador y causen problemas de rendimiento ",</i> Dice Anders. <br><br>  El equipo decidi√≥ usar <i>IJobChunk</i> , porque miles de enemigos implicaban la presencia de una gran cantidad de fragmentos de arquetipos que deber√≠an coincidir con la solicitud en tiempo de ejecuci√≥n.  <i>IJobChunk</i> distribuye los fragmentos correctos en varios flujos de trabajo. <br><br>  Cada cuadro, una nueva tarea <i>UpdatePositionAndHeadingJob,</i> es responsable de manejar la interpolaci√≥n de posiciones y turnos de enemigos en el juego. <br><br>  El c√≥digo para programar tareas es el siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> JobHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JobHandle inputDeps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionDataType = GetArchetypeChunkComponentType&lt;PositionData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingDataType = GetArchetypeChunkComponentType&lt;HeadingData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetPositionDataType = GetArchetypeChunkComponentType&lt;TargetPositionData&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatePosAndHeadingJob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UpdatePositionAndHeadingJob { PositionDataType = positionDataType, HeadingDataType = headingDataType, TargetPositionDataType = targetPositionDataType, DeltaTime = Time.deltaTime, RotationLerpSpeed = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, MovementLerpSpeed = <span class="hljs-number"><span class="hljs-number">4.0f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatePosAndHeadingJob.Schedule(m_Group, inputDeps); }</code> </pre> <br>  As√≠ es como se ve la tarea: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre> <br>  Cuando un subproceso de trabajo recupera una tarea de su cola, invoca el n√∫cleo de la tarea. <br><br>  As√≠ es como se ve el n√∫cleo de ejecuci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArchetypeChunk chunk, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstEntityIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkPositionData = chunk.GetNativeArray(PositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkHeadingData = chunk.GetNativeArray(HeadingDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkTargetPositionData = chunk.GetNativeArray(TargetPositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunk.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = chunkTargetPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionData = chunkPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingData = chunkHeadingData[i]; float2 toTarget = target.TargetPosition - positionData.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = math.length(toTarget); headingData.Heading = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( headingData.Heading, math.lerp(headingData.Heading, math.normalize(toTarget), math.mul(DeltaTime, RotationLerpSpeed)), distance &gt; <span class="hljs-number"><span class="hljs-number">0.008</span></span> ); positionData.Position = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( target.TargetPosition, math.lerp( positionData.Position, target.TargetPosition, math.mul(DeltaTime, MovementLerpSpeed)), distance &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ); chunkPositionData[i] = positionData; chunkHeadingData[i] = headingData; } }</code> </pre><br>  <i>‚ÄúPuede notar que usamos select en lugar de ramificaci√≥n, esto nos permite deshacernos del efecto llamado predicci√≥n de ramificaci√≥n incorrecta.</i>  <i>La funci√≥n select evaluar√° ambas expresiones y seleccionar√° la que coincida con la condici√≥n, y si sus expresiones no son tan dif√≠ciles de calcular, recomendar√≠a usar select, porque a menudo es m√°s barato que esperar que la CPU se recupere de una predicci√≥n de rama incorrecta ".</i> Anders <br><br><h3>  Aumenta la productividad con la explosi√≥n </h3><br>  El √∫ltimo paso para convertir DOTS a la posici√≥n enemiga y la interpolaci√≥n de rumbo es habilitar el compilador Burst.  La tarea le pareci√≥ bastante simple a Anders: "Dado que los datos se encuentran en matrices adyacentes y dado que utilizamos la nueva biblioteca de matem√°ticas de Unity, todo lo que tuvimos que hacer fue agregar el atributo <i>BurstCompile</i> a nuestra tarea". <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">BurstCompile</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre><br>  El compilador Burst nos proporciona datos m√∫ltiples de instrucci√≥n √∫nica (SIMD);  instrucciones de la m√°quina que pueden funcionar con m√∫ltiples conjuntos de datos de entrada y crear m√∫ltiples conjuntos de datos de salida con una sola instrucci√≥n.  Esto nos ayuda a llenar m√°s lugares en el bus de cach√© de 128 bits con los datos correctos.  El compilador Burst, combinado con un sistema de trabajo y composici√≥n de datos amigable con la cach√©, permiti√≥ al equipo aumentar significativamente la productividad.  Aqu√≠ est√° la tabla que compilaron midiendo el rendimiento despu√©s de cada paso de conversi√≥n. <br><br><img src="https://habrastorage.org/webt/bo/gu/8i/bogu8ir1i0apb5cwuhrjfjyk-bk.png"><br><br>  Esto signific√≥ que Far North se deshizo por completo de los problemas asociados con la interpolaci√≥n de la posici√≥n en el lado del cliente y la direcci√≥n de los zombies.  Sus datos ahora se almacenan en una forma conveniente para el almacenamiento en cach√©, y las l√≠neas de cach√© se llenan solo con datos √∫tiles.  La carga se distribuye a todos los n√∫cleos de la CPU, y el compilador Burst produce un c√≥digo de m√°quina altamente optimizado con instrucciones SIMD. <br><br><h4>  Far North Entertainment DOTS Consejos y trucos </h4><br><ul><li>  Comience a pensar en t√©rminos de flujos de datos, porque en ECS, las entidades son simplemente √≠ndices de b√∫squeda en flujos de datos de componentes paralelos. </li><li>  Imagine ECS como una base de datos relacional en la que los arquetipos son tablas, los componentes son columnas y las entidades son √≠ndices en una tabla (fila). </li><li>  Organice sus datos en arreglos secuenciales para usar la memoria cach√© del procesador y la captaci√≥n previa de hardware. </li><li>  Olv√≠date de querer crear jerarqu√≠as de objetos y tratar de encontrar una soluci√≥n com√∫n antes de comprender el problema real que est√°s tratando de resolver. </li><li>  Piensa en la recolecci√≥n de basura.  Evite la asignaci√≥n excesiva de montones en √°reas cr√≠ticas para el rendimiento.  Utilice los nuevos contenedores nativos de Unity en su lugar.  Pero tenga cuidado, debe lidiar con la limpieza manual. </li><li>  Reconozca el valor de sus abstracciones, tenga cuidado con la sobrecarga de invocar funciones virtuales. </li><li>  Use todos los n√∫cleos de CPU con el sistema de tareas C #. </li><li>  Analizar el nivel de hardware.  ¬øEl compilador Burst realmente genera instrucciones SIMD?  Use el Inspector de r√°faga para el an√°lisis. </li><li>  Deje de desperdiciar l√≠neas de cach√© en vac√≠o.  Piense en empaquetar datos en l√≠neas de cach√© como empaquetar datos en paquetes UDP. </li></ul><br>  El consejo principal que Anders Ericsson quiere compartir es un consejo m√°s general para aquellos cuyo proyecto ya est√° en desarrollo: <i>"Trata de identificar √°reas espec√≠ficas en tu juego donde tengas problemas de rendimiento y ve si puedes aplicar DOTS espec√≠ficamente en Esta zona aislada.</i>  <i>¬°No necesita cambiar toda la base de c√≥digo! ‚Äù</i> <br><br><h3>  Planes futuros </h3><br>  "Queremos usar DOTS en otras √°reas de nuestro juego, y nos quedamos encantados con los anuncios en Unite sobre animaciones DOTS, Unity Physics y Live Link.  Nos gustar√≠a aprender c√≥mo convertir m√°s objetos del juego en objetos ECS, y parece que Unity ha logrado un progreso significativo en la implementaci√≥n de esto ‚Äù, concluye Anders. <br><br>  Si tiene preguntas adicionales para el equipo de Far North, le recomendamos que se una a su <a href="https://discord.gg/jXJyxUh">Discord</a> . <br>  Echa un vistazo a la lista de reproducci√≥n <a href="https://www.youtube.com/playlist%3Flist%3DPLX2vGYjWbI0S1wHRTyDiPtKLEPTWFi4cd">Unite Copenhagen DOTS</a> para ver c√≥mo otros estudios de juegos modernos usan DOTS para crear grandes juegos de alto rendimiento, y c√≥mo los componentes basados ‚Äã‚Äãen DOTS como DOTS Physics, el nuevo Conversion Workflow y el compilador Burst trabajan juntos. <br><br>  La traducci√≥n ha llegado a su fin, y te <b>invitamos a asistir a un <a href="https://otus.pw/YRoY/">seminario web gratuito</a> , en el que <i>te diremos c√≥mo crear tu propio zombie shooter en una hora</i> .</b> </div></div><p>Source: <a href="https://habr.com/ru/post/484094/">https://habr.com/ru/post/484094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484076/index.html">D√≥nde almacenar la criptomoneda: impuestos de las criptomonedas en diferentes pa√≠ses</a></li>
<li><a href="../484084/index.html">1C-Bitrix y un intento de presentarlo</a></li>
<li><a href="../484088/index.html">Desfile de contrase√±as (an√°lisis de ~ 5 mil millones de contrase√±as de fugas)</a></li>
<li><a href="../484090/index.html">Nueva infraestructura de TI para el centro de datos de correos de Rusia</a></li>
<li><a href="../484092/index.html">Algo pr√≠ncipes y nobles vestidos</a></li>
<li><a href="../484096/index.html">La batalla de los dos Yakozun, o Cassandra vs HBase. Experiencia del equipo de Sberbank</a></li>
<li><a href="../484100/index.html">Trabajar con la interfaz en el SDK de Google Maps para Android</a></li>
<li><a href="../484102/index.html">PHP vs Python vs Ruby on Rails: Comparaci√≥n detallada</a></li>
<li><a href="../484106/index.html">MVCC en PostgreSQL-6. Vac√≠o</a></li>
<li><a href="../484108/index.html">Etherblade.net Encapsulador y sustituci√≥n de importaciones para componentes de red (segunda parte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>