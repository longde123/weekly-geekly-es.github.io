<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏻 🎗️ 👞 Noções básicas de injeção de dependência 👩🏼‍🏭 🕴🏻 ♉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre os conceitos básicos da injeção de dependência (Eng. Dependency Injection, DI ) em uma linguagem simples e também sobre os...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noções básicas de injeção de dependência</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Noções básicas de injeção de dependência"></p><br><p>  Neste artigo, falarei sobre os conceitos básicos da injeção de dependência (Eng. <em>Dependency Injection, DI</em> ) em uma linguagem simples e também sobre os motivos para usar essa abordagem.  Este artigo é destinado a quem não sabe o que é injeção de dependência ou que duvida da necessidade de usar essa técnica.  Então, vamos começar. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  O que é vício? </h2><br><p> Vamos ver um exemplo primeiro.  Temos <code>ClassA</code> , <code>ClassB</code> e <code>ClassC</code> como mostrado abaixo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Você pode ver que a classe <code>ClassA</code> contém uma instância da classe <code>ClassB</code> , portanto, podemos dizer que a classe <code>ClassA</code> depende da classe <code>ClassB</code> .  Porque  Porque <code>ClassA</code> precisa <code>ClassB</code> para funcionar corretamente.  Também podemos dizer que a classe <code>ClassB</code> é uma dependência da classe <code>ClassA</code> . </p><br><p>  Antes de continuar, quero esclarecer que esse relacionamento é bom, porque não precisamos de uma classe para fazer todo o trabalho no aplicativo.  Precisamos dividir a lógica em diferentes classes, cada uma das quais será responsável por uma determinada função.  E, neste caso, as classes poderão interagir efetivamente. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  Como trabalhar com dependências? </h2><br><p>  Vejamos três métodos usados ​​para executar tarefas de injeção de dependência: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Primeira maneira: criar dependências em uma classe dependente </h3><br><p>  Simplificando, podemos criar objetos sempre que precisarmos deles.  Veja o seguinte exemplo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  É muito fácil!  Criamos uma classe quando precisamos dela. </p><br><p>  <strong>Os benefícios</strong> </p><br><ul><li>  É fácil e simples. </li><li>  A classe dependente ( <code>ClassA</code> no nosso caso) controla totalmente como e quando criar as dependências. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  <code>ClassA</code> e <code>ClassB</code> intimamente relacionados entre si.  Portanto, sempre que precisarmos usar a <code>ClassA</code> , seremos forçados a usar a <code>ClassB</code> e <strong>será impossível substituir a <code>ClassB</code> por outra coisa</strong> . </li><li>  Com qualquer alteração na inicialização da classe <code>ClassB</code> , você precisará ajustar o código dentro da classe <code>ClassA</code> (e todas as outras classes dependentes da <code>ClassB</code> ).  Isso complica o processo de mudança de dependência. </li><li>  <strong><code>ClassA</code> não pode ser testado.</strong>  Se você precisar testar uma classe, e ainda assim esse for um dos aspectos mais importantes do desenvolvimento de software, será necessário realizar testes de unidade de cada classe separadamente.  Isso significa que, se você deseja verificar a operação correta da classe <code>ClassA</code> e criar vários testes de unidade para verificá-la, então, como mostrado no exemplo, você também criará uma instância da classe <code>ClassB</code> , mesmo quando ela não lhe interessar.  Se ocorrer um erro durante o teste, você não conseguirá entender onde ele está localizado - na <code>ClassA</code> ou na <code>ClassA</code> <code>ClassB</code>  Afinal, existe a possibilidade de que parte do código da <code>ClassB</code> causado um erro, enquanto a <code>ClassA</code> funcionando corretamente.  Em outras palavras, o teste de unidade não é possível porque os módulos (classes) não podem ser separados um do outro. </li><li>  <code>ClassA</code> deve ser configurada para injetar dependências.  Em nosso exemplo, ele precisa saber como criar um <code>ClassC</code> e usá-lo para criar um <code>ClassB</code> .  Seria melhor se ele não soubesse nada sobre isso.  Porque  Devido ao <strong>princípio da responsabilidade única</strong> . </li></ul><br><blockquote>  <em>Cada classe deve apenas fazer seu trabalho.</em> </blockquote><p>  Portanto, não queremos que as classes sejam responsáveis ​​por nada além de suas próprias tarefas.  A implementação de dependências é uma tarefa adicional que definimos para elas. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Segunda maneira: injetar dependências através de uma classe personalizada </h3><br><p>  Portanto, entendendo que injetar dependências em uma classe dependente não é uma boa ideia, vamos explorar uma maneira alternativa.  Aqui, a classe dependente define todas as dependências necessárias dentro do construtor e permite que a classe do usuário as forneça.  Esta é uma solução para o nosso problema?  Nós descobriremos um pouco mais tarde. </p><br><p>  Dê uma olhada no código de exemplo abaixo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Agora <code>ClassA</code> obtém todas as dependências dentro do construtor e pode simplesmente chamar os métodos da classe <code>ClassB</code> sem inicializar nada. </p><br><p>  <strong>Os benefícios</strong> </p><br><ul><li>  <code>ClassA</code> e <code>ClassB</code> agora <code>ClassB</code> fracamente acoplados, e podemos substituir a <code>ClassB</code> sem quebrar o código dentro da <code>ClassA</code> .  Por exemplo, em vez de passar na <code>ClassB</code> podemos passar <code>AssumeClassB</code> , que é uma subclasse da <code>ClassB</code> , e nosso programa funcionará corretamente. </li><li>  <code>ClassA</code> agora pode ser testado.  Ao escrever um teste de unidade, podemos criar nossa própria versão da <code>ClassB</code> (objeto de teste) e passá-la para a <code>ClassA</code> .  Se ocorrer um erro ao passar no teste, agora sabemos com certeza que esse é definitivamente um erro na <code>ClassA</code> . </li><li>  <code>ClassB</code> livre de trabalhar com dependências e pode se concentrar em suas tarefas. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  Esse método se assemelha a um mecanismo de cadeia e, em algum momento, a cadeia deve ser interrompida.  Em outras palavras, o usuário da classe <code>ClassA</code> deve saber tudo sobre a inicialização da <code>ClassB</code> , que por sua vez requer conhecimento sobre a inicialização da <code>ClassC</code> , etc.  Portanto, você vê que qualquer alteração no construtor de qualquer uma dessas classes pode levar a uma alteração na classe de chamada, sem mencionar que a <code>ClassA</code> pode ter mais de um usuário, portanto a lógica de criação de objetos será repetida. </li><li>  Apesar de nossas dependências serem claras e fáceis de entender, o código do usuário não é trivial e difícil de gerenciar.  Portanto, nem tudo é tão simples.  Além disso, o código viola o princípio da responsabilidade única, pois é responsável não apenas por seu trabalho, mas também pela implementação de dependências em classes dependentes. </li></ul><br><p>  O segundo método obviamente funciona melhor que o primeiro, mas ainda tem suas falhas.  É possível encontrar uma solução mais adequada?  Antes de considerar a terceira maneira, vamos primeiro falar sobre o próprio conceito de injeção de dependência. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  O que é injeção de dependência? </h3><br><blockquote>  A injeção de dependência é uma maneira de lidar com dependências fora da classe dependente quando a classe dependente não precisa fazer nada. </blockquote><p>  Com base nessa definição, nossa primeira solução obviamente não usa a idéia de injeção de dependência, e a segunda maneira é que a classe dependente não faz nada para fornecer as dependências.  Mas ainda achamos que a segunda solução é ruim.  POR QUE ?! </p><br><p>  Como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">definição de injeção de dependência</a> não diz nada sobre onde o trabalho com dependências deve ocorrer (exceto fora da classe dependente), o desenvolvedor deve escolher um local adequado para a injeção de dependência.  Como você pode ver no segundo exemplo, a classe de usuário não é o lugar certo. </p><br><p>  Como fazer melhor?  Vejamos uma terceira maneira de lidar com dependências. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Terceira maneira: deixar que outra pessoa lide com dependências em vez de nós </h3><br><p>  De acordo com a primeira abordagem, as classes dependentes são responsáveis ​​por obter suas próprias dependências e, na segunda abordagem, movemos o processamento de dependências da classe dependente para a classe de usuário.  Vamos imaginar que haja alguém que possa lidar com as dependências, como resultado das quais nem as classes dependentes nem as classes de usuários fariam o trabalho.  Este método permite trabalhar diretamente com dependências no aplicativo. </p><br><blockquote>  <strong><em>Uma implementação "limpa" da injeção de dependência (na minha opinião pessoal)</em></strong> <br><br>  <em>A responsabilidade de lidar com dependências é de terceiros, portanto, nenhuma parte do aplicativo irá interagir com eles.</em> </blockquote><p>  A injeção de dependência não é uma tecnologia, uma estrutura, uma biblioteca ou algo assim.  Isto é apenas uma ideia.  A idéia é trabalhar com dependências fora da classe dependente (de preferência em uma parte especialmente alocada).  Você pode aplicar essa ideia sem usar bibliotecas ou estruturas.  No entanto, geralmente recorremos às estruturas para implementar dependências, porque simplifica o trabalho e evita a gravação de código de modelo. </p><br><p>  Qualquer estrutura de injeção de dependência tem duas características inerentes.  Outras funções adicionais podem estar disponíveis para você, mas essas duas funções sempre estarão presentes: </p><br><p>  Primeiramente, essas estruturas oferecem uma maneira de determinar os campos (objetos) que devem ser implementados.  Algumas estruturas fazem isso anotando um campo ou construtor usando a anotação <code>@Inject</code> , mas existem outros métodos.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Koin</a> usa os recursos de linguagem incorporados do Kotlin para determinar a implementação.  <code>Inject</code> significa que a dependência deve ser tratada pela estrutura de DI.  O código será algo como isto: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Em segundo lugar, as estruturas permitem determinar como fornecer cada dependência, e isso acontece em um (s) arquivo (s) separado (s).  Aproximadamente, fica assim (lembre-se de que este é apenas um exemplo e pode variar de estrutura para estrutura): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Portanto, como você pode ver, cada função é responsável pelo processamento de uma dependência.  Portanto, se precisarmos usar a <code>ClassA</code> em algum lugar do aplicativo, acontecerá o seguinte: nossa estrutura DI cria uma instância da classe <code>provideClassC</code> chamando <code>provideClassC</code> , passando-a para <code>provideClassB</code> e recebendo uma instância da <code>ClassB</code> , que é passada para o <code>provideClassA</code> e, como resultado, a <code>ClassA</code> é criada.  Isso é quase mágico.  Agora vamos examinar as vantagens e vantagens do terceiro método. </p><br><p>  <strong>Os benefícios</strong> </p><br><ul><li>  Tudo é o mais simples possível.  A classe dependente e a classe que fornece as dependências são claras e simples. </li><li>  As classes são fracamente acopladas e são facilmente substituíveis por outras classes.  Suponha que desejamos substituir <code>ClassC</code> por <code>AssumeClassC</code> , que é uma subclasse de <code>ClassC</code> .  Para fazer isso, basta alterar o código do provedor da seguinte maneira e, onde quer que <code>ClassC</code> seja usado, a nova versão agora será automaticamente usada: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Observe que nenhum código dentro do aplicativo é alterado, apenas o método do provedor.  Parece que nada poderia ser ainda mais simples e flexível. </p><br><ul><li>  Testabilidade incrível.  Você pode substituir facilmente dependências por versões de teste durante o teste.  De fato, a injeção de dependência é o seu principal auxiliar quando se trata de testes. </li><li>  Melhorando a estrutura do código, como  o aplicativo possui um local separado para processamento de dependência.  Como resultado, o restante do aplicativo pode se concentrar exclusivamente em suas funções e não se sobrepor às dependências. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  As estruturas de DI têm um certo limite de entrada; portanto, a equipe do projeto precisa gastar tempo e estudá-lo antes de usá-lo efetivamente. </li></ul><br><h2 id="zaklyuchenie">  Conclusão </h2><br><ul><li>  O tratamento de dependência sem DI é possível, mas pode causar falhas no aplicativo. </li><li>  A DI é apenas uma idéia eficaz, segundo a qual é possível lidar com dependências fora da classe dependente. </li><li>  É mais eficaz usar o DI em certas partes do aplicativo.  Muitas estruturas contribuem para isso. </li><li>  Estruturas e bibliotecas não são necessárias para o DI, mas podem ajudar muito. </li></ul><br><p>  Neste artigo, tentei explicar o básico sobre como trabalhar com o conceito de injeção de dependência e também listei os motivos para o uso dessa idéia.  Há muito mais recursos que você pode explorar para aprender mais sobre o uso do DI em seus próprios aplicativos.  Por exemplo, uma seção separada na parte avançada do nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">curso profissional no Android é</a> dedicada a este tópico. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434380/">https://habr.com/ru/post/pt434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434362/index.html">NÃO previsto para 2019</a></li>
<li><a href="../pt434364/index.html">Suporte da fila do Hangfire</a></li>
<li><a href="../pt434368/index.html">Machine Learning para encontrar erros no código: como eu estagiei na JetBrains Research</a></li>
<li><a href="../pt434370/index.html">Outro conquistador de sombras em Phaser, ou o uso de bicicletas</a></li>
<li><a href="../pt434374/index.html">Verificando o RBAC no Kubernetes</a></li>
<li><a href="../pt434382/index.html">Portando o Alpine Linux para o RISC-V</a></li>
<li><a href="../pt434384/index.html">Sobre a responsabilidade dos artistas</a></li>
<li><a href="../pt434386/index.html">Douglas Engelbart: "Aumentando o intelecto humano: uma estrutura conceitual"</a></li>
<li><a href="../pt434394/index.html">Bugatti Automobiles testa com sucesso pinça de freio impressa em 3D</a></li>
<li><a href="../pt434398/index.html">Vanivar Bush: "Como podemos pensar". Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>