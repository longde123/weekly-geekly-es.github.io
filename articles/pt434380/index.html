<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™…ğŸ» ğŸ—ï¸ ğŸ‘ NoÃ§Ãµes bÃ¡sicas de injeÃ§Ã£o de dependÃªncia ğŸ‘©ğŸ¼â€ğŸ­ ğŸ•´ğŸ» â™‰ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre os conceitos bÃ¡sicos da injeÃ§Ã£o de dependÃªncia (Eng. Dependency Injection, DI ) em uma linguagem simples e tambÃ©m sobre os...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NoÃ§Ãµes bÃ¡sicas de injeÃ§Ã£o de dependÃªncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="NoÃ§Ãµes bÃ¡sicas de injeÃ§Ã£o de dependÃªncia"></p><br><p>  Neste artigo, falarei sobre os conceitos bÃ¡sicos da injeÃ§Ã£o de dependÃªncia (Eng. <em>Dependency Injection, DI</em> ) em uma linguagem simples e tambÃ©m sobre os motivos para usar essa abordagem.  Este artigo Ã© destinado a quem nÃ£o sabe o que Ã© injeÃ§Ã£o de dependÃªncia ou que duvida da necessidade de usar essa tÃ©cnica.  EntÃ£o, vamos comeÃ§ar. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  O que Ã© vÃ­cio? </h2><br><p> Vamos ver um exemplo primeiro.  Temos <code>ClassA</code> , <code>ClassB</code> e <code>ClassC</code> como mostrado abaixo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  VocÃª pode ver que a classe <code>ClassA</code> contÃ©m uma instÃ¢ncia da classe <code>ClassB</code> , portanto, podemos dizer que a classe <code>ClassA</code> depende da classe <code>ClassB</code> .  Porque  Porque <code>ClassA</code> precisa <code>ClassB</code> para funcionar corretamente.  TambÃ©m podemos dizer que a classe <code>ClassB</code> Ã© uma dependÃªncia da classe <code>ClassA</code> . </p><br><p>  Antes de continuar, quero esclarecer que esse relacionamento Ã© bom, porque nÃ£o precisamos de uma classe para fazer todo o trabalho no aplicativo.  Precisamos dividir a lÃ³gica em diferentes classes, cada uma das quais serÃ¡ responsÃ¡vel por uma determinada funÃ§Ã£o.  E, neste caso, as classes poderÃ£o interagir efetivamente. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  Como trabalhar com dependÃªncias? </h2><br><p>  Vejamos trÃªs mÃ©todos usados â€‹â€‹para executar tarefas de injeÃ§Ã£o de dependÃªncia: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Primeira maneira: criar dependÃªncias em uma classe dependente </h3><br><p>  Simplificando, podemos criar objetos sempre que precisarmos deles.  Veja o seguinte exemplo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  Ã‰ muito fÃ¡cil!  Criamos uma classe quando precisamos dela. </p><br><p>  <strong>Os benefÃ­cios</strong> </p><br><ul><li>  Ã‰ fÃ¡cil e simples. </li><li>  A classe dependente ( <code>ClassA</code> no nosso caso) controla totalmente como e quando criar as dependÃªncias. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  <code>ClassA</code> e <code>ClassB</code> intimamente relacionados entre si.  Portanto, sempre que precisarmos usar a <code>ClassA</code> , seremos forÃ§ados a usar a <code>ClassB</code> e <strong>serÃ¡ impossÃ­vel substituir a <code>ClassB</code> por outra coisa</strong> . </li><li>  Com qualquer alteraÃ§Ã£o na inicializaÃ§Ã£o da classe <code>ClassB</code> , vocÃª precisarÃ¡ ajustar o cÃ³digo dentro da classe <code>ClassA</code> (e todas as outras classes dependentes da <code>ClassB</code> ).  Isso complica o processo de mudanÃ§a de dependÃªncia. </li><li>  <strong><code>ClassA</code> nÃ£o pode ser testado.</strong>  Se vocÃª precisar testar uma classe, e ainda assim esse for um dos aspectos mais importantes do desenvolvimento de software, serÃ¡ necessÃ¡rio realizar testes de unidade de cada classe separadamente.  Isso significa que, se vocÃª deseja verificar a operaÃ§Ã£o correta da classe <code>ClassA</code> e criar vÃ¡rios testes de unidade para verificÃ¡-la, entÃ£o, como mostrado no exemplo, vocÃª tambÃ©m criarÃ¡ uma instÃ¢ncia da classe <code>ClassB</code> , mesmo quando ela nÃ£o lhe interessar.  Se ocorrer um erro durante o teste, vocÃª nÃ£o conseguirÃ¡ entender onde ele estÃ¡ localizado - na <code>ClassA</code> ou na <code>ClassA</code> <code>ClassB</code>  Afinal, existe a possibilidade de que parte do cÃ³digo da <code>ClassB</code> causado um erro, enquanto a <code>ClassA</code> funcionando corretamente.  Em outras palavras, o teste de unidade nÃ£o Ã© possÃ­vel porque os mÃ³dulos (classes) nÃ£o podem ser separados um do outro. </li><li>  <code>ClassA</code> deve ser configurada para injetar dependÃªncias.  Em nosso exemplo, ele precisa saber como criar um <code>ClassC</code> e usÃ¡-lo para criar um <code>ClassB</code> .  Seria melhor se ele nÃ£o soubesse nada sobre isso.  Porque  Devido ao <strong>princÃ­pio da responsabilidade Ãºnica</strong> . </li></ul><br><blockquote>  <em>Cada classe deve apenas fazer seu trabalho.</em> </blockquote><p>  Portanto, nÃ£o queremos que as classes sejam responsÃ¡veis â€‹â€‹por nada alÃ©m de suas prÃ³prias tarefas.  A implementaÃ§Ã£o de dependÃªncias Ã© uma tarefa adicional que definimos para elas. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Segunda maneira: injetar dependÃªncias atravÃ©s de uma classe personalizada </h3><br><p>  Portanto, entendendo que injetar dependÃªncias em uma classe dependente nÃ£o Ã© uma boa ideia, vamos explorar uma maneira alternativa.  Aqui, a classe dependente define todas as dependÃªncias necessÃ¡rias dentro do construtor e permite que a classe do usuÃ¡rio as forneÃ§a.  Esta Ã© uma soluÃ§Ã£o para o nosso problema?  NÃ³s descobriremos um pouco mais tarde. </p><br><p>  DÃª uma olhada no cÃ³digo de exemplo abaixo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Agora <code>ClassA</code> obtÃ©m todas as dependÃªncias dentro do construtor e pode simplesmente chamar os mÃ©todos da classe <code>ClassB</code> sem inicializar nada. </p><br><p>  <strong>Os benefÃ­cios</strong> </p><br><ul><li>  <code>ClassA</code> e <code>ClassB</code> agora <code>ClassB</code> fracamente acoplados, e podemos substituir a <code>ClassB</code> sem quebrar o cÃ³digo dentro da <code>ClassA</code> .  Por exemplo, em vez de passar na <code>ClassB</code> podemos passar <code>AssumeClassB</code> , que Ã© uma subclasse da <code>ClassB</code> , e nosso programa funcionarÃ¡ corretamente. </li><li>  <code>ClassA</code> agora pode ser testado.  Ao escrever um teste de unidade, podemos criar nossa prÃ³pria versÃ£o da <code>ClassB</code> (objeto de teste) e passÃ¡-la para a <code>ClassA</code> .  Se ocorrer um erro ao passar no teste, agora sabemos com certeza que esse Ã© definitivamente um erro na <code>ClassA</code> . </li><li>  <code>ClassB</code> livre de trabalhar com dependÃªncias e pode se concentrar em suas tarefas. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  Esse mÃ©todo se assemelha a um mecanismo de cadeia e, em algum momento, a cadeia deve ser interrompida.  Em outras palavras, o usuÃ¡rio da classe <code>ClassA</code> deve saber tudo sobre a inicializaÃ§Ã£o da <code>ClassB</code> , que por sua vez requer conhecimento sobre a inicializaÃ§Ã£o da <code>ClassC</code> , etc.  Portanto, vocÃª vÃª que qualquer alteraÃ§Ã£o no construtor de qualquer uma dessas classes pode levar a uma alteraÃ§Ã£o na classe de chamada, sem mencionar que a <code>ClassA</code> pode ter mais de um usuÃ¡rio, portanto a lÃ³gica de criaÃ§Ã£o de objetos serÃ¡ repetida. </li><li>  Apesar de nossas dependÃªncias serem claras e fÃ¡ceis de entender, o cÃ³digo do usuÃ¡rio nÃ£o Ã© trivial e difÃ­cil de gerenciar.  Portanto, nem tudo Ã© tÃ£o simples.  AlÃ©m disso, o cÃ³digo viola o princÃ­pio da responsabilidade Ãºnica, pois Ã© responsÃ¡vel nÃ£o apenas por seu trabalho, mas tambÃ©m pela implementaÃ§Ã£o de dependÃªncias em classes dependentes. </li></ul><br><p>  O segundo mÃ©todo obviamente funciona melhor que o primeiro, mas ainda tem suas falhas.  Ã‰ possÃ­vel encontrar uma soluÃ§Ã£o mais adequada?  Antes de considerar a terceira maneira, vamos primeiro falar sobre o prÃ³prio conceito de injeÃ§Ã£o de dependÃªncia. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  O que Ã© injeÃ§Ã£o de dependÃªncia? </h3><br><blockquote>  A injeÃ§Ã£o de dependÃªncia Ã© uma maneira de lidar com dependÃªncias fora da classe dependente quando a classe dependente nÃ£o precisa fazer nada. </blockquote><p>  Com base nessa definiÃ§Ã£o, nossa primeira soluÃ§Ã£o obviamente nÃ£o usa a idÃ©ia de injeÃ§Ã£o de dependÃªncia, e a segunda maneira Ã© que a classe dependente nÃ£o faz nada para fornecer as dependÃªncias.  Mas ainda achamos que a segunda soluÃ§Ã£o Ã© ruim.  POR QUE ?! </p><br><p>  Como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">definiÃ§Ã£o de injeÃ§Ã£o de dependÃªncia</a> nÃ£o diz nada sobre onde o trabalho com dependÃªncias deve ocorrer (exceto fora da classe dependente), o desenvolvedor deve escolher um local adequado para a injeÃ§Ã£o de dependÃªncia.  Como vocÃª pode ver no segundo exemplo, a classe de usuÃ¡rio nÃ£o Ã© o lugar certo. </p><br><p>  Como fazer melhor?  Vejamos uma terceira maneira de lidar com dependÃªncias. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Terceira maneira: deixar que outra pessoa lide com dependÃªncias em vez de nÃ³s </h3><br><p>  De acordo com a primeira abordagem, as classes dependentes sÃ£o responsÃ¡veis â€‹â€‹por obter suas prÃ³prias dependÃªncias e, na segunda abordagem, movemos o processamento de dependÃªncias da classe dependente para a classe de usuÃ¡rio.  Vamos imaginar que haja alguÃ©m que possa lidar com as dependÃªncias, como resultado das quais nem as classes dependentes nem as classes de usuÃ¡rios fariam o trabalho.  Este mÃ©todo permite trabalhar diretamente com dependÃªncias no aplicativo. </p><br><blockquote>  <strong><em>Uma implementaÃ§Ã£o "limpa" da injeÃ§Ã£o de dependÃªncia (na minha opiniÃ£o pessoal)</em></strong> <br><br>  <em>A responsabilidade de lidar com dependÃªncias Ã© de terceiros, portanto, nenhuma parte do aplicativo irÃ¡ interagir com eles.</em> </blockquote><p>  A injeÃ§Ã£o de dependÃªncia nÃ£o Ã© uma tecnologia, uma estrutura, uma biblioteca ou algo assim.  Isto Ã© apenas uma ideia.  A idÃ©ia Ã© trabalhar com dependÃªncias fora da classe dependente (de preferÃªncia em uma parte especialmente alocada).  VocÃª pode aplicar essa ideia sem usar bibliotecas ou estruturas.  No entanto, geralmente recorremos Ã s estruturas para implementar dependÃªncias, porque simplifica o trabalho e evita a gravaÃ§Ã£o de cÃ³digo de modelo. </p><br><p>  Qualquer estrutura de injeÃ§Ã£o de dependÃªncia tem duas caracterÃ­sticas inerentes.  Outras funÃ§Ãµes adicionais podem estar disponÃ­veis para vocÃª, mas essas duas funÃ§Ãµes sempre estarÃ£o presentes: </p><br><p>  Primeiramente, essas estruturas oferecem uma maneira de determinar os campos (objetos) que devem ser implementados.  Algumas estruturas fazem isso anotando um campo ou construtor usando a anotaÃ§Ã£o <code>@Inject</code> , mas existem outros mÃ©todos.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Koin</a> usa os recursos de linguagem incorporados do Kotlin para determinar a implementaÃ§Ã£o.  <code>Inject</code> significa que a dependÃªncia deve ser tratada pela estrutura de DI.  O cÃ³digo serÃ¡ algo como isto: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Em segundo lugar, as estruturas permitem determinar como fornecer cada dependÃªncia, e isso acontece em um (s) arquivo (s) separado (s).  Aproximadamente, fica assim (lembre-se de que este Ã© apenas um exemplo e pode variar de estrutura para estrutura): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Portanto, como vocÃª pode ver, cada funÃ§Ã£o Ã© responsÃ¡vel pelo processamento de uma dependÃªncia.  Portanto, se precisarmos usar a <code>ClassA</code> em algum lugar do aplicativo, acontecerÃ¡ o seguinte: nossa estrutura DI cria uma instÃ¢ncia da classe <code>provideClassC</code> chamando <code>provideClassC</code> , passando-a para <code>provideClassB</code> e recebendo uma instÃ¢ncia da <code>ClassB</code> , que Ã© passada para o <code>provideClassA</code> e, como resultado, a <code>ClassA</code> Ã© criada.  Isso Ã© quase mÃ¡gico.  Agora vamos examinar as vantagens e vantagens do terceiro mÃ©todo. </p><br><p>  <strong>Os benefÃ­cios</strong> </p><br><ul><li>  Tudo Ã© o mais simples possÃ­vel.  A classe dependente e a classe que fornece as dependÃªncias sÃ£o claras e simples. </li><li>  As classes sÃ£o fracamente acopladas e sÃ£o facilmente substituÃ­veis por outras classes.  Suponha que desejamos substituir <code>ClassC</code> por <code>AssumeClassC</code> , que Ã© uma subclasse de <code>ClassC</code> .  Para fazer isso, basta alterar o cÃ³digo do provedor da seguinte maneira e, onde quer que <code>ClassC</code> seja usado, a nova versÃ£o agora serÃ¡ automaticamente usada: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Observe que nenhum cÃ³digo dentro do aplicativo Ã© alterado, apenas o mÃ©todo do provedor.  Parece que nada poderia ser ainda mais simples e flexÃ­vel. </p><br><ul><li>  Testabilidade incrÃ­vel.  VocÃª pode substituir facilmente dependÃªncias por versÃµes de teste durante o teste.  De fato, a injeÃ§Ã£o de dependÃªncia Ã© o seu principal auxiliar quando se trata de testes. </li><li>  Melhorando a estrutura do cÃ³digo, como  o aplicativo possui um local separado para processamento de dependÃªncia.  Como resultado, o restante do aplicativo pode se concentrar exclusivamente em suas funÃ§Ãµes e nÃ£o se sobrepor Ã s dependÃªncias. </li></ul><br><p>  <strong>Desvantagens</strong> </p><br><ul><li>  As estruturas de DI tÃªm um certo limite de entrada; portanto, a equipe do projeto precisa gastar tempo e estudÃ¡-lo antes de usÃ¡-lo efetivamente. </li></ul><br><h2 id="zaklyuchenie">  ConclusÃ£o </h2><br><ul><li>  O tratamento de dependÃªncia sem DI Ã© possÃ­vel, mas pode causar falhas no aplicativo. </li><li>  A DI Ã© apenas uma idÃ©ia eficaz, segundo a qual Ã© possÃ­vel lidar com dependÃªncias fora da classe dependente. </li><li>  Ã‰ mais eficaz usar o DI em certas partes do aplicativo.  Muitas estruturas contribuem para isso. </li><li>  Estruturas e bibliotecas nÃ£o sÃ£o necessÃ¡rias para o DI, mas podem ajudar muito. </li></ul><br><p>  Neste artigo, tentei explicar o bÃ¡sico sobre como trabalhar com o conceito de injeÃ§Ã£o de dependÃªncia e tambÃ©m listei os motivos para o uso dessa idÃ©ia.  HÃ¡ muito mais recursos que vocÃª pode explorar para aprender mais sobre o uso do DI em seus prÃ³prios aplicativos.  Por exemplo, uma seÃ§Ã£o separada na parte avanÃ§ada do nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">curso profissional no Android Ã©</a> dedicada a este tÃ³pico. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434380/">https://habr.com/ru/post/pt434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434362/index.html">NÃƒO previsto para 2019</a></li>
<li><a href="../pt434364/index.html">Suporte da fila do Hangfire</a></li>
<li><a href="../pt434368/index.html">Machine Learning para encontrar erros no cÃ³digo: como eu estagiei na JetBrains Research</a></li>
<li><a href="../pt434370/index.html">Outro conquistador de sombras em Phaser, ou o uso de bicicletas</a></li>
<li><a href="../pt434374/index.html">Verificando o RBAC no Kubernetes</a></li>
<li><a href="../pt434382/index.html">Portando o Alpine Linux para o RISC-V</a></li>
<li><a href="../pt434384/index.html">Sobre a responsabilidade dos artistas</a></li>
<li><a href="../pt434386/index.html">Douglas Engelbart: "Aumentando o intelecto humano: uma estrutura conceitual"</a></li>
<li><a href="../pt434394/index.html">Bugatti Automobiles testa com sucesso pinÃ§a de freio impressa em 3D</a></li>
<li><a href="../pt434398/index.html">Vanivar Bush: "Como podemos pensar". Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>