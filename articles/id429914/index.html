<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€âš–ï¸ ğŸ˜ ğŸ•Œ OpenSceneGraph: Grafik Adegan dan Pointer Cerdas ğŸ…ğŸ¾ ğŸŒ ğŸ¤œğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Dalam artikel sebelumnya, kami melihat kumpulan OpenSceneGraph dari sumber dan menulis contoh dasar di mana sebuah pesawat abu-abu mengg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Grafik Adegan dan Pointer Cerdas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429914/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><br><h1>  Pendahuluan </h1><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami melihat kumpulan OpenSceneGraph dari sumber dan menulis contoh dasar di mana sebuah pesawat abu-abu menggantung di dunia ungu yang kosong.  Saya setuju, tidak terlalu mengesankan.  Namun, seperti yang saya katakan sebelumnya, dalam contoh kecil ini, ada konsep utama yang mendasari mesin grafis ini.  Mari kita pertimbangkan secara lebih detail.  Materi di bawah ini menggunakan ilustrasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Alexander Bobkov tentang OSG</a> (Sayang sekali penulis meninggalkan tulisan tentang OSG ...).  Artikel ini juga didasarkan pada bahan dan contoh-contoh dari buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSceneGraph 3.0.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan pemula</a> <br><br>  Saya harus mengatakan bahwa publikasi sebelumnya menjadi sasaran kritik, yang saya setujui sebagian - materi keluar tanpa diucapkan dan dikeluarkan dari konteks.  Saya akan mencoba memperbaiki kelalaian ini di bawah potongan. <br><a name="habracut"></a><br><h1>  1. Secara singkat tentang grafik adegan dan simpulnya </h1><br>  Konsep sentral dari mesin adalah apa yang disebut <i>grafik adegan</i> (bukan kebetulan bahwa ia terjebak dalam nama kerangka itu sendiri) - struktur pohon hierarkis yang memungkinkan Anda untuk mengatur representasi logis dan spasial dari adegan tiga dimensi.  Grafik adegan berisi simpul akar dan simpul atau <i>simpul</i> tengah dan terminalnya yang terkait. <br><br>  Sebagai contoh <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  Grafik ini menggambarkan adegan yang terdiri dari rumah dan meja di dalamnya.  Rumah memiliki representasi geometris tertentu dan terletak di ruang tertentu dengan cara relatif terhadap sistem koordinat dasar tertentu yang terkait dengan simpul akar (root).  Tabel ini juga dijelaskan oleh beberapa geometri, yang terletak dalam beberapa cara relatif terhadap rumah, dan bersama-sama dengan rumah - relatif terhadap simpul root.  Semua node, memiliki properti umum, karena mereka mewarisi dari satu osg :: kelas Node, dibagi menjadi beberapa tipe sesuai dengan tujuan fungsionalnya <br><br><ol><li>  Node grup (osg :: Grup) - adalah kelas dasar untuk semua node perantara dan dirancang untuk menggabungkan node lain ke dalam grup </li><li>  Node transformasi (osg :: Transform dan turunannya) - dirancang untuk menggambarkan transformasi koordinat objek </li><li>  Node geometris (osg :: Geode) - node terminal (daun) dari grafik adegan yang berisi informasi tentang satu atau lebih objek geometris. </li></ol><br>  Geometri objek pemandangan dalam OSG dijelaskan dalam sistem koordinat lokal objek itu sendiri.  Node transformasi yang terletak di antara objek ini dan simpul akar mengimplementasikan transformasi koordinat matriks untuk mendapatkan posisi objek dalam sistem koordinat dasar. <br><br>  Node melakukan banyak fungsi penting, khususnya, menyimpan keadaan tampilan objek, dan keadaan ini hanya mempengaruhi subgraph yang terkait dengan node ini.  Beberapa panggilan balik dapat dikaitkan dengan node dalam grafik adegan, penangan kejadian yang memungkinkan Anda untuk mengubah keadaan node dan subgraf yang terkait dengannya. <br><br>  Semua operasi global pada grafik adegan yang terkait dengan memperoleh hasil akhir pada layar dilakukan secara otomatis oleh mesin, dengan secara berkala melintasi grafik secara mendalam. <br><br>  Dalam contoh yang diperiksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> , adegan kami terdiri dari satu objek - model pesawat yang dimuat dari file.  Melihat jauh ke depan, saya akan mengatakan bahwa model ini adalah simpul daun dari grafik adegan.  Dilas dengan erat ke sistem koordinat basis global engine. <br><br><h1>  2. manajemen memori OSG </h1><br>  Karena node dari grafik adegan menyimpan banyak data tentang objek adegan dan operasi padanya, maka perlu untuk mengalokasikan memori, termasuk secara dinamis, untuk menyimpan data ini.  Dalam hal ini, ketika memanipulasi grafik adegan, dan, misalnya, menghapus beberapa node, Anda perlu memonitor dengan hati-hati bahwa node yang dihapus dari grafik tidak lagi diproses.  Proses ini selalu disertai dengan kesalahan, debugging yang memakan waktu, karena cukup sulit bagi pengembang untuk melacak pointer ke objek yang merujuk ke data yang ada dan yang harus dihapus.  Tanpa manajemen memori yang efektif, kesalahan segmentasi dan kebocoran memori lebih mungkin terjadi. <br><br>  Manajemen memori adalah tugas penting dalam OSG dan konsepnya didasarkan pada dua poin: <br><br><ol><li>  Alokasi memori: memastikan alokasi jumlah memori yang diperlukan untuk menyimpan suatu objek. <br></li><li>  Kosongkan memori: Kembalikan memori yang dialokasikan ke sistem ketika tidak diperlukan. <br></li></ol><br>  Banyak bahasa pemrograman modern, seperti C #, Java, Visual Basic .Net dan sejenisnya, menggunakan pengumpul sampah untuk membebaskan memori yang dialokasikan.  Konsep bahasa C ++ tidak menyediakan untuk pendekatan seperti itu, namun, kita dapat menirunya dengan menggunakan apa yang disebut smart pointer. <br><br>  Saat ini, C ++ memiliki smart pointer dalam arsenalnya, yang disebut â€œout of the boxâ€ (dan standar C ++ 17 telah berhasil menghilangkan bahasa dari beberapa jenis smart pointer yang usang), tetapi hal ini tidak selalu terjadi.  Versi OSG resmi nomor 0,9 yang paling awal lahir pada tahun 2002, dan ada tiga tahun lagi sebelum rilis resmi pertama.  Pada saat itu, standar C ++ belum menyediakan untuk pointer cerdas, dan bahkan jika Anda percaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu penyimpangan sejarah</a> , bahasa itu sendiri sedang mengalami masa-masa sulit.  Jadi penampilan sepeda dalam bentuk smart pointer sendiri, yang diimplementasikan dalam OSG, sama sekali tidak mengejutkan.  Mekanisme ini sangat terintegrasi ke dalam struktur mesin, sehingga memahami operasinya mutlak diperlukan sejak awal. <br><br><h1>  3. The osg :: ref_ptr &lt;&gt; dan osg :: kelas yang direferensikan </h1><br>  OSG menyediakan mekanisme penunjuk pintarnya sendiri berdasarkan kelas template osg :: ref_ptr &lt;&gt; untuk mengimplementasikan pengumpulan sampah otomatis.  Untuk pengoperasian yang benar, OSG menyediakan osg lain :: kelas yang direferensikan untuk mengelola blok memori yang referensinya dihitung. <br><br>  Kelas osg :: ref_ptr &lt;&gt; menyediakan beberapa operator dan metode. <br><br><ul><li>  get () adalah metode publik yang mengembalikan pointer mentah, misalnya, ketika menggunakan template osg :: Node sebagai argumen, metode ini akan mengembalikan osg :: Node *. <br></li><li>  operator * () sebenarnya adalah operator dereference. <br></li><li>  operator -&gt; () dan operator = () - memungkinkan Anda untuk menggunakan osg :: ref_ptr &lt;&gt; sebagai pointer klasik saat mengakses metode dan properti objek yang dijelaskan oleh pointer ini. <br></li><li>  operator == (), operator! = () dan operator! () - memungkinkan Anda untuk melakukan operasi perbandingan pada pointer pintar. <br></li><li>  valid () adalah metode publik yang mengembalikan true jika pointer yang dikelola memiliki nilai yang benar (bukan NULL).  Ekspresi some_ptr.valid () setara dengan ekspresi some_ptr! = NULL jika some_ptr adalah penunjuk pintar. <br></li><li>  rilis () adalah metode publik, berguna ketika Anda ingin mengembalikan alamat yang dikelola dari suatu fungsi.  Tentang itu akan dijelaskan lebih detail nanti. <br></li></ul><br>  Kelas osg :: Referenced adalah kelas dasar untuk semua elemen grafik adegan, seperti node, geometri, render state, dan objek lain yang ditempatkan di atas panggung.  Dengan demikian, membuat simpul akar adegan, kami secara tidak langsung mewarisi semua fungsi yang disediakan oleh kelas osg :: Referenced.  Karena itu, dalam program kami ada pengumuman <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  Osg :: Kelas yang direferensikan berisi penghitung bilangan bulat untuk referensi ke blok memori yang dialokasikan.  Penghitung ini diinisialisasi ke nol di konstruktor kelas.  Itu bertambah satu ketika objek osg :: ref_ptr &lt;&gt; dibuat.  Penghitung ini berkurang segera setelah referensi ke objek yang dijelaskan oleh pointer ini dihapus.  Suatu objek secara otomatis dihancurkan ketika pointer pintar berhenti untuk referensi itu. <br><br>  Osg :: Kelas yang direferensikan memiliki tiga metode publik: <br><br><ul><li>  ref () adalah metode publik yang bertambah dengan 1 jumlah referensi. <br></li><li>  unref () adalah metode publik, berkurang dengan 1 jumlah referensi. <br></li><li>  referenceCount () adalah metode publik yang mengembalikan nilai saat ini dari penghitung referensi, yang berguna ketika men-debug kode. <br></li></ul><br>  Metode ini tersedia di semua kelas yang berasal dari osg :: Dirujuk.  Namun, harus diingat bahwa kontrol manual penghitung tautan dapat menyebabkan konsekuensi yang tidak terduga, dan menggunakan ini Anda harus memahami dengan jelas apa yang Anda lakukan. <br><br><h1>  4. Bagaimana OSG mengumpulkan sampah dan mengapa diperlukan </h1><br>  Ada beberapa alasan mengapa smart pointer dan pengumpulan sampah harus digunakan: <br><br><ul><li>  Meminimalkan kesalahan kritis: penggunaan pointer pintar memungkinkan Anda untuk mengotomatisasi alokasi dan membebaskan memori.  Tidak ada petunjuk mentah yang berbahaya. <br></li><li>  Manajemen memori yang efektif: memori yang dialokasikan untuk objek dibebaskan segera, segera setelah objek menjadi tidak perlu, yang mengarah pada penggunaan sumber daya sistem secara ekonomis. <br></li><li>  Fasilitasi debugging aplikasi: memiliki kemampuan untuk melacak dengan jelas jumlah tautan ke suatu objek, kami memiliki peluang untuk berbagai jenis optimisasi dan eksperimen. <br></li></ul><br>  Misalkan grafik adegan terdiri dari simpul akar dan beberapa tingkat simpul anak.  Jika simpul root dan semua simpul anak dikelola menggunakan kelas osg :: ref_ptr &lt;&gt;, maka aplikasi hanya dapat melacak pointer ke simpul root.  Menghapus simpul ini akan menghasilkan penghapusan otomatis semua node anak secara berurutan. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Pointer pintar dapat digunakan sebagai variabel lokal, variabel global, anggota kelas, dan secara otomatis mengurangi jumlah referensi ketika pointer pintar keluar dari ruang lingkup. <br><br>  Pointer pintar sangat disarankan oleh pengembang OSG untuk digunakan dalam proyek, tetapi ada beberapa poin mendasar yang harus Anda perhatikan: <br><br><ul><li>  Contoh osg :: Dirujuk dan turunannya dapat dibuat secara eksklusif di heap.  Mereka tidak dapat dibuat di stack sebagai variabel lokal, karena destruktor dari kelas-kelas ini dinyatakan sebagai protected.  Sebagai contoh <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  Anda dapat membuat node adegan sementara menggunakan pointer C ++ biasa, namun pendekatan ini tidak aman.  Lebih baik menggunakan pointer pintar untuk memastikan bahwa grafik adegan dikelola dengan benar. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  Dalam kasus apa pun Anda tidak boleh menggunakan adegan tautan siklik di pohon ketika simpul merujuk ke dirinya sendiri secara langsung atau tidak langsung melalui beberapa level <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  Dalam contoh grafik grafik adegan, simpul Anak 1.1 merujuk ke dirinya sendiri, dan simpul Anak 2.2 juga merujuk ke simpul Anak 1.2.  Jenis tautan semacam itu dapat menyebabkan perhitungan jumlah tautan yang salah dan perilaku program yang tidak terbatas. <br><br><h1>  5. Melacak objek yang dikelola </h1><br>  Untuk menggambarkan operasi mekanisme penunjuk pintar di OSG, kami menulis contoh sintetis berikut <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Kami membuat osg :: kelas turunan direferensikan yang tidak melakukan apa pun kecuali dalam konstruktor dan destruktor yang melaporkan bahwa instance dibuat dan menampilkan pengidentifikasi yang ditentukan ketika instance dibuat.  Buat instance kelas menggunakan mekanisme pointer pintar <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Selanjutnya, kami menampilkan penghitung referensi untuk objek target <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Setelah itu, buat smart pointer baru, berikan nilai dari pointer sebelumnya <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  dan sekali lagi tampilkan penghitung referensi <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Mari kita lihat apa yang kita dapatkan dengan menganalisis output dari program <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  Ketika konstruktor kelas dimulai, pesan yang sesuai ditampilkan, memberi tahu kami bahwa memori untuk objek dialokasikan dan konstruktor bekerja dengan baik.  Selanjutnya, setelah membuat pointer pintar, kita melihat bahwa penghitung referensi untuk objek yang dibuat telah meningkat satu.  Membuat pointer baru, menetapkan nilai dari pointer lama pada dasarnya membuat tautan baru ke objek yang sama, sehingga penghitung referensi bertambah oleh yang lain.  Ketika program keluar, destruktor dari kelas MonitoringTarget dipanggil. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Mari kita lakukan percobaan lain dengan menambahkan kode tersebut ke akhir fungsi utama () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  mengarah ke program "buang" seperti itu <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  Kami membuat beberapa objek di tubuh loop, menggunakan pointer pintar.  Karena ruang lingkup pointer diperluas dalam hal ini hanya ke badan loop, ketika keluar, destruktor secara otomatis dipanggil.  Ini tidak akan terjadi, cukup jelas, kami akan menggunakan pointer biasa. <br><br>  Dengan membebaskan memori secara otomatis adalah fitur penting lainnya dari bekerja dengan pointer pintar.  Karena osg :: destructor kelas turunan yang direferensikan dilindungi, kami tidak dapat secara eksplisit memanggil operator hapus untuk menghapus objek.  Satu-satunya cara untuk menghapus objek adalah dengan mengatur ulang jumlah tautan ke sana.  Tetapi kemudian kode kita menjadi tidak aman selama pemrosesan data multi-utas - kita dapat mengakses objek yang sudah dihapus dari utas lainnya. <br><br>  Untungnya, OSG Memberikan solusi untuk masalah ini dengan penjadwal penghapusan objeknya.  Penjadwal ini didasarkan pada penggunaan kelas osg :: DeleteHandler.  Ia bekerja sedemikian rupa sehingga tidak melakukan operasi menghapus suatu objek dengan segera, tetapi melakukannya setelah beberapa saat.  Semua objek yang akan dihapus disimpan sementara sampai saatnya tiba untuk penghapusan yang aman, dan kemudian semuanya dihapus sekaligus.  Penjadwal penghapusan osg :: DeleteHandler dikendalikan oleh backend render OSG. <br><br><h1>  6. Kembali dari fungsi </h1><br>  Tambahkan fungsi berikut ke kode contoh kami <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  dan ganti panggilan ke operator baru di loop dengan panggilan ke fungsi ini <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  Panggilan rilis () akan mengurangi jumlah referensi ke objek ke nol, tetapi bukannya menghapus memori, itu mengembalikan pointer aktual ke memori yang dialokasikan secara langsung.  Jika pointer ini ditetapkan ke smart pointer lain, tidak akan ada kebocoran memori. <br><br><h1>  Kesimpulan </h1><br>  Konsep grafik adegan dan smart pointer adalah dasar untuk memahami prinsip operasi, dan karenanya penggunaan OpenSceneGraph yang efektif.  Mengenai pointer cerdas OSG, ingatlah bahwa penggunaannya sangat penting ketika <br><br><ul><li>  Penyimpanan jangka panjang dari fasilitas diharapkan. </li><li>  Satu objek menyimpan tautan ke objek lain </li><li>  Anda harus mengembalikan pointer dari suatu fungsi </li></ul><br>  Kode sampel yang disediakan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di sini</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dilanjutkan ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429914/">https://habr.com/ru/post/id429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429902/index.html">Page Rank di Era Web 2.0 - Bagian 1</a></li>
<li><a href="../id429904/index.html">Cerita lucu dan sedih tentang perkembangan game komputer</a></li>
<li><a href="../id429908/index.html">Cara menggunakan coroutine dalam makanan dan tidur nyenyak di malam hari</a></li>
<li><a href="../id429910/index.html">AppsConf Naik</a></li>
<li><a href="../id429912/index.html">Pengembangan perpustakaan: dari API ke rilis publik</a></li>
<li><a href="../id429916/index.html">Cara membangun dan membangun</a></li>
<li><a href="../id429918/index.html">Intel Dunia Virtual. Bagian 2: SMP</a></li>
<li><a href="../id429920/index.html">Tragicomedy in NaN bertindak: bagaimana kami membuat game di JS dan merilisnya di Steam</a></li>
<li><a href="../id429922/index.html">Bagaimana mengubah proyek sederhana menjadi konstruksi jangka panjang atau memotong semua yang tidak perlu</a></li>
<li><a href="../id429928/index.html">Semua yang perlu Anda ketahui tentang stres dan emosi yang kuat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>