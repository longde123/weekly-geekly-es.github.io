<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐞 👩🏾‍🏫 👸🏻 Remote control emulator Fceux menggunakan Python 🍻 🤜🏽 🌚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, saya akan menjelaskan cara membuat emulator NES dikendalikan dari jarak jauh, dan server untuk mengirim perintah ke sana dari jarak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Remote control emulator Fceux menggunakan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435428/">  Dalam artikel ini, saya akan menjelaskan cara membuat emulator NES dikendalikan dari jarak jauh, dan server untuk mengirim perintah ke sana dari jarak jauh. <br><br><img src="https://habrastorage.org/webt/fb/4n/te/fb4ntevb-6j5knunjyr3jq0wec0.png"><br><br><h2>  Mengapa ini dibutuhkan? </h2><br>  Beberapa emulator dari berbagai konsol game, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fceux</a> , memungkinkan Anda untuk menulis dan menjalankan skrip khusus di Lua.  Tapi Lua adalah bahasa yang buruk untuk menulis program serius.  Ini lebih merupakan bahasa untuk fungsi panggilan yang ditulis dalam C.  Para penulis emulator menggunakannya hanya karena ringan dan mudah ditanamkan.  Emulasi yang akurat membutuhkan banyak sumber daya prosesor, dan kecepatan emulasi sebelumnya adalah salah satu tujuan utama penulis, dan jika mereka mengingat kemungkinan tindakan scripting, itu tidak di tempat pertama. <br><br>  Sekarang kekuatan prosesor rata-rata sudah cukup untuk meniru NES, mengapa tidak menggunakan bahasa skrip yang kuat seperti Python atau JavaScript dalam emulator? <br><br>  Sayangnya, tidak ada emulator NES populer yang memiliki kemampuan untuk menggunakan ini atau bahasa lain.  Saya hanya menemukan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nintaco yang</a> sedikit diketahui, yang juga didasarkan pada kernel Fceux, untuk beberapa alasan ditulis ulang di Jawa.  Kemudian saya memutuskan untuk menambahkan kemampuan menulis skrip dengan Python untuk mengendalikan emulator sendiri. <br><br>  Hasil saya adalah Proof-of-Concept dari kemampuan untuk mengendalikan emulator, ia tidak berpura-pura kecepatan atau keandalan, tetapi ia bekerja.  Saya melakukannya untuk diri saya sendiri, tetapi karena pertanyaan tentang bagaimana mengendalikan emulator menggunakan skrip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">umum</a> , saya meletakkan kode sumber pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br><a name="habracut"></a><br><h2>  Bagaimana cara kerjanya </h2><br><h3>  Di sisi emulator </h3><br>  Emulator Fceux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah menyertakan</a> beberapa perpustakaan Lua yang disertakan di dalamnya <a href="">dalam bentuk kode yang dikompilasi</a> .  Salah satunya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuaSocket</a> .  Ini didokumentasikan dengan buruk, tetapi saya berhasil menemukan contoh kode kerja di antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kumpulan skrip</a> <i><b>Xkeeper0</b></i> .  Dia menggunakan soket untuk mengontrol emulator melalui Mirc.  Sebenarnya, kode yang membuka soket tcp adalah: <br><br><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address, port, laddress, lport)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> sock, err = socket.tcp() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> laddress <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:bind(laddress, lport, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:connect(address, port) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sock2, err2 = connect(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>) sock2:settimeout(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--it's our socket object print("Connected", sock2, err2)</span></span></code> </pre> <br>  Ini adalah soket tingkat rendah yang menerima dan mengirim data sebesar 1 byte. <br><br>  Dalam emulator Fceux, loop utama skrip Lua terlihat seperti ini: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--  passiveUpdate() --,        emu.frameadvance() --       end end</span></span></code> </pre><br>  Pemeriksaan data dari soket: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passiveUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message, err, part = sock2:receive(<span class="hljs-string"><span class="hljs-string">"*all"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> message = part <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(message)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--print(message) local recCommand = json.decode(message) table.insert(commandsQueue, recCommand) coroutine.resume(parseCommandCoroutine) end end</span></span></code> </pre><br>  Kode ini cukup sederhana - data dibaca dari soket, dan jika perintah berikutnya terdeteksi, maka diuraikan dan dieksekusi.  Parsing dan eksekusi diatur menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coroutine</a> (coroutine) - ini adalah konsep yang kuat dari bahasa Lua untuk menjeda dan melanjutkan eksekusi kode. <br><br>  Dan satu hal lagi yang penting tentang skrip Lua di Fceux - emulasi dapat dihentikan sementara dari skrip.  Bagaimana mengatur kelanjutan eksekusi kode Lua dan menjalankannya kembali dengan perintah yang diterima dari soket?  Ini tidak mungkin, tetapi ada kemampuan yang tidak terdokumentasi dengan baik untuk memanggil kode Lua bahkan ketika emulasi dihentikan (terima kasih karena telah <b><i>menunjukkannya</i></b> ): <br><br><pre> <code class="lua hljs">gui.register(passiveUpdate) <span class="hljs-comment"><span class="hljs-comment">--undocumented. this function will call even if emulator paused</span></span></code> </pre><br>  <b>Dengannya</b> , Anda dapat berhenti dan terus mengemulasi di dalam <b>pembaruan pasif</b> - dengan cara ini Anda dapat mengatur pemasangan breakpoint emulator melalui soket. <br><br><h3>  Perintah sisi server </h3><br>  Saya menggunakan protokol teks RPC berbasis JSON yang sangat sederhana.  Server membuat serial nama fungsi dan argumen menjadi string JSON dan mengirimkannya melalui soket.  Lebih lanjut, eksekusi kode dihentikan sampai emulator merespons dengan garis untuk menyelesaikan perintah.  Respons akan berisi bidang " <b>FUNCTIONNAME_finished</b> " dan hasil dari fungsinya. <br><br>  Idenya diimplementasikan di kelas <b>syncCall</b> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">syncCall</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, messageName)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""cycle for reading data from socket until needed message was read from it. All other messages will added in message queue"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), [messageName]) <span class="hljs-comment"><span class="hljs-comment">#print(cmd) if cmd != None: if len(cmd)&gt;1: return cmd[1] return @classmethod def call(cls, *params): """wrapper for sending [functionName, [param1, param2, ...]] to socket and wait until client return [functionName_finished, [result1,...]] answer""" sender.send(*params) funcName = params[0] return syncCall.waitUntil(funcName + "_finished")</span></span></code> </pre><br>  Dengan kelas ini, metode Lua emulator Fceux dapat dibungkus dalam kelas Python: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emu</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poweron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.poweron"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.pause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.unpause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.message"</span></span>, str) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">softreset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.softreset"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speedmode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.speedmode"</span></span>, str)</code> </pre><br>  Dan kemudian memanggil kata demi kata dengan cara yang sama seperti dari Lua: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : emu.poweron()</span></span></code> </pre><br><h3>  Metode panggilan balik </h3><br>  Di Lua, Anda dapat mendaftarkan panggilan balik - fungsi yang akan dipanggil saat kondisi tertentu terpenuhi.  Kita bisa port perilaku ini ke server di Python menggunakan trik berikut.  Pertama, kita menyimpan pengenal fungsi callback yang ditulis dengan Python dan meneruskannya ke kode Lua: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callbacks</span></span></span><span class="hljs-class">:</span></span> functions = {} callbackList = [ <span class="hljs-string"><span class="hljs-string">"emu.registerbefore_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"emu.registerafter_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerexecute_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerwrite_callback"</span></span>, ] @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerfunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> func == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> hfunc = hash(func) callbacks.functions[hfunc] = func <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hfunc @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, e)</span></span></span><span class="hljs-function">:</span></span> emu.message(<span class="hljs-string"><span class="hljs-string">"Python error: "</span></span> + str(e)) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAllCallbacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, cmd)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print("check:", cmd) for callbackName in callbacks.callbackList: if cmd[0] == callbackName: hfunc = cmd[1] #print("hfunc:", hfunc) func = callbacks.functions.get(hfunc) #print("func:", func) if func: try: func(*cmd[2:]) #skip function name and function hash and save others arguments except Exception as e: callbacks.error(e) pass #</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> thread locking sender.send(callbackName + "_finished")</span></span></code> </pre><br>  Lua-code juga menyimpan pengenal ini dan mendaftarkan Lua-callback biasa, yang akan mentransfer kontrol ke Python-code.  Selanjutnya, utas terpisah dibuat dalam kode Python yang hanya berkaitan dengan memeriksa bahwa perintah panggilan balik dari Lua belum diterima: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbacksThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cycle += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), callbacks.callbackList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd: <span class="hljs-comment"><span class="hljs-comment">#print("Callback received:", cmd) callbacks.checkAllCallbacks(cmd) pass except socket.timeout: pass time.sleep(0.001)</span></span></code> </pre><br>  Langkah terakhir adalah bahwa setelah panggilan balik Python dieksekusi, kontrol dikembalikan ke Lua menggunakan perintah " <b>CALLBACKNAME_finished</b> " untuk memberi tahu emulator bahwa panggilan balik telah selesai. <br><br><h2>  Cara menjalankan contoh </h2><br><ul><li>  Anda harus menjalankan <b>Python 3</b> dan <b>Jupyter Notebook</b> di sistem.  Anda harus menjalankan Jupyter dengan perintah <br><br><pre> <code class="plaintext hljs">jupyter notebook</code> </pre><br></li><li>  Buka laptop <b>FceuxPythonServer.py.ipynb</b> dan jalankan baris pertama <br><img src="https://habrastorage.org/webt/ns/7k/_i/ns7k_i60y_7kscct2pmyqz1_fi8.png"><br></li><li>  Sekarang Anda perlu menjalankan emulator Fceux, buka file ROM di dalamnya (saya menggunakan game <b>Castlevania (U) (PRG0) [!]. Nes</b> dalam contoh saya) dan jalankan skrip Lua dengan nama <i>fceux_listener.lua</i> .  Seharusnya terhubung ke server yang berjalan di laptop Jupyter. <br><br>  Tindakan ini dapat dilakukan menggunakan baris perintah: <br><br><pre> <code class="plaintext hljs">fceux.exe -lua fceux_listener.lua "Castlevania (U) (PRG0) [!].nes"</code> </pre><br></li><li>  Sekarang kembali ke Notebook Jupyter.  Anda akan melihat pesan tentang koneksi yang berhasil ke emulator: <br><br><img src="https://habrastorage.org/webt/41/on/es/41onesw9o66jmtyfexid7wpipbq.png"><br></li></ul><br>  Itu saja, Anda dapat mengirim perintah dari laptop Jupyter di browser langsung ke emulator Fceux. <br><br>  Anda dapat menjalankan semua baris laptop contoh secara berurutan dan mengamati hasil eksekusi di emulator. <br><br>  Contoh lengkap: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/spiiin/fceux_luaserver/blob/master/FceuxPythonServer.py.ipynb</a> <br><br>  Ini berisi fungsi sederhana seperti membaca memori: <br><br><img src="https://habrastorage.org/webt/sg/ut/du/sgutduhqvx6wqzgczn9seozyl08.png"><br><br>  Contoh panggilan balik yang lebih kompleks: <br><br><img src="https://habrastorage.org/webt/ul/qq/1q/ulqq1qufdcbol1zbw_6za2mtfdi.png"><br><br>  Dan skrip untuk game tertentu yang memungkinkan Anda untuk memindahkan musuh dari <b>Super Mario Bros.</b>  dengan mouse: <br><br><img src="https://habrastorage.org/webt/ie/iw/fa/ieiwfa__-dg4sck64cmekmbcy7y.png"><br><br>  Video Jalankan Laptop: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/c3D5gljbkO0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Keterbatasan dan Aplikasi </h3><br>  Script tidak memiliki perlindungan terhadap kebodohan dan tidak dioptimalkan untuk kecepatan eksekusi - akan lebih baik menggunakan protokol RPC biner daripada teks satu dan pesan grup bersama, tetapi implementasi saya tidak memerlukan kompilasi.  Script dapat mengubah konteks eksekusi dari Lua ke Python dan kembali 500-1000 kali per detik di laptop saya.  Ini cukup untuk hampir semua aplikasi, kecuali untuk kasus-kasus tertentu dari pixel-by-pixel atau debugging baris-demi-baris dari prosesor video, tetapi Fceux masih tidak mengizinkan operasi semacam itu dari Lua, jadi itu tidak masalah. <br><br>  Gagasan aplikasi yang mungkin: <br><br><ul><li>  Sebagai contoh penerapan kontrol tersebut untuk emulator dan bahasa lainnya </li><li>  Penelitian game </li><li>  Menambahkan cheat atau fitur untuk mengatur bagian TAS </li><li>  Masukkan atau ekstrak data dan kode ke dalam game </li><li>  Meningkatkan kemampuan emulator - menulis debugger, skrip untuk merekam dan melihat langkah-langkah, perpustakaan skrip, editor game </li><li>  Game jaringan, kontrol game menggunakan perangkat seluler, layanan jarak jauh, joypad atau perangkat kontrol lainnya, menyimpan dan menambal layanan cloud </li><li>  Fitur Cross-Emulator </li><li>  Menggunakan Python atau perpustakaan bahasa lain untuk analisis data dan kontrol game (membuat bot) </li></ul><br><h3>  Tumpukan teknologi </h3><br>  Saya menggunakan: <br><br>  <b>Fceux</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.fceux.com/web/home.html</a> <br>  Ini adalah emulator NES klasik, dan kebanyakan orang menggunakannya.  Ini belum diperbarui untuk waktu yang lama, dan bukan yang terbaik dalam fitur, tetapi tetap emulator default untuk banyak romhackers.  Juga, saya memilihnya karena dukungan soket Lua terintegrasi ke dalamnya, dan tidak perlu menghubungkannya sendiri. <br><br>  <b>Json.lua</b> - <a href="">github.com/spiiin/json.lua</a> <br>  Ini adalah implementasi JSON di Lua murni.  Saya memilihnya karena saya ingin membuat contoh yang tidak memerlukan kompilasi kode.  Tetapi saya masih harus mem-fork perpustakaan, karena beberapa perpustakaan yang dibangun di Fceux membebani fungsi <i><b>tostring</b></i> perpustakaan dan memutus serialisasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan pool</a> saya yang ditolak kepada penulis perpustakaan asli). <br><br>  <b>Python 3</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.python.org</a> <br>  Server Fceux Lua membuka soket tcp dan mendengarkan perintah yang diterima darinya.  Server yang mengirimkan perintah ke emulator dapat diimplementasikan dalam bahasa apa pun.  Saya memilih Python karena filosofi "Termasuk baterai" - sebagian besar modul termasuk dalam perpustakaan standar (bekerja dengan soket dan JSON juga).  Python juga tahu perpustakaan untuk bekerja dengan jaringan saraf, dan saya ingin mencoba menggunakannya untuk membuat bot di game NES. <br><br>  <b>Jupyter Notebook</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jupyter.org</a> <br>  Jupyter Notebook adalah lingkungan yang sangat keren untuk mengeksekusi kode Python secara interaktif.  Dengannya, Anda dapat menulis dan menjalankan perintah dalam editor spreadsheet di dalam browser.  Ini juga bagus untuk membuat contoh yang bagus. <br><br>  <b>Dexpot</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.dexpot.de</a> <br>  Saya menggunakan manajer desktop virtual ini untuk merapat jendela emulator di atas yang lain.  Ini sangat nyaman ketika menempatkan server dalam layar penuh untuk pelacakan instan perubahan di jendela emulator.  Alat Windows asli tidak memungkinkan Anda untuk mengatur docking windows di atas yang lain. <br><br><h2>  Referensi </h2><br>  Sebenarnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori proyek</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nintaco</a> - Java NES Emulator dengan Remote Management <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xkeeper0 emu-lua collection</a> - koleksi berbagai skrip Lua <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesen</a> adalah emulator NES modern di C # dengan kemampuan skrip Lua yang kuat.  Sejauh ini tanpa dukungan soket dan remote control. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CadEditor</a> adalah proyek saya editor tingkat universal untuk NES dan platform lainnya, serta alat yang kuat untuk meneliti game.  Saya menggunakan skrip dan server yang dijelaskan dalam posting untuk menjelajahi permainan dan menambahkannya ke editor. <br><br>  Saya akan menghargai umpan balik, pengujian, dan upaya untuk menggunakan skrip. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435428/">https://habr.com/ru/post/id435428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435418/index.html">Menggunakan SQLite di Flutter</a></li>
<li><a href="../id435420/index.html">Masa depan perang melawan kejahatan adalah studi tentang pohon keluarga</a></li>
<li><a href="../id435422/index.html">Betapa berpengalamannya orang-orang di Lembah Silikon</a></li>
<li><a href="../id435424/index.html">Parse & Android: rekomendasi untuk pengembang pemula</a></li>
<li><a href="../id435426/index.html">Cara Microsoft Excel bekerja dengan ketinggian baris</a></li>
<li><a href="../id435430/index.html">Berita paling keren CES 2019</a></li>
<li><a href="../id435432/index.html">Tahun Baru, GitHub Baru: Repositori Pribadi Gratis Tanpa Batas</a></li>
<li><a href="../id435436/index.html">5 tren dalam infrastruktur TI: perkiraan untuk 2019</a></li>
<li><a href="../id435438/index.html">PHP: mengubah struktur basis data dalam pengembangan tim</a></li>
<li><a href="../id435442/index.html">Saluran perubahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>