<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèª ‚ô†Ô∏è üë®üèø‚Äç‚öñÔ∏è Li√ß√£o para a noite: real√ßando a sintaxe da escrita üë∏üèª üôãüèæ ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, fiquei interessado em como o destaque do c√≥digo √© organizado por dentro. A princ√≠pio, parecia que tudo era muito complicado l√° - uma √°rv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Li√ß√£o para a noite: real√ßando a sintaxe da escrita</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482884/"> Recentemente, fiquei interessado em como o destaque do c√≥digo √© organizado por dentro.  A princ√≠pio, parecia que tudo era muito complicado l√° - uma √°rvore de sintaxe, recurs√£o, e isso era tudo.  No entanto, ap√≥s uma inspe√ß√£o mais detalhada, verificou-se que n√£o h√° nada dif√≠cil aqui.  Todo o trabalho pode ser feito em um ciclo com espiadas, al√©m disso, express√µes regulares quase nunca s√£o usadas no script resultante. <br><br>  P√°gina de demonstra√ß√£o: <a href="https://astynk.github.io/highlight.html">Marcador de c√≥digo Javascript</a> <br><a name="habracut"></a><br><h2>  Ideia principal </h2><br>  Declaramos a vari√°vel <i>state</i> , que armazenar√° informa√ß√µes sobre em que parte do c√≥digo estamos.  Se, por exemplo, <i>state</i> for igual a um, isso significa que estamos dentro de uma string com aspas simples.  O script aguardar√° a cita√ß√£o de fechamento e ignorar√° todo o resto.  A mesma coisa ao destacar coment√°rios, regexp e outros elementos, cada um tem seu pr√≥prio valor de <i>estado</i> .  Assim, diferentes caracteres de abertura e fechamento n√£o entrar√£o em conflito;  em outras palavras, um c√≥digo como este: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'"\'"'</span></span>;</code> </pre> <br>  ser√£o corretamente destacados, ou seja, esses casos causaram mais dificuldades. <br><br><h2>  Introdu√ß√£o </h2><br>  Determinamos os poss√≠veis valores da vari√°vel state, bem como a cor na qual essa ou aquela parte do c√≥digo ser√° colorida, bem como uma lista de palavras-chave Javascript (que tamb√©m ser√£o destacadas): <br><br><div class="spoiler">  <b class="spoiler_title">estados const = {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> states = { <span class="hljs-attr"><span class="hljs-attr">NONE</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">SINGLE_QUOTE</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 'string' DOUBLE_QUOTE : 2, // "string" ML_QUOTE : 3, // `string` REGEX_LITERAL : 4, // /regex/ SL_COMMENT : 5, // // single line comment ML_COMMENT : 6, // /* multiline comment */ NUMBER_LITERAL : 7, // 123 KEYWORD : 8 // function, var etc. }; const colors = { NONE : '#000', SINGLE_QUOTE : '#aaa', // 'string' DOUBLE_QUOTE : '#aaa', // "string" ML_QUOTE : '#aaa', // `string` REGEX_LITERAL : '#707', // /regex/ SL_COMMENT : '#0a0', // // single line comment ML_COMMENT : '#0a0', // /* multiline comment */ NUMBER_LITERAL : '#a00', // 123 KEYWORD : '#00a', // function, var etc. OPERATOR : '#07f' // null, true etc. }; const keywords = 'async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|set|static|super|switch|throw|try|typeof|var|void|while|with|yield|catch|finally'.split('|');</span></span></code> </pre><br></div></div><br>  Em seguida, criamos uma fun√ß√£o que pegar√° uma linha com o c√≥digo e retornar√° o HTML final com o c√≥digo destacado.  Para real√ßar, os caracteres ser√£o agrupados em SPAN com a cor especificada na vari√°vel <i>colors</i> . <br><br>  A fun√ß√£o ter√° apenas um ciclo, que analisa cada caractere e adiciona SPANs de abertura / fechamento quando necess√°rio. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highlight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = states.NONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; code.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> char = code[i], prev = code[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], next = code[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     } return output; }</span></span></code> </pre> <br>  Primeiro, destaque os coment√°rios: linha √∫nica e multilinha.  Se o caractere atual e o pr√≥ximo for uma barra, e eles n√£o estiverem dentro da linha ( <i>estado</i> √© 0, ou seja, <i>states.NONE</i> ), ent√£o este √© o come√ßo do coment√°rio.  Mude o <i>estado</i> e abra o SPAN com a cor desejada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.SL_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SL_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  <i>continue √©</i> necess√°rio para que as seguintes verifica√ß√µes n√£o funcionem e n√£o ocorra um conflito. <br><br>  Em seguida, aguardamos o final da linha: se o caractere atual for uma quebra de linha e no <i>estado um</i> coment√°rio de linha √∫nica, feche o SPAN e mude o <i>estado</i> para zero: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SL_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Da mesma forma, estamos procurando coment√°rios com v√°rias linhas, o algoritmo √© exatamente o mesmo, apenas os caracteres que voc√™ procura s√£o diferentes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.ML_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  O realce de strings ocorre de maneira semelhante, mas √© necess√°rio levar em considera√ß√£o que as aspas finais podem ser escapadas com uma barra invertida e, portanto, j√° deixam de ser uma barra final. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span>) { state = states.SINGLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SINGLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  O c√≥digo √© semelhante ao que j√° estava acima, s√≥ que agora n√£o registramos o final da linha se houver uma barra invertida antes da cota√ß√£o. <br><br>  A defini√ß√£o de cadeias de caracteres duplas ocorre exatamente da mesma maneira e faz pouco sentido analis√°-las em detalhes.  Para completar a imagem, colocarei sob o spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">if (state == states.NONE &amp;&amp; char == '' '') {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { state = states.DOUBLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.DOUBLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.DOUBLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span>) { state = states.ML_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br>  Literais regexp, que s√£o facilmente confundidos com o sinal de divis√£o, merecem uma considera√ß√£o separada.  Voltaremos a esse problema no final do artigo, mas por enquanto estamos fazendo o mesmo com regexps e com strings. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.REGEX_LITERAL &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Isso termina casos simples quando o in√≠cio e o fim de um literal podem ser determinados por um a dois caracteres.  Vamos come√ßar a destacar n√∫meros: como voc√™ sabe, eles sempre come√ßam com um n√∫mero, mas podem ter letras na composi√ß√£o ( <i>0xFF</i> , <i>123n</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]/</span></span>.test(char) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-z$_]/i</span></span>.test(prev)) { state = states.NUMBER_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.NUMBER_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NUMBER_LITERAL &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-fnx]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span> }</code> </pre> <br>  Aqui estamos procurando o in√≠cio de um n√∫mero: o caractere anterior n√£o deve ser um n√∫mero ou letra, caso contr√°rio, os n√∫meros nos nomes das vari√°veis ‚Äã‚Äãser√£o destacados.  Assim que o caractere atual n√£o for um n√∫mero ou uma letra que possa estar contida no literal de um n√∫mero, feche o SPAN e defina o <i>estado como</i> zero. <br><br>  Todos os tipos poss√≠veis de literais s√£o destacados, a pesquisa por palavras-chave permanece.  Para fazer isso, voc√™ precisa de um loop aninhado que olhe para o futuro e determine se o caractere atual √© o in√≠cio da palavra-chave. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[a-z0-9$_]/i</span></span>.test(prev)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (code[i + j] &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(code[i + j])) { word += code[i + j]; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keywords.includes(word)) { state = states.KEYWORD; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.KEYWORD + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>; } }</code> </pre> <br>  Aqui n√≥s olhamos, o caractere anterior n√£o pode estar no nome da vari√°vel; caso contr√°rio, <i>deixe</i> que a palavra-chave seja destacada na <i>sa√≠da de</i> palavras.  Em seguida, o loop aninhado coleta a palavra mais longa poss√≠vel at√© que um caractere n√£o alfab√©tico seja encontrado.  Se a palavra recebida estiver na matriz de <i>palavras</i> - <i>chave</i> , abra o SPAN e comece a destacar a palavra.  Assim que um caractere n√£o alfab√©tico for encontrado, isso significa o fim da palavra - portanto, feche o SPAN: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.KEYWORD &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; }</code> </pre> <br>  A coisa mais simples permanece - o destaque dos operadores, aqui voc√™ pode simplesmente comparar com o conjunto de caracteres que pode ocorrer nos operadores: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-string"><span class="hljs-string">'+-/*=&amp;|%!&lt;&gt;?:'</span></span>.indexOf(char) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.OPERATOR + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  No final do loop, se nenhuma das condi√ß√µes que <i>continuar continua a</i> causa for acionada, simplesmente adicionamos o caractere atual √† vari√°vel resultante.  Quando ocorre o in√≠cio ou o fim de um literal ou palavra-chave, abrimos / fechamos o SPAN com cores;  em todos os outros casos - por exemplo, quando a linha j√° est√° aberta, jogamos apenas um caractere de cada vez.  Tamb√©m vale a pena proteger os colchetes angulares de abertura, caso contr√°rio, eles podem quebrar o layout. <br><br><pre> <code class="javascript hljs">output += char.replace(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + <span class="hljs-string"><span class="hljs-string">'lt;'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  +      &lt;</span></span></code> </pre> <br><h2>  Bug fix </h2><br>  De alguma forma, tudo parecia simples demais, e n√£o em v√£o: com testes mais detalhados, houve casos em que a luz de fundo n√£o funcionava corretamente. <br><br>  A divis√£o √© reconhecida como regexp. Para diferenciar uma da outra, ser√° necess√°rio alterar a maneira como a regexp √© determinada.  Declaramos a vari√°vel <i>isRegex = true</i> , ap√≥s o que tentaremos "provar" que isso n√£o √© regexp, mas um sinal de divis√£o.  N√£o pode haver palavras-chave ou colchetes antes da opera√ß√£o de divis√£o - portanto, criamos um loop aninhado e vemos o que a barra enfrenta. <br><br><div class="spoiler">  <b class="spoiler_title">Como era antes</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, isRegex = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i + j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { j--; <span class="hljs-comment"><span class="hljs-comment">//        if ('+/-*=|&amp;&lt;&gt;%,({[?:;'.indexOf(code[i+j]) != -1) break; //   ;   -   if (!/[0-9a-z$_]/i.test(code[i+j]) &amp;&amp; word.length &gt; 0) break; //  ,     if (/[0-9a-z$_]/i.test(code[i+j])) word = code[i+j] + word; //   - ,     if (')]}'.indexOf(code[i+j]) != -1) { isRegex = false; break; } } //      -    //  : return /test/g - , plainWord /test/g -  if (word.length &gt; 0 &amp;&amp; !keywords.includes(word)) isRegex = false; if (isRegex) { state = states.REGEX_LITERAL; output += '&lt;span style="color: ' + colors.REGEX_LITERAL + '"&gt;' + char; continue; } }</span></span></code> </pre> <br>  Embora essa abordagem resolva o problema, ainda n√£o est√° isenta de falhas.  Voc√™ pode ajust√°-lo para que esse algoritmo tamb√©m destaque incorretamente, por exemplo: <i>if (a) / regex /</i> ou mais: <i>1 / / regex / / 2</i> .  Por que uma pessoa que divide n√∫meros em regexp precisa de destaque de c√≥digo - essa √© outra quest√£o;  o design √© sintaticamente correto, embora n√£o ocorra na vida real. <br><br>  Existem problemas com a colora√ß√£o regexp em muitos trabalhos, por exemplo, em <a href="https://prismjs.com/test.html">prism.js</a> .  Aparentemente, para o realce correto dos regexps, voc√™ precisa entender completamente a sintaxe, como os navegadores. <br><br>  O segundo bug com o qual eu tive que lidar estava relacionado a barras invertidas.  As aspas de fechamento n√£o foram reconhecidas em uma sequ√™ncia do formul√°rio <i>'test \\'</i> devido √† presen√ßa de uma barra invertida na frente dele.  De volta √† condi√ß√£o que captura o final da linha: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>)</code> </pre> <br>  A √∫ltima parte da condi√ß√£o precisa ser alterada: se a barra invertida for escapada (ou seja, houver outra barra invertida antes dela), registre o final da linha. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> closingCharNotEscaped = prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> || prev == <span class="hljs-string"><span class="hljs-string">'\\'</span></span> &amp;&amp; code[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... if (state == states.SINGLE_QUOTE &amp;&amp; char == '\'' &amp;&amp; closingCharNotEscaped)</span></span></code> </pre> <br>  As mesmas substitui√ß√µes devem ser feitas na pesquisa de cadeias com aspas duplas e reversas, bem como na pesquisa de regexp. <br><br>  Isso √© tudo, voc√™ pode testar o destaque pelo link no in√≠cio do artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482884/">https://habr.com/ru/post/pt482884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482870/index.html">Como comprei um laptop bloqueado no eBay e tentei fazer o meu AntiTheft baseado no IntelAMT</a></li>
<li><a href="../pt482872/index.html">Pol√≠gonos Outro Mundo</a></li>
<li><a href="../pt482876/index.html">C√°lculo do custo de produ√ß√£o de eletricidade solar para necessidades pr√≥prias de uma fam√≠lia no centro da Europa</a></li>
<li><a href="../pt482878/index.html">Como eu procurei pela defini√ß√£o de "produto"</a></li>
<li><a href="../pt482882/index.html">Motor como freio eletromagn√©tico</a></li>
<li><a href="../pt482886/index.html">An√°lise Habra: a dura√ß√£o da publica√ß√£o √© importante?</a></li>
<li><a href="../pt482888/index.html">Iniciando um servidor VPN atr√°s do provedor NAT</a></li>
<li><a href="../pt482892/index.html">Let vs const - o que usar?</a></li>
<li><a href="../pt482894/index.html">Gera√ß√£o de procedimento adapt√°vel usando o algoritmo WaveFunctionCollapse e distribui√ß√£o de probabilidade a priori</a></li>
<li><a href="../pt482896/index.html">OSCP - Minha experi√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>