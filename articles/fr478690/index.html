<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÖ üßí ‚ôâÔ∏è Assemblage et d√©ploiement dynamiques d'images Docker avec werf en utilisant l'exemple de site de documentation versionn√©e ‚úäüèº ü•ù üë©‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† parl√© de notre outil werf GitOps plus d'une fois , mais cette fois, nous aimerions partager l'exp√©rience de la construction du site av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assemblage et d√©ploiement dynamiques d'images Docker avec werf en utilisant l'exemple de site de documentation versionn√©e</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/478690/">  Nous avons d√©j√† parl√© de notre outil werf GitOps plus <a href="https://github.com/flant/werf">d'une fois</a> , mais cette fois, nous aimerions partager l'exp√©rience de la construction du site avec la documentation du projet - <a href="https://werf.io/">werf.io</a> (sa version russe est <a href="https://ru.werf.io/">ru.werf.io</a> ).  Il s'agit d'un site statique normal, mais son assemblage est int√©ressant car il est construit √† l'aide d'un nombre dynamique d'artefacts. <br><br><img src="https://habrastorage.org/webt/m_/ox/od/m_oxod8ckyfsipscttspcn5opd8.png"><br><br>  Entrez dans les nuances de la structure du site: g√©n√©ration d'un menu g√©n√©ral pour toutes les versions, pages d'informations sur les versions, etc.  - nous ne le ferons pas.  Au lieu de cela, nous nous concentrons sur les probl√®mes et les fonctionnalit√©s de l'assemblage dynamique et un peu sur les processus CI / CD associ√©s. <a name="habracut"></a><br><br><h2>  Introduction: comment le site est organis√© </h2><br>  Pour commencer, la documentation werf est stock√©e avec son code.  Cela pose certaines exigences de d√©veloppement qui d√©passent g√©n√©ralement le cadre de cet article, mais au moins, nous pouvons dire que: <br><br><ul><li>  Les nouvelles fonctions de werf ne doivent pas √™tre publi√©es sans mise √† jour de la documentation et, √† l'inverse, toute modification de la documentation implique la sortie d'une nouvelle version de werf; </li><li>  Le projet a un d√©veloppement assez intensif: de nouvelles versions peuvent sortir plusieurs fois par jour; </li><li>  Tout d√©ploiement manuel d'un site avec une nouvelle version de la documentation est au moins fastidieux; </li><li>  Le projet a adopt√© l'approche du <a href="https://ru.werf.io/releases.html">versioning</a> s√©mantique, avec 5 canaux de stabilit√©.  Le processus de lib√©ration implique le passage s√©quentiel des versions √† travers les canaux afin d'augmenter la stabilit√©: de l'alpha au solide comme le roc; </li><li>  Le site a une version en langue russe qui ¬´vit et se d√©veloppe¬ª (c'est-√†-dire dont le contenu est mis √† jour) en parall√®le avec la version principale (c'est-√†-dire en langue anglaise). </li></ul><br>  Pour cacher √† l'utilisateur toute cette ¬´cuisine int√©rieure¬ª, en lui offrant ce qui ¬´fonctionne tout simplement¬ª, nous avons cr√©√© un <b>outil d'installation et de mise √† jour de werf distinct</b> - c'est <a href="https://github.com/flant/multiwerf">multiwerf</a> .  Il suffit d'indiquer le num√©ro de version et le canal de stabilit√© que vous √™tes pr√™t √† utiliser, et multiwerf v√©rifiera s'il existe une nouvelle version sur le canal et la t√©l√©chargera si n√©cessaire. <br><br>  La derni√®re version de werf dans chaque canal est disponible dans le menu de s√©lection de version sur le site.  Par d√©faut, la version du canal le plus stable pour la derni√®re version s'ouvre sur <a href="https://werf.io/documentation/">werf.io/documentation</a> - elle est √©galement index√©e par les moteurs de recherche.  La documentation du canal est disponible √† des adresses individuelles (par exemple, <a href="https://werf.io/v1.0-beta/documentation/">werf.io/v1.0-beta/documentation</a> pour la version b√™ta 1.0). <br><br>  Total, le site a les versions suivantes: <br><br><ol><li>  root (ouvre par d√©faut) </li><li>  pour chaque canal de mise √† jour actif de chaque version (par exemple, <a href="https://werf.io/v1.0-beta/">werf.io/v1.0-beta</a> ). </li></ol><br>  Pour g√©n√©rer une version sp√©cifique d'un site dans le cas g√©n√©ral, il suffit de le compiler √† l'aide des outils <a href="https://jekyllrb.com/">Jekyll</a> en ex√©cutant la commande appropri√©e ( <code>jekyll build</code> ) dans le r√©pertoire <code>/docs</code> du r√©f√©rentiel werf, apr√®s avoir bascul√© sur la balise Git de la version requise. <br><br>  Il ne reste plus qu'√† ajouter que: <br><br><ul><li>  l'utilitaire lui-m√™me (werf) est utilis√© pour l'assemblage; </li><li>  Les processus CI / CD sont bas√©s sur GitLab CI; </li><li>  et tout cela, bien s√ªr, fonctionne √† Kubernetes. </li></ul><br><h2>  Les t√¢ches </h2><br>  Nous formulons maintenant des t√¢ches qui prennent en compte toutes les sp√©cificit√©s d√©crites: <br><br><ol><li>  Apr√®s avoir chang√© la version werf sur n'importe quel canal de mise √† jour, la <b>documentation sur le site doit √™tre mise √† jour automatiquement</b> . </li><li>  Pour le d√©veloppement, vous devez √™tre en mesure de <b>visualiser</b> occasionnellement <b>les versions pr√©liminaires du site</b> . </li></ol><br>  La recompilation du site doit √™tre effectu√©e apr√®s avoir chang√© la version sur n'importe quel canal √† partir des balises Git correspondantes, mais dans le processus de construction de l'image, nous obtiendrons les fonctionnalit√©s suivantes: <br><br><ul><li>  La liste des versions des canaux √©tant en train de changer, il suffit de remonter la documentation des canaux o√π la version a chang√©.  Apr√®s tout, tout remonter n'est pas tr√®s beau. </li><li>  L'ensemble des canaux pour les versions peut varier.  √Ä un certain moment, par exemple, la version sur les canaux peut ne pas √™tre plus stable que la version 1.1 √† acc√®s anticip√©, mais au fil du temps, elle appara√Ætra - ne changez pas l'assemblage √† la main dans ce cas? </li></ul><br>  Il s'av√®re que l' <b>assemblage d√©pend de la modification des donn√©es externes</b> . <br><br><h2>  Impl√©mentation </h2><br><h3>  Choix de l'approche </h3><br>  Vous pouvez √©galement ex√©cuter chaque version requise avec un module distinct dans Kubernetes.  Cette option implique un plus grand nombre d'objets dans le cluster, qui augmentera avec une augmentation du nombre de versions de werf stables.  Et cela implique √† son tour un service plus complexe: chaque version a son propre serveur HTTP, et avec une petite charge.  Bien s√ªr, cela entra√Æne des co√ªts plus √©lev√©s pour les ressources. <br><br>  Nous avons suivi le chemin de l' <b>assemblage de toutes les versions n√©cessaires en une seule image</b> .  Les statistiques compil√©es de toutes les versions du site sont dans un conteneur avec NGINX, et le trafic vers le d√©ploiement correspondant passe par NGINX Ingress.  Une structure simple - une application sans √©tat - facilite la mise √† l'√©chelle du d√©ploiement (en fonction de la charge) √† l'aide de Kubernetes lui-m√™me. <br><br>  Pour √™tre plus pr√©cis, nous collectons deux images: une pour le circuit de production, l'autre pour le circuit de d√©veloppement.  Une image suppl√©mentaire est utilis√©e (lanc√©e) uniquement sur le circuit de d√©veloppement avec la principale et contient la version du site √† partir de la validation de la revue, et le routage entre eux est effectu√© √† l'aide des ressources Ingress. <br><br><h3>  werf vs git clone et artefacts </h3><br>  Comme d√©j√† mentionn√©, afin de g√©n√©rer des statistiques de site pour une version sp√©cifique de la documentation, vous devez cr√©er en basculant vers la balise de r√©f√©rentiel correspondante.  On pourrait √©galement le faire en clonant le r√©f√©rentiel √† chaque fois pendant l'assemblage, en s√©lectionnant les balises appropri√©es dans la liste.  Cependant, c'est une op√©ration plut√¥t consommatrice de ressources et, de plus, n√©cessitant l'√©criture d'instructions non triviales ... Un autre inconv√©nient s√©rieux - avec cette approche, il n'y a aucun moyen de mettre en cache quelque chose pendant l'assemblage. <br><br>  Ici, l'utilitaire werf vient √† notre aide, qui impl√©mente <b>la mise en cache intelligente</b> et permet l'utilisation de <a href="https://ru.werf.io/documentation/configuration/stapel_image/git_directive.html"><b>r√©f√©rentiels externes</b></a> .  L'utilisation de werf pour ajouter du code √† partir du r√©f√©rentiel acc√©l√©rera consid√©rablement la construction, car  werf effectue essentiellement le clonage du r√©f√©rentiel une fois, puis <i>ne</i> <code>fetch</code> si n√©cessaire.  De plus, lors de l'ajout de donn√©es √† partir du r√©f√©rentiel, nous ne pouvons s√©lectionner que les r√©pertoires n√©cessaires (dans notre cas, c'est le r√©pertoire <code>docs</code> ), ce qui r√©duira consid√©rablement la quantit√© de donn√©es ajout√©es. <br><br>  √âtant donn√© que Jekyll est un outil con√ßu pour compiler des statistiques et n'est pas n√©cessaire dans l'image finale, il serait logique de compiler dans l' <a href="https://ru.werf.io/documentation/configuration/stapel_artifact.html">artefact werf</a> et d' <b>importer uniquement le r√©sultat de la compilation</b> dans l'image finale. <br><br><h3>  √âcriture werf.yaml </h3><br>  Nous avons donc d√©cid√© de compiler chaque version dans un artefact werf distinct.  Cependant, nous <b>ne savons pas combien de ces artefacts seront au cours de l'assemblage</b> , donc nous ne pouvons pas √©crire une configuration d'assemblage fixe (√† proprement parler, nous pouvons toujours, mais elle ne sera pas compl√®tement efficace). <br><br>  werf vous permet d'utiliser des <a href="https://ru.werf.io/documentation/configuration/introduction.html">Go-templates</a> dans votre fichier de configuration ( <code>werf.yaml</code> ), ce qui permet de <b>g√©n√©rer une config "√† la vol√©e" en</b> fonction de donn√©es externes (ce dont vous avez besoin!).  Les donn√©es externes dans notre cas sont des informations sur les versions et les versions, sur la base desquelles nous collectons le nombre n√©cessaire d'artefacts et obtenons en cons√©quence deux images: <code>werf-doc</code> et <code>werf-dev</code> pour le lancement sur des chemins diff√©rents. <br><br>  Les donn√©es externes sont transmises via des variables d'environnement.  Voici leur composition: <br><br><ul><li>  <code>RELEASES</code> - une ligne avec une liste de versions et la version actuelle correspondante de werf, sous la forme d'une liste, s√©par√©e par un espace, au format <code>&lt;_&gt;%&lt;_&gt;</code> .  Exemple: <code>1.0%v1.0.4-beta.20</code> </li><li>  <code>CHANNELS</code> - une ligne avec une liste de canaux et la version actuelle correspondante de werf, sous la forme d'une liste avec un espace de valeurs au format <code>&lt;&gt;%&lt;_&gt;</code> .  Exemple: <code>1.0-beta%v1.0.4-beta.20 1.0-alpha%v1.0.5-alpha.22</code> </li><li>  <code>ROOT_VERSION</code> - La version de la version werf √† afficher par d√©faut sur le site (il n'est pas toujours n√©cessaire d'afficher la documentation pour le num√©ro de version le plus √©lev√©).  Exemple: <code>v1.0.4-beta.20</code> </li><li>  <code>REVIEW_SHA</code> - hachage de la validation de r√©vision √† partir de laquelle vous devez collecter la version pour la boucle de test. </li></ul><br>  Ces variables seront remplies dans le pipeline GitLab CI, et comment exactement est d√©crit ci-dessous. <br><br>  Tout d'abord, pour plus de commodit√©, nous d√©finissons les variables Go-template dans <code>werf.yaml</code> leur affectant des valeurs √† partir des variables d'environnement: <br><br><pre> <code class="go hljs">{{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfVersions"</span></span> (cat (env <span class="hljs-string"><span class="hljs-string">"CHANNELS"</span></span>) (env <span class="hljs-string"><span class="hljs-string">"RELEASES"</span></span>) | splitList <span class="hljs-string"><span class="hljs-string">" "</span></span>) }} {{ $Root := . }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfRootVersion"</span></span> (env <span class="hljs-string"><span class="hljs-string">"ROOT_VERSION"</span></span>) }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfReviewCommit"</span></span> (env <span class="hljs-string"><span class="hljs-string">"REVIEW_SHA"</span></span>) }}</code> </pre> <br>  La description de l'artefact pour compiler la statique de la version du site est g√©n√©ralement la m√™me pour tous les cas dont nous avons besoin (y compris la g√©n√©ration de la version racine, ainsi que la version pour le circuit de d√©veloppement).  Par cons√©quent, nous le placerons dans un bloc s√©par√© en utilisant la fonction <code>define</code> - pour une r√©utilisation ult√©rieure avec <code>include</code> .  Nous transmettrons les arguments suivants au mod√®le: <br><br><ul><li>  <code>Version</code> - version g√©n√©r√©e (nom de la balise); </li><li>  <code>Channel</code> - le nom du canal de mise √† jour pour lequel l'artefact est g√©n√©r√©; </li><li>  <code>Commit</code> - validation du hachage si un artefact est g√©n√©r√© pour la validation de la r√©vision; </li><li>  contexte. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Description du mod√®le d'artefact</b> <div class="spoiler_text"><pre> <code class="go hljs">{{- define <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> -}} {{- $Root := index . <span class="hljs-string"><span class="hljs-string">"Root"</span></span> -}} artifact: doc-{{ .Channel }} from: jekyll/builder:<span class="hljs-number"><span class="hljs-number">3</span></span> mount: - from: build_dir to: /usr/local/bundle ansible: install: - shell: | export PATH=/usr/jekyll/bin/:$PATH - name: <span class="hljs-string"><span class="hljs-string">"Install Dependencies"</span></span> shell: bundle install args: executable: /bin/bash chdir: /app/docs beforeSetup: {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .Commit }} - shell: echo <span class="hljs-string"><span class="hljs-string">"Review SHA - {{ .Commit }}."</span></span> {{- end }} {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> eq .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} - name: <span class="hljs-string"><span class="hljs-string">"releases.yml HASH: {{ $Root.Files.Get "</span></span>releases.yml<span class="hljs-string"><span class="hljs-string">" | sha256sum }}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ $Root.Files.Get <span class="hljs-string"><span class="hljs-string">"releases.yml"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /app/docs/_data/releases.yml {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} - file: path: /app/docs/_data/releases.yml state: touch {{- end }} - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/ - /app/ru_site/ - file: dest: /app/docs/pages_ru/cli state: link src: /app/docs/pages/cli - shell: | echo -e <span class="hljs-string"><span class="hljs-string">"werfVersion: {{ .Version }}\nwerfChannel: {{ .Channel }}"</span></span> &gt; /tmp/_config_additional.yml export PATH=/usr/jekyll/bin/:$PATH {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and (ne .Version <span class="hljs-string"><span class="hljs-string">"review"</span></span>) (ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span>) }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> ( printf <span class="hljs-string"><span class="hljs-string">"v%s"</span></span> .Channel ) }} {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> .Channel }} {{- end }} jekyll build -s /app/docs -d /app/_main_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/tmp/_config_additional.yml jekyll build -s /app/docs -d /app/_ru_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/app/docs/_config_ru.yml,/tmp/_config_additional.yml args: executable: /bin/bash chdir: /app/docs git: - url: https:<span class="hljs-comment"><span class="hljs-comment">//github.com/flant/werf.git to: /app/ owner: jekyll group: jekyll {{- if .Commit }} commit: {{ .Commit }} {{- else }} tag: {{ .Version }} {{- end }} stageDependencies: install: ['docs/Gemfile','docs/Gemfile.lock'] beforeSetup: '**/*' includePaths: 'docs' excludePaths: '**/*.sh' {{- end }}</span></span></code> </pre> </div></div><br>  Le nom de l'artefact doit √™tre unique.  Nous pouvons y parvenir, par exemple, en ajoutant le nom du canal (valeur de la variable <code>.Channel</code> ) comme suffixe pour le nom de l'artefact: <code>artifact: doc-{{ .Channel }}</code> .  Mais vous devez comprendre que lors de l'importation √† partir d'artefacts, vous devrez vous r√©f√©rer aux m√™mes noms. <br><br>  Lors de la description d'un artefact, une fonctionnalit√© werf comme <a href="https://ru.werf.io/documentation/configuration/stapel_image/mount_directive.html">mount est utilis√©e</a> .  Le montage avec le <code>build_dir</code> service <code>build_dir</code> vous permet d'enregistrer le cache Jekyll entre les d√©marrages de pipeline, ce <b>qui acc√©l√®re consid√©rablement la reconstruction</b> . <br><br>  Vous avez peut-√™tre √©galement remarqu√© l'utilisation du fichier <code>releases.yml</code> - il s'agit du fichier YAML avec les donn√©es de publication demand√©es √† <a href="https://github.com/flant/werf">github.com</a> (l'artefact obtenu en ex√©cutant le pipeline).  Il est n√©cessaire lors de la compilation du site, mais dans le contexte de l'article, nous nous int√©ressons au fait qu'un <b>seul artefact</b> , l' <b>artefact</b> racine de la version du site <b>,</b> d√©pend de son √©tat (dans d'autres artefacts, il n'est pas n√©cessaire). <br><br>  Ceci est impl√©ment√© en utilisant l'op√©rateur conditionnel pour les mod√®les <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> go et le <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code>  <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> dans la <a href="https://ru.werf.io/documentation/reference/stages_and_images.html">sc√®ne</a> .  Cela fonctionne comme suit: lors de l'assemblage d'un artefact pour la version racine (la variable <code>.Channel</code> est <code>root</code> ), le hachage du fichier <code>releases.yml</code> affecte la signature de toute la sc√®ne, car il s'agit d'un composant du nom du travail Ansible (param√®tre <code>name</code> ).  Ainsi, lors de la modification du <b>contenu du</b> fichier <code>releases.yml</code> , l'artefact correspondant sera reconstruit. <br><br>  Faites √©galement attention √† travailler avec un r√©f√©rentiel externe.  Seul le r√©pertoire <code>/docs</code> est ajout√© √† l'image de l'artefact √† partir <a href="">du r√©f√©rentiel werf</a> , et selon les param√®tres transmis, les donn√©es de la balise ou de la validation de r√©vision n√©cessaires sont ajout√©es imm√©diatement. <br><br>  Pour utiliser le mod√®le d'artefact pour g√©n√©rer une description d'artefact des versions transf√©r√©es des canaux et des versions, nous organisons une boucle sur la variable <code>.WerfVersions</code> dans <code>werf.yaml</code> : <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> $VersionsDict._1 <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> $VersionsDict._0 <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{ end -}}</code> </pre> <br>  Parce que  la boucle va g√©n√©rer plusieurs artefacts (on l'esp√®re), il faut prendre en compte le s√©parateur entre eux - la s√©quence <code>---</code> (pour plus d'informations sur la syntaxe du fichier de configuration, voir la <a href="https://ru.werf.io/documentation/configuration/introduction.html">documentation</a> ).  Comme pr√©c√©demment d√©termin√©, lorsque vous appelez le mod√®le en boucle, nous transmettons les param√®tres de version, l'URL et le contexte racine. <br><br>  De m√™me, mais d√©j√† sans boucle, nous appelons le mod√®le d'artefact pour les "cas sp√©ciaux": pour la version racine, ainsi que la version du commit de r√©vision: <br><br><pre> <code class="go hljs">{{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> .WerfRootVersion <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"root"</span></span> <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .WerfReviewCommit }} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Commit"</span></span> .WerfReviewCommit <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} {{- end }}</code> </pre> <br>  Veuillez noter que l'artefact pour la validation de la r√©vision ne sera collect√© que si la variable <code>.WerfReviewCommit</code> est <code>.WerfReviewCommit</code> . <br><br>  Les artefacts sont pr√™ts - il est temps d'importer! <br><br>  L'image finale, con√ßue pour s'ex√©cuter dans Kubernetes, est un NGINX normal, dans lequel le fichier de configuration du serveur <code>nginx.conf</code> et les statiques des artefacts sont ajout√©s.  En plus de l'artefact de la version racine du site, nous devons r√©p√©ter la boucle sur la variable <code>.WerfVersions</code> pour importer des artefacts des versions des canaux et des versions + observer la r√®gle de d√©nomination des artefacts que nous avons adopt√©e pr√©c√©demment.  √âtant donn√© que chaque artefact stocke des versions du site dans deux langues, nous les importons aux emplacements fournis par la configuration. <br><br><div class="spoiler">  <b class="spoiler_title">Description de l'image finale werf-doc</b> <div class="spoiler_text"><pre> <code class="go hljs">image: werf-doc from: nginx:stable-alpine ansible: setup: - name: <span class="hljs-string"><span class="hljs-string">"Setup /etc/nginx/nginx.conf"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ .Files.Get <span class="hljs-string"><span class="hljs-string">".werf/nginx.conf"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /etc/nginx/nginx.conf - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/assets - /app/ru_site/assets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_main_site to: /app/main_site/v{{ $Channel }} before: setup {{ end -}} {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_ru_site to: /app/ru_site/v{{ $Channel }} before: setup {{ end -}}</code> </pre> </div></div><br>  L'image suppl√©mentaire, qui, avec l'image principale, est lanc√©e sur le circuit de d√©veloppement, ne contient que deux versions du site: la version du commit de r√©vision et la version racine du site (il existe des actifs g√©n√©raux et, si vous vous en souvenez, des donn√©es de publication).  Ainsi, l'image suppl√©mentaire de l'image principale ne diff√©rera que dans la section d'importation (et, bien s√ªr, dans le nom): <br><br><pre> <code class="plaintext hljs">image: werf-dev ... import: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{- if .WerfReviewCommit }} - artifact: doc-review add: /app/_main_site to: /app/main_site/review before: setup - artifact: doc-review add: /app/_ru_site to: /app/ru_site/review before: setup {{- end }}</code> </pre> <br>  Comme d√©j√† indiqu√© ci-dessus, l'artefact pour la validation de r√©vision ne sera g√©n√©r√© que lorsque werf d√©marre avec la variable d'environnement <code>REVIEW_SHA</code> .  Il serait possible de ne pas g√©n√©rer d'image werf-dev s'il n'y a pas de <code>REVIEW_SHA</code> environnement <code>REVIEW_SHA</code> , mais pour que le <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">nettoyage bas√©</a> sur werf-dev <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">des politiques pour les</a> images Docker fonctionne pour l'image werf-dev, nous la laissons √™tre collect√©e uniquement avec l'artefact de la version racine (de toute fa√ßon, il d√©j√† assembl√©), pour simplifier la structure du pipeline. <br><br>  L'assemblage est pr√™t!  On passe au CI / CD et aux nuances importantes. <br><br><h3>  Pipeline dans GitLab CI et fonctionnalit√©s de l'assemblage dynamique </h3><br>  Lors du d√©marrage de l'assembly, nous devons d√©finir les variables d'environnement utilis√©es dans <code>werf.yaml</code> .  Cela ne s'applique pas √† la variable REVIEW_SHA, que nous d√©finirons lorsque le pipeline est appel√© √† partir du hook GitHub. <br><br>  Nous g√©n√©rerons les donn√©es externes n√©cessaires dans le script Bash <code>generate_artifacts</code> , qui g√©n√©rera deux artefacts GitLab de pipeline: <br><br><ul><li>  fichier <code>releases.yml</code> avec les donn√©es de version, </li><li>  fichier <code>common_envs.sh</code> contenant les variables d'environnement √† exporter. </li></ul><br>  Vous trouverez le contenu du fichier <code>generate_artifacts</code> dans notre <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">exemple de r√©f√©rentiel</a> .  L'obtention de donn√©es n'est pas le sujet de l'article, mais le fichier <code>common_envs.sh</code> est important pour nous, car  le travail de werf en d√©pend.  Un exemple de son contenu: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> RELEASES=<span class="hljs-string"><span class="hljs-string">'1.0%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CHANNELS=<span class="hljs-string"><span class="hljs-string">'1.0-alpha%v1.0.7-1 1.0-beta%v1.0.7-1 1.0-ea%v1.0.6-4 1.0-stable%v1.0.6-4 1.0-rock-solid%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ROOT_VERSION=<span class="hljs-string"><span class="hljs-string">'v1.0.6-4'</span></span></code> </pre> <br>  Vous pouvez utiliser la sortie d'un tel script, par exemple, en utilisant la fonction Bash <code>source</code> . <br><br>  Et maintenant pour la partie amusante.  Pour que les applications de g√©n√©ration et de d√©ploiement fonctionnent correctement, vous devez rendre <code>werf.yaml</code> <b>identique</b> pour au moins <b>un pipeline</b> .  Si cette condition n'est pas remplie, les signatures des √©tapes que werf calcule lors de l'assemblage et, par exemple, du d√©ploiement, seront diff√©rentes.  Cela entra√Ænera une erreur de d√©ploiement, car  l'image requise pour le d√©ploiement sera absente. <br><br>  En d'autres termes, si lors de l'assemblage de l'image du site, les informations sur les versions et les versions sont une et qu'au moment de la publication une nouvelle version est publi√©e et que les variables d'environnement ont des valeurs diff√©rentes, le d√©ploiement √©choue avec une erreur: l'artefact de la nouvelle version n'a pas encore √©t√© collect√©. <br><br>  Si la g√©n√©ration de <code>werf.yaml</code> d√©pend de donn√©es externes (par exemple, une liste des versions actuelles, comme dans notre cas), la composition et les valeurs de ces donn√©es doivent √™tre enregistr√©es dans le pipeline.  Ceci est particuli√®rement important si les param√®tres externes changent assez souvent. <br><br>  Nous allons <b>recevoir et capturer des donn√©es externes</b> √† la premi√®re √©tape du pipeline dans GitLab ( <i>Prebuild</i> ) et les transf√©rer plus loin en tant <b>qu'artefact CI GitLab</b> .  Cela vous permettra de d√©marrer et de red√©marrer les t√¢ches de pipeline (g√©n√©ration, d√©ploiement, nettoyage) avec la m√™me configuration dans <code>werf.yaml</code> . <br><br>  Le contenu de l'√©tape <i>Prebuild du</i> fichier <i>.gitlab</i> - <i>ci.yml</i> : <br><br><pre> <code class="plaintext hljs">Prebuild: stage: prebuild script: - bash ./generate_artifacts 1&gt; common_envs.sh - cat ./common_envs.sh artifacts: paths: - releases.yml - common_envs.sh expire_in: 2 week</code> </pre> <br>  En capturant des donn√©es externes dans un artefact, vous pouvez cr√©er et d√©ployer √† l'aide des √©tapes de pipeline standard GitLab CI: g√©n√©ration et d√©ploiement.  Nous lan√ßons le pipeline par des hooks √† partir du r√©f√©rentiel gerHub werf (c'est-√†-dire lors du changement du r√©f√©rentiel sur GitHub).  Les donn√©es pour eux peuvent √™tre prises dans les propri√©t√©s du projet GitLab dans la section <i>Param√®tres CI / CD -&gt;</i> D√©clencheurs de <i>pipeline</i> , puis cr√©er le Webhook correspondant ( <i>Param√®tres -&gt; Webhooks</i> ) dans GitHub. <br><br>  L'√©tape de construction ressemblera √† ceci: <br><br><pre> <code class="plaintext hljs">Build: stage: build script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf build-and-publish --stages-storage :local except: refs: - schedules dependencies: - Prebuild</code> </pre> <br>  GitLab ajoutera deux artefacts de l'√©tape de <code>source common_envs.sh</code> √† la phase de construction, nous exportons donc les variables avec une entr√©e pr√©par√©e √† l'aide de la <code>source common_envs.sh</code> .  Nous entamons la phase d'assemblage dans tous les cas, √† l'exception du lancement du pipeline dans les d√©lais.  Selon le calendrier, le pipeline sera lanc√© pour le nettoyage - nous n'avons pas besoin de construire dans ce cas. <br><br>  Au stade du d√©ploiement, nous d√©crivons deux t√¢ches - s√©par√©ment pour le d√©ploiement sur les circuits de production et de d√©veloppement, √† l'aide du mod√®le YAML: <br><br><pre> <code class="plaintext hljs">.base_deploy: &amp;base_deploy stage: deploy script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf deploy --stages-storage :local dependencies: - Prebuild except: refs: - schedules Deploy to Production: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: prod environment: name: production url: werf.io only: refs: - master except: variables: - $REVIEW_SHA refs: - schedules Deploy to Test: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: dev environment: name: test url: werf.test.flant.com except: refs: - schedules only: variables: - $REVIEW_SHA</code> </pre> <br>  Les t√¢ches ne diff√®rent essentiellement qu'en indiquant le contexte du cluster sur lequel werf doit ex√©cuter le d√©ploiement ( <code>WERF_KUBE_CONTEXT</code> ) et en d√©finissant les variables d'environnement du contour ( <code>environment.name</code> et <code>environment.url</code> ), qui sont ensuite utilis√©es dans les mod√®les de graphique Helm.  Le contenu des mod√®les ne sera pas donn√©, car  il n'y a rien d'int√©ressant pour ce sujet, mais vous pouvez les trouver dans <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">le r√©f√©rentiel d'articles</a> . <br><br><h3>  Touche finale </h3><br>  √âtant donn√© que les versions werf sont publi√©es assez souvent, de nouvelles images sont souvent collect√©es et le Docker Registry s'agrandit constamment.  Par cons√©quent, il est n√©cessaire de configurer le nettoyage automatique des images par strat√©gie.  C'est tr√®s simple √† faire. <br><br>  Pour la mise en ≈ìuvre, vous aurez besoin de: <br><br><ul><li>  Ajouter une √©tape de purification √† <code>.gitlab-ci.yml</code> ; </li><li>  Ajouter des t√¢ches de nettoyage p√©riodiques; </li><li>  D√©finissez la variable d'environnement avec un jeton d'acc√®s en √©criture. </li></ul><br>  Ajoutez l'√©tape de nettoyage √† <code>.gitlab-ci.yml</code> : <br><br><pre> <code class="plaintext hljs">Cleanup: stage: cleanup script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - docker login -u nobody -p ${WERF_IMAGES_CLEANUP_PASSWORD} ${WERF_IMAGES_REPO} - werf cleanup --stages-storage :local only: refs: - schedules</code> </pre><br>  Presque nous tous l'avons d√©j√† vu un peu plus haut - uniquement pour le nettoyage, vous devez d'abord vous connecter au Docker Registry avec un jeton qui a le droit de supprimer des images dans le Docker Registry (le jeton de t√¢che GitLab CI √©mis automatiquement ne dispose pas de tels droits).  Le jeton doit √™tre entr√© dans GitLab √† l'avance et sa valeur doit √™tre sp√©cifi√©e dans la variable d'environnement <code>WERF_IMAGES_CLEANUP_PASSWORD</code> projet <i>(Param√®tres CI / CD -&gt; Variables)</i> . <br><br>  L'ajout d'une t√¢che de nettoyage avec le planning n√©cessaire se fait dans <i>CI / CD -&gt;</i> <i><br></i>  <i>Horaires</i> <br><br>  C'est tout: le projet dans le Docker Registry ne se d√©veloppera plus constamment √† partir d'images inutilis√©es. <br><br>  √Ä la fin de la partie pratique, je rappelle que la liste compl√®te de l'article est disponible dans <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Git</a> : <br><br><ul><li>  <a href="">.gitlab-ci.yml</a> ; </li><li>  <a href="">werf.yaml</a> . </li></ul><br><h2>  R√©sultat </h2><br><ol><li>  Nous avons obtenu une structure de construction logique: un artefact par version. </li><li>  L'assemblage est universel et ne n√©cessite pas de modifications manuelles lors de la sortie de nouvelles versions de werf: la documentation du site est automatiquement mise √† jour. </li><li>  Deux images sont collect√©es pour diff√©rents contours. </li><li>  √áa marche vite car  la mise en cache est utilis√©e au maximum - lorsqu'une nouvelle version de werf est publi√©e ou qu'un hook GitHub est appel√© pour une validation de r√©vision, seul l'artefact correspondant avec une version modifi√©e est reconstruit. </li><li>  Pas besoin de penser √† supprimer les images inutilis√©es: le nettoyage de la politique werf maintiendra l'ordre dans le Docker Registry. </li></ol><br><h2>  Conclusions </h2><br><ul><li>  L'utilisation de werf permet √† l'assembly de fonctionner rapidement gr√¢ce √† la mise en cache de l'assembly lui-m√™me et √† la mise en cache lorsque vous travaillez avec des r√©f√©rentiels externes. </li><li>    Git-               . werf        ,    <code>fetch</code>    . </li><li>   Go-     <code>werf.yaml</code>   ,      . </li><li>    werf     ‚Äî   ,     pipeline. </li><li> werf    ,      . </li></ul><br><h2>  PS </h2><br>     : <br><br><ul><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/476320/">         Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/469541/">      werf  GitLab CI</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/468049/"> werf    Helm-</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/481306/"> werf 1.0 stable:    GitOps,   </a> ¬ª. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478690/">https://habr.com/ru/post/fr478690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478670/index.html">Comment les attaquants peuvent lire votre correspondance dans Telegram. Et comment peuvent-ils l'emp√™cher</a></li>
<li><a href="../fr478672/index.html">Test et d√©marrage de l'IA: entretien avec Adam Carmi (Applitools)</a></li>
<li><a href="../fr478680/index.html">Pourquoi, et surtout, o√π vont les gens de l'informatique?</a></li>
<li><a href="../fr478684/index.html">Introduction au SSD. Partie 2. Interface</a></li>
<li><a href="../fr478688/index.html">Comment c'√©tait d'√©tudier la science des donn√©es en 2019</a></li>
<li><a href="../fr478692/index.html">Prise en charge de Java 8 sur Android</a></li>
<li><a href="../fr478694/index.html">Comme nous vous recommandons les derniers catalogues du cin√©ma en ligne ivi (+ code Python)</a></li>
<li><a href="../fr478696/index.html">Comment j'ai visit√© Urban Tech 2019. Rapport d'√©v√©nement</a></li>
<li><a href="../fr478698/index.html">Nous r√©alisons un plan de terrain interactif en 15 minutes</a></li>
<li><a href="../fr478702/index.html">Astuces de traitement m√©trique dans Kapacitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>