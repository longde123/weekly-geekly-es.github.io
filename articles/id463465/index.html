<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧 🤟🏻 🍊 Buku “JavaScript Ekspresif. Pemrograman web modern. Edisi ke-3 ⏪ 👨🏿‍⚖️ 🌷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Buku ini akan memungkinkan Anda untuk menyelam jauh ke dalam topik, belajar cara menulis kode yang indah dan efektif. Anda akan bel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku “JavaScript Ekspresif. Pemrograman web modern. Edisi ke-3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/463465/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/hj/ac/jw/hjacjwa9yynefuv1iquueauasum.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Buku ini akan memungkinkan Anda untuk menyelam jauh ke dalam topik, belajar cara menulis kode yang indah dan efektif.  Anda akan belajar tentang fungsi sintaks, panah dan asinkron, iterator, string pola, dan ruang lingkup blok. <br><br>  Marein Haverbeke - praktisi.  Dapatkan pengalaman dan belajar bahasa melalui banyak contoh melalui latihan dan proyek pelatihan.  Pertama, Anda akan menjadi terbiasa dengan struktur bahasa JavaScript, mengelola struktur, fungsi dan struktur data, kemudian mempelajari penanganan kesalahan dan perbaikan bug, modularitas dan pemrograman asinkron, dan kemudian beralih ke pemrograman browser. <br><a name="habracut"></a><br><h3>  Tinjau buku ini </h3><br>  Buku ini dibagi menjadi tiga bagian besar.  12 bab pertama membahas bahasa JavaScript.  Tujuh bab berikutnya adalah tentang browser dan bagaimana JavaScript digunakan untuk memprogram mereka.  Akhirnya, dua bab dikhususkan untuk Node.js, lingkungan pemrograman JavaScript lainnya. <br><br>  Sepanjang buku ini Anda akan bertemu lima bab proyek yang menggambarkan contoh program yang lebih besar sehingga Anda dapat merasakan cita rasa pemrograman yang sebenarnya.  Sesuai urutan penampilan mereka, kami akan berupaya membuat robot pengiriman, bahasa pemrograman, platform game, editor grafis raster, dan situs dinamis. <br><br>  Bagian bahasa buku dimulai dengan empat bab yang akan memperkenalkan Anda pada struktur dasar bahasa JavaScript.  Anda akan belajar tentang struktur kontrol (seperti kata kunci sementara, yang sudah Anda lihat dalam pendahuluan), fungsi (menulis blok bangunan Anda sendiri), dan struktur data.  Setelah itu, Anda dapat menulis program yang paling sederhana.  Lebih lanjut, bab 5 dan 6 menjelaskan cara menggunakan fungsi dan objek untuk menulis kode yang lebih abstrak dan mengontrol kerumitannya. <br><br>  Setelah bab dari proyek pertama, bagian bahasa buku akan dilanjutkan - bab-bab berikut ditujukan untuk mendeteksi dan memperbaiki kesalahan, ekspresi reguler (alat penting untuk bekerja dengan teks), modularitas (pertahanan lain terhadap kompleksitas) dan pemrograman asinkron (bekerja dengan peristiwa yang berlangsung selama beberapa waktu).  Bagian pertama dari buku ini diselesaikan oleh bab dari draft kedua. <br><br>  Bagian kedua, bab 13 hingga 19, menjelaskan alat yang dapat diakses oleh browser yang mengaktifkan JavaScript.  Anda akan belajar cara menampilkan elemen di layar (bab 14 dan 17), merespons input pengguna (bab 15) dan membagikannya melalui jaringan (bab 18).  Bagian ini juga berisi dua bab proyek. <br><br>  Setelah itu, Node.js dijelaskan di bab 20, dan situs kecil dibuat di bab 21 menggunakan alat yang ditentukan. <br><br><h3>  Kutipan.  Penjumlahan dengan mengurangi </h3><br>  Hal umum lain yang sering dilakukan dengan array adalah menghitung nilai tunggal berdasarkan pada mereka.  Kasus khusus dari ini adalah contoh yang telah kita gunakan dengan penjumlahan satu set angka.  Contoh lain adalah menemukan font yang mengandung karakter terbanyak. <br><br>  Operasi tingkat tinggi yang menerapkan pola ini disebut singkatan (kadang-kadang juga disebut konvolusi).  Operasi ini membangun nilai dengan berulang kali mendapatkan satu elemen dari array dan menggabungkannya dengan nilai saat ini.  Saat menjumlahkan angka, kita mulai dari nol dan kemudian menambahkan setiap elemen berikutnya ke penjumlahan. <br><br>  Parameter dari fungsi pengurangan, selain array, adalah fungsi menggabungkan dan nilai awal.  Fungsi ini sedikit lebih rumit daripada filter dan peta, jadi perhatikan lebih dekat: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, combine, start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> array) { current = combine(current, element); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], (a, b) =&gt; a + b, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → 10</span></span></code> </pre> <br>  Metode standar untuk bekerja dengan array pengurangan, yang, tentu saja, sesuai dengan fungsi ini, memiliki kenyamanan tambahan.  Jika array berisi setidaknya satu elemen, Anda bisa menghilangkan argumen awal.  Metode memilih elemen pertama array sebagai nilai awal dan mulai reduksi dari elemen kedua. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b)); <span class="hljs-comment"><span class="hljs-comment">// → 10</span></span></code> </pre> <br>  Untuk menggunakan perkecil (dua kali) untuk menemukan font dengan karakter terbanyak, kita dapat menulis sesuatu seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">script</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script.ranges.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, [</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">to — </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span></span><span class="hljs-function">); }, 0); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SCRIPTS.reduce((a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> characterCount(a) &lt; characterCount(b) ? b : a; })); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Han", ...}</span></span></code> </pre> <br>  Fungsi characterCount mengurangi rentang yang ditetapkan untuk font ini dengan menghitung jumlah ukurannya.  Perhatikan penggunaan perusakan dalam daftar parameter fungsi reduksi.  Kemudian panggilan kedua untuk mengurangi menggunakan hasil sebelumnya untuk menemukan font terbesar, berulang kali membandingkan dua font dan mengembalikan yang lebih besar. <br><br>  Font Han memiliki lebih dari 89.000 karakter yang ditetapkan padanya dalam standar Unicode, menjadikannya sistem penulisan terbesar dalam kumpulan data kami.  Han adalah font yang kadang-kadang digunakan untuk teks berbahasa Mandarin, Jepang, dan Korea.  Bahasa mereka memiliki banyak karakter umum, meskipun mereka ditulis secara berbeda.  Konsorsium Unicode (berlokasi di AS) memutuskan untuk mempertimbangkan karakter seperti itu sebagai sistem perekaman tunggal untuk menyimpan kode karakter.  Ini disebut Unifikasi Han dan masih sangat mengganggu bagi sebagian orang. <br><br><h3>  Kompabilitas </h3><br>  Mari kita pikirkan: bagaimana kita dapat menulis ulang contoh sebelumnya (menemukan font terbesar) tanpa fungsi tingkat tinggi?  Kode berikut tidak jauh lebih buruk. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> biggest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (biggest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || characterCount(biggest) &lt; characterCount(script)) { biggest = script; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(biggest); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Han", ...}</span></span></code> </pre> <br>  Beberapa binding tambahan muncul, dan program menjadi empat baris lebih panjang.  Namun kode ini masih cukup jelas. <br><br>  Fungsi tingkat tinggi mulai sangat berguna ketika Anda perlu menyusun operasi.  Sebagai contoh, kami akan menulis kode yang menghitung tahun rata-rata pembuatan font bahasa mati dan hidup dalam kumpulan data. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b) / array.length; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(average( SCRIPTS.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.living).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.year)))); <span class="hljs-comment"><span class="hljs-comment">// → 1188 console.log(Math.round(average( SCRIPTS.filter(s =&gt; !s.living).map(s =&gt; s.year)))); // → 188</span></span></code> </pre> <br>  Dengan demikian, skrip bahasa yang mati di Unicode rata-rata lebih tua dari skrip bahasa yang hidup. <br><br>  Ini bukan statistik yang signifikan atau mengejutkan.  Tapi Anda mudah-mudahan setuju bahwa kode yang digunakan untuk menghitungnya mudah dibaca.  Ini dapat dibayangkan sebagai konveyor: kita mulai dengan menganalisis semua font, menyaring yang hidup (atau mati), mengambil tahun pembuatannya, menghitung nilai rata-rata dan melengkapi hasilnya. <br><br>  Perhitungan ini juga dapat direpresentasikan sebagai satu siklus besar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.living) { total += script.year; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(total / count)); <span class="hljs-comment"><span class="hljs-comment">// → 1188</span></span></code> </pre> <br>  Tetapi dalam kode ini lebih sulit untuk memahami apa dan bagaimana cara menghitungnya.  Dan karena hasil antara tidak disajikan sebagai nilai yang konsisten, banyak pekerjaan yang harus dilakukan untuk memisahkan sesuatu seperti rata-rata menjadi fungsi yang terpisah. <br><br>  Dalam hal apa yang sebenarnya dilakukan komputer, kedua pendekatan ini pada dasarnya berbeda.  Yang pertama membuat array baru ketika filter dan peta dijalankan, sedangkan yang kedua hanya menghitung beberapa angka, melakukan lebih sedikit pekerjaan.  Biasanya Anda dapat membeli opsi yang lebih mudah dibaca, tetapi jika Anda harus memproses array yang sangat besar dan melakukannya berkali-kali, gaya yang kurang abstrak dapat memberi Anda tambahan kecepatan. <br><br><h3>  Kode string dan karakter </h3><br>  Salah satu penggunaan set data adalah untuk menentukan font mana dari suatu teks yang diketikkan.  Mari kita lihat program yang melakukan ini. <br><br>  Ingatlah bahwa untuk setiap font terdapat array rentang kode karakter.  Oleh karena itu, mengetahui kode karakter, kita dapat menggunakan fungsi berikut untuk menemukan font yang sesuai (jika ada): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.ranges.some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code &gt;= <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &amp;&amp; code &lt; to; })) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(characterScript(<span class="hljs-number"><span class="hljs-number">121</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Latin", ...}</span></span></code> </pre> <br>  Beberapa metode adalah fungsi urutan yang lebih tinggi.  Dibutuhkan fungsi tes dan melaporkan jika mengembalikan true untuk elemen array apa pun. <br><br>  Tetapi bagaimana kita mendapatkan kode karakter sebagai string? <br><br>  Dalam Bab 1, saya menyebutkan bahwa dalam JavaScript, string direpresentasikan sebagai urutan angka 16-bit.  Ini adalah unit kode yang disebut.  Awalnya, diasumsikan bahwa dalam Unicode kode karakter akan ditempatkan di blok seperti itu (yang memberikan sedikit lebih dari 65.000 karakter).  Ketika menjadi jelas bahwa ini tidak cukup, banyak mulai keberatan dengan kebutuhan untuk menggunakan lebih banyak memori untuk menyimpan satu karakter.  Untuk mengatasi masalah ini, format UTF-16 yang digunakan dalam string JavaScript diciptakan.  Di dalamnya, karakter yang paling umum menempati satu unit kode 16-bit, dan sisanya - dua unit kode. <br><br>  Hari ini secara umum diterima bahwa UTF-16 adalah ide yang buruk.  Tampaknya dibuat untuk menghasilkan kesalahan.  Anda dapat dengan mudah menulis program yang unit kode dan karakternya satu dan sama.  Dan jika bahasa ibu Anda tidak menggunakan karakter yang menempati dua unit kode, program ini akan berfungsi dengan baik.  Tetapi, segera setelah seseorang mencoba menggunakan program semacam itu untuk alfabet yang kurang umum, misalnya, untuk karakter Cina, itu akan segera pecah.  Untungnya, setelah munculnya emotikon, dua unit kode mulai digunakan di mana-mana untuk pengkodean karakter, dan beban penyelesaian masalah seperti itu didistribusikan lebih adil. <br><br>  Sayangnya, operasi yang jelas dengan string JavaScript, seperti mendapatkan panjangnya melalui properti panjang dan mengakses konten mereka dengan tanda kurung siku, hanya berurusan dengan unit kode. <br><br><img src="https://habrastorage.org/webt/3j/es/v4/3jesv4isii9yakfk56ng-ezxo_i.png" alt="gambar"><br><br>  Metode JavaScript charCodeAt tidak mengembalikan kode karakter lengkap, tetapi unit kode.  Metode codePointAt yang muncul kemudian mengembalikan karakter Unicode penuh.  Jadi kita bisa menggunakan ini untuk mendapatkan karakter dari string.  Namun argumen yang diteruskan ke codePointAt masih berupa indeks dalam urutan unit kode.  Jadi, untuk mengulangi semua karakter dalam string, kita masih perlu menyelesaikan pertanyaan apakah satu atau dua unit kode menempati karakter. <br><br>  Pada bab sebelumnya, saya menyebutkan bahwa for / of loop juga dapat digunakan untuk string.  Seperti codePointAt, jenis loop ini muncul pada saat programmer jelas menyadari masalah UTF-16.  Ketika Anda menerapkan loop ini ke string, itu memberikan karakter nyata, bukan unit kode. <br><br><img src="https://habrastorage.org/webt/bh/8v/n_/bh8vn_vzqr45dpffqo7mlseo_wq.png" alt="gambar"><br><br>  Jika Anda memiliki karakter (yang merupakan string dari satu atau dua unit kode), maka untuk mendapatkan kodenya, Anda dapat menggunakan codePointAt (0). <br><br><h3>  Pengenalan teks </h3><br>  Kami memiliki fungsi characterScript dan cara untuk menghitung dengan benar karakter dalam satu lingkaran.  Langkah selanjutnya adalah menghitung jumlah karakter yang dimiliki masing-masing font.  Di sini kita membutuhkan abstraksi penghitungan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, groupName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = groupName(item); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> known = counts.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.name == name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (known == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { counts.push({name, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { counts[known].count++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(countBy([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], n =&gt; n &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → [{name: false, count: 2}, {name: true, count: 3}]</span></span></code> </pre> <br>  Fungsi countBy menerima koleksi (semua yang bisa diurutkan dalam for / of loop) dan fungsi yang menghitung nama grup untuk elemen yang diberikan.  Fungsi countBy mengembalikan array objek, yang masing-masing berisi nama grup dan jumlah elemen yang ditemukan untuk itu. <br><br>  Fungsi ini menggunakan metode lain untuk bekerja dengan array - findIndex.  Metode ini agak mirip dengan indexOf, tetapi alih-alih mencari nilai tertentu, ia menemukan nilai pertama yang mengembalikan fungsi yang diberikan benar.  Jika item tidak ditemukan, findIndex, seperti indexOf, mengembalikan -1. <br><br>  Dengan menggunakan countBy, kita bisa menulis fungsi yang memberi tahu font mana yang digunakan dalam teks ini. <br><br><img src="https://habrastorage.org/webt/fz/ph/l_/fzphl_qnjsxe6dmsr5rbetd1lam.png" alt="gambar"><br><br>  Fungsi pertama menghitung karakter dengan nama font, menggunakan characterScript untuk memberi mereka nama, dan mengembalikan string "tidak ada" untuk karakter yang bukan milik font apa pun.  Filter panggilan menghapus entri "tidak ada" dari array yang dihasilkan, karena kami tidak tertarik dengan karakter ini. <br><br>  Untuk dapat menghitung persentase, pertama-tama kita perlu mendapatkan jumlah total karakter yang dimiliki font yang dapat kita hitung menggunakan metode pengurangan.  Jika tidak ada karakter yang ditemukan, maka fungsi mengembalikan string tertentu.  Jika tidak, itu mengubah hasil penghitungan menjadi string yang dapat dibaca menggunakan peta, dan kemudian menggabungkannya menggunakan gabungan. <br><br><h3>  Ringkasan </h3><br>  Kemampuan untuk memberikan nilai fungsional ke fungsi lain adalah aspek yang sangat berguna dari JavaScript.  Ini memungkinkan Anda untuk membuat fungsi yang mensimulasikan perhitungan dengan spasi.  Selanjutnya, ketika memanggil fungsi-fungsi tersebut dalam kode, "celah" ini diisi dengan nilai-nilai fungsional. <br><br>  Untuk array, ada sejumlah metode tingkat tinggi yang berguna.  Metode forEach dapat digunakan untuk mengulang elemen-elemen dari sebuah array.  Metode filter mengembalikan array baru yang hanya mengandung elemen yang memenuhi kondisi fungsi predikatif.  Konversi array dengan mengeksekusi fungsi untuk setiap elemen dilakukan dengan menggunakan peta.  Untuk menggabungkan semua elemen array ke dalam satu nilai, Anda bisa menggunakan pengurangan.  Beberapa metode memeriksa apakah ada elemen yang cocok dengan fungsi predikatif yang diberikan.  Akhirnya, metode findIndex menemukan posisi elemen pertama yang cocok dengan predikat. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>JavaScript</b> <br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463465/">https://habr.com/ru/post/id463465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463447/index.html">Astra Linux 1.6 (Smolensk). Apakah sistem siap bekerja dengan pengguna biasa? Contoh Kruk</a></li>
<li><a href="../id463455/index.html">Ribuan hal untuk diperbaiki di Jawa dari versi satu: wawancara hebat dengan Oracle, Sergey Kuksenko</a></li>
<li><a href="../id463459/index.html">Kesalahan tersembunyi dengan Transisi Elemen Bersama</a></li>
<li><a href="../id463461/index.html">Apa yang ada dan apa yang tidak ada dalam Go. Bagian 1</a></li>
<li><a href="../id463463/index.html">Metode untuk membuat efek DRAG dan DROP</a></li>
<li><a href="../id463469/index.html">Kucing Schrodinger tanpa kotak: masalah konsensus dalam sistem terdistribusi</a></li>
<li><a href="../id463471/index.html">Matikan fitur: Tampilan, Manfaat, dan Bekerja dengannya dalam .NET</a></li>
<li><a href="../id463477/index.html">Damai dan tenang: penyumbat telinga dBud dengan dua tingkat pengurangan kebisingan</a></li>
<li><a href="../id463481/index.html">Matematika diskrit untuk WMS: algoritma untuk mengompresi barang dalam sel (bagian 1)</a></li>
<li><a href="../id463483/index.html">Kolaborasi dokumen, obrolan perusahaan yang diperbarui dan aplikasi seluler: Apa yang Baru di Zextras Suite 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>