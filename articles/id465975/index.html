<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🃏 🤞🏿 👩🏽‍🎓 Panduan SQL: Cara Menulis Pertanyaan dengan Lebih Baik (Bagian 2) ⛺️ 🍶 👩🏼‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel lanjutan Panduan SQL: Cara Menulis Query dengan Lebih Baik 

 Dari permintaan hingga rencana eksekusi 
 Mengetahui bahwa antipatterns tidak st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan SQL: Cara Menulis Pertanyaan dengan Lebih Baik (Bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Artikel lanjutan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan SQL: Cara Menulis Query dengan Lebih Baik</a> <br><br><h2>  Dari permintaan hingga rencana eksekusi </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Mengetahui bahwa antipatterns tidak statis dan berevolusi ketika Anda tumbuh sebagai pengembang SQL, dan fakta bahwa ada banyak hal yang perlu dipertimbangkan ketika memikirkan alternatif juga berarti bahwa menghindari antipatterns dan menulis ulang permintaan bisa sangat sulit. tugas.  Bantuan apa pun bisa berguna, itulah sebabnya pendekatan yang lebih terstruktur untuk optimasi kueri menggunakan beberapa alat mungkin paling efektif. <br><br>  Juga harus dicatat bahwa beberapa antipatterns yang disebutkan di bagian terakhir berakar pada masalah kinerja, seperti operator <code>AND</code> , <code>OR</code> dan <code>NOT</code> dan ketidakhadiran mereka saat menggunakan indeks.  Berpikir tentang kinerja tidak hanya membutuhkan lebih terstruktur, tetapi juga pendekatan yang lebih dalam. <br><br>  Namun, pendekatan terstruktur dan mendalam ini terutama akan didasarkan pada rencana kueri, yang, seperti yang Anda ingat, adalah hasil dari kueri pertama yang diuraikan menjadi "parsing tree" atau "parse tree" dan menentukan dengan tepat algoritma mana digunakan untuk setiap operasi dan bagaimana pelaksanaannya dikoordinasikan. <br><a name="habracut"></a><br><h2>  Optimasi kueri </h2><br>  Saat Anda membaca di pendahuluan, Anda mungkin perlu memeriksa dan mengatur paket yang dikompilasi secara manual oleh optimizer.  Dalam kasus seperti itu, Anda perlu menganalisis permintaan Anda lagi dengan melihat rencana permintaan. <br><br>  Untuk mengakses rencana ini, Anda harus menggunakan alat yang disediakan oleh sistem manajemen basis data.  Alat-alat berikut ini dapat Anda gunakan: <br><br><ul><li>  Beberapa paket berisi alat yang menghasilkan representasi grafis dari rencana kueri.  Perhatikan contoh berikut: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  Alat lain akan memberikan deskripsi tekstual dari rencana kueri.  Salah satu contohnya adalah pernyataan <code>EXPLAIN PLAN</code> di Oracle, tetapi nama instruksi tergantung pada DBMS yang Anda gunakan.  Di tempat lain Anda dapat menemukan <code>EXPLAIN</code> (MySQL, PostgreSQL) atau <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Harap dicatat</b> bahwa ketika bekerja dengan PostgreSQL, Anda dapat membuat perbedaan antara <code>EXPLAIN</code> , di mana Anda hanya mendapatkan deskripsi yang memberi tahu bagaimana perencana bermaksud untuk mengeksekusi kueri tanpa menjalankannya, sementara <code>EXPLAIN ANALYZE</code> benar-benar mengeksekusi kueri dan mengembalikan analisis kepada Anda rencana permintaan yang diharapkan dan aktual.  Secara umum, rencana pelaksanaan nyata adalah rencana di mana permintaan sebenarnya dieksekusi, sementara rencana pelaksanaan evaluasi menentukan apa yang akan dilakukannya tanpa memenuhi permintaan.  Meskipun ini setara secara logis, rencana eksekusi sebenarnya jauh lebih berguna karena berisi informasi tambahan dan statistik tentang apa yang sebenarnya terjadi ketika permintaan dieksekusi. <br><br>  Di bagian selanjutnya, Anda akan belajar lebih banyak tentang <code>EXPLAIN</code> dan <code>ANALYZE</code> , serta cara menggunakannya untuk mendapatkan informasi lebih lanjut tentang rencana kueri dan kemungkinan kinerjanya.  Untuk melakukan ini, mulailah dengan beberapa contoh di mana Anda akan bekerja dengan dua tabel: <code>one_million</code> dan <code>half_million</code> . <br><br>  Anda bisa mendapatkan informasi saat ini dari tabel <code>one_million</code> menggunakan <code>EXPLAIN</code> ;  Pastikan untuk meletakkannya langsung di atas permintaan, dan setelah menjalankannya, itu akan mengembalikan rencana kueri kepada Anda: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  Dalam hal ini, Anda melihat bahwa biaya permintaan adalah <code>0.00..18584.82</code> , dan jumlah baris adalah <code>1025082</code> .  Lebar jumlah kolom adalah <code>36</code> . <br><br>  Selain itu, Anda dapat memperbarui statistik menggunakan <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Selain <code>EXPLAIN</code> dan <code>ANALYZE</code> , Anda juga bisa mendapatkan runtime sebenarnya dengan <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  Kerugian menggunakan <code>EXPLAIN ANALYZE</code> adalah bahwa kueri benar-benar dieksekusi, jadi berhati-hatilah dengan ini! <br><br>  Sejauh ini, semua algoritma yang telah Anda lihat adalah <code>Seq Scan</code> ( <code>Seq Scan</code> Sekuensial) atau Pemindaian Tabel Penuh: ini adalah pemindaian yang dilakukan dalam database di mana setiap baris tabel yang dipindai dibaca dalam urutan serial dan kolom yang ditemukan diperiksa untuk kepatuhan dengan kondisi atau tidak.  Dalam hal kinerja, pemindaian berurutan jelas bukan rencana eksekusi terbaik karena Anda masih melakukan pemindaian tabel penuh.  Namun, ini tidak terlalu buruk ketika tabel tidak pas di memori: membaca berurutan cukup cepat bahkan pada disk yang lambat. <br><br>  Anda akan belajar lebih banyak tentang ini nanti ketika kita berbicara tentang pemindaian indeks. <br><br>  Namun, ada algoritma lain.  Ambil, misalnya, paket permintaan ini untuk koneksi: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  Anda melihat bahwa pengoptimal kueri memilih <code>Hash Join</code> sini!  Ingat operasi ini, karena Anda akan memerlukannya untuk mengevaluasi kompleksitas waktu permintaan Anda.  Untuk saat ini, perhatikan bahwa tidak ada indeks di <code>half_million.counter</code> , yang kami tambahkan dalam contoh berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Anda melihat bahwa dengan membuat indeks, pengoptimal kueri sekarang telah memutuskan untuk menggunakan <code>Merge join</code> saat memindai <code>Index Scan</code> Indeks. <br><br>  <b>Perhatikan</b> perbedaan antara pemindaian indeks dan pemindaian tabel penuh atau pemindaian berurutan: yang pertama, juga disebut "pemindaian tabel," memindai data atau halaman indeks untuk menemukan catatan yang sesuai, sedangkan yang kedua memindai setiap baris tabel. <br><br>  Anda melihat bahwa runtime keseluruhan telah menurun dan kinerja harus lebih baik, tetapi ada dua pemindaian indeks, yang membuat memori lebih penting di sini, terutama jika tabel tidak cocok dengan itu.  Dalam kasus seperti itu, Anda harus terlebih dahulu melakukan pemindaian indeks penuh, yang dilakukan menggunakan pembacaan berurutan cepat dan bukan masalah, tetapi kemudian Anda memiliki banyak operasi pembacaan acak untuk memilih baris berdasarkan nilai indeks.  Ini adalah operasi baca acak yang biasanya beberapa urutan besarnya lebih lambat daripada yang berurutan.  Dalam kasus ini, pemindaian tabel lengkap memang terjadi lebih cepat daripada pemindaian indeks penuh. <br><br>  <b>Kiat:</b> Jika Anda ingin mempelajari lebih lanjut tentang MENJELASKAN atau mempertimbangkan contoh secara lebih rinci, coba baca Penjelasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemahaman</a> Guillaume Lelarge. <br><br><h2>  Kompleksitas Waktu dan Big O </h2><br>  Sekarang setelah Anda meninjau rencana kueri secara singkat, Anda dapat mulai menggali lebih dalam dan memikirkan kinerja dalam istilah yang lebih formal menggunakan teori kompleksitas komputasi.  Ini adalah bidang ilmu komputer teoretis, yang, antara lain, berfokus pada klasifikasi masalah komputasi tergantung pada kompleksitasnya;  Masalah komputasi ini mungkin berupa algoritme, tetapi juga kueri. <br><br>  Namun, untuk pertanyaan, mereka tidak perlu diklasifikasikan menurut kompleksitasnya, tetapi lebih tergantung pada waktu yang dibutuhkan untuk menyelesaikannya dan mendapatkan hasil.  Ini disebut kompleksitas waktu, dan Anda dapat menggunakan notasi O besar untuk merumuskan atau mengukur jenis kompleksitas ini. <br><br>  Dengan penunjukan O besar, Anda mengekspresikan runtime dalam hal seberapa cepat itu tumbuh relatif terhadap input, karena input menjadi besar secara sewenang-wenang.  Notasi O besar mengecualikan koefisien dan anggota dari urutan yang lebih rendah, sehingga Anda dapat fokus pada bagian penting dari waktu eksekusi kueri Anda: laju pertumbuhannya.  Ketika diekspresikan dengan cara ini, membuang koefisien dan syarat-syarat dari orde yang lebih rendah, mereka mengatakan bahwa kompleksitas waktu dijelaskan secara asimptotik.  Ini berarti bahwa ukuran input masuk hingga tak terhingga. <br><br>  Dalam bahasa database, kompleksitas menentukan berapa lama waktu yang dibutuhkan untuk menyelesaikan kueri saat ukuran tabel data dan oleh karena itu database tumbuh. <br><br>  <b>Harap dicatat</b> bahwa ukuran basis data Anda meningkat tidak hanya dari peningkatan jumlah data dalam tabel, tetapi fakta bahwa ada indeks juga memainkan peran dalam ukuran. <br><br>  Memperkirakan kompleksitas waktu dari rencana kueri Anda <br><br>  Seperti yang Anda lihat sebelumnya, rencana eksekusi, antara lain, menentukan algoritma mana yang digunakan untuk setiap operasi, yang memungkinkan Anda untuk secara logis mengekspresikan setiap waktu eksekusi kueri sebagai fungsi dari ukuran tabel yang termasuk dalam rencana kueri, yang disebut fungsi kompleksitas.  Dengan kata lain, Anda dapat menggunakan notasi O besar dan rencana eksekusi untuk mengevaluasi kompleksitas dan kinerja kueri. <br><br>  Di bagian berikut, Anda akan mendapatkan gambaran umum dari empat jenis kompleksitas waktu, dan Anda akan melihat beberapa contoh bagaimana kompleksitas waktu kueri dapat bervariasi tergantung pada konteks di mana ia dieksekusi. <br><br>  Petunjuk: indeks adalah bagian dari cerita ini! <br><br>  <b>Namun, harus dicatat</b> bahwa ada berbagai jenis indeks, rencana eksekusi yang berbeda, dan implementasi yang berbeda untuk database yang berbeda, sehingga kesulitan sementara yang tercantum di bawah ini sangat umum dan dapat bervariasi tergantung pada pengaturan tertentu. <br><br><h3>  O (1): Waktu Konstan </h3><br>  Mereka mengatakan bahwa suatu algoritma bekerja dalam waktu yang konstan jika membutuhkan jumlah waktu yang sama terlepas dari ukuran data input.  Ketika datang ke permintaan, itu akan dieksekusi dalam waktu yang konstan jika jumlah waktu yang sama diperlukan terlepas dari ukuran tabel. <br><br>  Jenis kueri ini tidak terlalu umum, tetapi ini adalah salah satu contohnya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  Kompleksitas waktu adalah konstan, karena satu baris arbitrer dipilih dari tabel.  Oleh karena itu, lamanya waktu seharusnya tidak tergantung pada ukuran tabel. <br><br><h3>  Waktu Linier: O (n) </h3><br>  Mereka mengatakan bahwa algoritma bekerja dalam waktu linier, jika waktu eksekusi berbanding lurus dengan ukuran data input, yaitu, waktu meningkat secara linier dengan ukuran data input.  Untuk database, ini berarti bahwa waktu eksekusi akan berbanding lurus dengan ukuran tabel: saat jumlah baris dalam tabel bertambah, waktu eksekusi permintaan meningkat. <br><br>  Contohnya adalah permintaan dengan <code>WHERE</code> untuk kolom yang tidak terindeks: pemindaian tabel penuh atau <code>Seq Scan</code> akan diperlukan, yang akan mengarah pada kompleksitas waktu O (n).  Ini berarti bahwa setiap baris harus dibaca untuk menemukan baris dengan pengenal yang diinginkan (ID).  Anda tidak memiliki batasan sama sekali, jadi Anda harus menghitung setiap baris, bahkan jika baris pertama cocok dengan kondisi tersebut. <br><br>  Pertimbangkan juga contoh kueri berikut, yang akan memiliki kompleksitas O (n) jika tidak ada indeks pada bidang <code>i_id</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  Penjelasan sebelumnya juga berarti bahwa kueri lain, seperti kueri untuk menghitung jumlah baris <code>COUNT (*) FROM TABLE;</code>  akan memiliki kompleksitas waktu <i>O (n)</i> , karena pemindaian tabel penuh akan diperlukan karena jumlah baris belum disimpan untuk tabel.  Kalau tidak, kompleksitas waktu akan mirip dengan <i>O (1)</i> . <br></li></ul><br>  Runtime linier terkait erat dengan runtime paket yang memiliki gabungan tabel.  Berikut ini beberapa contohnya: <br><br><ul><li>  Gabung hash memiliki kompleksitas yang diharapkan dari O (M + N) .Gabung hash klasik untuk menggabungkan dua tabel secara internal terlebih dahulu mempersiapkan tabel hash dari tabel yang lebih kecil.  Entri tabel hash terdiri dari atribut koneksi dan stringnya.  Tabel hash diakses dengan menerapkan fungsi hash ke atribut koneksi.  Setelah tabel hash dibangun, tabel besar dipindai, dan baris yang sesuai dari tabel yang lebih kecil ditemukan dengan mencari tabel hash. </li><li>  Gabungan gabungan biasanya memiliki kompleksitas O (M + N), tetapi akan sangat bergantung pada indeks kolom gabungan dan, jika tidak ada indeks, apakah baris diurutkan menurut kunci yang digunakan dalam gabungan: <ul><li>  Jika kedua tabel diurutkan berdasarkan tombol yang digunakan dalam gabungan, maka kueri akan memiliki kompleksitas waktu O (M + N). </li><li>  Jika kedua tabel memiliki indeks untuk kolom yang bergabung, maka indeks sudah mendukung kolom ini dalam urutan dan penyortiran tidak diperlukan.  Kesulitannya adalah O (M + N). </li><li>  Jika tidak ada tabel yang memiliki indeks pada kolom yang terhubung, Anda harus mengurutkan kedua tabel terlebih dahulu, sehingga kompleksitasnya akan terlihat seperti O (M log M + N log N). </li><li>  Jika hanya satu dari tabel yang memiliki indeks pada kolom yang terhubung, maka hanya tabel yang tidak memiliki indeks yang harus diurutkan sebelum langkah bergabung terjadi, sehingga kerumitan akan terlihat seperti O (M + N log N). </li></ul></li><li>  Untuk nested joins, kompleksitasnya biasanya O (MN).  Gabung ini efektif ketika satu atau kedua tabel sangat kecil (misalnya, kurang dari 10 catatan), yang merupakan situasi yang sangat umum ketika mengevaluasi kueri, karena beberapa subquery ditulis untuk mengembalikan hanya satu baris. </li></ul><br>  <b>Ingat:</b> gabungan bersarang adalah gabungan yang membandingkan setiap catatan dalam satu tabel dengan setiap catatan di yang lain. <br><br><h3>  Waktu Logaritma: O (log (n)) </h3><br>  Dikatakan bahwa suatu algoritma bekerja dalam waktu logaritma jika waktu eksekusi proporsional dengan logaritma ukuran input;  Untuk permintaan, ini berarti bahwa mereka akan dieksekusi jika waktu eksekusi sebanding dengan logaritma ukuran database. <br><br>  Kompleksitas waktu logaritmik ini valid untuk rencana kueri tempat <code>Index Scan</code> atau indeks berkerumun dipindai.  Indeks berkerumun adalah indeks di mana level indeks akhir berisi baris aktual tabel.  Indeks berkerumun mirip dengan indeks lain: itu didefinisikan dalam satu atau lebih kolom.  Mereka membentuk kunci indeks.  Kunci pengelompokan adalah kolom kunci dari indeks pengelompokan.  Memindai indeks berkerumun pada dasarnya adalah operasi membaca DBMS Anda untuk satu baris atau baris dari atas ke bawah dalam indeks berkerumun. <br><br>  Pertimbangkan contoh permintaan berikut, di mana ada indeks untuk <code>i_id</code> dan yang biasanya menghasilkan kompleksitas O (log (n)): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Perhatikan bahwa tanpa indeks, kompleksitas waktu adalah O (n). <br><br><h3>  Waktu Quadratic: O (n ^ 2) </h3><br>  Dipercaya bahwa algoritma dieksekusi dalam waktu kuadratik, jika waktu eksekusi sebanding dengan kuadrat ukuran input.  Sekali lagi, untuk basis data, ini berarti waktu eksekusi kueri sebanding dengan kuadrat ukuran basis data. <br><br>  Contoh kemungkinan kueri kompleksitas waktu kuadratik adalah sebagai berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  Kompleksitas minimum mungkin O (n log (n)), tetapi kompleksitas maksimum mungkin O (n ^ 2) berdasarkan informasi indeks atribut koneksi. <br><br>  Untuk meringkas, Anda juga dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada lembar contekan berikut</a> untuk mengevaluasi kinerja permintaan berdasarkan kompleksitas waktu dan efektivitasnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  Penyetelan SQL </h2><br>  Dengan adanya rencana eksekusi query dan kompleksitas waktu, Anda dapat lebih lanjut menyesuaikan kueri SQL Anda.  Anda dapat mulai dengan memfokuskan pada poin-poin berikut: <br><br><ul><li>  Ganti pindaian tabel penuh yang tidak perlu dengan pindaian indeks; </li><li>  Pastikan bahwa urutan bergabung optimal diterapkan. </li><li>  Pastikan indeks digunakan secara optimal.  Dan </li><li>  Caching scan teks lengkap dari tabel kecil (cache tabel kecil scan tabel penuh.) Digunakan. </li></ul><br><h2>  Penggunaan SQL lebih lanjut </h2><br>  Selamat!  Anda telah sampai pada akhir artikel ini, yang hanya memberi Anda sedikit melihat kinerja query SQL.  Saya harap Anda memiliki lebih banyak informasi tentang antipatterns, optimizer kueri, dan alat yang dapat Anda gunakan untuk menganalisis, mengevaluasi, dan menafsirkan kompleksitas rencana kueri Anda.  Namun, masih banyak yang harus Anda temukan!  Jika Anda ingin tahu lebih banyak, baca buku "Sistem Manajemen Basis Data" oleh R. Ramakrishnan dan J. Gehrke. <br><br>  Akhirnya, saya tidak ingin menyangkal StackOverflow dari Anda dalam kutipan ini: <br><blockquote>  Antipattern favorit saya tidak memeriksa permintaan Anda. <br><br>  Namun, itu berlaku ketika: <br><br><ul><li>  Kueri Anda menyediakan lebih dari satu tabel. </li><li>  Anda berpikir bahwa Anda memiliki desain yang optimal untuk permintaan tersebut, tetapi jangan mencoba memverifikasi asumsi Anda. </li><li>  Anda menerima permintaan kerja pertama, tidak tahu seberapa dekat dengan optimal. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465975/">https://habr.com/ru/post/id465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465959/index.html">Pohon keluarga di dalam git</a></li>
<li><a href="../id465961/index.html">Pelajari Pemasaran Internet Anda Sendiri: Lebih dari 50 Kursus Gratis</a></li>
<li><a href="../id465963/index.html">Biografi Gaji di Jerman 2019</a></li>
<li><a href="../id465969/index.html">Political Correctness Menembus Rusia Melalui Buku-Buku tentang Merancang Keripik pada SystemVerilog untuk Non-Pemula</a></li>
<li><a href="../id465973/index.html">10 laporan video paling populer dari 404fest 2018</a></li>
<li><a href="../id465977/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 31. CDP, Syslog dan NTP</a></li>
<li><a href="../id465979/index.html">Ingat semua ^ W hanya yang Anda butuhkan. Pengalaman menggunakan Anki. Bagian 1 (pengantar, kedua dari belakang)</a></li>
<li><a href="../id465981/index.html">Pengalaman administrasi IBM DB2 Express-C saya ketika digunakan dengan 1C: Enterprise</a></li>
<li><a href="../id465983/index.html">Intel Comet Lake: sedikit 14 nm pada generasi kesepuluh</a></li>
<li><a href="../id465985/index.html">Kami mempercepat pemrosesan terdistribusi grafik besar menggunakan struktur data probabilistik dan tidak hanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>