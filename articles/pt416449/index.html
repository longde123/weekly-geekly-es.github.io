<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😰 🚨 🤽🏿 .NET Core + Docker no Raspberry Pi. Isso é legal? 🏐 👨🏾‍🏫 🚵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A plataforma aberta do .NET Core funciona em quase tudo: Windows, Mac e uma dúzia de sistemas Linux. Mas há também um SDK e Runtime. Anteriormente, o ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET Core + Docker no Raspberry Pi. Isso é legal?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/416449/">  A plataforma aberta do .NET Core funciona em quase tudo: Windows, Mac e uma dúzia de sistemas Linux.  Mas há também um SDK e Runtime.  Anteriormente, o .NET Core SDK não era suportado nos chips ARMv7 / ARMv8 que executam o Raspberry Pi.  Mas tudo mudou.  Mais sobre como executar sob o corte! <br><br><img src="https://habrastorage.org/webt/_f/b3/eg/_fb3egm773lk0sdnwyqx7cah0-s.jpeg"><a name="habracut"></a><br><br>  <i>Este artigo foi escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scott Hanselman</a> .</i>  <i>Eu dou a ele a palavra.</i> <br><br>  Eu gosto do Raspberry Pi.  São ótimas máquinas compactas de aprendizado e as crianças gostam muito de brincar com elas.  Mesmo que essas crianças sejam adultas, elas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criam um cluster de seis nós Kubernetes Raspberry Pi</a> . <br><br>  <b>O NET Core agora é suportado em distribuições Linux ARM32 como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Raspbian</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ubuntu</a> !</b> <br><br><blockquote>  <i>Nota</i>  O .NET Core 2.1 é suportado no Raspberry Pi 2+.  Não é suportado no Pi Zero ou em outros dispositivos com um chip ARMv6.  Para trabalhar com o .NET Core, é necessário um chip ARMv7 ou ARMv8, como um ARM Cortex-A53.  Os especialistas da equipe do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Azure IoT Edge</a> usam as imagens .NET Core Bionic ARM32 Docker .NET para oferecer suporte a desenvolvedores que <a href="">escrevem em C # em dispositivos Edge</a> . </blockquote><br>  Existem duas maneiras de executar o .NET Core no Raspberry Pi. <br><br>  <b>A primeira maneira</b> é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usar o Docker</a> .  Essa é literalmente a maneira mais rápida e fácil de executar o .NET Core em um Pi.  Parece inacreditável, mas esses pequenos dispositivos Raspberry Pi suportam perfeitamente os contêineres da plataforma Docker.  Isso pode ser feito em minutos.  Para instalar rapidamente o Docker, você precisará de: <br><br><pre><code class="cs hljs">curl -sSL https:<span class="hljs-comment"><span class="hljs-comment">//get.docker.com | sh sudo usermod -aG docker pi</span></span></code> </pre> <br>  Após instalar o Docker, você deve efetuar login e sair.  Confira um pequeno exemplo para garantir que o .NET Core esteja funcionando corretamente.  Você pode ver as tags disponíveis do Docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em</a> e saber mais sobre os modelos do .NET Core Docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Agora posso iniciar o Docker e executar o comando "dotnet --info" para descobrir sobre o dotnet no meu Pi. <br><br><pre> <code class="cs hljs">pi@raspberrypi:~ $ docker run --rm -it microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk dotnet --info .<span class="hljs-function"><span class="hljs-function">NET Core </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDK</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reflecting any </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">global</span></span></span></span><span class="hljs-function"><span class="hljs-params">.json</span></span></span><span class="hljs-function">): Version: 2.1.300-rc1-008673 Commit: f5e3ddbe73 Runtime Environment: OS Name: debian OS Version: 9 OS Platform: Linux RID: debian.9-x86 Base Path: /usr/share/dotnet/sdk/2.1.300-rc1-008673/ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Host</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">useful </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> support</span></span></span><span class="hljs-function">): Version: 2.1.0-rc1 Commit: eb9bc92051 .NET Core SDKs installed: 2.1.300-rc1-008673 [/usr/share/dotnet/sdk] .NET Core runtimes installed: Microsoft.NETCore.App 2.1.0-rc1 [/usr/share/dotnet/shared/Microsoft.NETCore.App] To install additional .NET Core runtimes or SDKs: https:</span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//aka.ms/dotnet-download</span></span></span></span></code> </pre> <br>  Isso é ótimo!  Agora, apenas solicito o dotnet: 2.1-sdk no Raspberry Pi (RPi) e, como eles usam arquivos de arquitetura múltipla do Docker, a plataforma funciona corretamente.  Se você quiser usar o <a href="">.NET Core com Docker no ARM32</a> , poderá usar qualquer uma das seguintes tags. <br><br><blockquote>  <i>Nota</i>  As três primeiras tags são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multi-arch</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biion</a> para o Ubuntu 18.04.  O nome do código é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estendido</a> para o Debian 9. Portanto, eu uso o 2.1-sdk e funciona bem no meu RPi, mas posso ser mais específico se quiser. </blockquote><br><ul><li>  2.1-sdk </li><li>  2.1 tempo de execução </li><li>  2.1-aspnetcore-runtime </li><li>  2.1-sdk-stretch-arm3 </li><li>  2.1-runtime-stretch-slim-arm32v7 </li><li>  2.1-aspnetcore-runtime-stretch-slim-arm32v7 </li><li>  2.1-sdk-biion-arm32v7 </li><li>  2.1-runtime-biion-arm32v7 </li><li>  2.1-aspnetcore-runtime-biion-arm32v7 </li></ul><br>  Tente em minutos desta maneira: <br><br><pre> <code class="cs hljs">docker run --rm microsoft/dotnet-samples:dotnetapp</code> </pre> <br>  Aqui ele baixa a imagem ... <br><br><img src="https://habrastorage.org/webt/33/6m/xs/336mxsz44dzblzznmtsbk7xsykk.png"><br><br>  Nas versões anteriores dos arquivos do .NET Core Docker, isso não funcionaria se você executasse a imagem x64 no ARM. <br><br><pre> <code class="cs hljs">standard_init_linux.go:<span class="hljs-number"><span class="hljs-number">190</span></span>: exec user process caused <span class="hljs-string"><span class="hljs-string">"exec format error"</span></span></code> </pre> <br>  Processadores diferentes!  Mas com as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tags de</a> arquitetura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">múltipla</a> da Kendra Havens da Microsoft, tudo funciona bem na versão 2.1. <br><br><blockquote>  O Docker possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um recurso de multi-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquitetura</a> que recentemente começou a ser usado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">microsoft / dotnet-nightly</a> .  Em um futuro próximo, está planejado transferir isso para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório</a> oficial da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">microsoft / dotnet</a> .  O recurso de arquitetura múltipla permite que você use uma tag para várias configurações da máquina.  Sem esse recurso, uma tag exclusiva é necessária para cada arquitetura / OS / plataforma.  Por exemplo, a tag microsoft / dotnet: 1.0-runtime é baseada no Debian, e a tag microsoft / dotnet: 1.0-runtime-nanoserver está no Nano Server.  Com a arquitetura múltipla, apenas uma tag microsoft / dotnet comum será necessária: 1.0-runtime.  Se você pega essa tag no ambiente de contêiner Linux, obtém uma imagem baseada no Debian, enquanto que se você pega no ambiente de contêiner do Windows, obtém uma imagem baseada no Nano Server.  Isso ajuda a garantir que as tags sejam consistentes no ambiente do Docker, evitando confusões. </blockquote><br>  Nos exemplos acima, posso fazer o seguinte: <br><br>  Execute um aplicativo pré-configurado dentro de uma imagem do Docker, por exemplo: <br> <code>docker run --rm microsoft/dotnet-samples:dotnetapp</code> <br> <br>  Execute comandos dotnet em uma imagem SDK, por exemplo: <br> <code>docker run --rm -it microsoft/dotnet:2.1-sdk dotnet --info</code> <br> <br>  Inicie um terminal interativo em uma imagem SDK, por exemplo: <br> <code>docker run --rm -it microsoft/dotnet:2.1-sdk</code> <br> <br>  Como um pequeno exemplo, aqui vou entrar no contêiner, adicionar um pequeno aplicativo de console e executá-lo, apenas para provar que isso é possível.  Tudo será excluído quando eu sair do contêiner. <br><br><pre> <code class="cs hljs">pi@raspberrypi:~ $ docker run --rm -it microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk root@<span class="hljs-number"><span class="hljs-number">063f</span></span>3c50c88a:/<span class="hljs-meta"><span class="hljs-meta"># ls bin boot dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var root@063f3c50c88a:/# cd ~ root@063f3c50c88a:~# mkdir mytest root@063f3c50c88a:~# cd mytest/ root@063f3c50c88a:~/mytest# dotnet new console The template "Console Application" was created successfully. Processing post-creation actions... Running 'dotnet restore' on /root/mytest/mytest.csproj... Restoring packages for /root/mytest/mytest.csproj... Installing Microsoft.NETCore.DotNetAppHost 2.1.0-rc1. Installing Microsoft.NETCore.DotNetHostResolver 2.1.0-rc1. Installing NETStandard.Library 2.0.3. Installing Microsoft.NETCore.DotNetHostPolicy 2.1.0-rc1. Installing Microsoft.NETCore.App 2.1.0-rc1. Installing Microsoft.NETCore.Platforms 2.1.0-rc1. Installing Microsoft.NETCore.Targets 2.1.0-rc1. Generating MSBuild file /root/mytest/obj/mytest.csproj.nuget.g.props. Generating MSBuild file /root/mytest/obj/mytest.csproj.nuget.g.targets. Restore completed in 15.8 sec for /root/mytest/mytest.csproj. Restore succeeded. root@063f3c50c88a:~/mytest# dotnet run Hello World! root@063f3c50c88a:~/mytest# dotnet exec bin/Debug/netcoreapp2.1/mytest.dll Hello World!</span></span></code> </pre> <br>  Se você tentar você mesmo, notará que o comando dotnet run está lento.  Isso ocorre porque ele executa recuperação, compilação e inicialização.  A compilação não é muito rápida nesses pequenos dispositivos.  Portanto, vale a pena fazer o mínimo de trabalho possível.  Em vez de executar o dotnet run o tempo todo, executarei o comando dotnet build e, em seguida, o exec do dotnet, que é muito rápido. <br><br>  Se você tentar o Docker e o .NET Core, esses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recursos</a> serão incrivelmente úteis para você. <br><br><h2>  Criando aplicativos .NET Core usando o Docker </h2><br><ul><li>  <a href="">Exemplo para o .NET Core Docker</a> - Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> cria, testa e executa uma amostra.  Ele inclui e cria vários projetos. </li><li>  <a href="">Exemplo do ASP.NET Core Docker</a> - Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> demonstra como usar o Docker usando o aplicativo Web ASP.NET Core. </li></ul><br><h2>  Criando aplicativos .NET Core em um contêiner </h2><br><ul><li>  <a href="">Desenvolvimento de aplicativos .NET Core</a> - Este exemplo mostra como desenvolver, criar e testar aplicativos .NET Core usando o Docker sem instalar o .NET Core SDK. </li><li>  <a href="">Desenvolvimento de aplicativos principais do ASP.NET</a> - Este exemplo mostra como desenvolver e testar aplicativos básicos do ASP.NET usando o Docker sem instalar o .NET Core SDK. </li></ul><br><h2>  Otimização do tamanho do contêiner </h2><br><ul><li>  <a href="">Exemplo para o .NET Core Alpine Docker</a> - neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> , um aplicativo é criado, testado e iniciado usando o Alpine. </li><li>  <a href="">Exemplo para aplicativos independentes NET Core</a> - neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> , um aplicativo independente é criado e iniciado. </li></ul><br><h2>  ARM32 / FRAMBOESA PI </h2><br><ul><li>  <a href="">Exemplo para o .NET Core ARM32 Docker</a> - neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> , o aplicativo é criado e lançado do Debian para o ARM32 (executado no Raspberry Pi). </li><li>  <a href="">Exemplo para o Docker do ASP.NET Core ARM32</a> - neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> , o aplicativo ASP.NET Core é criado e iniciado do Debian para o ARM32 (executado no Raspberry Pi). </li></ul><br>  Parece-me que <a href="">esses exemplos são</a> muito úteis ... Verifique os arquivos do Docker, pois eles fornecerão uma quantidade enorme de informações sobre como estruturar seus próprios arquivos.  A capacidade de criar arquivos Docker de vários estágios é crítica ao trabalhar em um dispositivo pequeno, como o RPi.  É recomendável fazer o mínimo de trabalho possível e deixar o Docker armazenar em cache automaticamente o maior número possível de camadas.  Se você não pensar nesse ponto, vai gastar 10 vezes mais tempo criando camadas de imagem para cada montagem. <br><br><h2>  Tradução de um site ASP.NET real no Docker com testes! </h2><br>  Posso transferir meu site com podcasts para o Docker e também compilar / testar / executá-lo no Raspberry Pi?  Sim <br><br><pre> <code class="cs hljs">FROM microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk AS build WORKDIR /app <span class="hljs-meta"><span class="hljs-meta"># copy csproj and restore as distinct layers COPY *.sln . COPY hanselminutes.core/*.csproj ./hanselminutes.core/ COPY hanselminutes.core.tests/*.csproj ./hanselminutes.core.tests/ RUN dotnet restore # copy everything </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> and build app COPY . . WORKDIR /app/hanselminutes.core RUN dotnet build FROM build AS testrunner WORKDIR /app/hanselminutes.core.tests ENTRYPOINT ["dotnet", "test", "--logger:trx"] FROM build AS test WORKDIR /app/hanselminutes.core.tests RUN dotnet test FROM build AS publish WORKDIR /app/hanselminutes.core RUN dotnet publish -c Release -o out FROM microsoft/dotnet:2.1-aspnetcore-runtime AS runtime WORKDIR /app COPY --from=publish /app/hanselminutes.core/out ./ ENTRYPOINT ["dotnet", "hanselminutes.core.dll"]</span></span></code> </pre> <br>  Ótimo  Agora eu posso executar o comando docker build.  no Raspberry Pi.  O dispositivo irá restaurar, testar e construir.  Se o teste falhar, a construção do Docker falhará. <br><br>  Veja bem, há uma seção adicional chamada "testrunner" e depois "test?".  Esta seção não funciona.  Ele define ENTRYPOINT, mas ninguém nunca o usa ... por enquanto.  ENTRYPOINT é um início implícito se estiver na última linha do arquivo Docker.  Isso é feito para que eu possa encontrá-lo, se quiser. <br><br>  Eu posso apenas construir e rodar assim: <br><br><pre> <code class="cs hljs">docker build -t podcast . docker run --rm -it -p <span class="hljs-number"><span class="hljs-number">8000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> podcast</code> </pre> <br><blockquote>  <i>Nota</i>  Observe que a imagem "runtime" é microsoft / dotnet: 2.1-aspnetcore-runtime, não microsoft / dotnet: 2.1-runtime.  Além disso, o aspnetcore one inclui anteriormente o código binário necessário para executar o aplicativo ASP.NET, para que eu possa incluir apenas um link para "/&gt;" no csproj.  Se você não usou a imagem base do aspnetcore-runtime, teria que ativar manualmente todos os pacotes do ASP.NET Core necessários.  O uso de uma imagem básica pode aumentar os arquivos de imagem final, mas esse é apenas um equilíbrio entre conveniência e tamanho.  Depende de você.  Você pode ativar manualmente apenas os pacotes necessários ou usar o meta-pacote "Microsoft.AspNetCore.App" por conveniência.  Minha imagem final de podcast pesava 205 megabytes, o que não é ruim, mas, é claro, se eu quisesse, poderia reduzi-la de várias maneiras. </blockquote><br>  E se eu apenas precisar <a href="">dos</a> resultados <a href="">dos testes do Docker</a> , posso obtê-los!  Isso significa que eu posso executar o teste no contêiner do Docker, montar o volume entre o contêiner do Linux e o host (teórico) do Windows e abrir o arquivo .trx resultante no Visual Studio! <br><br><pre> <code class="cs hljs">docker build --pull --target testrunner -t podcast:test . docker run --rm -v D:\github\hanselminutes-core\TestResults:/app/hanselminutes.core.tests/TestResults podcast:test</code> </pre> <br>  Apenas olhe!  Estes são os resultados dos testes realizados em um contêiner Linux: <br><br><img src="https://habrastorage.org/webt/ht/tm/iw/httmiwxbkkpmk-su3oodd96snbc.png"><br><br>  Aqui está o resultado.  Agora eu tenho um site de podcast em execução no Docker no ARM32 Raspberry Pi 3 e levei apenas uma hora para trabalhar (escrevendo um arquivo do Docker)! <br><br><img src="https://habrastorage.org/webt/s8/cc/tf/s8cctfjbtp1df_s_krt5xejcaf4.png"><br><br>  <b>O segundo caminho.</b>  Você chegou a esse ponto?  Você pode simplesmente instalar o .NET Core 2.1 SDK no hardware.  O Docker não é necessário, basta baixar o tar.gz e configurá-lo.  Eu posso instalá-lo em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dispositivo como o RPI ARM32v7 Dockerfile</a> .  Observe que, ao fazer isso, eu tenho um tempo de execução comum do ASP.NET Core * e * .NET Core SDK.  Na versão final, você receberá um SDK que incluirá tudo, incluindo o ASP.NET. <br><br><pre> <code class="cs hljs">$ sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y update $ sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y install libunwind8 gettext $ wget https:<span class="hljs-comment"><span class="hljs-comment">//dotnetcli.blob.core.windows.net/dotnet/Sdk/2.1.300-rc1-008673/dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz $ wget https://dotnetcli.blob.core.windows.net/dotnet/aspnetcore/Runtime/2.1.0-rc1-final/aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz $ sudo mkdir /opt/dotnet $ sudo tar -xvf dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz -C /opt/dotnet/ $ sudo tar -xvf aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz -C /opt/dotnet/ $ sudo ln -s /opt/dotnet/dotnet /usr/local/bin $ dotnet --info</span></span></code> </pre><br>  Viva a plataforma cruzada! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416449/">https://habr.com/ru/post/pt416449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416437/index.html">Existem produtos químicos suficientes nos mundos gelados para sustentar a vida lá?</a></li>
<li><a href="../pt416439/index.html">iOS 12: agrupamento de notificações</a></li>
<li><a href="../pt416441/index.html">Rastreamento de afinação ou determinação da frequência de afinação na fala, usando Praat, YAAPT e YIN como exemplos</a></li>
<li><a href="../pt416443/index.html">9 segredos do núcleo do ASP.NET</a></li>
<li><a href="../pt416445/index.html">Webinars do Skillbox: os mais interessantes - de graça</a></li>
<li><a href="../pt416451/index.html">Bancos de dados de pesquisa da Microsoft agora disponíveis para todos</a></li>
<li><a href="../pt416453/index.html">Esquemas de roubo em sistemas RBS e cinco níveis de contra-ação para eles</a></li>
<li><a href="../pt416455/index.html">Robô "cego" Cheetah 3 pode subir uma escada cheia de obstáculos</a></li>
<li><a href="../pt416457/index.html">Bloomberg: Fundos de hedge descobrem resultados do Brexit para outros e ganham bilhões</a></li>
<li><a href="../pt416459/index.html">Tags HTML em cascata usando C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>