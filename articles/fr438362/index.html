<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üñïüèº ‚ò∫Ô∏è Comment nous avons traduit la configuration de nos services de XML en YAML üë©üèø üëæ üë¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 
 Notre entreprise, entre autres, a d√©velopp√© plusieurs services (plus pr√©cis√©ment - 12) qui fonctionnent comme le backend de nos syst√®mes. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons traduit la configuration de nos services de XML en YAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/utex/blog/438362/"><h2>  Contexte </h2><br>  Notre entreprise, entre autres, a d√©velopp√© plusieurs services (plus pr√©cis√©ment - 12) qui fonctionnent comme le backend de nos syst√®mes.  Chacun des services est un service Windows et effectue ses t√¢ches sp√©cifiques. <br><br>  Je souhaite transf√©rer tous ces services vers * nix-OS.  Pour ce faire, abandonnez l'encapsuleur sous forme de services Windows et basculez du .NET Framework vers le .NET Standard. <br><br>  La derni√®re exigence conduit √† la n√©cessit√© de se d√©barrasser de certains codes h√©rit√©s, qui ne sont pas pris en charge dans .NET Standard, y compris  du support pour la configuration de nos serveurs via XML, impl√©ment√© √† l'aide des classes de System.Configuration.  En m√™me temps, cela r√©sout le probl√®me de longue date li√© au fait que dans les configurations XML, nous avons fait des erreurs de temps en temps lors de la modification des param√®tres (par exemple, nous mettons parfois la balise de fermeture au mauvais endroit ou l'oublions du tout), mais un merveilleux lecteur de config XML System.Xml. XmlDocument avale silencieusement de telles configurations, donnant un r√©sultat compl√®tement impr√©visible. <br><br>  Il a √©t√© d√©cid√© de passer √† la configuration via la tendance YAML.  Quels probl√®mes avons-nous rencontr√©s et comment les avons-nous r√©solus? Dans cet article. <br><a name="habracut"></a><br><h2>  Qu'avons-nous </h2><br><h3>  Comment lisons-nous la configuration √† partir de XML </h3><br>  Nous lisons XML de mani√®re standard pour la plupart des autres projets. <br><br>  Chaque service poss√®de un fichier de param√®tres pour les projets .NET, appel√© AppSettings.cs, qui contient tous les param√®tres requis par le service.  Quelque chose comme √ßa: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Configuration.SettingsProvider(typeof(PortableSettingsProvider))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">IServerManagerConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { }</code> </pre> <br><br>  Une technique similaire pour s√©parer les param√®tres en interfaces facilite leur utilisation ult√©rieure via un conteneur DI. <br><br>  Toute la magie principale du stockage des param√®tres est r√©ellement cach√©e dans PortableSettingsProvider (voir l'attribut class), ainsi que dans le fichier de concepteur AppSettings.Designer.cs: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.CodeDom.Compiler.GeneratedCodeAttribute(<span class="hljs-string"><span class="hljs-string">"Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator"</span></span>, <span class="hljs-string"><span class="hljs-string">"14.0.0.0"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">global</span></span>::<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Configuration</span></span>.<span class="hljs-title"><span class="hljs-title">ApplicationSettingsBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } } [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.UserScopedSettingAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ListenPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ...</code> </pre><br>  Comme vous pouvez le voir, ¬´en arri√®re-plan¬ª sont cach√©es toutes les propri√©t√©s que nous ajoutons √† la configuration du serveur lorsque nous la modifions via le concepteur de param√®tres dans Visual Studio. <br><br>  Notre classe PortableSettingsProvider, mentionn√©e ci-dessus, lit directement le fichier XML et le r√©sultat de la lecture est d√©j√† utilis√© dans SettingsProvider pour √©crire des param√®tres dans les propri√©t√©s AppSettings. <br><br>  Un exemple de la configuration XML que nous lisons (la plupart des param√®tres sont masqu√©s pour des raisons de s√©curit√©): <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.UserSettingsGroup"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MetricServer.Properties.Settings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.ClientSettingsSection"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KickUnknownAfter"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>00:00:10<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h3>  Quels fichiers YAML j'aimerais lire </h3><br>  Quelque chose comme √ßa: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br><h3>  Probl√®mes de transition </h3><br>  <b>Premi√®rement, les</b> configurations en XML sont ¬´plates¬ª, mais en YAML elles ne le sont pas (les sections et sous-sections sont prises en charge).  Ceci est clairement visible dans les exemples ci-dessus.  En utilisant XML, nous avons r√©solu le probl√®me des param√®tres plats en introduisant nos propres analyseurs qui peuvent convertir des cha√Ænes d'un certain type dans nos classes plus complexes.  Un exemple d'une cha√Æne aussi complexe: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Je n'ai pas envie de faire de telles transformations lorsque je travaille avec YAML.  Mais en m√™me temps, nous sommes limit√©s par la structure ¬´plate¬ª existante de la classe AppSettings: toutes les propri√©t√©s des param√®tres qu'elle contient sont empil√©es en un seul tas. <br><br>  <b>Deuxi√®mement, les</b> configurations de nos serveurs ne sont pas un monolithe statique, nous les modifions de temps en temps au cours du travail du serveur, c'est-√†-dire  ces changements doivent pouvoir √™tre d√©tect√©s √† la vol√©e, lors de l'ex√©cution.  Pour ce faire, dans l'impl√©mentation XML, nous h√©ritons de nos AppSettings d'INotifyPropertyChanged (en fait, chaque interface qui impl√©mente AppSettings en est h√©rit√©e) et souscrivons √† la mise √† jour des √©v√©nements de propri√©t√©s des param√®tres.  Cette approche fonctionne car la classe de base System.Configuration.ApplicationSettingsBase pr√™te √† l'emploi impl√©mente INotifyPropertyChanged.  Un comportement similaire doit √™tre conserv√© apr√®s la transition vers YAML. <br><br>  <b>Troisi√®mement,</b> nous n'avons pas r√©ellement un fichier de configuration pour chaque serveur, mais deux autant: un avec les param√®tres par d√©faut, l'autre avec les param√®tres remplac√©s.  Cela est n√©cessaire pour que, dans chacune des instances de serveurs du m√™me type, √©coutant des ports diff√©rents et ayant des param√®tres l√©g√®rement diff√©rents, vous n'ayez pas √† copier compl√®tement l'ensemble des param√®tres. <br><br>  <b>Et un autre probl√®me</b> - l'acc√®s aux param√®tres passe non seulement par des interfaces, mais √©galement par un acc√®s direct √† AppSettings.Default.  Permettez-moi de vous rappeler comment il est d√©clar√© dans les coulisses AppSettings.Designer.cs: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } }</code> </pre><br>  Sur la base de ce qui pr√©c√®de, il √©tait n√©cessaire de trouver une nouvelle approche pour stocker les param√®tres dans AppSettings. <br><br><h2>  Solution </h2><br><h3>  Bo√Æte √† outils </h3><br>  Pour la lecture directe, YAML a d√©cid√© d'utiliser des biblioth√®ques pr√™tes √† l'emploi disponibles via NuGet: <br><br><ul><li>  YamlDotNet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/aaubry/YamlDotNet</a> .  D'apr√®s la description de la biblioth√®que (traduction): <br><blockquote>  YamlDotNet est la biblioth√®que .NET pour YAML.  YamlDotNet fournit un analyseur de bas niveau et un g√©n√©rateur YAML, ainsi qu'un mod√®le d'objet de haut niveau similaire √† XmlDocument.  Une biblioth√®que de s√©rialisation vous permet √©galement de lire et d'√©crire des objets depuis / vers des flux YAML. </blockquote><br></li><li>  NetEscapades.Configuration - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/andrewlock/NetEscapades.Configuration</a> .  Il s'agit du fournisseur de configuration lui-m√™me (au sens de Microsoft.Extensions.Configuration.IConfigurationSource, activement utilis√© dans les applications ASP.NET Core), qui lit les fichiers YAML en utilisant uniquement celui mentionn√© ci-dessus YamlDotNet. <br></li></ul><br>  En savoir plus sur l'utilisation de ces biblioth√®ques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Transition vers YAML </h3><br>  La transition elle-m√™me a √©t√© effectu√©e en deux √©tapes: au d√©but, nous sommes simplement pass√©s de XML √† YAML, mais en conservant une hi√©rarchie plate de fichiers de configuration, puis nous avons entr√© des sections dans des fichiers YAML.  Ces √©tapes pourraient, en principe, √™tre combin√©es en une seule, et pour des raisons de simplicit√© de pr√©sentation, je le ferai.  Toutes les actions d√©crites ci-dessous ont √©t√© appliqu√©es s√©quentiellement √† chaque service. <br><br><h3>  Pr√©paration d'un fichier YML </h3><br>  Vous devez d'abord pr√©parer le fichier YAML lui-m√™me.  Nous l'appelons le nom du projet (utile pour les futurs tests d'int√©gration, qui devraient pouvoir travailler avec diff√©rents serveurs et distinguer leurs configurations entre eux), mettre le fichier directement √† la racine du projet, √† c√¥t√© d'AppSettings: <br><br><img src="https://habrastorage.org/webt/es/2h/jo/es2hjofltziwk8fbqj3f5faxte0.png"><br><br>  Dans le fichier YML, pour commencer, enregistrons une structure ¬´plate¬ª: <br><br><pre> <code class="plaintext hljs">VirtualFeed: "MaxChartHistoryLength: 10, UseThrottling: True, ThrottlingIntervalMs: 50000, UseHistoryBroadcast: True, CalendarName: EmptyCalendar" VirtualFeedPort: 35016 UsMarketFeedUseImbalances: True</code> </pre><br><h3>  Remplir AppSettings avec les propri√©t√©s des param√®tres </h3><br>  Nous transf√©rons toutes les propri√©t√©s d'AppSettings.Designer.cs √† AppSettings.cs, en nous d√©barrassant simultan√©ment des attributs superflus du concepteur et du code lui-m√™me dans get / set-parts. <br><br>  C'√©tait: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Configuration.UserScopedSettingAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br>  C'est devenu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Nous supprimerons compl√®tement AppSettings <b>.Designer</b> .cs comme inutile.  Maintenant, en passant, vous pouvez compl√®tement vous d√©barrasser de la section userSettings du fichier app.config, si elle se trouve dans le projet - les m√™mes param√®tres par d√©faut y sont stock√©s, que nous sp√©cifions via le concepteur de param√®tres. <br>  Allez-y. <br><br><h3>  Contr√¥lez les param√®tres √† la vol√©e </h3><br>  √âtant donn√© que nous devons √™tre en mesure de d√©tecter les mises √† jour de nos param√®tres lors de l'ex√©cution, nous devons impl√©menter INotifyPropertyChanged dans nos AppSettings.  La base System.Configuration.ApplicationSettingsBase de base n'est plus l√†, respectivement, vous ne pouvez pas compter sur la magie. <br><br>  Vous pouvez l'impl√©menter ¬´sur le front¬ª: en ajoutant une impl√©mentation d'une m√©thode qui lance l'√©v√©nement souhait√© et en l'appelant dans le setter de chaque propri√©t√©.  Mais ce sont des lignes de code suppl√©mentaires, qui devront en outre √™tre copi√©es sur tous les services. <br><br>  Faisons plus beau - introduisez la classe de base auxiliaire AutoNotifier, qui fait en fait la m√™me chose, mais en arri√®re-plan, tout comme System.Configuration.ApplicationSettingsBase l'a fait auparavant: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Implements </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="INotifyPropertyChanged"/&gt;</span></span></span><span class="hljs-comment"> for classes with a lot of public properties (ie AppSettings). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> This implementation is: </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - fairly slow, so don't use it for classes where getting/setting of properties is often operation; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - not for properties described in inherited classes of 2nd level (bad idea: Inherit2 -&gt; Inherit1 -&gt; AutoNotifier; good idea: sealed Inherit -&gt; AutoNotifier) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class AutoNotifier : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment"> _wrappedValues = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment">(); //just to avoid manual writing a lot of fields protected T Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">([CallerMemberName] string propertyName = null) { return (T)_wrappedValues.GetValueOrDefault(propertyName, () =&gt; default(T)); } protected void Set</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(T value, [CallerMemberName] string propertyName = null) { // ReSharper disable once AssignNullToNotNullAttribute _wrappedValues.AddOrUpdate(propertyName, value, (s, o) =&gt; value); OnPropertyChanged(propertyName); } public object this[string propertyName] { get { return Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;object&gt;</span></span></span><span class="hljs-comment">(propertyName); } set { Set(value, propertyName); } } protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }</span></span></code> </pre><br>  Ici, l'attribut [CallerMemberName] vous permet d'obtenir automatiquement le nom de propri√©t√© de l'objet appelant, c'est-√†-dire  AppSettings <br><br>  Maintenant, nous pouvons h√©riter nos AppSettings de cette classe de base AutoNotifier, puis chaque propri√©t√© est l√©g√®rement modifi√©e: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Set(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre><br>  Avec cette approche, nos classes AppSettings, contenant m√™me pas mal de param√®tres, ont l'air compactes et impl√©mentent en m√™me temps compl√®tement INotifyPropertyChanged. <br><br>  Oui, je sais qu'il serait possible d'introduire un peu plus de magie, en utilisant, par exemple, Castle.DynamicProxy.IInterceptor, en interceptant les modifications des propri√©t√©s n√©cessaires et en y provoquant des √©v√©nements.  Mais une telle d√©cision me semblait trop surcharg√©e. <br><br><h3>  Lecture des param√®tres d'un fichier YAML </h3><br>  L'√©tape suivante consiste √† ajouter le lecteur de la configuration YAML elle-m√™me.  Cela se produit quelque part plus pr√®s du d√©but du service.  En cachant des d√©tails inutiles qui ne sont pas li√©s au sujet en discussion, nous obtenons quelque chose de similaire: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServerConfigurationProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadServerConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyDictionary&lt;Type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; allSections</span></span></span><span class="hljs-function">)</span></span> { IConfigurationBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder().SetBasePath(ConfigFiles.BasePath); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> configFile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> configFiles) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> directory = Path.GetDirectoryName(configFile); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(directory)) <span class="hljs-comment"><span class="hljs-comment">//can be empty if relative path is used { Directory.CreateDirectory(directory); } builder = builder.AddYamlFile(configFile, optional: true, reloadOnChange: true); } IConfigurationRoot config = builder.Build(); // load prepared files and merge them return new ServerConfigurationProvider&lt;TAppSettings&gt;(config, allSections); }</span></span></code> </pre><br>  Dans le code pr√©sent√©, ConfigurationBuilder n'est probablement pas d'un int√©r√™t particulier - tout le travail avec celui-ci est similaire √† l'utilisation des configurations dans ASP.NET Core.  Mais les points suivants sont int√©ressants.  Tout d'abord, ¬´pr√™t √† l'emploi¬ª, nous avons √©galement eu la possibilit√© de combiner les param√®tres de plusieurs fichiers.  Cela fournit l'exigence d'avoir au moins deux fichiers de configuration par serveur, comme je l'ai mentionn√© ci-dessus.  Deuxi√®mement, nous passons toute la configuration de lecture √† un certain ServerConfigurationProvider.  Pourquoi? <br><br><h3>  Sections du fichier YAML </h3><br>  Nous r√©pondrons √† cette question plus tard, et revenons maintenant √† l'exigence de stocker les param√®tres structur√©s hi√©rarchiquement dans un fichier YML. <br><br>  En principe, sa mise en ≈ìuvre est assez simple.  Tout d'abord, dans le fichier YML, nous introduisons la structure dont nous avons besoin: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br>  Passons maintenant √† AppSettings et apprenons-lui √† diviser nos propri√©t√©s en sections.  Quelque chose comme √ßa: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">AutoNotifier</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerManagerAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGlobalCredentialsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IHeartBeatConfig</span></span>, <span class="hljs-title"><span class="hljs-title">IConcurrentAcceptorProperties</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IReadOnlyDictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Sections { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDatabaseConfigStorage), <span class="hljs-string"><span class="hljs-string">"Database"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IWebSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Web"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Server"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IConcurrentAcceptorProperties), <span class="hljs-string"><span class="hljs-string">"ConcurrentAcceptor"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGraphiteAddressStorage), <span class="hljs-string"><span class="hljs-string">"Graphite"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IKeyCloackConfigFilePathProvider), <span class="hljs-string"><span class="hljs-string">"Keycloak"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPrometheusSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Prometheus"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IHeartBeatConfig), <span class="hljs-string"><span class="hljs-string">"Heartbeat"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerManagerAddressStorage), <span class="hljs-string"><span class="hljs-string">"ServerManager"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGlobalCredentialsStorage), <span class="hljs-string"><span class="hljs-string">"GlobalCredentials"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IBlackListStorage), <span class="hljs-string"><span class="hljs-string">"Blacklist"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IMetricsConfig), <span class="hljs-string"><span class="hljs-string">"Metrics"</span></span>} }; ...</code> </pre><br>  Comme vous pouvez le voir, nous avons ajout√© un dictionnaire directement √† AppSettings, o√π les cl√©s sont les types d'interfaces que la classe AppSettings impl√©mente, et les valeurs sont les en-t√™tes des sections correspondantes.  Maintenant, nous pouvons comparer la hi√©rarchie dans le fichier YML avec la hi√©rarchie des propri√©t√©s dans AppSettings (bien que pas plus profond qu'un niveau d'imbrication, mais dans notre cas, cela suffisait). <br><br>  Pourquoi faisons-nous cela ici - dans AppSettings?  Parce que de cette fa√ßon, nous ne diffusons pas les informations sur les param√®tres des diff√©rentes entit√©s, et en plus, c'est l'endroit le plus naturel, car  dans chaque service et, par cons√©quent, dans chaque AppSettings, sa propre section de param√®tres. <br><br><h3>  Si vous n'avez pas besoin d'une hi√©rarchie dans les param√®tres? </h3><br>  En principe, c'est un cas √©trange, mais nous l'avons eu exactement au premier stade, lorsque nous sommes simplement pass√©s de XML √† YAML, sans utiliser les avantages de YAML. <br><br>  Dans ce cas, cette liste enti√®re de sections ne peut pas √™tre stock√©e et ServerConfigurationProvider sera beaucoup plus simple (discut√© plus loin). <br><br>  Mais le point important est que si nous d√©cidons de laisser une hi√©rarchie plate, nous pouvons simplement remplir l'exigence de maintenir la capacit√© d'acc√©der aux param√®tres via AppSettings.Default.  Pour ce faire, ajoutez ici un constructeur public aussi simple dans AppSettings: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Default = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Maintenant, nous pouvons continuer √† acc√©der √† la classe de param√®tres partout via AppSettings.Default (√† condition que les param√®tres aient d√©j√† √©t√© lus via IConfigurationRoot dans ServerConfigurationProvider et, en cons√©quence, AppSettings a √©t√© instanci√©). <br><br>  Si une hi√©rarchie plate est inacceptable, alors, de toute fa√ßon, vous devez vous d√©barrasser d'AppSettings.Default partout par code et travailler avec des param√®tres uniquement via des interfaces (ce qui est bon en principe).  Pourquoi - cela deviendra clair plus loin. <br><br><h3>  ServerConfigurationProvider </h3><br>  La classe sp√©ciale ServerConfigurationProvider mentionn√©e pr√©c√©demment traite de la magie m√™me qui vous permet de travailler pleinement avec la nouvelle configuration hi√©rarchique YAML avec uniquement un AppSettings plat. <br><br>  Si vous ne pouvez pas attendre, le voici. <br><br><div class="spoiler">  <b class="spoiler_title">Code serveur complet de configuration du serveur</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class ServerConfigurationProvider</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment"> : IServerConfigurationProvider where TAppSettings : new() { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); private readonly IConfigurationRoot _configuration; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> _sectionsByInterface; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment"> _interfacesBySections; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Section name -&gt; config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment"> _cachedSections; public ServerConfigurationProvider(IConfigurationRoot configuration, IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> allSections) { _configuration = configuration; _cachedSections = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment">(); _sectionsByInterface = allSections; var interfacesBySections = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment">(); foreach (KeyValuePair</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> interfaceAndSection in _sectionsByInterface) { //section names must be unique interfacesBySections.Add(interfaceAndSection.Value, interfaceAndSection.Key); } _interfacesBySections = interfacesBySections; _configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, null); } private void OnConfigurationFileChanged(object _) { UpdateCache(); } private void UpdateCache() { foreach (string sectionName in _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; if (_cachedSections.TryGetValue(sectionName, out oldSection)) { UpdateSection(oldSection, newSection); } } } private void UpdateSection(TAppSettings oldConfig, TAppSettings newConfig) { foreach (PropertyInfo propertyInfo in typeof(TAppSettings).GetProperties().Where(p =&gt; p.GetMethod != null &amp;&amp; p.SetMethod != null)) { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } } public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections =&gt; _sectionsByInterface.Keys; public TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class { return (TSettingsSectionInterface)FindSection(typeof(TSettingsSectionInterface)); } [CanBeNull] public object FindSection(Type sectionInterface) { string sectionName = FindSectionName(sectionInterface); if (sectionName == null) { return null; } //we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); } private string FindSectionName(Type sectionInterface) { string sectionName; if (!_sectionsByInterface.TryGetValue(sectionInterface, out sectionName)) { Logger.Debug("This server doesn't contain settings for {0}", sectionInterface.FullName); return null; } return sectionName; } private TAppSettings ReadSection(string sectionName, Type sectionInterface) { TAppSettings parsed; try { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment">(); if (parsed == null) { //means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } } private void CheckSection(IConfigurationSection section, string sectionName, Type sectionInterface) { ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> properties = GetPublicProperties(sectionInterface, needSetters: false); var configProperties = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">(section.GetChildren().Select(c =&gt; c.Key)); foreach (PropertyInfo propertyInfo in properties) { if (!configProperties.Remove(propertyInfo.Name)) { if (propertyInfo.PropertyType != typeof(string) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { //no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } } private static ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> GetPublicProperties(Type type, bool needSetters) { if (!type.IsInterface) { return type.GetProperties().Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null)).ToArray(); } var propertyInfos = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment">(); var considered = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); var queue = new Queue</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); considered.Add(type); queue.Enqueue(type); while (queue.Count &gt; 0) { Type subType = queue.Dequeue(); foreach (Type subInterface in subType.GetInterfaces()) { if (considered.Contains(subInterface)) { continue; } considered.Add(subInterface); queue.Enqueue(subInterface); } PropertyInfo[] typeProperties = subType.GetProperties(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.Instance); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> newPropertyInfos = typeProperties.Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null) &amp;&amp; !propertyInfos.Contains(x)); propertyInfos.InsertRange(0, newPropertyInfos); } return propertyInfos; } }</span></span></code> </pre><br></div></div><br>  ServerConfigurationProvider est param√©tr√© par la classe de param√®tres AppSettings: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProvider</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TAppSettings</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IServerConfigurationProvider</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TAppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">new</span></span>()</code> </pre><br>  Comme vous pouvez le deviner, cela vous permet de l'utiliser imm√©diatement dans tous les services. <br><br>  La configuration de lecture elle-m√™me (IConfigurationRoot), ainsi que le dictionnaire de sections mentionn√© ci-dessus (AppSettings.Sections) sont pass√©s au constructeur.  Il y a un abonnement aux mises √† jour de fichiers (voulons-nous nous retirer imm√©diatement ces modifications en cas de modification du fichier YML?): <br><br><pre> <code class="cs hljs">_configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConfigurationFileChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cachedSections.TryGetValue(sectionName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> oldSection)) { UpdateSection(oldSection, newSection); } } }</code> </pre><br>  Comme vous pouvez le voir, ici, en cas de mise √† jour du fichier YML, nous parcourons toutes les sections que nous connaissons et lisons chacune.  Ensuite, si la section a d√©j√† √©t√© lue plus t√¥t dans le cache (c'est-√†-dire qu'elle a d√©j√† √©t√© demand√©e quelque part dans le code par une classe), alors nous r√©√©crivons les anciennes valeurs dans le cache avec de nouvelles. <br><br>  Il semblerait - pourquoi lire chaque section, pourquoi ne pas lire uniquement celles qui sont dans le cache (c'est-√†-dire demand√©es)?  Parce qu'en lisant la section, nous avons impl√©ment√© une v√©rification de la configuration correcte.  Et en cas de param√®tres incorrects, les alertes correspondantes sont lanc√©es, les probl√®mes sont enregistr√©s.  Il est pr√©f√©rable de se renseigner d√®s que possible sur les probl√®mes de modifications de configuration, √† partir desquels nous lisons imm√©diatement toutes les sections. <br><br>  La mise √† jour des anciennes valeurs dans le cache avec de nouvelles valeurs est assez triviale: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings oldConfig, TAppSettings newConfig</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">PropertyInfo propertyInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Where</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p =&gt; p.GetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; p.SetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">))</span></span> { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } }</code> </pre><br>  Mais la lecture des sections n'est pas si simple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TAppSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { TAppSettings parsed; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get&lt;TAppSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsed == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; }</span></span></code> </pre><br>  Ici, nous lisons tout d'abord la section elle-m√™me en utilisant le standard IConfigurationRoot.GetSection.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rifiez ensuite l'exactitude de la section de lecture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous lisons la section bindim pour le type de nos param√®tres: section.Get Ici, nous rencontrons une fonctionnalit√© de l'analyseur YAML - il ne fait pas de distinction entre une section vide (sans param√®tres, c'est-√†-dire absente) d'une section dans laquelle tous les param√®tres sont vides. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un cas similaire:</font></font><br><br><pre> <code class="plaintext hljs">VirtualFeed: Names: []</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, dans la section VirtualFeed, il y a un param√®tre Noms avec une liste de valeurs vide, mais l'analyseur YAML, malheureusement, dira que la section VirtualFeed est g√©n√©ralement compl√®tement vide. </font></font> C'est triste. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, dans cette m√©thode, un peu de magie de rue est impl√©ment√©e pour prendre en charge les propri√©t√©s IEnumerable dans les param√®tres. </font><font style="vertical-align: inherit;">Nous n'avons pas r√©ussi √† obtenir une lecture normale des listes ¬´pr√™tes √† l'emploi¬ª.</font></font><br><br><pre> <code class="cs hljs">ReadArrays(parsed, section); ... <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, nous trouvons toutes les propri√©t√©s dont le type est h√©rit√© de IEnumerable et leur attribuons des valeurs √† partir de la "section" fictive, √©galement nomm√©e comme param√®tre qui nous int√©resse. Mais avant cela, n'oubliez pas de v√©rifier: existe-t-il une valeur red√©finie de cette propri√©t√© √©num√©r√©e dans le deuxi√®me fichier de configuration? Si tel est le cas, nous le prenons uniquement et nous effa√ßons les param√®tres lus dans le fichier de configuration de base. Si cela n'est pas fait, les deux propri√©t√©s (du fichier de base et du fichier remplac√©) seront automatiquement fusionn√©es en un seul tableau au niveau de IConfigurationSection, et les indices du tableau serviront de cl√©s pour la combinaison. Cela entra√Ænera une sorte de hachage au lieu de la valeur remplac√©e normale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode ReadSection pr√©sent√©e est finalement utilis√©e dans la m√©thode principale de la classe: FindSection.</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CanBeNull</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName = FindSectionName(sectionInterface); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sectionName == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principe, il devient clair pourquoi, avec le soutien des sections, nous ne pouvons pas prendre en charge AppSettings.Default de quelque mani√®re que ce soit: chaque acc√®s √† une nouvelle section de param√®tres (pr√©c√©demment non lue) via FindSection nous donnera en fait une nouvelle instance de la classe AppSettings, bien qu'elle soit attach√©e √† l'interface souhait√©e et, par cons√©quent, si nous utilisions AppSettings.Default, il serait red√©fini chaque fois qu'une nouvelle section √©tait lue et ne contiendrait que les param√®tres qui appartiennent √† la derni√®re section lue (le reste aurait des valeurs par d√©faut - NULL et 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La validation des param√®tres dans la section est impl√©ment√©e comme suit:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IConfigurationSection section, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { ICollection&lt;PropertyInfo&gt; properties = GetPublicProperties(sectionInterface, needSetters: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(section.GetChildren().Select(c =&gt; c.Key)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (PropertyInfo propertyInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> properties) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!configProperties.Remove(propertyInfo.Name)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyInfo.PropertyType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { <span class="hljs-comment"><span class="hljs-comment">//no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, tout d'abord, toutes les propri√©t√©s publiques de l'interface qui nous int√©ressent sont extraites (lecture - sections param√®tres). Et pour chacune de ces propri√©t√©s, une correspondance est trouv√©e dans les param√®tres de lecture: si aucune correspondance n'est trouv√©e, le probl√®me correspondant est enregistr√©, car cela signifie qu'une configuration est manquante dans le fichier de configuration. √Ä la fin, il est en outre v√©rifi√© si l'un des param√®tres de lecture est rest√© sans correspondance avec l'interface. S'il y en a, le probl√®me est √† nouveau enregistr√©, car cela signifie que les propri√©t√©s qui ne sont pas d√©crites dans l'interface ont √©t√© trouv√©es dans le fichier de configuration, qui ne devraient pas non plus se trouver dans une situation normale.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La question se pose - d'o√π vient l'exigence que, dans le fichier lu, tous les param√®tres doivent correspondre √† ceux disponibles dans l'interface sur une base individuelle? Le fait est qu'en fait, comme mentionn√© ci-dessus, √† ce moment-l√†, aucun fichier n'a √©t√© lu, mais deux √† la fois - l'un avec les param√®tres par d√©faut et l'autre avec les param√®tres remplac√©s, et les deux sont contigus. En cons√©quence, en fait, nous ne regardons pas les param√®tres d'un fichier, mais ceux complets. Et dans ce cas, bien s√ªr, leur ensemble doit correspondre aux param√®tres attendus un √† un.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites √©galement attention dans les sources ci-dessus √† la m√©thode GetPublicProperties, qui, semble-t-il, ne renvoie que toutes les propri√©t√©s publiques de l'interface. </font><font style="vertical-align: inherit;">Mais ce n'est pas aussi simple que cela pourrait l'√™tre, car parfois nous avons une interface qui d√©crit les param√®tres du serveur h√©rit√© d'une autre interface, et, en cons√©quence, il est n√©cessaire de regarder toute la hi√©rarchie des interfaces afin de trouver toutes les propri√©t√©s publiques.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtention des param√®tres du serveur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sur la base de ce qui pr√©c√®de, pour obtenir les param√®tres du serveur partout par code, nous nous tournons vers l'interface suivante: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IServerConfigurationProvider { TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class; object FindSection(Type sectionInterface); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections { get; } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La premi√®re m√©thode de cette interface - FindSection - vous permet d'acc√©der √† la section des param√®tres qui vous int√©resse. </font></font> Quelque chose comme √ßa: <br><br><pre> <code class="cs hljs">IThreadPoolProperties threadPoolProperties = ConfigurationProvider.FindSection&lt;IThreadPoolProperties&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourquoi les deuxi√®me et troisi√®me m√©thodes sont n√©cessaires - je vais expliquer plus en d√©tail. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrement des interfaces de param√©trage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre projet, Castle Windsor est utilis√© comme conteneur IoC. C'est lui qui fournit, y compris les interfaces des param√®tres du serveur. En cons√©quence, ces interfaces doivent y √™tre enregistr√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce but, une simple classe Extension a √©t√© √©crite qui simplifie cette proc√©dure afin de ne pas √©crire l'enregistrement de l'ensemble des interfaces dans chaque serveur:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProviderExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAllConfigurationSections</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider</span></span></span><span class="hljs-function">)</span></span> { Register(container, configurationProvider, configurationProvider.AllSections.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type[] configSections</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registrations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IRegistration[configSections.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; registrations.Length; i++) { Type configSection = configSections[i]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> section = configurationProvider.FindSection(configSection); registrations[i] = Component.For(configSection).Instance(section).Named(configSection.FullName); } container.Register(registrations); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re m√©thode vous permet d'enregistrer toutes les sections de param√®tres (pour cela, vous avez besoin de la propri√©t√© AllSections dans l'interface IServerConfigurationProvider). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et la deuxi√®me m√©thode est utilis√©e dans la premi√®re, et elle lit automatiquement la section des param√®tres sp√©cifi√©s √† l'aide de notre ServerConfigurationProvider, l'√©crivant ainsi imm√©diatement dans le cache ServerConfigurationProvider et l'enregistrant √† Windsor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est ici que la deuxi√®me m√©thode FindSection, non param√©tr√©e, de IServerConfigurationProvider est utilis√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne reste plus qu'√† appeler notre m√©thode d'extension dans le code d'enregistrement des conteneurs de Windsor:</font></font><br><br><pre> <code class="cs hljs">container.RegisterAllConfigurationSections(configProvider);</code> </pre><br><h2>  Conclusion </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-il arriv√©? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la mani√®re pr√©sent√©e, il a √©t√© possible de transf√©rer assez facilement tous les param√®tres de nos serveurs de XML vers YAML, tout en apportant un minimum de modifications au code de serveur existant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrairement aux XML, les configurations YAML se sont av√©r√©es plus lisibles en raison non seulement d'une plus grande concision, mais √©galement de la prise en charge du partitionnement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas invent√© nos propres v√©los pour analyser YAML, mais avons utilis√© des solutions toutes faites. Cependant, pour les int√©grer dans les r√©alit√©s de notre projet, certaines des astuces d√©crites dans cet article √©taient n√©cessaires. J'esp√®re qu'ils seront utiles aux lecteurs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il a √©t√© possible de conserver la possibilit√© de d√©tecter les changements de param√®tres dans les museaux Web de nos serveurs √† la vol√©e. </font><font style="vertical-align: inherit;">De plus, le bonus a √©galement permis de capturer les changements dans le fichier YAML lui-m√™me √† la vol√©e (auparavant, il √©tait n√©cessaire de red√©marrer le serveur pour tout changement dans les fichiers de configuration). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons conserv√© la possibilit√© de fusionner deux fichiers de configuration - les param√®tres par d√©faut et remplac√©s, et nous l'avons fait en utilisant des solutions tierces pr√™tes √† l'emploi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce qui n'a pas tr√®s bien fonctionn√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai d√ª abandonner la possibilit√© pr√©c√©demment disponible d'enregistrer les modifications appliqu√©es √† partir des faces Web de nos serveurs dans les fichiers de configuration, car </font><font style="vertical-align: inherit;">la prise en charge d'une telle fonctionnalit√© n√©cessiterait de grands gestes, et la t√¢che commerciale qui nous attendait en g√©n√©ral n'√©tait pas telle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, j'ai √©galement d√ª refuser l'acc√®s aux param√®tres via AppSettings.Default, mais c'est plus un avantage qu'un inconv√©nient.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438362/">https://habr.com/ru/post/fr438362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438350/index.html">Guide complet de recherche professionnelle de cam√©ras cach√©es et d'appareils espions</a></li>
<li><a href="../fr438352/index.html">Vid√©o de la descente du rover "Yutu-2", ses premiers m√®tres √† la surface de la lune. Le sommeil de deux semaines sur la lune est termin√©</a></li>
<li><a href="../fr438354/index.html">Vue, Storybook, TypeScript - d√©marrer un nouveau projet avec les meilleures pratiques √† l'esprit</a></li>
<li><a href="../fr438356/index.html">Architecture certifi√©e Fast Track (DWFT) de SQL Server Data Warehouse: ce que cela signifie et comment cela fonctionne</a></li>
<li><a href="../fr438358/index.html">D'anciens agents de la NSA espionnant les iPhones des victimes command√©s par les √âmirats arabes unis</a></li>
<li><a href="../fr438364/index.html">R√©plication du premier brouilleur vocal num√©rique au monde</a></li>
<li><a href="../fr438366/index.html">Encore un autre examen de la fonctionnalit√© des jetons mat√©riels OATH dans Azure Cloud MFA</a></li>
<li><a href="../fr438368/index.html">Les ampoules intelligentes jet√©es √† la poubelle sont une pr√©cieuse source d'informations personnelles.</a></li>
<li><a href="../fr438370/index.html">La cybercriminalit√© en tant que service: services et tarifs</a></li>
<li><a href="../fr438372/index.html">La NASA poursuit ses tentatives pour contacter l'opportunit√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>