<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗨️ ♑️ 💆🏽 "Bonjour, Checkmarx!" Comment écrire une demande pour Checkmarx SAST et trouver des vulnérabilités intéressantes 🖖🏼 🐚 🙎🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Dans l'article, je veux parler de notre expérience dans la création de mes requêtes dans Checkmarx SAST. 

 Lorsque vous vous famili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Bonjour, Checkmarx!" Comment écrire une demande pour Checkmarx SAST et trouver des vulnérabilités intéressantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Bonjour, Habr! <br><br>  Dans l'article, je veux parler de notre expérience dans la création de mes requêtes dans Checkmarx SAST. <br><br>  Lorsque vous vous familiarisez avec cet analyseur pour la première fois, vous pouvez avoir l'impression qu'en plus de rechercher des algorithmes de chiffrement / hachage faibles et un tas de faux positifs, il ne renvoie rien d'autre.  Mais lorsqu'il est correctement configuré, c'est un outil super puissant qui peut rechercher des bugs graves. <br><br>  Nous allons comprendre les subtilités du langage de requête Checkmarx SAST et écrire 2 requêtes pour rechercher des injections SQL et des références d'objet direct non sécurisées. <br><a name="habracut"></a><br><br><h2>  Entrée </h2><br>  Après une longue recherche de guides ou d'articles sur Checkmarx, il est devenu clair pour moi qu'en dehors de la documentation officielle, il n'y avait pas assez d'informations utiles.  Et la documentation officielle ne dit pas que tout devient très clair et compréhensible.  Par exemple, je n'ai trouvé aucune meilleure pratique, comment organiser correctement les requêtes de remplacement, comment écrire une requête «pour les nuls», etc. Oui, il existe une documentation sur les fonctions du langage de requête CMx, mais voici comment combiner ces fonctions en une seule requête, la documentation n'est pas écrite. <br><br>  Peut-être que le manque d'articles et de guides de la communauté Checkmarx est associé au coût élevé de l'outil et, par conséquent, à un public restreint.  Ou peut-être que peu de gens s'embarrassent du réglage fin et utilisent la solution telle quelle, prête à l'emploi. <br><br>  D'après mon expérience, je constate davantage que SAST est davantage utilisé pour se conformer aux formalités liées aux diverses exigences des clients que pour rechercher de vrais bugs.  Avec cette approche, nous avons donc, au mieux, un nombre relativement faible de «vulnérabilités» que l'on appelle presque automatiquement «non exploitables» (car elles sont dans 99,9% des cas). <br><br>  Il convient de noter que Checkmarx essaie lui-même de mettre à jour ses requêtes afin de donner le meilleur résultat prêt à l'emploi.  Mais les requêtes CMx Query Language sont adaptées au «cas général».  La recherche initiale de jetons est basée sur le nom.  Par exemple, CMx SAST suppose que toutes les requêtes vers la base de données ressembleront à ceci: * createQuery * ou * createSQLQuery *.  Mais si le développement interne est utilisé pour travailler avec la base de données et que la méthode d'interrogation de la base de données est appelée différemment, par exemple * driveMyQuery *, toutes les méthodes SQL seront ignorées.  Par exemple, notre client utilise ORM personnalisé pour SQL DB.  Dans ce cas, les requêtes CMx prêtes à l'emploi ont ignoré toutes les injections SQL. <br><br><h4>  Abréviations et définitions </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - <b>Langage de</b> requête Checkmarx SAST <br>  <b>Token</b> - une chaîne avec une certaine valeur est le résultat du travail de l'analyseur lexical (qui est aussi appelé tokenisation) <br><br><h3>  Application de test </h3><br>  Pour écrire un article, j'ai esquissé du code Java, une petite application de test.  Ce code est une copie approximative d'une petite partie du système réel.  Bien qu'en général le code de l'application de test ne soit pas très différent de tout autre code backend HTTP.  Les sections clés du code de l'application de test seront visibles sur les captures d'écran. <br><br><h4>  L'application de test a la structure suivante </h4><br>  Classe <i>WebRouter</i> pour le traitement des requêtes HTTP entrantes; 4 méthodes de traitement des URL à l'intérieur: <br><ul><li>  <i>/ getTransaction</i> - accepte l' <i>ID de</i> transaction à l'entrée <i>et renvoie les informations</i> dessus, <i>id le</i> prend comme chaîne et le transmet à <i>getTransactionInfo (transactionId)</i> =&gt; <i>getTransactionInfo (transactoinId)</i> - fait que transactionId concatène à la requête SQL (c'est-à-dire que l'injection SQL est obtenue); </li><li>  <i>/ getSecureTransaction</i> - accepte l' <i>ID de</i> transaction en entrée <i>et renvoie les informations</i> dessus, <i>id le</i> prend comme chaîne et le transmet <i>getTransactionInfoSecured ()</i> =&gt; <i>getTransactionInfoSecured (transactoinId)</i> - <i>convertit d'</i> abord <i>la</i> chaîne <i>transactionId</i> en type Long, puis la concatène à la requête SQL (dans ce cas où l'injection n'est pas exploitée); </li><li>  <i>/ getSettings</i> - accepte <i>userId</i> et <i>mailboxId comme entrée</i> - et émet les paramètres de boîte aux lettres.  Ne vérifie pas que l' <i>ID de boîte</i> aux <i>lettres</i> appartient à l'utilisateur; </li><li>  <i>/ getSecureSettings</i> - accepte également <i>userId</i> et <i>mailboxId à l'entrée</i> et affiche les paramètres de boîte aux lettres.  MAIS vérifie que l' <i>ID de boîte</i> aux <i>lettres</i> appartient à l'utilisateur. </li></ul><br><br><h2>  CMx: informations générales et définitions de base </h2><br><h3>  Avant de commencer à développer des requêtes </h3><br>  Le développement des requêtes est effectué dans un programme distinct CxAuditor.  Dans CxAuditor, vous devez analyser tout le code (créer un projet local), pour lequel nous écrirons des requêtes.  Après cela, vous pouvez écrire et exécuter de nouvelles requêtes.  Avec une grande base de code, l'analyse principale peut prendre des heures et des gigaoctets de mémoire.  Après cela, chaque demande ne sera pas exécutée assez rapidement.  Ceci est totalement inadapté au développement. <br><br>  Par conséquent, vous pouvez prendre un petit ensemble de fichiers du projet, idéalement avec un bogue trouvé dans le code avant le type sous lequel nous écrivons une demande (ou y mettre le bogue avec vos mains) et analyser uniquement cet ensemble de fichiers.  Il n'est pas nécessaire de respecter la structure de fichiers du projet.  Autrement dit, si vous avez le package Java A et B, et que les classes du package B utilisent les classes et les méthodes du package A, vous pouvez mettre tout cela dans un seul répertoire, et CMx comprendra toujours les relations et construira correctement les chaînes d'appels entre les fichiers (enfin, ou presque toujours correct, bien que les erreurs soient à peine liées à la structure des fichiers du projet). <br><br><h3>  Définitions de base </h3><br><h4>  Cxlist </h4><br>  Le type de données principal dans CMx.  Le résultat de presque toutes les fonctions CMxQL sera <i>CxList</i> .  C'est beaucoup d'éléments avec certaines propriétés.  Les propriétés les plus utiles pour le développement seront examinées ci-dessous. <br><br><h4>  résultat </h4><br>  CMxQL a un <i>résultat</i> variable intégré.  L'ensemble qui contient la variable de <i>résultat</i> , après l'exécution de la requête entière, sera affiché comme résultat. <br><br>  Autrement dit, l'opération finale de toute requête doit être la chaîne <i>result = WHATEVER</i> , par exemple: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  élément de flux et de code </h4><br>  La plupart des fonctions CMxQL par type de valeurs retournées sont divisées en 2, celles qui renvoient des "éléments de code" et celles qui renvoient Flow.  Dans les deux cas, le résultat est une <i>CxList</i> .  Mais son contenu sera légèrement différent pour les éléments Flow et code. <br><ul><li>  <b>Élément de code</b> - jeton - par exemple, une variable, un appel de méthode, une affectation, etc. </li><li>  <b>Flow</b> - la relation entre les jetons donnés. </li></ul><br><br><h4>  Tous et «sous» tous </h4><br>  Chaque fonction CMxQL peut être exécutée soit sur l'ensemble <i>All</i> (il contient tous les jetons de tout le code analysé, nous avons déjà vu un exemple avec <i>résultat</i> ) ou sur l'ensemble <i>CxList</i> , qui à son tour a été obtenu à la suite de certaines opérations de la requête, par exemple, la requête: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  va créer un ensemble vide, que nous pouvons ensuite remplir avec des éléments en utilisant la méthode <i>Add ()</i> , puis rechercher déjà par les éléments du nouvel ensemble: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Propriétés des objets trouvés </h4><br>  Chaque élément de l'ensemble CxList possède plusieurs propriétés.  Lors de l'analyse des résultats de l'écriture de requêtes, les plus utiles sont: <br><br><ul><li>  <b>SourceFile</b> - le nom du fichier qui contient cet élément; </li><li>  <b>Ligne source</b> - numéro de ligne avec jeton; </li><li>  <b>Nom de la source</b> - le nom du jeton.  Équivalent au jeton, c'est-à-dire si la variable est appelée var1, alors Nom de la source = var1; </li><li>  <b>Type de source</b> - le type de jeton.  Par exemple, s'il s'agit d'une chaîne, ce sera StringLiteral, si la méthode est appelée, puis MethodInvokeExpr et bien d'autres; </li><li>  <b>Fichier de destination</b> </li><li>  <b>Ligne de destination;</b> </li><li>  <b>Nom de destination;</b> </li><li>  <b>Type de destination.</b> </li></ul><br><br>  La source et la destination seront différentes si les éléments de l'ensemble de résultats sont Flow, et vice versa, ils correspondront si le résultat est des éléments de code. <br><br><h2>  Commencez à créer des requêtes </h2><br>  Toutes les fonctions CMxQL peuvent être divisées en plusieurs types.  Ici, à mon avis, on peut noter le principal inconvénient de la documentation CMxQL, toutes les fonctions du dock sont décrites simplement par ordre alphabétique, alors qu'il serait beaucoup plus pratique de les structurer selon la fonctionnalité et seulement ensuite par ordre alphabétique. <br><br><ul><li>  Fonctions de recherche - presque toutes les fonctions CMxQL avec le nom <b>FindBy *</b> et <b>GetBy *</b> ; </li><li>  Les fonctions des opérations sur les ensembles sont l'addition, la soustraction, l'intersection, l'itération sur les éléments, etc. </li><li>  Fonctions d'analyse - Il s'agit essentiellement des fonctions <b>* InfluencedBy *</b> <b>* InfluencingOn *</b> . </li></ul><br><br>  Le principe de base des requêtes est l'alternance de ces types de fonctions.  Tout d'abord, en utilisant les fonctions de recherche, nous sélectionnons uniquement les jetons qui nous intéressent par certaines propriétés.  En utilisant des opérations sur des ensembles, nous pouvons combiner différents ensembles avec différentes propriétés de jeton en un seul, ou vice versa, soustraire l'autre d'un.  Ensuite, en utilisant les fonctions d'analyse, nous construisons le flux de code et essayons de comprendre si les vulnérabilités potentielles dépendent des paramètres aux points d'entrée. <br><br>  Le choix de l'endroit à partir duquel commencer la recherche, et en général du chemin de recherche entier, dépend du code spécifique, et plus précisément, même du «texte».  Dans certains cas, il est pratique de rechercher des requêtes utilisateur à partir du point d'entrée, dans certains cas, il est plus pratique de commencer par la «fin» ou même par le milieu.  Tout dépend du code spécifique et vous devez approcher individuellement chaque référentiel. <br><br><h2>  Exemple: recherche d'injection SQL </h2><br>  Plan de recherche, entre parenthèses, j'ai indiqué le nom des ensembles (variables dans la requête): <br><br><ol><li>  Définissez les exceptions - jetons qui peuvent être immédiatement retirés des étendues de recherche ( <i>exclusionList</i> ); </li><li>  Déterminer l'emplacement des contrôles de désinfection / sécurité ( <i>désinfection</i> ); </li><li>  Trouver tous les emplacements de bas niveau avec exécution de requête dans la base de données ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Trouver tous les paramètres des méthodes appelées <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Trouver des points d'entrée (méthodes parentes et leurs paramètres) pour les lieux d'exécution des requêtes dans la base de données ( <i>entryPointsParameters</i> ); </li><li>  Trouvez les dépendances des paramètres <i>runSSSQParams</i> sur <i>entryPoints</i> , tandis que seuls les endroits où il n'y a pas de <i>nettoyage de la purification d'</i> entrée. </li></ol><br><br>  En conséquence, nous obtenons des méthodes de bas niveau avec des requêtes SQL, où les paramètres de la requête SQL: <br><br><ul><li>  dépendent des paramètres de la méthode; </li><li>  les paramètres sont acceptés sous forme de chaînes; </li><li>  les paramètres sont concaténés à la demande. </li></ul><br>  Nous ne vérifierons pas si nous pouvons contrôler ces paramètres, car  nous pensons qu'il existe un mécanisme pour mapper des variables dans une requête et qu'il existe un transtypage en type numérique pour les nombres, et la concaténation de chaînes est toujours considérée comme dangereuse.  Même s'il n'y a aucun contrôle sur la ligne maintenant, elle pourrait bien apparaître dans la nouvelle version. <br><br><h3>  SQLi: étape 1. Définition des exceptions </h3><br>  Dans les exceptions, vous devez ajouter les classes ou fichiers dans lesquels les noms de jeton peuvent correspondre à ceux que vous recherchez, car  ces jetons entraîneront des entrées non valides. <br><br>  Par exemple, une méthode d'accès à une base de données est appelée <i>runSuperSecureSQLquery</i> .  Nous supposons que la méthode <i>runSuperSecureSQLquery à l'</i> intérieur est implémentée en toute sécurité.  Et notre tâche est de trouver des endroits où il n'est pas sûr d'utiliser la méthode elle-même.  Pour l'injection SQL, les lieux de concaténation des paramètres contrôlés par l'utilisateur ne seront pas des endroits sûrs.  Et des emplacements sûrs pour mapper des paramètres dans la structure ORM ou, par exemple, pour des paramètres numériques, il s'agit d'une conversion vers le type correspondant.  Nous n'avons pas besoin d'analyser tout le code qui se trouve «plus profondément» que <i>runSuperSecureSQLquery</i> , ce qui signifie qu'il est préférable de l'exclure afin d'éviter les découvertes inutiles. <br><br>  Pour rechercher de telles exceptions, il est pratique d'utiliser les fonctions CMxQL: <br><ul><li>  <b>FindByFileName ()</b> - trouvera l'ensemble de tous les jetons dans un fichier particulier; </li><li>  <b>GetByClass ()</b> - trouvera l'ensemble de tous les jetons de la classe avec le nom donné. </li></ul><br><br>  Pour une application de test, cette exception est la classe <i>Session</i> , qui contient l'implémentation de la méthode <i>runSuperSecureSQLquery</i> . <br>  Un exemple de demande d'exclusion de code dans la classe <i>Session</i> (la méthode <i>GetByClass ()</i> vérifiera lequel des jetons transmis à l'entrée a un type <i>CMx</i> de <i>ClassDecl</i> et émettra beaucoup de jetons de cette classe) <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  Ou une autre façon consiste à jeter du code dans le fichier <i>Session.java</i> entier: <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  L'astérisque devant le nom est important, car le nom de fichier inclut le chemin d'accès complet. <br>  Nous avons maintenant de nombreux jetons qui peuvent être soustraits dans les prochaines étapes de l'étendue de recherche. <br><br>  Résultat de la recherche de jetons dans la classe <i>Session</i> : <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: étape 2. Détermination des lieux de désinfection </h3><br>  Il existe 2 méthodes API dans l'application de test (voir une brève description de l'application de test).  La différence entre les deux méthodes API est que <i>getTransactionInfo ()</i> concatène le paramètre transactionId dans la requête SQL, et <i>getTransactionInfoSecured () convertit d'</i> abord transactionId en Long, puis le transmet sous forme de chaîne.  La vulnérabilité (concaténation des paramètres) est intégrée dans les deux méthodes.  Mais grâce à la <i>conversion</i> en Long dans <i>getTransactionInfoSecured ()</i> , la dernière méthode n'est pas vulnérable à l'injection, car lorsque nous essayons de passer une injection (chaîne), nous obtenons une exception Java. <br><br>  Dans cet exemple, nous considérerons le plâtre de Long comme le site d'assainissement.  Pour trouver ces jetons: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Exemple de résultat: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  Le résultat comprenait des jetons avec les méthodes de type YP <i>Long</i> et <i>getValueAsLong</i> , qui <i>convertissent en</i> interne <i>la</i> valeur en type <i>Long</i> .  Vous devez examiner attentivement le résultat pour vous assurer qu'il n'y a rien de plus. <br><br><h3>  SQLi: étape 3. Rechercher tous les emplacements de bas niveau avec exécution de requête dans la base de données </h3><br>  La requête suivante trouvera tous les emplacements à l'aide du jeton runSuperSecureSQLQuery (utilisé pour accéder à la base de données): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  Résultat de la recherche par nom de jeton runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  De plus, pour les endroits où cette méthode est appelée (classe de <i>facturation</i> ), seuls les jetons d'invocation de méthode (type <i>MethodInvokeExpr</i> ) seront trouvés, et pour le lieu de déclaration de méthode (classe <i>Session</i> ), tous les jetons seront trouvés - variables. <br><br>  Nous filtrons uniquement les jetons d'appel de méthode: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  Résultat: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  En conséquence, nous avons obtenu 7 places, dont 4 les appels requis à la méthode <i>runSuperSecureSQLQuery ()</i> (classes de <i>facturation</i> et d' <i>utilisateur</i> ).  2 - appels à la méthode interne runSuperSecureSQLQuery () à l'intérieur de la classe <i>Session</i> , et une de plus est la méthode <i>add</i> , qui est plutôt une sorte de bizarrerie de recherche CMxQL.  Disons simplement que je ne m'attendais pas à ce qu'il soit dans la liste =) Les jetons de la classe <i>Session</i> , comme nous l'avons découvert à l'étape 1, ne sont pas intéressants pour nous, nous allons donc simplement les soustraire du résultat: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Nous obtenons une liste valide d'appels à la méthode requise: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Notez les fonctions <i>FindByType ()</i> et <i>typeof ()</i> dans la requête précédente.  Si nous voulons rechercher par type CMx, c'est-à-dire par la propriété <i>CxList</i> «Source Type» - alors nous utilisons <i>typeof (Source Type)</i> .  Si nous voulons faire une recherche par type de données, nous devons passer le paramètre comme une chaîne.  Par exemple: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  trouvera tous les jetons java de type String. <br><br><h3>  SQLi: étape 4. Trouver tous les paramètres des méthodes appelées runSuperSecureSQLQuery </h3><br>  Pour rechercher des paramètres de méthode, la fonction <i>CMxQL GetParameters () est utilisée</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  Résultat: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: étape 5. Rechercher des points d'entrée pour les emplacements d'exécution des requêtes dans la base de données </h3><br>  Pour ce faire, nous obtenons d'abord les noms des méthodes parentes, à l'intérieur desquelles se trouvent les appels à la base de données <i>runSuperSecureSQLQuery</i> , puis nous obtenons leurs paramètres.  Pour rechercher des jetons parents, la fonction <i>CMxQL GetAncOfType () est utilisée</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  Dans cette requête, pour l'ensemble runSuperSecureSQLQuery, renvoyez tous les jetons parents de type MethodDecl - il s'agit de la méthode précédente dans la pile des appels: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Pour rechercher des paramètres de méthode, nous utilisons également <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  La requête renverra les paramètres d'un sous-ensemble de <i>entryPoints</i> avec le type Java String: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: étape 6. Recherchez les dépendances des paramètres runSSSQParams sur entryPointsParameters, alors que seuls les endroits où il n'y a pas d'entrée d'entrée de nettoyage </h3><br>  Dans cette étape, nous utilisons les fonctions d'analyse.  Les fonctions suivantes sont utilisées pour analyser le code Flow: <br><br><ul><li>  InfluencedBy () </li><li>  InfluencedByAndNotSanitized () </li><li>  InfluencingOn () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  Pour rechercher les paramètres de demande de flux <i>runSSSQParams en</i> fonction des paramètres de la méthode parent <i>entryPointsParameters</i> et exclure les jetons d'assainissement: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  Cependant, je ne sais pas si les fonctions <i>* AndNotSanitized à</i> l'intérieur font de la magie, et il semble plus que la méthode soustrait simplement l'ensemble aseptisé de son résultat.  Autrement dit, si vous le faites: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  il se passe la même chose.  Même si je n'ai peut-être pas trouvé d'option alors qu'il y a encore des différences. <br><br>  Le résultat de la requête nous donne un flux correctement construit: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Got Flow avec injection SQL potentielle.  Comme le montre la capture d'écran, Checkmarx a renvoyé 3 Flow.  Le flux dans la capture d'écran est le plus court, il commence et se termine dans un fichier et une méthode.  Le flux suivant part déjà dans la classe Session.  Faites attention à la source / destination.  Et la dernière est une autre méthode de la classe Session.  Le flux à l'intérieur de la <i>session</i> ressemblera à ceci: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Pour sélectionner un flux, la méthode <i>ReduceFlow (CxList.ReduceFlowType flowType) est utilisée</i> , où flowType peut être: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> - sélectionnez le flux le plus court </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> - sélectionnez le flux le plus long </li></ul><br><br><h3>  SQLi: requête finale pour trouver une injection SQL </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Exemple 2: recherche de références d'objet direct non sécurisées </h2><br>  Dans cette demande, nous rechercherons tous les endroits où le travail avec les objets a lieu sans vérifier le propriétaire de l'objet.  Dans ce cas, différents noms de paramètres HTTP pour l'identifiant de boîte aux lettres peuvent être utilisés (nous supposons qu'il s'agit de Legacy), et la vérification elle-même peut avoir lieu à différentes étapes: quelque part juste au point API d'entrée HTTP, quelque part avant la demande à la base de données, et parfois dans les méthodes intermédiaires. <br><br>  Plan de recherche <br><ol><li>  Définissez les exceptions ( <i>exclusionList</i> ); </li><li>  Identifier les lieux de contrôle des autorisations ( <i>idorSanitizer</i> ); </li><li>  Trouver des points d'entrée - lieux pour le traitement principal des requêtes HTTP ( <i>webRemoteMethods</i> ); </li><li>  Uniquement par des jetons de point d'entrée pour trouver l'emplacement d'extraction du paramètre HTTP <i>mailboxid</i> ( <i>mailboxidInit</i> ); </li><li>  Trouver tous les appels de webRemoteMethods vers les méthodes middleware et les paramètres de ces appels ( <i>middlewareMethods</i> ); </li><li>  Trouvez des méthodes de middleware qui dépendent de l'identifiant de boîte aux lettres ( <i>apiPotentialIDOR</i> ); </li><li>  Trouver tous les endroits où les méthodes middleware sont définies ( <i>middlewareDecl</i> ); </li><li>  Parcourez tous les <i>apiPotentialIDOR</i> et sélectionnez uniquement les <i>middlewareDecl</i> dans lesquels il n'y a pas de vérification du propriétaire de l'objet <i>boîte</i> aux <i>lettres</i> . </li></ol><br><br><h3>  IDOR: Étape 1. Identifier les exceptions </h3><br>  Dans ce cas, excluez tous les jetons d'un fichier spécifique: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i> contient une implémentation de méthodes telles que <i>getMailboxId</i> et <i>getUserId</i> , ainsi que la chaîne "mailboxid".  Étant donné que le nom des jetons coïncidera avec ceux dont nous avons besoin pour rechercher les vulnérabilités, ce fichier émettra de fausses constatations. <br><br><h3>  IDOR: Étape 2. Recherchez les contrôles d'autorisation </h3><br>  Dans l'application de test, la méthode <i>validateMailbox ()</i> est utilisée pour déterminer si l'objet demandé appartient à l'utilisateur: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  Résultat: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: étape 3. Rechercher des points d'entrée pour les requêtes API HTTP personnalisées </h3><br>  Les gestionnaires de requêtes HTTP ont une annotation spéciale qui les rend faciles à trouver.  Dans mon cas, il s'agit de «WebRemote», la fonction <i>CMxQL FindByCustomAttribute () est</i> utilisée pour rechercher des annotations.  Pour <i>FindByCustomAttribute ()</i> , la fonction de recherche du jeton parent <i>GetAncOfType ()</i> renverra la méthode sous l'annotation: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  Résultat de la demande: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: étape 4. À l'aide des jetons de point d'entrée uniquement, recherchez les emplacements d'extraction HTTP pour le paramètre mailboxid </h3><br>  Pour rechercher des jetons liés au traitement du paramètre HTTP mailboxid: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  nous avons ajouté 3 sets avec 3 lignes différentes, car  selon la légende, le nom du paramètre HTTP peut différer selon les différentes parties du système. <br><br>  La requête trouvera tous les endroits où la <i>boîte aux lettres / mid / boxid est</i> écrite sous forme de chaîne (entre guillemets).  Mais cette requête renverra beaucoup de trouvailles, tk.  une telle chaîne peut être trouvée non seulement aux endroits où les paramètres HTTP sont extraits.  Si nous continuons à travailler avec cet ensemble, nous obtiendrons un grand nombre de fausses découvertes. <br><br>  Par conséquent, nous ne rechercherons que des jetons de points d'entrée ( <i>webRemoteMethods</i> ).  Pour trouver tous les jetons enfants, la fonction <i>CMBQL GetByAncs () est utilisée</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  La demande renverra tous les jetons appartenant aux méthodes annotées en tant que <i>WebRemote</i> .  Déjà à ce stade, nous pouvons filtrer les jetons des méthodes dans lesquelles le propriétaire de l'objet est vérifié.  Par conséquent, nous réécrivons la requête précédente pour rechercher des jetons enfants de manière à sélectionner uniquement les jetons enfants des méthodes <i>WebRemote</i> , où il n'y a pas de contrôle de sécurité pour le propriétaire de l'objet.  Pour ce faire, utilisez une boucle avec la condition: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Nous pouvons maintenant effectuer une sélection plus précise à l'aide des paramètres HTTP <i>mailboxid</i> : <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Mais nous ne nous intéressons pas aux endroits où les paramètres HTTP sont obtenus, mais aux variables auxquelles sont finalement attribuées les valeurs des paramètres HTTP.  Puisqu'il est plus fiable de rechercher Flow précisément avec des jetons de variables. <br><br>  La fonction <i>CMxQL FindByInitialization ()</i> trouvera les lieux d'initialisation des variables pour les jetons donnés: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  Résultat: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: étape 5. Recherchez tous les appels de webRemoteMethods vers les méthodes et paramètres middleware de ces appels </h3><br>  Par middleware, j'entends un code qui va plus loin que les méthodes de traitement des requêtes API HTTP, c'est-à-dire plus profondément que les points d'entrée des requêtes des utilisateurs.  Par exemple, pour la capture d'écran ci-dessus, il s'agit des méthodes de la classe <i>User</i> , des appels à <i>user.getSettings ()</i> et <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Tout d'abord, nous sélectionnons tous les jetons avec le nom d'utilisateur, puis en utilisant <i>GetRightmostMember (), nous</i> sélectionnons les jetons d'appel pour le middleware.  <i>GetRightmostMember ()</i> dans la chaîne d'appels de méthode renverra celui le plus à droite.  Ensuite, nous dérivons les paramètres de la méthode trouvée en utilisant <i>GetParameters ()</i> . <br><br>  Résultat: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: étape 6. Rechercher des méthodes middleware qui dépendent de l'identifiant de boîte aux lettres </h3><br>  L'analyse de flux utilise les <i>méthodes</i> <i>* InfluencedBy *</i> et <i>* InfluncingOn *</i> .  La différence entre eux est claire de nom. <br><br>  Par exemple: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  passera par l'ensemble Tous et trouvera tous les jetons qui dépendent de <i>getMailboxHTTPParams</i> . <br><br>  La même chose peut être écrite d'une autre manière: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  Pour rechercher des jetons dépendants de <i>mailboxidInit</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  Résultat: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: Étape 7. Trouvez tous les endroits pour définir les méthodes du middleware </h3><br>  Trouvons les définitions de toutes les méthodes intermédiaires qui peuvent être utilisées dans les endroits où les demandes des utilisateurs sont traitées.  Pour ce faire, nous mettons en évidence leur propriété commune, par exemple, dans toutes ces méthodes, il y a la création d'un objet <i>Request ()</i> , la création d'un objet est de type <i>CMx ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(All - exclusionList)</i> - vous pouvez effectuer cette soustraction d'ensembles, puis appeler la fonction CMxQL souhaitée à partir du résultat.  <i>Les requêtes</i> contiennent désormais tous les jetons avec le nom <i>Request</i> et le type correspondant à la création de l'objet. <br><br>  Ensuite, en utilisant le <i>GetAncOfType ()</i> familier <i>,</i> nous trouvons le jeton parent de type <i>MethodDecl</i> . <br><br>  Résultat: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: Étape 8. Parcourez tous les apiPotentialIDOR et sélectionnez uniquement les middlewareDecl dans lesquels il n'y a pas de vérification du propriétaire de l'objet mailboxid </h3><br>  Dans la dernière partie de la demande, nous déterminerons lesquelles des méthodes middleware sont appelées directement à partir des méthodes du point d'entrée et ne vérifions pas à qui appartient l' <i>ID de boîte</i> aux <i>lettres</i> .  Combinez ensuite Flow pour une analyse plus pratique des résultats. <br><br>  Nouvelles fonctionnalités que nous n'avons pas encore utilisées: <br>  <i>GetCxListByPath ()</i> - cette fonction est nécessaire pour itérer sur Flow, si elle n'est PAS utilisée, CMx compressera le flux dans l'élément de code (dans le premier nœud de flux) <br>  <i>Concaténer * ()</i> - un certain nombre de fonctions nécessaires pour combiner plusieurs flux en un seul <br>  <i>FindByParameters ()</i> - recherche une méthode par un jeton de paramètre spécifique <br>  <i>GetName ()</i> - retournera une chaîne avec le nom du jeton, s'il y a plus d'un élément dans CxList, alors il retournera le premier.  La méthode est utilisée uniquement lors de l'itération sur les éléments d'un ensemble. <br><br>  La dernière partie de la demande: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  Résultat: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i>CocatenatePath</i>  ,          .     Code Element  Flow <br><br><h3> IDOR:     IDOR </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    –    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Conclusion </h2><br> Checkmarx      ,     .        ,      ,   ,     ..      Flow (    ).           ,         ,    «» . <br><br>     false positive,     : <br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     «Privacy Violation»,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     «hello world»  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477742/">https://habr.com/ru/post/fr477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477732/index.html">Mauvaise classification des doigts des systèmes de navigation sous-marine</a></li>
<li><a href="../fr477734/index.html">Comprendre l'UICollectionViewLayout avec l'application Photos</a></li>
<li><a href="../fr477736/index.html">Le parcours du testeur: du «frein à main» à l'automatisation</a></li>
<li><a href="../fr477738/index.html">iKassa ou comment nous avons apprivoisé le «caissier numérique»</a></li>
<li><a href="../fr477740/index.html">Et où regarder ce télescope avec votre œil?</a></li>
<li><a href="../fr477744/index.html">Pourquoi les professionnels créent-ils parfois de mauvaises applications?</a></li>
<li><a href="../fr477746/index.html">Concepteur de monétisation: qui il est et comment le devenir</a></li>
<li><a href="../fr477752/index.html">Backend United # 5: Shawarma - Microservices, systèmes distribués et Kafka</a></li>
<li><a href="../fr477754/index.html">Comparez micro: bit avec Arduino. Et comment obtenir gratuitement micro: bit si vous n'êtes pas étudiant en anglais?</a></li>
<li><a href="../fr477756/index.html">Comment nous avons épousé deux systèmes CRM bancaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>