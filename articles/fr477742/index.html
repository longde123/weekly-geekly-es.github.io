<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó®Ô∏è ‚ôëÔ∏è üíÜüèΩ "Bonjour, Checkmarx!" Comment √©crire une demande pour Checkmarx SAST et trouver des vuln√©rabilit√©s int√©ressantes üññüèº üêö üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Dans l'article, je veux parler de notre exp√©rience dans la cr√©ation de mes requ√™tes dans Checkmarx SAST. 

 Lorsque vous vous famili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Bonjour, Checkmarx!" Comment √©crire une demande pour Checkmarx SAST et trouver des vuln√©rabilit√©s int√©ressantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Bonjour, Habr! <br><br>  Dans l'article, je veux parler de notre exp√©rience dans la cr√©ation de mes requ√™tes dans Checkmarx SAST. <br><br>  Lorsque vous vous familiarisez avec cet analyseur pour la premi√®re fois, vous pouvez avoir l'impression qu'en plus de rechercher des algorithmes de chiffrement / hachage faibles et un tas de faux positifs, il ne renvoie rien d'autre.  Mais lorsqu'il est correctement configur√©, c'est un outil super puissant qui peut rechercher des bugs graves. <br><br>  Nous allons comprendre les subtilit√©s du langage de requ√™te Checkmarx SAST et √©crire 2 requ√™tes pour rechercher des injections SQL et des r√©f√©rences d'objet direct non s√©curis√©es. <br><a name="habracut"></a><br><br><h2>  Entr√©e </h2><br>  Apr√®s une longue recherche de guides ou d'articles sur Checkmarx, il est devenu clair pour moi qu'en dehors de la documentation officielle, il n'y avait pas assez d'informations utiles.  Et la documentation officielle ne dit pas que tout devient tr√®s clair et compr√©hensible.  Par exemple, je n'ai trouv√© aucune meilleure pratique, comment organiser correctement les requ√™tes de remplacement, comment √©crire une requ√™te ¬´pour les nuls¬ª, etc. Oui, il existe une documentation sur les fonctions du langage de requ√™te CMx, mais voici comment combiner ces fonctions en une seule requ√™te, la documentation n'est pas √©crite. <br><br>  Peut-√™tre que le manque d'articles et de guides de la communaut√© Checkmarx est associ√© au co√ªt √©lev√© de l'outil et, par cons√©quent, √† un public restreint.  Ou peut-√™tre que peu de gens s'embarrassent du r√©glage fin et utilisent la solution telle quelle, pr√™te √† l'emploi. <br><br>  D'apr√®s mon exp√©rience, je constate davantage que SAST est davantage utilis√© pour se conformer aux formalit√©s li√©es aux diverses exigences des clients que pour rechercher de vrais bugs.  Avec cette approche, nous avons donc, au mieux, un nombre relativement faible de ¬´vuln√©rabilit√©s¬ª que l'on appelle presque automatiquement ¬´non exploitables¬ª (car elles sont dans 99,9% des cas). <br><br>  Il convient de noter que Checkmarx essaie lui-m√™me de mettre √† jour ses requ√™tes afin de donner le meilleur r√©sultat pr√™t √† l'emploi.  Mais les requ√™tes CMx Query Language sont adapt√©es au ¬´cas g√©n√©ral¬ª.  La recherche initiale de jetons est bas√©e sur le nom.  Par exemple, CMx SAST suppose que toutes les requ√™tes vers la base de donn√©es ressembleront √† ceci: * createQuery * ou * createSQLQuery *.  Mais si le d√©veloppement interne est utilis√© pour travailler avec la base de donn√©es et que la m√©thode d'interrogation de la base de donn√©es est appel√©e diff√©remment, par exemple * driveMyQuery *, toutes les m√©thodes SQL seront ignor√©es.  Par exemple, notre client utilise ORM personnalis√© pour SQL DB.  Dans ce cas, les requ√™tes CMx pr√™tes √† l'emploi ont ignor√© toutes les injections SQL. <br><br><h4>  Abr√©viations et d√©finitions </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - <b>Langage de</b> requ√™te Checkmarx SAST <br>  <b>Token</b> - une cha√Æne avec une certaine valeur est le r√©sultat du travail de l'analyseur lexical (qui est aussi appel√© tokenisation) <br><br><h3>  Application de test </h3><br>  Pour √©crire un article, j'ai esquiss√© du code Java, une petite application de test.  Ce code est une copie approximative d'une petite partie du syst√®me r√©el.  Bien qu'en g√©n√©ral le code de l'application de test ne soit pas tr√®s diff√©rent de tout autre code backend HTTP.  Les sections cl√©s du code de l'application de test seront visibles sur les captures d'√©cran. <br><br><h4>  L'application de test a la structure suivante </h4><br>  Classe <i>WebRouter</i> pour le traitement des requ√™tes HTTP entrantes; 4 m√©thodes de traitement des URL √† l'int√©rieur: <br><ul><li>  <i>/ getTransaction</i> - accepte l' <i>ID de</i> transaction √† l'entr√©e <i>et renvoie les informations</i> dessus, <i>id le</i> prend comme cha√Æne et le transmet √† <i>getTransactionInfo (transactionId)</i> =&gt; <i>getTransactionInfo (transactoinId)</i> - fait que transactionId concat√®ne √† la requ√™te SQL (c'est-√†-dire que l'injection SQL est obtenue); </li><li>  <i>/ getSecureTransaction</i> - accepte l' <i>ID de</i> transaction en entr√©e <i>et renvoie les informations</i> dessus, <i>id le</i> prend comme cha√Æne et le transmet <i>getTransactionInfoSecured ()</i> =&gt; <i>getTransactionInfoSecured (transactoinId)</i> - <i>convertit d'</i> abord <i>la</i> cha√Æne <i>transactionId</i> en type Long, puis la concat√®ne √† la requ√™te SQL (dans ce cas o√π l'injection n'est pas exploit√©e); </li><li>  <i>/ getSettings</i> - accepte <i>userId</i> et <i>mailboxId comme entr√©e</i> - et √©met les param√®tres de bo√Æte aux lettres.  Ne v√©rifie pas que l' <i>ID de bo√Æte</i> aux <i>lettres</i> appartient √† l'utilisateur; </li><li>  <i>/ getSecureSettings</i> - accepte √©galement <i>userId</i> et <i>mailboxId √† l'entr√©e</i> et affiche les param√®tres de bo√Æte aux lettres.  MAIS v√©rifie que l' <i>ID de bo√Æte</i> aux <i>lettres</i> appartient √† l'utilisateur. </li></ul><br><br><h2>  CMx: informations g√©n√©rales et d√©finitions de base </h2><br><h3>  Avant de commencer √† d√©velopper des requ√™tes </h3><br>  Le d√©veloppement des requ√™tes est effectu√© dans un programme distinct CxAuditor.  Dans CxAuditor, vous devez analyser tout le code (cr√©er un projet local), pour lequel nous √©crirons des requ√™tes.  Apr√®s cela, vous pouvez √©crire et ex√©cuter de nouvelles requ√™tes.  Avec une grande base de code, l'analyse principale peut prendre des heures et des gigaoctets de m√©moire.  Apr√®s cela, chaque demande ne sera pas ex√©cut√©e assez rapidement.  Ceci est totalement inadapt√© au d√©veloppement. <br><br>  Par cons√©quent, vous pouvez prendre un petit ensemble de fichiers du projet, id√©alement avec un bogue trouv√© dans le code avant le type sous lequel nous √©crivons une demande (ou y mettre le bogue avec vos mains) et analyser uniquement cet ensemble de fichiers.  Il n'est pas n√©cessaire de respecter la structure de fichiers du projet.  Autrement dit, si vous avez le package Java A et B, et que les classes du package B utilisent les classes et les m√©thodes du package A, vous pouvez mettre tout cela dans un seul r√©pertoire, et CMx comprendra toujours les relations et construira correctement les cha√Ænes d'appels entre les fichiers (enfin, ou presque toujours correct, bien que les erreurs soient √† peine li√©es √† la structure des fichiers du projet). <br><br><h3>  D√©finitions de base </h3><br><h4>  Cxlist </h4><br>  Le type de donn√©es principal dans CMx.  Le r√©sultat de presque toutes les fonctions CMxQL sera <i>CxList</i> .  C'est beaucoup d'√©l√©ments avec certaines propri√©t√©s.  Les propri√©t√©s les plus utiles pour le d√©veloppement seront examin√©es ci-dessous. <br><br><h4>  r√©sultat </h4><br>  CMxQL a un <i>r√©sultat</i> variable int√©gr√©.  L'ensemble qui contient la variable de <i>r√©sultat</i> , apr√®s l'ex√©cution de la requ√™te enti√®re, sera affich√© comme r√©sultat. <br><br>  Autrement dit, l'op√©ration finale de toute requ√™te doit √™tre la cha√Æne <i>result = WHATEVER</i> , par exemple: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  √©l√©ment de flux et de code </h4><br>  La plupart des fonctions CMxQL par type de valeurs retourn√©es sont divis√©es en 2, celles qui renvoient des "√©l√©ments de code" et celles qui renvoient Flow.  Dans les deux cas, le r√©sultat est une <i>CxList</i> .  Mais son contenu sera l√©g√®rement diff√©rent pour les √©l√©ments Flow et code. <br><ul><li>  <b>√âl√©ment de code</b> - jeton - par exemple, une variable, un appel de m√©thode, une affectation, etc. </li><li>  <b>Flow</b> - la relation entre les jetons donn√©s. </li></ul><br><br><h4>  Tous et ¬´sous¬ª tous </h4><br>  Chaque fonction CMxQL peut √™tre ex√©cut√©e soit sur l'ensemble <i>All</i> (il contient tous les jetons de tout le code analys√©, nous avons d√©j√† vu un exemple avec <i>r√©sultat</i> ) ou sur l'ensemble <i>CxList</i> , qui √† son tour a √©t√© obtenu √† la suite de certaines op√©rations de la requ√™te, par exemple, la requ√™te: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  va cr√©er un ensemble vide, que nous pouvons ensuite remplir avec des √©l√©ments en utilisant la m√©thode <i>Add ()</i> , puis rechercher d√©j√† par les √©l√©ments du nouvel ensemble: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Propri√©t√©s des objets trouv√©s </h4><br>  Chaque √©l√©ment de l'ensemble CxList poss√®de plusieurs propri√©t√©s.  Lors de l'analyse des r√©sultats de l'√©criture de requ√™tes, les plus utiles sont: <br><br><ul><li>  <b>SourceFile</b> - le nom du fichier qui contient cet √©l√©ment; </li><li>  <b>Ligne source</b> - num√©ro de ligne avec jeton; </li><li>  <b>Nom de la source</b> - le nom du jeton.  √âquivalent au jeton, c'est-√†-dire si la variable est appel√©e var1, alors Nom de la source = var1; </li><li>  <b>Type de source</b> - le type de jeton.  Par exemple, s'il s'agit d'une cha√Æne, ce sera StringLiteral, si la m√©thode est appel√©e, puis MethodInvokeExpr et bien d'autres; </li><li>  <b>Fichier de destination</b> </li><li>  <b>Ligne de destination;</b> </li><li>  <b>Nom de destination;</b> </li><li>  <b>Type de destination.</b> </li></ul><br><br>  La source et la destination seront diff√©rentes si les √©l√©ments de l'ensemble de r√©sultats sont Flow, et vice versa, ils correspondront si le r√©sultat est des √©l√©ments de code. <br><br><h2>  Commencez √† cr√©er des requ√™tes </h2><br>  Toutes les fonctions CMxQL peuvent √™tre divis√©es en plusieurs types.  Ici, √† mon avis, on peut noter le principal inconv√©nient de la documentation CMxQL, toutes les fonctions du dock sont d√©crites simplement par ordre alphab√©tique, alors qu'il serait beaucoup plus pratique de les structurer selon la fonctionnalit√© et seulement ensuite par ordre alphab√©tique. <br><br><ul><li>  Fonctions de recherche - presque toutes les fonctions CMxQL avec le nom <b>FindBy *</b> et <b>GetBy *</b> ; </li><li>  Les fonctions des op√©rations sur les ensembles sont l'addition, la soustraction, l'intersection, l'it√©ration sur les √©l√©ments, etc. </li><li>  Fonctions d'analyse - Il s'agit essentiellement des fonctions <b>* InfluencedBy *</b> <b>* InfluencingOn *</b> . </li></ul><br><br>  Le principe de base des requ√™tes est l'alternance de ces types de fonctions.  Tout d'abord, en utilisant les fonctions de recherche, nous s√©lectionnons uniquement les jetons qui nous int√©ressent par certaines propri√©t√©s.  En utilisant des op√©rations sur des ensembles, nous pouvons combiner diff√©rents ensembles avec diff√©rentes propri√©t√©s de jeton en un seul, ou vice versa, soustraire l'autre d'un.  Ensuite, en utilisant les fonctions d'analyse, nous construisons le flux de code et essayons de comprendre si les vuln√©rabilit√©s potentielles d√©pendent des param√®tres aux points d'entr√©e. <br><br>  Le choix de l'endroit √† partir duquel commencer la recherche, et en g√©n√©ral du chemin de recherche entier, d√©pend du code sp√©cifique, et plus pr√©cis√©ment, m√™me du ¬´texte¬ª.  Dans certains cas, il est pratique de rechercher des requ√™tes utilisateur √† partir du point d'entr√©e, dans certains cas, il est plus pratique de commencer par la ¬´fin¬ª ou m√™me par le milieu.  Tout d√©pend du code sp√©cifique et vous devez approcher individuellement chaque r√©f√©rentiel. <br><br><h2>  Exemple: recherche d'injection SQL </h2><br>  Plan de recherche, entre parenth√®ses, j'ai indiqu√© le nom des ensembles (variables dans la requ√™te): <br><br><ol><li>  D√©finissez les exceptions - jetons qui peuvent √™tre imm√©diatement retir√©s des √©tendues de recherche ( <i>exclusionList</i> ); </li><li>  D√©terminer l'emplacement des contr√¥les de d√©sinfection / s√©curit√© ( <i>d√©sinfection</i> ); </li><li>  Trouver tous les emplacements de bas niveau avec ex√©cution de requ√™te dans la base de donn√©es ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Trouver tous les param√®tres des m√©thodes appel√©es <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Trouver des points d'entr√©e (m√©thodes parentes et leurs param√®tres) pour les lieux d'ex√©cution des requ√™tes dans la base de donn√©es ( <i>entryPointsParameters</i> ); </li><li>  Trouvez les d√©pendances des param√®tres <i>runSSSQParams</i> sur <i>entryPoints</i> , tandis que seuls les endroits o√π il n'y a pas de <i>nettoyage de la purification d'</i> entr√©e. </li></ol><br><br>  En cons√©quence, nous obtenons des m√©thodes de bas niveau avec des requ√™tes SQL, o√π les param√®tres de la requ√™te SQL: <br><br><ul><li>  d√©pendent des param√®tres de la m√©thode; </li><li>  les param√®tres sont accept√©s sous forme de cha√Ænes; </li><li>  les param√®tres sont concat√©n√©s √† la demande. </li></ul><br>  Nous ne v√©rifierons pas si nous pouvons contr√¥ler ces param√®tres, car  nous pensons qu'il existe un m√©canisme pour mapper des variables dans une requ√™te et qu'il existe un transtypage en type num√©rique pour les nombres, et la concat√©nation de cha√Ænes est toujours consid√©r√©e comme dangereuse.  M√™me s'il n'y a aucun contr√¥le sur la ligne maintenant, elle pourrait bien appara√Ætre dans la nouvelle version. <br><br><h3>  SQLi: √©tape 1. D√©finition des exceptions </h3><br>  Dans les exceptions, vous devez ajouter les classes ou fichiers dans lesquels les noms de jeton peuvent correspondre √† ceux que vous recherchez, car  ces jetons entra√Æneront des entr√©es non valides. <br><br>  Par exemple, une m√©thode d'acc√®s √† une base de donn√©es est appel√©e <i>runSuperSecureSQLquery</i> .  Nous supposons que la m√©thode <i>runSuperSecureSQLquery √† l'</i> int√©rieur est impl√©ment√©e en toute s√©curit√©.  Et notre t√¢che est de trouver des endroits o√π il n'est pas s√ªr d'utiliser la m√©thode elle-m√™me.  Pour l'injection SQL, les lieux de concat√©nation des param√®tres contr√¥l√©s par l'utilisateur ne seront pas des endroits s√ªrs.  Et des emplacements s√ªrs pour mapper des param√®tres dans la structure ORM ou, par exemple, pour des param√®tres num√©riques, il s'agit d'une conversion vers le type correspondant.  Nous n'avons pas besoin d'analyser tout le code qui se trouve ¬´plus profond√©ment¬ª que <i>runSuperSecureSQLquery</i> , ce qui signifie qu'il est pr√©f√©rable de l'exclure afin d'√©viter les d√©couvertes inutiles. <br><br>  Pour rechercher de telles exceptions, il est pratique d'utiliser les fonctions CMxQL: <br><ul><li>  <b>FindByFileName ()</b> - trouvera l'ensemble de tous les jetons dans un fichier particulier; </li><li>  <b>GetByClass ()</b> - trouvera l'ensemble de tous les jetons de la classe avec le nom donn√©. </li></ul><br><br>  Pour une application de test, cette exception est la classe <i>Session</i> , qui contient l'impl√©mentation de la m√©thode <i>runSuperSecureSQLquery</i> . <br>  Un exemple de demande d'exclusion de code dans la classe <i>Session</i> (la m√©thode <i>GetByClass ()</i> v√©rifiera lequel des jetons transmis √† l'entr√©e a un type <i>CMx</i> de <i>ClassDecl</i> et √©mettra beaucoup de jetons de cette classe) <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  Ou une autre fa√ßon consiste √† jeter du code dans le fichier <i>Session.java</i> entier: <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  L'ast√©risque devant le nom est important, car le nom de fichier inclut le chemin d'acc√®s complet. <br>  Nous avons maintenant de nombreux jetons qui peuvent √™tre soustraits dans les prochaines √©tapes de l'√©tendue de recherche. <br><br>  R√©sultat de la recherche de jetons dans la classe <i>Session</i> : <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: √©tape 2. D√©termination des lieux de d√©sinfection </h3><br>  Il existe 2 m√©thodes API dans l'application de test (voir une br√®ve description de l'application de test).  La diff√©rence entre les deux m√©thodes API est que <i>getTransactionInfo ()</i> concat√®ne le param√®tre transactionId dans la requ√™te SQL, et <i>getTransactionInfoSecured () convertit d'</i> abord transactionId en Long, puis le transmet sous forme de cha√Æne.  La vuln√©rabilit√© (concat√©nation des param√®tres) est int√©gr√©e dans les deux m√©thodes.  Mais gr√¢ce √† la <i>conversion</i> en Long dans <i>getTransactionInfoSecured ()</i> , la derni√®re m√©thode n'est pas vuln√©rable √† l'injection, car lorsque nous essayons de passer une injection (cha√Æne), nous obtenons une exception Java. <br><br>  Dans cet exemple, nous consid√©rerons le pl√¢tre de Long comme le site d'assainissement.  Pour trouver ces jetons: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Exemple de r√©sultat: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  Le r√©sultat comprenait des jetons avec les m√©thodes de type YP <i>Long</i> et <i>getValueAsLong</i> , qui <i>convertissent en</i> interne <i>la</i> valeur en type <i>Long</i> .  Vous devez examiner attentivement le r√©sultat pour vous assurer qu'il n'y a rien de plus. <br><br><h3>  SQLi: √©tape 3. Rechercher tous les emplacements de bas niveau avec ex√©cution de requ√™te dans la base de donn√©es </h3><br>  La requ√™te suivante trouvera tous les emplacements √† l'aide du jeton runSuperSecureSQLQuery (utilis√© pour acc√©der √† la base de donn√©es): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  R√©sultat de la recherche par nom de jeton runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  De plus, pour les endroits o√π cette m√©thode est appel√©e (classe de <i>facturation</i> ), seuls les jetons d'invocation de m√©thode (type <i>MethodInvokeExpr</i> ) seront trouv√©s, et pour le lieu de d√©claration de m√©thode (classe <i>Session</i> ), tous les jetons seront trouv√©s - variables. <br><br>  Nous filtrons uniquement les jetons d'appel de m√©thode: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  R√©sultat: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  En cons√©quence, nous avons obtenu 7 places, dont 4 les appels requis √† la m√©thode <i>runSuperSecureSQLQuery ()</i> (classes de <i>facturation</i> et d' <i>utilisateur</i> ).  2 - appels √† la m√©thode interne runSuperSecureSQLQuery () √† l'int√©rieur de la classe <i>Session</i> , et une de plus est la m√©thode <i>add</i> , qui est plut√¥t une sorte de bizarrerie de recherche CMxQL.  Disons simplement que je ne m'attendais pas √† ce qu'il soit dans la liste =) Les jetons de la classe <i>Session</i> , comme nous l'avons d√©couvert √† l'√©tape 1, ne sont pas int√©ressants pour nous, nous allons donc simplement les soustraire du r√©sultat: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Nous obtenons une liste valide d'appels √† la m√©thode requise: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Notez les fonctions <i>FindByType ()</i> et <i>typeof ()</i> dans la requ√™te pr√©c√©dente.  Si nous voulons rechercher par type CMx, c'est-√†-dire par la propri√©t√© <i>CxList</i> ¬´Source Type¬ª - alors nous utilisons <i>typeof (Source Type)</i> .  Si nous voulons faire une recherche par type de donn√©es, nous devons passer le param√®tre comme une cha√Æne.  Par exemple: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  trouvera tous les jetons java de type String. <br><br><h3>  SQLi: √©tape 4. Trouver tous les param√®tres des m√©thodes appel√©es runSuperSecureSQLQuery </h3><br>  Pour rechercher des param√®tres de m√©thode, la fonction <i>CMxQL GetParameters () est utilis√©e</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: √©tape 5. Rechercher des points d'entr√©e pour les emplacements d'ex√©cution des requ√™tes dans la base de donn√©es </h3><br>  Pour ce faire, nous obtenons d'abord les noms des m√©thodes parentes, √† l'int√©rieur desquelles se trouvent les appels √† la base de donn√©es <i>runSuperSecureSQLQuery</i> , puis nous obtenons leurs param√®tres.  Pour rechercher des jetons parents, la fonction <i>CMxQL GetAncOfType () est utilis√©e</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  Dans cette requ√™te, pour l'ensemble runSuperSecureSQLQuery, renvoyez tous les jetons parents de type MethodDecl - il s'agit de la m√©thode pr√©c√©dente dans la pile des appels: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Pour rechercher des param√®tres de m√©thode, nous utilisons √©galement <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  La requ√™te renverra les param√®tres d'un sous-ensemble de <i>entryPoints</i> avec le type Java String: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: √©tape 6. Recherchez les d√©pendances des param√®tres runSSSQParams sur entryPointsParameters, alors que seuls les endroits o√π il n'y a pas d'entr√©e d'entr√©e de nettoyage </h3><br>  Dans cette √©tape, nous utilisons les fonctions d'analyse.  Les fonctions suivantes sont utilis√©es pour analyser le code Flow: <br><br><ul><li>  InfluencedBy () </li><li>  InfluencedByAndNotSanitized () </li><li>  InfluencingOn () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  Pour rechercher les param√®tres de demande de flux <i>runSSSQParams en</i> fonction des param√®tres de la m√©thode parent <i>entryPointsParameters</i> et exclure les jetons d'assainissement: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  Cependant, je ne sais pas si les fonctions <i>* AndNotSanitized √†</i> l'int√©rieur font de la magie, et il semble plus que la m√©thode soustrait simplement l'ensemble aseptis√© de son r√©sultat.  Autrement dit, si vous le faites: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  il se passe la m√™me chose.  M√™me si je n'ai peut-√™tre pas trouv√© d'option alors qu'il y a encore des diff√©rences. <br><br>  Le r√©sultat de la requ√™te nous donne un flux correctement construit: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Got Flow avec injection SQL potentielle.  Comme le montre la capture d'√©cran, Checkmarx a renvoy√© 3 Flow.  Le flux dans la capture d'√©cran est le plus court, il commence et se termine dans un fichier et une m√©thode.  Le flux suivant part d√©j√† dans la classe Session.  Faites attention √† la source / destination.  Et la derni√®re est une autre m√©thode de la classe Session.  Le flux √† l'int√©rieur de la <i>session</i> ressemblera √† ceci: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Pour s√©lectionner un flux, la m√©thode <i>ReduceFlow (CxList.ReduceFlowType flowType) est utilis√©e</i> , o√π flowType peut √™tre: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> - s√©lectionnez le flux le plus court </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> - s√©lectionnez le flux le plus long </li></ul><br><br><h3>  SQLi: requ√™te finale pour trouver une injection SQL </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Exemple 2: recherche de r√©f√©rences d'objet direct non s√©curis√©es </h2><br>  Dans cette demande, nous rechercherons tous les endroits o√π le travail avec les objets a lieu sans v√©rifier le propri√©taire de l'objet.  Dans ce cas, diff√©rents noms de param√®tres HTTP pour l'identifiant de bo√Æte aux lettres peuvent √™tre utilis√©s (nous supposons qu'il s'agit de Legacy), et la v√©rification elle-m√™me peut avoir lieu √† diff√©rentes √©tapes: quelque part juste au point API d'entr√©e HTTP, quelque part avant la demande √† la base de donn√©es, et parfois dans les m√©thodes interm√©diaires. <br><br>  Plan de recherche <br><ol><li>  D√©finissez les exceptions ( <i>exclusionList</i> ); </li><li>  Identifier les lieux de contr√¥le des autorisations ( <i>idorSanitizer</i> ); </li><li>  Trouver des points d'entr√©e - lieux pour le traitement principal des requ√™tes HTTP ( <i>webRemoteMethods</i> ); </li><li>  Uniquement par des jetons de point d'entr√©e pour trouver l'emplacement d'extraction du param√®tre HTTP <i>mailboxid</i> ( <i>mailboxidInit</i> ); </li><li>  Trouver tous les appels de webRemoteMethods vers les m√©thodes middleware et les param√®tres de ces appels ( <i>middlewareMethods</i> ); </li><li>  Trouvez des m√©thodes de middleware qui d√©pendent de l'identifiant de bo√Æte aux lettres ( <i>apiPotentialIDOR</i> ); </li><li>  Trouver tous les endroits o√π les m√©thodes middleware sont d√©finies ( <i>middlewareDecl</i> ); </li><li>  Parcourez tous les <i>apiPotentialIDOR</i> et s√©lectionnez uniquement les <i>middlewareDecl</i> dans lesquels il n'y a pas de v√©rification du propri√©taire de l'objet <i>bo√Æte</i> aux <i>lettres</i> . </li></ol><br><br><h3>  IDOR: √âtape 1. Identifier les exceptions </h3><br>  Dans ce cas, excluez tous les jetons d'un fichier sp√©cifique: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i> contient une impl√©mentation de m√©thodes telles que <i>getMailboxId</i> et <i>getUserId</i> , ainsi que la cha√Æne "mailboxid".  √âtant donn√© que le nom des jetons co√Øncidera avec ceux dont nous avons besoin pour rechercher les vuln√©rabilit√©s, ce fichier √©mettra de fausses constatations. <br><br><h3>  IDOR: √âtape 2. Recherchez les contr√¥les d'autorisation </h3><br>  Dans l'application de test, la m√©thode <i>validateMailbox ()</i> est utilis√©e pour d√©terminer si l'objet demand√© appartient √† l'utilisateur: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: √©tape 3. Rechercher des points d'entr√©e pour les requ√™tes API HTTP personnalis√©es </h3><br>  Les gestionnaires de requ√™tes HTTP ont une annotation sp√©ciale qui les rend faciles √† trouver.  Dans mon cas, il s'agit de ¬´WebRemote¬ª, la fonction <i>CMxQL FindByCustomAttribute () est</i> utilis√©e pour rechercher des annotations.  Pour <i>FindByCustomAttribute ()</i> , la fonction de recherche du jeton parent <i>GetAncOfType ()</i> renverra la m√©thode sous l'annotation: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  R√©sultat de la demande: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: √©tape 4. √Ä l'aide des jetons de point d'entr√©e uniquement, recherchez les emplacements d'extraction HTTP pour le param√®tre mailboxid </h3><br>  Pour rechercher des jetons li√©s au traitement du param√®tre HTTP mailboxid: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  nous avons ajout√© 3 sets avec 3 lignes diff√©rentes, car  selon la l√©gende, le nom du param√®tre HTTP peut diff√©rer selon les diff√©rentes parties du syst√®me. <br><br>  La requ√™te trouvera tous les endroits o√π la <i>bo√Æte aux lettres / mid / boxid est</i> √©crite sous forme de cha√Æne (entre guillemets).  Mais cette requ√™te renverra beaucoup de trouvailles, tk.  une telle cha√Æne peut √™tre trouv√©e non seulement aux endroits o√π les param√®tres HTTP sont extraits.  Si nous continuons √† travailler avec cet ensemble, nous obtiendrons un grand nombre de fausses d√©couvertes. <br><br>  Par cons√©quent, nous ne rechercherons que des jetons de points d'entr√©e ( <i>webRemoteMethods</i> ).  Pour trouver tous les jetons enfants, la fonction <i>CMBQL GetByAncs () est utilis√©e</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  La demande renverra tous les jetons appartenant aux m√©thodes annot√©es en tant que <i>WebRemote</i> .  D√©j√† √† ce stade, nous pouvons filtrer les jetons des m√©thodes dans lesquelles le propri√©taire de l'objet est v√©rifi√©.  Par cons√©quent, nous r√©√©crivons la requ√™te pr√©c√©dente pour rechercher des jetons enfants de mani√®re √† s√©lectionner uniquement les jetons enfants des m√©thodes <i>WebRemote</i> , o√π il n'y a pas de contr√¥le de s√©curit√© pour le propri√©taire de l'objet.  Pour ce faire, utilisez une boucle avec la condition: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Nous pouvons maintenant effectuer une s√©lection plus pr√©cise √† l'aide des param√®tres HTTP <i>mailboxid</i> : <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Mais nous ne nous int√©ressons pas aux endroits o√π les param√®tres HTTP sont obtenus, mais aux variables auxquelles sont finalement attribu√©es les valeurs des param√®tres HTTP.  Puisqu'il est plus fiable de rechercher Flow pr√©cis√©ment avec des jetons de variables. <br><br>  La fonction <i>CMxQL FindByInitialization ()</i> trouvera les lieux d'initialisation des variables pour les jetons donn√©s: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: √©tape 5. Recherchez tous les appels de webRemoteMethods vers les m√©thodes et param√®tres middleware de ces appels </h3><br>  Par middleware, j'entends un code qui va plus loin que les m√©thodes de traitement des requ√™tes API HTTP, c'est-√†-dire plus profond√©ment que les points d'entr√©e des requ√™tes des utilisateurs.  Par exemple, pour la capture d'√©cran ci-dessus, il s'agit des m√©thodes de la classe <i>User</i> , des appels √† <i>user.getSettings ()</i> et <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Tout d'abord, nous s√©lectionnons tous les jetons avec le nom d'utilisateur, puis en utilisant <i>GetRightmostMember (), nous</i> s√©lectionnons les jetons d'appel pour le middleware.  <i>GetRightmostMember ()</i> dans la cha√Æne d'appels de m√©thode renverra celui le plus √† droite.  Ensuite, nous d√©rivons les param√®tres de la m√©thode trouv√©e en utilisant <i>GetParameters ()</i> . <br><br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: √©tape 6. Rechercher des m√©thodes middleware qui d√©pendent de l'identifiant de bo√Æte aux lettres </h3><br>  L'analyse de flux utilise les <i>m√©thodes</i> <i>* InfluencedBy *</i> et <i>* InfluncingOn *</i> .  La diff√©rence entre eux est claire de nom. <br><br>  Par exemple: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  passera par l'ensemble Tous et trouvera tous les jetons qui d√©pendent de <i>getMailboxHTTPParams</i> . <br><br>  La m√™me chose peut √™tre √©crite d'une autre mani√®re: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  Pour rechercher des jetons d√©pendants de <i>mailboxidInit</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: √âtape 7. Trouvez tous les endroits pour d√©finir les m√©thodes du middleware </h3><br>  Trouvons les d√©finitions de toutes les m√©thodes interm√©diaires qui peuvent √™tre utilis√©es dans les endroits o√π les demandes des utilisateurs sont trait√©es.  Pour ce faire, nous mettons en √©vidence leur propri√©t√© commune, par exemple, dans toutes ces m√©thodes, il y a la cr√©ation d'un objet <i>Request ()</i> , la cr√©ation d'un objet est de type <i>CMx ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(All - exclusionList)</i> - vous pouvez effectuer cette soustraction d'ensembles, puis appeler la fonction CMxQL souhait√©e √† partir du r√©sultat.  <i>Les requ√™tes</i> contiennent d√©sormais tous les jetons avec le nom <i>Request</i> et le type correspondant √† la cr√©ation de l'objet. <br><br>  Ensuite, en utilisant le <i>GetAncOfType ()</i> familier <i>,</i> nous trouvons le jeton parent de type <i>MethodDecl</i> . <br><br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: √âtape 8. Parcourez tous les apiPotentialIDOR et s√©lectionnez uniquement les middlewareDecl dans lesquels il n'y a pas de v√©rification du propri√©taire de l'objet mailboxid </h3><br>  Dans la derni√®re partie de la demande, nous d√©terminerons lesquelles des m√©thodes middleware sont appel√©es directement √† partir des m√©thodes du point d'entr√©e et ne v√©rifions pas √† qui appartient l' <i>ID de bo√Æte</i> aux <i>lettres</i> .  Combinez ensuite Flow pour une analyse plus pratique des r√©sultats. <br><br>  Nouvelles fonctionnalit√©s que nous n'avons pas encore utilis√©es: <br>  <i>GetCxListByPath ()</i> - cette fonction est n√©cessaire pour it√©rer sur Flow, si elle n'est PAS utilis√©e, CMx compressera le flux dans l'√©l√©ment de code (dans le premier n≈ìud de flux) <br>  <i>Concat√©ner * ()</i> - un certain nombre de fonctions n√©cessaires pour combiner plusieurs flux en un seul <br>  <i>FindByParameters ()</i> - recherche une m√©thode par un jeton de param√®tre sp√©cifique <br>  <i>GetName ()</i> - retournera une cha√Æne avec le nom du jeton, s'il y a plus d'un √©l√©ment dans CxList, alors il retournera le premier.  La m√©thode est utilis√©e uniquement lors de l'it√©ration sur les √©l√©ments d'un ensemble. <br><br>  La derni√®re partie de la demande: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  R√©sultat: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i>CocatenatePath</i>  ,          .     Code Element  Flow <br><br><h3> IDOR:     IDOR </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    ‚Äì    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Conclusion </h2><br> Checkmarx      ,     .        ,      ,   ,     ..      Flow (    ).           ,         ,    ¬´¬ª . <br><br>     false positive,     : <br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     ¬´Privacy Violation¬ª,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     ¬´hello world¬ª  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477742/">https://habr.com/ru/post/fr477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477732/index.html">Mauvaise classification des doigts des syst√®mes de navigation sous-marine</a></li>
<li><a href="../fr477734/index.html">Comprendre l'UICollectionViewLayout avec l'application Photos</a></li>
<li><a href="../fr477736/index.html">Le parcours du testeur: du ¬´frein √† main¬ª √† l'automatisation</a></li>
<li><a href="../fr477738/index.html">iKassa ou comment nous avons apprivois√© le ¬´caissier num√©rique¬ª</a></li>
<li><a href="../fr477740/index.html">Et o√π regarder ce t√©lescope avec votre ≈ìil?</a></li>
<li><a href="../fr477744/index.html">Pourquoi les professionnels cr√©ent-ils parfois de mauvaises applications?</a></li>
<li><a href="../fr477746/index.html">Concepteur de mon√©tisation: qui il est et comment le devenir</a></li>
<li><a href="../fr477752/index.html">Backend United # 5: Shawarma - Microservices, syst√®mes distribu√©s et Kafka</a></li>
<li><a href="../fr477754/index.html">Comparez micro: bit avec Arduino. Et comment obtenir gratuitement micro: bit si vous n'√™tes pas √©tudiant en anglais?</a></li>
<li><a href="../fr477756/index.html">Comment nous avons √©pous√© deux syst√®mes CRM bancaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>