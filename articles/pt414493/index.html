<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✨ 👩🏻‍🌾 🎚️ Como escrever um contrato inteligente para a ICO em 5 minutos ☝🏼 📱 🎅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! Neste artigo, mostrarei como iniciar um contrato inteligente de coleta de dinheiro para sua ICO no Ethereum em 5 minutos e vários comando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever um contrato inteligente para a ICO em 5 minutos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414493/"><img src="https://habrastorage.org/webt/rv/6d/_c/rv6d_cyxk3ix-su6le9q4lyqntc.png"><br><br>  Olá pessoal!  Neste artigo, mostrarei como iniciar um contrato inteligente de coleta de dinheiro para sua ICO no Ethereum em 5 minutos e vários comandos no terminal.  Este ensaio potencialmente economizará dezenas de milhares de dólares, já que qualquer programador - e também não um programador - poderá lançar um contrato inteligente auditado e seguro (em vez de pagar US $ 15.000 a US $ 75.000 pelo desenvolvimento).  Em resumo, você pode enviar dinheiro para este contrato inteligente e receber tokens ERC20 por ele.  Pode-se dizer que este artigo é uma coleção de toda a experiência adquirida ao lançar uma OIC para o meu projeto. <br><br>  Na Internet, esses já estão cheios de artigos sobre contratos inteligentes, mas assim que você começa a escrever um, você se depara com o fato de que as informações são repetidas em todos os lugares e simplesmente não há tutoriais sobre como enganar seu ERC20, ou eles já estão desatualizados.  A propósito, para que este artigo permaneça relevante, tentarei indicar possíveis locais onde ele pode se tornar obsoleto (e como corrigi-lo).  Vamos lá! <br><a name="habracut"></a><br><h2>  Solidez </h2><br>  Esse é o nome do idioma principal que a equipe de kefir desenvolveu para lançar contratos inteligentes.  Se você é um programador, basta examinar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação da linguagem</a> - é indecentemente simples.  A propósito, eles simplificaram o processo, tornando mais difícil cometer um erro ao escrever um contrato inteligente.  Portanto, <b>absolutamente qualquer</b> programador, pelo menos no nível júnior, será capaz de descobrir isso.  <b>Não há absolutamente nenhum</b> sentido em pagar grandes quantias de dinheiro a desenvolvedores que conhecem solidez - será uma ordem de magnitude mais barata treinar um desenvolvedor existente. <br><br><h2>  Contratos inteligentes </h2><br>  ... e tudo que você precisa saber sobre eles.  Pule esta seção se você não for um programador.  Um contrato inteligente é um pedaço de código.  Em princípio, esta é uma classe de solidez (OOP, sim), que possui dois tipos de funções: mudança de estado e não mudança de estado.  Bem, para executar funções em um contrato inteligente apenas enviando kefir, é necessário marcar esta função como <code>payable</code> . <br><br>  State é um data warehouse, blockchain, EPT.  Os contratos podem alterar a blockchain (estado, armazenamento) - mas para alterar a blockchain você precisa pagar kefir aos mineradores.  Como eles compartilharão o kefir não será analisado na estrutura deste artigo.  O pagamento aos mineradores pela execução do código de alteração de estado é chamado Gás.  Se alguém de fora jogar kefir para o endereço de um contrato inteligente com uma chamada para uma função marcada como <code>payable</code> mas não marcada <code>Constant</code> , <code>View</code> ou <code>Pure</code> , a quantidade necessária de kefir para pagamento aos mineiros será deduzida do valor enviado.  Normalmente, nos tokens do ERC20, essas são funções que fornecem o remetente de token para kefir ou transferem tokens de um detentor de token para outro. <br><br>  E se você marcar uma função no contrato com as palavras <code>Constant</code> ou <code>View</code> (elas significam a mesma coisa, elas permitem apenas a leitura do estado) ou <code>Pure</code> (a mesma coisa, você nem lê o estado), não precisará gastar kefir na execução dessa função!  Vou dizer ainda mais que essas funções não precisam ser chamadas pelas transações - afinal, qualquer cliente de iogurte pode teoricamente executá-lo em casa - e ninguém precisa mais saber sobre isso (afinal, nada está escrito no blockchain). <br><br>  E há duas coisas importantes na solidez: herança múltipla e modificadores de função.  Você também precisa saber sobre eles. <br><br>  O primeiro - contratos justos podem ser herdados simultaneamente de várias classes, como <code>TimedCrowdsale</code> , <code>CappedCrowdsale</code> , <code>MintedCrowdsale</code> , <code>Ownable</code> - enquanto as funções dos construtores também são lançadas uma após a outra - mas vou explicar isso mais tarde, como exemplo. <br><br>  A segunda é a capacidade de criar funções que serão inseridas em outras funções.  É como um encapsulamento simples, apenas um pouco mais flexível - é literalmente <b>um modelo de</b> função.  Ao criar um modificador, você escreve o caractere especial <code>_</code> onde quer dizer o código de uma função usando esse modificador.  Ou seja, modificadores não são apenas funcionalidades encapsuladas que retornam um valor;  esse é um modelo de função quando o código de um modificador é literalmente inserido em uma função usando esse modificador. <br><br>  Vamos seguir praticando. <br><br><h2>  Ambiente de cozinha </h2><br>  Se você não souber o que é o Terminal, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo aqui</a> .  Se você estiver no Windows, configure um terminal via WLS.  Se você já está familiarizado com o Terminal, vamos continuar.  Além disso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coloque-se</a> imediatamente Node.js - será necessário para as próximas etapas.  É melhor instalar o LTS, mas, de fato, não faz diferença qual das versões modernas do nó instalar. <br><br>  A primeira coisa que instalamos e iniciamos imediatamente o processo de sincronização do bloco é <code>geth</code> .  Em resumo, este é um utilitário escrito em Go que nos permitirá executar o nó ether no computador local e conectar-se às redes reais e de teste.  Você pode instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">via instaladores</a> , mas eu recomendo que você <code>geth</code> imediatamente no Terminal, conforme descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Você pode verificar se seus padrões <code>geth</code> estão <code>geth</code> executando o comando no Terminal: <br><br><pre> <code class="bash hljs">geth version</code> </pre> <br>  Se você cuspir a versão geth - tudo está em aberto, continue o tutorial.  Se não - ruim, correto;  parece que você precisará fazer amor com o Terminal e o sistema operacional - mas não é a primeira vez que você descobre isso.  Como instalar o geth, execute o comando no Terminal: <br><br><pre> <code class="bash hljs">geth --testnet console</code> </pre> <br>  Isso iniciará o processo de sincronização do seu nó com o servidor de teste, cujos blocos podem ser visualizados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Você pode verificar se sincronizou com a rede no console <code>geth</code> : <br><br><pre> <code class="bash hljs">eth.blockNumber <span class="hljs-comment"><span class="hljs-comment">#  0 —     eth.syncing #     false,    </span></span></code> </pre> <br>  O processo de sincronização levou de 1 a 4 horas - quando como.  Além disso, além da sincronização de blocos, você também precisará aguardar a sincronização de estado - geralmente é mais longa que a sincronização de blocos.  Você também pode usar <code>geth</code> com o sinalizador <code>--light</code> -, a sincronização dura de alguns segundos a um minuto e ainda é possível implantar contratos. <br><br>  Ok, instalamos o primeiro utilitário - coloque o próximo.  Precisamos colocar um análogo de <code>geth</code> , apenas uma simulação de blockchain muito local - <code>testrpc</code> .  Sim, temos <b>3 blockchains</b> : <br><br><ul><li>  <code>testrpc</code> - simulação local de blockchain;  rápido, mas falso e armazenado apenas em sua máquina </li><li>  <code>geth --testnet</code> já é um blockchain real, mas você não perde dinheiro onde pode obter kefir e testar todos os <code>geth --testnet</code> gratuitamente </li><li>  <code>geth</code> - mainnet, principal, blockchain real, kefir real;  tudo de uma maneira adulta, os erros aqui são as perdas de kefir real </li></ul><br>  Dessa forma, iniciaremos o contrato de teste com o <code>testrpc</code> , em seguida instalá-lo no <code>geth --testnet</code> e, em seguida, fazer o download diretamente no <code>geth</code> . <br><br>  <code>testrpc</code> executando o seguinte comando: <br><br><pre> <code class="bash hljs">npm install -g ethereumjs-testrpc</code> </pre> <br>  Bem, ou sobe imediatamente com uma trufa, já que agora o <code>testrpc</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sob a asa da trufa</a> e é chamado <code>ganache-cli</code> .  Embora o diabo saiba, tudo funcionou <code>testrpc</code> com o <code>testrpc</code> baunilha.  E se funcionar, não toque, como fui ensinado na academia intergaláctica.  Você também pode executá-lo para verificar a instalação registrando <code>truffle</code> no console, mas o blockchain de teste já está sincronizado conosco - não vamos incomodar. <br><br>  Bem, descobri as cadeias?  Agora existem nós e o teste está sincronizado?  Colocamos um utilitário conveniente para trabalhar com contratos inteligentes no kefir - <code>truffle</code> , com o seguinte comando: <br><br><pre> <code class="bash hljs">npm install -g truffle truffle version <span class="hljs-comment"><span class="hljs-comment">#  ,  ,  </span></span></code> </pre> <br>  O Truffle é uma ferramenta que permite manter contratos inteligentes em arquivos diferentes, importar outros arquivos e também compilar seu código de contrato inteligente em um bytecode grande (ilegível por uma pessoa); ele encontra automaticamente o <code>geth</code> execução local (teste e teste real). ) ou <code>testrpc</code> , implante seu contrato inteligente nessa rede.  Além disso, verifica se há erros no código do contrato inteligente e as transações concluídas recentemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">também ajudam a depurar</a> .  Masthead, em suma. <br><br>  Nesse estágio, você deve ter instalado: <code>testrpc</code> , <code>geth</code> , <code>truffle</code> - se algo estiver faltando ou a versão não for enviada ao console mediante solicitação, corrija-o;  caso contrário, você não terá sucesso. <br><br><blockquote>  Além disso, joguei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">script</a> simples do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bash</a> que instalará tudo para você.  Chamado assim: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(curl -s https://raw.githubusercontent.com/backmeupplz/eth-installer/master/install.sh)</code> </pre> <br>  - mas eu nunca testei ainda, então não tenho certeza do seu desempenho.  No entanto, ficarei feliz em receber solicitações. </blockquote><br><h2>  Contrato Figash </h2><br>  Tudo já foi inventado e escrito para você - isso é bom.  Um pouco de estamenha será o mesmo - mas tentarei minimizá-lo para você.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usaremos contratos ERC20 já prontos do OpenZeppelin</a> - esse é agora o padrão do setor, eles passaram na auditoria e, de fato, todos usam seu código.  Muito obrigado por sua contribuição ao código aberto. <br><br>  Faça do <code>cd</code> uma pasta segura e depois escreva: <br><br><pre> <code class="bash hljs">mkdir contract &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> contract</code> </pre> <br>  Nesta pasta, vamos trabalhar.  Crie um esboço aqui para o nosso contrato inteligente: <br><br><pre> <code class="bash hljs">truffle init</code> </pre> <br>  Tropeçar, claramente.  Agora temos duas pastas muito importantes nas quais escalaremos: <code>contracts</code> e <code>migrations</code> .  O primeiro é o código para nossos contratos, o segundo é o código para as trufas saberem o que fazer ao implantar contratos na blockchain. <br><br>  Em seguida, precisamos pegar o código atual do contrato inteligente a partir da NPM e, de fato, iniciar o próprio projeto: <br><br><pre> <code class="bash hljs">npm init -y <span class="hljs-comment"><span class="hljs-comment">#     ( -y) npm install -E openzeppelin-solidity #       ( -E)</span></span></code> </pre> <br>  Bem, o código de contratos inteligentes do OpenZeppelin está no nosso bolso na pasta <code>node_modules/openzeppelin-solidity/contracts</code> .  Agora vamos para a pasta principal dos <code>contracts</code> , <code>MyToken.sol</code> todos os arquivos e adicionamos os arquivos <code>MyToken.sol</code> e <code>MyCrowdsale.sol</code> - naturalmente, você <code>MyCrowdsale.sol</code> seus contratos de maneira diferente.  O primeiro será um contrato para o nosso Token ERC20 e o segundo será um contrato da nossa OIC, que aceitará o kefir e distribuirá o <code>MyToken</code> pessoas.  Este artigo pode estar desatualizado, mas você sempre pode ver como o OpenZeppelin sugere que você crie contratos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em seu repositório</a> .  É assim que o <code>MyToken.sol</code> se parecerá <code>MyToken.sol</code> : <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; // Main token smart contract contract MyToken is MintableToken { string public constant name = "My Token"; string public constant symbol = "MTKN"; uint8 public constant decimals = 18; }</span></span></code> </pre> <br>  Bom - você tem um contrato inteligente com seu próprio token (basta alterar os nomes nas constantes)!  Você pode ver que <code>MintableToken</code> herança existe no <code>MintableToken</code> - mas tudo é o mais simples possível.  É um token que pode ser emitido (do inglês “Mint” - para mint), e somente o proprietário tem o direito de emiti-lo, pois o <code>MintableToken</code> também herda do <code>Ownable</code> .  Além disso, o <code>MintableToken</code> também herda das classes de tokens do ERC20 escritas pelo OpenZeppelin, nas quais a interface do ERC20 é implementada: <br><br><pre> <code class="javascript hljs">contract ERC20Basic { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">totalSupply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address to, uint256 value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bool</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address indexed from, address indexed to, uint256 value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  Sim, aqui você tem toda a interface do ERC20.  Isso é difícil?  Eu acho que não.  Ele oferece a oportunidade de verificar quantos tokens foram emitidos, verificar o saldo do endereço e transferir tokens para outro endereço, divulgando um evento de transferência para clientes de kefir leve na rede.  E tudo isso você ganha de graça no <code>MyToken.sol</code> graças ao trabalho do OpenZeppelin - eles são ótimos. <br><br>  E agora vamos para a parte principal da nossa OIC - precisamos aceitar o kefir e distribuir o <code>MyToken</code> !  É assim que o seu <code>MyCrowdsale.sol</code> será: <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; contract MyCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale { constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _cap, MintableToken _token, uint256 _goal ) public Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) RefundableCrowdsale(_goal) { //   ,  ,    // ,     require(_goal &lt;= _cap); } }</span></span></code> </pre><br>  So-so-so-so, o que há conosco?  Meninos, contratos inteligentes?  Nossa venda pública de tokens herda três das propriedades mais populares: possui um limite máximo, que não pode mais ser coletado;  tampa macia, não coletando quais ésteres são devolvidos;  horário de início e término da venda do token.  De fato, o que mais é necessário para a felicidade? <br><br>  Programadores, observe como os construtores de várias classes de herança são organizados em uma linha e obtém argumentos do construtor principal de <code>MyCrowdsale</code> .  Além disso, verificamos que a hardkey é maior que a softkey - Ales Gut!  Além disso, não se <code>MyCrowdsale</code> parâmetros <code>MyCrowdsale</code> no construtor <code>MyCrowdsale</code> - nós os transmitiremos no estágio de implantação do contrato na trufa. <br><br>  Isso é tudo - você tem contratos prontos de seu próprio token ERC20 e até mesmo um contrato inteligente da OIC, configurado de acordo com o seu desejo e distribuindo seus tokens para kefir.  Além disso, é suportado por todas as carteiras ERC20 - um erro!  Vamos passar para testes manuais e implantação. <br><br><h2>  Migrações </h2><br>  Como eu disse anteriormente, testaremos sequencialmente em três redes blockchain, mas o processo de teste com canetas será sempre o mesmo.  Vamos começar com <code>testrpc</code> , depois seguir para <code>geth --testnet</code> e continuar com <code>geth</code> .  Sou faróis, acabamos de escrever o código, vamos tentar compilá-lo.  Na pasta do projeto, escreva: <br><br><pre> <code class="bash hljs">truffle compile</code> </pre> <br>  Se tudo for compilado sem problemas, você verá a <code>build</code> , que conterá o krakozyab da trufa para que possa incorporar o bytecode de seus contratos inteligentes na blockchain.  Antes de implantar contratos inteligentes, precisamos dizer à trufa o que fazer.  A implantação de trufas de contratos inteligentes é chamada migração - bem, vamos nos ater a essa terminologia.  Vá para <code>migrations/1_initial_migration.js</code> e altere-o da seguinte maneira: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyToken.sol"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crowdsale = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyCrowdsale.sol"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deployer, network, accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openingTime = <span class="hljs-number"><span class="hljs-number">1514764800</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 15  2018 const closingTime = 1561939200; // 1  2019 const rate = new web3.BigNumber(1); // 1   1  const wallet = '0x281055afc982d96fab65b3a49cac8b878184cb16'; // - const cap = 200 * 1000000; //  const goal = 100 * 1000000; //  return deployer .then(() =&gt; { return deployer.deploy(token); }) .then(() =&gt; { return deployer.deploy( crowdsale, openingTime, closingTime, rate, wallet, cap, token.address, goal ); }) .then(() =&gt; { // Crowdsale    var tokenContract = web3.eth.contract(token.abi).at(token.address); web3.eth.defaultAccount = web3.eth.accounts[0]; tokenContract.transferOwnership(crowdsale.address); }); };</span></span></code> </pre> <br>  Este é o mesmo arquivo que será usado pela trufa para implantar contratos.  Então, o que estamos fazendo aqui?  Primeiro, solicitamos o <code>MyToken</code> e o <code>MyToken</code> compilados.  Depois, definimos as constantes com todos os argumentos da nossa OIC - definimos os horários de início e término;  quantos tokens as pessoas receberão por 1 vey de kefir (0,000000000000000001 eth = 1 wei; definir <code>decimals</code> indica quantos pedidos wei são necessários para obter 1 de seus tokens recém-criados);  carteira, de onde virá o kefir obtido com a venda;  tampa dura e tampa macia.  Observe que o <code>openingTime</code> sempre deve ser posterior ao horário do bloco atual na blockchain - caso contrário, seu contrato inteligente não será bloqueado devido à verificação da condição no <code>TimedCrowdsale</code> .  Eu entrei nesse rake e transações com falha não podem ser debitadas.  Mude essas constantes como desejar. <br><br>  O próximo passo é precisamente a implantação de contratos inteligentes.  Nada de interessante aqui: temos um objeto <code>deployer</code> que implementa artefatos de contrato inteligentes e passa argumentos para lá.  Observe que o MyToken é <code>MyToken</code> primeiro e somente depois o <code>MyCrowdsale</code> - e o endereço do primeiro é passado no segundo como argumento. <br><br>  Então, o mais interessante é sobre o que eles não escrevem na documentação ou nos livros.  Quando você cria um <code>MyToken</code> partir de uma carteira, essa carteira se torna o proprietário do <code>MyToken</code> na superclasse <code>Ownable</code> - o mesmo acontece com o <code>MyCrowdsale</code> .  Se você se aprofundar no <code>MintableToken</code> , poderá ver que apenas o <code>Owner</code> pode cunhar moedas!  E quem é o proprietário do <code>MyToken</code> ?  É isso mesmo: o endereço que o aborreceu.  E quem enviará pedidos de cunhagem de moedas?  Correto: contrato inteligente <code>MyCrowdsale</code> .  Deixe-me lembrá-lo de que o endereço que criou o <code>MyToken</code> e o <code>MyCrowdsale</code> são dois endereços diferentes. <br><br>  Portanto, estamos adicionando a terceira etapa de implantação não-ortodoxa, em que o endereço que desafiou os contratos ( <code>web3.eth.accounts[0]</code> ) chama a função <code>transferOwnership</code> no contrato <code>MyToken</code> , <code>MyToken</code> que o <code>MyCrowdsale</code> dono do <code>MyToken</code> e possa cunhar moedas.  E o <code>MyCrowdsale</code> ainda está sob propriedade de <code>web3.eth.accounts[0]</code> - então tudo está incluído. <br><br><blockquote>  Observação sobre <code>web3.eth.accounts[0]</code> : ao implantar um contrato inteligente, verifique se geth ou testrpc possui a carteira correta em <code>web3.eth.accounts[0]</code> - não perca a chave privada, embora isso não o prejudique, mas de repente o proprietário precisará fazer algo mais tarde, mas a chave não está mais lá? </blockquote><blockquote>  No <code>testrpc</code> , como regra, as contas são criadas imediatamente na inicialização e são desbloqueadas imediatamente;  no entanto, em um blockchain de teste e de ar real, vale a pena criar uma conta por meio do <code>personal.newAccount()</code> - reabasteça esse endereço via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faucet</a> no blockchain de teste ou kefir real no blockchain real.  Não perca sua senha e chaves privadas. </blockquote><blockquote>  Além disso, você pode adicionar uma carteira existente às suas contas chamando <code>web3.personal.importRawKey('pvt_key', 'password')</code> , mas para isso é necessário chamar <code>geth</code> com o parâmetro adicional <code>--rpcapi="db,eth,net,web3,personal,web3"</code> .  Eu acho que você vai descobrir. </blockquote><br><h2>  Teste e implantação </h2><br>  Sim, os contratos estão prontos, as migrações são escritas, resta apenas implantar e verificar.  Ambos, <code>geth</code> (test e real) e <code>testrpc</code> gerenciados da mesma maneira no <code>truffle console</code> - portanto, descreverei o método de verificação do <code>testrpc</code> e <code>testrpc</code> como habilitar o <code>geth</code> after.  E assim, lançamos o blockchain de kefir local de teste: <br><br><pre> <code class="bash hljs">testrpc</code> </pre> <br>  Hum ... isso é tudo.  Você simula o blockchain de kefir localmente. <br><br><blockquote>  E para implantar no blockchain ether de teste, em vez deste comando, você obterá <code>geth --testnet --rpc</code> .  E para implantar no verdadeiro blockchain do éter, você simplesmente <code>geth --rpc</code> .  O sinalizador <code>--rpc</code> necessário para que a trufa possa se conectar.  As etapas de implantação e teste a seguir são mais ou menos as mesmas para todos os três tipos de blockchain.  A única coisa é que depois de executar o teste ou o blockchain real via <code>geth</code> , ele começará a sincronizar os blocos - e isso pode levar de quatro a cinco horas em uma boa conexão com a Internet.  Uma observação sobre isso estava no começo do artigo.  Antes de implantar contratos inteligentes, recomendo aguardar a sincronização completa.  Além disso, o blockchain pesa na região de 60 a 100 gigabytes, portanto, prepare o espaço em disco para isso. </blockquote><blockquote>  Além disso, verifique também se <code>web3.eth.accounts[0]</code> desbloqueado.  Geralmente, você pode registrar o <code>testrpc</code> no console, que é aberto imediatamente, ou em uma janela Terminal separada no console, que é aberta via <code>geth console</code> : <code>eth.unlockAccount(eth.accounts[0], ",    ", 24*3600)</code> - isso desbloqueará sua conta, o que deve criar um contrato inteligente </blockquote><br>  Agora abra uma nova janela do Terminal (não fechamos o <code>testrpc</code> - deve funcionar) e escreva-o na pasta do projeto: <br><br><pre> <code class="bash hljs">truffle migrate --reset</code> </pre> <br>  Esse comando mágico compila um contrato inteligente (ou seja, você não precisa escrever uma <code>truffle compile</code> todas as vezes) e o implementa no micro servidor blockchain encontrado localmente aberto.  Vale ressaltar que, se <code>testrpc</code> fizer isso instantaneamente, o teste e as cadeias reais incluirão a transação nos próximos blocos por muito mais tempo.  Depois disso, você deve cuspir algo assim no console: <br><br><pre> <code class="bash hljs">Using network <span class="hljs-string"><span class="hljs-string">'development'</span></span>. Running migration: 1_initial_migration.js Running step... Replacing MyToken... ... 0x86a7090b0a279f8befc95b38fa8bee6918df30928dda0a3c48416454e2082b65 MyToken: 0x2dc35f255e56f06bd2935f5a49a0033548d85477 Replacing MyCrowdsale... ... 0xf0aab5d550f363478ac426dc2aff570302a576282c6c2c4e91205a7a3dea5d72 MyCrowdsale: 0xaac611907f12d5ebe89648d6459c1c81eca78151 ... 0x459303aa0b79be2dc2c8041dd48493f2d0e109fac19588f50c0ac664f34c7e30 Saving artifacts...</code> </pre> <br>  Acho que você já percebeu que o console forneceu os endereços dos contratos inteligentes <code>MyToken</code> e <code>MyCrowdsale</code> .  Isso é tudo!  O contrato inteligente está incorporado na blockchain cujo microsservidor você abriu.  Resta apenas verificar se os tokens são realmente distribuídos aos usuários que enviam kefir ao contrato inteligente <code>MyCrowdsale</code> .  Escrevemos o seguinte no Terminal para entrar no console de trufas: <br><br><pre> <code class="bash hljs">truffle console</code> </pre> <br>  Escrevemos o seguinte na trufa agora (sem comentários): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - t="0x2dc35f255e56f06bd2935f5a49a0033548d85477" //     MyToken ="0xaac611907f12d5ebe89648d6459c1c81eca78151" //     MyCrowdsale //   - token=MyToken.at(t) crowdsale=MyCrowdsale.at(c) //       account=web3.eth.accounts[0] // ,      token.balanceOf(account) //   0 //    - web3.eth.sendTransaction({from: account, to:c, value: web3.toWei(0.1, 'ether'), gas: 900000})</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de, </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você pode verificar imediatamente o saldo de nossa carteira novamente, mas no caso de teste e blockchain real, é necessário aguardar até que nossa transação seja incluída no bloco - geralmente quando isso acontece, a trufa fornece o número da transação. Você já esperou? Verifique novamente nosso saldo em </font></font><code>MyToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      token.balanceOf(account) //    </span></span></code> </pre> <br>  Isso é tudo!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro a massa sobre o seu contrato </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, então </font></font><code>geth --testnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em seguida, deployte on </font></font><code>geth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Então você lançou seu próprio ICO! E você não precisou gastar dezenas de kilobaks para auditoria e lançamento. Estragar tudo o que os caras do OpenZeppelin nos forneceram é realmente muito difícil. E quando você o usa </font></font><code>truffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- é assim que o desenvolvimento solidário geralmente se transforma em um conto de fadas. Bem, exceto nos casos em que as transações são revertidas durante a execução de um contrato inteligente - estréia no inferno. Mas a depuração de contratos inteligentes é realmente digna de um artigo separado.</font></font><br><br><h2>  Conclusão </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muito obrigado pela leitura até o final deste artigo! Se eu consegui economizar tempo ou dinheiro, ou se você aprendeu algo novo com este artigo, ficarei muito feliz com isso. Também ficaria muito grato se você compartilhar este artigo com seus amigos ou conhecidos que desejam realizar uma ICO - economize US $ 75.000 para sub-programadores que sugam dinheiro do mercado de criptografia como parasitas, copiando e colando as mesmas 25 linhas de código . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boa sorte no desenvolvimento de contratos inteligentes! Ainda tem dúvidas? Peço-lhe nos comentários. Ficarei feliz em responder a tudo e tentar ajudar com problemas.</font></font><br><br><h2>  Bônus </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas e se você quiser alterar a lógica pela qual o preço de compra dos tokens é considerado? </font><font style="vertical-align: inherit;">Claro, você pode alterá-lo corretamente </font></font><code>rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou usar uma das classes de contratos do OpenZeppelin, mas e se você quiser algo ainda mais pervertido? </font><font style="vertical-align: inherit;">Em um contrato inteligente, você pode substituir a função da </font></font><code>getTokenAmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte maneira:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getTokenAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256 _weiAmount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.timestamp &lt; <span class="hljs-number"><span class="hljs-number">1533081600</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// August 1st, 2018 rate = rate * 4; } else if (block.timestamp &lt; 1546300800) { // January 1st, 2019 rate = rate * 2; } return _weiAmount.mul(rate); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, isso pode tornar o preço do token dependente do momento da compra - quanto mais longe na floresta, mais caros os tokens. </font><font style="vertical-align: inherit;">Não tenha medo de experimentar e reescrever alguns dos recursos de contratos inteligentes - é divertido!</font></font><br><br><img src="https://habrastorage.org/webt/3a/mp/lk/3amplkx2fhpeplqauietmgshkc8.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414493/">https://habr.com/ru/post/pt414493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414481/index.html">Quiz do PHP de sexta-feira: algumas aventuras do programador Brad, uma sequência estranha e prêmios</a></li>
<li><a href="../pt414483/index.html">Digite SQL Seguro no Kotlin</a></li>
<li><a href="../pt414485/index.html">GNMT, falha épica ou sutilezas da tradução automática</a></li>
<li><a href="../pt414487/index.html">Um raro representante do tipo de força bruta: a história de um ataque</a></li>
<li><a href="../pt414489/index.html">EUA planejam tratar seriamente da questão de detritos espaciais</a></li>
<li><a href="../pt414495/index.html">toString: Ótimo e terrível</a></li>
<li><a href="../pt414497/index.html">API da interface do usuário do Consulo da ideia ao protótipo</a></li>
<li><a href="../pt414499/index.html">Relatório do Clube de Roma de 2018, capítulo 1.1.3: “Um mundo vazio versus uma paz total”</a></li>
<li><a href="../pt414501/index.html">Relatório do Clube de Roma de 2018, capítulo 3.11: “Reformas do setor financeiro”</a></li>
<li><a href="../pt414503/index.html">Intel NUC Hades Canyon com gráficos AMD Vega - VR ou não VR?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>