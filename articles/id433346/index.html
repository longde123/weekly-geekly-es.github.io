<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 📱 🎠 Beralih dari Redshift ke ClickHouse 💉 🤱🏾 ⏬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk waktu yang lama, iFunny menggunakan Redshift sebagai database untuk peristiwa yang terjadi di layanan backend dan aplikasi mobile. Itu dipilih k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beralih dari Redshift ke ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/433346/"><img src="https://habrastorage.org/webt/s8/xo/0d/s8xo0dnodxojhff6jufnruyg660.jpeg"><br><br>  Untuk waktu yang lama, iFunny menggunakan Redshift sebagai database untuk peristiwa yang terjadi di layanan backend dan aplikasi mobile.  Itu dipilih karena pada saat implementasi, pada umumnya, tidak ada alternatif yang sebanding dalam biaya dan kenyamanan. <br><br>  Namun, semuanya berubah setelah rilis publik ClickHouse.  Kami mempelajarinya untuk waktu yang lama, membandingkan biaya, memperkirakan perkiraan arsitektur, dan akhirnya, musim panas ini kami memutuskan untuk melihat betapa bergunanya bagi kami.  Di artikel ini, Anda akan belajar tentang masalah yang Redshift bantu kami selesaikan, dan bagaimana kami memindahkan solusi ini ke ClickHouse. <br><a name="habracut"></a><br><h2>  Masalah </h2><br>  iFunny membutuhkan layanan yang mirip dengan Yandex.Metrica, tetapi khusus untuk konsumsi domestik.  Saya akan menjelaskan alasannya. <br><br>  Klien eksternal menulis acara.  Ini bisa berupa aplikasi seluler, situs web atau layanan backend internal.  Sangat sulit bagi klien-klien ini untuk menjelaskan bahwa layanan penerimaan acara saat ini tidak tersedia, "cobalah untuk mengirimkannya dalam 15 menit atau dalam satu jam".  Ada banyak pelanggan, mereka ingin mengirim acara setiap saat dan tidak bisa menunggu sama sekali. <br><br>  Berbeda dengan mereka, ada layanan internal dan pengguna yang cukup toleran dalam hal ini: mereka dapat bekerja dengan benar bahkan dengan layanan analisis yang tidak dapat diakses.  Dan sebagian besar metrik produk dan hasil tes A / B umumnya masuk akal untuk menonton hanya sekali sehari, atau mungkin bahkan lebih jarang.  Oleh karena itu, persyaratan membaca cukup rendah.  Dalam hal terjadi kecelakaan atau pembaruan, kita dapat membiarkan diri kita tidak dapat diakses atau tidak konsisten dalam membaca selama beberapa jam atau bahkan berhari-hari (dalam kasus yang terabaikan). <br><br>  Jika kita berbicara tentang angka, maka kita perlu mengambil sekitar lima miliar peristiwa (300 GB data terkompresi) per hari, sambil menyimpan data selama tiga bulan dalam bentuk "panas" yang tersedia untuk query SQL, dan dalam "dingin" satu selama dua tahun atau lebih, tetapi agar dalam beberapa hari kita bisa mengubahnya menjadi "panas". <br><br>  Pada dasarnya, data adalah kumpulan acara yang dipesan berdasarkan waktu.  Ada sekitar tiga ratus jenis acara, masing-masing memiliki set properti sendiri.  Masih ada beberapa data dari sumber pihak ketiga yang harus disinkronkan dengan database analitik: misalnya, kumpulan instalasi aplikasi dari MongoDB atau layanan AppsFlyer eksternal. <br><br>  Ternyata kita membutuhkan sekitar 40 TB disk untuk basis data, dan sekitar 250 TB untuk penyimpanan "dingin". <br><br><h2>  Solusi Redshift </h2><br><img src="https://habrastorage.org/webt/f0/nq/dl/f0nqdl7cvriq9ygc3jlhelfdlqi.png"><br><br>  Jadi, ada klien seluler dan layanan backend yang darinya Anda perlu menerima acara.  Layanan HTTP menerima data, melakukan validasi minimum, mengumpulkan peristiwa pada disk lokal ke dalam file yang dikelompokkan berdasarkan satu menit, segera mengompresnya dan mengirimkannya ke keranjang S3.  Ketersediaan layanan ini tergantung pada ketersediaan server dengan aplikasi dan AWS S3.  Aplikasi tidak menyimpan status, sehingga mudah diseimbangkan, diskalakan dan dipertukarkan.  S3 adalah layanan penyimpanan file yang relatif sederhana dengan reputasi dan ketersediaan yang baik, sehingga Anda dapat mengandalkannya. <br><br>  Selanjutnya, Anda harus mengirim data ke Redshift.  Semuanya cukup sederhana di sini: Redshift memiliki importir S3 bawaan, yang merupakan cara yang disarankan untuk memuat data.  Oleh karena itu, setiap 10 menit sekali, skrip dimulai yang menghubungkan ke Redshift dan memintanya mengunduh data menggunakan awalan <code>s3://events-bucket/main/year=2018/month=10/day=14/10_3*</code> <br><br>  Untuk memantau status tugas unduhan, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Airflow</a> : ini memungkinkan Anda mengulangi operasi jika terjadi kesalahan dan memiliki riwayat eksekusi yang jelas, yang penting untuk sejumlah besar tugas tersebut.  Dan jika ada masalah, Anda dapat mengulangi unduhan untuk beberapa interval waktu atau mengunduh data "dingin" dari S3 setahun yang lalu. <br><br>  Dalam Aliran Udara yang sama, dengan cara yang sama, sesuai dengan jadwal, skrip bekerja yang terhubung ke database dan melakukan unduhan berkala dari repositori eksternal, atau membuat agregasi acara dalam bentuk <code>INSERT INTO ... SELECT ...</code> <br><br>  Redshift memiliki jaminan ketersediaan yang lemah.  Sekali seminggu, hingga setengah jam (jendela waktu ditentukan dalam pengaturan) AWS dapat menghentikan cluster untuk memperbarui atau pekerjaan terjadwal lainnya.  Dalam hal terjadi kegagalan pada satu node, gugus juga menjadi tidak tersedia sampai host dipulihkan.  Ini biasanya memakan waktu sekitar 15 menit dan terjadi setiap enam bulan sekali.  Dalam sistem saat ini, ini bukan masalah, ini awalnya dirancang agar pangkalan tidak tersedia secara berkala. <br><br>  Di bawah Redshift, digunakan instance 4 ds2.8xlarge (36 CPU, 16 TB HDD), yang totalnya memberi kami ruang disk 64 TB. <br><br>  Poin terakhir adalah cadangan.  Jadwal cadangan dapat ditentukan dalam pengaturan cluster, dan berfungsi dengan baik. <br><br><h2>  Motivasi Transisi ClickHouse </h2><br>  Tentu saja, jika tidak ada masalah, tidak ada yang akan berpikir untuk bermigrasi ke ClickHouse.  Namun, mereka. <br><br>  Jika Anda melihat skema penyimpanan ClickHouse dengan mesin MergeTree dan Redshift, Anda dapat melihat bahwa ideologinya sangat mirip.  Kedua basis data adalah kolom, berfungsi baik dengan sejumlah besar kolom dan kompres data pada disk dengan sangat baik (dan di Redshift Anda dapat mengonfigurasi jenis kompresi untuk setiap kolom individu).  Bahkan data disimpan dengan cara yang sama: mereka diurutkan berdasarkan kunci primer, yang memungkinkan Anda untuk membaca hanya blok tertentu dan tidak menyimpan indeks individual dalam memori, dan ini penting ketika bekerja dengan sejumlah besar data. <br><br>  Perbedaan mendasar, seperti biasa, adalah dalam perinciannya. <br><br><h3>  Meja harian </h3><br>  Menyortir data pada disk dan menghapusnya di Redshift terjadi saat Anda melakukannya: <pre> <code class="xml hljs">VACUUM <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tablename</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre>  Dalam hal ini, proses vakum bekerja dengan semua data dalam tabel ini.  Jika Anda menyimpan data selama tiga bulan dalam satu tabel, proses ini membutuhkan waktu yang tidak senonoh, dan Anda perlu melakukannya setidaknya setiap hari, karena data lama dihapus dan yang baru ditambahkan.  Saya harus membuat tabel terpisah untuk setiap hari dan menggabungkannya melalui Tampilan, dan ini bukan hanya kesulitan dalam memutar dan mendukung Tampilan ini, tetapi juga memperlambat kueri.  Atas permintaan, menilai dengan menjelaskan, semua tabel dipindai.  Dan meskipun pemindaian satu tabel membutuhkan waktu kurang dari satu detik, dengan jumlah 90 buah ternyata setiap kueri membutuhkan waktu setidaknya satu menit.  Ini sangat tidak nyaman. <br><br><h3>  Duplikat </h3><br>  Masalah selanjutnya adalah duplikat.  Dengan satu atau lain cara, saat mengirimkan data melalui jaringan, ada dua opsi: kehilangan data atau menerima duplikat.  Kami tidak dapat kehilangan pesan, oleh karena itu, kami hanya berdamai dengan kenyataan bahwa sebagian kecil dari peristiwa akan digandakan.  Anda dapat menghapus duplikat per hari dengan membuat tabel baru, memasukkan data dari yang lama ke dalamnya, di mana menggunakan baris fungsi jendela dengan id duplikat dihapus, tabel lama dihapus dan yang baru diganti namanya.  Karena ada tampilan di atas tabel harian, perlu untuk tidak melupakannya dan menghapusnya saat mengganti nama tabel.  Dalam hal ini, perlu juga untuk memantau kunci, jika tidak, dalam kasus permintaan yang memblokir tampilan atau salah satu tabel, proses ini dapat diseret. <br><br><h3>  Pemantauan dan pemeliharaan </h3><br>  Tidak ada satu permintaan pun di Redshift yang membutuhkan waktu kurang dari beberapa detik.  Bahkan jika Anda hanya ingin menambahkan pengguna atau melihat daftar permintaan aktif, Anda harus menunggu beberapa puluh detik.  Tentu saja, Anda dapat mentolerir, dan untuk kelas database ini hal ini dapat diterima, tetapi pada akhirnya itu diterjemahkan ke dalam banyak waktu yang hilang. <br><br><h3>  Biaya </h3><br>  Menurut perhitungan kami, menggunakan ClickHouse pada contoh AWS dengan sumber daya yang persis sama persis dengan setengah harga.  Tentu saja, seharusnya begitu, karena menggunakan Redshift, Anda mendapatkan basis data siap pakai yang dapat Anda sambungkan dengan klien PostgreSQL apa pun setelah mengeklik beberapa tombol di konsol AWS, dan AWS akan melakukan sisanya untuk Anda.  Tetapi apakah itu sepadan?  Kami sudah memiliki infrastruktur, kami sepertinya dapat melakukan backup, pemantauan dan konfigurasi, dan kami melakukan ini untuk banyak layanan internal.  Mengapa tidak menangani dukungan ClickHouse? <br><br><h2>  Proses transisi </h2><br>  Pertama, kami mengangkat instalasi ClickHouse kecil dari satu mesin, di mana kami mulai secara berkala, menggunakan alat bawaan, mengunduh data dari S3.  Dengan demikian, kami dapat menguji asumsi kami tentang kecepatan dan kemampuan ClickHouse. <br><br>  Setelah beberapa minggu pengujian pada salinan kecil data, menjadi jelas bahwa untuk mengganti Redshift dengan Clickhouse, beberapa masalah harus diselesaikan: <br><br><ul><li>  pada jenis instance dan disk apa yang akan digunakan; </li><li>  menggunakan replikasi? </li><li>  cara menginstal, mengkonfigurasi dan menjalankan; </li><li>  bagaimana melakukan pemantauan; </li><li>  skema mana yang akan; </li><li>  cara mengirim data dari S3; </li><li>  Bagaimana cara menulis ulang semua permintaan dari SQL standar ke non-standar? </li></ul><br>  <b>Jenis instance dan disk</b> .  Dalam jumlah prosesor, disk dan memori, mereka memutuskan untuk membangun instalasi Redshift saat ini.  Ada beberapa opsi, termasuk instance i3 dengan disk NVMe lokal, tetapi memutuskan untuk berhenti di r5.4xlarge dan penyimpanan dalam bentuk 8T ST1 EBS untuk setiap instance.  Menurut perkiraan, ini seharusnya memberikan kinerja yang sebanding dengan Redshift dengan setengah biaya.  Pada saat yang sama, karena penggunaan disk EBS, kami mendapatkan cadangan dan pemulihan sederhana melalui snapshot disk, hampir seperti di Redshift. <br><br>  <b>Replikasi</b>  Karena kami mulai dari apa yang sudah ada di Redshift, kami memutuskan untuk tidak menggunakan replikasi.  Selain itu, ini tidak memaksa kita untuk segera mempelajari ZooKeeper, yang belum ada dalam infrastruktur, tetapi sangat bagus bahwa sekarang mungkin untuk melakukan replikasi sesuai permintaan. <br><br>  <b>Instalasi</b>  Ini adalah bagian yang paling mudah.  Peran yang cukup kecil untuk Ansible, yang akan menginstal paket RPM yang sudah jadi dan membuat konfigurasi yang sama pada setiap host. <br><br>  <b>Pemantauan</b>  Untuk memantau semua layanan, Prometheus digunakan bersama dengan Telegraf dan Grafana, oleh karena itu, mereka hanya menempatkan agen Telegraf di host dengan ClickHouse, mengumpulkan dashboard di Grafana, yang menunjukkan beban server saat ini dengan prosesor, memori, dan disk.  Melalui plugin ke Grafana, kami membawa ke dashboard ini permintaan aktif saat ini untuk cluster, status impor dari S3, dan hal-hal berguna lainnya.  Ternyata bahkan lebih baik dan lebih informatif (dan secara signifikan lebih cepat) daripada dashboard yang memberi konsol AWS. <br><br>  <b>Skema</b> .  Salah satu kesalahan utama kami di Redshift adalah memadamkan hanya bidang acara utama di kolom terpisah, dan menambahkan bidang yang jarang digunakan untuk menambahkan <br>  dalam satu properti kolom besar.  Di satu sisi, ini memberi kami fleksibilitas dalam mengubah bidang pada tahap awal, ketika tidak ada pemahaman penuh tentang peristiwa apa yang akan kami kumpulkan, dengan properti apa, apalagi, mereka berubah 5 kali sehari.  Dan di sisi lain, permintaan kolom properti yang besar membutuhkan waktu yang semakin lama.  Di ClickHouse, kami memutuskan untuk melakukan hal yang benar segera, jadi kami mengumpulkan semua kolom yang mungkin dan memasukkan jenis yang optimal untuk mereka.  Hasilnya adalah tabel dengan sekitar dua ratus kolom. <br><br>  Tugas selanjutnya adalah memilih mesin yang tepat untuk penyimpanan dan partisi. <br>  Mereka tidak berpikir tentang partisi lagi, tetapi melakukan hal yang sama seperti di Redshift - partisi untuk setiap hari, tetapi sekarang semua partisi adalah satu tabel, yang <br>  secara signifikan mempercepat permintaan dan menyederhanakan perawatan.  Mesin penyimpanan diambil oleh ReplacingMergeTree, karena memungkinkan Anda untuk menghapus duplikat dari partisi tertentu, cukup dengan melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MENGOPTIMALKAN ... FINAL</a> .  Selain itu, skema partisi harian memungkinkan, jika terjadi kesalahan atau kecelakaan, untuk bekerja hanya dengan data selama sehari, bukan sebulan, yang jauh lebih cepat. <br><br>  <b>Pengiriman data dari s3 ke ClickHouse</b> .  Ini adalah salah satu proses terpanjang.  Itu hanya tidak berhasil membuat pemuatan oleh alat ClickHouse bawaan, karena data pada S3 ada di JSON, setiap bidang perlu diekstrak dalam jsonpath sendiri, seperti yang kami lakukan di Redshift, dan kadang-kadang kami juga perlu menggunakan transformasi: misalnya, UUID pesan dari catatan standar dalam bentuk <code>DD96C92F-3F4D-44C6-BCD3-E25EB26389E9</code> dikonversi menjadi byte dan dimasukkan ke dalam tipe FixedString (16). <br><br>  Saya ingin memiliki layanan khusus yang mirip dengan yang kami miliki di Redshift sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah COPY</a> .  Mereka tidak menemukan sesuatu yang siap, jadi saya harus melakukannya.  Anda dapat menulis artikel terpisah tentang cara kerjanya, tetapi singkatnya, ini adalah layanan HTTP yang digunakan pada setiap host dengan ClickHouse.  Anda dapat merujuk ke salah satu dari mereka.  Parameter permintaan menentukan awalan S3 dari mana file diambil, daftar jsonpath untuk konversi dari JSON ke satu set kolom, serta satu set konversi untuk setiap kolom.  Server tempat permintaan itu mulai memindai file pada S3 dan mendistribusikan pekerjaan parsing ke host lain.  Pada saat yang sama, penting bagi kami bahwa baris yang tidak dapat diimpor, bersama dengan kesalahan, ditambahkan ke tabel ClickHouse yang terpisah.  Ini sangat membantu untuk menyelidiki masalah dan bug di layanan penerima acara dan klien yang menghasilkan acara ini.  Dengan penempatan importir langsung pada host basis data, kami menggunakan sumber daya tersebut, yang, pada umumnya, tidak digunakan, karena permintaan yang kompleks tidak berjalan sepanjang waktu.  Tentu saja, jika ada lebih banyak permintaan, Anda selalu dapat mengambil layanan importir ke host yang terpisah. <br><br>  Tidak ada masalah besar dengan mengimpor data dari sumber eksternal.  Dalam skrip yang ada, mereka hanya mengubah tujuan dari Redshift ke ClickHouse. <br><br>  Ada opsi untuk menghubungkan MongoDB dalam bentuk kamus, dan tidak melakukan salinan harian.  Sayangnya, itu tidak sesuai, karena kamus harus ditempatkan di memori, dan ukuran sebagian besar koleksi di MongoDB tidak memungkinkan ini.  Tetapi kamus juga bermanfaat bagi kami: menggunakannya sangat mudah untuk menghubungkan basis data GeoIP dari MaxMind dan digunakan dalam kueri.  Untuk ini kami menggunakan tata letak ip_trie dan file CSV yang disediakan oleh layanan.  Misalnya, konfigurasi kamus geoip_asn_blocks_ipv4 terlihat seperti ini: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dictionaries</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>geoip_asn_blocks_ipv4<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">path</span></span></span><span class="hljs-tag">&gt;</span></span>GeoLite2-ASN-Blocks-IPv4.csv<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">path</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">format</span></span></span><span class="hljs-tag">&gt;</span></span>CSVWithNames<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">format</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">source</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lifetime</span></span></span><span class="hljs-tag">&gt;</span></span>300<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lifetime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ip_trie</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">structure</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>prefix<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span>String<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>autonomous_system_number<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span>UInt32<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">null_value</span></span></span><span class="hljs-tag">&gt;</span></span>0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">null_value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>autonomous_system_organization<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span>String<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">null_value</span></span></span><span class="hljs-tag">&gt;</span></span>?<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">null_value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attribute</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">structure</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dictionaries</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Cukup dengan menempatkan konfigurasi ini di <code>/etc/clickhouse-server/geoip_asn_blocks_ipv4_dictionary.xml</code> , setelah itu Anda dapat membuat kueri ke kamus untuk mendapatkan nama penyedia berdasarkan alamat IP: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> dictGetString(<span class="hljs-string"><span class="hljs-string">'geoip_asn_blocks_ipv4'</span></span>, <span class="hljs-string"><span class="hljs-string">'autonomous_system_organization'</span></span>, tuple(IPv4StringToNum(<span class="hljs-string"><span class="hljs-string">'192.168.1.1'</span></span>)));</code> </pre><br>  <b>Ubah skema data</b> .  Seperti yang disebutkan di atas, kami memutuskan untuk tidak menggunakan replikasi, karena sekarang kami dapat menjadi tidak dapat diakses jika terjadi kecelakaan atau pekerjaan yang direncanakan, dan salinan data sudah pada s3 dan kami dapat mentransfernya ke ClickHouse dalam jumlah waktu yang wajar.  Jika tidak ada replikasi, maka mereka tidak memperluas ZooKeeper, dan tidak adanya ZooKeeper juga menyebabkan ketidakmampuan untuk menggunakan ekspresi ON CLUSTER dalam permintaan DDL.  Masalah ini diselesaikan oleh skrip python kecil yang menghubungkan ke setiap host ClickHouse (hanya ada delapan dari mereka sejauh ini) dan mengeksekusi query SQL yang ditentukan. <br><br>  <b>Dukungan SQL tidak lengkap di ClickHouse</b> .  Proses mentransfer permintaan dari sintaks Redshift ke sintaks ClickHouse berjalan paralel dengan pengembangan importir, dan itu terutama ditangani oleh tim analis.  Anehnya, tapi masalahnya bukan di GABUNG, tapi di fungsi jendela.  Untuk memahami bagaimana mereka dapat dilakukan melalui fungsi array dan lambda, perlu beberapa hari.  Adalah baik bahwa masalah ini sering diliput dalam laporan tentang ClickHouse, yang jumlahnya sangat banyak, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">events.yandex.ru/lib/talks/5420</a> .  Pada titik ini, data sudah ditulis sekaligus di dua tempat: baik di Redshift dan di ClickHouse baru, jadi ketika kami mentransfer permintaan, kami membandingkan hasilnya.  Itu bermasalah untuk membandingkan kecepatan, karena kami menghapus satu kolom besar properti, dan sebagian besar pertanyaan mulai bekerja hanya dengan kolom yang diperlukan, yang, tentu saja, memberikan peningkatan yang signifikan, tetapi pertanyaan di mana kolom properti tidak berpartisipasi, bekerja dengan cara yang sama, atau sedikit lebih cepat. <br><br>  Hasilnya, kami mendapat skema berikut: <br><br><img src="https://habrastorage.org/webt/tj/h8/ka/tjh8kagqccdbjgnswbmbm9wkloc.png"><br><br><h2>  Hasil </h2><br>  Pada intinya, kami mendapat manfaat berikut: <br><br><ul><li>  Satu meja, bukan 90 </li><li>  Permintaan layanan dieksekusi dalam milidetik </li><li>  Biaya telah berkurang setengahnya </li><li>  Penghapusan mudah acara duplikat </li></ul><br>  Ada juga kelemahan yang siap kami siapkan: <br><br><ul><li>  Jika terjadi kecelakaan, Anda harus memperbaiki sendiri kluster </li><li>  Perubahan skema sekarang perlu dilakukan pada setiap host secara terpisah </li><li>  Memperbarui ke versi baru harus melakukannya sendiri </li></ul><br>  Kami tidak dapat membandingkan kecepatan permintaan secara langsung, karena skema data telah berubah secara signifikan.  Banyak pertanyaan menjadi lebih cepat, hanya karena mereka membaca lebih sedikit data dari disk.  Dalam cara yang baik, perubahan seperti itu harus dilakukan kembali di Redshift, tetapi diputuskan untuk menggabungkannya dengan migrasi ke ClickHouse. <br><br>  Semua migrasi bersama dengan persiapan memakan waktu sekitar tiga bulan.  Dia berjalan dari awal Juli hingga akhir September dan menuntut partisipasi dua orang.  27 September, kami mematikan Redshift dan sejak itu kami hanya bekerja di ClickHouse.  Ternyata, sudah lebih dari dua bulan.  Istilah ini pendek, tetapi sejauh ini tidak pernah mengalami kehilangan data atau bug kritis, karena itu seluruh cluster akan bangun.  Di depan kita sedang menunggu pembaruan pada versi baru! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433346/">https://habr.com/ru/post/id433346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433336/index.html">Implementasi perpustakaan Babel</a></li>
<li><a href="../id433338/index.html">Ikhtisar Produsen Printer 3D Creality</a></li>
<li><a href="../id433340/index.html">Perangkat nirkabel Xiaomi di rumah pintar ioBroker</a></li>
<li><a href="../id433342/index.html">Prosesor Verilog sederhana lainnya</a></li>
<li><a href="../id433344/index.html">Dua keberhasilan ruang pribadi</a></li>
<li><a href="../id433348/index.html">Mengetik DSL dalam TypeScript dari JSX</a></li>
<li><a href="../id433350/index.html">Acara digital di Moskow dari 17 Desember hingga 23 Desember</a></li>
<li><a href="../id433352/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 343 (10 - 16 Desember 2018)</a></li>
<li><a href="../id433354/index.html">Berita dari dunia OpenStreetMap No. 438 (12/04/2018 - 12/10/2018)</a></li>
<li><a href="../id433356/index.html">Penyerang belajar untuk mem-bypass otentikasi dua faktor Yahoo Mail dan Gmail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>