<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📱 👨‍🚒 👨🏼‍🎓 使用TableGen的LLVM中的处理器体系结构描述 😡 🚼 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目前，LLVM已经成为非常流行的系统，许多人积极地使用它来创建各种编译器，分析器等。 关于该主题的大量有用材料已经写好，包括俄语，这是个好消息。 但是，在大多数情况下，文章中的主要偏见是在前端和中端LLVM上进行的。 当然，当描述LLVM操作的完整方案时，并不会绕过机器代码的生成，但是基本上这个主题...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用TableGen的LLVM中的处理器体系结构描述</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/">目前，LLVM已经成为非常流行的系统，许多人积极地使用它来创建各种编译器，分析器等。 关于该主题的大量有用材料已经写好，包括俄语，这是个好消息。 但是，在大多数情况下，文章中的主要偏见是在前端和中端LLVM上进行的。 当然，当描述LLVM操作的完整方案时，并不会绕过机器代码的生成，但是基本上这个主题是随意涉及的，尤其是在俄语出版物中。 同时，LLVM具有相当灵活和有趣的机制来描述处理器体系结构。 因此，本文将专门讨论LLVM的一部分实用程序TableGen。 <br><br> 编译器需要了解有关每个目标平台的体系结构的信息的原因非常明显。 自然，每个处理器模型都有自己的寄存器集，自己的机器指令等。 并且编译器需要具有关于它们的所有必要信息，以便能够生成有效和高效的机器代码。 编译器解决了各种平台特定的任务：分发寄存器等。 另外，LLVM后端还已经在机器IR上进行了优化，这更接近于实际指令或汇编程序指令本身。 在此类优化中，需要替换和转换指令；因此，有关它们的所有信息都应可用。 <br><a name="habracut"></a><br> 为了解决描述处理器体系结构的问题，LLVM采用了一种格式来确定编译器所需的处理器属性。 对于每种受支持的体系结构， <code>.td</code>包含特殊形式语言的描述。 使用LLVM附带的TableGen实用程序构建编译器时，它将转换为<code>.inc</code>文件。 实际上，生成的文件是C源代码，但是很可能具有单独的扩展名，以使可以轻松地区分和过滤这些自动生成的文件。  TableGen的官方文档在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> ，提供了所有必要的信息，还提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了对该语言</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正式描述</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">概述</a> 。 <br><br> 当然，这是一个非常广泛的主题，其中有许多您可以撰写个别文章的细节。 在本文中，即使没有概述所有功能，我们也只是考虑了处理器描述的基本要点。 <br><br><h2>  .td文件中的体系结构说明 </h2><br> 因此，TableGen中使用的形式化描述语言具有与普通编程语言类似的功能，并允许您以声明性样式描述架构的特征。 据我了解，该语言通常也称为TableGen。 即 在本文中，TableGen既使用形式语言本身的名称，又使用从中生成结果构件的实用程序。 <br><br> 现代处理器是非常复杂的系统，因此对它们的描述非常多就不足为奇了。 因此，要创建结构并简化<code>.td</code>文件的维护，可以使用C程序员常用的<code>#include</code>指令相互包含。 在此指令的帮助下，始终始终首先包含<code>Target.td</code>文件，其中包含与平台无关的接口，必须实施这些接口才能提供所有必需的TableGen信息。 该文件已经包含一个带有LLVM内部描述的<code>.td</code>文件，但是它本身主要包含基类，例如<code>Register</code> ， <code>Instruction</code> ， <code>Processor</code>等，您需要从这些基类继承以创建自己的编译器架构，基于LLVM。 从上一句话可以清楚地看出，TableGen具有所有程序员都熟悉的类的概念。 <br><br> 通常，TableGen仅具有两个基本实体： <b>类</b>和<b>定义</b> 。 <br><br><h3> 班级 </h3><br> 与所有面向对象的编程语言一样，TableGen类也是抽象的，但是它们是更简单的实体。 <br><br> 类可以具有参数和字段，并且它们也可以继承其他类。 <br> 例如，下面提供了一个基类。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br> 尖括号表示分配给类属性的输入参数。 从此示例中，您还可以注意到TableGen语言是静态类型的。  TableGen中存在的类型： <code>bit</code> （值为0和1的布尔型模拟）， <code>int</code> ， <code>string</code>和<code>code</code> （一段代码，这是一种类型，仅因为TableGen没有通常意义上的方法和函数，所以代码行用<code>[{ ... }]</code> ），位&lt;n&gt;，列表&lt;type&gt;（值使用方括号[...]设置，如Python和其他一些编程语言中一样）， <code>class type</code> ， <code>dag</code> 。 <br><br> 大多数类型应该都可以理解，但是如果有疑问，它们会在语言规范中进行详细说明，可从本文开头提供的链接中获得。 <br><br> 继承也通过与<code>:</code>相当熟悉的语法来描述<code>:</code> <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br> 在这种情况下，创建的类当然可以使用<code>let</code>关键字覆盖基类中指定的字段的值。 并且它可以添加自己的字段，类似于上一个示例中提供的描述，指示字段的类型。 <br><br><h3> 定义 </h3><br> 定义已经是具体的实体，您可以将它们与所有对象的熟悉对象进行比较。 定义是使用<code>def</code>关键字定义的，可以实现一个类，以与上述完全相同的方式重新定义基类的字段，并且也具有自己的字段。 <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3> 多类 </h3><br> 自然地，处理器中的大量指令具有相似的语义。 例如，可能存在一组三地址指令，其采用两种形式<code>“reg = reg op reg”</code>和<code>“reg = reg op imm”</code> 。 在一种情况下，从寄存器中获取值，结果也保存在寄存器中；在另一种情况下，第二个操作数是一个常量值（imm-立即数）。 <br><br> 手动列出所有组合非常繁琐；犯错的风险增加。 当然，可以通过编写简单的脚本自动生成它们，但这不是必需的，因为TableGen语言中存在诸如多类的概念。 <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br> 在多类内部，您需要使用<code>def</code>关键字描述所有可能的指令形式。 但这不是要生成的指令的完整形式。 同时，您可以重新定义它们中的字段，并执行常规定义中可能的所有事情。 要基于多类创建真实定义，您需要使用<code>defm</code>关键字。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br> 因此，实际上，对于通过<code>defm</code>给出的每个这样的定义，将构造几个定义，这些定义是主指令和多类中描述的所有可能形式的组合。 结果，在此示例中将生成以下指令： <code>ADD_rr</code> ， <code>ADD_ri</code> ， <code>SUB_rr</code> ， <code>SUB_ri</code> ， <code>MUL_rr</code> ， <code>MUL_ri</code> 。 <br><br> 多类不仅可以包含带有<code>def</code>定义，还可以包含嵌套的<code>defm</code> ，从而允许生成复杂形式的指令。 可以在官方文档中找到说明创建此类链的示例。 <br><br><h3> 子目标 </h3><br> 对于具有不同指令集变化的处理器，另一项基本和有用的事情是LLVM中对子目标的支持。  LLVM SPARC实现就是一个使用示例，该实现一次涵盖了SPARC微处理器体系结构的三个主要版本：版本8（V8，32位体系结构），版本9（V9，64位体系结构）和UltraSPARC体系结构。 架构之间的差异非常大，不同类型的寄存器数量不同，支持的字节顺序等。 在这种情况下，如果有多种配置，则值得为该体系结构实现<code>XXXSubtarget</code>类。 在描述中使用此类将产生新的命令行选项<code>-mcpu=</code>和<code>-mattr=</code> 。 <br><br> 除了<code>Subtarget</code>类本身之外， <code>Subtarget</code>类<code>Subtarget</code>很重要。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br> 在<code>Sparc.td</code>文件中，您可以找到<code>Sparc.td</code>的实现示例，该示例使您可以描述体系结构的每个子类型的一组指令的可用性。 <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br> 在这种情况下，无论如何， <code>Sparc.td</code>仍然定义<code>Proc</code>类，该类用于描述SPARC处理器的特定子类型，该子类型可能具有上述属性，包括不同的指令集。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  TableGen中的指令属性与LLVM后端代码之间的关系 </h2><br> 类和定义的属性允许您正确生成和设置体系结构功能，但是无法从LLVM后端源代码直接访问它们。 但是，有时您希望能够直接在编译器代码中获得某些平台特定的指令属性。 <br><br><h3>  TSFlags </h3><br> 为此， <code>Instruction</code>基类有一个特殊的<code>TSFlags</code>字段，大小为64位，由TableGen转换为MCInstrDesc类的C ++对象的字段，该字段基于从TableGen描述接收的数据生成。 您可以指定存储信息所需的任何位数。 例如，这可能是一些布尔值，以表明我们正在使用标量ALU。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br> 或者我们可以存储指令类型。 那么，我们当然需要不止一位。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br> 结果，可以从后端代码中的指令获取这些属性。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br> 如果属性更复杂，则可以将其与TableGen中描述的值进行比较，该值将添加到自动生成的枚举中。 <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3> 函数谓词 </h3><br> 同样，功能谓词可用于获取有关指令的必要信息。 在他们的帮助下，您可以告诉TableGen您需要生成一个函数，该函数将相应地在后端代码中可用。 下面介绍了可用于创建此类函数定义的基类。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br> 您可以在X86后端轻松找到用法示例。 因此，有一个自己的中间类，借助于它，已经创建了必要的功能定义。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br> 结果，可以在C ++代码中使用<code>isThreeOperandsLEA</code>方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br> 这里的TII是目标指令信息，可以使用<code>getInstrInfo()</code>方法从<code>MCSubtargetInfo</code>获取所需的体系结构。 <br><br><h2> 优化过程中的指令转换。 指令映射 </h2><br> 在编译的后期阶段执行大量优化期间，通常会出现将一种形式的全部或部分指令转换为另一种形式的指令的任务。 给定开始时描述的多类应用，我们可以拥有大量具有相似语义和属性的指令。 当然，在代码中，这些转换可以以大型<code>switch-case</code>结构的形式编写，对于每条指令，它们都会粉碎相应的转换。 部分地，这些巨大的构造可以借助宏来减少，这些宏将根据众所周知的规则形成指令的必要名称。 但是，这种方法仍然非常不便，由于所有指令名称都已明确列出，因此很难维护。 添加新指令很容易导致错误，因为 您必须记住将其添加到所有相关的转化中。 经过这种方法的折磨，LLVM创建了一种特殊的机制，可以有效地将一种形式的指令转换为另一种<code>Instruction Mapping</code> 。 <br><br> 这个想法非常简单，有必要描述可能的模型，以便直接在TableGen中转换指令。 因此，在LLVM TableGen中，有一个用于描述此类模型的基类。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br> 让我们看一下文档中给出的示例。 现在，可以在源代码中找到的示例更加简单，因为最终表中仅获得两列。 在后端代码中，您可以找到使用指令映射描述的将旧形式转换为新形式的指令，mmdsp中的dsp指令等。 实际上，到目前为止，这种机制还没有得到广泛使用，仅仅是因为大多数后端是在它出现之前就开始创建的，并且为了使其正常工作，您仍然需要为指令设置正确的属性，因此切换到它并不总是那么容易，您可能需要一些重构。 <br><br> 因此，例如。 假设我们有没有谓词的指令形式和谓词分别为真和假的指令。 我们借助多类和特殊类来描述它们，我们将它们用作过滤器。 没有参数和许多属性的简化描述可能是这样的。 <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">ADD</span></span>”&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">SUB</span></span>”&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">MUL</span></span>”&gt;; …</code> </pre> <br> 顺便说一下，在此示例中，还显示了如何使用<code>let … in</code>构造一次覆盖多个定义的属性。 结果，我们有许多指令存储其基本名称和属性，以唯一地描述其形式。 然后，您可以创建一个转换模型。 <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=”” let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br> 结果，将从该描述生成下表。 <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense =“” </th><th>  PredSense =“真” </th><th>  PredSense =“假” </th></tr><tr><td> 新增 </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td> 潜艇 </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td> 穆尔 </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  <code>.inc</code>文件中将生成一个函数 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br> 因此，它接受用于转换的指令代码和PredSense自动生成的枚举的值，该值在列中包含所有可能的值。 该功能的实现非常简单，因为 它返回我们感兴趣的指令所需的数组元素。 <br><br> 而且在后端代码中，只需编写生成的函数即可，而无需编写<code>switch-case</code>只需调用生成的函数即可，该函数将返回转换后指令的代码。 添加新指令的简单解决方案不会导致需要采取其他措施。 <br><br><h2> 自动生成的工件（ <code>.inc</code>文件） </h2><br>  TableGen描述与LLVM后端代码之间的所有交互都由生成的包含C代码的<code>.inc</code>文件确保。 为了获得完整的图片，让我们来看看它们到底是什么。 <br><br> 每次构建后，对于每种体系结构，构建目录中都会有几个<code>.inc</code>文件，每个文件都存储有关体系结构的单独信息。    <code>&lt;TargetName&gt;GenInstrInfo.inc</code> ,    , <code>&lt;TargetName&gt;GenRegisterInfo.inc</code> ,     ,           <code>&lt;TargetName&gt;GenAsmMatcher.inc</code>  <code>&lt;TargetName&gt;GenAsmWriter.inc</code>  .. <br><br>      ?      , ,    .           <code>&lt;TargetName&gt;GenInstrInfo.inc</code> . <br><br>     namespace     ,   ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, … ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来是描述指令属性的数组</font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下数组包含有关指令名称等的信息。</font><font style="vertical-align: inherit;">基本上，所有信息都存储在传输和数组中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有使用谓词描述的功能。</font><font style="vertical-align: inherit;">根据上一节中讨论的函数谓词定义，将生成以下函数。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是生成的文件和结构中有数据。</font><font style="vertical-align: inherit;">在上</font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇</font><font style="vertical-align: inherit;">文章中，</font><font style="vertical-align: inherit;">您可以找到后端代码中应使用的结构示例，以获取有关该体系结构的信息，在上一节中通过它得出了TTI。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果用于</font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述各种配置</font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将使用</font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有恒定值的数组</font><font style="vertical-align: inherit;">描述的属性创建一个枚举，</font><font style="vertical-align: inherit;">以指示CPU的特征和子类型，并且将生成一个函数来</font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理带有选项集的字符串</font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此外，该方法</font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在后端代码中的实现应对应于以下伪代码，其中必须使用此功能：</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管</font></font><code>.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件非常庞大并且包含巨大的数组，但是由于访问数组元素的时间是恒定的，因此这使我们能够优化信息的访问时间。</font><font style="vertical-align: inherit;">使用二进制搜索算法来实现按指令生成的搜索功能，以最大程度地减少操作时间。</font><font style="vertical-align: inherit;">因此以这种形式存储是非常合理的。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，多亏了LLVM中的TableGen，我们以单一格式获得了易读且易于支持的体系结构描述，其中包含用于从LLVM后端源代码进行交互和访问信息以进行优化和代码生成的各种机制。</font><font style="vertical-align: inherit;">同时，由于使用高效解决方案和数据结构的自动生成的代码，因此这种描述不会影响编译器的性能。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474460/">https://habr.com/ru/post/zh-CN474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474444/index.html">针对开发人员的另外5个大胆的培训项目（层，Squeosh，计算器，网站抓取工具，音乐播放器）</a></li>
<li><a href="../zh-CN474448/index.html">计算机世界中学生的大脑有什么能力</a></li>
<li><a href="../zh-CN474450/index.html">停止为DNS使用非常小的TTL</a></li>
<li><a href="../zh-CN474452/index.html">Haxe秋季状态报告</a></li>
<li><a href="../zh-CN474458/index.html">SQL中的累积总数</a></li>
<li><a href="../zh-CN474462/index.html">俄语语音版本1.0的巨大开放数据集</a></li>
<li><a href="../zh-CN474466/index.html">第一部暗黑破坏神的历史</a></li>
<li><a href="../zh-CN474470/index.html">对RDP服务的DDoS攻击：认识并克服。 Tucha的成功经验</a></li>
<li><a href="../zh-CN474472/index.html">移动应用程序的30点UX清单</a></li>
<li><a href="../zh-CN474474/index.html">服务器和Web应用程序负载测试的开放基准</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>