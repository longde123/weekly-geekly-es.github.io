<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö• üßöüèª üëáüèΩ Machine Learning para encontrar erros no c√≥digo: como eu estagiei na JetBrains Research üë©üèø‚Äçüî¨ ‚ô£Ô∏è üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, conversamos sobre como obter um est√°gio no Google. Al√©m do Google, nossos alunos experimentam JetBrains, Yandex, Acronis e outras empres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machine Learning para encontrar erros no c√≥digo: como eu estagiei na JetBrains Research</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/434368/">  Recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversamos</a> sobre como obter um est√°gio no Google.  Al√©m do Google, nossos alunos experimentam JetBrains, Yandex, Acronis e outras empresas. <br><br>  Neste artigo, compartilharei minha experi√™ncia de est√°gio na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JetBrains Research</a> , falarei sobre as tarefas que eles resolvem l√° e detalharei como o aprendizado de m√°quina pode procurar bugs no c√≥digo do programa. <br><br><img src="https://habrastorage.org/webt/gf/xa/bh/gfxabh9xemshdpmkrr48vind45a.jpeg"><br><a name="habracut"></a><br><h2>  Sobre mim </h2><br>  Meu nome √© Egor Bogomolov, sou aluno do quarto ano do curso de gradua√ß√£o em SSMA de S√£o Petersburgo em Matem√°tica Aplicada e Ci√™ncia da Computa√ß√£o.  Nos primeiros tr√™s anos, eu, como meus colegas de classe, estudei na Universidade Acad√™mica e, desde setembro, nos mudamos para a Escola Superior de Economia com todo o departamento. <br><br>  Ap√≥s o segundo ano, estive em um est√°gio de ver√£o no Google Zurich.  L√°, passei tr√™s meses trabalhando na equipe do Calend√°rio Android, na maioria das vezes fazendo frontend'om e um pouco de pesquisa sobre UX.  A parte mais interessante do meu trabalho foi a pesquisa sobre como as interfaces do calend√°rio podem parecer no futuro.  Acabou sendo agrad√°vel que quase todo o trabalho que fiz no final do est√°gio tenha terminado na vers√£o principal do aplicativo.  Mas o t√≥pico de est√°gios no Google √© muito bem abordado em uma postagem anterior, ent√£o vou falar sobre o que fiz neste ver√£o. <br><br><h2>  O que √© JB Research? </h2><br>  O JetBrains Research √© um conjunto de laborat√≥rios que trabalham em v√°rios campos: linguagens de programa√ß√£o, matem√°tica aplicada, aprendizado de m√°quina, rob√≥tica e outros.  Dentro de cada √°rea existem v√°rios grupos cient√≠ficos.  Devido √† minha dire√ß√£o, conhe√ßo melhor as atividades de grupos no campo de aprendizado de m√°quina.  Cada um deles organiza semin√°rios semanais nos quais os membros do grupo ou convidados conversam sobre seu trabalho ou artigos interessantes em seu campo.  Muitos estudantes do HSE comparecem a esses semin√°rios, pois atravessam a rua do edif√≠cio principal do Campus de HSE em S√£o Petersburgo. <br><br>  No nosso programa de bacharelado, estamos obrigatoriamente envolvidos em trabalhos de pesquisa (P&amp;D) e apresentamos os resultados da pesquisa duas vezes por ano.  Muitas vezes, esse trabalho gradualmente se transforma em est√°gios de ver√£o.  Isso tamb√©m aconteceu com meu trabalho de pesquisa: neste ver√£o, fiz um est√°gio no laborat√≥rio ‚ÄúM√©todos de aprendizado de m√°quina em engenharia de software‚Äù com meu supervisor de pesquisa Timofey Bryksin.  As tarefas que est√£o sendo trabalhadas neste laborat√≥rio incluem sugest√µes autom√°ticas de refatora√ß√£o, an√°lise do estilo de c√≥digo para programadores, conclus√£o de c√≥digo, pesquisa de erros no c√≥digo do programa. <br><br>  Meu est√°gio durou dois meses (julho e agosto) e, no outono, continuei envolvido em tarefas designadas no √¢mbito da pesquisa.  Trabalhei em v√°rias √°reas, a mais interessante delas, na minha opini√£o, foi a busca autom√°tica de bugs no c√≥digo, e quero falar sobre isso.  O ponto de partida foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo de Michael Pradel</a> . <br><br><h2>  Pesquisa autom√°tica de bugs </h2><br><h3>  Como os bugs s√£o pesquisados ‚Äã‚Äãagora? </h3><br>  Por que procurar bugs √© mais ou menos claro.  Vamos ver como eles est√£o indo agora.  Os detectores de erros modernos s√£o baseados principalmente na an√°lise de c√≥digo est√°tico.  Para cada tipo de erro, procure padr√µes observados anteriormente pelos quais ele possa ser determinado.  Ent√£o, para reduzir o n√∫mero de falsos positivos, s√£o inventadas heur√≠sticas, inventadas para cada caso individual.  Os padr√µes podem ser pesquisados ‚Äã‚Äãem uma √°rvore de sintaxe abstrata (AST) constru√≠da por c√≥digo e em gr√°ficos de um fluxo ou dados de controle. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || x &gt; MAX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = bar(x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><img src="https://habrastorage.org/webt/76/8t/wn/768twn22o7j83mwak6x-n9kw5d4.png"><br><br>  O c√≥digo e a √°rvore que foi constru√≠da nele. <br><br>  Para entender como isso funciona, considere um exemplo.  O tipo de erro pode ser o uso de = em vez de == no C ++.  Vejamos o seguinte trecho de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value = <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  Houve um erro na express√£o condicional, enquanto o primeiro = na atribui√ß√£o do valor √† vari√°vel est√° correto.  O padr√£o vem daqui: se a atribui√ß√£o for usada dentro da condi√ß√£o em if, isso √© um bug em potencial.  Procurando um padr√£o desse tipo no AST, podemos detectar o erro e corrigi-lo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  Em um caso mais geral, n√£o conseguiremos encontrar uma maneira t√£o f√°cil de descrever o erro.  Suponha que desejamos determinar a ordem correta dos operandos.  Mais uma vez, observe os fragmentos de c√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; n; i++) { a[i] = a[<span class="hljs-number"><span class="hljs-number">1</span></span> - i] + a[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - i; }</code> </pre><br>  No primeiro caso, o uso de 1-i foi incorreto, e no segundo foi completamente correto, o que √© claro a partir do contexto.  Mas como descrev√™-lo na forma de um padr√£o?  Com a complica√ß√£o do tipo de erros, temos que considerar uma se√ß√£o maior do c√≥digo e analisar cada vez mais casos individuais. <br><br>  O √∫ltimo exemplo motivador: informa√ß√µes √∫teis tamb√©m est√£o contidas nos nomes dos m√©todos e vari√°veis.  √â ainda mais dif√≠cil expressar por algumas condi√ß√µes especificadas manualmente. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSquare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDim, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yDim)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = getSquare(y, x);</code> </pre><br>  Uma pessoa entende que, muito provavelmente, os argumentos da chamada de fun√ß√£o est√£o confusos, porque entendemos que x √© mais parecido com xDim que com yDim.  Mas como relatar isso ao detector?  Voc√™ pode adicionar algum tipo de heur√≠stica da forma "o nome da vari√°vel √© o prefixo do nome do argumento", mas suponha que x seja mais frequentemente uma largura do que uma altura, para que n√£o seja mais expresso. <br><br>  Total: o problema da abordagem moderna para encontrar erros √© que muito trabalho deve ser feito com suas m√£os: para determinar padr√µes, adicionar heur√≠sticas, por isso, adicionar suporte a um novo tipo de erro no detector torna-se demorado.  Al√©m disso, √© dif√≠cil usar uma parte importante das informa√ß√µes que o desenvolvedor deixou no c√≥digo: os nomes das vari√°veis ‚Äã‚Äãe m√©todos. <br><br><h3>  Como o aprendizado de m√°quina pode ajudar? </h3><br>  Como voc√™ deve ter notado, em muitos exemplos os erros s√£o vis√≠veis aos seres humanos, mas s√£o dif√≠ceis de descrever formalmente.  Nessas situa√ß√µes, os m√©todos de aprendizado de m√°quina geralmente podem ajudar.  Vamos parar de procurar argumentos reorganizados em uma chamada de fun√ß√£o e entender o que precisamos procur√°-los usando o aprendizado de m√°quina: <br><br><ol><li>  Um grande n√∫mero de c√≥digo de amostra sem erros </li><li>  Uma grande quantidade de c√≥digo com erros de um determinado tipo </li><li>  M√©todo para vetorizar fragmentos de c√≥digo </li><li>  O modelo que vamos ensinar a distinguir entre c√≥digo com e sem erros </li></ol><br>  Podemos esperar que, na maior parte do c√≥digo apresentado em dom√≠nio p√∫blico, os argumentos nas chamadas de fun√ß√£o estejam na ordem correta.  Portanto, para c√≥digo de exemplo sem erros, voc√™ pode usar um grande conjunto de dados.  No caso do autor do artigo original, era JS 150K (150 mil arquivos em Javascript), no nosso caso, um conjunto de dados semelhante para Python. <br><br>  Encontrar c√≥digo com bugs √© muito mais dif√≠cil.  Mas n√£o podemos procurar os erros de outra pessoa, mas voc√™ mesmo!  Para o tipo de erros, voc√™ precisa especificar uma fun√ß√£o que, de acordo com o c√≥digo correto, a corrompa.  No nosso caso, reorganize os argumentos na chamada de fun√ß√£o. <br><br><h3>  Como vetorizar o c√≥digo? </h3><br>  Armado com muitos c√≥digos bons e ruins, estamos quase prontos para ensinar alguma coisa.  Antes disso, ainda precisamos responder √† pergunta: como apresentar fragmentos de c√≥digo? <br><br>  Uma chamada de fun√ß√£o pode ser representada como uma tupla do nome de um m√©todo, cujo nome √© de qual m√©todo, os nomes e os tipos de argumentos transmitidos √†s vari√°veis.  Se aprendermos como vetorizar tokens individuais (nomes de vari√°veis ‚Äã‚Äãe m√©todos, todas as ‚Äúpalavras‚Äù encontradas no c√≥digo), poderemos tomar a concatena√ß√£o de vetores de tokens de seu interesse e obter o vetor desejado para o fragmento. <br><br>  Para vetorizar tokens, vamos dar uma olhada em como as palavras em textos comuns se vetorizam.  Uma das maneiras mais bem-sucedidas e populares √© a word2vec proposta em 2013. <br><br><img src="https://habrastorage.org/webt/kj/0o/pp/kj0opp-scftpuqr16t5c9fj1uv0.png"><br><br>  Funciona da seguinte forma: ensinamos √† rede a prever por palavra outras palavras que aparecem pr√≥ximas a ela nos textos.  A rede ao mesmo tempo parece uma camada de entrada do tamanho de um dicion√°rio, uma camada oculta do tamanho da vetoriza√ß√£o que queremos obter e uma camada de sa√≠da, tamb√©m do tamanho de um dicion√°rio.  Durante o treinamento, as redes s√£o alimentadas com um vetor de unidade de entrada com uma unidade no lugar da palavra em quest√£o (raposa) e, na sa√≠da, queremos obter palavras que ocorram dentro da janela em torno dessa palavra (r√°pido, marrom, saltos, sobre).  Nesse caso, a rede primeiro traduz todas as palavras em um vetor em uma camada oculta e, em seguida, faz uma previs√£o. <br><br>  Os vetores resultantes para palavras individuais t√™m boas propriedades.  Por exemplo, vetores de palavras com significado semelhante est√£o pr√≥ximos um do outro, e a soma e a diferen√ßa dos vetores s√£o a adi√ß√£o e a diferen√ßa dos "significados" das palavras. <br><br>  Para criar uma vetoriza√ß√£o semelhante de tokens no c√≥digo, voc√™ precisa definir de alguma forma o ambiente que ser√° previsto.  Eles podem ser informa√ß√µes do AST: tipos de v√©rtices ao redor, tokens encontrados, posi√ß√£o em uma √°rvore. <br><br>  Ap√≥s receber uma vetoriza√ß√£o, √© poss√≠vel ver quais tokens s√£o semelhantes entre si.  Para fazer isso, calcule a dist√¢ncia do cosseno entre eles.  Como resultado, os seguintes vetores vizinhos s√£o obtidos para Javascript (n√∫mero √© a dist√¢ncia do cosseno): <br><br><img src="https://habrastorage.org/webt/lf/q0/4q/lfq04qjp4fcygqjikgy0zq9av8y.png"><br><br>  O ID e o LIT adicionados no in√≠cio indicam se o token √© um identificador (nome de uma vari√°vel, m√©todo) ou um literal (constante).  Pode-se ver que a proximidade √© significativa. <br><br><h3>  Treinamento do Classificador </h3><br>  Ap√≥s receber uma vetoriza√ß√£o para tokens individuais, obter uma exibi√ß√£o de um peda√ßo de c√≥digo com um erro em potencial √© bastante simples: √© uma concatena√ß√£o de vetores importantes para a classifica√ß√£o de tokens.  Um perceptron de duas camadas √© treinado em partes de c√≥digo com ReLU como uma fun√ß√£o de ativa√ß√£o e desist√™ncia para reduzir o sobreajuste.  O aprendizado converge rapidamente, o modelo resultante √© pequeno e pode fazer previs√µes para centenas de exemplos por segundo.  Isso permite que voc√™ use em tempo real, o que ser√° discutido mais adiante. <br><br><h3>  Resultados </h3><br>  A avalia√ß√£o da qualidade do classificador resultante foi dividida em duas partes: avalia√ß√£o em um grande n√∫mero de exemplos gerados artificialmente e verifica√ß√£o manual em um n√∫mero pequeno (50 para cada detector) de exemplos com a maior probabilidade prevista.  Os resultados para os tr√™s detectores (argumentos reorganizados, a corre√ß√£o do operador bin√°rio e do operando bin√°rio) foram os seguintes: <br><br><img src="https://habrastorage.org/webt/n9/f5/sm/n9f5smfdvj55bw3qeb-l_y9jub0.png"><br><br>  √â dif√≠cil encontrar alguns dos erros previstos nos m√©todos de pesquisa cl√°ssicos.  Um exemplo com res reorganizados e errar em uma chamada para p.done: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( promises === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || promises . length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { p. done (error , result ) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { promises [<span class="hljs-number"><span class="hljs-number">0</span></span>](error, result).then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, err</span></span></span><span class="hljs-function">) </span></span>{ p.done(res, err); }); }</code> </pre><br>  Havia tamb√©m exemplos nos quais n√£o havia erro, mas as vari√°veis ‚Äã‚Äãdeveriam ser renomeadas para n√£o enganar a pessoa que tentava descobrir o c√≥digo.  Por exemplo, adicionar largura e cada um deles n√£o parece uma boa ideia, apesar de n√£o ser um bug: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cw = cs[i].width + each;</code> </pre><br><h3>  Portabilidade Python </h3><br>  Eu estava envolvido em portar o trabalho de Michael Pradel de js para python e, em seguida, criar um plug-in para PyCharm que implementa inspe√ß√µes com base no m√©todo descrito acima.  Utilizamos o conjunto de dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python 150K</a> (150 mil arquivos Python dispon√≠veis no GitHub). <br><br>  Primeiro, verificou-se que no Python existem mais tokens diferentes do que no javascript.  Para js, os 10.000 tokens mais populares representavam mais de 90% de todos os encontrados, enquanto para o Python era necess√°rio usar cerca de 40.000, o que levou a um aumento no tamanho do mapeamento de token em vetores, o que dificultou a portabilidade para o plug-in. <br><br>  Em segundo lugar, tendo implementado para o Python uma busca por argumentos incorretos nas chamadas de fun√ß√£o e analisando os resultados manualmente, obtive uma taxa de erro superior a 90%, que estava em desacordo com os resultados de js.  Tendo entendido os motivos, descobriu-se que em javascript mais fun√ß√µes foram declaradas no mesmo arquivo que suas chamadas.  Eu, seguindo o exemplo do autor do artigo, a princ√≠pio n√£o permiti a declara√ß√£o de fun√ß√µes de outros arquivos, o que levou a maus resultados. <br><br>  No final de agosto, conclu√≠ a implementa√ß√£o do Python e escrevi a base do plug-in.  O plugin continua a ser desenvolvido, agora a estudante Anastasia Tuchina do nosso laborat√≥rio est√° envolvida nisso. <br><br>  Voc√™ pode encontrar as etapas para tentar como o plug-in funciona no wiki do reposit√≥rio. <br><br>  Links no github: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reposit√≥rio com implementa√ß√£o em python</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reposit√≥rio com plugin</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434368/">https://habr.com/ru/post/pt434368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434356/index.html">Still de Python com e-mail</a></li>
<li><a href="../pt434358/index.html">Substitui√ß√£o de importa√ß√£o de sistemas operacionais. Como vejo o SO dom√©stico</a></li>
<li><a href="../pt434360/index.html">Palestra explicada sobre programa√ß√£o ass√≠ncrona em Javascript</a></li>
<li><a href="../pt434362/index.html">N√ÉO previsto para 2019</a></li>
<li><a href="../pt434364/index.html">Suporte da fila do Hangfire</a></li>
<li><a href="../pt434370/index.html">Outro conquistador de sombras em Phaser, ou o uso de bicicletas</a></li>
<li><a href="../pt434374/index.html">Verificando o RBAC no Kubernetes</a></li>
<li><a href="../pt434380/index.html">No√ß√µes b√°sicas de inje√ß√£o de depend√™ncia</a></li>
<li><a href="../pt434382/index.html">Portando o Alpine Linux para o RISC-V</a></li>
<li><a href="../pt434384/index.html">Sobre a responsabilidade dos artistas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>