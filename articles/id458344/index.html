<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📓 🛐 🗼 Menggunakan Pesan Asinkron untuk Meningkatkan Ketersediaan ☑️ 🧒🏽 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Kami baru-baru ini menyerahkan sebuah buku karya Chris Richardson ke percetakan, yang tujuannya adalah untuk mengajarkan bagaimana ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan Pesan Asinkron untuk Meningkatkan Ketersediaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458344/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/hz/bw/dj/hzbwdju5aq8nv9xbromr1vbgdsi.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Kami baru-baru ini menyerahkan sebuah buku karya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chris Richardson</a> ke percetakan, yang tujuannya adalah untuk mengajarkan bagaimana cara berhasil mengembangkan aplikasi menggunakan arsitektur layanan mikro.  Buku ini tidak hanya membahas kelebihan, tetapi juga kelemahan dari layanan mikro.  Anda akan belajar dalam situasi apa masuk akal untuk menerapkannya, dan ketika lebih baik memikirkan pendekatan monolitik. <br><br>  Buku ini berfokus pada arsitektur dan desain.  Ini dirancang untuk siapa saja yang tanggung jawabnya termasuk menulis dan mengirimkan perangkat lunak, termasuk pengembang, arsitek, direktur teknis dan kepala departemen pengembangan. <br><br>  Berikut ini adalah kutipan dari buku Menggunakan Asynchronous Messaging <br><a name="habracut"></a><br><h3>  Menggunakan Pesan Asinkron untuk Meningkatkan Ketersediaan </h3><br>  Seperti yang Anda lihat, berbagai mekanisme IPC mendorong Anda ke berbagai kompromi.  Salah satunya terkait dengan bagaimana IPC mempengaruhi aksesibilitas.  Di bagian ini, Anda akan belajar bahwa interaksi sinkron dengan layanan lain sebagai bagian dari pemrosesan permintaan mengurangi ketersediaan aplikasi.  Dalam hal ini, ketika merancang layanan Anda, Anda harus menggunakan pesan asinkron bila memungkinkan. <br><br>  Pertama, mari kita lihat masalah apa yang menciptakan interaksi sinkron dan bagaimana hal itu mempengaruhi aksesibilitas. <br><br><h3>  3.4.1.  Interaksi yang disinkronkan mengurangi ketersediaan </h3><br>  REST adalah mesin IPC yang sangat populer.  Anda mungkin tergoda untuk menggunakannya untuk komunikasi antar layanan.  Tetapi masalah dengan REST adalah bahwa itu adalah protokol sinkron: klien HTTP harus menunggu sampai layanan mengembalikan respons.  Setiap kali layanan berkomunikasi satu sama lain melalui protokol sinkron, ini mengurangi ketersediaan aplikasi. <br><br>  Untuk memahami mengapa ini terjadi, pertimbangkan skenario yang ditunjukkan pada Gambar.  3.15.  Layanan Pesanan memiliki REST API untuk membuat pesanan.  Untuk memeriksa pesanan, ia beralih ke layanan Consumer and Restaurant, yang juga memiliki REST API. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/uq/22/pnuq22tmdzqdhbr_wxa9nuntoeq.png" alt="gambar"></div><br>  Membuat pesanan terdiri dari urutan langkah-langkah ini. <br><br><ol><li>  Klien membuat permintaan HTTP POST / pesanan ke layanan Pemesanan. </li><li>  Layanan Pesanan mengambil informasi pelanggan dengan membuat HTTP GET / permintaan konsumen / id ke layanan Konsumen. </li><li>  Layanan Order mengambil informasi restoran dengan mengeksekusi permintaan GET / restoran / id HTTP ke layanan Restoran. </li><li>  Pesanan Mengambil memeriksa permintaan menggunakan informasi tentang pelanggan dan restoran. </li><li>  Menerima Pesanan menciptakan pesanan. </li><li>  Pengambilan Pesanan mengirim respons HTTP ke klien. </li></ol><br>  Karena layanan ini menggunakan HTTP, semuanya harus dapat diakses oleh FTGO untuk memproses permintaan CreateOrder.  Itu tidak akan dapat membuat pesanan jika setidaknya salah satu layanan tidak tersedia.  Dari sudut pandang matematis, ketersediaan operasi sistem adalah produk dari ketersediaan layanan yang terlibat di dalamnya.  Jika layanan Pemesanan dan dua layanan yang disebutnya memiliki ketersediaan 99,5%, maka ketersediaan keseluruhannya akan menjadi 99,5% 3 = 98,5%, yang jauh lebih rendah.  Setiap layanan selanjutnya yang berpartisipasi dalam permintaan membuat operasi kurang dapat diakses. <br><br>  Masalah ini tidak unik untuk interaksi berbasis REST.  Ketersediaan menurun setiap kali suatu layanan perlu menerima tanggapan dari layanan lain untuk menanggapi klien.  Bahkan transisi ke gaya interaksi permintaan / respons di atas pesan asinkron tidak akan membantu di sini.  Misalnya, jika layanan Pemesanan mengirim pesan ke layanan Konsumen melalui pialang dan mulai menunggu tanggapan, ketersediaannya akan menurun. <br><br>  Jika Anda ingin memaksimalkan aksesibilitas, minimalkan jumlah interaksi sinkron.  Mari kita lihat bagaimana melakukannya. <br><br><h3>  3.4.2.  Singkirkan interaksi yang sinkron </h3><br>  Ada beberapa cara untuk mengurangi jumlah interaksi sinkron dengan layanan lain saat memproses permintaan sinkron.  Pertama, untuk sepenuhnya menghindari masalah ini, semua layanan dapat disediakan dengan API asinkron secara eksklusif.  Tetapi ini tidak selalu memungkinkan.  Misalnya, API publik umumnya mematuhi standar REST.  Oleh karena itu, beberapa layanan diharuskan memiliki API sinkron. <br><br>  Untungnya, untuk memproses permintaan sinkron, Anda tidak perlu menjalankannya sendiri.  Mari kita bicara tentang opsi semacam itu. <br><br>  <b>Menggunakan Gaya Interaksi Asinkron</b> <br><br>  Idealnya, semua interaksi harus terjadi dalam gaya asinkron yang dijelaskan sebelumnya dalam bab ini.  Bayangkan, misalnya, bahwa klien aplikasi FTGO menggunakan gaya interaksi permintaan / sinkronisasi respons asinkron untuk membuat pesanan.  Untuk membuat pesanan, ia mengirim pesan permintaan ke layanan Pemesanan.  Kemudian layanan ini secara asinkron bertukar pesan dengan layanan lain dan akhirnya mengembalikan respons kepada klien (Gbr. 3.16). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/j3/px/7ej3pxinlckogxf4ga0fmjaxtmu.png" alt="gambar"></div><br>  Klien dan layanan berkomunikasi secara tidak sinkron, mengirim pesan melalui saluran.  Tidak ada satu pun peserta dalam interaksi ini yang diblokir yang menunggu tanggapan. <br><br>  Arsitektur seperti itu akan sangat kuat, karena broker memberi pesan sampai konsumsinya memungkinkan.  Tetapi masalahnya adalah bahwa layanan seringkali memiliki API eksternal yang menggunakan protokol sinkron seperti REST dan, sebagai akibatnya, harus segera menanggapi permintaan. <br><br>  Jika layanan memiliki API sinkron, aksesibilitas dapat ditingkatkan melalui replikasi data.  Mari kita lihat cara kerjanya. <br><br>  <b>Replikasi data</b> <br><br>  Salah satu cara untuk meminimalkan interaksi sinkron selama pemrosesan kueri adalah dengan mereplikasi data.  Layanan menyimpan salinan (replika) dari data yang diperlukan untuk memproses permintaan.  Agar replika tetap mutakhir, ia berlangganan acara yang diterbitkan oleh layanan tempat data ini berada.  Misalnya, layanan Pemesanan dapat menyimpan salinan data milik layanan Pelanggan dan Restoran.  Ini akan memungkinkan dia untuk memproses permintaan untuk membuat pesanan tanpa menggunakan layanan ini.  Arsitektur seperti itu ditunjukkan dalam gambar.  3.17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p9/vz/zs/p9vzzssvlgjr7xx3efpsyjtesly.png" alt="gambar"></div><br>  Layanan Konsumen dan Restoran mempublikasikan acara kapan pun datanya berubah.  Layanan pesanan berlangganan acara-acara ini dan memperbarui replika-nya. <br><br>  Dalam beberapa kasus, replikasi data adalah solusi yang baik.  Sebagai contoh, Bab 5 menjelaskan bagaimana layanan Pemesanan mereplikasi data layanan Restoran untuk dapat memeriksa item menu.  Salah satu kelemahan dari pendekatan ini adalah bahwa kadang-kadang memerlukan menyalin sejumlah besar data, yang tidak efisien.  Misalnya, jika kami memiliki banyak pelanggan, menyimpan replika data milik layanan Konsumen mungkin tidak praktis.  Kerugian lain dari replikasi terletak pada kenyataan bahwa itu tidak menyelesaikan masalah memperbarui data milik layanan lain. <br><br>  Untuk mengatasi masalah ini, suatu layanan dapat menunda interaksi dengan layanan lain hingga menanggapi kliennya.  Ini akan dibahas lebih lanjut. <br><br>  <b>Akhiri pemrosesan setelah mengembalikan respons</b> <br><br>  Cara lain untuk menghilangkan interaksi sinkron selama pemrosesan kueri adalah dengan melakukan pemrosesan ini dalam bentuk langkah-langkah berikut. <br><br><ol><li>  Layanan memeriksa permintaan hanya dengan bantuan data yang tersedia secara lokal. </li><li>  Ini memperbarui basis datanya, termasuk menambahkan pesan ke tabel OUTBOX. </li><li>  Mengembalikan respons ke kliennya. </li></ol><br>  Selama pemrosesan permintaan, layanan tidak secara serentak mengakses layanan lain apa pun.  Sebagai gantinya, ia mengirimi mereka pesan-pesan tidak sinkron.  Pendekatan ini memberikan konektivitas layanan yang buruk.  Seperti yang akan Anda lihat di bab selanjutnya, proses ini sering diimplementasikan sebagai narasi. <br><br>  Bayangkan bahwa layanan Order bertindak dengan cara ini.  Dia membuat pesanan dengan status PENDING dan kemudian memeriksanya dengan bertukar pesan asinkron dengan layanan lain.  Dalam gbr.  Gambar 3.18 menunjukkan apa yang terjadi ketika operasi createOrder () dipanggil.  Rangkaian acara terlihat seperti ini. <br><br><ol><li>  Layanan Order membuat pesanan dengan status PENDING. </li><li>  Layanan pesanan mengembalikan respons dengan ID pesanan ke kliennya. </li><li>  Layanan Pesanan mengirimkan pesan ValidateConsumerInfo ke layanan Konsumen. </li><li>  Layanan Pesanan mengirimkan pesan ValidateOrderDetails ke layanan Restoran. </li><li>  Layanan Konsumen menerima pesan ValidateConsumerInfo, memeriksa untuk melihat apakah pelanggan dapat melakukan pemesanan, dan mengirimkan pesan ConsumerValidated ke layanan Pemesanan. </li><li>  Layanan restoran menerima pesan ValidateOrderDetails, memeriksa kebenaran item menu dan kemampuan restoran untuk mengirimkan pesanan ke alamat yang diberikan, dan mengirim pesan OrderDetailsValidated ke layanan Order. </li><li>  Layanan pesanan menerima pesan ConsumerValidated dan OrderDetailsValidated dan mengubah status pesanan menjadi VALIDATED. </li></ol><br>  Dan seterusnya ... <br><br>  Layanan Pesanan dapat menerima pesan ConsumerValidated dan OrderDetailsValidated dalam urutan apa pun.  Untuk mengetahui yang mana yang ia terima pertama, ia mengubah status pesanan.  Jika pesan pertama adalah ConsumerValidated, status pesanan berubah menjadi CONSUMER_VALIDATED, dan jika OrderDetailsValidated berubah menjadi ORDER_DETAILS_VALIDATED.  Setelah menerima pesan kedua, Layanan pesanan menetapkan status pesanan ke DILAKUKAN. <br><br>  Setelah memeriksa pesanan, layanan Pemesanan melakukan langkah-langkah yang tersisa untuk membuatnya, yang akan kita bahas di bab selanjutnya.  Sebagian besar dari pendekatan ini adalah bahwa layanan Pemesanan dapat membuat pesanan dan menanggapi pelanggan, bahkan jika layanan Konsumen tidak tersedia.  Cepat atau lambat, layanan Konsumen akan pulih dan memproses semua pesan yang tertunda, yang akan menyelesaikan verifikasi pesanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/d2/e_/hvd2e_kioxghqoo4jwcyqroerk8.png" alt="gambar"></div><br>  Kerugian dari mengembalikan respons sebelum permintaan diproses sepenuhnya adalah bahwa hal itu membuat klien lebih kompleks.  Misalnya, ketika layanan Pemesanan mengembalikan respons, itu memberikan jaminan minimal tentang status pesanan yang baru saja dibuat.  Dia menjawab segera, bahkan sebelum memeriksa pesanan dan mengesahkan kartu bank klien.  Dengan demikian, untuk mengetahui apakah pesanan telah berhasil dibuat, klien harus secara berkala meminta informasi atau layanan Pemesanan harus mengirimkan pesan pemberitahuan kepadanya.  Terlepas dari kerumitan pendekatan ini, dalam banyak kasus ada baiknya lebih disukai, terutama karena memperhitungkan masalah dengan manajemen transaksi terdistribusi, yang akan kita bahas dalam Bab 4. Dalam bab 4 dan 5, saya akan menunjukkan teknik ini menggunakan contoh layanan Order. <br><br><h3>  Ringkasan </h3><br><ul><li>  Arsitektur microservice didistribusikan, sehingga komunikasi antar proses memainkan peran kunci di dalamnya. </li><li>  Pengembangan layanan API harus didekati dengan hati-hati dan hati-hati.  Ini paling mudah untuk membuat perubahan yang kompatibel ke belakang karena mereka tidak mempengaruhi cara pelanggan bekerja.  Saat membuat perubahan pada API layanan, Anda biasanya harus mempertahankan versi lama dan baru hingga klien diperbarui. </li><li>  Ada banyak teknologi IPC, masing-masing dengan kekuatan dan kelemahannya sendiri.  Keputusan utama pada tahap desain adalah pilihan antara panggilan prosedur jauh sinkron dan pesan asinkron.  Yang paling mudah digunakan adalah protokol sinkron seperti REST, berdasarkan panggilan prosedur jarak jauh.  Namun idealnya, untuk meningkatkan aksesibilitas, layanan harus berkomunikasi menggunakan pesan asinkron. </li><li>  Untuk mencegah akumulasi kegagalan seperti longsoran salju dalam sistem, klien yang menggunakan protokol sinkron harus mampu mengatasi kegagalan parsial - fakta bahwa layanan yang dipanggil tidak tersedia atau menunjukkan latensi tinggi.  Khususnya, ketika mengeksekusi permintaan, perlu untuk menghitung waktu tunggu, membatasi jumlah permintaan yang terlambat dan menerapkan templat "Fuse" untuk menghindari panggilan ke layanan yang salah. </li><li>  Arsitektur yang menggunakan protokol sinkron harus menyertakan mekanisme penemuan sehingga klien dapat menentukan lokasi jaringan instance layanan.  Cara termudah adalah dengan fokus pada mekanisme penemuan yang disediakan oleh platform penyebaran: pada templat “Penemuan sisi server” dan “pendaftaran pihak ketiga”.  Pendekatan alternatif adalah penerapan penemuan layanan di tingkat aplikasi: template Penemuan Klien dan Registrasi Mandiri.  Metode ini membutuhkan lebih banyak upaya, tetapi cocok untuk situasi di mana layanan berjalan pada beberapa platform penempatan. </li><li>  Model pesan dan saluran merangkum detail implementasi sistem pesan dan menjadi pilihan yang baik ketika merancang jenis arsitektur ini.  Kemudian, Anda dapat mengikat arsitektur Anda ke infrastruktur pengiriman pesan tertentu, yang biasanya menggunakan broker. </li><li>  Kesulitan utama dalam pengiriman pesan adalah penerbitan dan pembaruan basis data.  Solusi yang baik adalah dengan menggunakan templat Penerbitan Peristiwa: pesan ditulis ke basis data di bagian paling awal sebagai bagian dari transaksi.  Proses terpisah kemudian mengambil pesan dari database menggunakan Interogating Publisher atau templat Pelacakan Log Transaksional, dan meneruskannya ke broker. </li></ul><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Untuk Khabrozhiteley diskon 30% untuk buku pre-order dengan kupon - <b>Microservices</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458344/">https://habr.com/ru/post/id458344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458332/index.html">Pemrograman asinkron - kinerja async: pahami biaya async dan tunggu</a></li>
<li><a href="../id458334/index.html">Replikasi berkelanjutan dari PostgreSQL Lama ke Baru dengan Slony</a></li>
<li><a href="../id458336/index.html">Siklus penuh pengembangan produk TI menggunakan contoh proyek: peran tim, tugas pelanggan, tahapan</a></li>
<li><a href="../id458338/index.html">Manajer Keamanan Aplikasi. Pengembang atau keamanan?</a></li>
<li><a href="../id458342/index.html">Tekstur, atau apa yang perlu Anda ketahui untuk menjadi Artis Permukaan. Bagian 1. Pixel</a></li>
<li><a href="../id458346/index.html">Pemecahan masalah dengan pwnable.kr 01 - fd. File deskriptor dan proses</a></li>
<li><a href="../id458348/index.html">Samsung Ecosystem - Hasil Kontes</a></li>
<li><a href="../id458350/index.html">Ulasan Twitter kotor dari VS7.0-ER</a></li>
<li><a href="../id458352/index.html">[Peter] Bertemu JUG.ru dengan Cliff Click - JVM Melakukannya?</a></li>
<li><a href="../id458354/index.html">Pengantar Pembalikan dari Awal Menggunakan IDA PRO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>