<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔝 👇🏼 👨🏽‍🚀 VB.NET和C＃之间的差异的详尽列表。 第一部分 ☘️ ⛹🏽 ㊙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="根据2018年TIOBE 评级 ，VB.NET的受欢迎程度超过了C＃。 是否巧合，但在2月，C＃的创建者之一埃里克·利珀特（Eric Lippert） 敦促读者注意他的朋友的博客，他的朋友是罗斯林编译器的前队友，并且是热情的VB.NET爱好者安东尼·格林 （ Anthony Green） 。 “这些...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VB.NET和C＃之间的差异的详尽列表。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443684/"><img src="https://habrastorage.org/webt/lv/zu/ex/lvzuexv-rlsyr8aeycle0f9r--4.png" alt="图片"><br><br> 根据2018年TIOBE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评级</a> ，VB.NET的受欢迎程度超过了C＃。 是否巧合，但在2月，C＃的创建者之一埃里克·利珀特（Eric Lippert） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">敦促</a>读者注意他的朋友的博客，他的朋友是罗斯林编译器的前队友，并且是热情的VB.NET爱好者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安东尼·格林</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Anthony Green）</a> 。  “这些资源是来自专家的深入细节，通过阅读文档很难找到，” Eric写道。 我们提请您注意Anthony Green的文章的第一部分“ VB.NET与C＃之间的差异的详尽列表”。 也许正是由于这些差异，才使这些语言的评级动态化的秘密所在。 <br><a name="habracut"></a><br> 在我将近一半的生命中，我目睹并参与了无数关于两种最流行的.NET语言的相似或不同之处的讨论。 首先，作为一个业余爱好者，然后是一个专业人士，最后，作为客户拥护者，程序经理和语言设计师，我可以毫不夸张地说出我听到或阅读过以下内容的次数： <br><blockquote>  <i>“ ... VB.NET实际上只是IL之上的一个薄层，就像C＃一样……”</i> </blockquote> 或 <blockquote>  <i>“ ... VB.NET实际上只是C＃，没有分号...”</i> </blockquote>好像这些语言是XML转换或样式表一样。 <br><br> 而且，如果某些热心的访客没有在评论中写这个，那么通常这暗示着这样的问题： <i>“你好，安东尼！</i>  <i>我在一个地方遇到了这么小的差异-这是一个错误吗？</i>  <i>在这世界上所有善良和圣洁的名义上应该完全相同的这两种原本相同的语言如何在这个地方散布？</i>  <i>为什么我们需要这种不公正？</i> <br><br> 直到出现突变为止，它们都是相同的， <i>然后</i>变成独立的物种。 哈哈！ <br><br> 但我明白。 在加入Microsoft之前，我可能还模糊地坚持了这个想法，并将其用作回应对手或使某人放心的论据。 我了解她的魅力。 这很容易理解，很容易重复。 但是在Roslyn上工作（基本上完全从头重写VB和C＃）长达5年，我意识到<b>这个想法是</b>多么<b>明确</b> 。 我与一个开发人员和测试人员团队合作，在一个巨大的多项目解决方案中重新实现了这两种语言的每一寸，以及它们的工具，该解决方案具有数百万种用两种语言编写的代码行。 考虑到大量开发人员之间的来回切换，以及与以前版本的结果和经验的高度兼容性以及需要以最小的细节可靠地复制大量API的需求，我被迫非常仔细地了解它们之间的差异。 实际上，有时候在我看来，我每天都学习有关VB.NET（我最喜欢的语言）的新知识。 <br><br> 最后，我花时间坐下来，从大脑中卸载过去15年来我学习使用和创建VB.NET所学知识的一部分，希望我至少可以节省下一次的时间。 <br><br> 在继续之前，我将概述基本规则： <br><br><ul><li> 通常情况下，此列表并不详尽。 他很穷。 这些并不是所有的差异。 这些甚至都不是我通常知道的所有差异。 这些只是我首先要记住的差异，直到我累得无法继续为止。 直到我筋疲力尽。 如果我或你们中的任何一个遇到或忆起其他分歧，我将很乐意更新此列表。 </li><li> 我将从VB 11规范的开头开始，然后使用其内容向下移动，以提醒自己该主题首先引起的差异。 </li><li>  <b>这不是VB中C＃以外的功能的列表。</b> 因此，没有“ XML文字与指针”。 这太普通了，互联网上已经有很多这样的列表（其中一些是我写的，也许将来我会写更多）。 我将主要关注在两种语言中都具有类似物的构造，并且不知情的观察者可能会建议这两种事物的行为相同，但是差别不大。 它们可能看起来相同，但工作方式不同，或者最终生成不同的代码。 </li><li>  <b>这不是VB和C＃之间的语法差异</b> （无数）的列表。 我将主要讨论语义差异（事物的含义），而不是语法差异（事物的编写方式）。 因此，没有类似“ VB以'开头的注释，而C＃使用//”或“在C＃_中是有效的标识符，但在VB中不是有效的标识符”之类的词。 但是我将在若干情况下违反此规则。 毕竟，规范的第一部分是关于词汇规则的。 </li><li> 我经常会举一些例子，有时我会提供理由说明为什么设计可以采用一种方法。 有些设计决策是在我眼前做出的，但是绝大多数决策是在我时代之前完成的，我只能猜测为什么做出这些决策。 </li><li> 请发表评论或鸣叫我（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ThatVBGuy</a> ），让我知道您最喜欢的差异和/或您想了解的更多差异。 </li></ul><br> 确定了期望并且没有进一步的延迟... <br><br><h2> 目录内容 </h2><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"><h4> 语法和预处理 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1. VB关键字和运算符可以使用全角字符</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2. VB支持智能报价</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.预处理常量可以是任何原始类型（包括日期），并且可以包含任何常量值</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.算术运算符可用于预处理表达式</a> </li></ul><br><h4> 公告等 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5. VB有时会跳过IL中的实现声明，以防止按名称意外隐式实现接口</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6. VB默认情况下按名称（阴影）隐藏基类的成员，而不按名称和签名（过载）隐藏基类的成员</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.对于泛型中的受保护成员，VB11及以下版本更加严格</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.属性中的语法“命名参数”始终会初始化属性/字段</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9.所有顶级声明（通常）都隐式位于项目的根名称空间中。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">10.模块不是在IL中作为密封的抽象类生成的，因此它们看起来并不完全像静态C＃类，反之亦然</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">11.在WinForms应用程序中，不需要显式的入口点方法（Sub Main）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">12.如果调用一些过时的VB运行时方法（例如FileOpen），则调用方法将隐式地标记有属性，以出于正确性的原因禁用内联</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">13.如果您的类型标记有DesignerGenerated属性，并且不包含任何显式的构造函数声明，则默认情况下生成的编译器（如果为此类型定义）将调用InitializeComponent。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">14.缺少Partial修饰符并不意味着该类型不是partial。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">15.在默认类中，公共访问级别适用于除字段以外的所有内容，在公共结构中也适用于字段</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">16. VB在调用基本构造函数之后初始化字段，而C＃在调用基本构造函数之前初始化字段</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">17. VB事件的隐式声明的支持字段的名称与C＃中的名称不同，并且可以按名称访问</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">18. VB自动属性的隐式声明的辅助字段具有一个通用名称，可通过该名称访问</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">19.自动属性的隐式声明的只读帮助器字段允许编写</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">20.事件属性有时会应用于辅助事件字段</a> </li></ul><br><h4> 使用说明 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">21.标签的范围是包含标签的整个方法的主体；</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以跳进方块（不是全部）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">22.局部变量&lt;&gt;范围的生存期</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">23.变量总是被初始化为对应类型的默认值。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">24.如果辅助字段为null，则RaiseEvent不会引发异常</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">25.分配并不总是相同的。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有时引用类型分配执行浅表克隆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">26. Select Case不支持掉线；</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无需休息</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">27.每个Case块都有自己的范围</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">28、29、30。Select Case适用于非原始类型，可以在检查中使用任意非恒定表达式，默认情况下使用=运算符</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">31.在循环内部声明的变量在某种程度上保留了迭代之间的含义</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">32.三个For循环表达式在循环开始时仅被评估一次。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">33.对于VB中的每个循环，可以使用GetEnumerator扩展方法</a> </li></ul></div></div><br><h2> 语法和预处理 </h2><br><a name="section1"></a><h3>  1. VB关键字和运算符可以使用全角字符 </h3><br> 在某些语言中（我不知道确切多少，但至少在某些形式的中文，日文和韩文中）使用全角字符。 简而言之，这意味着当使用等宽字体时（像大多数程序员一样），汉字占据的水​​平空间是我们过去在西方看到的拉丁字符的两倍。 例如： <br><br><img src="https://habrastorage.org/webt/wl/j8/0u/wlj80uri5nr810dqgpwymj5eru0.png"><br><br> 在这里，我有一个用日语编写的变量声明，以及一个用日语编写的字符串进行初始化的方法。 根据Bing翻译人员的说法，该变量称为“ greeting”，而该行显示为“ Hello World！”。 日语中的变量名只有2个字符长，但是它占用了我的键盘通常会给出的4个半角字符的空间，如第一个注释所示。 有数字的全角版本和所有其他印刷的ASCII字符，其宽度与日语相同。 为了证明这一点，我用全角数字“ 1”和“ 2”写了第二条评论。 这些与第一条评论中的“ 1”和“ 2”不同。 数字之间没有空格。 您还可以看到字符的大小不完全是2个字符宽，略有偏移。 部分原因是因为该程序在一行和所有三行中混合了全角和半角字符。 <br><br> 空格为半角，字母数字字符为全角。 除非我们沉迷于文本对齐，否则我们不是程序员。 在我看来，如果您是中国人，日本人或韩国人（或其他使用全角字符作为其语言的人）并使用以其本国语言编写的标识符或字符串，那么这些较小的对齐错误会令人发指。 <br><br> 据我了解，根据您的日语键盘，在象形文字和拉丁语之间进行切换很容易，但是最好使用全角拉丁字符。  VB在关键字，空格，运算符甚至引号中都支持此功能。 所以所有这些可以这样写： <br><br><img src="https://habrastorage.org/webt/me/mq/ph/memqph465sxyx_tvxov6fglrjfw.png"><br><br> 如您所见，在此版本中，关键字，空格，注释，运算符，甚至引号都使用其完整版本。 陷入混乱带来秩序。 <br><br> 是的 日本人使用VB。 实际上，尽管语法类似于英语（也许就是这个原因），但对于我在论坛上看到的大多数VB用户而言，英语并不是主要语言。 在微软工作期间，我多次遇到日本VB MVP，其中至少有一位经常带来日本糖果。 如果您是来自中国，日本或韩国（或来自使用全角字符的任何其他国家）的VB程序员，请在评论中写。  （在对作者的评论中，他们写道，日语在代码中到处都在尝试使用ascii- <i>大约。</i> ） <br><br>  <i><b>有趣的时刻：</b>当我最初在VB中实现插值行时，（令我感到羞耻）我没有考虑替换位置使用全角花括号的可能性。</i>  <i>Vladimir Reshetnikov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@vreshetnikov</a> ）发现并纠正了此错误，因此VB宽字符宽容的传统一直有效。</i> <br><br><a name="section2"></a><h3>  2. VB支持智能报价 </h3><br> 好的，这当然是一件小事，但值得一提。 您是否曾经在这样的文本文档中看到示例代码： <br><br><img src="https://habrastorage.org/webt/ls/8l/qc/ls8lqckokgku3b0raqiboefn9bc.png"><br><br> 在将示例复制到代码中之后，您是否发现所有（突出显示的）引号都不起作用，因为Word用<code>“</code>智能引号<code>”</code>替换了所有常见的ASCII引号？ <br><br> 我不知道 好的，我知道了，但是只有当我将示例复制到C＃时才知道。 在VB中，智能引号是字符串的有效分隔符（有趣的是，俄罗斯引号<code>«»</code>无效-大约。）： <br><br><img src="https://habrastorage.org/webt/l0/yk/wi/l0ykwi3ebeigkgrkkrzq8lfrwhm.png"><br><br> 它们也可以在字符串内部工作，尽管可能以一种奇怪的方式。 如果将巧妙的引号加倍以进行转义，则在运行时获得的只是纯（“哑”）引号。 这似乎有些奇怪，但是却非常实用，因为字符串中几乎所有其他地方都允许使用智能引号。 如果您从智能引号开始，编译器并不会使您肯定以智能引号结尾或使用正确的引号，因此您可以混合使用而不必担心。 是的，这也适用于用于注释的单引号字符： <br><br><img src="https://habrastorage.org/webt/4y/9j/8n/4y9j8n7mexmkyvtx_vmj-jesfak.png"><br><br> 我试图让Paul Wick（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@panopticoncntrl</a> ）承认他这样做是因为他在制定规范时饱受这个问题的折磨，但他否认有罪恶感。 在VB6中不是这种情况，因此以后有人添加了。 <br><br><a name="section3"></a><h3>  3.预处理常量可以是任何原始类型（包括日期），并且可以包含任何常量值 </h3><br><p><img src="https://habrastorage.org/webt/sd/0f/jv/sd0fjva0vsarlwmx7vgwn8yf8xq.png"></p><br><a name="section4"></a><h3>  4.算术运算符可用于预处理表达式 </h3><br><p><img src="https://habrastorage.org/webt/hx/cw/0k/hxcw0k25imfieuvg_ncshwbizim.png"></p><br><br><h2> 公告等 </h2><br><a name="section5"></a><h3>  5. VB有时会跳过IL实现声明，以防止按名称意外隐式实现接口。 </h3><br> 此项来自神秘主义。 在VB中，接口的实现总是显式完成的。 但是事实证明，在没有显式实现的情况下，调用接口方法时CLR的默认行为是按名称和签名搜索公共方法。 在大多数情况下，这是正常现象，因为在VB中，您<i>通常</i>需要为所实现的接口的每个成员提供一个实现，除了以下一种情况： <br><br><pre> <code class="vbscript hljs">Interface IFoo <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Baz() <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Interface <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Foo Implements IFoo <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() Implements IFoo.Bar <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> IFoo_Baz() Implements IFoo.Baz <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> FooDerived Inherits Foo Implements IFoo <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() Implements IFoo.Bar <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Baz() <span class="hljs-comment"><span class="hljs-comment">' Does something unrelated to what an IFoo.Baz would do. End Sub End Class</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/39634fd98a0cacc093719ab62d7ab1e6#file-partial-re-implementation-vb</a> <br><br> 在此示例中， <code>FooDerived</code>类仅想将<code>IFoo.Bar</code>重新分配给新方法，而其余实现则保持不变。 事实证明，如果编译器仅生成<code>FooDerived</code>的Implements指令，则CLR还将<code>FooDerived.Baz</code>用作<code>FooDerived.Baz</code>的新实现（尽管在此示例中与<code>IFoo</code>不相关）。 在C＃中，这是隐式发生的（我不确定是否可以拒绝它），但是在VB中，编译器实际上从整个声明中省略了“实现”来避免这种情况，并仅重新定义了已重新实现的特定成员。 换句话说，如果您询问<code>FooDerived</code>是否直接<code>IFoo</code> ，它将拒绝： <br><p><img src="https://habrastorage.org/webt/kz/u7/fr/kzu7fr0j1zz4eadll-m5gto7f8q.png"></p><br> 为什么我知道这一点，为什么它很重要？ 多年来，VB用户一直要求支持接口的隐式实现（在每个声明中未明确指定<code>Implements</code> ），通常用于代码生成。 仅将其与当前语法结合起来将是<code>FooDerived.Baz</code>重大突破，因为<code>FooDerived.Baz</code>现在隐式实现了<code>IFoo.Baz</code> ，尽管以前没有这样做。 但是最近，我在使用“默认接口实现”功能讨论潜在的设计问题时了解了更多有关此行为的信息，该功能将允许接口包括某些成员的默认实现，而无需在每个类中重新实现。 这对于重载很有用，例如，当所有实现者的实现可能都相同时（委派给主重载）。 另一种情况是版本控制。 如果接口可以包含默认实现，则可以在不破坏旧实现的情况下向其添加新成员。 但是有一个问题。 由于CLR中的默认行为是按名称和签名搜索公共实现，因此，如果VB类未使用默认实现来实现接口成员，但具有具有适当名称和签名的公共成员，则即使您完全完成此操作，它们也会隐式实现这些接口成员。不应该。 当在编译时知道完整的接口成员集时，您可以采取一些措施来解决此问题。 但是，如果成员是在编译代码后添加的，则它只是在运行时以静默方式更改行为。 <br><br><a name="section6"></a><h3>  6. VB默认情况下按名称（阴影）隐藏基类的成员，而不按名称和签名（过载）隐藏基类的成员 </h3><br> 我认为这种差异是众所周知的。 场景是这样的：您继承了基类（ <code>DomainObject</code> ）（可能不在您的控制范围之内），并声明了一个在类的上下文中有意义的名称的方法，例如<code>Print</code> ： <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> DomainObject <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Invoice Inherits DomainObject <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Print(copies As Integer) <span class="hljs-comment"><span class="hljs-comment">' Sends contents of invoice to default printer. End Sub End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/863cfd1e7536fe8bda7cd145795eaf9f#file-shadows-example-vb</a> <br><br> 可以打印发票的事实很有意义。 但是在声明您的基类的API的下一版本中，它们决定进行调试，以向所有DomainObjects添加一个方法，该方法在调试窗口中显示对象的全部内容。 这种方法被巧妙地称为“打印”。 问题在于您的API的客户端可能会注意到Invoice对象具有<code>Print()</code>和<code>Print(Integer)</code>方法，并认为这些是相关的重载。 也许第一个只打印一份。 但是，这根本不是您所认为的发票的作者。 您不知道<code>DomainObject.Print</code>将出现。 是的，这在VB中不起作用。 出现这种情况时，会出现警告，但更重要的是，VB中的默认行为是按名称隐藏。 也就是说，在您用<code>Overloads</code>关键字明确指出您的<code>Print</code>是基类的<code>Print</code>的重载之前<code>Print</code>基类的成员（及其任何重载）都将被完全隐藏。 只有您最初声明的API才会显示给类客户端。 默认情况下，此方法有效，但是您可以通过Shadows关键字显式地进行操作。  C＃只能执行<code>Overloads</code> （尽管在引用VB库时会考虑<code>Shadows</code> ），并且默认情况下会这样做（使用<code>new</code>关键字）。 但是，当某些继承层次结构出现在以一种语言定义另一种语言并用另一种语言定义另一类并且有重载方法的项目中时，这种差异会不时出现，这超出了差异列表中当前项目的范围。 <br><br><a name="section7"></a><h3>  7.对于泛型中的受保护成员，VB11及以下版本更加严格 </h3><br> 实际上，我们在VS2013和VS2015之间进行了更改。 特别是，我们决定不再为重新实施而烦恼。 但是，如果您使用旧版本并注意到它，我正在写这个区别。 简而言之：如果以通用类型声明了受保护的成员，那么继承人（也是通用的）只能通过具有相同类型参数的继承实例来访问此受保护成员。 <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Base(Of T) Protected x As T <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Derived</span></span>(Of T) Inherits Base(Of T) <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> F(y As <span class="hljs-built_in"><span class="hljs-built_in">Derived</span></span>(Of <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)) <span class="hljs-comment"><span class="hljs-comment">' Error: Derived(Of T) cannot access Derived(Of String)'s ' protected members yx = "a" End Sub End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/ce12ac986219eb51d6c85fa02c339a2f#file-protected-in-generics-vb</a> <br><br><a name="section8"></a><h3>  8.属性中的语法“命名参数”始终会初始化属性/字段 </h3><br>  VB使用相同的语法<code>:=</code>来初始化属性属性/字段，就像通过名称传递方法参数一样。 因此，无法通过名称将参数传递给属性构造函数。 <br><br><a name="section9"></a><h3>  9.所有顶级声明（通常）都隐式位于项目的根名称空间中 </h3><br> 这种差异几乎在“高级功能”类别中，但是我将其包括在列表中，因为它改变了代码的含义。  VB项目的属性中有一个字段： <br><br><p><img src="https://habrastorage.org/webt/0y/hy/7_/0yhy7_k2xkchvxq70v1duka5z4a.png"></p><br> 默认情况下，这只是创建时项目的名称。 该字段与C＃项目的属性中的“默认名称空间”不同。 默认名称空间只是设置默认情况下将哪些代码添加到C＃中的新文件中。 但是VB中的根名称空间意味着，除非另有说明，否则该项目中的每个顶级声明都隐式包含在该名称空间中。 这就是为什么VB文档模板通常不包含任何名称空间声明的原因。 此外，如果添加名称空间声明，它不会覆盖根目录，而是被添加到根目录中： <br><br><pre> <code class="vbscript hljs">Namespace Controllers <span class="hljs-comment"><span class="hljs-comment">' Child namespace. End Namespace Namespace Global.Controllers ' Top-level namespace End Namespace</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/fd1e5e3a58aee862a5082e1d2b078084#file-root-namespace-vb</a> <br><br> 因此，除非您通过在命名空间中显式声明<code>Global</code>来摆脱此机制，否则<code>Controllers</code>命名空间实际上会声明<code>VBExamples.Controllers</code>命名空间。 <br><br> 这很方便，因为它为每个VB文件节省了一层缩进和一个额外的概念。 这在创建UWP应用程序时特别有用（因为所有内容都必须在UWP的名称空间中），如果决定将整个项目的顶级名称空间从Roslyn之类的代码名称更改为Roslyn，这将非常方便。较长版本的文件，例如<code>Microsoft.CodeAnalysis</code> ，因为您不必手动更新解决方案中的每个文件。 使用代码生成器，XAML名称空间和新的<code>.vbproj</code>文件<code>.vbproj</code>时，请记住这一点也很重要。 <br><br><a name="section10"></a><h3>  10.模块不是在IL中作为密封的抽象类生成的，因此它们看起来并不完全像静态C＃类，反之亦然。 </h3><br> 尽管我们在2010年尝试使VB中的模块在IL方面相同，但VB中的模块存在于静态C＃类之前。 不幸的是，这是一个重大更改，因为该版本的.NET（我认为他们已将其修复）的XML序列化器（或者可能是二进制）不希望将嵌套的类型序列化为无法创建的类型（以及抽象类）不能）。 他抛出了一个例外。 <br><br> 我们在进行更改后将其找到并回滚，因为某些地方的某些代码使用了嵌入在模块中的枚举类型。 而且由于您不知道编译程序将使用哪个版本的序列化程序，因此将永远无法对其进行更改，因为在一个版本的应用程序中它将运行，而在其他情况下，它将引发异常。 <br><br><a name="section11"></a><h3>  11.在WinForms应用程序中，不需要显式的入口点方法（Sub Main） </h3><br> 如果您的项目使用Form作为起始对象，而不使用“ Application Framework”（在下一篇文章中有更多内容），则VB会生成<code>Sub Main</code> ，它会创建您的起始表单并将其传递给<code>Application.Run</code> ，从而可以保存整个文件要管理此过程，可以使用<code>Form</code>的其他方法，甚至需要考虑此问题。 <br><br><a name="section12"></a><h3>  12.如果调用一些过时的VB运行时方法（例如FileOpen），则调用方法将隐式地标记有属性，以出于正确性的原因禁用内联 </h3><br> 简而言之，使用VB6样式的文件（如<code>FileOpen</code>依赖于特定于代码所在程序集的上下文。 例如，文件1可以是一个项目中的日志，而另一个项目中的配置。 要确定哪个程序集正在运行， <code>Assembly.GetCallingAssembly()</code>调用<code>Assembly.GetCallingAssembly()</code> 。 但是，如果JIT将您的方法内<i>联</i>到调用程序中，则从堆栈的角度来看，VB运行时方法将不会由您的方法调用，而是由调用程序（可能位于不同的程序集中）调用，然后可以使您的代码访问或违反调用程序的内部状态。对象。 这不是安全问题，因为如果破坏性代码正在您的进程中运行，那么您已经迷路了。 这是正确性的问题。 因此，如果使用这些方法，编译器将禁用内联。 <br><br> 这项更改是在2010年的最后一刻进行的，因为x64 JIT在内联/优化代码时非常激进，我们发现它很晚了，这是最安全的选择。 <br><br><a name="section13"></a><h3>  13.如果您的类型标记有DesignerGenerated属性，并且不包含任何显式的构造函数声明，则默认生成的编译器（如果为此类型定义）将调用InitializeComponent。 </h3><br> 在Partial类型出现之前的时代，VB团队发动了一场战争，以减少WinForms项目中的样板代码。 但是，即使使用<code>Partial</code>它也是有用的，因为它允许生成的文件完全省略构造函数，并且用户可以在需要时在其文件中手动声明它，或者在不需要时不声明它。 否则，设计人员将被迫仅向调用<code>InitializeComponent</code>添加一个构造函数，并且如果用户添加的话，它们将是重复的，或者该工具箱应该足够聪明，可以将构造函数从设计器文件移至用户一个文件，并且如果已经在设计器中不重新生成它存在于用户文件中。 <br><br><a name="section14"></a><h3>  14.缺少Partial修饰符并不意味着该类型不是partial。 </h3><br> 从技术上讲，在VB中，只应将一个类标记为“部分”。 这通常是（在GUI项目中）一个生成的文件。 <br><br>  <b>怎么了</b> 这样可以使用户文件保持美观和整洁，并且在生成自定义代码或将自定义代码添加到生成的代码之后，可以非常方便地包含该文件。 但是，建议最多一个类没有Partial修饰符，否则会发出警告。 <br><br><a name="section15"></a><h3>  15.在默认类中，公共访问级别适用于除字段以外的所有内容，在公共结构中也适用于字段 </h3><br> 我对此有百感交集。 在C＃中，默认情况下所有内容都是<code>private</code>的（欢呼，封装！），但是根据您经常声明的内容，有一个参数可以做：公共合同或实现细节。 属性和事件通常是供外部（ <code>public</code> ）使用的，并且除了<code>public</code>之外，不能访问操作员。 但是，我很少依赖默认的可访问性（除了像本文中的示例这样的演示之外）。 <br><br><a name="section16"></a><h3>  16. VB在调用基本构造函数之后初始化字段，而C＃在调用基本构造函数之前初始化字段 </h3><br> 您是否听说过在构造函数中发生的第一件事是对基类的构造函数的调用？ 好吧，至少在C＃中不是这样。 在C＃中，在调用<code>base()</code> （显式或隐式<code>base()</code>之前，首先执行字段初始化程序，然后执行构造函数调用，然后执行代码。 这个决定会产生后果，我想我知道为什么语言开发人员可以走一条路。 我相信这些后果之一是以下代码无法直接转换为C＃： <br><br><pre> <code class="vbscript hljs">Imports System.Reflection <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> ReflectionFoo <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringType As Type = GetType(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringLengthProperty As PropertyInfo = StringType.GetProperty(<span class="hljs-string"><span class="hljs-string">"Length"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringGetEnumeratorMethod As MethodInfo = StringType.GetMethod(<span class="hljs-string"><span class="hljs-string">"GetEnumerator"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringEnumeratorType As Type = StringGetEnumeratorMethod.ReturnType <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">New</span></span>() Console.WriteLine(StringType) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/37d01c8e7f085e06172bfaf6a1e567d4#file-field-init-me-reference-vb</a> <br><br> 在从事反射的日子里，我经常写这样的代码。 而且我隐约记得微软（Josh）之前的一位同事，他曾将我的代码翻译成C＃，有时抱怨需要将我所有的初始化程序移植到构造函数中。 在C＃中，禁止在调用<code>base()</code>之前引用正在创建的对象。 并且由于字段初始化器是在指定的调用之前执行的，因此它们也不能引用其他字段或对象实例的任何成员。 因此，此示例也仅在VB中有效： <br><br><pre> <code class="vbscript hljs">MustInherit <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Base <span class="hljs-comment"><span class="hljs-comment">' OOP OP? Private Cached As Object = DerivedFactory() Protected MustOverride Function DerivedFactory() As Object End Class Class Derived Inherits Base Protected Overrides Function DerivedFactory() As Object Return New Object() End Function End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/fe5ca89e5a98efee97ffee93aa684e50#file-base-derived-init-vb</a> <br><br> 在这里，我们有一个基类，它应该具有很多功能，但是它需要一些关键对象来进行管理和工作，这由派生类型决定。 有很多方法可以实现这样的模板，但是我通常使用这个模板是因为： <br><br><ul><li> 他矮了； </li><li> 不需要我声明构造函数； </li><li> 不需要我将初始化代码放入构造函数中（如果有）； </li><li> 允许我缓存创建的对象，并且不需要派生类型来声明和管理所提供对象的存储，尽管现在自动属性已不再是问题。 </li></ul><br> 此外，我遇到过两种情况：当派生类型的字段想要调用在基类中声明的方法时，以及当基类的字段初始化程序需要调用由派生类型实现的<code>MustOverride</code>成员时。 两者在VB中均有效，而在C＃中均无效，这很有意义。 如果C＃字段初始化程序可以调用基类的成员，则该成员可以依赖于在基函数构造函数（尚未运行）中初始化的字段，并且结果几乎肯定是错误的，因此无法解决。 <br><br> 但是在VB中，基本构造函数已经解决了，因此您可以执行任何操作！ 在相反的情况下，一切都有些复杂，因为从基类的初始化程序（或构造函数）调用<code>Overridable</code>成员可能导致在字段“初始化”之前进行访问。 但是只有您的实现知道这是否有问题。 在我的脚本中，这只是没有发生。 它们不依赖于实例的状态，但不能成为<code>Shared</code>成员，因为出于技术原因，您不能拥有任何语言的<code>Shared Overridable</code>成员，但本文不涉及其范围。 另外，在启动自定义初始化程序之前，已明确定义了字段发生了什么-它们使用默认值进行初始化，就像VB中的所有变量一样。 没什么好奇怪的 <br><br>  <b>那为什么呢</b> 实际上，我不知道我的脚本是否是最初的VB.NET团队在设计脚本时所考虑的。 就我而言，它才有效！  ,       :  VB ,         ,       .              .          . <br><br> <i> ,              ,    ,          C#  VB,       ,    VB  ,   C#.</i> <br><br><a name="section17"></a><h3> 17.     (backing field)  VB   ,   C#,     </h3><br>          (       ).        <code>E</code> ,  VB   (  IDE)    <code>EEvent</code> .  C#     <code>E</code> ,     ,   <code>E</code>   ,    . <br><br><a name="section18"></a><h3> 18.      VB         </h3><br>      <code>P</code> ,      <code>_P'</code> .    IntelliSense,      .  C#    «» ( <i>mangled</i> ) ,  ,            C#     . <br><br> <b> ?</b>  VB    , -,             «WithEvents»,  -,     ,   -     ,        . <br><br><a name="section19"></a><h3> 19.     read-only    </h3><br>    ,        ,  ….   VB     « »    .    <code>WithEvents</code> -, non-Custom           ,       ,     .    IntelliSense,      ,     ,  .   FTW!  ,   VB  ,    private set;   C#. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Alarm <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> ReadOnly Code As Integer ReadOnly <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> Status As <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"Disarmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">New</span></span>(code As Integer) <span class="hljs-keyword"><span class="hljs-keyword">Me</span></span>.Code = code <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Arm() <span class="hljs-comment"><span class="hljs-comment">' I'm motifying the value of this externally read-only property here. _Status = "Armed" End Sub Function Disarm(code As Integer) As Boolean If code = Me.Code Then ' And here. _Status = "Disarmed" Return True Else Return False End If End Function End Class</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/57ce7962700c5498894ad417296f9066#file-read-only-auto-property-backing-field-is-writeable-vb</a> <br><br><a name="section20"></a><h3> 20.         </h3><br>  ,  <code>NonSerialized</code> . <br><br>   VB       (expanded) Custom-  2005  (?) <b></b>       ,         ,  ,   <code>NonSerialized</code> .  ,     ,   ,   ,       «»       ,    « ». <br><br>     ,   ,          ,  ,   . , , ,     ,     two-way bindable ( ,   <code>PropertyChanged</code> ),     ,    , , ,    . <br><br>   ,     ,       CLSA «Expert Business Objects» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  (Rocky Lhotka)</a> ,      undo/redo (    ,    ,   - ,  ,     ),       .  ,         .  ,  ,        ,    . <br><br><h2>  </h2><br><a name="section21"></a><h3> 21.    —    ,  ;      ( ) </h3><br>   ,      <code>GoTo</code>     .   ,        -   . ,       <code>For</code>  <code>For Each</code> ;  <code>Using</code> , <code>SyncLock</code>  <code>With</code> ,   ,     ,        <code>Finally</code> .   <code>If</code>  <code>Select Case</code> ,  <code>Do</code>  <code>While</code> ,    Try —    ,        : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">0</span></span> Try Retry: <span class="hljs-comment"><span class="hljs-comment">' IO call. Catch ex As IO.IOException When retryCount &lt; 3 retryCount += 1 GoTo Retry End Try End Sub End Module</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/b93adcf3c3705e4768dcab0b05b187a0#file-try-goto-retry-vb</a> <br><br>  ,  ,   ,   .NET  VB      «».  VB6        Quick Basic  ( )       .      QB,      .     ,       « »,           .        GoTo,         —   ,        . <br><br> <b></b> :    <code>Try</code>    ,  VB -   <code>await</code>   <code>Catch</code>  <code>Finally</code> ,  ,     <code>GoTo</code>    . <br><br><a name="section22"></a><h3> 22.     &lt;&gt;   </h3><br>    ,  VB   (     )  ( <code>static</code> )        (      ).    ,     .        <code>Catch</code>       3 .      <code>Try</code>      <code>Catch</code> ,      ,   ,       <code>Try</code>     . <br><br>  ,  VB.NET     ,     .       CLR      VB   .      :           ,    . <br><br> <i>, C# ,        ,       «».   VB.NET     .</i> <br><br><a name="section22"></a><h3> 23.          </h3><br>       ,        ,    C#       « » ( <i>definite assignment</i> ).   ,    , ,         « ».   ,   ( )           ,   ,          .    C/C++.      , !   ,        .  ,        ,    , —  .           ,     ,   ,         ,  ,         ,      ,          ,    .  ,  BASIC   ,          ,      «» ,       <code>= Nothing</code> , <code>= 0</code> , <code>= False</code>  .. <br><br> ,   ( <i>flow analysis</i> )  VB    ,    . <br><br>         ,    C#   ,  ,          ,            . VB    <i></i>  ,       ,        ,       .  Roslyn, , API       « »,       ,      . <br><br><a name="section24"></a><h3> 24. RaiseEvent   ,     null </h3><br>     ,  -     C#  VB. <code>RaiseEvent</code>  VB —        ,     <code>null</code> ( ),    <code>null</code> - —  ,      . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">' You don't have to write this: If PropertyChangedEvent IsNot Nothing Then RaiseEvent PropertyChanged(Me, e) End If ' You don't have to write this: Dim handlers = PropertyChangedEvent If handlers IsNot Nothing Then handlers(Me, e) End If ' You don't have to write this either: PropertyChangedEvent?(Me, e) ' Just write this: RaiseEvent PropertyChanged(Me, e)</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/c3dea3d91ef4ffc50cfa92c41f967937#file-null-safe-event-raising-vb</a> <br><br> ,    null-conditional   C#  VS2015     C#   ,      VB (  ),       ,     ;   VB.NET    . <br><br><a name="section25"></a><h3> 25.    ;        (shallow clone) </h3><br>     , ,        17 , ,     .     (boxed)      Object,       <code>System.Runtime.CompilerServices.RuntimeHelper.GetObjectValue</code> .   ,   CLR.    ,    : <br><br><ul><li>     ,      . <br></li><li>       ,    (,     Integer ),      . <br></li><li>        ,            . <br></li></ul><br>    ,     ,  ,    ,       ( <i>late-bound situations</i> ). ,        ,     (    )  ,           ,   ,        ,      ( <i>caller's copy</i> ).          ,     ,  - , —     . <br><br>          .     : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyEventArgs <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> Value As Object <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Structure MyStruct <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> X, Y As Integer <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Structure Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> defaultValue As Object = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> {.X = <span class="hljs-number"><span class="hljs-number">3</span></span>, .Y = <span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> MyEventArgs <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> {.Value = defaultValue} RaiseEvent DoSomething(<span class="hljs-literal"><span class="hljs-literal">Nothing</span></span>, e) <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> e.Value <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span> defaultValue <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> <span class="hljs-comment"><span class="hljs-comment">' No handlers have changed anything. Console.WriteLine("Unchanged.") End If End Sub Event DoSomething(sender As Object, e As MyEventArgs) End Module</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/422ac4574af92d9bbbf59f0fbc40b74d#file-get-object-value-vb</a> <br><br>      ,     WPF,               .    ,     . ,                     ,        .    ,    .   ,    -   ,  , ,              . <br><br> ,    ,   « »         .    IronRuby/Python,    <code>dynamic</code>  C# (  C#): C#    <code>GetObjectValue</code>     .         <code>object.ReferenceEquals</code> ,  ,    ,   <i></i>    -    <code>dynamic</code> C# (     ).       <code>==</code> ,    .   C#,    ,          . <br><br><a name="section26"></a><h3> 26. Select Case   «» (fall-through);   break </h3><br>     Friday    ,  Sunday —  ,  5   . <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> Today.DayOfWeek <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Monday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Tuesday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Wednesday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Thursday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Friday: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Weekday"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Saturday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Sunday: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Weekend"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/7b7e136c71dd11b2417a6c7267bb3546#file-select-case-no-fallthrough-vb</a> <br><br>     Roslyn C#  ,  -      : <i>«,    ?   !»</i>   <i>«,  »</i> .   . VS    ,    ,   ,    ,      ,     .    ! <br><br>       . C# ,        C,       C.       .  , C#     ,    case   .   -  ,     <code>goto</code> ,  <code>break</code> .     VB   <code>break</code> , <code>Exit Select</code> ,       ,    VB   . <br><br><a name="section27"></a><h3> 27.   Case     </h3><br>      ,      .           C#,   : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> Today.DayOfWeek <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> message = <span class="hljs-string"><span class="hljs-string">"Get to work!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Saturday, DayOfWeek.Sunday <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> message = <span class="hljs-string"><span class="hljs-string">"Funtime!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/bd642061896246c9336255881fb78546#file-select-case-scopes-vb</a> <br><br>   ,  <code>message</code>        ,    C#   <code>switch</code>         <code>case</code> —   .     . ,  ,  -    (  ,  C):        , , ,  ,     . <br><br><a name="section28to30"></a><h3> 28, 29, 30. Select Case    ,             = </h3><br> ,  ,     ,            ,     <code>Select Case</code>             . <br><br>             ,       ,     .    : <br><br><ul><li> <code>Select Case</code> —  ,           , … <br></li><li> <code>switch</code> —   / ,   « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   ». <br></li></ul><br>  ,    26-30. <code>switch</code>    ,    ,  , ,     <code>if</code> .  IL   <code>switch</code> ,   ,   <code>If</code> ,   VB        ,   .    switch       , ,    C   .  VB    . <br><br><a name="section31"></a><h3> 31. ,   ,         </h3><br>       <code>x</code>    ,      ,      -1, -2, -3: <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> x As Integer x -= <span class="hljs-number"><span class="hljs-number">1</span></span> Console.WriteLine(x) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/cbc3a9c70677354973d64f1d993a3c5d#file-loop-variables-retain-their-values-vb</a> <br><br>    <i>«     ,    ,    »</i> ( ).   ,      VB2008  ,    -: <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> lambdas = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> List(Of Action) <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> x As Integer x -= <span class="hljs-number"><span class="hljs-number">1</span></span> lambdas.Add(<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>() Console.WriteLine(x)) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Each</span></span> lambda <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> lambdas lambda() <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/2ef9ba3dfcf9a1abe0e94b0cde12faf1#file-loop-variables-captured-per-iteration-vb</a> <br><br>     -1, -2, -3.     <code>x</code> — « », -   <code>x</code>    ,      .          ,        <code>x</code>     .     flow analysis API — ! ( <i>«… …  ?»</i> ) <br><br>  <b>怎么了</b>   ,  ,      ,    ,      ,        #22.         ,        ,       -,         . <br><br> ,   VB  C#      ( <i>control variables</i> )  <code>For Each</code>  VS2012 (?),  -   « ».   10000%    ,    (  , VB      ,      ).  ,    VB         <code>For</code> ,        .            ,      .      ,   VB  <code>For</code>      <code>For Each</code> ,  <code>for</code>  <code>foreach</code>  C#.          ,   <code>For</code>  VB -  ,    ,      . <br><br><a name="section32"></a><h3> 32.    For        </h3><br>         <code>For</code> .        ,   ,       1,3,5,7,9,          ,     . <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> lower = <span class="hljs-number"><span class="hljs-number">1</span></span>, upper = <span class="hljs-number"><span class="hljs-number">9</span></span>, increment = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = lower <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> upper <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span> increment Console.WriteLine(i) upper += <span class="hljs-number"><span class="hljs-number">1</span></span> increment -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/1e48113be204f515c51e221858666ac7#file-for-loop-bounds-cached-vb</a> <br><br>    ,          (       ),   ,     ,    ,          <code>IndexOutOfRangeExceptions</code> ,    . <br><br>   ,   ,      , , ,       C,    VB .  - ,  VB ,  <code>For i = a To b Step c</code>   (  ,  <code>i&gt; b</code> )   (  ,  <code>i &lt;b</code> ),   <code>c</code>    ?    ,    ,      ,   <code>b</code>   ,   — .    ,     , , ,       . <br><br><a name="section33"></a><h3> 33. For Each   VB     GetEnumerator </h3><br>       <code>For Each</code> ,     <code>IEnumerable</code> ,       <code>GetEnumerator</code>  ,    <code>For Each</code> . <br> ,   ,     <code>For Each</code>  <code>IEnumerator</code>  ,          , : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> List(Of Integer) From {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> info = list.FirstAndRest() <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> info.First IsNot <span class="hljs-literal"><span class="hljs-literal">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> Console.Write(info.First.GetValueOrDefault()) <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Each</span></span> other <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> info.Additional Console.Write(<span class="hljs-string"><span class="hljs-string">", "</span></span>) Console.Write(other) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> Console.WriteLine() <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> &lt;Runtime.CompilerServices.Extension&gt; <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> FirstAndRest(Of T As Structure)(sequence As IEnumerable(Of T)) As (First As T?, Additional As IEnumerator(Of T)) <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> enumerator = sequence.GetEnumerator() <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> enumerator.MoveNext() <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> Return (enumerator.Current, enumerator) <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span> Return (<span class="hljs-literal"><span class="hljs-literal">Nothing</span></span>, enumerator) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> &lt;Runtime.CompilerServices.Extension&gt; <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> GetEnumerator(Of T)(enumerator As IEnumerator(Of T)) As IEnumerator(Of T) Return enumerator <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist.github.com/AnthonyDGreen/d7dbb7a5b98a940765c4adc33e3eaeee#file-for-each-extension-get-enumerator-vb</a> <br><br>           F#        ,    <code>IEnumerator</code> ,     <code>For Each</code>    ,   . <br><br>  VB   ,            ( <i>well-known name</i> ),      .   , ,   Add,   . C#     ,          (. <code>async</code> / <code>await</code> ).      ,    C# Roslyn ()     ,     . <br><blockquote> 分钟的广告。 15-16   -    .NET- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext 2019 Piter</a> .   ,       .       ,      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443684/">https://habr.com/ru/post/zh-CN443684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443672/index.html">基于风险的测试</a></li>
<li><a href="../zh-CN443676/index.html">乙烯基代替邮票：罕见的稀有</a></li>
<li><a href="../zh-CN443678/index.html">代码可读性</a></li>
<li><a href="../zh-CN443680/index.html">每周四天工作。 俄罗斯经验</a></li>
<li><a href="../zh-CN443682/index.html">云货币化：如何吸引客户而永不破产</a></li>
<li><a href="../zh-CN443686/index.html">3月30日至31日，西布尔挑战赛在下诺夫哥罗德</a></li>
<li><a href="../zh-CN443690/index.html">Parallels RAS：它是什么以及与什么一起吃？</a></li>
<li><a href="../zh-CN443692/index.html">21世纪的炼金术：将液态金属氘转化为等离子体</a></li>
<li><a href="../zh-CN443694/index.html">浏览器如何帮助Major同志</a></li>
<li><a href="../zh-CN443698/index.html">Google已停止“扼杀鹅”：DuckDuckGo已列入60个国家/地区的标准Chrome搜索引擎列表中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>