<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 👩🏼‍🍳 🐧 Apresentações tridimensionais de produtos no Three.js para os menores 🚴🏾 👦🏿 🤩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os tipos de apresentações de produtos em 3D não são tão raros em nossos dias, mas essas tarefas causam muitas perguntas aos desenvolvedores inic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apresentações tridimensionais de produtos no Three.js para os menores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433876/"><p><img src="https://habrastorage.org/webt/zq/qv/nw/zqqvnwkx2md-fl2vpq4mkwyx3ka.jpeg"></p><br><p>  Todos os tipos de apresentações de produtos em 3D não são tão raros em nossos dias, mas essas tarefas causam muitas perguntas aos desenvolvedores iniciantes.  Hoje, examinaremos alguns princípios básicos que ajudarão você a entrar neste tópico e não tropeçar em uma tarefa tão simples como exibir um modelo tridimensional em um navegador.  Como auxílio, usaremos o Three.js como a ferramenta mais popular nessa área. </p><a name="habracut"></a><br><h2 id="pristupaem-k-rabote">  Começando a trabalhar </h2><br><p>  Primeiro de tudo, vamos criar um modelo HTML para nós mesmos.  Para não complicar o exemplo, não usaremos nada supérfluo, nem montadores, pré-processadores, etc. </p><br><p>  Precisamos de um contêiner para canvas e um conjunto de scripts - na verdade three.js, um carregador para modelos no formato obj e um script para controlar a câmera com o mouse. </p><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'canvas-container'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/build/three.min.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/loaders/OBJLoader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/controls/OrbitControls.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'./main.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Se o seu projeto usa o NPM e os construtores, você pode importar tudo isso do pacote três.  Na verdade, se alguém não souber, o Unpkg aceita todos os pacotes do NPM. </p><br><blockquote>  Se você precisar conectar rapidamente algo de algum pacote à sua página, mas não encontrou o link para a CDN, lembre-se de Unpkg, provavelmente é necessário. </blockquote><p>  O script principal começará com várias variáveis ​​globais.  Isso simplificará o exemplo. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> SCENE; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> CAMERA; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> RENDERER; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> LOADING_MANAGER; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> IMAGE_LOADER; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> OBJ_LOADER; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> CONTROLS; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> MOUSE; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> RAYCASTER; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TEXTURE; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> OBJECT;</code> </pre> <br><p>  No Three.js, tudo começa com a cena, então inicialize-a e crie algumas fontes de luz: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); initLights(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ambient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.AmbientLight(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>); SCENE.add(ambient); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> directionalLight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.DirectionalLight(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>); directionalLight.position.set(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); SCENE.add(directionalLight); }</code> </pre> <br><p>  As fontes de luz são diferentes.  Na maioria das vezes, nessas tarefas, o ambiente é usado - preenchendo a luz e direcionado - a luz em uma determinada direção.  Ainda existem fontes pontuais de luz, mas ainda não precisamos delas.  Tornamos o brilho da cor branca para que não haja distorções. </p><br><blockquote>  Pode ser útil brincar com a cor do brilho de preenchimento, especialmente com tons de cinza, para que você possa criar uma imagem mais suave. </blockquote><p>  A segunda coisa importante é a câmera.  Essa é uma entidade que determina o ponto em que estamos e a direção em que olhamos. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CAMERA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>); CAMERA.position.z = <span class="hljs-number"><span class="hljs-number">100</span></span>; }</code> </pre> <br><p>  Os parâmetros da câmera geralmente são selecionados a olho nu e dependem dos modelos usados. </p><br><p>  O terceiro objeto de que precisamos é um renderizador.  Ele é responsável por renderizar a imagem.  Sua inicialização fala por si: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ RENDERER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.WebGLRenderer({ <span class="hljs-attr"><span class="hljs-attr">alpha</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); RENDERER.setPixelRatio(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.devicePixelRatio); RENDERER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); }</code> </pre> <br><p>  Carregadores são necessários para carregar dados de diferentes formatos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> você pode encontrar uma longa lista de opções, mas precisamos apenas de duas - uma para as fotos (vem com o kit) e outra para os modelos (nós a conectamos no início). </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLoaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ LOADING_MANAGER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.LoadingManager(); IMAGE_LOADER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ImageLoader(LOADING_MANAGER); OBJ_LOADER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.OBJLoader(LOADING_MANAGER); }</code> </pre> <br><p>  Prosseguimos para carregar o modelo.  Como esperado, ocorre de forma assíncrona.  Depois de carregar o modelo, podemos brincar com seus parâmetros: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ OBJ_LOADER.load(<span class="hljs-string"><span class="hljs-string">'./model.obj'</span></span>, (object) =&gt; { object.scale.x = <span class="hljs-number"><span class="hljs-number">0.3</span></span>; object.scale.y = <span class="hljs-number"><span class="hljs-number">0.3</span></span>; object.scale.z = <span class="hljs-number"><span class="hljs-number">0.3</span></span>; object.rotation.x = -<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">2</span></span>; object.position.y = <span class="hljs-number"><span class="hljs-number">-30</span></span>; OBJECT = object; SCENE.add(OBJECT); }); }</code> </pre><br><p>  Resta iniciar o órgão de barril: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); render(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CAMERA.lookAt(SCENE.position); RENDERER.render(SCENE, CAMERA); }</code> </pre> <br><p>  Como resultado, temos apenas uma árvore de Natal branca com sombras (tirei o modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ). </p><br><p><img src="https://habrastorage.org/webt/ry/re/2z/ryre2z9uir0w1uew_21kydffldq.jpeg"></p><br><p>  Um, dois, três, queima de árvore de Natal!  Mas sem texturas, é claro, não queimará.  Sim, e falaremos sobre os shaders de fogo e outros elementos em outro momento ... Mas pelo menos podemos ver que o modelo da árvore de Natal está “na TV”. </p><br><p>  Antes de passar para as texturas, é útil adicionar uma janela padrão do navegador para redimensionar o manipulador de eventos: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initEventListeners</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'resize'</span></span>, onWindowResize); onWindowResize(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWindowResize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CAMERA.aspect = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; CAMERA.updateProjectionMatrix(); RENDERER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); }</code> </pre> <br><h2 id="dobavlyaem-teksturu">  Adicionar textura </h2><br><p>  Nosso modelo e textura de imagem trabalham com o princípio de adesivos-tradutores em modelos infantis de equipamentos.  Como já sabemos, os objetos no contexto do WebGL consistem em um monte de triângulos.  Sozinhos, eles não têm cor.  Para cada triângulo, existe o mesmo "adesivo" triangular com a textura que você precisa colar.  Mas se tivermos 1000 triângulos, precisamos carregar 1000 imagens de textura?  Claro que não.  É feito um sprite, o mesmo que para ícones CSS (você provavelmente os encontrou no trabalho) e informações sobre quais triângulos e onde são adicionados ao próprio modelo.  E então o Three.js já entende tudo de forma independente e vemos o resultado final.  De fato, tudo é um pouco mais complicado, mas a ideia deve ser entendida dessa maneira. </p><br><p>  Galhos de árvores de Natal não são um exemplo muito revelador.  Eles são todos iguais.  A estrutura dessa textura será muito melhor vista no exemplo de um bulbasaur: </p><br><p><img src="https://habrastorage.org/webt/lc/op/bq/lcopbq_gxwwf7y-yuevk5bom3n8.jpeg"></p><br><p>  Mas palavras suficientes, vamos começar a ação.  Inicialize a textura e carregue uma imagem com ela: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ TEXTURE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Texture(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ IMAGE_LOADER.load(<span class="hljs-string"><span class="hljs-string">'./texture.jpg'</span></span>, (image) =&gt; { TEXTURE.image = image; TEXTURE.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }); }</code> </pre> <br><p>  Agora precisamos expandir a função de carregamento do modelo.  Se tivéssemos a mesma textura que o bulbasaur, tudo seria simples.  Mas com uma árvore de Natal, a textura cobre apenas os galhos.  É necessário separá-los de alguma forma e aplicá-los apenas a eles.  Como fazer isso?  Você pode abordar esse problema de maneiras diferentes.  É hora de usar o console.log e ver o próprio modelo. </p><br><blockquote>  Se você não sabe como destacar uma parte específica do modelo, use console.log.  Geralmente, é a maneira mais rápida de descobrir como as peças diferem. </blockquote><p>  Normalmente, temos duas opções para dividir o modelo em partes.  A primeira (boa) é quando o artista 3D assinou as partes componentes do modelo e temos acesso aos campos de nome delas e podemos determinar a partir delas o que é o quê.  No nosso exemplo, isso não é, mas existem nomes de materiais.  Nós vamos usá-los.  Para partes do modelo do material "Christmas_Tree", usaremos a textura: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ OBJ_LOADER.load(<span class="hljs-string"><span class="hljs-string">'./model.obj'</span></span>, (object) =&gt; { object.traverse(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (child.material.name) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'Christmas_Tree'</span></span>: child.material.map = TEXTURE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// . . . } } }); // . . .</span></span></code> </pre> <br><p>  Então, temos algo parecido com isto: </p><br><p><img src="https://habrastorage.org/webt/pi/zw/ab/pizwab2a2sf46kuxndt_a06qn2s.jpeg"></p><br><p>  Para peças feitas de materiais “vermelhos” e “rosa” (estas são bolas - bolas de Natal), simplesmente definimos uma cor aleatória.  Nesses casos, é conveniente usar o HSL: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (child.material.name) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'Christmas_Tree'</span></span>: child.material.map = TEXTURE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'red'</span></span>: child.material.color.setHSL(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'pink'</span></span>: child.material.color.setHSL(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><blockquote>  Nota para artistas: dê nomes significativos a tudo nos modelos.  Os nomes dos materiais em nosso exemplo simplesmente quebram o cérebro.  Aqui o vermelho pode ser verde.  Não os mudei para mostrar todo o absurdo do que estava acontecendo.  O nome abstrato "material para bolas" seria mais universal. </blockquote><br><h2 id="equirectangular-projection">  Projeção equiretangular </h2><br><p>  A palavra composta projeção equiretangular na tradução para o russo é projeção igual a intermediária.  Traduzido em casa - puxou a bola em um retângulo.  Você pode me citar.  Todos nós vimos um mapa-múndi na escola - é retangular, mas entendemos que, se o transformarmos um pouco, teremos um globo.  É isso.  Para entender melhor como essas distorções são organizadas, dê uma olhada na imagem: </p><br><p><img src="https://habrastorage.org/webt/9f/mm/pq/9fmmpqqzen-c2sfcngzrjmfzkto.jpeg"></p><br><p>  Ao criar miniaturas de produtos diferentes, o plano de fundo geralmente é feito usando essas projeções.  Tiramos uma foto distorcida com o ambiente e a exibimos em uma grande esfera.  A câmera parece estar dentro dela.  Parece algo como isto: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sphere = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereGeometry(<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); sphere.scale(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Texture(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial({ <span class="hljs-attr"><span class="hljs-attr">map</span></span>: texture }); IMAGE_LOADER.load(<span class="hljs-string"><span class="hljs-string">'./world.jpg'</span></span>, (image) =&gt; { texture.image = image; texture.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }); SCENE.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Mesh(sphere, material)); }</code> </pre> <br><p>  Como exemplo, minei deliberadamente as bordas; portanto, se você usar o exemplo no github, poderá encontrar uma costura distinta ao longo da qual a imagem se fecha.  Se alguém estiver interessado, o original é retirado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> . </p><br><p>  Total no momento, temos algo parecido com isto: </p><br><p><img src="https://habrastorage.org/webt/dh/ps/tj/dhpstjadkcyb9i1cjtzlxu7t-wi.jpeg"></p><br><p>  Uma árvore de Natal com bolas coloridas parece bem fofa. </p><br><h2 id="orbit-controls">  Controles de órbita </h2><br><p>  Para apreciar a beleza de uma sala tridimensional, adicione o controle do mouse.  E então tudo parece estar em 3D, você precisa torcer tudo.  Normalmente, o OrbitControls é usado nessas tarefas. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initControls</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CONTROLS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.OrbitControls(CAMERA); CONTROLS.minPolarAngle = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; CONTROLS.maxPolarAngle = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * <span class="hljs-number"><span class="hljs-number">3</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; CONTROLS.update(); }</code> </pre> <br><p>  É possível definir restrições nos ângulos pelos quais você pode girar a câmera, restrições no zoom e outras opções.  É útil olhar para a documentação, há muitas coisas interessantes. </p><br><p>  Você não pode dizer muito sobre esse tipo de controle.  Conectado, ligado e funciona.  Só não se esqueça de atualizar regularmente o estado: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); CONTROLS.update(); render(); }</code> </pre> <br><p>  <em>Aqui você pode se distrair, torcer a árvore de Natal em diferentes direções ...</em> </p><br><h2 id="raycaster">  Raycaster </h2><br><p>  O Raycaster permite que você faça o seguinte: desenha uma linha reta no espaço e encontra todos os objetos com os quais se cruzou.  Isso permite que você faça muitas coisas interessantes diferentes, mas no contexto das apresentações do produto, haverá dois casos principais - isso é reagir ao passar o mouse sobre algo e reagir a um clique do mouse em algo.  Para fazer isso, você precisará desenhar linhas perpendiculares à tela através de um ponto com as coordenadas do mouse e procurar interseções.  É isso que faremos.  Estenda a função render, procure interseções com bolas e repinte-as: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ RAYCASTER.setFromCamera(MOUSE, CAMERA); paintHoveredBalls(); <span class="hljs-comment"><span class="hljs-comment">// . . . } function paintHoveredBalls() { if (OBJECT) { const intersects = RAYCASTER.intersectObjects(OBJECT.children); for (let i = 0; i &lt; intersects.length; i++) { switch (intersects[i].object.material.name) { case 'red': intersects[i].object.material.color.set(0x000000); break; case 'pink': intersects[i].object.material.color.set(0xffffff); break; } } } }</span></span></code> </pre> <br><p>  Com movimentos simples do mouse para frente e para trás, garantimos que tudo funcione. </p><br><p><img src="https://habrastorage.org/webt/4z/lp/ti/4zlptiw4eiggtfnkmpglprqlcu8.jpeg"></p><br><p>  Mas há uma sutileza - o Three.js não sabe como alterar as cores suavemente.  E, em geral, essa biblioteca não trata de alterações suaves nos valores.  Aqui é o momento de conectar alguma ferramenta projetada para isso, por exemplo Anime.js. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/animejs@2.2.0/anime.min.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Usamos esta biblioteca para animar valores: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (intersects[i].object.material.name) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'red'</span></span>: <span class="hljs-comment"><span class="hljs-comment">// intersects[i].object.material.color.set(0x000000); anime({ targets: intersects[i].object.material.color, r: 0, g: 0, b: 0, easing: 'easeInOutQuad' }); break; // . . . }</span></span></code> </pre> <br><p>  Agora as cores mudam sem problemas, mas somente depois que o mouse se afasta da bola.  Algo precisa ser consertado.  Usaremos símbolos para isso - eles nos permitem adicionar com segurança informações meta aos objetos, e precisamos apenas adicionar informações sobre se a bola é animada ou não. </p><br><blockquote>  Símbolos no ES6 + é uma ferramenta muito poderosa que, entre outras coisas, permite adicionar informações a objetos de bibliotecas de terceiros sem medo de que isso leve a um conflito de nome ou quebre a lógica. </blockquote><p>  Fazemos uma constante global (em teoria, valeria a pena criar um objeto global para todos esses símbolos, mas temos um exemplo simples, não o complicaremos): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _IS_ANIMATED = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'is animated'</span></span>);</code> </pre> <br><p>  E adicionamos uma verificação à função de repintar as bolas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!intersects[i].object[_IS_ANIMATED]) { anime({ <span class="hljs-attr"><span class="hljs-attr">targets</span></span>: intersects[i].object.material.color, <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">'easeInOutQuad'</span></span> }); intersects[i].object[_IS_ANIMATED] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Agora eles repintam suavemente imediatamente ao passar o mouse.  Assim, com a ajuda de símbolos, você pode adicionar rapidamente verificações semelhantes em animações sem salvar os estados de todas as bolas em um local separado. </p><br><h2 id="vsplyvayuschie-podskazki">  Dicas de ferramentas </h2><br><p>  A última coisa que fazemos hoje são as dicas de ferramentas.  Esta tarefa é frequentemente encontrada.  Para iniciantes, precisamos apenas inventá-los. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'popup-3d'</span></span></span><span class="hljs-tag">&gt;</span></span>  !<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.popup-3d</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">font-family</span></span>: <span class="hljs-string"><span class="hljs-string">'Pacifico'</span></span>, cursive; <span class="hljs-attribute"><span class="hljs-attribute">font-size</span></span>: <span class="hljs-number"><span class="hljs-number">10rem</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">pointer-events</span></span>: none; }</code> </pre> <br><blockquote>  Lembre-se de desativar os eventos do ponteiro se não precisar deles. </blockquote><p>  Resta adicionar CSS3DRenderer.  Na verdade, isso não é um renderizador, é algo que simplesmente adiciona transformações CSS aos elementos e parece que eles estão em uma cena comum.  Para etiquetas pop-up - é exatamente isso que você precisa.  Criamos a variável global CSSRENDERER, inicializamos e não esquecemos de chamar a função render.  Tudo parece um renderizador comum: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initCSSRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CSSRENDERER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.CSS3DRenderer(); CSSRENDERER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); CSSRENDERER.domElement.style.position = <span class="hljs-string"><span class="hljs-string">'absolute'</span></span>; CSSRENDERER.domElement.style.top = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CAMERA.lookAt(SCENE.position); RENDERER.render(SCENE, CAMERA); CSSRENDERER.render(SCENE, CAMERA); }</code> </pre> <br><p>  Nada aconteceu no momento.  Na verdade, não fizemos nada.  Inicializamos o elemento pop-up, podemos brincar imediatamente com seu tamanho e posição no espaço: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initPopups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popupSource = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.popup-3d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.CSS3DObject(popupSource); popup.position.x = <span class="hljs-number"><span class="hljs-number">0</span></span>; popup.position.y = <span class="hljs-number"><span class="hljs-number">-10</span></span>; popup.position.z = <span class="hljs-number"><span class="hljs-number">30</span></span>; popup.scale.x = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; popup.scale.y = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; popup.scale.z = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(popup); SCENE.add(popup); }</code> </pre> <br><p>  Agora vemos a inscrição "em 3D".  Na verdade, não é totalmente em 3D, está no topo da tela, mas para dicas pop-up não é tão importante, o efeito é importante </p><br><p>  O último toque permanece - para mostrar suavemente a inscrição em um determinado intervalo de ângulos.  Mais uma vez, use o símbolo global: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _IS_VISIBLE = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'is visible'</span></span>);</code> </pre> <br><p>  E atualizamos o estado do elemento pop-up, dependendo do ângulo de rotação da câmera: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePopups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popupSource = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.popup-3d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> angle = CONTROLS.getAzimuthalAngle(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(angle) &gt; <span class="hljs-number"><span class="hljs-number">.9</span></span> &amp;&amp; popupSource[_IS_VISIBLE]) { anime({ <span class="hljs-attr"><span class="hljs-attr">targets</span></span>: popupSource, <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">'easeInOutQuad'</span></span> }); popupSource[_IS_VISIBLE] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(angle) &lt; <span class="hljs-number"><span class="hljs-number">.9</span></span> &amp;&amp; !popupSource[_IS_VISIBLE]) { anime({ <span class="hljs-attr"><span class="hljs-attr">targets</span></span>: popupSource, <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">'easeInOutQuad'</span></span> }); popupSource[_IS_VISIBLE] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Tudo é bem simples.  Agora a inscrição aparece suavemente e desaparece.  Você pode adicionar rotação automática e aproveitar o resultado. </p><br><pre> <code class="javascript hljs">CONTROLS.autoRotate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CONTROLS.autoRotateSpeed = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/w6/c3/54/w6c354h5duszg2rud08wc237mwq.jpeg"></p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Hoje, vimos como exibir modelos tridimensionais em nossa página, como transformá-los com o mouse, como fazer dicas de ferramentas, como responder ao mouse pairando sobre certas partes do modelo e como usar caracteres no contexto de várias animações.  Espero que esta informação seja útil.  Bem, tudo com o próximo, agora você sabe o que pode aprender durante as férias. </p><br><p>  PS: As fontes completas para o exemplo de espinha de peixe estão disponíveis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433876/">https://habr.com/ru/post/pt433876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433866/index.html">"Home lokalki" renasce na forma de redes de malha. LibreRouter e outros roteadores gratuitos</a></li>
<li><a href="../pt433868/index.html">Por que o medidor de glicose do Alphabet não voou</a></li>
<li><a href="../pt433870/index.html">Por que é tão difícil medir continuamente a glicose?</a></li>
<li><a href="../pt433872/index.html">Acesso móvel - usando um smartphone em sistemas de controle de acesso</a></li>
<li><a href="../pt433874/index.html">Experiências de interface neural JavaScript</a></li>
<li><a href="../pt433878/index.html">KVM, passagem de PCI, espelho e tudo-tudo-tudo</a></li>
<li><a href="../pt433880/index.html">Dicas de vida para desenvolvedores: usando o SQ (qualificador de origem) com eficiência no Informatica Power Center</a></li>
<li><a href="../pt433884/index.html">Aspectos legais da vigilância por vídeo: como evitar problemas com a lei</a></li>
<li><a href="../pt433886/index.html">Aprendizado de máquina Python com demonstrações interativas do Jupyter</a></li>
<li><a href="../pt433888/index.html">O uso de baterias de íon de lítio no no-break monofásico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>