<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ 💶 🎅🏿 如何在Go中使用Postgres：做法，功能，细微差别 👇🏽 ⏹️ 😿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="该应用程序与使用数据库有关的意外行为导致DBA和开发人员之间发生战争：DBA大喊：“您的应用程序删除了数据库”，开发人员-“但是，以前一切正常！” 最糟糕的是，DBA和开发人员无法互相帮助：有些人不了解应用程序和驱动程序的细微差别，另一些人不了解与基础架构相关的功能。 避免这种情况将很不错。 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在Go中使用Postgres：做法，功能，细微差别</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461935/"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p> 该应用程序与使用数据库有关的意外行为导致DBA和开发人员之间发生战争：DBA大喊：“您的应用程序删除了数据库”，开发人员-“但是，以前一切正常！” 最糟糕的是，DBA和开发人员无法互相帮助：有些人不了解应用程序和驱动程序的细微差别，另一些人不了解与基础架构相关的功能。 避免这种情况将很不错。 </p><br><p> 您必须了解，浏览<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-database-sql.org</a>通常是不够的。 最好用他人的经验武装自己。 如果这是一次鲜血和金钱损失的经验，那就更好了。 </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 我的名字叫<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ryabinkov Artemy</a> ，本文是对我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saints HighLoad 2019</a>大会上的报告的免费解释。 </p><br><h1 id="instrumenty"> 工具 </h1><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-database-sql.org</a>上找到有关如何使用任何类似SQL的数据库的最少必需信息。 如果您尚未阅读，请阅读。 </p><br><h2 id="sqlx">  sqlx </h2><br><p> 在我看来，Go的强大之处在于简单性。 例如，这表示Go习惯以裸SQL编写查询（ORM不受欢迎）。 这既是优势又是其他困难的根源。 </p><br><p>因此，采用标准的<code>database/sql</code>语言包，您将需要扩展其接口。 一旦发生这种情况，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/jmoiron/sqlx</a> 。 让我向您展示一些有关此扩展如何简化您的生活的示例。 </p><br><p> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StructScan</a>无需手动将数据从列移入结构属性。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NamedQuery</a> ，您可以将结构属性用作查询中的占位符。 </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p> 使用“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">获取</a>并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择”</a>使您无需手动编写从数据库获取行的循环。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery"> 车手 </h1><br><p>  <code>database/sql</code>是用于处理数据库的一组接口，而<code>sqlx</code>是它们的扩展。 为了使这些接口起作用，它们需要一个实现。 驱动程序负责实施。 </p><br><p> 最受欢迎的驱动程序： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/lib/pq-</a> <code>pure Go Postgres driver for database/sql.</code> 该驱动程序长期以来一直是默认标准。 但是今天，它已经失去了相关性，作者尚未开发。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/jackc/pgx-</a> <code>PostgreSQL driver and toolkit for Go.</code> 今天最好选择此工具。 </li></ul><br><p>  <strong>github.com/jackc/pgx-</strong>这是您要使用的驱动程序。 怎么了 </p><br><ul><li> 积极<strong>支持和发展</strong> 。 </li><li> 如果在没有<code>database/sql</code>接口的情况下使用它，则可以提高<strong>生产率</strong> 。 </li><li> 支持<code>PostgreSQL</code>在<code>SQL</code>标准之外实现的<strong>60多种PostgreSQL</strong> 。 </li><li> 方便地实现驱动程序内部事件<strong>记录</strong>的功能。 </li><li>  <code>pgx</code> <strong>人类可读的错误</strong> ，而<code>lib/pq</code>引发恐慌攻击。 如果您没有惊慌，程序将崩溃。  （ <em>您不应在Go中使用恐慌，这与异常不同。</em> ） </li><li> 使用<code>pgx</code> ，我们可以独立<strong>配置每个连接</strong> 。 </li><li> 支持<code>PostgreSQL</code> <strong>逻辑复制协议</strong> 。 </li></ul><br><h2 id="4kb">  4KB </h2><br><p> 通常，我们编写此循环以从数据库获取数据： </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p> 在驱动程序内部，我们通过将数据存储在<strong>4KB缓冲区中来</strong>获取数据。  <code>rows.Next()</code>产生网络行程并填充缓冲区。 如果缓冲区不足，那么我们将进入网络以获取剩余数据。 更多的网络访问-更低的处理速度。 另一方面，由于缓冲区限制为4KB，所以请不要忘记整个进程的内存。 </p><br><p> 但是，当然，我想最大程度地松开缓冲区数量，以减少对网络的请求数量并减少我们的服务延迟。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们增加了</a>这个机会，并尝试找出<a href="">综合测试</a>的预期加速： </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p> 可以看出，处理速度没有太大差异。 为什么这样 </p><br><p> 事实证明，我们受Postgres自身内部用于发送数据的缓冲区大小的限制。 该缓冲区的<a href="">固定</a>大小为<strong>8KB</strong> 。 使用<code>strace</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以看到</a> OS在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">读取的</a>系统调用中返回了<code>8192</code>字节。  <code>tcpdump</code>通过数据包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>大小来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">确认</a>这一点。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tom Lane</a> （ <em>Postgres内核的核心开发人员之一</em> ） <a href="">评论</a>如下： </p><br><blockquote> 至少传统上，这至少是Unix计算机中管道缓冲区的大小，因此，原则上，这是通过Unix套接字发送数据的最佳块大小。 </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andres Freund</a> （ <em>EnterpriseDB的Postgres开发人员</em> ） <a href="">认为</a> ，迄今为止8KB缓冲区并不是最佳的实现选项，您需要在不同大小和不同套接字配置下测试行为。 </p><br><p> 我们还必须记住，PgBouncer也有一个缓冲区，可以使用<code>pkt_buf</code>参数配置其大小。 </p><br><h2 id="oids">  OID </h2><br><p>  pgx（ <em>v3</em> ）驱动程序的另一个功能：对于每个连接，它都会向数据库发出请求以获取有关<strong>对象ID</strong> （ <em>OID</em> ）的信息。 </p><br><p> 这些标识符已添加到Postgres中，以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唯一标识</a>内部对象：行，表，函数等。 </p><br><p> 驱动程序使用<code>OIDs</code>知识来了解将哪种数据库列添加到哪种语言原语中以添加数据。 为此， <code>pgx</code>支持这样的表（ <em>键是类型名，值是Object ID</em> ） </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p> 这种实现导致以下事实：与数据库的每个已建立连接的驱动程序都会发出大约三个请求，以形成具有<code>Object ID</code>的表。 在数据库和应用程序的正常操作模式下，Go中的连接池允许您不生成与数据库的新连接。 但是，即使数据库降级了一点点，应用程序侧的连接池也已耗尽，并且每单位时间生成的连接数显着增加。 对<code>OIDs</code>请求非常繁重，因此，驱动程序可以使数据库进入临界状态。 </p><br><p> 这是将此类请求注入我们的数据库之一的时刻： </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p> 在正常模式下， <strong>每分钟15</strong> <strong>个事务</strong> ，降级期间最多可跳跃<strong>6500个事务</strong> 。 </p><br><p>  <strong>怎么办</strong> </p><br><p> 首先，从上方限制池的大小。 </p><br><p> 对于<code>database/sql</code>可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DB.SetMaxOpenConns</a>函数来完成。 如果放弃<code>database/sql</code>接口并使用<code>pgx.ConnPool</code> （ <em>由驱动程序本身实现</em>的<em>连接池</em> ），则可以<code>MaxConnections</code>指定<code>MaxConnections</code> （ <em>默认值为5</em> ）。 </p><br><p> 顺便说一句，当使用<code>pgx.ConnPool</code>驱动程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将重用</a>有关接收到的<code>OIDs</code>信息，并且不会为每个新连接对数据库进行查询。 </p><br><p> 如果您不想拒绝<code>database/sql</code> ，则可以自己缓存有关<code>OIDs</code>信息。 </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p> 这是一种可行的方法，但是在两种情况下使用它可能会很危险： </p><br><ul><li> 您在Postgres中使用枚举或域类型； </li><li> 如果向导失败，则将应用程序切换到由逻辑复制注入的副本。 </li></ul><br><p> 满足这些条件将导致缓存的<code>OIDs</code>无效。 但是我们无法清理它们，因为我们不知道换新基地的时刻。 </p><br><p> 在<code>Postgres</code>世界中，通常使用物理复制来组织高可用性，这种复制会一点一点地复制数据库实例，因此<code>OIDs</code>缓存的问题很少在野外出现。  （ <em>但是最好与您的DBA一起检查备用数据库的工作方式</em> ）。 </p><br><p> 在<code>pgx</code>驱动程序<code>pgx</code>的下一个主要版本中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将没有</a>针对<code>OIDs</code>活动。 现在，驱动程序将仅依赖在代码中<code>OIDs</code>的<code>OIDs</code>列表。 对于自定义类型，您将需要在应用程序端控制反序列化：驱动程序将简单地放弃一块内存作为字节数组。 </p><br><h1 id="logirovanie-i-monitoring"> 记录与监控 </h1><br><p> 监视和记录将有助于在基础崩溃之前发现问题。 </p><br><p>  <code>database/sql</code>提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DB.Stats（）</a>方法。 返回的状态快照将使您了解驱动程序内部正在发生的情况。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool State OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p> 如果直接在<code>pgx</code>使用池，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConnPool.Stat（）</a>方法将为您提供类似信息： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p> 日志记录同样重要，并且<code>pgx</code>允许您执行此操作。 驱动程序接受<code>Logger</code>接口，通过实现该接口，您可以获得驱动程序内部发生的所有事件。 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p> 最有可能的是，您甚至不必自己实现此接口。 开箱即用的<code>pgx</code>中有一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组</a>适用于最受欢迎的记录器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的适配器</a> ，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uber-go / zap</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sirupsen / logrus</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rs / zerolog</a> 。 </p><br><h1 id="infrastruktura"> 基础设施 </h1><br><p> 在使用<code>Postgres</code>时，几乎总是使用<strong>连接池</strong> ，它将是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PgBouncer</a> （ <em>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奥德赛</a> -如果您是Yandex的话</em> ）。 </p><br><p> 为什么这样，您可以阅读出色的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">brandur.org/postgres-connections</a> 。 简而言之，当客户端数量<strong>超过100时，</strong>处理请求<strong>的</strong>速度开始下降。 发生这种情况的原因是Postgres本身实现的功能：为每个连接启动一个独立的进程，删除快照的机制以及使用共享内存进行交互-所有这些都会影响。 </p><br><p> 这是各种连接池实现的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基准</a> ： <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p> 具有和不具有PgBouncer的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基准</a>带宽。 </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p> 结果，您的基础结构将如下所示： </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  <code>Server</code>是处理用户请求的过程。 此过程将<code>kubernetes</code> 3个副本（ <em>至少</em> ）。 另外，在铁质服务器上有<code>Postgres</code> ，由<code>PgBouncer'</code>覆盖。  <code>PgBouncer</code>本身<code>PgBouncer</code>单线程的，因此我们启动了多个启动器，使用<code>HAProxy</code>可以平衡流量。 结果，我们在数据库中获得了这样的查询执行链： <code>   → HAProxy → PgBouncer → Postgres</code> 。 </p><br><p>  <code>PgBouncer</code>可以在三种模式下工作： </p><br><ul><li>  <strong>会话池</strong> -对于每个会话，在整个生命周期内都会发出一个连接并将其分配给该连接。 </li><li>  <strong>事务池</strong> -事务运行时连接有效。 交易完成后， <code>PgBouncer</code>会立即建立此连接并将其返回给另一笔交易。 此模式可以很好地处理化合物。 </li><li>  <strong>语句池</strong> - <strong>不建议使用的</strong>模式。 创建它仅是为了支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PL / Proxy</a> 。 </li></ul><br><p> 您可以看到每种模式下可用属性的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">矩阵</a> 。 我们选择<strong>事务池</strong> ，但是它在使用<code>Prepared Statements</code>方面有局限性。 </p><br><h2 id="transaction-pooling--prepared-statements"> 事务池+预备语句 </h2><br><p> 假设我们要准备一个请求然后执行它。 在某个时候，我们开始一个事务，在该事务中发送一个Prepare请求，然后从数据库中获取已准备请求的ID。 </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p> 之后，我们会在其他任何时间生成另一​​笔交易。 在其中，我们转到数据库，并希望使用带有指定参数的标识符来满足请求。 </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p> 在<strong>事务池</strong>模式下，可以在不同的连接中执行两个事务，但是<strong>语句ID</strong>仅在一个连接中有效。 尝试执行请求时，我们得到一个<code>prepared statement does not exist</code>错误。 </p><br><p> 最不愉快的是：由于在开发和测试过程中负载很小，因此<code>PgBouncer</code>经常发出相同的连接，并且一切正常。 但是，一旦我们推出产品，请求就会因错误而下降。 </p><br><p> 现在，在以下代码中找到“ <code>Prepared Statements</code> ： </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p> 你不会看到他的！ 查询准备将隐式发生在<code>Query()</code>内部。 同时，请求的准备和执行将在不同的事务中进行，我们将完全收到我上述的所有信息。 </p><br><p>  <strong>怎么办</strong> </p><br><p> 第一个最简单的选择是将<strong><code>PgBouncer</code>切换到<code>Session pooling</code></strong> 。 一个连接分配给该会话，所有事务都开始进入该连接，并且准备好的请求正常工作。 但是在这种模式下，化合物的利用效率尚待提高。 因此，不考虑此选项。 </p><br><p> 第二种选择是<strong>在客户端准备请求</strong> 。 我不想这样做有两个原因： </p><br><ul><li> 潜在的SQL漏洞。 开发人员可能会忘记或错误地进行转义。 </li><li> 每次必须用手书写时，都转义查询参数。 </li></ul><br><p> 另一种选择是<strong>将每个请求显式包装在事务中</strong> 。 毕竟，只要交易有效， <code>PgBouncer</code>就不会建立连接。 这行得通，但是，除了代码中的冗长之外，我们还获得了更多的网络调用：开始，准备，执行，提交。 每个请求共4个网络通话。 延迟在增长。 </p><br><p> 但我希望它既安全又方便又有效。 并且有这样的选择！ 您可以明确告知驱动程序您要<strong>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简单查询</a>模式</strong> 。 在这种模式下，将不需要任何准备，整个请求将通过一个网络呼叫传递。 在这种情况下，驱动程序将自行屏蔽每个参数（ <em>必须在基本级别或建立连接时激活<code>standard_conforming_strings</code></em> ）。 </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov"> 取消要求 </h1><br><p> 以下问题与在应用程序端取消请求有关。 </p><br><p> 看一下这段代码。 陷阱在哪里？ </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go有一个控制程序执行流程的方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-context.Context</a> 。 在此代码中，我们将<code>ctx</code>传递<code>ctx</code>驱动程序，以便在关闭上下文时，驱动程序在数据库级别取消请求。 </p><br><p> 同时，我们希望通过取消没有人等待的请求来节省资源。 但是，当请求被<code>PgBouncer</code> <em>1.7</em>版会将信息发送到该连接，该连接已准备就绪，可以使用，然后将其返回到池中。  <code>PgBouncer'</code>这种行为会误导驱动程序，该驱动程序在发送下一个请求时会立即收到<code>ReadyForQuery</code>作为响应。 最后，我们捕获了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">意外的ReadyForQuery错误</a> 。 </p><br><p> 从<code>PgBouncer</code> <em>1.8</em>版开始<em>，</em>此行为已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">得到修复</a> 。 使用当前版本的<code>PgBouncer</code> 。 </p><br><p> 而且，尽管在这种情况下，错误将消失-有趣的行为仍将保留。 在某些情况下，我们的应用程序可能收到的不是其请求的答案，而是相邻请求的答案（主要是请求与所请求数据的类型和顺序匹配）。 即，例如，对于<code>where user_id = 2</code>的查询<code>where user_id = 42</code>将返回<code>where user_id = 42</code>的查询的响应。 这是由于在不同级别处理取消请求：在驱动程序池和保镖池级别。 </p><br><h3 id="otlozhennaya-otmena"> 延迟取消 </h3><br><p> 要取消请求，我们需要创建与数据库的新连接并请求取消。  <code>Postgres</code>为每个连接创建一个单独的过程。 我们发送命令以在特定过程中取消<strong>当前</strong>请求。 为此，请创建一个新的连接，并在其中将感兴趣的进程ID（PID）传送给我们。 但是，当取消命令飞向基地时，被取消的请求可能会自行结束。 </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code>将执行命令并在给定的过程中取消<strong>当前</strong>请求。 但是当前请求不会是我们最初想要取消的请求。 由于使用<code>PgBouncer</code>与<code>Postgres</code>一起使用时的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这种行为</a> <code>PgBouncer</code>更安全的<code>PgBouncer</code>不要在驱动程序级别取消请求。 为此，您可以设置<code>CustomCancel</code> ，即使使用<code>context.Context</code> ，该<code>CustomCancel</code>也不会取消请求。 </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Postgres清单 </h1><br><p> 我没有得出结论，而是决定制作一份与Postgres合作的清单。 这应该可以使这篇文章适合我的想法。 </p><br><ul><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/jackc/pgx</a>作为使用Postgres的驱动程序。 </li><li> 从上方限制连接池的大小。 </li><li> 缓存<code>OIDs</code>或使用<code>pgx</code>版本3时使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pgx.ConnPool</a> 。 </li><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DB.Stats（）</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConnPool.Stat（）</a>从连接池中收集指标。 </li><li> 记录驱动程序中正在发生的事情。 </li><li> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简单查询</a>模式可以避免在<code>PgBouncer</code>事务模式下查询准备方面的问题。 </li><li> 将<code>PgBouncer</code>更新到最新版本。 </li><li> 取消应用程序的请求时要小心。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461935/">https://habr.com/ru/post/zh-CN461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461919/index.html">在React上重用表单</a></li>
<li><a href="../zh-CN461921/index.html">HDMI-LVDS。 MStar在TSUMV59上的开发</a></li>
<li><a href="../zh-CN461923/index.html">圣彼得堡的JetBrains开放日：视频</a></li>
<li><a href="../zh-CN461927/index.html">主动排名学习</a></li>
<li><a href="../zh-CN461929/index.html">在Linux上监视和检查SSD状态</a></li>
<li><a href="../zh-CN461937/index.html">帕金森定律以及如何破解</a></li>
<li><a href="../zh-CN461939/index.html">石墨烯-Python历险年</a></li>
<li><a href="../zh-CN461941/index.html">按摩一下</a></li>
<li><a href="../zh-CN461945/index.html">2019年8月IT领域HR专业人员的事件摘要</a></li>
<li><a href="../zh-CN461949/index.html">AppCode 2019.2：Swift 5.1，通过测试分析代码覆盖率，显示反汇编代码等</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>