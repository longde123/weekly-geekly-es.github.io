<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª üåΩ üí† Leit√£o vulc√¢nico ou SQL fa√ßa voc√™ mesmo üò∑ üëõ üíÉüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A coleta, armazenamento, convers√£o e apresenta√ß√£o de dados s√£o os principais desafios enfrentados pelos engenheiros de dados. O departamento de Busine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leit√£o vulc√¢nico ou SQL fa√ßa voc√™ mesmo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  A coleta, armazenamento, convers√£o e apresenta√ß√£o de dados s√£o os principais desafios enfrentados pelos engenheiros de dados.  O departamento de Business Intelligence Badoo recebe e processa mais de 20 bilh√µes de eventos enviados a partir de dispositivos do usu√°rio por dia, ou 2 TB de dados recebidos. </p><br><p>  O estudo e a interpreta√ß√£o de todos esses dados nem sempre s√£o uma tarefa trivial, √†s vezes √© necess√°rio ir al√©m das capacidades dos bancos de dados prontos.  E se voc√™ tiver a coragem e decidiu fazer algo novo, primeiro se familiarize com os princ√≠pios de trabalho das solu√ß√µes existentes. </p><br><p>  Em uma palavra, desenvolvedores curiosos e perspicazes, este artigo √© abordado.  Nele, voc√™ encontrar√° uma descri√ß√£o do modelo tradicional de execu√ß√£o de consultas em bancos de dados relacionais, usando a linguagem de demonstra√ß√£o PigletQL como exemplo. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Antecedentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura do interpretador SQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo de vulc√£o e execu√ß√£o de consultas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lexical e parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisador sem√¢ntico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compilando consultas em uma exibi√ß√£o intermedi√°ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execu√ß√£o de uma apresenta√ß√£o intermedi√°ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Operadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de trabalho</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Literatura</a> </li></ul><br><h1 id="predystoriya">  Antecedentes </h1><br><p>  Nosso grupo de engenheiros est√° envolvido em back-end e interfaces, oferecendo oportunidades para an√°lise e pesquisa de dados dentro da empresa (a prop√≥sito, estamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expandindo</a> ).  Nossas ferramentas padr√£o s√£o um banco de dados distribu√≠do de dezenas de servidores (Exasol) e um cluster Hadoop para centenas de m√°quinas (Hive e Presto). </p><br><p>  A maioria das consultas a esses bancos de dados √© anal√≠tica, ou seja, afeta de centenas de milhares a bilh√µes de registros.  Sua execu√ß√£o leva minutos, dezenas de minutos ou at√© horas, dependendo da solu√ß√£o usada e da complexidade da solicita√ß√£o.  Com o trabalho manual do usu√°rio-analista, esse tempo √© considerado aceit√°vel, mas n√£o √© adequado para pesquisa interativa atrav√©s da interface do usu√°rio. </p><br><p>  Com o tempo, destacamos as consultas e consultas anal√≠ticas populares, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dif√≠ceis de definir em termos de</a> SQL, e desenvolvemos pequenos bancos de dados especializados para eles.  Eles armazenam um subconjunto de dados em um formato adequado para algoritmos de compacta√ß√£o leves (por exemplo, streamvbyte), que permitem armazenar dados em uma √∫nica m√°quina por v√°rios dias e executar consultas em segundos. </p><br><p>  As primeiras linguagens de consulta para esses dados e seus int√©rpretes foram implementadas rapidamente, precis√°vamos refin√°-las constantemente e cada vez que levava um tempo inaceitavelmente longo. </p><br><p>  Os idiomas de consulta n√£o eram suficientemente flex√≠veis, embora n√£o houvesse raz√µes √≥bvias para limitar seus recursos.  Como resultado, voltamos √† experi√™ncia dos desenvolvedores de int√©rpretes SQL, gra√ßas √† qual conseguimos resolver parcialmente os problemas que surgiram. </p><br><p>  Abaixo, falarei sobre o modelo de execu√ß√£o de consulta mais comum em bancos de dados relacionais - Volcano.  O c√≥digo fonte do int√©rprete do dialeto SQL primitivo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PigletQL</a> , est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anexado ao artigo</a> , para que todos os interessados ‚Äã‚Äãpossam se familiarizar facilmente com os detalhes no reposit√≥rio. </p><br><h1 id="struktura-interpretatora-sql">  Estrutura do interpretador SQL </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Estrutura de int√©rpretes"></a> </p><br><p>  Os bancos de dados mais populares fornecem uma interface para dados na forma de uma linguagem de consulta SQL declarativa.  Uma consulta na forma de uma sequ√™ncia √© convertida pelo analisador em uma descri√ß√£o da consulta, semelhante a uma √°rvore de sintaxe abstrata.  √â poss√≠vel executar consultas simples j√° neste est√°gio; no entanto, para otimizar transforma√ß√µes e execu√ß√£o subseq√ºente, essa representa√ß√£o √© inconveniente.  Nos bancos de dados conhecidos por mim, representa√ß√µes intermedi√°rias s√£o introduzidas para esses fins. </p><br><p>  A √°lgebra relacional tornou-se um modelo para representa√ß√µes intermedi√°rias.  √â uma linguagem na qual as transforma√ß√µes ( <em>operadores</em> ) executadas nos dados s√£o explicitamente descritas: selecionando um subconjunto dos dados de acordo com um predicado, combinando dados de diferentes fontes, etc. Al√©m disso, a √°lgebra relacional √© uma √°lgebra no sentido matem√°tico, ou seja, um grande n√∫mero equivalente de transforma√ß√µes.  Portanto, √© conveniente realizar transforma√ß√µes otimizadas sobre uma consulta na forma de uma √°rvore de operadores de √°lgebra relacional. </p><br><p>  Existem diferen√ßas importantes entre as representa√ß√µes internas nos bancos de dados e a √°lgebra relacional original; portanto, √© mais correto cham√°-la de <em>√°lgebra l√≥gica</em> . </p><br><p>  A verifica√ß√£o da validade de uma consulta geralmente √© realizada ao compilar a representa√ß√£o inicial da consulta em operadores de √°lgebra l√≥gica e corresponde ao est√°gio de an√°lise sem√¢ntica nos compiladores convencionais.  O papel da tabela de s√≠mbolos nos bancos de dados √© desempenhado pelo <em>diret√≥rio do banco de dados</em> , que armazena informa√ß√µes sobre o esquema e os metadados do banco de dados: tabelas, colunas da tabela, √≠ndices, direitos do usu√°rio etc. </p><br><p>  Comparados com os int√©rpretes de uso geral, os int√©rpretes de banco de dados t√™m mais uma peculiaridade: diferen√ßas no volume de dados e meta-informa√ß√µes sobre os dados nos quais as consultas devem ser feitas.  Em tabelas ou rela√ß√µes em termos de √°lgebra relacional, pode haver uma quantidade diferente de dados; em algumas colunas ( <em>atributos de</em> relacionamento), √≠ndices podem ser constru√≠dos, etc. Ou seja, dependendo do esquema do banco de dados e da quantidade de dados nas tabelas, a consulta deve ser realizada por algoritmos diferentes. e use-os em uma ordem diferente. </p><br><p>  Para resolver este problema, outra representa√ß√£o intermedi√°ria √© introduzida - <em>√°lgebra f√≠sica</em> .  Dependendo da disponibilidade de √≠ndices nas colunas, da quantidade de dados nas tabelas e da estrutura da √°rvore da √°lgebra l√≥gica, s√£o oferecidas diferentes formas da √°rvore da √°lgebra f√≠sica, dentre as quais a melhor op√ß√£o √© escolhida.  √â essa √°rvore que √© mostrada no banco de dados como um plano de consulta.  Nos compiladores convencionais, esse est√°gio corresponde condicionalmente aos est√°gios de aloca√ß√£o de registro, planejamento e sele√ß√£o de instru√ß√µes. </p><br><p>  O √∫ltimo passo no trabalho do int√©rprete √© diretamente a execu√ß√£o da √°rvore de operadores de √°lgebra f√≠sica. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Modelo de vulc√£o e execu√ß√£o de consultas </h1><br><p>  Int√©rpretes de √°lgebra f√≠sica sempre foram usados ‚Äã‚Äãem bancos de dados comerciais fechados, mas a literatura acad√™mica geralmente se refere ao otimizador experimental Volcano, desenvolvido no in√≠cio dos anos 90. </p><br><p>  No modelo Volcano, cada operador de uma √°rvore de √°lgebra f√≠sica se transforma em uma estrutura com tr√™s fun√ß√µes: abrir, fechar, fechar.  Al√©m das fun√ß√µes, o operador cont√©m um estado operacional - estado.  A fun√ß√£o aberta inicia o estado da instru√ß√£o, a pr√≥xima fun√ß√£o retorna a pr√≥xima <em>tupla</em> (tupla em ingl√™s) ou NULL, se n√£o houver tuplas restantes, a fun√ß√£o fechar encerra a instru√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Os operadores podem ser aninhados para formar uma √°rvore de operadores de √°lgebra f√≠sica.  Cada operador, portanto, itera sobre as tuplas de uma rela√ß√£o existente em um meio real ou de uma rela√ß√£o virtual formada pela enumera√ß√£o das tuplas de operadores aninhados: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  Em termos de linguagens modernas de alto n√≠vel, a √°rvore desses operadores √© uma cascata de iteradores. </p><br><p>  At√© os int√©rpretes de consulta industrial no DBMS relacional s√£o repelidos do modelo Volcano, foi por isso que tomei isso como base do interpretador PigletQL. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Para demonstrar o modelo, desenvolvi o int√©rprete da linguagem de consulta limitada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PigletQL</a> .  Est√° escrito em C, suporta a cria√ß√£o de tabelas no estilo SQL, mas est√° limitado a um √∫nico tipo - n√∫meros inteiros positivos de 32 bits.  Todas as tabelas est√£o na mem√≥ria.  O sistema opera em um √∫nico encadeamento e n√£o possui um mecanismo de transa√ß√£o. </p><br><p>  N√£o h√° otimizador no PigletQL, e as consultas SELECT s√£o compiladas diretamente na √°rvore do operador da √°lgebra f√≠sica.  O restante das consultas (CREATE TABLE e INSERT) funciona diretamente das visualiza√ß√µes internas principais. </p><br><p>  Exemplo de sess√£o do usu√°rio no PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Lexical e parser </h2><br><p>  O PigletQL √© uma linguagem muito simples e sua implementa√ß√£o n√£o foi necess√°ria nas etapas de an√°lise lexical e de an√°lise. </p><br><p>  O analisador lexical √© escrito √† m√£o.  Um objeto analisador ( <a href="">scanner_t</a> ) √© criado a partir da string de consulta, que fornece tokens um por um: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  A an√°lise √© feita usando o m√©todo de descida recursiva.  Primeiro, √© <a href="">criado</a> o objeto <a href="">parser_t</a> , que, ap√≥s receber o analisador lexical (scanner_t), preenche o objeto query_t com informa√ß√µes sobre a solicita√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  O resultado da an√°lise em query_t √© um dos tr√™s tipos de consulta suportados pelo PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  O tipo mais complexo de consulta no PigletQL √© SELECT.  Corresponde √† <a href="">estrutura de</a> dados <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  A estrutura cont√©m uma descri√ß√£o da consulta (uma matriz de atributos solicitados pelo usu√°rio), uma lista de fontes de dados - relacionamentos, uma matriz de predicados, filtrando tuplas e informa√ß√µes sobre o atributo usado para classificar os resultados. </p><br><h2 id="semanticheskiy-analizator">  Analisador sem√¢ntico </h2><br><p>  A fase de an√°lise sem√¢ntica no SQL regular envolve a verifica√ß√£o da exist√™ncia das tabelas listadas, colunas nas tabelas e verifica√ß√£o de tipo nas express√µes de consulta.  Para verifica√ß√µes relacionadas a tabelas e colunas, √© usado o diret√≥rio do banco de dados, onde todas as informa√ß√µes sobre a estrutura de dados s√£o armazenadas. </p><br><p>  N√£o h√° express√µes complexas no PigletQL, portanto, a verifica√ß√£o de consultas √© reduzida √† verifica√ß√£o de metadados de cat√°logo de tabelas e colunas.  As consultas SELECT, por exemplo, s√£o <a href="">validadas</a> pela fun√ß√£o <a href="">validate_select</a> .  Vou traz√™-lo de forma abreviada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Se a solicita√ß√£o for v√°lida, a pr√≥xima etapa √© compilar a √°rvore de an√°lise em uma √°rvore do operador. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Compilando consultas em uma exibi√ß√£o intermedi√°ria </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  Em int√©rpretes SQL completos, geralmente existem duas representa√ß√µes intermedi√°rias: √°lgebra l√≥gica e f√≠sica. </p><br><p>  Um interpretador PigletQL simples executa consultas CREATE TABLE e INSERT diretamente de suas √°rvores de an√°lise, ou seja, <a href="">estruturas query_create_table_t</a> e <a href="">query_insert_t</a> .  As consultas SELECT mais complexas s√£o compiladas em uma √∫nica representa√ß√£o intermedi√°ria, que ser√° executada pelo int√©rprete. </p><br><p>  A √°rvore do operador √© criada das folhas para a raiz na seguinte sequ√™ncia: </p><br><ol><li><p>  Na parte direita da consulta ("... FROM rela√ß√£o1, rela√ß√£o2, ..."), s√£o obtidos os nomes das rela√ß√µes desejadas, para cada uma das quais uma instru√ß√£o de varredura √© criada. </p><br></li><li><p>  Extraindo tuplas das rela√ß√µes, os operadores de verifica√ß√£o s√£o combinados em uma √°rvore bin√°ria do lado esquerdo atrav√©s do operador de jun√ß√£o. </p><br></li><li><p>  Os atributos solicitados pelo usu√°rio ("SELECT attr1, attr2, ...") s√£o selecionados pela instru√ß√£o do projeto. </p><br></li><li><p>  Se algum predicado for especificado ("... WHERE a = 1 AND b&gt; 10 ..."), a instru√ß√£o select ser√° adicionada √† √°rvore acima. </p><br></li><li><p>  Se o m√©todo para classificar o resultado for especificado ("... ORDER BY attr1 DESC"), o operador de classifica√ß√£o ser√° adicionado √† parte superior da √°rvore. </p><br></li></ol><br><p>  Compila√ß√£o no <a href="">c√≥digo</a> PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Depois que a √°rvore √© formada, geralmente s√£o realizadas transforma√ß√µes otimizadas, mas o PigletQL continua imediatamente para o est√°gio de execu√ß√£o da representa√ß√£o intermedi√°ria. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Execu√ß√£o de uma apresenta√ß√£o intermedi√°ria </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  O modelo Volcano implica uma interface para trabalhar com operadores por meio de tr√™s opera√ß√µes comuns de abrir / pr√≥ximo / fechar.  Em ess√™ncia, cada declara√ß√£o do Volcano √© um iterador do qual as tuplas s√£o "puxadas" uma a uma, portanto, essa abordagem de execu√ß√£o tamb√©m √© chamada de modelo pull. </p><br><p>  Cada um desses iteradores pode chamar as mesmas fun√ß√µes de iteradores aninhados, criar tabelas tempor√°rias com resultados intermedi√°rios e converter as tuplas recebidas. </p><br><p>  Executando <a href="">consultas SELECT</a> no PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  A solicita√ß√£o √© compilada primeiro pela fun√ß√£o compile_select, que retorna a raiz da √°rvore do operador, ap√≥s a qual as mesmas fun√ß√µes de abrir / fechar / fechar s√£o chamadas no operador raiz.  Cada chamada para a pr√≥xima retorna a pr√≥xima tupla ou NULL.  No √∫ltimo caso, isso significa que todas as tuplas foram extra√≠das e a fun√ß√£o de iterador pr√≥ximo deve ser chamada. </p><br><p>  As tuplas resultantes s√£o recalculadas e produzidas pela tabela no fluxo de sa√≠da padr√£o. </p><br><h2 id="operatory">  Operadores </h2><br><p>  A coisa mais interessante sobre o PigletQL √© a √°rvore do operador.  Vou mostrar o dispositivo de alguns deles. </p><br><p>  <a href="">Os</a> operadores t√™m uma <a href="">interface</a> comum e consistem em ponteiros para a fun√ß√£o abrir / pr√≥ximo / fechar e uma fun√ß√£o de destrui√ß√£o adicional, que libera os recursos de toda a √°rvore do operador de uma s√≥ vez: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  Al√©m das fun√ß√µes, o operador pode conter um estado interno arbitr√°rio (ponteiro de estado). </p><br><p>  Abaixo, analisarei o dispositivo de dois operadores interessantes: a varredura mais simples e a cria√ß√£o de um tipo de rela√ß√£o intermedi√°ria. </p><br><h3 id="operator-scan">  Declara√ß√£o de digitaliza√ß√£o </h3><br><p>  A instru√ß√£o que inicia qualquer consulta √© varredura.  Ele apenas passa por todas as tuplas do relacionamento.  <a href="">O estado interno da varredura</a> √© um ponteiro para a rela√ß√£o de onde as tuplas ser√£o recuperadas, o √≠ndice da pr√≥xima tupla na rela√ß√£o e uma estrutura de link para a tupla atual passada ao usu√°rio: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Para criar um estado de instru√ß√£o de verifica√ß√£o, voc√™ precisa de uma rela√ß√£o de origem;  tudo o resto (ponteiros para as fun√ß√µes correspondentes) j√° √© conhecido: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Opera√ß√µes de abertura / fechamento no caso de links de redefini√ß√£o de varredura de volta ao primeiro elemento do relacionamento: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  A pr√≥xima chamada retorna a pr√≥xima tupla ou NULL se n√£o houver mais tuplas na rela√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Instru√ß√£o de classifica√ß√£o </h3><br><p>  A instru√ß√£o de classifica√ß√£o produz tuplas na ordem especificada pelo usu√°rio.  Para fazer isso, crie uma rela√ß√£o tempor√°ria com tuplas obtidas de operadores aninhados e classifique-a. </p><br><p>  <a href="">O estado interno do</a> operador: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  A classifica√ß√£o √© realizada de acordo com os atributos especificados na solicita√ß√£o (sort_attr_name e sort_order) ao longo da raz√£o de tempo (tmp_relation).  Tudo isso acontece quando a fun√ß√£o aberta √© chamada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  A enumera√ß√£o dos elementos do relacionamento tempor√°rio √© realizada pelo operador tempor√°rio tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  O relacionamento tempor√°rio √© desalocado na fun√ß√£o close: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Aqui voc√™ pode ver claramente por que as opera√ß√µes de classifica√ß√£o em colunas sem √≠ndices podem demorar bastante tempo. </p><br><h2 id="primery-raboty">  Exemplos de trabalho </h2><br><p>  Vou dar alguns exemplos de consultas PigletQL e as √°rvores correspondentes da √°lgebra f√≠sica. </p><br><p>  O exemplo mais simples em que todas as tuplas de uma rela√ß√£o s√£o selecionadas: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Para as consultas mais simples, s√£o usadas apenas recuperando tuplas da rela√ß√£o de varredura e selecionando o √∫nico atributo de projeto das tuplas: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Escolhendo tuplas com um predicado: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Predicados s√£o expressos pela instru√ß√£o select: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Sele√ß√£o de tuplas com classifica√ß√£o: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  O operador de classifica√ß√£o de varredura na chamada aberta cria ( <em>materializa</em> ) um relacionamento tempor√°rio, coloca todas as tuplas recebidas l√° e classifica o todo.  Depois disso, nas pr√≥ximas chamadas, infere as tuplas da rela√ß√£o tempor√°ria na ordem especificada pelo usu√°rio: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Combinando tuplas de duas rela√ß√µes com um predicado: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  O operador de jun√ß√£o no PigletQL n√£o usa algoritmos complexos, mas simplesmente forma um produto cartesiano a partir dos conjuntos de tuplas das sub√°rvores esquerda e direita.  Isso √© muito ineficiente, mas para um int√©rprete de demonstra√ß√£o, ele far√°: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Conclus√µes </h1><br><p>  Concluindo, observo que, se voc√™ estiver criando um int√©rprete de uma linguagem semelhante ao SQL, provavelmente dever√° usar qualquer um dos muitos bancos de dados relacionais dispon√≠veis.  Milhares de pessoas / ano foram investidas em otimizadores modernos e int√©rpretes de consulta de bancos de dados populares, e leva anos para desenvolver at√© os bancos de dados de uso geral mais simples. </p><br><p>  A linguagem de demonstra√ß√£o PigletQL imita o trabalho do int√©rprete SQL, mas, na realidade, usamos apenas elementos individuais da arquitetura Volcano e apenas para aqueles (raros!) Tipos de consultas que s√£o dif√≠ceis de expressar na estrutura do modelo relacional. </p><br><p>  No entanto, repito: mesmo um conhecimento superficial da arquitetura de tais int√©rpretes √© √∫til nos casos em que √© necess√°rio trabalhar de maneira flex√≠vel com fluxos de dados. </p><br><h1 id="literatura">  Literatura </h1><br><p>  Se voc√™ est√° interessado nas quest√µes b√°sicas do desenvolvimento de banco de dados, os livros s√£o melhores que "Implementa√ß√£o do sistema de banco de dados" (Garcia-Molina H., Ullman JD, Widom J., 2000), voc√™ n√£o encontrar√°. </p><br><p>  Sua √∫nica desvantagem √© uma orienta√ß√£o te√≥rica.  Pessoalmente, gosto quando exemplos concretos de c√≥digo ou mesmo um projeto de demonstra√ß√£o s√£o anexados ao material.  Para isso, voc√™ pode consultar o livro ‚ÄúDesign e implementa√ß√£o de banco de dados‚Äù (Sciore E., 2008), que fornece o c√≥digo completo para um banco de dados relacional em Java. </p><br><p>  Os bancos de dados relacionais mais populares ainda usam varia√ß√µes sobre o tema Volcano.  A publica√ß√£o original √© escrita em uma linguagem muito acess√≠vel e pode ser facilmente encontrada no Google Scholar: ‚ÄúVolcano - um sistema extensivo e paralelo de avalia√ß√£o de consultas‚Äù (Graefe G., 1994). </p><br><p>  Embora os int√©rpretes SQL tenham mudado bastante em detalhes nas √∫ltimas d√©cadas, a estrutura geral desses sistemas n√£o mudou por um longo tempo.  Voc√™ pode ter uma id√©ia disso em um artigo de revis√£o do mesmo autor, ‚ÄúT√©cnicas de avalia√ß√£o de consultas para grandes bancos de dados‚Äù (Graefe G. 1993). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461699/">https://habr.com/ru/post/pt461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461689/index.html">Identifica√ß√£o da IoT do desenvolvedor</a></li>
<li><a href="../pt461691/index.html">Como fechamos as vulnerabilidades no sistema operacional Astra Linux Special Edition</a></li>
<li><a href="../pt461693/index.html">Compila√ß√£o cruzada OpenCV 4 para Raspberry Pi e BeagleBone Black</a></li>
<li><a href="../pt461695/index.html">Est√°gio VFX</a></li>
<li><a href="../pt461697/index.html">Intelig√™ncia da cerveja</a></li>
<li><a href="../pt461703/index.html">Relat√≥rios de micro etapas no trabalho de um programador</a></li>
<li><a href="../pt461707/index.html">As aventuras dos indescrit√≠veis Malvari, parte V: mais scripts DDE e COM</a></li>
<li><a href="../pt461709/index.html">O que esperar se voc√™ deseja se tornar um desenvolvedor iOS</a></li>
<li><a href="../pt461713/index.html">4 maneiras de economizar em backups na nuvem</a></li>
<li><a href="../pt461715/index.html">Medo e √≥dio como Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>