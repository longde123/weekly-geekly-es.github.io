<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☕️ 👩🏾‍🤝‍👩🏽 💃🏿 Redux - Nicht benötigt! Ersetzen durch useContext und useReducer in React? 🍯 🧡 🆑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Chabrowsk! 


 Ich möchte darüber sprechen, wie ich kürzlich in React von bestimmten „Hooks“ erfahren habe. Sie erschienen vor relativ kurz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redux - Nicht benötigt! Ersetzen durch useContext und useReducer in React?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473070/"><p><img src="https://habrastorage.org/webt/5k/yx/v3/5kyxv3j_arei6bk5dzy1niailh4.jpeg" alt="Bild"></p><br><p>  Guten Tag, Chabrowsk! </p><br><p>  Ich möchte darüber sprechen, wie ich kürzlich in React von bestimmten „Hooks“ erfahren habe.  Sie erschienen vor relativ kurzer Zeit in der <a href="">Version [16.8.0]</a> vom 6. Februar 2019 (die nach den Entwicklungsgeschwindigkeiten von FrontEnd bereits sehr lange zurückliegt). </p><br><p>  Nachdem ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> gelesen hatte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> konzentrierte ich mich auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">useReducer-</a> Hook und stellte mir sofort die Frage: <strong><em>"Dieses Ding kann Redux komplett ersetzen !?"</em></strong>  Ich habe mehrere Abende mit Experimenten verbracht und möchte nun die Ergebnisse und meine Schlussfolgerungen teilen. </p><a name="habracut"></a><br><h1 id="nuzhno-li-zamenyat-redux-s-pomoschyu-usecontext--usereducer">  Muss ich Redux durch useContext + useReducer ersetzen? </h1><br><h2 id="dlya-neterpelivyh---srazu-vyvody">  Für die ungeduldigen - sofort Schlussfolgerungen </h2><br><p>  <strong>Für:</strong> </p><br><ul><li>  Sie können Hooks (useContext + useReducer) anstelle von Redux in kleinen Anwendungen verwenden (wo keine großen kombinierten Reduzierer erforderlich sind).  In diesem Fall kann Redux tatsächlich redundant sein. </li></ul><br><p>  <strong>Gegen:</strong> </p><br><ul><li>  Auf einer Reihe von React + Redux wurde bereits eine große Menge Code geschrieben, und es erscheint zumindest vorerst nicht ratsam, ihn in Hooks (useContext + useReducer) umzuschreiben. </li><li>  Redux ist eine bewährte Bibliothek, Hooks sind eine Innovation, ihre Schnittstellen und ihr Verhalten können sich in Zukunft ändern. </li><li>  Um die Verwendung von useContext + useReducer wirklich bequem zu gestalten, müssen Sie einige Fahrräder schreiben. </li></ul><br><p>  <em>Die Schlussfolgerungen sind die persönliche Meinung des Autors und erheben keinen Anspruch auf bedingungslose Wahrheit. Wenn Sie nicht einverstanden sind, freue ich mich über Ihre konstruktive Kritik in den Kommentaren.</em> </p><br><h2 id="davayte-poprobuem-razobratsya">  Versuchen wir es herauszufinden </h2><br><p>  <strong>Beginnen wir mit einem einfachen Beispiel.</strong> </p><br><p>  <em>(reducer.js)</em> </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ContextApp = React.createContext(); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-string"><span class="hljs-string">'test_context'</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'test_update'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, ...action.payload }; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state } };</code> </pre> <br><p>  Bisher sieht unser Reduzierer genauso aus wie bei Redux </p><br><p>  <em>(app.js)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {useReducer} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {ContextApp, initialState, testReducer} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./reducer.js"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {IndexComponent} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./IndexComponent.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  reducer   state + dispatch   const [state, dispatch] = useReducer(testReducer, initialState); return ( //  ,     reducer   //  ContextApp   (dispatch  state) //      &lt;ContextApp.Provider value={{dispatch, state}}&gt; &lt;IndexComponent/&gt; &lt;/ContextApp.Provider&gt; ) };</span></span></code> </pre> <br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {useContext} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {ContextApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./reducer.js"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   useContext    ContextApp //  IndexComponent      ContextApp.Provider const {state, dispatch} = useContext(ContextApp); return ( //  dispatch    reducer.js   testReducer //    .    Redux &lt;div onClick={() =&gt; {dispatch({ type: 'test_update', payload: { newVar: 123 } })}}&gt; {JSON.stringify(state)} &lt;/div&gt; ) }</span></span></code> </pre> <br><p>  Dies ist das einfachste Beispiel, in dem wir einfach <del>  Update </del>  Schreiben Sie neue Daten in einen flachen Reduzierer (ohne Verschachtelung) <br>  Theoretisch können Sie sogar versuchen, so zu schreiben: </p><br><p>  <em>(reducer.js)</em> </p><br><pre> <code class="javascript hljs">... export <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, ...data } ...</code> </pre> <br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs">... return ( <span class="hljs-comment"><span class="hljs-comment">//      ,   type &lt;div onClick={() =&gt; {dispatch({ newVar: 123 }&gt; {JSON.stringify(state)} &lt;/div&gt; ) ...</span></span></code> </pre> <br><p>  Wenn wir keine große und einfache Anwendung haben (was in der Realität selten der Fall ist), können Sie den <u>Typ</u> nicht verwenden und Reduzierungsaktualisierungen immer direkt aus der Aktion heraus verwalten.  Übrigens haben wir auf Kosten von Updates in diesem Fall nur neue Daten in Reducer geschrieben, aber was ist, wenn wir einen Wert in einem Baum mit mehreren Verschachtelungsebenen ändern müssen? </p><br><h2 id="teper-poslozhnee">  Jetzt komplizierter </h2><br><p>  Schauen wir uns das folgende Beispiel an: </p><br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs">... return ( <span class="hljs-comment"><span class="hljs-comment">//        //     -     //      ,     callback: &lt;div onClick={() =&gt; { //  ,    callback, //   testReducer     state (state) =&gt; { const {tree_1} = state; return { tree_1: { ...tree_1, tree_2_1: { ...tree_1.tree_2_1, tree_3_1: 'tree_3_1 UPDATE' }, }, }; }&gt; {JSON.stringify(state)} &lt;/div&gt; ) ...</span></span></code> </pre> <br><p>  <em>(reducer.js)</em> </p><br><pre> <code class="javascript hljs">... export <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">tree_1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">tree_2_1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">tree_3_1</span></span>: <span class="hljs-string"><span class="hljs-string">'tree_3_1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tree_3_2</span></span>: <span class="hljs-string"><span class="hljs-string">'tree_3_2'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">tree_2_2</span></span>: { <span class="hljs-attr"><span class="hljs-attr">tree_3_3</span></span>: <span class="hljs-string"><span class="hljs-string">'tree_3_3'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tree_3_4</span></span>: <span class="hljs-string"><span class="hljs-string">'tree_3_4'</span></span> } } }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      state      //      callback const action = callback(state); return { ...state, ...action } ...</span></span></code> </pre> <br><p>  Okay, wir haben auch das Baum-Update herausgefunden.  In diesem Fall ist es jedoch bereits <u><strong>besser, wieder Typen</strong></u> in testReducer zu verwenden und den Baum gemäß einer bestimmten Art von Aktion zu aktualisieren.  Alles ist wie in Redux, nur das resultierende Bündel ist etwas kleiner [8]. </p><br><h2 id="asinhronnye-operacii-i-dispatch">  Asynchrone Operationen und Versand </h2><br><p>  Aber ist alles in Ordnung?  Was passiert, wenn wir asynchrone Operationen verwenden? <br>  Dazu müssen wir unseren eigenen Versand definieren.  Lass es uns versuchen! </p><br><p>  <em>(action.js)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actions = { <span class="hljs-attr"><span class="hljs-attr">sendToServer</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{dataForServer}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   dispatch return function (dispatch) { //   dispatch    , //   state      dispatch(state =&gt; { return { pending: true } }); } }</span></span></code> </pre> <br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, _dispatch] = useReducer(AppReducer, AppInitialState); <span class="hljs-comment"><span class="hljs-comment">//     dispatch   -&gt; //    ,  Proxy const dispatch = (action) =&gt; action(_dispatch); ... dispatch(actions.sendToServer({dataForServer: 'data'})) ...</span></span></code> </pre> <br><p>  Alles scheint auch in Ordnung zu sein, <u><strong>aber jetzt haben wir viele Callback-Verschachtelungen</strong></u> , was nicht sehr cool ist. Wenn wir nur den Status ändern wollen, ohne eine Aktionsfunktion zu erstellen, müssen wir eine Konstruktion dieser Art schreiben: </p><br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs">... dispatch( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function">) =&gt;</span></span> dispatch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { {<span class="hljs-attr"><span class="hljs-attr">dataForServer</span></span>: <span class="hljs-string"><span class="hljs-string">'data'</span></span>} } }) ) ...</code> </pre> <br><p>  Es stellt sich heraus, dass etwas beängstigend ist, oder?  Für ein einfaches Datenupdate möchte ich wirklich so etwas schreiben: </p><br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs">... dispatch({<span class="hljs-attr"><span class="hljs-attr">dataForServer</span></span>: <span class="hljs-string"><span class="hljs-string">'data'</span></span>}) ...</code> </pre> <br><p>  Dazu müssen Sie den Proxy für die zuvor erstellte Versandfunktion ändern <br>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, _dispatch] = useReducer(AppReducer, AppInitialState); <span class="hljs-comment"><span class="hljs-comment">//  // const dispatch = (action) =&gt; action(_dispatch); //  const dispatch = (action) =&gt; { if (typeof action === "function") { action(_dispatch); } else { _dispatch(() =&gt; action) } }; ...</span></span></code> </pre> <br><p>  Jetzt können wir sowohl eine Aktionsfunktion als auch ein einfaches Objekt zum Versenden übergeben. <br>  <strong><u>Aber!</u></strong>  Bei einer einfachen Übertragung des Objekts müssen Sie vorsichtig sein, Sie könnten versucht sein, dies zu tun: </p><br><p>  <em>(IndexComponent.js)</em> </p><br><pre> <code class="javascript hljs">... dispatch({ <span class="hljs-attr"><span class="hljs-attr">tree</span></span>: { <span class="hljs-comment"><span class="hljs-comment">//  state         AppContext ...state.tree, data: 'newData' } }) ...</span></span></code> </pre> <br><p>  Warum ist dieses Beispiel schlecht?  Durch die Tatsache, dass zum Zeitpunkt der Verarbeitung dieses Versands der Status möglicherweise durch einen anderen Versand aktualisiert wurde, diese Änderungen jedoch noch nicht unsere Komponente erreicht haben, verwenden wir tatsächlich eine alte Statusinstanz, die alles mit alten Daten überschreibt. </p><br><p>  Aus diesem Grund ist eine solche Methode kaum geeignet, nur um flache Reduzierungen zu aktualisieren, bei denen keine Verschachtelung vorliegt und Sie den Status nicht zum Aktualisieren verschachtelter Objekte verwenden müssen.  In der Realität sind Reduzierungen selten perfekt flach, daher würde ich Ihnen raten, diese Methode überhaupt nicht zu verwenden und Daten nur durch Aktionen zu aktualisieren. </p><br><p>  <em>(action.js)</em> </p><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">// ..  dispatch   callback,    //       (. reducer.js) dispatch(state =&gt; { return { dataFromServer: { ...state.dataFromServer, form_isPending: true } } }); axios({ method: 'post', url: `...`, data: {...} }).then(response =&gt; { dispatch(state =&gt; { //   axios     //         dispatch //     ,  state -    , // ..       testReducer (reducer.js) return { dataFromServer: { ...state.dataFromServer, form_isPending: false, form_request: response.data }, user: {} } }); }).catch(error =&gt; { dispatch(state =&gt; { // , state -    ) return { dataFromServer: { ...state.dataFromServer, form_isPending: false, form_request: { error: error.response.data } }, } }); ...</span></span></code> </pre> <br><h2 id="vyvody">  Schlussfolgerungen: </h2><br><ul><li>  Es war eine interessante Erfahrung, ich vertiefte mein akademisches Wissen und lernte neue Merkmale der Reaktion </li><li>  Ich werde diesen Ansatz nicht in der Produktion anwenden (zumindest in den nächsten sechs Monaten).  Aus den oben bereits beschriebenen Gründen (dies ist eine neue Funktion und Redux ist ein bewährtes und zuverlässiges Tool) + Ich habe keine Leistungsprobleme, die ich nach den Millisekunden verfolgen muss, die Sie gewinnen können, wenn Sie den Editor verlassen. [8] </li></ul><br><p>  <strong><em>Ich werde mich freuen, in den Kommentaren die Meinung von Kollegen aus dem Front-End-Teil unserer Habrosobschestva zu erfahren!</em></strong> </p><br><h4 id="ssylki">  Referenzen: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux durch React Hooks und Kontext ersetzen (Teil 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wann sollte der native React.useReducer Hook verwendet werden und wie unterscheidet er sich von Redux?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Möglicherweise benötigen Sie kein Redux (aber Sie können es nicht durch Haken ersetzen).</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React's useReducer gegen Redux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenn der Kontext Redux ersetzt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux integrierte Alternative mit React Context und Hooks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ersetzen Reaktionshaken Redux?</a> </li><li>  [8] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bespoyasov.ru/blog/you-really-dont-need-redux-now/</a> <br><img src="https://habrastorage.org/webt/mt/88/hb/mt88hb8zhgx4od6mo5uxuqkhxtg.png" alt="Bild"></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473070/">https://habr.com/ru/post/de473070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473056/index.html">Wie Alice Länder anhand von Fotografien erkennt. Yandex-Forschung</a></li>
<li><a href="../de473058/index.html">Sergey Sinitsyn: „OSM ist mehr als nur das Zeichnen von Häusern oder Spuren. Das sind mehr Geschichten! “</a></li>
<li><a href="../de473062/index.html">Subjektive user.js für Mozilla Firefox und nicht nur</a></li>
<li><a href="../de473064/index.html">Batavianische Tränen, Autos und Gorilla-Glas: über einige Arten von verstärktem Glas</a></li>
<li><a href="../de473066/index.html">Quadrantenbäume und Kollisionserkennung</a></li>
<li><a href="../de473072/index.html">Wie Gazpromneft einen digitalen Weg für einen Firmenkunden schafft</a></li>
<li><a href="../de473074/index.html">Was ist APS und warum wird ein Produktionsplan nicht so erstellt, wie wir es wollen ...</a></li>
<li><a href="../de473078/index.html">Verwalten Sie einfach Mikroservice-Konfigurationen mit microconfig.io</a></li>
<li><a href="../de473082/index.html">Wie wir Microservices schreiben und warum wir das nicht schnell machen</a></li>
<li><a href="../de473084/index.html">"Ivan" ist ein Chat-Bot-Beruf. Oder kreative Experimente mit virtuellen Assistenten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>