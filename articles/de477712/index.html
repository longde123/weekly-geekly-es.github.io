<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕑 🧘🏿 👨🏼 Objekte versus Datenstrukturen 🤢 🤹🏼 💎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dem Artikel, dessen Übersetzung unten vorgeschlagen wird, scheint Robert Martin mit Gedanken zu beginnen, die denen sehr ähnlich sind, die in Jegor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Objekte versus Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477712/"><p>  In dem Artikel, dessen Übersetzung unten vorgeschlagen wird, scheint Robert Martin mit Gedanken zu beginnen, die denen sehr ähnlich sind, die in Jegor Bugaenkos Diskussionen über ORM zu sehen sind, aber andere ziehen Schlussfolgerungen.  Persönlich beeindruckt mich Yegors Herangehensweise, aber ich denke, dass Martin das Thema ausführlicher aufdeckt.  Es scheint mir, dass es sich lohnt, alle kennenzulernen, die jemals darüber nachgedacht haben, welchen Platz ORM einnehmen soll und generell, warum wir Objekte brauchen, in denen alle Felder offen sind.  Der Artikel ist im Genre "Dialog" geschrieben, in dem ein erfahrener Programmierer ein Problem mit jemandem bespricht, der weniger Erfahrung hat. </p><br><blockquote>  Was ist eine Klasse? </blockquote><p>  Eine Klasse ist eine Spezifikation vieler ähnlicher Objekte. </p><br><blockquote>  Was ist ein Objekt? </blockquote><p>  Ein Objekt ist eine Reihe von Funktionen, die Aktionen mit gekapselten Daten ausführen. </p><br><blockquote>  Oder ist es besser zu sagen, dass ein Objekt eine Reihe von Funktionen ist, die Aktionen mit Daten ausführen, deren Existenz impliziert ist </blockquote><p>  Im Sinne von "impliziert"? </p><a name="habracut"></a><br><blockquote>  Sobald das Objekt Funktionen hat, kann davon ausgegangen werden, dass sich dort auch Daten befinden, es jedoch keinen direkten Zugriff auf die Daten gibt und sie von außen überhaupt nicht sichtbar sind. </blockquote><p>  Sind die Daten nicht im Objekt? </p><br><blockquote>  Vielleicht sind sie es, aber die Regel, die besagt, dass sie da sein müssen, ist nicht.  Aus Sicht des Benutzers ist ein Objekt nichts anderes als eine Reihe von Funktionen.  Die Daten, mit denen diese Funktionen arbeiten, müssen existieren, aber die Position dieser Daten ist dem Benutzer unbekannt. </blockquote><p>  Sagen wir mal. </p><br><blockquote>  Was ist eine Datenstruktur? </blockquote><p>  Eine Datenstruktur ist eine Sammlung verwandter Elemente. </p><br><blockquote>  Mit anderen Worten, eine Datenstruktur ist eine Menge von Elementen, mit denen Funktionen arbeiten, deren Existenz implizit impliziert wird. </blockquote><p>  Okay, okay.  Ich verstehe.  Die Funktionen, die mit Datenstrukturen arbeiten, sind nicht in diesen Strukturen definiert, aber aus der Existenz einer Datenstruktur können wir schließen, dass es etwas geben muss, das mit ihnen funktioniert. </p><br><blockquote>  Richtig.  Und was ist mit diesen beiden Definitionen? </blockquote><p>  In gewissem Sinne sind sie Gegensätze. </p><br><blockquote>  Wirklich.  Sie ergänzen sich.  Wie eine Hand und ein Handschuh. <br><ul><li>  Ein Objekt ist eine Reihe von Funktionen, die mit Datenelementen arbeiten, deren Existenz implizit impliziert wird. </li><li>  Eine Datenstruktur ist eine Menge von Datenelementen, mit denen Funktionen arbeiten, deren Existenz implizit impliziert wird. </li></ul><br></blockquote><p>  Wow!  Es stellt sich also heraus, dass Objekte und Datenstrukturen nicht dasselbe sind! </p><br><blockquote>  Richtig.  Datenstrukturen sind DTOs. </blockquote><p>  Und Tabellen in Datenbanken sind auch keine Objekte, oder? </p><br><blockquote>  Wieder wahr.  Datenbanken enthalten Datenstrukturen, keine Objekte. </blockquote><p>  Warte einen Moment.  Ordnet ORM nicht Tabellen aus der Datenbank Objekten zu? </p><br><blockquote>  Natürlich nicht.  Sie können keine Datenbanktabellen Objekten zuordnen.  Tabellen in der Datenbank sind Datenstrukturen, keine Objekte. </blockquote><p>  Was macht ORM dann? </p><br><blockquote>  Sie übertragen Daten von einer Struktur in eine andere. </blockquote><p>  Sie haben also nichts mit Objekten zu tun? </p><br><blockquote>  Gar nichts.  Genau genommen gibt es so etwas wie ORM im Sinne einer Technologie, die relationale Daten auf Objekte abbildet, nicht, weil Tabellen nicht von einer Datenbank auf Objekte abgebildet werden können. </blockquote><p>  Aber sie sagten mir, dass ORMs Geschäftsobjekte sammeln. </p><br><blockquote>  Nein, ORM ruft Daten aus einer Datenbank ab, mit der Geschäftsobjekte arbeiten </blockquote><p>  Aber fallen diese Datenstrukturen nicht in Geschäftsobjekte? </p><br><blockquote>  Vielleicht bekommen sie oder vielleicht nicht.  ORM weiß nichts darüber. </blockquote><p>  Der Unterschied ist jedoch rein semantisch. </p><br><blockquote>  Ja Nein.  Es gibt weitreichende Konsequenzen. </blockquote><p>  Zum Beispiel? </p><br><blockquote>  Zum Beispiel den Entwurf des Datenbankschemas und den Entwurf von Geschäftsobjekten.  Geschäftsobjekte definieren das Geschäftsverhalten.  Das Datenbankschema definiert die Geschäftsdatenstruktur.  Diese Strukturen sind durch sehr unterschiedliche Kräfte begrenzt.  Eine Geschäftsdatenstruktur ist nicht unbedingt die beste Struktur für das Geschäftsverhalten. </blockquote><p>  Eeee.  Das ist unverständlich. </p><br><blockquote>  Denken Sie so darüber nach.  Das Datenschema ist nicht für eine einzelne Anwendung konzipiert, sondern für die unternehmensweite Verwendung vorgesehen.  Daher ist die Datenstruktur ein Kompromiss zwischen mehreren verschiedenen Anwendungen. </blockquote><p>  Das ist klar. </p><br><blockquote>  Gut  Denken Sie jetzt über jede einzelne Anwendung nach.  Das Objektmodell jeder Anwendung beschreibt, wie das Verhalten der Anwendung strukturiert ist.  Jede Anwendung verfügt über ein eigenes Objektmodell, um dem Verhalten der Anwendung besser zu entsprechen. </blockquote><p>  Ahh, ich verstehe.  Da das Datenschema einen Kompromiss zwischen verschiedenen Anwendungen darstellt, hängt das Schema nicht vom Objektmodell jeder einzelnen Anwendung ab. </p><br><blockquote>  Richtig!  Objekte und Strukturen sind auf verschiedene Dinge beschränkt.  Sie passen sehr selten zusammen.  Die Leute nennen dies die Nichtübereinstimmung der objektrelationalen Impedanz. </blockquote><p>  Etwas, an das ich mich erinnere.  Es scheint jedoch, dass die Impedanzfehlanpassung nur mit ORM korrigiert wurde. </p><br><blockquote>  Und jetzt wissen Sie, dass dies nicht so ist.  Impedanzfehlanpassung zwischen Objekten und Datenstrukturen ist komplementär und nicht isomorph. </blockquote><p>  Was denn </p><br><blockquote>  Sie sind Gegensätze, nicht etwas Ähnliches. </blockquote><p>  Gegensätze? </p><br><blockquote>  Ja, in einem sehr interessanten Sinne.  Sie sehen, Objekte und Datenstrukturen implizieren diametral entgegengesetzte Kontrollstrukturen. </blockquote><p>  Was denn </p><br><blockquote>  Stellen Sie sich eine Reihe von Klassen vor, die eine Art gemeinsames Interface implementieren.  Stellen Sie sich beispielsweise Klassen vor, die zweidimensionale Figuren darstellen, in denen Funktionen zum Berechnen der Fläche und des Umfangs einer Figur vorhanden sind. </blockquote><p>  Inwieweit werden Objekte in allen Beispielen von Shapes codiert? </p><br><blockquote>  Betrachten wir zwei verschiedene Arten von Formen: Quadrate und Kreise.  Es ist klar, dass die Funktionen zur Berechnung der Fläche und des Umfangs dieser Klassen unterschiedliche Datenstrukturen verwenden.  Es versteht sich auch, dass diese Operationen unter Verwendung eines dynamischen Polymorphismus aufgerufen werden. </blockquote><p>  Entschleunigen Sie bitte, nichts ist klar. </p><br><blockquote>  Es gibt zwei verschiedene Funktionen zur Berechnung der Fläche, eine für das Quadrat und eine für den Kreis.  Wenn eine Funktion aufgerufen wird, um die Fläche eines bestimmten Objekts zu berechnen, entscheidet dieses Objekt, welche bestimmte Funktion aufgerufen werden soll.  Dies nennt man dynamischen Polymorphismus. </blockquote><p>  Ok  Natürlich.  Ein Objekt weiß, wie seine Methoden implementiert sind.  Natürlich. </p><br><blockquote>  Lassen Sie uns diese Objekte nun in Datenstrukturen umwandeln.  Wir benutzen diskriminierte Gewerkschaften. </blockquote><p>  Was diskriminiert? </p><br><blockquote>  Diskriminierte Gewerkschaften.  Nun, C ++, Zeiger, das Schlüsselwort union, ein Flag zur Bestimmung des Strukturtyps, Diskriminierte Gewerkschaften.  In unserem Fall sind dies nur zwei unterschiedliche Datenstrukturen.  Eine für den Platz und eine für den Kreis.  Der Kreis hat einen Mittelpunkt und einen Radius.  Und ein Typcode, aus dem hervorgeht, dass es sich um einen Kreis handelt. </blockquote><p>  Das Feld mit dem Code wird enum sein? </p><br><blockquote>  Na ja  Und das Quadrat wird den oberen linken Punkt und die Länge der Seite haben.  Und auch enum, um den Typ anzugeben. </blockquote><p>  Ok  Es wird zwei Strukturen mit einem Typcode geben. </p><br><blockquote>  Richtig.  Betrachten wir nun die Funktion für den Bereich.  Es wird wahrscheinlich einen Schalter geben, oder? </blockquote><p>  Na ja  Natürlich für zwei Klassen.  Der Zweig für den Platz und für den Kreis.  Und für den Perimeter benötigen Sie auch einen ähnlichen Schalter. </p><br><blockquote>  Und wieder richtig.  Denken Sie nun über diese beiden Szenarien nach.  In einem Szenario mit Objekten sind zwei Implementierungen von Funktionen für einen Bereich unabhängig voneinander und gehören (gewissermaßen) direkt zum Typ.  Die Funktion für die Fläche des Quadrats gehört zum Quadrat, und die Funktion zum Bestimmen der Fläche des Kreises gehört zum Kreis. </blockquote><p>  Okay, ich verstehe, wohin du führst.  In einem Szenario mit Datenstrukturen befinden sich beide Implementierungen einer Funktion für einen Bereich in derselben Funktion und gehören nicht zum Typ (was auch immer dieses Wort bedeutet). </p><br><blockquote>  Weiter ist besser.  Welcher Code sollte bei Objekten geändert werden, wenn Sie den Typ "Dreieck" hinzufügen müssen? </blockquote><p>  Ändern Sie überhaupt nichts.  Erstelle einfach eine neue Triangle-Klasse.  Obwohl dies nicht der Fall ist, müssen Sie wahrscheinlich den Code korrigieren, mit dem die Objekte erstellt werden. </p><br><blockquote>  Richtig.  Wenn Sie also einen neuen Typ hinzufügen, sind die Änderungen vernachlässigbar.  Angenommen, Sie müssen eine neue Funktion hinzufügen, z. B. eine Funktion zum Bestimmen des Mittelpunkts. </blockquote><p>  Dann müssen Sie es zu allen drei Typen, Kreis, Quadrat und Dreieck, hinzufügen. </p><br><blockquote>  Gut  Es stellt sich heraus, dass das Hinzufügen neuer Funktionen schwierig ist, da Sie in jeder Klasse Änderungen vornehmen müssen. </blockquote><p>  Bei Datenstrukturen ist alles anders.  Um ein Dreieck hinzuzufügen, müssen Sie jede Funktion ändern, um Zweige hinzuzufügen, die das Dreieck in jedem Schalter behandeln. </p><br><blockquote>  Richtig.  Es ist schwierig, Typen hinzuzufügen, Sie müssen jede Funktion bearbeiten. </blockquote><p>  Um jedoch eine Funktion für die Zentrale hinzuzufügen, muss nichts geändert werden. </p><br><blockquote>  Das Hinzufügen von Funktionen ist einfach. </blockquote><p>  Wow.  Es stellt sich heraus, dass diese beiden Ansätze direkt entgegengesetzt sind. </p><br><blockquote>  Auf jeden Fall ja.  Um es zusammenzufassen </blockquote><br><ul><li>  Es ist schwierig, Klassen neue Funktionen hinzuzufügen. Sie müssen in jeder Klasse Änderungen vornehmen </li><li>  Das Hinzufügen neuer Funktionen zu Datenstrukturen ist einfach. Sie müssen lediglich eine Funktion hinzufügen, nichts anderes muss geändert werden </li><li>  Das Hinzufügen neuer Typen zu Klassen ist einfach. Sie müssen lediglich eine neue Klasse hinzufügen </li><li>  Es ist schwierig, neue Typen für Strukturen hinzuzufügen, Sie müssen jede Funktion reparieren </li></ul><br><p>  Ja  Gegensätze.  Gegensätze im eigentümlichen Sinne.  Das heißt, wenn im Voraus bekannt ist, dass neue Funktionen hinzugefügt werden müssen, ist es zweckmäßig, Datenstrukturen zu verwenden.  Wenn Sie jedoch im Voraus wissen, dass Sie neue Typen hinzufügen müssen, müssen Sie Klassen verwenden. </p><br><blockquote>  Gute Beobachtung!  Aber heute müssen wir uns noch eine Sache überlegen.  Es gibt einen weiteren Punkt, an dem Datenstrukturen und Klassen einander gegenüberstehen.  Abhängigkeiten. </blockquote><p>  Sucht? </p><br><blockquote>  Ja, die Richtung der Abhängigkeiten im Quellcode. </blockquote><p>  Okay, ich werde fragen.  Was ist der unterschied </p><br><blockquote>  Schauen wir uns den Fall der Strukturen an.  Jede Funktion enthält einen Schalter, der die gewünschte Implementierung basierend auf dem Typcode in der Union auswählt. </blockquote><p>  Ja, das ist es.  Na und? </p><br><blockquote>  Schauen wir uns den Funktionsaufruf für den Bereich an.  Der aufrufende Code hängt von der Funktion für das Gebiet ab, und die Funktion für das Gebiet hängt von jeder spezifischen Implementierung ab. </blockquote><p>  Und was meinst du mit "abhängig"? </p><br><blockquote>  Stellen Sie sich vor, dass jede Implementierung einer Funktion für einen Bereich einer separaten Funktion zugeordnet ist.  Das heißt, es gibt circleArea-, squareArea- und triangleArea-Funktionen. </blockquote><p>  Nun, es stellt sich heraus, dass es in den Vermittlungszweigen einfach Aufrufe zu diesen Funktionen geben wird. </p><br><blockquote>  Stellen Sie sich vor, diese Funktionen befinden sich in verschiedenen Dateien. </blockquote><p>  Dann in die Datei mit dem Schalter importieren oder für Dateien mit Funktionen verwenden oder einschließen. </p><br><blockquote>  Richtig  Dies ist eine Abhängigkeit auf Quellcodeebene.  Eine Quelle hängt von einer anderen Quelle ab.  Wie ist diese Abhängigkeit gerichtet? </blockquote><p>  Der Quellcode mit Schalter hängt vom Quellcode ab, in dem sich die Implementierungen befinden. </p><br><blockquote>  Was ist mit dem Code, der die Funktion für den Bereich aufruft? </blockquote><p>  Der aufrufende Code hängt vom Code mit Schalter ab, der von allen Implementierungen abhängt. </p><br><blockquote>  Richtig.  In allen Quellen ist der Pfeil in die Richtung des Aufrufs gerichtet, vom aufrufenden Code bis zur Implementierung.  Wenn Sie also eine kleine Änderung an diesen Implementierungen vornehmen möchten ... </blockquote><p>  Okay, okay, ich verstehe, worauf du hinaus willst.  Eine Änderung in einer der Implementierungen führt zur Neukompilierung aller Dateien mit switch, und dies führt dazu, dass alles, was diesen switch aufruft, neu kompiliert wird, beispielsweise in unserem Fall die Funktion für area. </p><br><blockquote>  Ja  Zumindest für Sprachen, die Änderungsdaten verwenden, um zu verstehen, was neu erstellt werden muss. </blockquote><p>  Und das sind im Allgemeinen alle Systeme mit statischer Typisierung, oder? </p><br><blockquote>  Ja und einige andere Systeme ohne </blockquote><p>  Dies muss viel umgebaut werden. </p><br><blockquote>  Und viel zu wiederholen. </blockquote><p>  Okay, aber im Fall von Klassen ist es umgekehrt? </p><br><blockquote>  Ja, da der Code, der die Funktion für den Bereich aufruft, von der Schnittstelle abhängt und die Implementierung auch von dieser Schnittstelle abhängt. </blockquote><p>  Ich verstehe  Der Code für die Square-Klasse importiert oder verwendet oder enthält eine Datei mit der Shape-Schnittstelle. </p><br><blockquote>  Richtig.  Der Pfeil in den Implementierungsdateien zeigt in die entgegengesetzte Richtung zum Aufruf.  Es wird vom Implementierungscode zum Aufrufcode weitergeleitet.  Zumindest wird dies für statisch typisierte Sprachen der Fall sein.  Bei dynamisch getippten Sprachen ist der Code, der die Funktion für den Bereich aufruft, von nichts abhängig, da die Verknüpfung zur Laufzeit erfolgt. </blockquote><p>  Ja ok  Das heißt, wenn Sie Änderungen an einer der Implementierungen vornehmen ... </p><br><blockquote>  Es ist nur erforderlich, den Code mit diesen Änderungen neu zu erstellen und zu installieren. </blockquote><p>  Dies liegt daran, dass Abhängigkeiten entgegen der Anrufrichtung gerichtet sind. </p><br><blockquote>  Ja, wir nennen es Abhängigkeitsinversion. </blockquote><p>  Okay, lassen Sie uns alles zusammenfassen.  Klassen und Datenstrukturen stehen sich in dreifacher Hinsicht gegenüber. </p><br><ul><li>  Die Funktionen befinden sich explizit in den Klassen, und Sie können nur raten, ob Daten vorhanden sind.  Datenstrukturen sind explizit in den Datenstrukturen vorhanden, und Sie können nur raten, welche Funktionen verfügbar sind. </li><li>  Bei Klassen ist das Hinzufügen von Typen einfach, das Hinzufügen von Funktionen jedoch schwierig.  Bei Strukturen ist das Hinzufügen von Funktionen einfach, das Hinzufügen von Typen jedoch schwierig. </li><li>  Datenstrukturen führen zu einer Neukompilierung und Neuverteilung des aufrufenden Codes.  Klassen isolieren den aufrufenden Code und müssen ihn nicht erneut kompilieren und bereitstellen. </li></ul><br><blockquote>  Ja, das ist richtig.  Dies sollte jeder Designer und Software-Architekt berücksichtigen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477712/">https://habr.com/ru/post/de477712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477694/index.html">JavaScript muss nicht durch irgendetwas ersetzt werden - auch andere Sprachen haben die gleichen Probleme</a></li>
<li><a href="../de477696/index.html">Front-End-Domain basierend auf TLS 1.3. Teil 2</a></li>
<li><a href="../de477700/index.html">Hollywood-Prinzip (IoC)</a></li>
<li><a href="../de477706/index.html">Gemischte Inhalte beim Herunterladen von HTTPS: So finden und überwinden Sie</a></li>
<li><a href="../de477710/index.html">Was sie in der Schule nicht unterrichten: Wie wir Techniker ausbilden</a></li>
<li><a href="../de477716/index.html">Mathematiker berechnen anhand des Beispiels "Tag", wie Zufälligkeiten auftreten</a></li>
<li><a href="../de477718/index.html">Faltungsschicht: schnelle Faltung nach der Methode von Shmuel Vinograd</a></li>
<li><a href="../de477722/index.html">Google Style Guide in C ++. Teil 8</a></li>
<li><a href="../de477724/index.html">HR-Marken-Habraseminar: Über Talente, Jagd und Inhalte</a></li>
<li><a href="../de477728/index.html">Was zu tun ist Teamführung, damit das Team nicht ausbrennt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>