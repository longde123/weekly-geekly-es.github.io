<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📔 Ⓜ️ 🤛 使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求 ⏩ 🤾🏽 🤟🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从7.04版开始，针对Linux和macOS上的C和C ++语言的PVS-Studio分析仪具有测试功能，可以检查指定文件的列表。 使用新模式，您可以将分析器配置为检查提交和请求。 本文将向您展示如何在Travis CI，Buddy和AppVeyor等流行的CI（持续集成）系统中配置检查GitHub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/470984/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac4/d08/0e7/ac4d080e7661626569ef514abe190662.png" alt="图片11"></div><br> 从7.04版开始，针对Linux和macOS上的C和C ++语言的PVS-Studio分析仪具有测试功能，可以检查指定文件的列表。 使用新模式，您可以将分析器配置为检查提交和请求。 本文将向您展示如何在Travis CI，Buddy和AppVeyor等流行的CI（持续集成）系统中配置检查GitHub项目的已修改文件的列表。 <br><a name="habracut"></a><br><h2> 文件列表检查模式 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>是用于检测用C，C ++，C＃和Java编写的程序的源代码中的错误和潜在漏洞的工具。 它适用于Windows，Linux和macOS上的64位系统。 <br><br> 在适用于Linux和macOS的PVS-Studio版本7.04中，出现了检查源文件列表的模式。 这适用于其生成系统允许生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">compile_commands.json</a>文件的项目。 分析器需要提取有关指定文件编译的信息。 如果您的构建系统不支持compile_commands.json文件的生成，则可以尝试使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bear</a>实用程序生成这样的文件。 <br><br> 另外，文件列表检查模式可与编译器启动的strace跟踪日志（pvs-studio-analyzer跟踪）一起使用。 为此，您首先需要对项目进行完整的组装并对其进行跟踪，以便分析器收集有关所有测试文件的编译参数的完整信息。 <br><br> 但是，此选项有一个很大的缺点-您要么需要在每次启动时对整个项目的组装进行完整的跟踪，这本身就与快速检查提交的想法相矛盾。 或者，如果缓存了跟踪结果本身，如果跟踪后源文件的依赖关系结构发生了变化（例如，新的#include已添加到一个源文件中），则后续的分析器启动可能无法完成。 <br><br> 因此，我们不建议在跟踪日志中使用文件列表检查模式来检查提交或请求请求。 如果在检查提交时可以进行增量汇编，请考虑使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增量分析</a>模式。 <br><br> 用于分析的源文件列表保存在文本文件中，并使用<i>-S</i>参数传输到分析器： <br><br><pre><code class="bash hljs">pvs-studio-analyzer analyze ... -f build/compile_commands.json -S check-list.txt</code> </pre> <br> 在此文件中，指示文件的相对或绝对路径，并且每个新文件都应在新行上。 不仅可以指定分析文件的名称，还可以指定各种文本。 分析器将看到这不是文件，并且将忽略该行。 如果手动指定文件，这对于注释很有用。 但是，通常会在CI中进行分析时生成文件列表，例如，这些文件可能是来自提交或拉取请求的文件。 <br><br> 现在，使用这种模式，您可以在新代码进入主开发分支之前快速对其进行检查。 为了使验证系统能够响应分析器警告， <i>已将--indicate-warnings</i>标志添加到<i>plog-converter</i> <i>实用程序中</i> ： <br><br><pre> <code class="bash hljs">plog-converter ... --indicate-warnings ... -o /path/to/report.tasks ...</code> </pre> <br> 使用此标志，如果分析仪报告中有警告，则转换器将返回非零代码。 使用返回码，您可以阻止预提交的挂接，提交或提取请求，并在屏幕上显示生成的分析器报告，共享或通过邮件发送。 <br><br>  <i>注意事项</i>  <i>第一次运行文件列表分析时，将分析整个项目，因为</i>  <i>分析器需要从头文件生成项目源文件的依赖项文件。</i>  <i>这是C和C ++文件分析的功能。</i>  <i>将来，依赖项文件可以被缓存，并且分析器将自动对其进行更新。</i>  <i>与使用增量分析模式相比，使用文件列表验证模式时检查提交的优势在于，您仅需要缓存此文件，而不是对象文件。</i> <br><br><h2> 拉取请求分析的一般原则 </h2><br> 整个项目的分析需要很多时间，因此仅检查其中的一部分是有意义的。 问题是您需要将新文件与其余项目文件分开。 <br><br> 考虑具有两个分支的提交树的示例： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/722/646/68c/72264668c4a90b96ccb63f363a46c683.png" alt="图片5"></div><br><br> 让我们想象一下提交<i>A1</i>包含了大量已经经过测试的代码。 早些时候，我们从提交<i>A1</i>分支了，并更改了一些文件。 <br><br> 当然，您注意到在<i>A1</i>之后还有两次提交，但是它们也是其他分支的合并，因为我们不在<i>master中</i>进行提交。 现在， <i>修补程序</i>准备就绪的时间到了。 因此， <i>出现</i>了合并<i>B3</i>和<i>A3的</i>请求。 <br><br> 当然，可以检查合并的全部结果，但这将太长且不合理，因为仅更改了一些文件。 因此，仅分析更改会更有效。 <br><br> 为此，我们要获得分支之间的差异，该分支位于我们要从中合并到master的分支的HEAD中： <br><br><pre> <code class="bash hljs">git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list</code> </pre> <br>  <i>$ MERGE_BASE，</i>我们将在后面详细讨论。 事实是，并非每个CI服务都提供有关合并基础的必要信息，因此每次您都必须想出新方法来获取此数据。 这将在下面描述的每个Web服务中详细说明。 <br><br> 因此，我们得到了分支之间的区别，或更确切地说，得到了已更改的文件名列表。 现在我们需要将<i>.pvs-pr.list文件</i> （上面的输出重定向到上面）提供给分析器： <br><br><pre> <code class="bash hljs">pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list</code> </pre> <br> 经过分析，我们需要将日志文件（PVS-Studio.log）转换为易于阅读的格式： <br><br><pre> <code class="bash hljs">plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 此命令将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stderr</a> （标准错误消息输出流）中列出错误。 <br><br> 直到现在，我们不仅需要显示错误，还需要告知我们的服务以组装和测试问题。 为此，将<i>-W</i>标志（ <i>--indicate-warnings</i> ）添加到了转换器中。 如果至少有一个分析器警告，则<i>plog-converter</i>实用程序的返回码将更改为2，从而将通知CI服务有关拉取请求文件中存在潜在错误的信息。 <br><br><h2> 特拉维斯 </h2><br> 该配置作为<i>.travis.yml</i>文件进行。 为了方便起见，我建议您将所有内容放在一个单独的bash脚本中，该脚本具有将从<i>.travis.yml</i>文件调用的<i>函数</i> （ <i>bash script_name.sh function_name</i> ）。 <br><br> 我们将必要的代码添加到<i>bash</i>脚本中，以便获得更多功能。 在<i>安装</i>部分中，编写以下内容： <br><br><pre> <code class="xml hljs">install: - bash .travis.sh travis_install</code> </pre> <br> 如果有任何说明，可以通过删除连字符将它们转移到脚本中。 <br><br> 打开<i>.travis.sh</i>文件，然后将分析器安装添加到<i>travis_install（）</i>函数中： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_install</span></span></span></span>() { wget -q -O - https://files.viva64.com/etc/pubkey.txt \ | sudo apt-key add - sudo wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list sudo apt-get update -qq sudo apt-get install -qq pvs-studio }</code> </pre> <br> 现在将分析运行添加到<i>脚本</i>部分： <br><br><pre> <code class="xml hljs">script: - bash .travis.sh travis_script</code> </pre> <br> 在bash脚本中： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TRAVIS_PULL_REQUEST</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"false"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> git diff --name-only origin/HEAD &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w }</code> </pre> <br> 例如，如果您在CMake上进行了构建，则需要在构建项目后运行此代码： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { CMAKE_ARGS=<span class="hljs-string"><span class="hljs-string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=On </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CMAKE_ARGS}</span></span></span><span class="hljs-string">"</span></span> cmake <span class="hljs-variable"><span class="hljs-variable">$CMAKE_ARGS</span></span> CMakeLists.txt make -j8 }</code> </pre> <br> 结果会是这样的： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { CMAKE_ARGS=<span class="hljs-string"><span class="hljs-string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=On </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CMAKE_ARGS}</span></span></span><span class="hljs-string">"</span></span> cmake <span class="hljs-variable"><span class="hljs-variable">$CMAKE_ARGS</span></span> CMakeLists.txt make -j8 pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TRAVIS_PULL_REQUEST</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"false"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> git diff --name-only origin/HEAD &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w }</code> </pre> <br> 您可能已经注意到了指定的环境变量<i>$ TRAVIS_PULL_REQUEST</i>和<i>$ TRAVIS_BRANCH</i> 。  Travis CI自行宣布： <br><br><ul><li>  <i>$ TRAVIS_PULL_REQUEST</i>存储拉取<i>请求</i>号，如果是常规分支，则返回<i>false</i> ； </li><li>  <i>$ TRAVIS_REPO_SLUG</i>存储项目存储库的名称。 </li></ul><br> 此函数的算法： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/d21/1c5/9e2d211c559a48b4bf144bdd606e4bc7.png" alt="图片7"></div><br>  Travis CI会响应返回代码，因此警告的出现将告诉服务将提交标记为包含错误。 <br><br> 现在，让我们仔细看一下这行代码： <br><br><pre> <code class="bash hljs">git diff --name-only origin/HEAD &gt; .pvs-pr.list</code> </pre> <br> 事实是Travis CI在拉取请求分析期间自动合并分支： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/443/986/1f4/4439861f46637d41119e83f83e2e440b.png" alt="图片8"></div><br> 因此，我们分析<i>A4</i>而不是<i>B3-&gt; A3</i> 。 由于此功能，我们需要计算与<i>A3</i>的差， <i>A3</i>恰好是<i>原点</i>的分支顶部。 <br><br> 一个重要的细节仍然是头文件对已编译转换单元（* .c，* .cc，* .cpp等）的缓存依赖性。 分析器在文件列表检查模式下的第一次启动时计算这些依赖关系，然后将其保存在.PVS-Studio目录中。  Travis CI允许您缓存文件夹，因此我们将保存<i>.PVS-Studio /</i>目录的数据： <br><br><pre> <code class="xml hljs">cache: directories: - .PVS-Studio/</code> </pre> <br> 此代码需要添加到<i>.travis.yml</i>文件。 此目录存储分析后收集的各种数据，这将大大加快文件列表分析或增量分析的后续启动速度。 如果不这样做，那么分析器实际上将每次都分析所有文件。 <br><br><h2> 好友 </h2><br> 与Travis CI一样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Buddy</a>提供了自动构建和测试存储在GitHub上的项目的功能。 与Travis CI不同，它是在Web界面中配置的（提供bash支持），因此无需在项目中存储配置文件。 <br><br> 首先，我们需要向装配线添加一个新动作： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/2fd/36e/75e2fd36e9a4420ff74256429ff73e0c.gif" alt="图片1"></div><br> 我们指出用于构建项目的编译器。 请注意此操作中安装的Docker容器。 例如，有一个特殊的GCC容器： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95b/837/7ad/95b8377adbac7e50e55d97c5b318f56c.png" alt="图片6"></div><br> 现在安装PVS-Studio和必要的实用程序： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/fba/02b/88efba02b5a4c34f55c4344744812cc7.gif" alt="图片2"></div><br> 将以下行添加到编辑器： <br><br><pre> <code class="bash hljs">apt-get update &amp;&amp; apt-get -y install wget gnupg jq wget -q -O - https://files.viva64.com/etc/pubkey.txt | apt-key add - wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list apt-get update &amp;&amp; apt-get -y install pvs-studio</code> </pre> <br> 现在转到“运行”选项卡（第一个图标），并将以下代码添加到编辑器的相应字段中： <br><br><pre> <code class="bash hljs">pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${BUDDY_REPO_SLUG}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 如果您阅读有关Travs-CI的部分，那么您已经熟悉此代码，但是现在出现了一个新阶段： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/40f/ec9/61540fec9bc7edf2032a84bdaf5a28fe.png" alt="图片9"></div><br> 事实是，现在我们不分析合并的结果，而是分析发出拉取请求的分支的HEAD： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/722/646/68c/72264668c4a90b96ccb63f363a46c683.png" alt="图片10"></div><br> 因此，我们处于条件提交<i>B3中</i> ，我们需要与<i>A3</i>进行区别： <br><br><pre> <code class="bash hljs">PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${BUDDY_REPO_SLUG}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list</code> </pre> <br> 要确定<i>A3，请</i>使用GitHub API： <br><br><pre> <code class="bash hljs">https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${USERNAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${REPO}</span></span>/pulls/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span></code> </pre> <br> 我们使用了Buddy提供的以下变量： <br><br><ul><li>  <i>$ BUDDY_EXECUTION_PULL_REQEUST_NO-</i>拉取<i>请求</i>号； </li><li>  <i>$ BUDDY_REPO_SLUG-</i>用户名和存储库的组合（例如max / test）。 </li></ul><br> 现在，使用下面的按钮保存更改并启用拉取请求分析： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74c/5d6/876/74c5d6876c07c0b2e0c10cdabb8b0f78.gif" alt="图片3"></div><br> 与Travis CI不同，我们不需要指定<i>.pvs-studio</i>进行缓存，因为Buddy会自动缓存所有文件以供后续启动。 因此，剩下的最后一件事是在Buddy中保存PVS-Studio的登录名和密码。 保存更改后，我们将返回到管道。 我们需要继续设置变量并添加PVS-Studio的登录名和密钥： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/816/e3e/eb1816e3e4aff72ad55b187ec1ebf0a2.gif" alt="图片4"></div><br> 之后，出现新的请求或提交将触发检查。 如果提交中包含错误，那么Buddy将在拉取请求页面上指出这一点。 <br><br><h2> 传送带 </h2><br>  AppVeyor的设置类似于Buddy，因为一切都在Web界面中进行，并且无需将* .yml文件添加到项目存储库。 <br><br> 转到项目概述中的“设置”选项卡： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/2fc/576/f112fc576fc1f8bf7552625578093292.png" alt="图片12"></div><br> 向下滚动此页面，然后打开缓存保存以构建请求请求： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/8f3/f34/be88f3f34708075a49bdd13c65f5bc26.png" alt="图片18"></div><br> 现在转到“环境”选项卡，在此处为程序集指定图像和必要的环境变量： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/26a/80c/45326a80c62211c6b29bd16fad1ef0d1.png" alt="图片19"></div><br> 如果您阅读了前面的部分，您将非常了解这两个变量<i>-PVS_KEY</i>和<i>PVS_USERNAME</i> 。 如果不是，那么我提醒您，检查PVS-Studio分析仪的许可证是必需的。 将来，我们将在Bash脚本中再次与他们会面。 <br><br> 在下面的同一页面上，我们指示用于缓存的文件夹： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e2/967/dbf/4e2967dbfb796e2d0104d5b6539be65a.png" alt="图片15"></div><br> 如果不这样做，那么我们将分析整个项目而不是一对文件，但是我们将从指定的文件中获取输出。 因此，输入正确的目录名称很重要。 <br><br> 现在该检查脚本了。 打开测试选项卡，然后选择脚本： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/dbd/0d6/b5fdbd0d6d448174bc05222fe1965c1c.png" alt="图片20"></div><br> 将以下代码插入此表单： <br><br><pre> <code class="bash hljs">sudo apt-get update &amp;&amp; sudo apt-get -y install jq wget -q -O - https://files.viva64.com/etc/pubkey.txt \ | sudo apt-key add - sudo wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list sudo apt-get update &amp;&amp; sudo apt-get -y install pvs-studio pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> PWD=$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> -L) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ --dump-files --dump-log pvs-dump.log \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 请注意以下代码部分： <br><br><pre> <code class="bash hljs">PWD=$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> -L) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ --dump-files --dump-log pvs-dump.log \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br> 乍看之下，将pwd命令的值分配给应该存储此默认值的变量的相当具体的分配似乎很奇怪，但是，我现在将解释所有内容。 <br><br> 在AppVeyor中配置分析器时，我遇到了极其奇怪的分析器行为。 一方面，一切正常，但分析没有开始。 我花了很多时间注意到我们位于目录/ home / appveyor / projects / testcalc /中，并且分析器确定我们位于/ opt / appveyor / build-agent /中。 然后，我意识到$ PWD变量有点小了。 因此，在开始分析之前，我手动更新了它的值。 <br><br> 然后，一切如前所述： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0aa/4b9/a33/0aa4b9a3398ce2f52cc8e1df0833f459.png" alt="图片17"></div><br> 现在考虑以下代码片段： <br><br><pre> <code class="bash hljs">PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>`</code> </pre> <br> 在其中，我们获得了声明拉取请求的分支之间的差异。 为此，我们需要以下环境变量： <br><br><ul><li>  $ APPVEYOR_PULL_REQUEST_NUMBER-拉取请求的数量； </li><li>  $ APPVEYOR_REPO_NAME-项目用户名和存储库。 </li></ul><br><h2> 结论 </h2><br> 当然，我们并未考虑持续集成的所有可能服务，但是，它们彼此之间的工作细节非常相似。 除了缓存之外，每个服务都会创建自己的“自行车”，因此一切总是不同的。 <br><br> 在某些地方，例如在Travis-CI中，几行代码和缓存可以完美地工作。 就像AppVeyor中一样，您只需要在设置中指定文件夹即可； 但是您需要在某个地方创建唯一键并尝试说服系统，以便您有机会覆盖缓存的片段。 因此，如果您想在持续集成服务上配置对拉取请求的分析（上面没有讨论过），请首先确保您不会在缓存方面遇到问题。 <br><br> 谢谢您的关注。 如果无法解决问题，请随时写信给我们以寻求<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a> 。 我们会提示和帮助。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Maxim Zvyagintsev。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470984/">https://habr.com/ru/post/zh-CN470984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470974/index.html">分析师掌握的被动DNS</a></li>
<li><a href="../zh-CN470976/index.html">冰之歌（血腥企业）和火焰之歌（DevOps和IaC）</a></li>
<li><a href="../zh-CN470978/index.html">分析师市场研究：他们在哪里学习，使用什么工具以及赚多少钱</a></li>
<li><a href="../zh-CN470980/index.html">软件机器人（RPA）在银行业中解决的任务</a></li>
<li><a href="../zh-CN470982/index.html">使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</a></li>
<li><a href="../zh-CN470988/index.html">Slerm DevOps在莫斯科开放注册</a></li>
<li><a href="../zh-CN470990/index.html">在线营销工具包：3个可促进视觉传达的应用程序</a></li>
<li><a href="../zh-CN470994/index.html">从无聊的书呆子的角度继承JavaScript：Constructors Factory</a></li>
<li><a href="../zh-CN470996/index.html">简单的<img>标签如何对企业造成高风险？</a></li>
<li><a href="../zh-CN470998/index.html">木制玩具，第十部分-1996</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>