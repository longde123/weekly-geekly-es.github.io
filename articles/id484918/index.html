<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏽 🏭 🖌️ Proses anotasi tambahan untuk mempercepat pembuatan gradle 🤹 🔯 📓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dimulai dengan versi Gradle 4.7 dan Kotlin 1.3.30, menjadi mungkin untuk mendapatkan perakitan proyek inkremental yang dipercepat karena operasi yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proses anotasi tambahan untuk mempercepat pembuatan gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="gambar"></p><br><p>  Dimulai dengan versi Gradle 4.7 dan Kotlin 1.3.30, menjadi mungkin untuk mendapatkan perakitan proyek inkremental yang dipercepat karena operasi yang benar dari pemrosesan tambahan anotasi.  Dalam artikel ini, kami memahami bagaimana teori kompilasi tambahan dalam Gradle bekerja dalam teori, apa yang perlu dilakukan untuk melepaskan potensi penuhnya (tanpa kehilangan pembuatan kode pada saat yang sama), dan apa jenis peningkatan kecepatan majelis tambahan yang dapat dicapai dengan aktivasi pemrosesan tambahan penjelasan dalam praktik. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  Cara kompilasi tambahan bekerja </h2><br><p>  Build tambahan dalam Gradle diimplementasikan pada dua level.  Level pertama adalah untuk membatalkan dimulainya modul kompilasi ulang menggunakan <a href="https://docs.gradle.org/current/userguide/java_plugin.html">kompilasi menghindari</a> .  Yang kedua adalah kompilasi tambahan langsung, meluncurkan kompiler dalam kerangka satu modul hanya pada file-file yang telah berubah, atau secara langsung bergantung pada file yang diubah. </p><br><p>  Mari kita pertimbangkan kompilasi penghindaran pada contoh (diambil dari <a href="https://blog.gradle.org/incremental-compiler-avoidance">artikel</a> dari Gradle) dari proyek tiga modul: <strong>aplikasi</strong> , <strong>inti</strong> dan <strong>utilitas</strong> . </p><br><p>  Kelas utama modul <strong>aplikasi</strong> (tergantung pada <strong>inti</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  Dalam modul <strong>inti</strong> (tergantung pada <strong>utils</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  Dalam modul <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Urutan kompilasi pertama dari modul adalah sebagai berikut (sesuai dengan urutan dependensi): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>inti</strong> <br>  3) <strong>aplikasi</strong> </p><br><p>  Sekarang pertimbangkan apa yang terjadi ketika Anda mengubah implementasi internal kelas IOUtils: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Perubahan ini tidak mempengaruhi modul ABI.  ABI (Application Binary Interface) adalah representasi biner dari antarmuka publik dari modul yang dirakit.  Dalam kasus di mana perubahan hanya berkaitan dengan implementasi internal modul dan tidak memengaruhi antarmuka publik dengan cara apa pun, Gradle akan menggunakan kompilasi penghindaran dan mulai mengkompilasi ulang hanya modul <strong>utilitas</strong> .  Jika ABI modul <strong>utilitas</strong> terpengaruh (misalnya, metode publik tambahan muncul atau tanda tangan dari modul yang ada berubah), maka kompilasi modul <strong>inti juga</strong> akan dimulai, tetapi modul <strong>aplikasi yang</strong> bergantung pada <strong>inti</strong> tidak akan dikompilasi ulang secara transitif jika ketergantungan di dalamnya terhubung melalui <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">implementasi</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Ilustrasi penghindaran kompilasi di tingkat modul proyek</em> </p><br><p>  Tingkat kenaikan kedua adalah kenaikan pada tingkat peluncuran kompiler untuk file yang diubah secara langsung di dalam masing-masing modul. </p><br><p>  Sebagai contoh, tambahkan kelas baru ke modul <strong>inti</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Dan dalam <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Dalam hal ini, di kedua modul hanya perlu mengkompilasi ulang dua file baru (tanpa memengaruhi WordCount dan IOUtils yang ada dan tidak berubah), karena tidak ada ketergantungan antara kelas baru dan lama. </p><br><p>  Dengan demikian, kompiler inkremental menganalisis dependensi antara kelas dan mengkompilasi ulang saja: </p><br><ul><li>  kelas yang mengandung perubahan </li><li><p>  kelas yang secara langsung bergantung pada perubahan kelas </p><br><h2 id="inkrementalnyy-annotation-processing">  Pemrosesan anotasi tambahan </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="masukkan deskripsi gambar di sini"></p><br></li></ul><br><p>  Membuat kode menggunakan APT dan KAPT mengurangi waktu yang diperlukan untuk menulis dan men-debug kode boilerplate, tetapi pemrosesan anotasi dapat secara signifikan meningkatkan waktu pembuatan.  Untuk membuat keadaan menjadi lebih buruk, untuk waktu yang lama, pemrosesan anotasi secara fundamental mematahkan kemungkinan kompilasi tambahan di Gradle. </p><br><p>  Setiap prosesor anotasi dalam proyek memberitahu informasi kompilator tentang daftar anotasi yang diprosesnya.  Tetapi dari sudut pandang perakitan, pemrosesan anotasi adalah kotak hitam: Gradle tidak tahu apa yang akan dilakukan prosesor, khususnya, file mana yang akan dihasilkan dan di mana.  Hingga Gradle 4.7, kompilasi inkremental secara otomatis dinonaktifkan pada set sumber yang menggunakan prosesor anotasi. </p><br><p>  Dengan <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">dirilisnya</a> Gradle 4.7, kompilasi tambahan sekarang mendukung pemrosesan anotasi, tetapi hanya untuk APT.  Di KAPT, dukungan untuk anotasi tambahan telah <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">diperkenalkan</a> dengan Kotlin 1.3.30.  Itu juga memerlukan <a href="https://docs.gradle.org/current/userguide/java_plugin.html">dukungan</a> dari perpustakaan yang menyediakan prosesor anotasi.  Pengembang prosesor anotasi memiliki kesempatan untuk secara eksplisit mengatur kategori prosesor, dengan demikian menginformasikan Gradle informasi yang diperlukan agar kompilasi tambahan berfungsi. </p><br><h2 id="kategorii-processorov-annotaciy">  Kategori Prosesor Anotasi </h2><br><p>  Gradle mendukung dua kategori prosesor: </p><br><p>  <strong>Mengisolasi</strong> - prosesor tersebut harus membuat semua keputusan untuk pembuatan kode hanya berdasarkan informasi dari <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> yang dikaitkan dengan elemen anotasi tertentu.  Ini adalah kategori tercepat dari prosesor anotasi, karena Gradle mungkin tidak me-restart prosesor dan menggunakan file yang dihasilkan sebelumnya jika tidak ada perubahan pada file sumber. </p><br><p>  <strong>Agregasi</strong> - digunakan untuk prosesor yang membuat keputusan berdasarkan beberapa input (misalnya, analisis anotasi dalam beberapa file sekaligus atau berdasarkan studi AST, yang dapat dijangkau secara transparan dari elemen yang dianotasi).  Setiap kali, Gradle akan memulai prosesor untuk file yang menggunakan anotasi dari prosesor agregasi, tetapi tidak akan mengkompilasi ulang file yang dihasilkannya jika tidak ada perubahan pada mereka. </p><br><p>  Untuk banyak perpustakaan populer berdasarkan pembuatan kode, dukungan kompilasi tambahan sudah diterapkan di versi terbaru.  Lihat daftar perpustakaan yang mendukungnya di <a href="https://docs.gradle.org/current/userguide/java_plugin.html">sini</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Pengalaman kami menerapkan pemrosesan anotasi tambahan </h2><br><p>  Sekarang untuk proyek-proyek yang dimulai dari awal dan menggunakan versi terbaru dari perpustakaan dan plugins gradle, build incremental kemungkinan besar akan aktif secara default.  Tetapi bagian terbesar dari peningkatan produktivitas perakitan dapat dicapai dengan penambahan pemrosesan anotasi pada proyek-proyek besar dan berumur panjang.  Dalam hal ini, pembaruan versi besar-besaran mungkin diperlukan.  Apakah ini sepadan dengan praktiknya?  Ayo lihat! </p><br><p>  Jadi, agar pemrosesan tambahan anotasi berfungsi, kita perlu: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Semua prosesor anotasi dalam proyek kami harus memiliki dukungannya.  Ini sangat penting, karena jika dalam satu modul setidaknya satu prosesor tidak mendukung incrementality, Gradle akan menonaktifkannya untuk seluruh modul.  Semua file dalam modul akan dikompilasi lagi setiap kali!  Salah satu opsi alternatif untuk mendapatkan dukungan untuk kompilasi tambahan tanpa memutakhirkan versi adalah penghapusan semua kode menggunakan prosesor anotasi dalam modul terpisah.  Dalam modul yang tidak memiliki prosesor anotasi, kompilasi tambahan akan berfungsi dengan baik </li></ul><br><p>  Untuk mendeteksi prosesor yang tidak memenuhi kondisi terakhir, Anda dapat menjalankan perakitan dengan flag <em>-Pkapt.verbose = true</em> .  Jika Gradle terpaksa menonaktifkan pemrosesan anotasi tambahan untuk satu modul, maka dalam log pembangunan kita akan melihat pesan tentang prosesor mana dan di mana modul ini terjadi (lihat nama tugas): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  Pada proyek perpustakaan kami dengan prosesor anotasi non-tambahan, ada 3: </p><br><ul><li>  Tusuk gigi </li><li>  Kamar </li><li>  IzinDatchatcher </li></ul><br><p>  Untungnya, perpustakaan ini didukung secara aktif, dan versi terbaru mereka sudah memiliki dukungan tambahan.  Selain itu, semua prosesor anotasi dalam versi terbaru dari perpustakaan ini memiliki kategori yang optimal - isolasi.  Dalam proses meningkatkan versi, saya harus berurusan dengan refactoring karena perubahan dalam API library Toothpick, yang mempengaruhi hampir setiap modul kita.  Tetapi dalam kasus ini, kami beruntung, dan ternyata menjadi refactoring sepenuhnya secara otomatis menggunakan nama penggantian otomatis dari metode perpustakaan umum yang digunakan. </p><br><p>  Perhatikan bahwa jika Anda menggunakan perpustakaan Room, Anda harus secara eksplisit melewati <em>room.incremental: true</em> flag ke prosesor anotasi.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Sebuah contoh</a>  Di masa depan, pengembang Kamar <a href="https://developer.android.com/jetpack/androidx/releases/room">berencana</a> untuk mengaktifkan bendera ini secara default. </p><br><p>  Untuk versi Kotlin 1.3.30-1.3.50, Anda harus mengaktifkan dukungan untuk pemrosesan anotasi tambahan <strong>secara eksplisit</strong> melalui <em>kapt.incremental.apt = true</em> dalam file properti gradle.properties proyek.  Dimulai dengan versi 1.3.50, opsi ini disetel ke true secara default. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Profil perakitan tambahan </h2><br><p>  Setelah versi semua dependensi yang diperlukan telah dinaikkan, sekarang saatnya untuk menguji kecepatan build tambahan.  Untuk melakukan ini, kami menggunakan seperangkat alat dan teknik berikut: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Pemindaian gradle build</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">gradle-profiler</a> </li><li>  Untuk menjalankan skrip dengan pemrosesan anotasi inkremental yang diaktifkan dan dinonaktifkan, properti <em>gradle kapt.incremental.apt = [true | false] digunakan</em> </li><li>  Untuk hasil yang konsisten dan informatif, majelis dibesarkan di lingkungan CI yang terpisah.  Inkrementalitas build direproduksi menggunakan gradle-profiler </li></ul><br><p>  gradle-profiler memungkinkan <a href="https://github.com/gradle/gradle-profiler">skrip</a> deklaratif untuk <a href="https://github.com/gradle/gradle-profiler">skrip</a> build tambahan.  4 skenario disusun berdasarkan kondisi berikut: </p><br><ul><li>  Memodifikasi file memengaruhi / tidak memengaruhi ABI-nya </li><li>  Dukungan untuk pemrosesan anotasi tambahan on / off </li></ul><br><p>  Jalankan masing-masing skenario adalah urutan: </p><br><ul><li>  Mulai ulang daemon gradle </li><li>  Luncurkan build-up builds </li><li>  Jalankan 10 rakitan tambahan, sebelum masing-masing file diubah dengan menambahkan metode baru (pribadi untuk perubahan non-ABI dan publik untuk perubahan ABI) </li></ul><br><p>  Semua build dilakukan dengan Gradle 5.4.1.  File yang terlibat dalam perubahan mengacu pada salah satu modul inti proyek (umum), yang darinya 40 modul (termasuk inti dan fitur) bergantung langsung.  File ini menggunakan anotasi untuk mengisolasi prosesor. </p><br><p>  Juga perlu dicatat bahwa menjalankan benchmark dilakukan pada dua tugas <em>gradle</em> : <em>ompileDebugSources</em> dan <em>assembleDebug</em> .  Yang pertama hanya memulai kompilasi file dengan kode sumber, tanpa melakukan pekerjaan apa pun dengan sumber daya dan menggabungkan aplikasi menjadi file .apk.  Berdasarkan fakta bahwa kompilasi tambahan hanya memengaruhi file .kt dan .java, tugas <em>compileDedugSource</em> dipilih untuk pembandingan yang lebih terisolasi dan lebih cepat.  Dalam kondisi pengembangan nyata, ketika Anda me-restart aplikasi, Android Studio menggunakan tugas <em>assembleDebug</em> , yang mencakup generasi penuh versi debug aplikasi. </p><br><h2 id="rezultaty-benchmarkov">  Hasil benchmark </h2><br><p>  Di semua grafik yang dihasilkan oleh gradle-profiler, sumbu vertikal menunjukkan waktu rakitan tambahan dalam milidetik, dan sumbu horizontal menunjukkan angka mulai rakitan. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource sebelum memperbarui prosesor anotasi </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="masukkan deskripsi gambar di sini"><br>  Waktu berjalan rata-rata untuk setiap skenario adalah 38 detik sebelum memperbarui prosesor anotasi ke versi yang mendukung inkrementalitas.  Dalam hal ini, Gradle menonaktifkan dukungan untuk kompilasi tambahan, sehingga tidak ada perbedaan yang signifikan antara skrip. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource setelah memperbarui prosesor anotasi </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Skenario </th><th>  Perubahan ABI inkremental </th><th>  Perubahan ABI non-incremental </th><th>  Perubahan non-ABI inkremental </th><th>  Perubahan non-abi non-inkremental </th></tr></thead><tbody><tr><td>  <strong>jahat</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>median</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>maks</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193.29 </td><td>  1240.81 </td><td>  888.24 </td><td>  815.91 </td></tr></tbody></table></div><br><p>  Pengurangan rata-rata dalam waktu perakitan karena inkrementalitas adalah 31% untuk perubahan ABI dan 32,5% untuk perubahan non-ABI.  Dalam nilai absolut, sekitar 10 detik. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug setelah memperbarui prosesor anotasi </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Skenario </th><th>  Perubahan ABI inkremental </th><th>  Perubahan ABI non-incremental </th><th>  Perubahan non-ABI inkremental </th><th>  Perubahan non-abi non-inkremental </th></tr></thead><tbody><tr><td>  <strong>jahat</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>median</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>maks</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953.28 </td><td>  1011.20 </td><td>  1015.37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Untuk membangun versi debug penuh aplikasi pada proyek kami, penurunan rata-rata dalam waktu pembangunan karena peningkatan adalah 21,5% untuk perubahan ABI dan 23% untuk perubahan non-ABI.  Secara absolut, kira-kira sama 10 detik, karena penambahan kompilasi kode sumber tidak mempengaruhi kecepatan perakitan sumber daya. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Build Scan Anatomy dalam Gradle Build Scan </h2><br><p>  Untuk pemahaman yang lebih dalam tentang bagaimana peningkatan dicapai selama kompilasi tambahan, kami membandingkan pemindaian majelis inkremental dan non-inkremental. </p><br><p>  Dalam kasus kenaikan KAPT yang dinonaktifkan, bagian utama waktu pembuatan adalah kompilasi modul aplikasi, yang tidak dapat diparalelkan dengan tugas lain.  Batas waktu untuk KAPT non-inkremental adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="masukkan deskripsi gambar di sini"></p><br><p>  Eksekusi tugas: kaptDebugKotlin dari modul aplikasi kami membutuhkan waktu sekitar 8 detik dalam kasus ini. </p><br><p>  Garis waktu untuk kasus dengan kenaikan KAPT diaktifkan: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="masukkan deskripsi gambar di sini"></p><br><p>  Sekarang modul aplikasi telah dikompilasi ulang dalam waktu kurang dari satu detik.  Penting untuk memperhatikan ketidakseimbangan visual dari skala dari dua pemindaian dalam picch di atas.  Tugas yang tampak lebih pendek di gambar pertama tidak harus lebih lama di gambar kedua, di mana mereka tampak lebih lama.  Tetapi sangat nyata seberapa besar proporsi kompilasi ulang modul-aplikasi menurun ketika Anda mengaktifkan KAPT tambahan.  Dalam kasus kami, kami menang sekitar 8 detik pada modul ini dan tambahan sekitar 2 detik pada modul yang lebih kecil yang dikompilasi secara paralel. </p><br><p>  Pada saat yang sama, total waktu eksekusi dari semua tugas * kapt untuk inkrementalitas dinonaktifkan dari anotasi pemrosesan adalah 1 menit dan 36 detik terhadap 55 detik ketika diaktifkan.  Artinya, tanpa memperhitungkan perakitan paralel modul, keuntungannya lebih besar. </p><br><p>  Perlu juga dicatat bahwa hasil benchmark di atas disiapkan pada lingkungan CI dengan kemampuan untuk menjalankan 24 thread paralel untuk perakitan.  Pada lingkungan 8-utas, keuntungan dari mengaktifkan pemrosesan anotasi tambahan adalah sekitar 20-30 detik pada proyek kami. </p><br><h2 id="incremental-vs--parallel">  Incremental vs (?) Paralel </h2><br><p>  Cara lain untuk mempercepat perakitan secara signifikan (baik inkremental dan bersih) adalah melakukan tugas gradle secara paralel dengan memecah proyek menjadi sejumlah besar modul yang digabungkan secara longgar.  Dengan satu atau lain cara, modularisasi mewakili potensi yang jauh lebih besar untuk mempercepat majelis daripada menggunakan KAPT tambahan.  Tetapi semakin monolitik proyek tersebut, dan semakin banyak generasi kode digunakan di dalamnya, semakin besar pula proses penambahan anotasi.  Lebih mudah untuk mendapatkan efek incrementality lengkap rakitan daripada memecah aplikasi menjadi modul.  Namun demikian, kedua pendekatan tersebut tidak saling bertentangan dan saling melengkapi. </p><br><h2 id="itog">  Ringkasan </h2><br><ul><li>  Dimasukkannya pemrosesan tambahan anotasi pada proyek kami memungkinkan kami untuk mencapai peningkatan 20% dalam kecepatan pembangunan kembali lokal </li><li>  Untuk mengaktifkan pemrosesan anotasi tambahan, akan berguna untuk mempelajari log lengkap rakitan saat ini dan mencari pesan peringatan dengan teks "Permintaan pemrosesan anotasi tambahan diminta, tetapi dukungan dinonaktifkan karena prosesor berikut ini bukan tambahan ...".  Diperlukan untuk meningkatkan versi perpustakaan ke versi dengan dukungan untuk pemrosesan anotasi tambahan dan memiliki versi Gradle 4.7+, Kotlin 1.3.30+ </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Bahan dan apa yang harus dibaca tentang topik tersebut </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Tentang dukungan untuk pemrosesan anotasi tambahan di tingkat plugin Java Gradle</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Artikel tentang gradle-profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Lebih lanjut tentang fitur KAPT</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Laporkan di Google I / O 2019 dengan trik akselerasi membangun saat ini</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Laporan lain tentang Optimalisasi Gradle di Google I / O 2017, termasuk bahan build tambahan dan kompilasi penghindaran</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484918/">https://habr.com/ru/post/id484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484902/index.html">Pada persamaan derajat yang lebih tinggi</a></li>
<li><a href="../id484904/index.html">Setahun tanpa Splunk - bagaimana sebuah perusahaan Amerika mengubah pasar untuk analisis data mesin di Rusia dan yang ditinggalkannya</a></li>
<li><a href="../id484906/index.html">Tim terdistribusi dan tim memimpin pada remote</a></li>
<li><a href="../id484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): apa yang harus dilakukan ketika satu menit downtime berharga $ 100,000</a></li>
<li><a href="../id484910/index.html">Paul Graham: Pembenci</a></li>
<li><a href="../id484920/index.html">Bagaimana memahami bahwa Anda adalah operator mesin penggilingan?</a></li>
<li><a href="../id484930/index.html">Mari fastcode seperti profesional</a></li>
<li><a href="../id484932/index.html">Sifat ganda persyaratan perangkat lunak</a></li>
<li><a href="../id484934/index.html">Dari pengembangan pribadi hingga Agile dalam skala XXXL dalam dua hari di TeamLead Conf</a></li>
<li><a href="../id484936/index.html">Pengetahuan dan kompetensi dalam tim: menemukan, melihat, memompa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>