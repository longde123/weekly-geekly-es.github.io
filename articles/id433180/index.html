<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â£ï¸ ğŸ‘©ğŸ»â€ğŸ³ ğŸ‘°ğŸ» Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan ğŸ‘¦ ğŸ¤¯ ğŸ”­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, saya ingin berbicara tentang masalah apa dengan tipe data di Ruby, masalah apa yang saya temui, bagaimana mereka dapat dipecahkan d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433180/">  Dalam artikel ini, saya ingin berbicara tentang masalah apa dengan tipe data di Ruby, masalah apa yang saya temui, bagaimana mereka dapat dipecahkan dan bagaimana memastikan bahwa data yang bekerja dengan kita dapat diandalkan. <br><br><img src="https://habrastorage.org/webt/re/27/5n/re275nqouf3ucrd8gxrmv0cvboq.png" alt="gambar"><br><a name="habracut"></a><br>  Pertama, Anda perlu memutuskan tipe data apa.  Saya melihat definisi istilah yang sangat sukses, yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HaskellWiki</a> . <br><blockquote>  Jenis adalah bagaimana Anda menggambarkan data yang akan dikerjakan oleh program Anda. </blockquote>  Tapi apa yang salah dengan tipe data di Ruby?  Untuk menggambarkan masalah secara komprehensif, saya ingin menyoroti beberapa alasan. <br><br><h4>  Alasan 1. Masalah Ruby itu sendiri </h4><br>  Seperti yang Anda ketahui, Ruby menggunakan <b>pengetikan dinamis yang ketat dengan dukungan untuk apa yang disebut.</b>  <b>mengetik bebek</b> .  Apa artinya ini? <br><br>  Pengetikan yang kuat membutuhkan pengecoran eksplisit dan tidak menghasilkan casting ini sendiri, seperti yang terjadi, misalnya, dalam JavaScript.  Karenanya, daftar kode berikut di Ruby akan gagal: <br><br><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">'1'</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> #=&gt; <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> can<span class="hljs-string"><span class="hljs-string">'t be coerced into Integer)</span></span></code> </pre> <br>  Dalam pengetikan dinamis, pengecekan tipe berlangsung dalam runtime, yang memungkinkan kami untuk tidak menentukan tipe variabel dan menggunakan variabel yang sama untuk menyimpan nilai dari tipe yang berbeda: <br><br><pre> <code class="javascript hljs">x = <span class="hljs-number"><span class="hljs-number">123</span></span> x = <span class="hljs-string"><span class="hljs-string">"123"</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Pernyataan berikut ini biasanya diberikan sebagai penjelasan dari istilah "mengetik bebek": jika terlihat seperti bebek, berenang seperti bebek dan dukun seperti bebek, maka kemungkinan besar ini adalah bebek.  Yaitu  mengetik bebek, mengandalkan perilaku objek, memberi kita fleksibilitas tambahan dalam menulis sistem kami.  Misalnya, dalam contoh di bawah ini, nilai bagi kami bukan jenis argumen <code>collection</code> , tetapi kemampuannya untuk menanggapi pesan <code>blank?</code>  dan <code>map</code> : <br><br><pre> <code class="javascript hljs">def process(collection) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> collection.blank? collection.map { |item| do_something_with(item) } end</code> </pre><br>  Kemampuan untuk membuat "bebek" seperti itu adalah alat yang sangat kuat.  Namun, seperti alat kuat lainnya, itu membutuhkan kehati-hatian saat menggunakannya.  Ini dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diverifikasi oleh penelitian Rollbar</a> , di mana mereka menganalisis lebih dari 1000 aplikasi Rail dan mengidentifikasi kesalahan yang paling umum.  Dan 2 dari 10 kesalahan paling umum dihubungkan tepat dengan fakta bahwa objek tidak dapat menanggapi pesan tertentu.  Dan karena itu, memeriksa perilaku objek yang diberikan oleh mengetik bebek pada kita dalam banyak kasus mungkin tidak cukup. <br><br>  Kita dapat mengamati bagaimana pemeriksaan jenis ditambahkan ke bahasa dinamis dalam satu bentuk atau yang lain: <br><br><ul><li>  TypeScript membawa pengecekan tipe ke pengembang JavaScript </li><li>  Petunjuk tipe ditambahkan dalam Python 3 </li><li>  Dialyzer melakukan pekerjaan yang baik untuk memeriksa tipe Erlang / Elixir </li><li>  Curam dan Sorbet tambahkan pengecekan tipe dalam Ruby 2.x </li></ul><br>  Namun, sebelum berbicara tentang alat lain untuk bekerja dengan jenis yang lebih efisien di Ruby, mari kita lihat dua masalah lagi yang ingin saya temukan solusinya. <br><br><h4>  Alasan 2. Masalah umum pengembang dalam berbagai bahasa pemrograman </h4><br>  Mari kita mengingat kembali definisi tipe data yang saya berikan di awal artikel: <blockquote>  Jenis adalah bagaimana Anda menggambarkan data yang akan dikerjakan oleh program Anda. </blockquote>  Yaitu  tipe dirancang untuk membantu kami menggambarkan data dari area subjek kami di mana sistem kami beroperasi.  Namun, seringkali alih-alih beroperasi dengan tipe data yang kami buat dari area subjek kami, kami menggunakan tipe primitif, seperti angka, string, array, dll., Yang tidak mengatakan apa pun tentang area subjek kami.  Masalah ini biasanya diklasifikasikan sebagai Obsesi Primitif (obsesi dengan primitif). <br><br>  Berikut adalah contoh Obsesi Primitif yang khas: <br><br><pre> <code class="javascript hljs">price = <span class="hljs-number"><span class="hljs-number">9.99</span></span> # vs Money = Struct.new(:amount_cents, :currency) price = Money.new(<span class="hljs-number"><span class="hljs-number">9</span></span>_99, <span class="hljs-string"><span class="hljs-string">'USD'</span></span>)</code> </pre><br>  Alih-alih menggambarkan tipe data untuk bekerja dengan uang, angka reguler sering digunakan.  Dan angka ini, seperti jenis primitif lainnya, tidak mengatakan apa-apa tentang bidang subjek kita.  Menurut pendapat saya, ini adalah masalah terbesar dalam menggunakan primitif daripada membuat sistem tipe Anda sendiri, di mana tipe ini akan menggambarkan data dari area subjek kami.  Kami sendiri menolak kelebihan yang bisa kami dapatkan dengan penggunaan tipe. <br><br>  Saya akan berbicara tentang keuntungan ini segera setelah membahas masalah lain yang diajarkan kerangka kerja Ruby on Rails kami, terima kasih yang, saya yakin, sebagian besar dari mereka di sini datang ke Ruby. <br><br><h4>  Alasan 3. Masalah yang biasa dialami kerangka kerja Ruby on Rails kami </h4><br>  Ruby on Rails, atau lebih tepatnya kerangka ORM <code>ActiveRecord</code> dibangun di dalamnya, mengajarkan kita bahwa objek yang berada dalam keadaan tidak valid adalah normal.  Menurut saya, ini jauh dari ide terbaik.  Dan saya akan mencoba menjelaskannya. <br><br>  Ambil contoh ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">validates</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">presence</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class"> </span></span>= App.new app.valid? # =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br>  Tidak sulit untuk memahami bahwa objek <code>app</code> akan memiliki keadaan tidak valid: validasi model <code>App</code> mengharuskan objek model ini memiliki atribut <code>platform</code> , dan objek kami memiliki atribut ini kosong. <br><br>  Sekarang, mari kita coba meneruskan objek ini dalam keadaan tidak valid ke layanan yang mengharapkan objek <code>App</code> sebagai argumen dan melakukan beberapa tindakan tergantung pada atribut <code>platform</code> objek ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoSomethingWithAppPlatform</span></span></span><span class="hljs-class"> # @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class"> [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class"> # # @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">) # </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">something</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoSomethingWithAppPlatform</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Dalam hal ini, bahkan pemeriksaan tipe akan berlalu.  Namun, karena atribut ini kosong untuk objek, tidak jelas bagaimana layanan akan menangani kasus ini.  Bagaimanapun, memiliki kemampuan untuk membuat objek dalam keadaan tidak valid, kami mengutuk diri kita sendiri dengan kebutuhan untuk terus menangani kasus ketika negara yang tidak valid telah bocor ke sistem kami. <br><br>  Tapi mari kita pikirkan masalah yang lebih dalam.  Secara umum, mengapa kita memeriksa validitas data?  Sebagai aturan, untuk memastikan bahwa keadaan yang tidak valid tidak bocor ke sistem kami.  Jika sangat penting untuk memastikan bahwa keadaan yang tidak valid tidak diizinkan, lalu mengapa kita membiarkan objek dengan keadaan yang tidak valid dibuat?  Terutama ketika kita berhadapan dengan objek penting seperti model ActiveRecord, yang sering merujuk pada logika bisnis root.  Menurut pendapat saya, ini kedengarannya seperti ide yang sangat buruk. <br><br>  Jadi, meringkas semua hal di atas, kami mendapatkan masalah berikut dalam bekerja dengan data di Ruby / Rails: <br><br><ul><li>  bahasa itu sendiri memiliki mekanisme untuk memverifikasi perilaku, tetapi bukan data </li><li>  kami, seperti pengembang dalam bahasa lain, cenderung menggunakan tipe data primitif daripada membuat sistem tipe untuk area subjek kami </li><li>  Rails membiasakan kita dengan fakta bahwa keberadaan benda-benda dalam keadaan tidak valid adalah normal, meskipun solusi seperti itu sepertinya ide yang sangat buruk </li></ul><br><h4>  Bagaimana mengatasi masalah ini? </h4><br>  Saya ingin mempertimbangkan salah satu solusi untuk masalah yang dijelaskan di atas, menggunakan contoh implementasi fitur nyata di Appodeal.  Dalam proses pengumpulan statistik pada statistik Pengguna Aktif Harian (selanjutnya DAU) untuk aplikasi yang menggunakan Appodeal untuk memonetisasi, kami sampai pada sekitar struktur data berikut yang perlu kami kumpulkan: <br><br><pre> <code class="javascript hljs">DailyActiveUsersData = Struct.new( :app_id, :country_id, :user_id, :ad_type, :platform_id, :ad_id, :first_request_date, <span class="hljs-attr"><span class="hljs-attr">keyword_init</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> )</code> </pre><br>  Struktur ini memiliki semua masalah yang sama yang saya tulis di atas: <br><br><ul><li>  pengecekan tipe apa pun sama sekali tidak ada, yang membuatnya tidak jelas nilai apa yang dapat diambil atribut dari struktur ini </li><li>  tidak ada deskripsi data yang digunakan dalam struktur ini, dan alih-alih jenis khusus untuk domain kami, primitif digunakan </li><li>  struktur mungkin ada dalam keadaan tidak valid </li></ul><br>  Untuk mengatasi masalah ini, kami memutuskan untuk menggunakan perpustakaan <code>dry-types</code> <code>dry-struct</code> dan <code>dry-struct</code> .  <code>dry-types</code> adalah sistem tipe sederhana dan dapat dikembangkan untuk Ruby, berguna untuk casting, menerapkan berbagai kendala, mendefinisikan struktur kompleks, dll. <code>dry-struct</code> adalah perpustakaan yang dibangun di atas <code>dry-types</code> yang menyediakan DSL yang nyaman untuk mendefinisikan struktur yang diketik / kelas. <br><br>  Untuk menggambarkan data area subjek kami yang digunakan dalam struktur untuk mengumpulkan DAU, sistem tipe berikut ini dibuat: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Types include Dry::Types.module AdTypeId = Types::Strict::Integer.enum(AD_TYPES.invert) EntityId = Types::Strict::Integer.constrained(gt: <span class="hljs-number"><span class="hljs-number">0</span></span>) PlatformId = Types::Strict::Integer.enum(PLATFORMS.invert) Uuid = Types::Strict::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.constrained(format: UUID_REGEX) Zero = Types.Constant(<span class="hljs-number"><span class="hljs-number">0</span></span>) end</code> </pre><br>  Sekarang kami telah menerima deskripsi data yang digunakan dalam sistem kami dan yang dapat kami gunakan dalam struktur.  Seperti yang Anda lihat, tipe <code>EntityId</code> dan <code>Uuid</code> memiliki beberapa keterbatasan, dan tipe enumerable <code>AdTypeId</code> dan <code>PlatformId</code> hanya dapat memiliki nilai dari set tertentu.  Bagaimana cara kerjanya dengan jenis ini?  Pertimbangkan <code>PlatformId</code> sebagai contoh: <br><br><pre> <code class="javascript hljs">#     enumerable- PLATFORMS = { <span class="hljs-string"><span class="hljs-string">'android'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fire_os'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'ios'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> }.freeze #       , #     Types::PlatformId[<span class="hljs-number"><span class="hljs-number">1</span></span>] == Types::PlatformId[<span class="hljs-string"><span class="hljs-string">'android'</span></span>] #    ,    #   ,     Types::PlatformId[<span class="hljs-string"><span class="hljs-string">'fire_os'</span></span>] # =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> #     ,   Types::PlatformId[<span class="hljs-string"><span class="hljs-string">'windows'</span></span>] # =&gt; Dry::Types::ConstraintError</code> </pre><br>  Jadi, menggunakan tipe-tipe itu sendiri sudah diketahui.  Sekarang mari kita terapkan pada struktur kita.  Sebagai hasilnya, kami mendapatkan ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DailyActiveUsersData</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dry</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app_id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">country_id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ad_type</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdTypeId</span></span></span><span class="hljs-class"> Ç€ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zero</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlarformId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ad_id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Uuid</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_request_date</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strict</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Apa yang kita lihat sekarang dalam struktur data untuk DAU?  Dengan menggunakan <code>dry-types</code> <code>dry-struct</code> dan <code>dry-struct</code> kami menyingkirkan masalah yang terkait dengan kurangnya pemeriksaan tipe data dan kurangnya deskripsi data.  Sekarang, siapa pun yang melihat struktur ini dan deskripsi jenis yang digunakan di dalamnya dapat memahami nilai apa yang dapat diambil setiap atribut. <br><br>  Adapun masalah dengan objek dalam keadaan tidak valid, <code>dry-struct</code> menyelamatkan kita dari ini: jika kita mencoba menginisialisasi struktur dengan nilai-nilai tidak valid, kita akan mendapatkan kesalahan sebagai hasilnya.  Dan untuk kasus-kasus di mana kebenaran data sangat penting (dan dalam kasus pengumpulan DAU, ini kasusnya dengan kami), menurut pendapat saya, mendapatkan pengecualian jauh lebih baik daripada mencoba menangani data yang tidak valid nanti.  Selain itu, jika proses pengujian telah ditetapkan untuk Anda (dan ini persis sama dengan kami), maka dengan probabilitas tinggi kode yang menghasilkan kesalahan tersebut tidak akan mencapai lingkungan produksi. <br><br>  Dan selain ketidakmampuan menginisialisasi objek dalam keadaan tidak valid, <code>dry-struct</code> juga tidak memungkinkan perubahan objek setelah inisialisasi.  Berkat kedua faktor ini, kami mendapatkan jaminan bahwa objek dari struktur tersebut akan berada dalam kondisi yang valid dan Anda dapat dengan aman mengandalkan data ini di mana pun di sistem Anda. <br><br><h4>  Ringkasan </h4><br>  Pada artikel ini saya mencoba menjelaskan masalah yang mungkin Anda temui saat bekerja dengan data di Ruby, serta berbicara tentang alat yang kami gunakan untuk menyelesaikan masalah ini.  Dan berkat penerapan alat-alat ini, saya benar-benar berhenti khawatir tentang kebenaran data yang sedang kami kerjakan.  Bukankah itu sempurna?  Bukankah ini tujuan dari instrumen apa pun - untuk memudahkan hidup kita dalam beberapa aspek?  Dan menurut saya, <code>dry-types</code> <code>dry-struct</code> dan <code>dry-struct</code> tugasnya dengan sempurna! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433180/">https://habr.com/ru/post/id433180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433170/index.html">Bagaimana kami tidak bisa mengulang arsitektur perusahaan</a></li>
<li><a href="../id433172/index.html">Kami kencangkan multipemain ke game seluler "Buat kata-kata dari kata-kata" di iOS dan Android, ditulis dalam C ++</a></li>
<li><a href="../id433174/index.html">Tidak semua tambalan sama-sama bermanfaat.</a></li>
<li><a href="../id433176/index.html">Certificate Remote Authentication Docker Remote dengan verifikasi pencabutan</a></li>
<li><a href="../id433178/index.html">Bagaimana kami memulihkan file .wav yang rusak</a></li>
<li><a href="../id433182/index.html">Apakah mungkin untuk melatih agen untuk perdagangan di pasar saham dengan bala bantuan? Implementasi bahasa R</a></li>
<li><a href="../id433184/index.html">ASP.NET Core 2.2 dirilis. Apa yang baru? (2 dari 3)</a></li>
<li><a href="../id433186/index.html">Tidak cukup hanya dengan menghitung poligon untuk mengoptimalkan model 3D</a></li>
<li><a href="../id433188/index.html">Negara Duma memperkenalkan RUU tentang pekerjaan otonom Runet</a></li>
<li><a href="../id433192/index.html">Kubernetes: Solusi Proyek Pribadi yang Luar Biasa Terjangkau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>