<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➖ 👩🏿‍⚖️ 🥐 Piala Mini AI # 3: Menulis Bot Top 🐝 ❌ 🎅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal musim gugur, kompetisi untuk menulis bot Mini AI Cup # 3 (alias Mobil Gila) selesai, di mana para peserta harus bertarung dengan mobil. Pese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Piala Mini AI # 3: Menulis Bot Top</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430466/"><p><img src="https://habrastorage.org/webt/uk/nd/_2/uknd_2qxbi4b0qt85hqcoxgvt7i.png"></p><br><p>  Pada awal musim gugur, kompetisi untuk menulis bot <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mini AI Cup # 3</a> (alias Mobil Gila) selesai, di mana para peserta harus bertarung dengan mobil.  Peserta banyak berdebat tentang apa yang akan berhasil dan apa yang tidak akan berhasil, ide-ide diungkapkan dan diuji dari jika sederhana untuk melatih jaringan saraf, tetapi tempat-tempat teratas diambil oleh orang-orang dengan apa yang disebut "simulasi".  Mari kita coba memahami apa itu, membandingkan solusi untuk tempat ke-1, ke-3 dan ke-4 dan berdiskusi tentang topik solusi lain yang mungkin. </p><a name="habracut"></a><br><h1 id="diskleymer">  Penafian </h1><br><p>  Artikel ini ditulis bekerja sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexei Dichkovsky (Commandos)</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Kiselev (Valdemar)</a> . </p><br><p>  Bagi mereka yang hanya ingin membaca tentang keputusan pemenang, saya sarankan Anda untuk segera mulai dengan item "Simulasi". </p><br><h1 id="postanovka-zadachi">  Pernyataan masalah </h1><br><p> Kali ini, mekanisme dunia sangat mirip dengan game mobile Drive Ahead: para pemain diberi mobil dengan tombol yang terletak di sana;  tugasnya adalah menekan tombol musuh lebih cepat dari yang dilakukannya.  Jika tidak ada yang menang dalam 600 kutu game, kartu mulai tenggelam ke tumpukan sampah, yang juga dapat menekan tombol.  Dengan kata lain, Anda perlu melindungi tombol Anda dari musuh, dunia di sekitar Anda dan banyak sampah (sangat, ya).  Setiap pemain diberikan 5 nyawa, permainan berlangsung dari 5 hingga 9 putaran, sementara seseorang tidak mengakhiri hidup mereka.  Setiap putaran diadakan pada peta acak dan mobil, sama untuk kedua peserta.  Total ada 6 kartu yang berbeda dan 3 jenis mobil - total 18 kombinasi yang berbeda. </p><br><p> Setiap putaran dipecah menjadi kutu.  Kutu adalah satu gerakan, seperti dalam catur.  Satu-satunya perbedaan adalah bahwa kedua pemain pergi pada saat yang sama.  Ada kompetisi di mana setiap orang bergiliran, atau Anda dapat melakukan tindakan hanya sekali setiap beberapa gerakan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memilih unit sebagai bingkai</a> . <br>  Setiap tanda centang pada bot muncul keadaan damai dan diberi kesempatan untuk melakukan 3 tindakan: <code></code> , <code></code> , <code></code> .  Tindakan ini membuat mobil masuk ke salah satu arah, dan jika pada saat yang sama tidak menyentuh roda bumi, maka mereka memberikan sedikit putaran ke seluruh tubuh (sedikit fisika arcade).  Setelah kedua lawan memilih tindakan, simulasi dunia permainan dimulai, negara baru dipertimbangkan dan dikirim ke para pemain.  Jika seseorang mengklik tombol, maka putaran berakhir dan yang berikutnya dimulai.  Semuanya sederhana, tetapi ada nuansa. </p><br><p>  Aturan yang lebih lengkap dapat ditemukan di <a href="">sini</a> .  Dan lihat pertandingan final di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h1 id="obschee-opisanie-resheniya">  Deskripsi Solusi Umum </h1><br><p>  Kebanyakan kompetisi penulisan bot sangat mirip: ada jumlah kutu yang terbatas (ada sekitar 1.500 maksimum untuk satu putaran), ada sejumlah tindakan yang mungkin terbatas, Anda perlu memilih urutan tindakan yang lebih baik daripada lawan Anda.  Beberapa saat kemudian kita akan kembali ke apa artinya menjadi lebih baik, tetapi untuk sekarang kita akan mencari tahu bagaimana menangani masalah utama - sejumlah besar opsi: pada awalnya kita memiliki satu keadaan awal, maka setiap mesin dapat bergerak dalam tiga cara yang berbeda, yang memberi kita 9 kombinasi yang berbeda untuk dua mobil, pada langkah 1500 itu akan menjadi 9 ^ 1500 kombinasi yang berbeda ... Yang sedikit lebih daripada yang kita inginkan jika kita berencana untuk mengaturnya selama keberadaan Semesta. </p><br><p>  Di sini kita sampai pada apa itu <strong>simulasi</strong> .  Ini bukan semacam algoritma, tetapi hanya rekreasi dari aturan permainan dengan akurasi yang cukup atau lengkap sehingga dimungkinkan untuk memilah-milah solusi.  Tentu saja, kita tidak akan melalui semua solusi, tetapi hanya sebagian saja.  Algoritme pencarian akan digunakan untuk ini - di pohon status permainan kami sedang mencari yang terbaik untuk kami.  Ada banyak algoritma (dari minimax ke MCTS), masing-masing memiliki nuansa tersendiri.  Yang terbaik adalah membiasakan diri dengan keputusan yang ditulis peserta dalam kompetisi AI sebelumnya.  Ini akan memberikan pemahaman dasar dalam kondisi apa algoritma bekerja, dan di mana tidak demikian.  Ada banyak tautan untuk ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori khusus</a> . </p><br><p>  Saat memilih suatu algoritma, Anda harus mempertimbangkan: </p><br><ul><li>  batas waktu untuk 1 tick (di sini saya salah hitung banyak tahun ini, tetapi bisa tetap di posisi ke-3); </li><li>  jumlah pemain.  Misalnya, jika ada tiga pemain, akan sulit untuk menggunakan minimax; </li><li>  akurasi simulasi, seperti  ini memungkinkan penggunaan kembali perhitungan lama; </li><li>  "Percabangan" dari pohon negara (apakah mungkin untuk menghitung semua negara yang mungkin setidaknya 10 langkah di depan); </li><li>  akal sehat - jangan mulai menulis MCTS jika kompetisi berlangsung 4 jam. </li></ul><br><p>  Dalam kompetisi ini, 1 tick memberi sekitar 10-13ms (2 menit untuk seluruh pertandingan).  Selama waktu ini, bot harus membaca data, membuat keputusan dan mengirim perintah untuk pindah.  Ini cukup untuk merangsang sekitar 500-1000 gerakan.  Iterasi semua negara bagian.  Algoritma pencarian paling sederhana mungkin terlihat seperti perbandingan dari tiga pilihan gerakan: "50 ticks go left", "50 ticks go right", "50 ticks click stop".  Dan betapapun sederhananya kedengarannya, tidak jauh dari keputusan pemenang. </p><br><p>  Karena  kita hanya menghitung 50 langkah ke depan, yang dalam kebanyakan kasus tidak dihitung sampai akhir permainan, maka kita membutuhkan <strong>fungsi evaluasi</strong> yang akan mengatakan seberapa baik dan buruk keadaan dunia bagi kita.  Paling sering, itu dibangun di atas heuristik dan memahami apa yang penting untuk kemenangan.  Misalnya, dalam kompetisi Piala Rusia Rusia 2014 ada balapan, tetapi Anda bisa menang jika Anda datang terakhir, jika Anda mendapatkan lebih banyak poin bonus.  Oleh karena itu, fungsi peringkat harus merangsang pengumpulan poin pada saat yang sama dengan pergerakan cepat di sepanjang jalan raya.  Skor hanya dapat dihitung untuk keadaan terakhir dari simulasi (setelah 50 ticks) atau sebagai jumlah dari perkiraan keadaan perantara.  Seringkali, perkiraan "memudar" pada waktunya sehingga keadaan yang terjadi lebih awal lebih dipengaruhi.  Karena  kita tidak dapat secara pasti memprediksi musuh, maka opsi di masa depan kemungkinan kecil akan terjadi, kita tidak akan terlalu bergantung pada mereka.  Juga, teknik ini membuat bot lebih cepat untuk menyelesaikan tugasnya, dan tidak menunda semuanya untuk nanti.  Tetapi perlu dicatat bahwa bot akan mengambil risiko lebih sedikit demi manfaat selanjutnya. </p><br><p>  Karena kita akan memprediksi keadaan dunia sebagai respons atas tindakan kita, kita perlu memodelkan perilaku musuh.  Tidak ada yang rumit dan ada beberapa opsi umum: </p><br><ul><li>  <strong>Rintisan atau heuristik</strong> <br>  Logika perilaku sederhana ditulis di mana musuh tidak melakukan apa-apa, atau memilih tindakan berdasarkan heuristik sederhana (misalnya, Anda dapat menggunakan versi strategi Anda yang pertama atau cukup mengulangi langkah lawan sebelumnya). </li><li>  <strong>Gunakan algoritma yang sama seperti untuk Anda sendiri</strong> <br>  Pertama kita mencoba untuk menemukan tindakan terbaik untuk musuh (terhadap set tindakan terbaik kita dari langkah terakhir, atau terhadap rintisan), dan kemudian kita mencari tindakan terbaik untuk diri kita sendiri, menggunakan perilaku yang ditemukan musuh.  Di sini bot akan mencoba untuk melawan musuh yang licik.  Logika ini tidak berfungsi dengan baik pada awal kompetisi, karena  banyak bot masih sangat lemah, dan keputusan Anda akan terlalu berhati-hati dengan mereka. </li><li>  <strong>Lainnya</strong> <br>  Minimax yang sama mengulangi semua gerakan pemain pada saat yang sama, dan dia tidak akan membutuhkan heuristik. </li></ul><br><p>  Jika Anda menerapkan semua langkah di atas, maka kemungkinan besar Anda akan mendapatkan bot yang sangat bagus, terutama jika Anda dapat mengambil fungsi peringkat yang baik.  Tetapi, melihat melalui perkelahiannya, Anda dapat melihat bahwa dalam situasi tertentu ia berperilaku aneh.  Memperbaiki fungsi evaluasi untuk situasi ini bisa sulit, atau ada risiko besar melanggar logika lain.  Di sini kruk dan seandainya datang untuk menyelamatkan.  Ya, hari-hari terakhir kompetisi sering berakhir dengan menulis kruk dan seandainya untuk memperbaiki kekurangan dalam kondisi spesifik apa pun.  Secara pribadi, saya benar-benar tidak suka bagian ini, tetapi saya telah memperhatikan lebih dari sekali bahwa itu adalah kruk di final yang dapat mempengaruhi pengaturan tempat di sepuluh besar, yang berarti bahwa jika tidak tertulis dapat dikenakan biaya hadiah (hati saya sakit ketika saya menulis kata-kata ini, saya Saya juga suka algoritma dan solusi yang indah). </p><br><p>  <strong>T: Apakah mungkin dilakukan tanpa simulasi sama sekali?</strong> <br>  <em>A: Ya, Anda dapat menggunakan solusi heuristik (pohon keputusan, sekelompok ifs, dll.).</em>  <em>Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus dengan arsitektur AI tentang heuristik.</em> </p><br><p>  <strong>T: Seberapa jauh lebih baik penggunaan simulasi daripada pendekatan heuristik?</strong> <br>  <em>A: Itu semua tergantung pada tugas.</em>  <em>Sebagai contoh, di sini beberapa kombinasi kartu dan mobil dapat dikodekan dengan seandainya dan selalu menang (atau seri).</em>  <em>Namun, seringkali simulasi menemukan solusi yang sulit dipikirkan sendiri, atau sulit diterapkan heuristik.</em>  <em>Dalam kontes ini, ketika Anda membalikkan mobil lain, solusi pada simulasi menempatkan roda mereka di atas roda musuh, yang mematikan bendera "di udara", yang berarti bahwa musuh tidak dapat menerapkan rotasi tubuh dan memutar kembali pada roda.</em>  <em>Tetapi keputusan itu tidak memikirkan arti dari ini, hanya menemukan opsi di mana musuh akan jatuh lebih cepat di atap dan menekan tombolnya.</em> </p><br><p><img src="https://habrastorage.org/webt/in/i4/wk/ini4wk8qqxl7dfzdzlcegwpmyyq.gif"></p><br><p>  <strong>T: Jaringan saraf dan RL?</strong> <br>  <em>A: Tidak peduli seberapa populer ini, dalam kompetisi bot solusi seperti itu jarang berkinerja baik.</em>  <em>Meskipun jaringan saraf tidak perlu simulasi, karena</em>  <em>mereka cukup mengeluarkan tindakan berdasarkan parameter input dari keadaan saat ini, mereka masih perlu mempelajari sesuatu, dan untuk ini mereka sering harus menulis simulator untuk menggerakkan ribuan game secara lokal.</em>  <em>Secara pribadi, saya yakin mereka punya potensi.</em>  <em>Mungkin mereka dapat menyelesaikan sebagian dari masalah, atau menggunakannya dalam kondisi waktu respons yang sangat terbatas.</em> </p><br><p>  <strong>Catatan</strong> <br>  <em>Mengenai jumlah tindakan yang mungkin terbatas, perlu diperjelas bahwa kadang-kadang diizinkan untuk "dengan lancar" menyesuaikan beberapa parameter.</em>  <em>Misalnya, tidak hanya memajukan, tetapi dengan persentase daya.</em>  <em>Dalam hal ini, "keterbatasan" jumlah kesimpulan dapat dengan mudah dicapai hanya dengan menggunakan beberapa nilai, misalnya, 0%, 25%, 50%, 75% dan 100%.</em>  <em>Paling sering, hanya dua yang cukup: "sepenuhnya aktif" dan "benar-benar mati".</em> </p><br><h1 id="simulyaciya">  Simulasi </h1><br><p>  Dalam kompetisi ini, kami menggunakan mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fisika tupai</a> siap pakai.  Harapan penyelenggara adalah bahwa ia sudah tua, sudah teruji waktu dan memiliki banyak pembungkus sehingga semua orang dapat memasukkannya dalam keputusan mereka ... </p><br><p>  Pada kenyataannya, mesin menghasilkan nilai yang berbeda setiap kali, yang membuatnya sulit untuk menyalakannya kembali untuk menghitung opsi untuk bergerak.  Masalahnya diselesaikan "langsung" - pengalokasi memori ditulis dalam C dan sepotong memori dengan keadaan dunia sepenuhnya disalin.  Pengalokasi seperti itu mengakhiri kemampuan untuk menulis solusi dalam bahasa selain C ++ (pada kenyataannya, itu mungkin, tetapi sangat padat karya dan pengalokasi masih harus ditulis dalam C).  Selain itu, keakuratan prediksi dipengaruhi oleh urutan penambahan elemen ke dunia game, yang membutuhkan salinan kode yang sangat akurat yang digunakan panitia untuk menghitung game.  Tapi dia sudah menggunakan Python.  Sorotan terakhir dalam peti mati bahasa pemrograman lain adalah bahwa mesinnya sudah tua dan berisi banyak optimisasi yang tidak dapat dibuat ulang secara akurat selama kompetisi untuk mendapatkan versi simulasi fisika Anda sendiri. </p><br><p>  Akibatnya, mesin, yang seharusnya memberi semua peserta kondisi yang sama untuk mensimulasikan gerakan, menjadi kendala paling sulit untuk ini.  Lebih dari 10 orang dapat mengatasinya. 7 tempat pertama di papan peringkat diambil secara eksklusif oleh orang-orang yang membuat simulasi yang akurat, yang dapat berfungsi sebagai beberapa bukti pentingnya dalam kompetisi tersebut. </p><br><p>  Dengan pengecualian beberapa peserta yang dapat masuk ke dalam chipmunk dan mengoptimalkan menyalin keadaannya, sisanya memiliki simulasi kinerja yang kira-kira sama (yang membuat kompetisi sedikit lebih menarik, karena Anda tahu bahwa perjuangannya adalah untuk algoritma keputusan, bukan "yang menghitung gerakan lebih banyak"). </p><br><h1 id="algoritm-poiska-i-predskazanie-protivnika">  Algoritma untuk mencari dan memprediksi musuh </h1><br><p>  Dari titik ini, deskripsi terpisah dari solusi dimulai.  Algoritma akan dijelaskan atas nama pengarangnya. </p><br><h3 id="vladimir-kiselev-valdemar-4-mesto">  Vladimir Kiselev (Valdemar) tempat ke-4 </h3><br><p>  Pencarian acak (Monte Carlo) digunakan untuk mencari ruang solusi.  Algoritma adalah sebagai berikut: </p><br><ol><li>  Kami menginisialisasi genom - urutan tindakan (kiri, kanan, berhenti) untuk 60 ticks - data acak. </li><li>  Ambil genom terbaik yang ditemukan </li><li>  Ubah salah satu tindakan secara acak </li><li>  Dengan menggunakan fungsi evaluasi kita mendapatkan angka - indikator seberapa bagus genom baru </li><li>  Jika Anda mendapatkan solusi yang lebih baik, maka perbarui solusi terbaik. </li><li>  Ulangi lagi dari langkah 2 </li></ol><br><p>  Simulator saya menghasilkan ~ simulasi 100k dunia dalam 1 detik, mengingat ada rata-rata ~ 12 ms per tick, kami mendapatkan 1200 aksi per tick.  Artinya, dalam 1 tick kita berhasil melewati siklus penuh sekitar 20 kali. </p><br><p>  Untuk menemukan solusi optimal, jumlah iterasi ini jelas tidak cukup.  Oleh karena itu, gagasan dengan tindakan "peregangan" diterapkan: alih-alih genom 60 gerakan, kami akan beroperasi dengan rantai 12 gerakan "peregangan" - kami percaya bahwa setiap tindakan berlangsung 5 kutu berturut-turut. <br>  Plus: Meningkatkan kualitas mutasi dengan mengurangi panjang genom, simulasi juga dapat dijalankan setiap 5 kutu dan memeriksa 100 genom bukannya 20 (untuk menghindari jatuh dalam batas waktu, saya akhirnya berhenti di 70). <br>  Lebih sedikit: aksi peregangan dapat menyebabkan solusi yang tidak optimal (misalnya, berayun pada bumper, bukannya rak yang stabil) </p><br><p>  Perlu dicatat teknik yang telah secara signifikan meningkatkan kualitas algoritma: </p><br><ul><li>  Kami melakukan inisialisasi acak hanya pada kutu pertama, sisa waktu kami menggunakan kembali solusi terbaik yang ditemukan dengan pergeseran 1 langkah (tindakan pada kutu 2 digeser ke 1, dll, tindakan acak ditambahkan ke akhir).  Ini sangat meningkatkan kualitas pencarian, karena jika tidak, algoritma "lupa" apa yang akan dilakukan pada centang terakhir dan membuat tersentak tidak masuk akal di arah yang berbeda. </li><li>  Pada awal kursus, kami melakukan perubahan yang lebih intensif (kami mengubah genom 2 atau 3 kali alih-alih satu) dengan harapan dapat memecahkan maksimum lokal (kesamaan suhu dalam metode simulasi annealing). <br>  Intensitas dipilih secara manual: 30 iterasi pertama membuat 3 mutasi, 10 berikutnya 2, kemudian oleh 1. </li><li>  Yang sangat penting adalah prediksi aksi musuh.  Untuk merugikan waktu untuk mencari solusi kami sendiri, kami meluncurkan pencarian acak dari sisi lawan, pada 20 iterasi, lalu 50 untuk diri kita sendiri, menggunakan informasi tentang gerakan optimal lawan. <br>  Keputusan terbaik lawan juga digunakan kembali pada langkah selanjutnya dengan offset.  Pada saat yang sama, ketika mencari solusi untuk musuh, genom dari langkah terakhir digunakan sebagai tindakan yang saya maksudkan. </li></ul><br><p>  Selama kompetisi, ia secara aktif menggunakan alat untuk pengembangan lokal, yang memungkinkan untuk dengan cepat menemukan bug dan fokus pada titik lemah dari strategi: </p><br><ul><li>  arena lokal - meluncurkan banyak pertandingan melawan versi sebelumnya; </li><li>  visualizer untuk perilaku debug; </li><li>  skrip untuk mengumpulkan statistik pada pertandingan dari situs - memungkinkan Anda untuk memahami di peta dan mesin mana kekalahan paling sering terjadi. </li></ul><br><blockquote>  <strong>mortido:</strong> <br>  Menghitung setiap 5 tick terlihat berisiko, terutama jika musuh bergerak menjauh dari opsi yang Anda prediksi.  Di sisi lain, di dunia game ini selama 5 kutu, tidak banyak yang terjadi. <br>  Selain itu, dalam keputusan saya, saya menambahkan kombinasi acak setiap centang, tetapi saya pasti tidak akan mengatakan bagaimana ini mempengaruhi keputusan. <br><br>  <strong>Commandos:</strong> <br>  Mengubah beberapa tindakan dengan sejumlah simulasi tidak terlihat sangat berarti, karena sangat sedikit perubahan terjadi dalam satu tindakan.  Tetapi ketika Anda merentangkan satu tindakan ke 5 kutu makna, tampaknya menjadi lebih. <br>  Saya juga tidak menyukai ide itu sendiri - kami mengambil set terbaik dan mencoba mengeditnya di suatu tempat di awal.  Tampaknya tidak masuk akal bahwa mengubah kutu pertama akan meninggalkan kutu berikutnya setidaknya cukup memadai. </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto">  Alexander Kiselev (mortido) tempat ke-3 </h3><br><p>  Berbekal artikel oleh pemenang kompetisi lain, saya memutuskan untuk menggunakan algoritma genetika.  Ternyata, sesuatu yang mirip dengan pencarian acak atau bahkan tiruan dari anil, tetapi lebih pada nanti. </p><br><p>  Kami menyandikan solusi dengan array 40 angka, di mana -1, 0, dan 1 berhubungan dengan gerakan <code></code> , <code></code> dan <code></code> . </p><br><p>  Pada awal setiap putaran, saya menghitung berapa banyak waktu yang telah saya habiskan untuk seluruh permainan, menghitung batas waktu baru berdasarkan berapa banyak putaran lagi, dan setiap putaran saya anggap 1.200 kutu.  T.O.  Awalnya, saya mencoba menghabiskan tidak lebih dari 11 ms per putaran, tetapi saya bisa "berjalan" sedikit di akhir jika putaran sebelumnya lebih cepat dari 1.200 kutu. </p><br><blockquote>  <strong>Valdemar:</strong> <br>  Menariknya, chip ini memperburuk permainan bagi saya.  Ternyata selalu lebih baik untuk menghabiskan 20-30ms dari 11 pertama, dan 60 di akhir </blockquote><p>  Sepertiga dari waktu ini saya sedang mencari langkah terbaik musuh, sisanya pergi untuk menghitung keputusan saya sendiri.  Saat mencari langkah untuk musuh, perilaku saya dimodelkan sebagai yang terbaik dari langkah terakhir, digeser 1 tick.  Yaitu  seolah-olah aku terus bertindak sesuai dengan rencana yang dibuat dalam tanda centang terakhir, dan dia berusaha melawanku. </p><br><p>  Pencarian solusi itu sendiri sama untuk lawan dan lawannya: </p><br><ol><li>  Kami mengambil keputusan dari langkah terakhir dan menggesernya dengan 1 langkah (yang telah kami lakukan) </li><li>  Kami membuktikan pada populasi solusi acak sampai kami mengisi semuanya </li><li>  Kami mensimulasikan semua keputusan dan menetapkan kebugaran menggunakan fungsi evaluasi.  Kami ingat yang terbaik. </li><li>  Sementara ada waktu untuk perhitungan <br><ol><li>  Petunjuk, selalu tambahkan 1 mutasi dari solusi terbaik saat ini untuk populasi, ingatlah jika itu lebih baik </li><li>  Selama ada tempat di populasi baru dan waktu untuk perhitungan belum terlampaui (Anda bisa pergi ke lantai populasi yang dihuni) <br><ol><li>  Kami mengambil dua individu yang berbeda dan pergi dengan kebugaran terbaik - ibu </li><li>  Kami mengambil dua individu yang berbeda dan pergi dengan kebugaran terbaik - ayah (tidak harus bertepatan dengan ibu) </li><li>  Lintasi mereka </li><li>  Bermutasi jika <code>RND &lt;  </code> </li><li>  Kami mensimulasikan solusi dan mengingatnya, jika itu yang terbaik </li></ol></li></ol></li></ol><br><p>  Akibatnya, kami akan mengembalikan urutan tindakan yang dianggap optimal.  Langkah pertama di dalamnya dikirim sebagai tindakan bot.  Sayangnya, ada kekurangan serius dalam rencana saya, seperti  jumlah simulasi yang dapat dilakukan dalam tick sangat kecil (termasuk karena fungsi evaluasi yang panjang), maka pada server kompetisi 4 poin dilakukan hanya 1 kali, dan untuk musuh itu tidak dilakukan sama sekali.  Ini membuat algoritme lebih seperti pencarian acak atau simulasi anil (karena kami berhasil memutasikan solusi 1 kali dari langkah terakhir).  Sudah terlambat untuk mengubah sesuatu, dan kami berhasil mempertahankan posisi ke-3. </p><br><p>  Karena itu penting untuk menerapkan algoritma untuk menyeberang, bermutasi, dan menghasilkan solusi acak awal  itu tergantung pada keputusan apa yang akan diuji, dan keputusan acak yang lengkap tidak sebaik kelihatannya pada pandangan pertama (itu akan berhasil, tetapi lebih banyak pilihan akan dibutuhkan). </p><br><p>  Dalam versi final, keputusan acak dihasilkan dalam segmen, yang mengecualikan solusi "menyentak" di satu tempat: </p><br><ol><li>  Tim acak dipilih </li><li>  Untuk seluruh panjang solusi (40 gerakan) <br><ol><li>  Kami menulis perintah saat ini di sel </li><li>  Dengan probabilitas 10%, kami mengubah tim saat ini menjadi acak </li></ol></li></ol><br><p>  Menurut teknologi yang sama, mutasi juga terjadi - segmen acak dari solusi diganti dengan perintah acak.  Crossing terjadi dengan memilih titik pengambilan keputusan dari 1 orang tua, dan setelah dari 2. </p><br><p>  Saya suka bahwa kami menggunakan semua waktu yang tersedia untuk menemukan solusi terbaik.  Ini bukan masalah besar jika solusinya bukan yang terbaik - kami dapat memperbaikinya pada centang berikutnya, karena  optimasi ternyata "kabur" pada waktunya.     ,        .  ,      -  ,    .           ,           </p><br><blockquote> <strong>Valdemar:</strong> <br>   1     , ,             . <br><br> <strong>Commandos:</strong> <br>    —   -        . <br>         —    ,     .         ,     …      ,        .    "    ”.         -. </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto">   (Commandos) 1  </h3><br><p>        (  ),   <strong>n</strong>  <strong>m</strong>  .    3^2=9 .       <strong>m</strong> + <strong>n</strong>      40 . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">|----------- n  -----------|---------- m  --------| |   ...   |   ...   |</code> </pre> <br><p>          :     ,  ,  .      (   ). </p><br><p>       <strong>n</strong>  <strong>m</strong> ,          .       ,     . </p><br><p>        : </p><br><ol><li>     ,       (       ,   ): <br><ul><li>   ,     ,   ,     . </li><li>       ,      ,   .           .                .            ,       ,      ,     . </li><li>         .   ;        (           ). </li></ul></li><li>       <strong>n</strong>  <strong>m</strong>  .      ,    .1,      ,          .     -  (    )  ,        —        ,      ; </li><li>             .   ,     —      .    ,       (       ). </li></ol><br><blockquote> <strong>Valdemar:</strong> <br> ,       2    .    .         ,    . <br><br> <strong>mortido:</strong> <br> !   ,       .    .  ,   2    ,   40-60       .  ,        3   . <br> n + m == const ? </blockquote><p>   .  <code>n + m != const</code> ,              .      ,  .  -   . </p><br><h1 id="funkciya-ocenki">   </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-1">   (Valdemar) 4  </h3><br><p>   ,       . ,    (  , ,   ..)    [0..1]. <br>           .     :   ,        . <br>            ,    ,      :      ,          . </p><br><p> ,   : </p><br><ul><li>    —    70  180  (  :         ). <br>       ,       . </li><li>       0..500 </li><li>   —  [2pi, pi/4]   [0, 1] </li><li>    —    ,       (    ),   (  ,      ,        ) </li><li>   — ,      ,     ,           . <br>      ,  ,       . </li><li>  —     .          . </li><li>     Y   —    . </li><li>           </li></ul><br><p>  ,       2           , . </p><br><p>           . </p><br><p>         : </p><br><ul><li>  “”      ,       </li><li>  “  ”        ,   ,        . </li></ul><br><blockquote> <strong>mortido:</strong> <br>    , ..      ,     . <br><br> <strong>Commandos:</strong> <br>      ,      .    -  </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-1">   (mortido) 3  </h3><br><p>        ,      chipmunk.              .     ,      ,     ,   ,   .        . </p><br><p>                    3   <del>  </del>   . </p><br><p>   ,        ( ,     ,   ): </p><br><ul><li>   .          ,  ,        (       ,     ); </li><li>    ,    —       ,     ;      ,     1  ; </li><li>   ; </li><li>      (    ,  ); </li><li>       (   “+”,    “-”); <br> -     (   “+”,    “-”);   ,     ,      ,          ; <br>   30    ,       ,      (   ); </li><li>  ,         . </li></ul><br><p>  ,        ,         (,            ,     ) </p><br><blockquote> <strong>Valdemar:</strong> <br>         .    ,     “  ,     ,    ”     ,      (     ..)     . </blockquote><p>  ,    ,        .    . </p><br><blockquote> <strong>Commandos:</strong> <br>   ,   ,   “”…      ?              ,   “” . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-1">   (Commandos) 1  </h3><br><p>      <code>SquaredWheelsBuggy</code> ,      ..  ,       .     Buggy   ,          ,          (         /). <br> : </p><br><ol><li>   ; </li><li>     ;         — ,     ,   1  0; ..        ; </li><li>     .        ;          10      (            ); </li><li>             (       ,    ); </li><li>     (,          ); </li><li>       — -    ,   ; </li><li> /     ;       ,       —   ;             . </li></ol><br><p>  1-5      ,   .   2     “  ”. </p><br><blockquote> <strong>Valdemar:</strong> <br>     ,        .       ,      . <br><br> <strong>mortido:</strong> <br>      ,     10 . </blockquote><br><h1 id="kostyli-i-ify">   IF' </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-2">   (Valdemar) 4  </h3><br><p>      ,            if'.         3    ,         ,           . ,        ,         -. <br>  :      ,    “”   —      ,   - ,           (  ,   ) —   . </p><br><p>     : </p><br><ul><li>     .      ,        . </li><li>      —     ,                  . </li><li>   .      “  ”      . <br>      ,        ,         . <br>                ,      ,      . </li></ul><br><p>        ,    :     .   ,       ,   if'     . </p><br><blockquote> <strong>mortido:</strong> <br>     ,       .            . <br><br> <strong>Commandos:</strong> <br>   if'.   ,    ,    …          ,     ,     . </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-2">   (mortido) 3  </h3><br><p>              - . </p><br><p>     3  .    .         .  “”,                  .        ,      ,    . </p><br><p>          ,     “”   .       .     ,        , ,      -  .        .     ,       , ..    . </p><br><p>    ,      ,  ,     ,           ,       .     …         .    -       —  ,     (      ,     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>    ,     .          .        “” ,       if'.  ,           —             . </blockquote><p>          ,       +      . ,       . </p><br><blockquote> <strong>Commandos:</strong> <br>   …  ,  -   —   ,      ,   .        ,     ,                . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-2">   (Commandos) 1  </h3><br><p>         .      (,     ,    ).         (  )   /. </p><br><p>    pill carcass map        ,       ,             (         ).      island map,      ,     . </p><br><p>             island hole  buggy.    /      ,     ,      (  ).       —    .  ,          ,    .   SquaredWheelBuggy           .    ,      ,      ,    .  ,   …    ,      ,     . </p><br><p>    (Pill map, Bus)                 ,        (     /  100% ). </p><br><p>         pill hubble map.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> (    ),     .       . </p><br><p>               —         ,   ... </p><br><p>       ,     .                ,    .          (     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>   ,          —        .   ,     . <br><br> <strong>mortido:</strong> <br>     ,     “”  . </blockquote><br><h1 id="emocii">  </h1><br><blockquote> <strong>Valdemar:</strong> <br>     .           ,      .    (   )      . <br>                  .  “”,      ,          , ,  :) <br>  ,  mailru  ,     . <br><br> <strong>mortido:</strong> <br>        :               ,          …   ,      ,       (      ).     ,     3   ,    ,   …      . <br><br> <strong>Commandos:</strong> <br> -     ,     . , ,   ,  .    …       .         —     ,      . <br>     —       ++.       .       ,       .     1  <del>       </del>     -. </blockquote><br><h1 id="itak">  </h1><br><p> ,           .    ,              .      ,      ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  Mail.Ru Group   . </p><br><h1 id="bonus">  </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Valdemar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mortido</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/bz/b8/cd/bzb8cdwabur3c-7qbcwzmjokx0o.gif"></p><br><p><img src="https://habrastorage.org/webt/tw/nw/cw/twnwcwndcdjglzq2hhuh0ulxohc.gif"></p><br><p><img src="https://habrastorage.org/webt/ib/jh/vq/ibjhvquma8mwq6meckt2qzteicy.gif"></p><br><p><img src="https://habrastorage.org/webt/4e/eg/c9/4eegc9jvtcg-0namubh_9cqx2ok.gif"></p><br><p><img src="https://habrastorage.org/webt/4f/uw/w8/4fuww8dcs4-fx4nuar8bcur0lpm.gif"></p><br><p><img src="https://habrastorage.org/webt/fz/q3/6u/fzq36ufo15jgjwbd9ev_cnc6mso.gif"></p><br><p><img src="https://habrastorage.org/webt/og/55/dt/og55dtgv4ohguhiucwhn0qwqiak.gif"></p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430466/">https://habr.com/ru/post/id430466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430454/index.html">Saya dikelilingi oleh orang-orang idiot atau bagaimana cara bekerja dalam tim</a></li>
<li><a href="../id430456/index.html">Buku Manajemen Proyek Legal oleh PMI</a></li>
<li><a href="../id430458/index.html">Multilayer Graphene Superconductor: Investigasi Zona Datar</a></li>
<li><a href="../id430460/index.html">Trojan Penguin: Membuat virus untuk Linux</a></li>
<li><a href="../id430462/index.html">Di Rusia, sebuah RUU telah muncul tentang penyediaan data dari pengguna jejaring sosial ke lingkaran orang yang tidak terbatas. Jejaring sosial menentang</a></li>
<li><a href="../id430468/index.html">Meningkatkan kesadaran warga</a></li>
<li><a href="../id430470/index.html">Mengapa mempertahankan konteks pada akun klien - jujur ​​dan menguntungkan</a></li>
<li><a href="../id430472/index.html">Jaringan DECT DIY mulus</a></li>
<li><a href="../id430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../id430476/index.html">NCBI Genome Workbench: Endangered Research</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>