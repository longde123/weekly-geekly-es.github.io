<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Resolviendo el problema de mosaico usando el solucionador SAT usando el ejemplo de pentamino   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez que encontr茅 un juego de pentomino donde era necesario poner 13 figuras en un cuadrado de 8 por 8. Despu茅s de un cierto per铆odo de tiempo dura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolviendo el problema de mosaico usando el solucionador SAT usando el ejemplo de pentamino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408299/"> Una vez que encontr茅 un juego de pentomino donde era necesario poner 13 figuras en un cuadrado de 8 por 8. Despu茅s de un cierto per铆odo de tiempo durante el cual intent茅 resolver este problema sin 茅xito, decid铆 que era necesario escribir un programa que hiciera esto por m铆.  Para hacer esto, fue necesario elegir un algoritmo de soluci贸n.  Lo primero que viene a la mente es el algoritmo habitual de ramas y bordes, cuando las figuras se apilan una tras otra adyacentes entre s铆 (el algoritmo con enlaces de baile no es adecuado aqu铆, ya que las figuras son diferentes).  Por lo general, se utilizan diversas heur铆sticas para acelerar este algoritmo, por ejemplo, se prefiere la ramificaci贸n con el menor n煤mero de opciones.  Puede crear e implementar otras heur铆sticas en este algoritmo, pero aqu铆 pens茅 que muchos trucos diferentes para acelerar la soluci贸n de tales problemas ya se han implementado en solucionadores SAT.  Por lo tanto, es necesario traducir la tarea al lenguaje matem谩tico apropiado y utilizar alg煤n tipo de solucionador SAT.  Acerca de c贸mo se implement贸 esto y qu茅 resultados pueden leerse debajo del corte. <br><a name="habracut"></a><br>  Al principio quiero recordarte qu茅 es el juego pentamino.  Este es un campo cuadrado de 8x8, que debe estar en mosaico con 13 figuras - 12 garabatos, que consisten en 5 cuadrados y una figura de 2x2: <br><br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/59907/59907_900.jp" alt="imagen"><br><br>  Aqu铆 vale la pena decir cu谩l es el problema de satisfacci贸n booleana o el problema SAT.  En t茅rminos generales, puede formularse como el hallazgo de tales valores de variables booleanas en las que la expresi贸n dada se vuelve verdadera.  En t茅rminos generales, esta es una tarea completa de NP, sin embargo, hay muchos trucos que ayudan a resolverlo de manera efectiva.  Para hacer esto, se han desarrollado muchas aplicaciones especiales llamadas solucionadores SAT.  Usar茅 un solucionador SAT llamado minisat.  Para resolver este problema, es necesario reescribir la expresi贸n de entrada en forma conjuntiva normal, es decir, en forma de un producto de sumas l贸gicas de variables.  Cada par茅ntesis en forma normal conjuntiva aqu铆 se llama una cl谩usula, que es el "o" l贸gico de algunos literales, es decir, variables booleanas o sus negaciones.  Por ejemplo: <br><br>  (x1 V no x3) (x2 V x4) (x2 V x3 V no X4) <br><br>  Necesitaba traducir la tarea de mosaico en la tarea SAT.  Tome una figura de pentamino y p贸ngala en el campo de juego de todas las formas posibles, incluidos los cambios, giros y reflexiones.  Para cada posici贸n de la figura, asociamos una variable booleana y asumiremos que si en nuestra soluci贸n final esta figura est谩 presente en esta posici贸n en particular, entonces la variable ser谩 verdadera y, si no, falsa.  Hacemos esto para todas las figuras. <br><br>  Ahora elaboremos una f贸rmula que describa nuestro problema, es decir, en realidad impondremos restricciones a nuestras variables.  Lo primero que debe hacer es asegurarse de que todas las celdas de nuestro campo de juego estar谩n cubiertas con al menos una figura.  Para hacer esto, para cada celda de 64, encontramos todas las figuras y posiciones de estas figuras que cubren esta celda y componimos una cl谩usula a partir de las variables que se asignan a estas posiciones de las figuras.  Lo segundo que debe hacer es eliminar la intersecci贸n de las formas.  Esto se puede hacer en un ciclo doble, simplemente clasificando todas las posiciones posibles de todas las figuras y determinando si el par tiene celdas comunes.  Si lo hay, entonces se cruzan y necesita agregar una cl谩usula de la forma (no x_i V no x_j), donde x_i es la variable asignada a la primera posici贸n, y x_j es la segunda posici贸n.  Esta cl谩usula es verdadera cuando x_i y x_j no son iguales a uno al mismo tiempo, es decir, excluye intersecciones.  Y finalmente, la tercera cosa a considerar es que cada figura puede estar presente en el campo de juego solo una vez.  Para hacer esto, tambi茅n revisamos todas las posiciones de cada figura en un ciclo doble y para cada par de posiciones de la misma figura hacemos una cl谩usula similar a la anterior y que consta de dos negativos.  Es decir, cuando aparecen dos figuras id茅nticas (pero en diferentes posiciones), una de estas cl谩usulas dar谩 falso y, en consecuencia, excluir谩 dicha soluci贸n. <br><br>  Todo era una teor铆a, y ahora pasemos a la pr谩ctica.  Cada figura tiene un n煤mero del 1 al d para distinguirla de otras e imprimir convenientemente.  Luego cree una matriz del campo de juego y codifique las celdas correspondientes del campo de juego como ocupadas / no ocupadas por la figura: <br><br> <code>. . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . 1 1 . . . . . <br> 1 1 . . . . . . <br> . 1 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 3 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 4 . . . . . . . <br> 4 . . . . . . . <br> 4 4 . . . . . . <br> . 4 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 5 5 . . . . . . <br> 5 5 . . . . . . <br> 5 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 6 6 6 . . . . . <br> . 6 . . . . . . <br> . 6 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 7 . 7 . . . . . <br> 7 7 7 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 8 . . . . . . . <br> 8 . . . . . . . <br> 8 8 8 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . 9 . . . . . <br> . 9 9 . . . . . <br> 9 9 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . a . . . . . . <br> aaa . . . . . <br> . a . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> b . . . . . . . <br> bb . . . . . . <br> b . . . . . . . <br> b . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . cc . . . . . <br> . c . . . . . . <br> cc . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> dd . . . . . . <br> dd . . . . . . <br></code> <br>  Ahora, para cada pieza, es necesario encontrar todas las posiciones posibles en el campo de juego mediante turnos, giros y reflexiones.  Comencemos con giros y reflexiones.  En total, hay 8 posibles transformaciones de giros y reflexiones, incluida una transformaci贸n trivial que deja la figura intacta.  Para estas transformaciones, creo 8 matrices correspondientes, como se muestra a continuaci贸n.  Despu茅s de la rotaci贸n o reflexi贸n, la figura puede ir m谩s all谩 del campo de juego, por lo que es necesario devolverla nuevamente al campo de juego.  Tambi茅n debe tenerse en cuenta que algunas figuras pueden transformarse en s铆 mismas despu茅s de la transformaci贸n, y tales casos deben excluirse.  Agrego opciones 煤nicas a la clase de Orientaci贸n.  El resultado es el siguiente c贸digo: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dimension_ = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_SIZE = dimension_ * dimension_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MATRIX_SIZE; i++ ) { matrix[ i ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dimension_; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix, matrix + MATRIX_SIZE, matrix1 ); matrix1[ i ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = dimension_; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !matrix1[ j - dimension_ ] ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix1, matrix1 + MATRIX_SIZE, matrix2 ); matrix2[ j ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; dimension_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; NUMBER; l++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix2, matrix2 + MATRIX_SIZE, matrix3 ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; l1 &lt; dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = dimension_; l1 &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } Orientation * orientation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Orientation( figure ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point *&gt;::const_iterator h = figure-&gt;points().begin(); h != figure-&gt;points().end(); ++h ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point * p = *h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { x = x + p-&gt;coord( i1 ) * matrix3[ i1 ]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { y = y + p-&gt;coord( i1 ) * matrix3[ dimension_ + i1 ]; } <span class="hljs-function"><span class="hljs-function">Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x, y )</span></span></span></span>; orientation-&gt;createPoint( p1.coord( <span class="hljs-number"><span class="hljs-number">0</span></span> ), p1.coord( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); } orientation-&gt;moveToOrigin(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isUnique( orientations, orientation ) ) { orientations.push_back( orientation ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix3; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix2; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix1; }</code> </pre><br>  Este c贸digo se aplica a cada una de las figuras, y luego, las orientaciones 煤nicas recibidas se desplazan a lo largo de los ejes xey creando todas las posiciones posibles de cada figura.  Como resultado, tenemos el siguiente n煤mero de posiciones diferentes para cada una de las figuras: <br><br> <code>---------- Figure 1 <br> Count = 288 <br> ---------- Figure 2 <br> Count = 64 <br> ---------- Figure 3 <br> Count = 280 <br> ---------- Figure 4 <br> Count = 280 <br> ---------- Figure 5 <br> Count = 336 <br> ---------- Figure 6 <br> Count = 144 <br> ---------- Figure 7 <br> Count = 168 <br> ---------- Figure 8 <br> Count = 144 <br> ---------- Figure 9 <br> Count = 144 <br> ---------- Figure a <br> Count = 36 <br> ---------- Figure b <br> Count = 280 <br> ---------- Figure c <br> Count = 144 <br> ---------- Figure d <br> Count = 49 <br></code> <br>  Luego asignamos una variable booleana a cada posici贸n posible y creamos una f贸rmula, como se describi贸 anteriormente.  Despu茅s de eso, llamamos a minisat directamente desde la aplicaci贸n, que devuelve una soluci贸n: un conjunto de nuestras variables con los valores asignados verdadero o falso.  Sabiendo a qu茅 posiciones se asignaron estas variables, imprimimos la soluci贸n: <br><br> <code>bbbb 3 3 3 3 <br> ddbc 8 8 8 3 <br> dd 1 ccc 8 2 <br> 5 5 1 1 1 c 8 2 <br> 5 5 5 1 4 4 4 2 <br> 7 7 a 4 4 9 6 2 <br> 7 aaa 9 9 6 2 <br> 7 7 a 9 9 6 6 6 <br></code> <br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/60414/60414_900.jpg" alt="imagen"><br><br><h2>  Que sigue </h2><br>  Naturalmente, detenerse en esto no ser铆a tan interesante.  Por lo tanto, la primera pregunta que surgi贸 para m铆 fue "驴cu谩ntas soluciones diferentes existen que no difieren en giros triviales y reflexiones del campo de juego?".  Para hacer esto, hay un modo en el solucionador SAT que le permite agregar cl谩usulas sin perder la informaci贸n existente, lo que acelera significativamente el proceso en comparaci贸n con como si la soluci贸n se buscara desde cero.  La siguiente soluci贸n se puede encontrar agregando una cl谩usula que contenga la negaci贸n de todas las variables presentes en la soluci贸n anterior.  Despu茅s de agregar este procedimiento y comparar la nueva soluci贸n con las anteriores, teniendo en cuenta los giros y las reflexiones del campo de juego, obtuve 1364 opciones diferentes. <br><br>  Otra extensi贸n interesante que implement茅 fue el estudio de varias otras formas del campo de juego y las figuras.  Y finalmente, el estudio de los campos de juego tridimensionales fue muy interesante.  Pero este es un tema para otro art铆culo. <br><br><h2>  Actualizaci贸n </h2><br><br>  Despu茅s de agregar una condici贸n adicional: para cada figura de una cl谩usula: debe haber al menos una posici贸n de esta figura en el campo de juego, el c谩lculo se ha vuelto mucho m谩s r谩pido.  Adem谩s, se ha solucionado un error, como resultado de lo cual el n煤mero de todas las opciones 煤nicas posibles es 16146. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es408299/">https://habr.com/ru/post/es408299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es408285/index.html">Encuesta de usuarios Geektimes</a></li>
<li><a href="../es408287/index.html">驴Qui茅n tiene la culpa de un accidente que involucra un autom贸vil aut贸nomo? 驴Cu谩ndo veremos KAMAZ aut贸nomo en las carreteras?</a></li>
<li><a href="../es408289/index.html">Interfaz de usuario futurista del nuevo Tesla Model 3</a></li>
<li><a href="../es408291/index.html">En el planeta enano Ceres, un oc茅ano podr铆a existir en el pasado</a></li>
<li><a href="../es408297/index.html">C贸mo funcionan los actores de doblaje: parte 2</a></li>
<li><a href="../es408301/index.html">DJI amenaza a la corte con un especialista en ciberseguridad que descubri贸 claves para acceder a las cuentas de la compa帽铆a en GitHub</a></li>
<li><a href="../es408303/index.html">Una breve historia del papel electr贸nico: evoluci贸n y perspectivas</a></li>
<li><a href="../es408305/index.html">La red neuronal de Stanford diagnostica la neumon铆a en rayos X mejor que los m茅dicos</a></li>
<li><a href="../es408307/index.html">Raise3D: la impresi贸n 3D reemplaza la fabricaci贸n tradicional de calzado</a></li>
<li><a href="../es408311/index.html">Protones y neutrones: amontonamiento dentro de la materia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>