<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ 🕠 🕸️ Layanan Mikro: cara mematuhi kontrak 🏅 ⛑️ 🐹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transisi ke arsitektur layanan mikro memerlukan revisi pendekatan untuk pengembangan, pengujian, pemeliharaan, desain - dengan kata lain, untuk semua ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan Mikro: cara mematuhi kontrak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/483380/">  Transisi ke arsitektur layanan mikro memerlukan revisi pendekatan untuk pengembangan, pengujian, pemeliharaan, desain - dengan kata lain, untuk semua aspek siklus hidup komponen perangkat lunak.  Dalam posting ini, kita akan berbicara tentang praktik yang dilakukan tim arsitek Acronis dalam bergerak menuju API komponen terbaik.  Kisah ini akan mencakup pernyataan masalah dan analisis solusinya.  Mungkin posting ini akan menjadi “kapten” bagi sebagian orang, tidak akan jelas bagi seseorang mengapa mereka melewatkan solusi-super X, tetapi kami berharap ini akan menarik dan bermanfaat bagi Anda.  Kami mengundang pembuat microservice untuk membaca dan meninggalkan komentar Anda di bawah cat. <br><br> <a href="https://habr.com/ru/company/acronis/blog/483380/"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/bbd/435/4a8bbd4357c0ea6080a856a129918ae9.png" alt="gambar"></a> <br><a name="habracut"></a><br>  Jika Anda berlangganan blog kami, Anda sudah membaca tentang kontrak layanan mikro.  Kami berbicara tentang mereka dalam posting tentang memilih <a href="https://habr.com/ru/company/acronis/blog/466691/">Swagger atau RAML</a> , serta <a href="https://habr.com/ru/company/acronis/blog/470910">pemeriksaan statis</a> yang dapat dilakukan berdasarkan anotasi yang dibuat sebelumnya.  Alasan posting hari ini adalah <a href="https://www.highload.ru/moscow/2019/abstracts/5234">laporan di konferensi HighLoad</a> .  Kami perlu secara umum berbicara tentang jalan yang kami tempuh untuk meresmikan hubungan antara layanan-layanan mikro.  Dan hari ini saya ingin membagikan kesimpulan kami dengan Habr, dan juga untuk memeriksa apakah arsitek lain setuju dengan kami. <br><br>  Layanan Microsoft adalah "batu bata" tempat pengembang membuat aplikasi modern.  Setiap layanan tersebut berinteraksi dengan dunia luar melalui API.  Biasanya, layanan mikro dikembangkan oleh tim terpisah, terkadang tersebar secara geografis, sehingga untuk pekerjaan yang efektif perlu menjaga konsistensi dan integritas antarmuka publik mereka.  Di perusahaan besar dengan ratusan layanan, perlu memiliki anotasi dari masing-masing komponen: memformalkan data input dan menjelaskan secara terperinci hasil pekerjaannya.  Jika Anda bekerja dengan HTTP REST, maka ada dua format anotasi umum untuk ini: RAML dan Spesifikasi Open API (alias Swagger).  Tetapi pertanyaan-pertanyaan yang kami fokuskan hari ini tidak terikat dengan protokol tertentu.  Oleh karena itu, yang berikut akan relevan bahkan untuk gRPC. <br><br><h3>  Latar belakang </h3><br>  Acronis telah ada selama lebih dari 15 tahun.  Selama ini, produk dan basis kode telah berevolusi secara signifikan.  Dari aplikasi desktop yang kompleks, kami sampai pada model perusahaan dengan konsol manajemen terpusat, pembatasan hak, dan log audit.  Langkah selanjutnya adalah transformasi aplikasi perusahaan menjadi platform terbuka, di mana akumulasi pengalaman digunakan untuk berintegrasi dengan layanan eksternal. <br><br>  Jika sebelum API penting, sekarang telah menjadi komponen penting dari produk.  Dan proses yang disediakan API ini telah matang. <br><br><h3>  Masalah besar </h3><br>  Masalah seputar bangunan API tampak familier bagi semua orang.  Kami akan menggambarkan mereka dalam bentuk hipertrofi: sebagai rasa sakit yang menyiksa programmer hipotetis Vasya dan manajernya yang tidak kurang hipotetis Kolya.  Semua nama adalah fiktif, dan setiap kecocokan tidak disengaja :) <br><br>  <b>1. Deskripsi sudah usang</b> <br><br>  Biarkan programmer Vasya mengembangkan komponen A, yang menggunakan API komponen B. Yang terakhir memiliki anotasi, tetapi tidak valid.  Vasya harus merangkak ke kode orang lain, mencari orang, bertanya.  Tenggat waktu sedang keluar, dan manajernya Kolya harus berurusan dengan transfer tenggat waktu. <br><br>  <b>2. API tidak konsisten</b> <br><br>  Programmer Vasya menyelesaikan tugas dan beralih ke yang berikutnya terkait dengan pengoperasian komponen B. Namun, baik pengembang B dan pengembang C memiliki perasaan keindahan yang berbeda, sehingga hal yang sama dilakukan secara berbeda dalam API.  Vasya kembali berurusan dengan kode, dan lagi-lagi Kolya menderita gagal memenuhi tenggat waktu. <br><br>  <b>3. API tidak didokumentasikan</b> <br><br>  Manajer Kolya memutuskan untuk menerbitkan API komponen A sehingga integrator dapat membuat integrasi yang luar biasa.  Integrator dihadapkan dengan masalah, layanan dukungan kelebihan beban, semuanya terbakar dengan manajer Kolya, dan Vasya merasa bahwa gilirannya akan segera datang. <br><br>  <b>4. API tidak kompatibel dengan versi lama.</b> <br><br>  Integrasi diterapkan, semua kebakaran padam.  Tapi Vasya tiba-tiba memutuskan bahwa API komponennya jauh dari sempurna dan tenggelam dalam revisi.  Tentu saja, dalam hal ini kompatibilitas ke belakang dilanggar dan semua integrasi berantakan.  Situasi ini menyebabkan biaya pada bagian integrator dan hilangnya uang oleh perusahaan pengembangan. <br><br><h3>  Metode pengobatan </h3><br>  Semua masalah ini muncul ketika programmer tidak tahu tentang REST API yang baik atau tampilan ini terpecah-pecah.  Pada kenyataannya, tidak semua pengembang memiliki pengalaman dengan REST.  Dan karena itu, metode utama "perawatan" ditujukan untuk pendidikan.  Ketika visi API yang tepat, yang dikoordinasikan dengan visi pengembang lain, arsitek, dan dokumenter, mulai mual di kepala setiap pengembang, API menjadi ideal.  Proses pembentukan visi ini membutuhkan upaya dan alat khusus, yang sekarang akan kita bicarakan. <br><br><h4>  Nyeri 1. Anotasi tidak sesuai dengan implementasi </h4><br>  Anotasi mungkin berbeda dari kondisi layanan saat ini tidak hanya karena itu adalah API dari "masa lalu yang gelap", yang tidak dapat dijangkau.  Ini juga bisa menjadi API masa depan yang cerah yang belum tiba. <br><br>  Alasan untuk kondisi ini adalah kurangnya pemahaman tentang mengapa anotasi diperlukan.  Tanpa teror dari pihak arsitek, pengembang cenderung menganggap anotasi sebagai alat bantu internal dan tidak menyiratkan bahwa seseorang di luar akan menggunakannya. <br><br>  Anda dapat menyembuhkan rasa sakit ini dengan: <br><br><ul><li>  <b>Ulasan arsitektur.</b>  Suatu hal yang sangat berguna bagi perusahaan dari semua ukuran, di mana setidaknya ada satu programmer yang "tahu bagaimana melakukannya dengan benar".  Saat mengganti layanan, arsitek atau penanggung jawab harus memantau status anotasi dan mengingatkan programmer bahwa perlu memperbarui tidak hanya layanan, tetapi juga deskripsinya.  Efek samping - hambatan dalam wajah arsitek </li><li>  <b>Pembuatan kode dari anotasi.</b>  Inilah yang disebut pendekatan API-first.  Ini menyiratkan bahwa Anda awalnya membuat anotasi, kemudian menghasilkan kode utama (ada cukup alat untuk ini, misalnya [go-swagger] (https://github.com/go-swagger/go-swagger)), dan kemudian mengisi layanan bisnis logika  Pengaturan ini menghindari ketidakkonsistenan.  Ini bekerja dengan baik ketika bidang tugas yang diselesaikan oleh layanan jelas digambarkan. </li><li>  <b>Menguji anotasi versus implementasi</b> .  Untuk melakukan ini, kami menghasilkan dari anotasi (RAML / kesombongan) klien yang membombardir layanan dengan permintaan.  Jika jawaban sesuai dengan anotasi, dan layanan itu sendiri tidak jatuh, maka semuanya baik-baik saja. </li></ul><br>  <b>Menguji anotasi vs implementasi</b> <br>  Mari kita coba pengujian.  Pembuatan kueri yang sepenuhnya otomatis semacam itu adalah tugas yang kompleks.  Memiliki data dari anotasi API, Anda dapat membuat permintaan terpisah.  Namun, API apa pun menyiratkan dependensi, misalnya, sebelum memanggil GET / klien / {cliend_id} Anda harus membuat objek ini terlebih dahulu dan kemudian mendapatkan id.  Kadang-kadang dependensi kurang eksplisit - membuat objek X memerlukan melewati pengidentifikasi objek terkait Y, dan ini bukan sub-koleksi.  Baik RAML maupun Swagger memungkinkan dependensi eksplisit untuk dijelaskan.  Oleh karena itu, beberapa pendekatan mungkin dilakukan di sini: <br><br><ol><li>  Harapkan komentar formal dari pengembang dalam anotasi yang mengindikasikan dependensi. </li><li>  Untuk meminta deskripsi urutan yang diharapkan dari pengembang (ada beberapa cara untuk menggambarkan permintaan menggunakan <a href="https://github.com/taverntesting/tavern">YAML</a> , <a href="https://github.com/intuit/karate">DSL</a> khusus <a href="https://github.com/intuit/karate">,</a> atau melalui GUI yang indah, seperti yang dilakukan oleh orang yang ditinggalkan sekarang. </li><li>  Ambil data nyata (misalnya, menggunakan <a href="https://openresty.org/en/">OpenResty</a> untuk <a href="https://openresty.org/en/">mencatat</a> semua permintaan dan respons server) </li><li>  Ekstrak dependensi dari anotasi menggunakan (hampir) kecerdasan buatan (mis. <a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf">RESTler</a> ) </li></ol><br>  Bagaimanapun, tugas pengujian sangat memakan waktu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/194/5d1/965/1945d1965cf415d42cd0f0e724735e57.png" alt="gambar"><br><br>  Secara pribadi, kami sampai pada titik mempersiapkan urutan pengujian secara manual.  Bagaimanapun, pengembang perlu menulis tes, sehingga kami dapat menyediakan mereka dengan alat yang nyaman yang dapat menemukan beberapa bug tambahan. <br><br>  Utilitas kami menggunakan yaml berikut untuk menggambarkan urutan permintaan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa1/26e/bf6/aa126ebf6f6eda1c65b596d4d80b812e.png" alt="gambar"><br><br>  Kurung keriting menyatakan variabel yang disubstitusikan selama pengujian.  Variabel alamat dilewatkan sebagai parameter CLI, dan acak menghasilkan string arbitrer.  Yang paling menarik di sini adalah bidang response-to-var: berisi variabel di mana json akan ditulis dengan respons server.  Dengan demikian, di baris terakhir, Anda bisa mendapatkan id dari objek yang dibuat menggunakan task.id. <br><br><h4>  Nyeri 2. API tidak konsisten </h4><br>  Apa itu konsistensi?  Kami tidak akan memperkenalkan definisi formal apa pun, tetapi, menyederhanakan, ini adalah konsistensi internal.  Misalnya, dalam proyek awal, Vasya perlu mengumpulkan data laporan di HighLoad, dan API menyediakan pemfilteran data berdasarkan tahun.  Setelah proyek hampir selesai, manajer Kolya datang ke Vasya dengan permintaan untuk menambahkan statistik pada pembicara untuk analisis, dan untuk membuat metode baru "GET speaker" juga dengan penyaringan berdasarkan tahun.  Akibatnya, Vasya menyelesaikan kode dalam beberapa jam, tetapi selama proses pengujian ternyata metode ini tidak berfungsi.  Alasannya adalah bahwa dalam satu kasus, "tahun" adalah angka, di lain, string.  Tapi ini, tentu saja, tidak jelas pada pandangan pertama dan membutuhkan perawatan yang konstan saat bekerja dengan API.  Kegigihan API adalah ketika perawatan berlebihan seperti itu tidak diperlukan. <br><br>  Ada banyak contoh ketidakkonsistenan: <br><br><ol><li>  penggunaan format berbeda dari data yang sama.  Misalnya, format waktu, jenis pengidentifikasi (nomor atau string UUID), </li><li>  menerapkan sintaks yang berbeda untuk penyaringan atau pagination, </li><li>  skema otorisasi berbeda untuk layanan.  Tidak hanya perbedaan otak pemrogram bedak, mereka juga bercermin pada tes yang perlu mendukung skema yang berbeda. </li></ol><br><br>  <b>Pengobatan</b> : <br><br><ul><li>  <b>Ulasan arsitektur.</b>  Jika ada arsitek tiran, ia (tanpa adanya skizofrenia) akan memastikan konsistensi.  Efek samping: faktor bus dan tirani :) </li><li>  <b>Membuat API Pedoman.</b>  Ini adalah standar tunggal yang perlu dikembangkan (atau disiapkan), tetapi yang paling penting adalah untuk menerapkannya.  Ini membutuhkan propaganda, tongkat, dan wortel. </li><li>  <b>Penerapan pemeriksaan statis</b> untuk kepatuhan dengan Pedoman API anotasi (baca di <a href="https://habr.com/ru/company/acronis/blog/470910/">sini</a> ). </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/aa1/26e/bf6/aa126ebf6f6eda1c65b596d4d80b812e.png" alt="gambar"><br>  <i><font color="#999999">Contoh - Item Tes Statis</font></i> <br><br>  Setiap perusahaan membuat pilihannya sendiri untuk menggunakan Pedoman mana.  Dan, mungkin, tidak ada pendekatan universal, apa yang seharusnya dan apa yang tidak.  Lagi pula, semakin banyak ketentuan dalam standar, semakin ketat Anda mengendalikan dan semakin Anda membatasi kebebasan kreativitas.  Dan yang paling penting, sedikit orang membaca sampai akhir dokumen "hanya 100 halaman". <br><br>  Di perusahaan kami, kami memasukkan poin-poin berikut dalam pedoman: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47d/613/f76/47d613f762d1dfee282bcc5d97a69f0e.png" alt="gambar"><br>  Contoh Pedoman bagus lainnya dapat ditemukan di <a href="">Microsoft</a> , <a href="">PayPal</a> , <a href="https://cloud.google.com/apis/design/">Google</a> . <br><br><h4>  Nyeri 3. API tidak didokumentasikan </h4><br>  Keberadaan anotasi adalah syarat yang diperlukan tetapi tidak cukup untuk kesederhanaan bekerja dengan API.  Anda dapat menulis anotasi sehingga tidak menyadari potensi penuhnya.  Ini terjadi ketika: <br><br><ol><li>  tidak cukup deskripsi (untuk parameter, header, kesalahan, dll.); </li><li>  tidak ada cukup contoh penggunaan, karena contoh dapat digunakan tidak hanya untuk meningkatkan dokumentasi (lebih banyak konteks untuk pengembang dan kemampuan untuk bermain langsung dengan API langsung dari portal), tetapi juga untuk pengujian (sebagai titik awal untuk fuzzing)); </li><li>  ada fitur tidak berdokumen. </li></ol><br>  Biasanya ini terjadi ketika pengembang tidak memiliki pemahaman yang jelas tentang mengapa anotasi yang diperlukan diperlukan, ketika tidak ada komunikasi antara penulis teknis dan programmer, dan juga jika tidak ada yang tahu berapa biaya perusahaan dengan dokumentasi yang buruk.  Dan jika mereka datang ke programmer dan menarik setelah setiap permintaan dukungan, semua anotasi akan diisi dengan sangat cepat. <br><br>  <b>Pengobatan:</b> <br><br><ul><li>  <b>Ketersediaan alat penghasil referensi API untuk programmer.</b>  Jika pengembang melihat seperti apa uraian API-nya bagi kolega dan pengguna, ia akan mencoba membuat anotasi lebih baik.  Efek samping: Mengkonfigurasi alat-alat ini akan membutuhkan pekerjaan manual tambahan. </li><li>  <b>Mengatur interaksi antara semua yang terlibat</b> : programmer, penginjil, staf pendukung.  Efek samping: bertemu semua orang dengan semua orang, proses yang rumit. </li><li>  <b>Menggunakan tes berdasarkan anotasi API</b> .  Penerapan pemeriksaan statis di atas dalam repositori CI dengan anotasi. </li></ul><br>  Di Acronis, API anotasi dihasilkan berdasarkan anotasi dengan klien SDK dan bagian Try-It.  Bersama-sama dengan contoh kode dan deskripsi kasus penggunaan, mereka membentuk berbagai tambahan yang diperlukan dan nyaman untuk programmer.  Lihat portal kami di developer.acronis.com <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9a/393/66e/e9a39366ef31a82816b011e78b259e39.png" alt="gambar"><br><br>  Saya harus mengatakan bahwa ada seluruh kelas alat untuk menghasilkan referensi API.  Beberapa perusahaan sendiri mengembangkan alat tersebut untuk kebutuhan mereka sendiri.  Lainnya menggunakan alat yang cukup sederhana dan gratis seperti <a href="https://editor.swagger.io/">Editor Swagger</a> .  Setelah penelitian yang sangat panjang, kami di Acronis memilih Apimatic.io, lebih memilihnya daripada REST United, Mulesoft AnyPoint, dan lainnya. <br><br><h4>  Nyeri 4. Masalah kompatibilitas ke belakang </h4><br>  Kompatibilitas mundur mungkin terganggu karena hal-hal sepele.  Sebagai contoh, programmer Vasya menulis kata kompatibilitas setiap kali dengan kesalahan ketik: kompatibilitas.  Kesalahan ketik ini ditemukan dalam kode, di komentar, dan dalam satu parameter kueri.  Setelah melihat kesalahan, Vasya membuat penggantian kata ini di seluruh proyek dan tanpa melihat mengirimkan perubahan ke produksi.  Tentu saja, kompatibilitas ke belakang akan terganggu dan layanan akan turun selama beberapa jam. <br><br>  Mengapa peristiwa seperti itu bisa terjadi?  Alasan utamanya adalah kesalahpahaman dari siklus hidup API, yang dapat memanifestasikan dirinya dalam melanggar integrasi, dalam kebijakan EOL (End Of Life) yang tidak dapat diprediksi, dan dalam rilis API yang tidak jelas. <br><br>  <b>Pengobatan:</b> <br><br><ul><li>  <b>Ulasan arsitektur.</b>  Seperti biasa, tangan tegas seorang arsitek dapat mencegah kompatibilitas ke belakang.  Namun, tugas utamanya adalah menjelaskan biaya untuk mendukung beberapa versi dan mencari opsi untuk membuat perubahan tanpa melanggar API yang ada. </li><li>  <b>Pemeriksaan kompatibilitas mundur.</b>  Jika anotasi API berisi uraian terbaru, maka pelanggaran kompatibilitas mundur dapat diperiksa pada tahap CI; </li><li>  <b>Pembaruan dokumentasi tepat waktu.</b>  Referensi API dan deskripsi API harus diperbarui pada saat yang sama ketika kode layanan berubah.  Untuk melakukan ini, Anda setidaknya dapat memulai daftar periksa standar, setidaknya mengatur pemberitahuan untuk perubahan, setidaknya melatih kemampuan super untuk menghasilkan segalanya dari segalanya ... Penting!  Departemen dokumentasi harus mengetahui semua perubahan yang direncanakan sehingga mereka memiliki kesempatan untuk merencanakan sumber daya untuk memperbarui dokumentasi dan menulis panduan peningkatan.  Panduan Upgrade, diuji dan diverifikasi, adalah atribut menyedihkan dari penggantian nama yang Anda mulai di API. </li></ul><br><h3>  Ubah manajemen </h3><br>  Aturan yang menggambarkan aktivitas yang terkait dengan siklus hidup API disebut kebijakan manajemen perubahan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/576/a06/d97/576a06d97a0f5c3ab4a5fb95f3e1faf0.png" alt="gambar"><br><br>  Jika Anda memiliki dua versi anotasi "saat ini" dan "baru", pemeriksaan kompatibilitas mundur secara teknis sederhana: cukup uraikan kedua anotasi dan periksa apakah bidang yang diperlukan ada <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99a/6d7/51a/99a6d751ac5990ba394401d35e2fb064.png" alt="gambar"><br><br>  Kami menulis alat khusus yang memungkinkan Anda untuk membandingkan semua parameter penting untuk kompatibilitas mundur di CI.  Misalnya, ketika mengubah badan tanggapan dalam permintaan cek kesehatan / GET, pesan yang mirip dengan yang berikut ini akan ditampilkan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b5/8ec/b39/5b58ecb39ec5c48488a4bc4cb710ba4b.png" alt="gambar"><br><br><h3>  Kesimpulan </h3><br>  Setiap arsitek bermimpi untuk menyingkirkan masalah API.  Setiap manajer bermimpi tidak tahu tentang masalah API.  :)  Ada banyak obat, tetapi masing-masing memiliki harga sendiri dan efek sampingnya.  Kami berbagi opsi perawatan kami untuk penyakit anak-anak yang paling sederhana dengan API, dan kemudian timbul masalah yang lebih serius.  Kesimpulan dari artikel kami "kapten": Masalah API dimulai dengan kepala dan mengajar orang praktik yang baik adalah jaminan utama kesuksesan.  Yang lainnya hanyalah masalah teknologi.  Dan masalah apa yang Anda hadapi dan solusi apa yang Anda pilih di organisasi Anda? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cdd/9d4/718/cdd9d47186f9c974f130eac5b6c083bb.png" alt="gambar"><br>  <i><font color="#999999">Obat untuk API buruk.</font></i> <br><br>  Kami akan senang dengan segala pemikiran, peringkat, komentar, pendapat dan pertanyaan! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483380/">https://habr.com/ru/post/id483380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483368/index.html">Membuat file packer ELF x86_64 untuk linux</a></li>
<li><a href="../id483372/index.html">Cara melatih jaringan saraf DeepPavlov di laptop menggunakan GPU</a></li>
<li><a href="../id483374/index.html">Rekomendasi API REST - Contoh Desain Layanan Web di Jawa dan Musim Semi</a></li>
<li><a href="../id483376/index.html">Di permukaan lubang hitam</a></li>
<li><a href="../id483378/index.html">Jenis-aman bekerja dengan register tanpa overhead di C ++ 17: metaprogramming berbasis nilai</a></li>
<li><a href="../id483382/index.html">Kali Linux 2020.1</a></li>
<li><a href="../id483384/index.html">Apa kata-kata bahasa Inggris dari leksikon IT yang paling sering kita ucapkan salah</a></li>
<li><a href="../id483386/index.html">Tabrakan galaksi yang akan datang dari Bima Sakti sudah melahirkan bintang-bintang baru</a></li>
<li><a href="../id483388/index.html">Pacar saya dan gim video pertama. Pengembangan persatuan. Bagian 2</a></li>
<li><a href="../id483392/index.html">Jumlah nilai maksimum di enum Bagian I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>