<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÑ üîµ ‚õ±Ô∏è Gu√≠a para la auditor√≠a autom√°tica de contratos inteligentes. Parte 3: Mythril ü§∑üèº ü¶è üö£üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advertencia 


 Este art√≠culo no es una calificaci√≥n de la efectividad de los analizadores autom√°ticos. Los aplico a mis propios contratos, sintetizan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a para la auditor√≠a autom√°tica de contratos inteligentes. Parte 3: Mythril</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442114/"><h2 id="warning">  <strong>Advertencia</strong> </h2><br><p>  Este art√≠culo no es una calificaci√≥n de la efectividad de los analizadores autom√°ticos.  Los aplico a mis propios contratos, sintetizando errores intencionalmente, y estudio las reacciones.  Tal estudio no puede ser la base para determinar "mejor-peor", para esto tiene sentido realizar un estudio ciego en una gran muestra de contratos, que, dada la naturaleza caprichosa de este tipo de software, es extremadamente dif√≠cil de realizar.  Es muy posible que un peque√±o error en el contrato pueda deshabilitar una gran parte de la l√≥gica del analizador, y un simple signo heur√≠stico puede agregar una enorme cantidad de puntos al analizador al encontrar un error generalizado que los competidores simplemente no lograron agregar.  Los errores en la preparaci√≥n y compilaci√≥n de contratos tambi√©n pueden desempe√±ar un papel.  Todo el software en cuesti√≥n es bastante joven y se est√° desarrollando constantemente, por lo que no tome los comentarios cr√≠ticos como problemas irreparables. </p><br><p> El prop√≥sito del art√≠culo es dar al lector una comprensi√≥n de c√≥mo funcionan los m√©todos de an√°lisis de c√≥digo en diferentes analizadores y la capacidad de usarlos correctamente, en lugar de "tomar una decisi√≥n".  Una opci√≥n razonable es utilizar varias herramientas a la vez, centr√°ndose en la m√°s adecuada para el contrato analizado. </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>Configuraci√≥n y preparaci√≥n para el lanzamiento.</strong> </h2><br><p>  Mythril utiliza varios tipos de an√°lisis a la vez, aqu√≠ hay un par de buenos art√≠culos al respecto: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s importante</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> .  Antes de continuar, tiene sentido leerlos. </p><br><p>  Primero, construyamos nuestra propia imagen Docker de Mythril (¬øno importa lo que queramos cambiar en ella?): </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p>  Ahora intente ejecutarlo en nuestros <code>contracts/flattened.sol</code> (uso el mismo contrato que se discuti√≥ en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducci√≥n</a> ), en el que hay dos contratos principales, <code>Ownable</code> de Zeppelin y nuestra <code>Booking</code> .  Todav√≠a tenemos un problema con la versi√≥n del compilador, lo arregl√© de la misma manera que en el art√≠culo anterior, agregando l√≠neas al Dockerfile que reemplazar√° la versi√≥n del compilador: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  Despu√©s de reconstruir la imagen, puede intentar ejecutar un an√°lisis de contrato.  Inmediatamente usemos los indicadores <code>-v4</code> y <code>--verbose-report</code> para ver todas las advertencias.  Vamos: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p>  Aqu√≠ trabajamos con un contrato aplanado sin dependencias.  Para analizar un contrato de <code>Booking.sol</code> separado y hacer que Mythril recoja todas las dependencias, puede usar algo como esto: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p>  Prefiero trabajar con la opci√≥n aplanada, como  modificaremos mucho en el c√≥digo.  Pero Mythril tambi√©n tiene un modo extremadamente conveniente: la <code>--truffle</code> , que simplemente <code>--truffle</code> todo lo que <code>truffle</code> y verifica la vulnerabilidad de todo el proyecto.  Otra caracter√≠stica importante es la capacidad de especificar el nombre del contrato que se analizar√° a trav√©s de dos puntos, de lo contrario Mythril analizar√° todos los contratos que encuentre.  Creemos que <code>Ownable</code> 's Ownable es un contrato seguro, y solo vamos a analizar <code>Booking</code> , por lo que la l√≠nea final para ejecutar es: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>Iniciar y desplegar contrato</strong> </h2><br><p>  Iniciamos el analizador con la l√≠nea anterior, miramos la salida y obtenemos, entre otras cosas, esta l√≠nea: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p>  Resulta que nuestro contrato no fue creado y "arreglado" en el emulador.  Es por eso que recomiendo usar el indicador <code>-v4</code> para todos los tipos de an√°lisis para ver todos los mensajes y no perder ninguno.  Veamos qu√© pasa.  La soluci√≥n a este problema pr√°ctico es bastante importante para comprender c√≥mo usar Mythril correctamente. </p><br><p>  Entonces, estamos leyendo sobre Mythril: <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> .  Si no est√° muy familiarizado con estos t√©rminos, le recomiendo el wiki sobre pruebas conc√≥licas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ hay una</a> buena presentaci√≥n sobre la comprobaci√≥n de manchas para x86.  En resumen: Mythril emula la ejecuci√≥n de un contrato, arregla las ramas a lo largo de las cuales puede ir la ejecuci√≥n e intenta alcanzar un estado "roto" del contrato, clasificando varias combinaciones de par√°metros e intentando sortear todas las rutas posibles.  Aqu√≠ hay un diagrama de acci√≥n de muestra del art√≠culo anterior: </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p>  Si lo simplifica enormemente, Mythril, despu√©s de haber encontrado una rama en el c√≥digo, puede entender bajo qu√© conjuntos de variables es posible ingresar en una y otra rama.  En cada rama, Mythril sabe si conduce a la <code>selfdestruct</code> <code>transfer</code> , <code>selfdestruct</code> y otros <code>selfdestruct</code> relevantes para la seguridad.  Por lo tanto, Mythril analiza qu√© conjuntos de par√°metros y transacciones pueden conducir a una violaci√≥n de seguridad.  Y la forma en que Mythril corta ramas que nunca obtienen control y analiza el flujo de control es su truco principal.  Aqu√≠ encontrar√° m√°s detalles sobre el intestino Mythril y el andar de ramas. </p><br><p>  Debido a la naturaleza determinista de la ejecuci√≥n de contratos inteligentes, la misma secuencia de instrucciones siempre conduce estrictamente a un conjunto de cambios de estado, independientemente de la plataforma, la arquitectura o el entorno.  Adem√°s, las funciones en los contratos inteligentes son bastante cortas y los recursos son extremadamente limitados, por lo tanto, los analizadores como Mythril, que combinan la ejecuci√≥n simb√≥lica y nativa, pueden funcionar de manera extremadamente eficiente para los contratos inteligentes. </p><br><p>  En el proceso, Mythril utiliza el concepto de "estado": este es el c√≥digo del contrato, su entorno, un puntero al comando actual, el almacenamiento del contrato y el estado de la pila.  Aqu√≠ est√° la documentaci√≥n: </p><br><pre> <code class="plaintext hljs">The machine state Œº is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ‚àà P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents Œºm are a series of zeroes of size 256.</code> </pre> <br><p>  El gr√°fico de transici√≥n entre estados es el principal objeto de estudio.  En caso de lanzamiento exitoso del an√°lisis, la informaci√≥n sobre este gr√°fico se muestra en el registro de an√°lisis.  Adem√°s, Mythril puede construir este gr√°fico en una forma legible por humanos usando la opci√≥n <code>--graph</code> . </p><br><p>  Ahora, m√°s o menos entendiendo lo que har√° Mythril, seguiremos entendiendo por qu√© el contrato no se analiza y de d√≥nde proviene <code>[WARNING]: No contract was created during the execution of contract creation</code> .  Para comenzar, <code>--max-depth</code> <code>--create-timeout</code> y <code>--max-depth</code> (como se recomienda) y, al no obtener el resultado, pens√© que el culpable era el constructor, algo que no funcionaba.  Aqu√≠ est√° su c√≥digo: </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p>  Recordemos el algoritmo de acci√≥n de Mythril.  Para ejecutar el seguimiento, debe llamar al constructor del contrato, porque toda la ejecuci√≥n posterior depender√° de los par√°metros con los que se llam√≥ al constructor.  Por ejemplo, si llama al constructor con <code>_price == 0</code> , el constructor lanzar√° una excepci√≥n en <code>require(_price &gt; 0)</code> .  Incluso si Mythril itera sobre los muchos valores de <code>_price</code> , el constructor a√∫n se romper√° si, por ejemplo, <code>_price &lt;= _cancellationFee</code> .  En este contrato, hay una docena de par√°metros asociados con restricciones estrictas, y Mythril, por supuesto, no puede adivinar las combinaciones v√°lidas de par√°metros.  Intenta pasar a la siguiente rama de ejecuci√≥n, clasificando los par√°metros del constructor, pero pr√°cticamente no tiene ninguna posibilidad de adivinar: hay demasiadas combinaciones de par√°metros.  Por lo tanto, el c√°lculo del contrato no funciona: todas las formas se basan en alg√∫n tipo de <code>require(...)</code> , y obtenemos el problema anterior. </p><br><p>  Ahora tenemos dos formas: la primera es deshabilitar todos los <code>require</code> en el constructor al comentarlos.  Entonces Mythril podr√° llamar al constructor con cualquier conjunto de par√°metros y todo funcionar√°.  Pero esto significa que al examinar un contrato con tales par√°metros, Mythril encontrar√° errores que son posibles con valores incorrectos pasados ‚Äã‚Äãal constructor.  En pocas palabras, si Mythril encuentra un error que surge si el creador del contrato especifica <code>_cancellationFee</code> mil millones de veces el precio de alquiler de <code>_mprice</code> , entonces no hay uso en dicho error: dicho contrato nunca se bloquear√° y se <code>_mprice</code> recursos para encontrar errores.  Implicamos que el contrato todav√≠a est√° atascado con par√°metros m√°s o menos consistentes, por lo que para un an√°lisis posterior tiene sentido especificar par√°metros de constructor m√°s realistas para que Mythril no busque errores que nunca ocurrir√°n si el contrato se cierra correctamente. </p><br><p>  Pas√© muchas horas tratando de entender exactamente d√≥nde se rompe el despliegue, incluyendo e inhabilitando varias partes del constructor.  Adem√°s de mis problemas, el constructor usa <code>getCurrentTime()</code> , que devuelve la hora actual, y no est√° claro c√≥mo maneja esta llamada Mythril.  No describir√© estas aventuras aqu√≠, porque  Lo m√°s probable es que con el uso regular, estas sutilezas sean conocidas por el auditor.  Por lo tanto, eleg√≠ la segunda forma: para limitar los datos de entrada, y simplemente <code>getCurrentTime()</code> todos los par√°metros del constructor, incluso <code>getCurrentTime()</code> , simplemente codifiqu√© los par√°metros necesarios directamente en el constructor (idealmente, estos par√°metros deben obtenerse del cliente): </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p>  Adem√°s, para que todo comience, tambi√©n debe establecer el par√°metro de <code>max-depth</code> .  Me funcion√≥ con este constructor con <code>--max-depth=34</code> en la instancia de AWS t2.medium.  Al mismo tiempo, en mi computadora port√°til, que es m√°s potente, todo comienza sin ninguna <code>max-depth</code> .  A juzgar por el uso de este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">par√°metro</a> , es necesario construir ramas para el an√°lisis, y su valor predeterminado es infinito ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> ).  Por lo tanto, gire este par√°metro, pero aseg√∫rese de analizar el contrato deseado.  Puedes entender esto por mensajes como: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p>  La primera l√≠nea solo describe el gr√°fico que se analizar√°, lea el resto de las l√≠neas usted mismo.  Se requieren recursos computacionales serios para analizar las diversas ramas que se pueden ejecutar, por lo que al analizar contratos grandes, tendr√° que esperar incluso en una computadora r√°pida. </p><br><h2 id="poisk-oshibok">  <strong>Buscar errores</strong> </h2><br><p>  Ahora buscaremos errores y agregaremos los nuestros.  Mythril busca sucursales en las que se realizan transmisiones, autodestrucciones, afirmaciones y otras acciones que son importantes desde el punto de vista de la seguridad.  Si una de las instrucciones anteriores aparece en alg√∫n lugar del c√≥digo del contrato, Mythril examina las formas en que es posible llegar a esta sucursal y, adem√°s, muestra la secuencia de transacciones que conducen a esta sucursal. </p><br><p>  Primero, veamos qu√© emiti√≥ Mythril para el prolongado contrato de <code>Booking</code> .  Primera advertencia: </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p>  y surge porque </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p>  en la funci√≥n de reserva. </p><br><p>  Tenga en cuenta que Mythril se dio cuenta de que <code>getCurrentTime()</code> oculta en <code>getCurrentTime()</code> .  A pesar del hecho de que el significado del contrato no es un error, el hecho de que Mythril asocie <code>block.timestamp</code> con la transmisi√≥n es excelente.  En este caso, el programador debe comprender que la decisi√≥n se toma sobre la base del valor que el minero puede controlar.  Y, si en el futuro surge una subasta u otra subasta para un servicio en este lugar del contrato, se debe tener en cuenta la posibilidad de ataques de primera l√≠nea. </p><br><p>  Veamos si Mythril ve una dependencia en <code>block.timestamp</code> si <code>block.timestamp</code> la variable en una llamada anidada como esta: </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p>  Y si!  Mythril contin√∫a viendo la conexi√≥n entre block.timestamp y la transferencia de transmisi√≥n, esto es extremadamente importante para el auditor.  La conexi√≥n entre la variable controlada por el atacante y la decisi√≥n tomada despu√©s de varios cambios en el estado del contrato puede estar muy enmascarada por la l√≥gica, y Mythril le permite rastrearla.  Aunque no vale la pena confiar en el hecho de que todas las conexiones posibles entre todas las variables posibles ser√°n <code>getCurrentTime()</code> por usted: si contin√∫a burl√°ndose de la funci√≥n <code>getCurrentTime()</code> y realiza una triple profundidad de anidaci√≥n, la advertencia desaparece.  Cada llamada a funciones para Mythril requiere la creaci√≥n de nuevas ramas estatales, por lo que analizar niveles muy profundos de anidamiento requerir√° enormes recursos. </p><br><p>  Existe, por supuesto, una posibilidad bastante seria de que simplemente use incorrectamente los par√°metros de an√°lisis o que el corte ocurra en alg√∫n lugar en las profundidades del analizador.  Como dije, el producto est√° en desarrollo activo, justo en el momento de escribir esto, veo compromisos en el repositorio con la menci√≥n de <code>max-depth</code> , por lo que no tome en serio los problemas actuales, ya hemos encontrado suficiente evidencia de que Mythril puede buscar muy efectivamente conexiones impl√≠citas entre variables </p><br><p>  Primero, agregue al contrato una funci√≥n que proporcione la transmisi√≥n a cualquier persona, pero solo despu√©s de que el cliente env√≠e la transmisi√≥n al contrato.  Permitimos que cualquiera recoja 1/5 del √©ter, pero solo cuando el contrato est√° en estado <code>State.PAID</code> Estado <code>State.PAID</code> (es decir, solo despu√©s de que el cliente haya pagado el n√∫mero alquilado con el √©ter).  Aqu√≠ est√° la funci√≥n: </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p>  Mythril encontr√≥ el problema: </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p>  Genial, es decir  Mythril incluso sac√≥ dos transacciones, lo que lleva al hecho de que puede tomar √©ter del contrato.  Ahora cambie el requisito <code>State.RENT</code> a <code>State.RENT</code> , as√≠: </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p>  Ahora se puede llamar a <code>collectTaxes()</code> solo cuando el contrato est√° en el <code>State.RENT</code> state, y en este momento no hay nada en el saldo, porque  El contrato ya ha enviado toda la transmisi√≥n al propietario.  ¬°Y lo importante aqu√≠ es que Mythril esta vez <strong>NO</strong> genera el error <code>==== Unprotected Ether Withdrawal ====</code> !  Bajo la condici√≥n <code>onlyState(State.RENT)</code> , el analizador no lleg√≥ a la rama de c√≥digo que env√≠a el √©ter del contrato con un saldo distinto de cero.  Mythril pas√≥ por diferentes opciones para los par√°metros, pero puede ingresar a <code>State.RENT</code> solo enviando toda la transmisi√≥n al arrendador.  Por lo tanto, es imposible llegar a esta rama del c√≥digo con un saldo distinto de cero, ¬°y Mythril no molesta absolutamente al auditor! </p><br><p>  Del mismo modo, Mythril encontrar√° <code>selfdestruct</code> y <code>selfdestruct</code> , mostrando al auditor qu√© acciones pueden conducir a la destrucci√≥n del contrato o al colapso de una funci√≥n importante.  No dar√© estos ejemplos, solo trato de hacer una funci√≥n similar a la anterior, solo llamando a <code>selfdestruct</code> , y <code>selfdestruct</code> su l√≥gica. </p><br><p>  Adem√°s, no olvide que una de las partes de Mythril es la ejecuci√≥n simb√≥lica, y este enfoque, por s√≠ solo, sin emular la ejecuci√≥n, puede determinar muchas vulnerabilidades.  Por ejemplo, cualquier uso de "+", "-" y otros operadores aritm√©ticos puede considerarse una vulnerabilidad de "Desbordamiento de enteros" si el atacante controla de alguna manera uno de los operandos.  Pero repito nuevamente, la caracter√≠stica m√°s poderosa de Mythril es la combinaci√≥n de ejecuci√≥n simb√≥lica y nativa y la determinaci√≥n de valores de par√°metros que conducen a la ramificaci√≥n l√≥gica. </p><br><h2 id="zaklyuchenie">  <strong>Conclusi√≥n</strong> </h2><br><p>  Por supuesto, para mostrar la gama completa de problemas potenciales que Mythril es capaz de detectar, se necesitar√°n no solo uno, sino varios art√≠culos.  Para todo lo dem√°s, sabe c√≥mo hacerlo todo en una cadena de bloques real, encontrando los contratos y vulnerabilidades necesarios mediante firmas, creando hermosos gr√°ficos de llamadas, formateando informes.  Mythril tambi√©n le permite escribir sus propios scripts de prueba, proporcionando una interfaz basada en python para el contrato y permiti√©ndole probar funciones individuales, corregir valores de par√°metros o incluso implementar su propia estrategia para trabajar con c√≥digo desmontado con un grado arbitrario de flexibilidad. </p><br><p>  Mythril sigue siendo un software bastante joven, este no es IDA Pro, y hay muy poca documentaci√≥n, excepto algunos art√≠culos.  El valor de muchos par√°metros solo se puede leer en el c√≥digo Mythril, comenzando con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cli.py.</a>  Espero que en la documentaci√≥n aparezca una descripci√≥n completa y detallada del funcionamiento de cada par√°metro. </p><br><p>  Adem√°s, cuando el contrato es m√°s o menos grande, la producci√≥n de un mont√≥n de errores ocupa mucho espacio, pero me gustar√≠a poder recibir informaci√≥n comprimida sobre el error encontrado, porque  cuando trabaje con Mythril, definitivamente debe mirar la ruta de an√°lisis, ver qu√© contratos han sido probados de la mejor manera posible y ser capaz de desactivar por la fuerza errores espec√≠ficos que el auditor considera falsos positivos. </p><br><p>  Pero en general, Mythril es una herramienta excelente y extremadamente poderosa para analizar contratos inteligentes y, por el momento, debe estar en el arsenal de cualquier auditor.  Le permite al menos prestar atenci√≥n a las partes cr√≠ticas del c√≥digo y detectar relaciones ocultas entre variables. </p><br><p>  Para resumir, las recomendaciones para usar Mythril son: </p><br><ol><li>  Limite las condiciones de inicio del contrato en estudio tanto como sea posible.  Si durante el an√°lisis Mythril gastar√° muchos recursos en sucursales que nunca se implementar√°n en la pr√°ctica, perder√° la capacidad de encontrar errores realmente importantes, por lo que siempre debe tratar de reducir el √°rea de sucursales potenciales. </li><li>  Aseg√∫rese de que el an√°lisis del contrato ha comenzado, no se pierda mensajes como <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> , de lo contrario puede considerar err√≥neamente que no hay errores. </li><li>  Puede deshabilitar arbitrariamente las sucursales en el c√≥digo del contrato, dando a Mythril menos variaci√≥n en la elecci√≥n de sucursales y el ahorro de recursos.  Intente hacerlo sin restricciones en <code>max-depth</code> , para no "cortar" el an√°lisis, pero tenga cuidado de no enmascarar el error. </li><li>  Preste atenci√≥n a cada advertencia, incluso los comentarios ligeros a veces valen la pena al menos agregar un comentario al c√≥digo del contrato, lo que facilita a otros desarrolladores. </li></ol><br><p>  En el pr√≥ximo art√≠culo, trataremos el analizador Manticore, pero aqu√≠ est√° la tabla de contenido para los art√≠culos que est√°n listos o planeados para su escritura: </p><br><p>  Parte 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilaci√≥n, aplanamiento, versiones de Solidity</a> <br>  Parte 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Slither</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Mythril (este art√≠culo) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4. Manticore (durante la escritura) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 5. Echidna (durante la escritura)</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442114/">https://habr.com/ru/post/442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442102/index.html">A la cuesti√≥n de las bater√≠as</a></li>
<li><a href="../442104/index.html">Gu√≠a del usuario de Kibana. Visualizaci√≥n. Parte 5</a></li>
<li><a href="../442108/index.html">Gu√≠a para desarrolladores para crear aplicaciones de IA</a></li>
<li><a href="../442110/index.html">Antipatterns Vim</a></li>
<li><a href="../442112/index.html">Nuevos lenguajes de programaci√≥n matan silenciosamente nuestra conexi√≥n con la realidad</a></li>
<li><a href="../442116/index.html">Mejora de la funcionalidad del componente React con React.memo ()</a></li>
<li><a href="../442118/index.html">El grupo minero de Coinhive deja de funcionar</a></li>
<li><a href="../442120/index.html">Capacitaci√≥n de modelos TensorFlow con el Servicio Azure Machine Learning</a></li>
<li><a href="../442122/index.html">Un simple se√±or moscovita: una entrevista con el creador de Duke Nukem</a></li>
<li><a href="../442124/index.html">Facebook dar√° a los usuarios la oportunidad de limpiar su historia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>