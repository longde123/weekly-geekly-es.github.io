<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😄 🔵 ⛱️ Guía para la auditoría automática de contratos inteligentes. Parte 3: Mythril 🤷🏼 🦏 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advertencia 


 Este artículo no es una calificación de la efectividad de los analizadores automáticos. Los aplico a mis propios contratos, sintetizan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guía para la auditoría automática de contratos inteligentes. Parte 3: Mythril</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442114/"><h2 id="warning">  <strong>Advertencia</strong> </h2><br><p>  Este artículo no es una calificación de la efectividad de los analizadores automáticos.  Los aplico a mis propios contratos, sintetizando errores intencionalmente, y estudio las reacciones.  Tal estudio no puede ser la base para determinar "mejor-peor", para esto tiene sentido realizar un estudio ciego en una gran muestra de contratos, que, dada la naturaleza caprichosa de este tipo de software, es extremadamente difícil de realizar.  Es muy posible que un pequeño error en el contrato pueda deshabilitar una gran parte de la lógica del analizador, y un simple signo heurístico puede agregar una enorme cantidad de puntos al analizador al encontrar un error generalizado que los competidores simplemente no lograron agregar.  Los errores en la preparación y compilación de contratos también pueden desempeñar un papel.  Todo el software en cuestión es bastante joven y se está desarrollando constantemente, por lo que no tome los comentarios críticos como problemas irreparables. </p><br><p> El propósito del artículo es dar al lector una comprensión de cómo funcionan los métodos de análisis de código en diferentes analizadores y la capacidad de usarlos correctamente, en lugar de "tomar una decisión".  Una opción razonable es utilizar varias herramientas a la vez, centrándose en la más adecuada para el contrato analizado. </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>Configuración y preparación para el lanzamiento.</strong> </h2><br><p>  Mythril utiliza varios tipos de análisis a la vez, aquí hay un par de buenos artículos al respecto: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más importante</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> .  Antes de continuar, tiene sentido leerlos. </p><br><p>  Primero, construyamos nuestra propia imagen Docker de Mythril (¿no importa lo que queramos cambiar en ella?): </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p>  Ahora intente ejecutarlo en nuestros <code>contracts/flattened.sol</code> (uso el mismo contrato que se discutió en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducción</a> ), en el que hay dos contratos principales, <code>Ownable</code> de Zeppelin y nuestra <code>Booking</code> .  Todavía tenemos un problema con la versión del compilador, lo arreglé de la misma manera que en el artículo anterior, agregando líneas al Dockerfile que reemplazará la versión del compilador: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  Después de reconstruir la imagen, puede intentar ejecutar un análisis de contrato.  Inmediatamente usemos los indicadores <code>-v4</code> y <code>--verbose-report</code> para ver todas las advertencias.  Vamos: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p>  Aquí trabajamos con un contrato aplanado sin dependencias.  Para analizar un contrato de <code>Booking.sol</code> separado y hacer que Mythril recoja todas las dependencias, puede usar algo como esto: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p>  Prefiero trabajar con la opción aplanada, como  modificaremos mucho en el código.  Pero Mythril también tiene un modo extremadamente conveniente: la <code>--truffle</code> , que simplemente <code>--truffle</code> todo lo que <code>truffle</code> y verifica la vulnerabilidad de todo el proyecto.  Otra característica importante es la capacidad de especificar el nombre del contrato que se analizará a través de dos puntos, de lo contrario Mythril analizará todos los contratos que encuentre.  Creemos que <code>Ownable</code> 's Ownable es un contrato seguro, y solo vamos a analizar <code>Booking</code> , por lo que la línea final para ejecutar es: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>Iniciar y desplegar contrato</strong> </h2><br><p>  Iniciamos el analizador con la línea anterior, miramos la salida y obtenemos, entre otras cosas, esta línea: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p>  Resulta que nuestro contrato no fue creado y "arreglado" en el emulador.  Es por eso que recomiendo usar el indicador <code>-v4</code> para todos los tipos de análisis para ver todos los mensajes y no perder ninguno.  Veamos qué pasa.  La solución a este problema práctico es bastante importante para comprender cómo usar Mythril correctamente. </p><br><p>  Entonces, estamos leyendo sobre Mythril: <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> .  Si no está muy familiarizado con estos términos, le recomiendo el wiki sobre pruebas concólicas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí hay una</a> buena presentación sobre la comprobación de manchas para x86.  En resumen: Mythril emula la ejecución de un contrato, arregla las ramas a lo largo de las cuales puede ir la ejecución e intenta alcanzar un estado "roto" del contrato, clasificando varias combinaciones de parámetros e intentando sortear todas las rutas posibles.  Aquí hay un diagrama de acción de muestra del artículo anterior: </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p>  Si lo simplifica enormemente, Mythril, después de haber encontrado una rama en el código, puede entender bajo qué conjuntos de variables es posible ingresar en una y otra rama.  En cada rama, Mythril sabe si conduce a la <code>selfdestruct</code> <code>transfer</code> , <code>selfdestruct</code> y otros <code>selfdestruct</code> relevantes para la seguridad.  Por lo tanto, Mythril analiza qué conjuntos de parámetros y transacciones pueden conducir a una violación de seguridad.  Y la forma en que Mythril corta ramas que nunca obtienen control y analiza el flujo de control es su truco principal.  Aquí encontrará más detalles sobre el intestino Mythril y el andar de ramas. </p><br><p>  Debido a la naturaleza determinista de la ejecución de contratos inteligentes, la misma secuencia de instrucciones siempre conduce estrictamente a un conjunto de cambios de estado, independientemente de la plataforma, la arquitectura o el entorno.  Además, las funciones en los contratos inteligentes son bastante cortas y los recursos son extremadamente limitados, por lo tanto, los analizadores como Mythril, que combinan la ejecución simbólica y nativa, pueden funcionar de manera extremadamente eficiente para los contratos inteligentes. </p><br><p>  En el proceso, Mythril utiliza el concepto de "estado": este es el código del contrato, su entorno, un puntero al comando actual, el almacenamiento del contrato y el estado de la pila.  Aquí está la documentación: </p><br><pre> <code class="plaintext hljs">The machine state μ is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ∈ P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents μm are a series of zeroes of size 256.</code> </pre> <br><p>  El gráfico de transición entre estados es el principal objeto de estudio.  En caso de lanzamiento exitoso del análisis, la información sobre este gráfico se muestra en el registro de análisis.  Además, Mythril puede construir este gráfico en una forma legible por humanos usando la opción <code>--graph</code> . </p><br><p>  Ahora, más o menos entendiendo lo que hará Mythril, seguiremos entendiendo por qué el contrato no se analiza y de dónde proviene <code>[WARNING]: No contract was created during the execution of contract creation</code> .  Para comenzar, <code>--max-depth</code> <code>--create-timeout</code> y <code>--max-depth</code> (como se recomienda) y, al no obtener el resultado, pensé que el culpable era el constructor, algo que no funcionaba.  Aquí está su código: </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p>  Recordemos el algoritmo de acción de Mythril.  Para ejecutar el seguimiento, debe llamar al constructor del contrato, porque toda la ejecución posterior dependerá de los parámetros con los que se llamó al constructor.  Por ejemplo, si llama al constructor con <code>_price == 0</code> , el constructor lanzará una excepción en <code>require(_price &gt; 0)</code> .  Incluso si Mythril itera sobre los muchos valores de <code>_price</code> , el constructor aún se romperá si, por ejemplo, <code>_price &lt;= _cancellationFee</code> .  En este contrato, hay una docena de parámetros asociados con restricciones estrictas, y Mythril, por supuesto, no puede adivinar las combinaciones válidas de parámetros.  Intenta pasar a la siguiente rama de ejecución, clasificando los parámetros del constructor, pero prácticamente no tiene ninguna posibilidad de adivinar: hay demasiadas combinaciones de parámetros.  Por lo tanto, el cálculo del contrato no funciona: todas las formas se basan en algún tipo de <code>require(...)</code> , y obtenemos el problema anterior. </p><br><p>  Ahora tenemos dos formas: la primera es deshabilitar todos los <code>require</code> en el constructor al comentarlos.  Entonces Mythril podrá llamar al constructor con cualquier conjunto de parámetros y todo funcionará.  Pero esto significa que al examinar un contrato con tales parámetros, Mythril encontrará errores que son posibles con valores incorrectos pasados ​​al constructor.  En pocas palabras, si Mythril encuentra un error que surge si el creador del contrato especifica <code>_cancellationFee</code> mil millones de veces el precio de alquiler de <code>_mprice</code> , entonces no hay uso en dicho error: dicho contrato nunca se bloqueará y se <code>_mprice</code> recursos para encontrar errores.  Implicamos que el contrato todavía está atascado con parámetros más o menos consistentes, por lo que para un análisis posterior tiene sentido especificar parámetros de constructor más realistas para que Mythril no busque errores que nunca ocurrirán si el contrato se cierra correctamente. </p><br><p>  Pasé muchas horas tratando de entender exactamente dónde se rompe el despliegue, incluyendo e inhabilitando varias partes del constructor.  Además de mis problemas, el constructor usa <code>getCurrentTime()</code> , que devuelve la hora actual, y no está claro cómo maneja esta llamada Mythril.  No describiré estas aventuras aquí, porque  Lo más probable es que con el uso regular, estas sutilezas sean conocidas por el auditor.  Por lo tanto, elegí la segunda forma: para limitar los datos de entrada, y simplemente <code>getCurrentTime()</code> todos los parámetros del constructor, incluso <code>getCurrentTime()</code> , simplemente codifiqué los parámetros necesarios directamente en el constructor (idealmente, estos parámetros deben obtenerse del cliente): </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p>  Además, para que todo comience, también debe establecer el parámetro de <code>max-depth</code> .  Me funcionó con este constructor con <code>--max-depth=34</code> en la instancia de AWS t2.medium.  Al mismo tiempo, en mi computadora portátil, que es más potente, todo comienza sin ninguna <code>max-depth</code> .  A juzgar por el uso de este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parámetro</a> , es necesario construir ramas para el análisis, y su valor predeterminado es infinito ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código</a> ).  Por lo tanto, gire este parámetro, pero asegúrese de analizar el contrato deseado.  Puedes entender esto por mensajes como: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p>  La primera línea solo describe el gráfico que se analizará, lea el resto de las líneas usted mismo.  Se requieren recursos computacionales serios para analizar las diversas ramas que se pueden ejecutar, por lo que al analizar contratos grandes, tendrá que esperar incluso en una computadora rápida. </p><br><h2 id="poisk-oshibok">  <strong>Buscar errores</strong> </h2><br><p>  Ahora buscaremos errores y agregaremos los nuestros.  Mythril busca sucursales en las que se realizan transmisiones, autodestrucciones, afirmaciones y otras acciones que son importantes desde el punto de vista de la seguridad.  Si una de las instrucciones anteriores aparece en algún lugar del código del contrato, Mythril examina las formas en que es posible llegar a esta sucursal y, además, muestra la secuencia de transacciones que conducen a esta sucursal. </p><br><p>  Primero, veamos qué emitió Mythril para el prolongado contrato de <code>Booking</code> .  Primera advertencia: </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p>  y surge porque </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p>  en la función de reserva. </p><br><p>  Tenga en cuenta que Mythril se dio cuenta de que <code>getCurrentTime()</code> oculta en <code>getCurrentTime()</code> .  A pesar del hecho de que el significado del contrato no es un error, el hecho de que Mythril asocie <code>block.timestamp</code> con la transmisión es excelente.  En este caso, el programador debe comprender que la decisión se toma sobre la base del valor que el minero puede controlar.  Y, si en el futuro surge una subasta u otra subasta para un servicio en este lugar del contrato, se debe tener en cuenta la posibilidad de ataques de primera línea. </p><br><p>  Veamos si Mythril ve una dependencia en <code>block.timestamp</code> si <code>block.timestamp</code> la variable en una llamada anidada como esta: </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p>  Y si!  Mythril continúa viendo la conexión entre block.timestamp y la transferencia de transmisión, esto es extremadamente importante para el auditor.  La conexión entre la variable controlada por el atacante y la decisión tomada después de varios cambios en el estado del contrato puede estar muy enmascarada por la lógica, y Mythril le permite rastrearla.  Aunque no vale la pena confiar en el hecho de que todas las conexiones posibles entre todas las variables posibles serán <code>getCurrentTime()</code> por usted: si continúa burlándose de la función <code>getCurrentTime()</code> y realiza una triple profundidad de anidación, la advertencia desaparece.  Cada llamada a funciones para Mythril requiere la creación de nuevas ramas estatales, por lo que analizar niveles muy profundos de anidamiento requerirá enormes recursos. </p><br><p>  Existe, por supuesto, una posibilidad bastante seria de que simplemente use incorrectamente los parámetros de análisis o que el corte ocurra en algún lugar en las profundidades del analizador.  Como dije, el producto está en desarrollo activo, justo en el momento de escribir esto, veo compromisos en el repositorio con la mención de <code>max-depth</code> , por lo que no tome en serio los problemas actuales, ya hemos encontrado suficiente evidencia de que Mythril puede buscar muy efectivamente conexiones implícitas entre variables </p><br><p>  Primero, agregue al contrato una función que proporcione la transmisión a cualquier persona, pero solo después de que el cliente envíe la transmisión al contrato.  Permitimos que cualquiera recoja 1/5 del éter, pero solo cuando el contrato está en estado <code>State.PAID</code> Estado <code>State.PAID</code> (es decir, solo después de que el cliente haya pagado el número alquilado con el éter).  Aquí está la función: </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p>  Mythril encontró el problema: </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p>  Genial, es decir  Mythril incluso sacó dos transacciones, lo que lleva al hecho de que puede tomar éter del contrato.  Ahora cambie el requisito <code>State.RENT</code> a <code>State.RENT</code> , así: </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p>  Ahora se puede llamar a <code>collectTaxes()</code> solo cuando el contrato está en el <code>State.RENT</code> state, y en este momento no hay nada en el saldo, porque  El contrato ya ha enviado toda la transmisión al propietario.  ¡Y lo importante aquí es que Mythril esta vez <strong>NO</strong> genera el error <code>==== Unprotected Ether Withdrawal ====</code> !  Bajo la condición <code>onlyState(State.RENT)</code> , el analizador no llegó a la rama de código que envía el éter del contrato con un saldo distinto de cero.  Mythril pasó por diferentes opciones para los parámetros, pero puede ingresar a <code>State.RENT</code> solo enviando toda la transmisión al arrendador.  Por lo tanto, es imposible llegar a esta rama del código con un saldo distinto de cero, ¡y Mythril no molesta absolutamente al auditor! </p><br><p>  Del mismo modo, Mythril encontrará <code>selfdestruct</code> y <code>selfdestruct</code> , mostrando al auditor qué acciones pueden conducir a la destrucción del contrato o al colapso de una función importante.  No daré estos ejemplos, solo trato de hacer una función similar a la anterior, solo llamando a <code>selfdestruct</code> , y <code>selfdestruct</code> su lógica. </p><br><p>  Además, no olvide que una de las partes de Mythril es la ejecución simbólica, y este enfoque, por sí solo, sin emular la ejecución, puede determinar muchas vulnerabilidades.  Por ejemplo, cualquier uso de "+", "-" y otros operadores aritméticos puede considerarse una vulnerabilidad de "Desbordamiento de enteros" si el atacante controla de alguna manera uno de los operandos.  Pero repito nuevamente, la característica más poderosa de Mythril es la combinación de ejecución simbólica y nativa y la determinación de valores de parámetros que conducen a la ramificación lógica. </p><br><h2 id="zaklyuchenie">  <strong>Conclusión</strong> </h2><br><p>  Por supuesto, para mostrar la gama completa de problemas potenciales que Mythril es capaz de detectar, se necesitarán no solo uno, sino varios artículos.  Para todo lo demás, sabe cómo hacerlo todo en una cadena de bloques real, encontrando los contratos y vulnerabilidades necesarios mediante firmas, creando hermosos gráficos de llamadas, formateando informes.  Mythril también le permite escribir sus propios scripts de prueba, proporcionando una interfaz basada en python para el contrato y permitiéndole probar funciones individuales, corregir valores de parámetros o incluso implementar su propia estrategia para trabajar con código desmontado con un grado arbitrario de flexibilidad. </p><br><p>  Mythril sigue siendo un software bastante joven, este no es IDA Pro, y hay muy poca documentación, excepto algunos artículos.  El valor de muchos parámetros solo se puede leer en el código Mythril, comenzando con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cli.py.</a>  Espero que en la documentación aparezca una descripción completa y detallada del funcionamiento de cada parámetro. </p><br><p>  Además, cuando el contrato es más o menos grande, la producción de un montón de errores ocupa mucho espacio, pero me gustaría poder recibir información comprimida sobre el error encontrado, porque  cuando trabaje con Mythril, definitivamente debe mirar la ruta de análisis, ver qué contratos han sido probados de la mejor manera posible y ser capaz de desactivar por la fuerza errores específicos que el auditor considera falsos positivos. </p><br><p>  Pero en general, Mythril es una herramienta excelente y extremadamente poderosa para analizar contratos inteligentes y, por el momento, debe estar en el arsenal de cualquier auditor.  Le permite al menos prestar atención a las partes críticas del código y detectar relaciones ocultas entre variables. </p><br><p>  Para resumir, las recomendaciones para usar Mythril son: </p><br><ol><li>  Limite las condiciones de inicio del contrato en estudio tanto como sea posible.  Si durante el análisis Mythril gastará muchos recursos en sucursales que nunca se implementarán en la práctica, perderá la capacidad de encontrar errores realmente importantes, por lo que siempre debe tratar de reducir el área de sucursales potenciales. </li><li>  Asegúrese de que el análisis del contrato ha comenzado, no se pierda mensajes como <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> , de lo contrario puede considerar erróneamente que no hay errores. </li><li>  Puede deshabilitar arbitrariamente las sucursales en el código del contrato, dando a Mythril menos variación en la elección de sucursales y el ahorro de recursos.  Intente hacerlo sin restricciones en <code>max-depth</code> , para no "cortar" el análisis, pero tenga cuidado de no enmascarar el error. </li><li>  Preste atención a cada advertencia, incluso los comentarios ligeros a veces valen la pena al menos agregar un comentario al código del contrato, lo que facilita a otros desarrolladores. </li></ol><br><p>  En el próximo artículo, trataremos el analizador Manticore, pero aquí está la tabla de contenido para los artículos que están listos o planeados para su escritura: </p><br><p>  Parte 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducción.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilación, aplanamiento, versiones de Solidity</a> <br>  Parte 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Slither</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Mythril (este artículo) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4. Manticore (durante la escritura) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 5. Echidna (durante la escritura)</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442114/">https://habr.com/ru/post/442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442102/index.html">A la cuestión de las baterías</a></li>
<li><a href="../442104/index.html">Guía del usuario de Kibana. Visualización. Parte 5</a></li>
<li><a href="../442108/index.html">Guía para desarrolladores para crear aplicaciones de IA</a></li>
<li><a href="../442110/index.html">Antipatterns Vim</a></li>
<li><a href="../442112/index.html">Nuevos lenguajes de programación matan silenciosamente nuestra conexión con la realidad</a></li>
<li><a href="../442116/index.html">Mejora de la funcionalidad del componente React con React.memo ()</a></li>
<li><a href="../442118/index.html">El grupo minero de Coinhive deja de funcionar</a></li>
<li><a href="../442120/index.html">Capacitación de modelos TensorFlow con el Servicio Azure Machine Learning</a></li>
<li><a href="../442122/index.html">Un simple señor moscovita: una entrevista con el creador de Duke Nukem</a></li>
<li><a href="../442124/index.html">Facebook dará a los usuarios la oportunidad de limpiar su historia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>