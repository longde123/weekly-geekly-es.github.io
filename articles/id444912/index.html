<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’º â™»ï¸ ğŸ¥• Kontrol LCD F-51543NFU-LW-ADN / PWB51543C-2-V0 (dari perpustakaan tape) âœ‰ï¸ ğŸœ ğŸ‘©â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo lagi, Habr! Setelah menerjemahkan artikel tentang mengelola modul LCD dengan driver, tetapi tanpa RAM video saya sendiri, saya memutuskan untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontrol LCD F-51543NFU-LW-ADN / PWB51543C-2-V0 (dari perpustakaan tape)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444912/"><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Halo lagi, Habr!  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerjemahkan</a> artikel tentang mengelola modul LCD dengan driver, tetapi tanpa RAM video saya sendiri, saya memutuskan untuk menerjemahkan publikasi lain dengan topik yang sama.  Di sini modul sudah lebih sederhana, monokrom, tetapi untuk "menghidupkan kembali" itu tidak kalah menarik. <a name="habracut"></a><br><br><h1>  Kontrol LCD dengan driver, tetapi tanpa pengontrol </h1><br>  Tampilan yang penulis akan kerjakan diambil dari perpustakaan tape lama.  Kontroler tidak bertahan, tetapi pencarian untuk apa pun yang terkait dengan "263645-001" menunjukkan bahwa ada FPGA.  Diyakini bahwa secara langsung mengontrol modul-modul LCD dari Arduino, dll.  Tidak mungkin, Anda memerlukan tautan perantara - pengontrol seri SEDxxxxx, yang tidak â€œbertemanâ€ dengan papan tempat memotong roti, dan memiliki lebih banyak input daripada modul itu sendiri.  Tapi ini tidak benar.  Berikut adalah sebanyak empat proyek serupa: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di ATmega8515</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di atasnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di foto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pada ESP32</a> <br><br>  Dan beberapa monitor VGA AVR delapan bit yang umumnya ... <br><br>  Secara umum, penulis berhasil, perangkat lunak di bawah lisensi MIT ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h1>  Gambar diam </h1><br>  Untuk memastikan semuanya bekerja, pertama-tama Anda harus mencoba mengeluarkan gambar raster bit tunggal dari memori flash mikrokontroler.  Untuk mendapatkan tegangan negatif, diambil tiga "Crones", tegangan dari pembagi diterapkan ke pin V0, yang digunakan sebagai resistor tuning.  Dan di sini di layar adalah Lenna: <br><br><img src="https://habrastorage.org/webt/yb/7-/fg/yb7-fgxw6yf64l_ylhqaccnhq-g.jpeg"><br><br>  Penulis masih tidak mengerti bagaimana ia berhasil membalik gambar (lihat di sisi mana kabelnya).  Bagaimanapun, ada contoh ini di halaman proyek di GitHub. <br><br><h1>  Mode teks </h1><br>  Tetapi ROM video tidak banyak digunakan, dan tidak ada 9600 byte untuk RAM video di Arduino.  Mode teks datang untuk menyelamatkan, di mana ROM dari generator karakter dan RAM video yang digabungkan memiliki volume kurang dari RAM video dalam mode grafis.  Pendukung Republik Kazakhstan dan "Spesialis" dapat mematahkan tombak tanpa henti mengenai hal ini. <br><br><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Contoh singkat dalam bahasa rakitan AVR: <br><br><pre><code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br><h1>  Perangkat Keras yang Diperlukan </h1><br><img src="https://habrastorage.org/webt/85/p_/52/85p_52apzq0nmbzcnde9vaphrxy.jpeg"><br><br>  Untuk modul F-51543NFU-LW-ADN / PWB51543C-2-V0, penulis menerapkan: <br><br>  Arduino pada AVR dengan frekuensi clock 16 MHz (diuji pada Uno, Leonardo dan klon yang mirip dengan ProMicro). <br><br>  Sumber tegangan negatif.  Bagi penulis, ini adalah konverter DC-DC A0524S-1W yang tidak distabilkan dengan isolasi input dan output.  Konverter untuk MC34063 juga cocok (chip ini sangat mudah ditemukan - cukup bongkar pengisian USB termurah untuk pemantik rokok) atau MAX749.  Stabilisasi tidak diperlukan, kisaran voltase yang diperbolehkan pada input ini untuk modul yang digunakan di sini cukup lebar.  Nilai nominalnya minus 24 V, maksimum minus 30 relatif terhadap kawat biasa dan 35 antara Vdd dan Vee.  Konsumsi saat ini adalah 6 mA. <br><br>  Dua N-channel MOS transistor dengan kontrol level logika.  Penulis menggunakan IRL530n, stok, tentu saja, besar, tetapi tentu saja tidak akan habis.  Satu transistor mengendalikan cahaya latar, yang lain sumber tegangan negatif. <br><br>  250 kÎ© resistor pemangkasan untuk memasok tegangan ke input V0.  Atur agar -16.8 V pada suhu +25 Â° C pada kontak yang dapat dipindahkan.  Ini dari datasheet, dan tentu saja akurasi seperti itu tidak diperlukan. <br><br>  Beberapa resistor 10-kilo untuk ditarik. <br><br>  Tata letak dan jumper. <br><br>  Apa yang akan kamu lakukan sekarang?  Menonton QR?  Tanyakan kote: <br><br><img src="https://habrastorage.org/webt/lw/yv/qp/lwyvqp84jo4uvj5byzropcuzf7k.jpeg"><br><br>  Kote menawarkan untuk mengimplementasikan simulasi beberapa LCD umum dengan pengontrol.  Sehingga "pemikiran" lain yang berfungsi dengan tampilan pada HD44780, hanya besar, dapat dihubungkan ke Arduino ini. <br><br><h1>  Font - juga dalam RAM </h1><br>  Kami mengambil contoh dengan EGA dan VGA - di sana, ketika bekerja dalam mode teks, itu dilakukan begitu saja.  Hanya di sini ada total 64 karakter, tetapi setidaknya semuanya masuk ke dalam RAM, tidak seperti mode grafis.  Benar, siklus utama acara telah melambat, tetapi Anda dapat mencoba ubin grafik: <br><br><img src="https://habrastorage.org/webt/ie/5w/qa/ie5wqaezqkvosxnzrjhvu3bzpaa.jpeg"><br><br><h1>  Mode grafis dan halftone </h1><br>  Di Arduino pada AVR tidak ada begitu banyak RAM, dan itu intinya.  Bahkan di Mega.  320x240 bahkan dengan satu bit per piksel - ini sudah 9600 byte.  Hanya empat halftone yang akan membutuhkan dua kali lebih banyak.  Dengan RAM eksternal, misalnya, 23LC512 dalam mode SQI, Anda dapat mencoba menerapkan sesuatu yang mirip dengan DMA, tetapi lebih mudah dan lebih menguntungkan untuk membuat kembali semuanya di ESP32, di mana ada lebih banyak RAM statis dan DMA lebih mudah. <br><br>  Jika Anda hanya ingin menghubungkan layar seperti itu ke PC melalui USB, Anda dapat mencoba menggunakan ATmega32u4 untuk ini - akan ada sumber daya yang cukup bahkan untuk gradasi kecerahan (menggunakan FRC, seperti yang dijelaskan dalam terjemahan saya sebelumnya).  Tetapi tidak dengan "mega" yang digunakan sebagai konverter antarmuka, tetapi dengan PC yang akan memindai LCD dengan cepat dengan kecepatan 5,4 megabit per detik. <br><br>  Ketika modul masih berdiri di perpustakaan tape, ada GUI dan gradasi kecerahan - semuanya ada di sana. <br><br>  Pembaruan akan dilakukan.  Sementara itu ... <br><br><img src="https://habrastorage.org/webt/9z/cu/p9/9zcup9llwkpyuzyzxky3wghu_hs.jpeg"><br><br>  Dan ini bukan montase foto, tetapi hasil kontrol dari PC.  Dan kami akan beralih dari Hackaday.io ke GitHub - masih ada banyak hal menarik di README.md. <br><br><h1>  Sinyal untuk mengendalikan modul tersebut </h1><br>  FLM - First Line Marker - penanda baris pertama, dapat juga disebut FRAME, VSYNC, dll. <br>  CL1 - Row latch pulse - write string pulse, juga bisa disebut.  LOAD, HSYNC, dll. <br>  CL2 - Pixel shift clock - pixel change pulse, juga bisa disebut.  CP (ubah piksel), dll. <br>  M - sinyal bolak-balik, karena piksel dikendalikan oleh tegangan bolak-balik, dapat juga disebut BIAS (offset), dll. <br><br>  D0-D3 adalah bus data paralel empat-bit. <br><br>  Memimpin untuk kawat biasa, daya lampu latar (mis. VLED Â±), daya modul (VEE dan V0) <br><br>  Jangan abaikan lembar data.  Modul ini mungkin memerlukan voltase negatif lain, atau mungkin berubah menjadi positif, atau konverter mungkin built-in.  Logikanya mungkin berbeda, misalnya, dengan unit pada CL1 tidak akan ada reaksi pada CL2.  Mungkin ada lampu latar yang berbeda (CCFL (hati-hati, inverter adalah "gigitan"), bukan LED, atau tidak ada pinout di papan, maka Anda tidak akan mengetahuinya tanpa lembar data.  Anda tidak dapat menghubungkan apa pun secara acak. <br><br><h1>  Apa yang harus dilakukan </h1><br>  Mengirimkan string dalam potongan-potongan empat bit, rekaman dilakukan pada penurunan pada garis CL2.  Setelah melewati garis, tuliskan resesi pada garis CL1 (yeah, setelah semua, sedikit RAM dalam modul ada di satu baris).  Baris berikutnya akan dipilih secara otomatis.  Setelah mentransmisikan seluruh frame, kembali ke awal menggunakan sinyal FLM.  Dalam lembar data di LC79401 ada contoh.  Rekam dengan kecepatan yang cukup, berikan pulsa ke CL1 secara merata.  Kontrolernya sedikit ragu - layar berkedip jelek. <br><br>  Setelah setiap frame, ubah level logika pada input M ke kebalikan, sehingga piksel dikontrol oleh tegangan bolak-balik.  Jika tidak, tampilan akan menurun: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZP0KxZl5N2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Anda tidak dapat mempercayai operasi ini ke mikrokontroler, tetapi letakkan pemicu yang dapat dihitung.  Pintu masuk ke FLM, keluar ke M - secara umum, bisa dimengerti. <br><br>  Contoh untuk mengeluarkan gambar dari memori flash (lihat bagian awal artikel) disebut clglcd_simple dalam repositori ini. <br><br>  Seperti yang telah disebutkan, tidak mungkin untuk melakukan hal yang sama dengan RAM di Arduino pada AVR - itu tidak akan cukup, oleh karena itu ... <br><br><h1>  Dan lagi - mode teks </h1><br>  Menurut datasheet, Anda dapat mengirimkan data pada bus empat-bit dan "menarik" CL2 dengan frekuensi hingga 6 MHz.  Oleh karena itu, Anda dapat dengan cepat dan cepat mentransfer saluran, kemudian mikrokontroler sedikit menyelesaikan tugas-tugas lain, dan ketika timer "mengatakan" itu, itu "menarik" CL1 dan mengulangi siklus. <br><br>  Saat menghasilkan karakter untuk resolusi horizontal 320 piksel, semua ini dapat dilakukan dalam 20 Î¼s (320 piksel / 4 bit = 80 pulsa, CL2 "ditarik" dengan frekuensi 4 MHz).  Untuk tugas yang tersisa, 39,5 Î¼s tetap.  CL1 â€œbrengsekâ€ setiap 59,5 Î¼s dan dapatkan frame rate 70 Hz.  Nah, akan ada lebih banyak prosedur untuk menangani gangguan dan sebagainya, secara umum, mikrokontroler akan sibuk mengendalikan tampilan 45% dari waktu.  "Seluruh" 45 atau "total" 45?  Mungkin yang kedua: menimpa data dalam RAM video bisa cukup cepat. <br><br>  Apakah Anda ingin mikrokontroler menghabiskan lebih sedikit waktu mengelola indikator, dan lebih banyak pada tugas-tugas lain?  Anda dapat mengurangi frame rate hingga 50 Hz, Anda dapat meng-overclock mikrokontroler hingga 20 MHz.  Dengan salah satu metode ini, lebih banyak siklus jam akan terjadi di antara rutinitas interupsi. <br><br>  Pengukur waktu perbandingan keluaran mengganti saluran CL2 setiap empat jam pulsa dengan siklus kerja 50%.  Pada saat yang sama, data tiba pada output port PORTB, terhubung ke bus data empat-bit modul sedemikian rupa sehingga mereka berubah pada saat tingkat naik ke CL2, dan pada saat resesi mereka tetap tidak berubah.  Tentu saja, ini tidak dapat dilakukan tanpa assembler: <br><br><pre> <code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br>  8 siklus - dan empat camilan ditransmisikan.  Dan apa yang harus ditransmisikan tergantung pada simbol mana yang ada dalam sel RAM video yang sesuai, piksel mana yang sesuai dengan simbol ini yang harus ditransfer dari ROM pembangkit karakter, dan apa yang disimpan dalam sel yang sesuai dari ROM ini. <br><br>  Hal yang paling tidak nyaman di sini adalah kebutuhan untuk menghentikan timer setelah tepat 80 pulsa.  Beberapa penghitung waktu, seperti Timer4 dalam 32u4, tidak bisa. <br><br>  Untuk mendapatkan sinyal yang dipasok ke saluran CL1, penulis menerapkan output mikrokontroler yang berbeda, yang dimaksudkan untuk timer dan untuk PWM cepat.  Yang mana dari ini diterapkan di sini bisa dimengerti.  Switch setiap 952 langkah.  Atau jika Anda menghitung setelah pembagi jam dengan 8 - ternyata setiap 119 pulsa.  Pada titik ini, rutinitas pemrosesan interupsi dimulai dan memaksa mikrokontroler untuk mengirimkan data baru ke jalur kontrol yang akan diperlukan selama pulsa berikutnya ke CL1.  Nah, level pada garis M berubah dengan setengah frekuensi.  Dan LCD tidak memburuk.  Semua sinyal bersama terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/yt/_0/dh/yt_0dhpk4km7w-yml5spdz5ukl8.png"><br><br>  Generator karakter terdiri dari 256 karakter - cukup untuk 866, KOI-8R atau 1251. 40xN karakter ditempatkan dalam RAM video, di mana N adalah jumlah garis tergantung pada ketinggian karakter.  Lebar simbol selalu 8 piksel, dan tingginya bisa 6, 8, 10, 12, 15, 16. Semakin kecil, semakin sedikit ROM yang diperlukan untuk generator karakter dan lebih banyak RAM video.  Dengan font 8x8 (40 karakter per 30 baris), Anda memerlukan 1200 byte RAM dan 2048 byte ROM.  Dengan font 8x16 (terlihat paling baik di modul ini), RAM membutuhkan 600 byte, dan ROM 4096. Dari penerjemah: Anda dapat menyimpan font dalam bentuk 8x8, dan skala secara vertikal dua kali dengan perangkat lunak, dan biaya 600 byte RAM dan 2048 ROM.  Untuk menyimpan beberapa font dalam ROM, Anda perlu menjaga agar alamat font mulai tidak dalam konstanta, tetapi dalam variabel, tetapi itu tidak akan berfungsi untuk mencetak teks dalam beberapa font sekaligus, kecuali, tentu saja, Anda mengubah alamat ini dengan cepat oleh prosedur pemrosesan interupsi secara langsung selama mentransfer piksel ke layar. <br><br>  Font disimpan seperti ini: pertama baris teratas dari semua 256 karakter, kemudian satu baris di bawah ini, dan seterusnya.  Ada skrip Python di folder misc repositori yang secara otomatis mengubah font TTF ke file header clglcd_font.h dengan array PROGMEM dalam format yang diperlukan.  Font piksel klasik untuk CC-BY-SA 4.0 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h1>  Dan lagi - ambil contoh dengan EGA dan VGA </h1><br>  Tapi kali ini dengan detail.  Generator karakter dalam RAM, seperti yang ditunjukkan di atas, mengandung total 64 karakter, mereka dapat diidentifikasi dengan angka dari 0 hingga n atau dari 255-n hingga 255. Mereka disimpan dengan cara yang sama: baris teratas semua karakter, kemudian yang berikut, dan seterusnya.  Hanya semua ini yang selaras dengan mempertimbangkan fakta bahwa karakter tidak 256, tetapi 64. Untuk karakter dengan ukuran 8x16 piksel, diperlukan 16 * 64 = 1024 byte.  Repositori memiliki contoh bekerja dengan generator karakter dalam RAM. <br><br>  Jika kedua generator karakter digunakan pada saat yang sama - 256-karakter dalam ROM dan 64-karakter dalam RAM, Anda harus menerima bahwa tidak hanya akan ada lebih sedikit RAM, tetapi juga kecepatan transfer data dari garis-garis dalam modul akan berkurang - bukannya 8 siklus clock, dua camilan akan membutuhkan 12, yaitu, bukan 20 mikrodetik, tetapi 30, dan alih-alih 45% dari waktu untuk kontrol LCD, dibutuhkan 60. <br><br><h1>  Mode Grafika Halftone </h1><br>  Seperti yang ditunjukkan di atas, dalam hal ini, mikrokontroler hanya berfungsi sebagai konverter antarmuka.  Anda akan membutuhkan ATmega32u4, dan apa yang harus dilakukan dijelaskan di <a href="">sini</a> .  Harap dicatat bahwa modul dapat menjadi rusak karena program dibekukan pada PC. <br><br>  Jadi apa loop empat-kawat ini - dari sensor resistif, ternyata. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mMqvBnYOjEQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Di mana harus terhubung </h1><br>  Seperti ditunjukkan di atas, diperlukan tegangan negatif, yang pada percobaan pertama dapat dilepas dari tiga "Crones", dan kemudian merakit konverter, misalnya, pada MAX749.  Sinyal kontrol daya, serta sinyal DISPOFF (ini adalah sinyal terbalik, modul dihidupkan sekaligus), menarik resistor ke bawah.  Selama flashing dan reset mikrokontroler, tampilan unit logis tidak dapat diterima. <br><br>  Terapkan tegangan negatif setelah tegangan + 5V, dan unit logis ke jalur DISPOFF - ketika data sudah ada di jalur kontrol: setidaknya satu unit di bus data, unit di CL1.  Jika tidak, modul mungkin gagal. <br><br>  Input D0-D3 dapat dihubungkan ke output dari port yang sama dari mikrokontroler, misalnya, Px4-Px7, sedangkan output Px0-Px3 tidak dapat digunakan sebagai GPIO.  Anda dapat menetapkan fungsi-fungsi lain kepada mereka, misalnya, menggunakannya sebagai output penghitung waktu, antarmuka serial, dll.  Jika Anda menggunakannya sebagai input, berhati-hatilah: resistor pull-in built-in dapat beralih secara sewenang-wenang jika tidak dinonaktifkan (PUD - pull-up disable). <br><br>  Input M - ke output dari timer perbandingan atau PWM. <br><br>  Input CL1 - ke output lain dari timer yang sama. <br><br>  Input CL2 - ke output timer perbandingan lain. <br><br>  FLM - ke keluaran digital apa pun. <br><br>  DISPOFF - ke output digital lainnya. <br><br>  Sisanya tergantung pada bagaimana Anda menyalakan modul.  Penulis lebih suka mengontrol lampu latar dan Vee secara terpisah. <br><br><h1>  Cara menggunakan firmware </h1><br>  Masukkan file clglcd.h dan clglcd.cpp ke dalam sketsa <br><br>  Buat salinan cadangan dari file clglcd_config.h dan edit dengan mempertimbangkan apa yang terhubung, serta fungsi apa yang Anda butuhkan: generator karakter dalam RAM, dll.  Perhatian, kode tidak menunjukkan nama pin Arduino, tetapi nama pin mikrokontroler sesuai dengan lembar data.  Nama-nama output tamers perbandingan diuraikan sebagai berikut: misalnya, 2, B adalah OC2B, yang pada Arduino Uno sesuai dengan PD3.  Contoh-contoh menunjukkan opsi koneksi yang telah diperoleh oleh penulis. <br><br>  Hasilkan file font clglcd_font.h dengan skrip Python di folder misc (lihat di atas). <br><br>  Lihat dalam contoh cara menginisialisasi, menghidupkan dan mematikan layar.  Masukkan array layar teks yang ingin Anda tampilkan untuk verifikasi. <br><br>  Kompilasi dan isi sketsa.  Periksa dengan penganalisis logika bahwa sinyal yang benar akan ditampilkan, dan dengan voltmeter semua voltase pasokan normal.  Hanya dengan demikian sambungkan display. <br><br>  Tambahkan kode ke sketsa yang akan melakukan sesuatu, misalnya, menerima teks pada port serial dan menampilkannya. <br><br><h1>  Gangguan tampilan </h1><br>  Layar perlu diperbarui terus-menerus, itulah yang dilakukan prosedur penanganan interupsi.  Jika interupsi berhenti selama lebih dari 30 mikrodetik, layar akan berkedip, dan jika lebih dari 60 mikrodetik untuk unit di jalur FLM, mungkin gagal.  Jika Anda perlu menghentikan interupsi untuk waktu yang lama, matikan layar terlebih dahulu dengan sinyal DISPOFF (saya ulangi, ini adalah sinyal terbalik, modul dihidupkan satu).  Tentu saja, jika mati selama dua detik setiap kali Anda perlu memproses data dari sensor kelembaban dan suhu, beberapa akan menyukainya, tetapi lebih baik daripada merusak modul.  Lebih baik lagi, isi daya sisanya ke mikrokontroler terpisah.  Pertukaran informasi oleh mikrokontroler yang sama dengan perangkat yang beroperasi pada protokol 1-kawat dan LED alamat sangat tidak dapat diterima.  Arduino Pro Micro klon cukup murah untuk membeli dua. <br><br><h1>  Komunikasi </h1><br>  Tetapi antarmuka yang diimplementasikan perangkat keras akan bekerja dengan sempurna: port serial, I <sup>2</sup> C bus, SPI dalam mode master.  Dalam slave - hanya jika master memungkinkan "roll-off" berkala dari slave dengan 25-35 Î¼s.  Tentu saja, itu masih tergantung pada berapa banyak "kaki" yang tersisa setelah menghubungkan layar. <br><br>  USB pada 32u4 berfungsi dengan baik jika Anda tidak terlalu sering menginterogasi titik akhir manajemen (kode rutin interupsi lambat).  Pengandar CDC dan API-nya cukup cepat. <br><br>  Kemudian dalam file README.md di GitHub daftar proyek serupa diulang, sama seperti pada halaman proyek di Hackaday.io <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444912/">https://habr.com/ru/post/id444912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444902/index.html">Optimalisasi desain dengan metode teori kontrol otomatis</a></li>
<li><a href="../id444904/index.html">Mengambil Kata Sandi Utama dari Manajer Kata Kunci Terkunci SafeInCloud</a></li>
<li><a href="../id444906/index.html">Baca sampah</a></li>
<li><a href="../id444908/index.html">Tempat menumbuhkan smartphone</a></li>
<li><a href="../id444910/index.html">Stimulasi suara dan cahaya membantu mengatasi Alzheimer, pada tikus, tetapi hasilnya menggembirakan</a></li>
<li><a href="../id444916/index.html">Tidak membeli DLC: fungsi yang akan menyelamatkan 737 yang jatuh, Boeing dijual sebagai opsi</a></li>
<li><a href="../id444918/index.html">Di mana smartphone tumbuh: peta jalan untuk menjadi komputer yang lengkap</a></li>
<li><a href="../id444920/index.html">Algoritma baru ini mempercepat 200 kali desain otomatis jaringan saraf</a></li>
<li><a href="../id444922/index.html">Bagaimana melindungi diri Anda dari hypnovirus</a></li>
<li><a href="../id444924/index.html">WIAD pertama di Moskow: bagaimana kelanjutannya dan apa yang mereka bicarakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>