<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👚 🙇 🥝 Un ejemplo de cálculo de la reacción de la señal utilizando la transformada de Fourier en MATLAB 👱🏿 😮 🤱🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al resolver los problemas de transmisión de datos a través de líneas representadas por características de frecuencia, se aplican transformadas de Four...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un ejemplo de cálculo de la reacción de la señal utilizando la transformada de Fourier en MATLAB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416497/">  Al resolver los problemas de transmisión de datos a través de líneas representadas por características de frecuencia, se aplican transformadas de Fourier: la transferencia de señales del dominio del tiempo al dominio de la frecuencia y viceversa.  El entorno MATLAB tiene un conjunto completo de funciones para resolver tales problemas.  En este trabajo, se analiza un ejemplo de cálculo en MATLAB de la reacción de una señal transmitida a través de una línea cuya característica se mide a frecuencias que no coinciden con la frecuencia de transferencia de datos.  Espero que este ejemplo facilite la comprensión de las características de la tecnología de conversión de señal en el entorno MATLAB. <br><br><h3>  Condición de la tarea </h3><br>  Es necesario determinar el cambio en la forma de la señal digital binaria que pasa a través del filtro y la línea de señal.  La señal se establece por la amplitud y la velocidad de transmisión.  El filtro de segundo orden, normalizado a la frecuencia de transferencia de datos, se establece mediante constantes de tiempo.  La función de transferencia de la línea de señal está representada por la respuesta de frecuencia medida en forma compleja. <br><br>  El entorno utilizado para calcular y mostrar datos es MATLAB R2015a. <br>  Las siguientes relaciones publicadas en el sitio web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.StatEye.org</a> para la versión del método GUI StatEye 3.0 [1, 2, 3] se tomaron como un ejemplo de los datos iniciales. <br><br>  Velocidad de datos bps = 10.3125 Gbit / s.  Las constantes de tiempo del filtro de segundo orden normalizado son las mismas; su recíproco es ¾ de la frecuencia de transmisión de datos.  La línea de señal está representada por una respuesta de frecuencia.  La característica se midió en el canal f = 0.006495: 0.0012475: 20 GHz.  El número especificado de puntos de muestreo de la transformada de Fourier: puntos = 2 ^ 13. <br><a name="habracut"></a><br>  La Figura 1 muestra los resultados de transferencia de datos, secuencia y procesamiento de datos discutidos en este documento.  La transición del dominio del tiempo al dominio de la frecuencia y viceversa se realiza utilizando el algoritmo de Transformación rápida de Fourier (FFT). <br><img src="https://habrastorage.org/webt/ex/c8/fw/exc8fwf3_bfcnnczjnoo_qdj43q.png" alt="imagen"><br>  <i>Figura 1. Canal de datos.</i>  <i>Señal de entrada iSignal.Tx, señal de salida del filtro iSignal.Filter_out, línea de señal de salida iSignal.Rx.</i>  <i>Las características que se muestran en el diagrama se analizan a continuación.</i> <br><br><h3>  Secuencia de cálculo </h3><br>  En este trabajo, los cálculos principales se realizan en el dominio de la frecuencia.  Para esto, la señal original del dominio del tiempo se transfirió al dominio de la frecuencia utilizando la transformada de Fourier, al multiplicar las características espectrales de la señal, el filtro y la línea de señal, se encontró la señal de salida de la ruta, que se transfiere del dominio de la frecuencia al dominio del tiempo por la transformada inversa de Fourier. <br><br>  La velocidad de transferencia de datos es dos veces mayor que la frecuencia a la que se transmiten los datos.  La frecuencia máxima de la línea de señal medida máx. (Canal f) = 20 GHz.  A esta frecuencia, los datos pueden transmitirse a una velocidad de 40 Gbit / s (como 2 * máx. (Canal f)). <br><br>  La velocidad máxima de transferencia de datos, que no excede la velocidad máxima de transmisión en la línea de señal de 40 Gbit / sy una velocidad de transmisión múltiple de bps = 10.3125 Gbit / s, es fmax = 30.9375 Gbit / s, la multiplicidad N = 3 (N = fmax / bps).  Además, fmax se usa como la frecuencia límite para calcular la respuesta de la señal usando la transformada de Fourier. <br><br><h3>  Traducción de la señal de entrada al dominio de frecuencia </h3><br>  Discreción de tiempo para construir la señal de entrada (bit de datos) en el dominio de tiempo Ts = 1 / fmax;  Ts = 3.232e-11 s.  Normalizada con respecto a la duración de la señal, la escala de tiempo consta de 2 ^ 13 puntos (puntos), la escala incluye la siguiente matriz de puntos tiempo = bps / Ts. * (1: puntos).  Una señal única discreta a una velocidad de transmisión de bps = 10.3125 Gbit / sy la cuantificación con un período Ts = 1 / fmax consta de tres puntos en el rango de 10 a 11 unidades de tiempo normalizado.  Se puede construir una señal de amplitud de unidad en cualquier otro lugar de la línea de tiempo, pero es mejor retroceder desde los bordes para ver completamente el fondo y el proceso de transición de la señal de salida.  En la Figura 2 se muestra una señal de pulso (bit de datos) construida con los siguientes comandos de MATLAB. <br><br><pre><code class="matlab hljs">iSignal.Tx(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(time,<span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>; t0 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>)); t1 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>)); iSignal.Tx(t0:t1) = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/qf/df/ec/qfdfec6aehsjzwgjgenqazdh82y.png" alt="imagen"><br>  <i>Figura 2. Señal de pulso de entrada iSignal.Tx, bit de datos.</i> <br><br>  La traducción de la señal iSignal.Tx al dominio de frecuencia se realiza mediante las siguientes funciones FFT. <br><br><pre> <code class="matlab hljs">iSignal.shiftedPSD = fft(iSignal.Tx); iSignal.PSD = fftshift(iSignal.shiftedPSD);</code> </pre> <br>  La función de transformación de Fourier fft construye un espectro simétrico de la señal en las regiones de frecuencias positivas y negativas, cuya frecuencia máxima está en el centro del espectro (ver Figura 3).  La función fftshift restaura el espectro desplazando hacia el centro la frecuencia cero de la señal como se muestra en la Figura 4. <br><br>  La resolución de la frecuencia del espectro es fs = fmax / puntos;  Las frecuencias del espectro varían de -fmax / 2 a fmax / 2-fs y son iguales a f = -fmax / 2: fs: fmax / 2-fs; <br><br><img src="https://habrastorage.org/webt/ho/8s/sb/ho8ssbopxofj9awqb5rudr9i4ks.png" alt="imagen"><br>  <i>Figura 3. Respuesta de amplitud del espectro desplazado de la señal iSignal.Tx obtenida utilizando la FFT.</i> <br><br><img src="https://habrastorage.org/webt/gr/hn/lc/grhnlcgd4yp6lhei-wwiqw_ui0c.png" alt="imagen"><br>  <i>Figura 4. Respuesta de amplitud del espectro reconstruido de la señal iSignal.Tx que se muestra en la Figura 3. Se presentan 2 ^ 13 muestras.</i>  <i>El recuento promedio en 4097 corresponde a la frecuencia cero.</i>  <i>Las frecuencias negativas se encuentran en el lado izquierdo (de 1 a 4096 puntos), y la región de frecuencias positivas en el lado derecho (de 4098 a 8192 puntos).</i> <br><br><h3>  Función de transferencia del filtro de paso bajo normalizado </h3><br>  En este ejemplo, la función de transferencia del filtro de segundo orden tiene la forma <br><br><img src="https://habrastorage.org/webt/bz/ov/pt/bzovptea80xq-lyjjgayndllj98.png" alt="imagen"><br>  donde T1 y T2 son constantes de tiempo de filtro.  Las frecuencias 1 / T1 son iguales y 1 / T2 se establecen en relación con la frecuencia a la que se transmiten los datos: 1 / T1 = 1 / T2 = 0.75 * bps (bps = 10.3125 Gbit / s). <br><br>  Ancho de banda de filtro normalizado <br><br><pre> <code class="matlab hljs">f_nrm =fmax/bps/points.*(-points/<span class="hljs-number"><span class="hljs-number">2</span></span>:points/<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>).</code> </pre> <br>  Operador <br><br><pre> <code class="matlab hljs">s = f_nrm .* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>;</code> </pre> <br>  La característica de amplitud-fase del filtro normalizado para frecuencias positivas y negativas normalizadas con respecto a la frecuencia de transmisión de señal se muestra en la Figura 5. La característica de frecuencia de amplitud logarítmica del filtro se muestra en la Figura 6. <br><br><img src="https://habrastorage.org/webt/ct/32/rj/ct32rjkglsoalv2s9lq9sdc41xy.png" alt="imagen"><br>  <i>Figura 5. La característica de fase de amplitud de un filtro normalizado.</i> <br><br><img src="https://habrastorage.org/webt/fa/zp/x5/fazpx5t-iptrisubkndxs-aizes.png" alt="imagen"><br>  <i>Figura 6. Respuesta de frecuencia de fase de amplitud logarítmica de un filtro normalizado.</i>  <i>La línea discontinua azul muestra la posición de la frecuencia del filtro con un valor de 0,75 de la frecuencia a la que se transmiten los datos.</i>  <i>A esta frecuencia (1 / T1 = 1 / T2), el coeficiente de transmisión del filtro de segundo orden es -6 decibelios.</i>  <i>La línea roja discontinua indica la frecuencia de la unidad a la que se transmiten los datos.</i> <br><br><h3>  Traducción de los resultados de medición de la línea de señal al tipo de función de transferencia </h3><br>  La característica de fase de amplitud medida de la línea de señal incluye 1599 muestras en la banda de hasta 20 GHz con un paso fijo de 12.475 MHz.  Contiene los siguientes valores de frecuencia: channel.f = 0.006495: 0.0012475: 20 GHz.  Inicialmente, la línea de señal estaba representada por una característica de cuatro terminales.  Esta característica se ha transformado y se utiliza en el ejemplo como una función compleja unidimensional. <br><br>  Las frecuencias características de la línea de señal obtenidas como resultado de la medición no coinciden con las frecuencias del espectro de señal de entrada que son múltiplos de la frecuencia de transmisión de datos.  Además, el espectro de la línea de señal contiene solo frecuencias positivas y no contiene frecuencias en la región cero.  El espectro de la señal de entrada contiene frecuencias positivas, cero y negativas. <br>  Para convertir las características de la línea de señal en una función de transferencia, una característica cuyas frecuencias coinciden con las frecuencias del espectro de la señal de entrada, se siguen los siguientes pasos. <br><br>  1. El cálculo de la amplitud de las características de la línea a frecuencia cero mediante su extrapolación.  Para esto, a partir de diez puntos de la característica de amplitud más cercana a la frecuencia cero, se encuentran los coeficientes de un polinomio lineal que se aproximan a la característica de amplitud: <br><br><pre> <code class="matlab hljs">[a] = polyfit(channel.f(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  El segundo coeficiente polinómico encontrado es igual a la amplitud de la característica a frecuencia cero: <br><br><pre> <code class="matlab hljs">channel.dc = a(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  2. La respuesta de fase a frecuencia cero se toma igual a cero. <br><br><pre> <code class="matlab hljs">channel.dcPhase = <span class="hljs-number"><span class="hljs-number">0.00</span></span>;</code> </pre> <br>  3. El recálculo de las características de amplitud channel.abs y phase channel.phase de la línea de señal con valores a frecuencia cero se realiza en la frecuencia del espectro de señal de entrada (f = -fmax / 2: fmax / points: fmax / 2-fmax / points) con extrapolación de las características a área de frecuencias cero y negativas: <br><br><pre> <code class="matlab hljs">ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dc channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.phase = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dcPhase <span class="hljs-built_in"><span class="hljs-built_in">unwrap</span></span>(channel.phase)], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.s = ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> .* <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(+<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>.*ichannel.phase); ichannel.tf = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ichannel.s) + <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">imag</span></span>(ichannel.s) .* <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(f);</code> </pre> <br>  La función de transferencia obtenida: la respuesta de frecuencia de fase de amplitud del canal en la región de baja frecuencia se muestra en la Figura 7. Las características de frecuencia de amplitud de la línea de señal medida y la función de transferencia calculada en los rangos de frecuencia completos se muestran en la Figura 8. Las mismas características en el espacio de fase se muestran en la Figura 9. <br><br><img src="https://habrastorage.org/webt/u0/wm/sl/u0wmslmlvtgejybmkwlmg-qwxcg.png" alt="imagen"><br>  <i>Figura 7. La función de transferencia de la línea de señal en la región de baja frecuencia.</i>  <i>Los puntos rojos y azules indican características discretas de amplitud y fase, respectivamente.</i>  <i>La respuesta de amplitud se muestra en decibelios, la fase en radianes.</i>  <i>La línea rosa marca la frecuencia más baja de la característica medida de la línea de señal.</i>  <i>El coeficiente de transmisión a frecuencia cero es 0.992.</i> <br><br><img src="https://habrastorage.org/webt/4o/q5/yd/4oq5ydmnjdijeopyumfiir0nlia.png" alt="imagen"><br>  <i>Figura 8. Respuesta de frecuencia de la línea de señal.</i>  <i>Los puntos azules indican los datos complejos de la línea medida.</i>  <i>La dependencia simétrica calculada de la ganancia de línea de señal en las frecuencias del espectro de señal de entrada se resalta en rojo.</i>  <i>En la región de frecuencia cero, esta característica se muestra en la Figura 7.</i> <br><br><img src="https://habrastorage.org/webt/nx/zp/xo/nxzpxosf_rti2d2-zdny6p-qbrw.png" alt="imagen"><br>  <i>Figura 9. Características de frecuencia de fase de amplitud de la línea de datos medidos y su espectro normalizado.</i> <br><br><h3>  Cálculo de respuesta de señal </h3><br>  La respuesta (respuesta al efecto de entrada) en el dominio de la frecuencia se obtiene multiplicando el espectro de la señal por el producto de las funciones de transferencia de los elementos que relacionan la reacción con la señal de entrada.  En nuestro caso, la señal pasa a través del filtro y la línea de señal. <br>  La transformación inversa de Fourier ifft se usa para transferir la señal del dominio de frecuencia al dominio del tiempo. <br><br>  La salida del filtro en el dominio de tiempo iSignal.Filter_out se calcula como <br><br><pre> <code class="matlab hljs">TransFunction.PSD = iSignal.PSD .* Filter.PSD_Tx; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  La señal de salida de la línea iSignal.Rx es igual al producto del espectro de la señal de entrada y las funciones de transferencia del filtro y la línea de señal con la transferencia posterior de la señal recibida del dominio de frecuencia al dominio del tiempo. <br><br><pre> <code class="matlab hljs">TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  La respuesta del filtro al pulso ideal de entrada y la respuesta del canal se muestran en la Figura 10. <br><br><img src="https://habrastorage.org/webt/ta/fh/0b/tafh0btf_ayq9wcxrowembxxbdk.png" alt="imagen"><br>  <i>Figura 10. Salida de filtro (gráfico rojo) y salida de línea de datos (gráfico verde).</i>  <i>Señal de entrada del filtro: en la Figura 2 se muestra un pulso único. La entrada de la línea de señal es la señal de salida del filtro.</i> <br><br><h3>  Solicitud  Código m usado MATLAB </h3><br><div class="spoiler">  <b class="spoiler_title">Listado</b> <div class="spoiler_text"><pre> <code class="matlab hljs">clear all <span class="hljs-comment"><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Ini data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% bps = 1.03125e+10; FilterParam = [0.75 0.75]; points = 2^13; load('channel'); N = floor(max(channel.f)*2/bps); fmax = N*bps; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Signal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % normalise all the scales for the bit rate time = bps/fmax .* (1:points); iSignal.Tx(1:size(time,2)) = 0; t0 = max(find(time&lt;=10)); t1 = max(find(time&lt;11)); iSignal.Tx(t0:t1) = 1.0; figure plot(time(1:t1+10), iSignal.Tx(1:t1+10),'b'); hold on plot(time(1:t1+10), iSignal.Tx(1:t1+10),'xb'); grid on xlabel('Normalised Time, tick Ts = 1/fmax'); ylabel('Normalised Amplitude'); title(['Pulse, data bit']); iSignal.shiftedPSD = fft(iSignal.Tx); figure plot(abs(iSignal.shiftedPSD),'c'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fft(iSignal.Tx))']); iSignal.PSD = fftshift(iSignal.shiftedPSD); figure plot(abs(iSignal.PSD),'r'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fftshift(fft(iSignal.Tx)))']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Filter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f_nrm =fmax/bps/points.*(-points/2:points/2-1); s = f_nrm .* j; Filter_PSD = 1 ./(1 + s/FilterParam(1)) ./ (1 + s/FilterParam(2)); figure [AX,H1,H2] = plotyy (f_nrm, abs(Filter_PSD), f_nrm, phase(Filter_PSD)); hold(AX(1)); hold(AX(2)); set(H1,'LineWidth',2); grid(AX(2),'on'); xlabel('Normalised Frequency (Hz)'); set(get(AX(1),'Ylabel'),'String','Gain'); set(get(AX(2),'Ylabel'),'String','Phase, rad'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); figure plot_handles_Filter = plot(f_nrm(points/2 + 1:points), 20*log10(abs(Filter_PSD(points/2 + 1:points))), 'r', 'linewidth', 2); hold on stem_handles_br = stem(1, 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; 1))))), '-.ro'); hold on stem_handles_c = stem(FilterParam, [20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(1)))))) 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(2))))))], '-.bo'); grid legend_handles = [plot_handles_Filter, stem_handles_br(1), stem_handles_c(1)]; legend(legend_handles, 'transfer function', 'filter attenuation at normalised baud rate', 'filter attenuation at normalised cutoff frequency', 3); xlabel('Normalised Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Channel %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % create negative frequencies, convert data to complex value, taking care about negative frequency channel.abs = abs(channel.s); channel.phase = angle(channel.s); %channel.s = channel.abs .* exp(+j.*channel.phase); [a] = polyfit(channel.f(1:10), channel.abs(1:10), 1); channel.dc = a(2); channel.dcPhase = 0.00; fs = fmax/points; % frequency step f = -fmax/2:fs:fmax/2-fs; % frequency matrix % create new data structure with linearly interpolated data ichannel.abs = interp1([0 channel.f], [channel.dc channel.abs], abs(f), 'linear', 'extrap'); ichannel.phase = interp1([0 channel.f], [channel.dcPhase unwrap(channel.phase)], abs(f), 'linear', 'extrap'); % correct for negative frequencies ichannel.s = ichannel.abs .* exp(+j.*ichannel.phase); ichannel.tf = real(ichannel.s) + j*imag(ichannel.s) .* sign(f); figure disp_points = 2*round(channel.f(1)/fs); stem_handles_br = stem(channel.f(1), angle(ichannel.tf(max(find(f &lt; channel.f(1))))), '-.mo'); hold on plot_abs = plot(f(points/2-disp_points:points/2+disp_points), 20*log10(abs(ichannel.tf(points/2-disp_points:points/2+disp_points))), '.r', 'linewidth', 3); hold on plot_phase = plot(f(points/2-disp_points:points/2+disp_points), angle(ichannel.tf(points/2-disp_points:points/2+disp_points)), '.b', 'linewidth', 3); grid legend_handles = [plot_abs, plot_phase, stem_handles_br(1)]; legend(legend_handles, 'absolute value (dB)', 'phase (rad)', 'min data freq', 3); xlabel('Relative Frequency (Hz)'); ylabel('Magnitude'); title(sprintf('dc extrapolation. dc trans function=%4.3f, dc phase=%4.3f rad', abs(ichannel.tf(points/2+1)), angle(ichannel.tf(points/2+1)))); figure plot(channel.f, 20*log10(channel.abs), '.r', 'linewidth', 3); hold on plot(f, 20*log10(ichannel.abs), 'g'); grid on legend('Measured Data', 'Interpolated Data', 3); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Chnnel interpolated Data : ']); figure plot3(channel.f, real(channel.s), imag(channel.s),'r'); hold on plot3(f, real(ichannel.tf), imag(ichannel.tf),'g'); grid on legend('Measured Data', 'Interpolated Data'); xlabel('Frequency in Hz'); ylabel('Re(fwd transfer)'); zlabel('Im(fwd transfer)'); title(['Chnnel interpolated Data : ']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Response %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % filter Output TransFunction.PSD = iSignal.PSD .* Filter_PSD; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = real(ifft(TransFunction.shiftedPSD)); % pass through channel TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = real(ifft(TransFunction.shiftedPSD)); figure plot(time, iSignal.Filter_out,'r'); hold on [max_Tx, time_maxTx] = max(iSignal.Filter_out); [min_Tx, time_minTx] = min(iSignal.Filter_out); [max_Rx, time_maxRx] = max(iSignal.Rx); dtime_p5= round((time_maxRx - time_maxTx)*time(1) -1); plot(time - dtime_p5, iSignal.Rx,'g'); hold on plot(time, iSignal.Filter_out,'rx'); axis([(time_maxTx*time(1) - 3) (time_maxTx*time(1) + 5) (min_Tx-0.15) (max_Tx+0.1)]) grid on legend('Filter out','Rx', 2); xlabel('Normalised Time'); ylabel('Normalised Amplitude'); title(sprintf('Transmit pulse (Tx) max= %4.3f; Response (Rx) max (h0)= %4.3f', max(iSignal.Filter_out), max(iSignal.Rx)));</span></span></code> </pre><br></div></div><br><h3>  Lista bibliográfica </h3><br>  1. IEEE802.3ap.  Resultados de la simulación NRZ de 10.3125 Gbps utilizando "StatEye" y "Modelo de señal a interferencia" en componentes de canal en cascada.  Shannon Sawyer y Charles Moore / Agilent Technologies.  24 de enero de 2005 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.ieee802.org/3/ap/public/jan05/sawyer_01_0105.pdf</a> <br><br>  2. Qué es StatEye.  IEEE 803.3ap Task Force.  16 de septiembre de 2004 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.ieee802.org/3/ap/public/signal_adhoc/ghiasi_01_0904.pdf</a> <br><br>  3. Acuerdo de Stat Eye / IBM.  Steve Anderson  Xilinx, Inc.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.ieee802.org/3/ap/public/nov04/anderson_01_1104.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416497/">https://habr.com/ru/post/es416497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416487/index.html">Radio Astron cumple 7 años</a></li>
<li><a href="../es416489/index.html">Vida extraterrestre: sobre la corrección de la ecuación de Drake y el gran filtro</a></li>
<li><a href="../es416491/index.html">Activiti - Motor de procesos comerciales</a></li>
<li><a href="../es416493/index.html">Inicie SIIG MiniSys S286</a></li>
<li><a href="../es416495/index.html">SamsPcbGuide Parte 6: Trazar líneas de señal. Modelos de pérdida y diafonía</a></li>
<li><a href="../es416501/index.html">Escríbeme un servidor GraphQL en C #</a></li>
<li><a href="../es416505/index.html">Escribimos una máquina virtual de pila en Rust'e</a></li>
<li><a href="../es416511/index.html">Los errores más comunes en su código React que usted (posiblemente) comete</a></li>
<li><a href="../es416513/index.html">El resumen de materiales interesantes para el desarrollador móvil # 260 (2 de julio - 8 de julio)</a></li>
<li><a href="../es416515/index.html">Valoración de artículos para agregar a favoritos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>