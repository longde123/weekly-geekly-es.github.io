<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏽 🛄 👨🏼‍🌾 So funktioniert Alpha Compositing 🙋🏻 🧑🏿‍🤝‍🧑🏻 🤱🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transparenz scheint kein interessantes Thema zu sein. Das GIF-Format, mit dem einige Pixel durch den Hintergrund scheinen konnten, wurde vor über 30 J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Alpha Compositing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="Bild"></div><br>  Transparenz scheint kein interessantes Thema zu sein.  Das GIF-Format, mit dem einige Pixel durch den Hintergrund scheinen konnten, wurde vor über 30 Jahren veröffentlicht.  Nahezu jede in den letzten zwei Jahrzehnten veröffentlichte Grafikdesign-Anwendung unterstützt die Erstellung durchscheinender Inhalte.  Diese Konzepte sind längst nichts Neues mehr. <br><br>  In meinem Artikel möchte ich zeigen, dass Transparenz in digitalen Bildern tatsächlich viel interessanter ist, als es scheint - in dem, was wir für selbstverständlich halten, gibt es eine unsichtbare Tiefe und Schönheit. <br><a name="habracut"></a><br><h1>  Deckkraft </h1><br>  Wenn Sie jemals durch eine rosa Brille geschaut haben, können Sie etwas Ähnliches wie in der folgenden Abbildung sehen.  [Im Originalartikel sind viele Bilder interaktiv.] Versuchen Sie, die Brille zu bewegen, um zu sehen, wie sie sich auf das auswirkt, was durch sie sichtbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br>  Solche Brillen funktionieren wie folgt: Sie vermissen viel Rot, eine ordentliche Menge Blau und sehr wenig Grün.  Die Mathematik dieser Punkte kann in drei Gleichungen geschrieben werden.  Der Buchstabe <strong>R</strong> gibt das Ergebnis der Operation an, und der Buchstabe <strong>D</strong> beschreibt den Punkt, den wir betrachten.  RGB-Indizes geben rote, grüne und blaue Komponenten an: <br><br><blockquote><code>R <sub>R</sub> = D <sub>R</sub> × 1.0 <br> R <sub>G</sub> = D <sub>G</sub> × 0.7 <br> R <sub>B</sub> = D <sub>B</sub> × 0.9</code> </blockquote> <br>  Dieses Buntglas überträgt rote, grüne und blaue Komponenten des Hintergrunds mit unterschiedlichen Stärken.  Mit anderen Worten, die <em>Transparenz einer</em> rosa Brille hängt von der Farbe des einfallenden Lichts ab.  Im Allgemeinen kann die Transparenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Abhängigkeit von der Wellenlänge des Lichts variieren.</a> In diesem vereinfachten Beispiel interessiert uns jedoch nur, wie sich Brillen auf die klassischen RGB-Komponenten auswirken. <br><br>  Die Simulation des Verhaltens gewöhnlicher Sonnenbrillen ist viel einfacher. Sie dämpfen das einfallende Licht normalerweise nur um einen gewissen Betrag: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br>  Diese Gläser lassen nur 30% des Lichts durch.  Ihr Verhalten kann durch die folgenden Gleichungen beschrieben werden: <br><br><blockquote> <code>R <sub>R</sub> = D <sub>R</sub> × 0.3 <br> R <sub>G</sub> = D <sub>G</sub> × 0.3 <br> R <sub>B</sub> = D <sub>B</sub> × 0.3</code> </blockquote> <br>  Alle drei Farbkomponenten werden um den gleichen Wert reduziert - die Absorption des einfallenden Lichts ist gleich.  Wir können sagen, dass dunkle Brillen zu 30% transparent (undurchsichtig) oder zu 70% undurchsichtig sind.  <em>Die Deckkraft eines</em> Objekts bestimmt, wie viel Farbe es blockiert.  In der Computergrafik handelt es sich normalerweise um ein vereinfachtes Modell, bei dem nur ein Wert zur Beschreibung dieser Eigenschaft benötigt wird.  Die Opazität kann räumlich variieren.  wie zum Beispiel eine Rauchsäule, die höher und transparenter wird. <br><br>  In der realen Welt sind Objekte mit einer Deckkraft von 100% einfach undurchsichtig und lassen überhaupt kein Licht durch.  Die Welt der digitalen Bilder ist etwas anders.  Es gibt Grenzfälle, in denen selbst feste undurchsichtige Objekte eine bestimmte Lichtmenge passieren. <br><br><h1>  Abdeckung </h1><br>  Vektorgrafiken befassen sich mit klaren und unendlich genauen Beschreibungen von Formen, die mithilfe von Punkten, Liniensegmenten, Bezier-Kurven und anderen mathematischen Grundelementen definiert wurden.  Wenn Sie Zahlen auf einem Computerbildschirm anzeigen müssen, müssen diese einwandfreien Entitäten in eine Bitmap gerastert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>  <i>Rasterisierung einer Vektorform zu einer Bitmap</i> <br><br>  Die primitivste Methode zum Rastern besteht darin, zu überprüfen, wo sich die Pixelprobe befindet - innerhalb oder außerhalb der Vektorform.  In den folgenden Beispielen können Sie das Dreieck ziehen. In einer vergrößerten Ansicht sind die Bewegungen genauer.  Ein blauer Umriss zeigt die ursprüngliche Vektorgeometrie an.  Wie Sie sehen können, sieht die Leiter an den Rändern des Dreiecks hässlich aus und flackert beim Verschieben der Geometrie stark: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br>  Der Nachteil dieses Ansatzes besteht darin, dass wir nur eine Prüfung für jedes angezeigte Pixel durchführen und die Ergebnisse auf einen von zwei möglichen Werten diskretisiert werden - innen oder außen. <br><br>  Sie können die Vektorgeometrie mehrmals pro Pixel abtasten, um eine große Abstufung der Schritte zu erhalten und zu entscheiden, dass einige Pixel nur <em>teilweise</em> geschlossen sind.  Eine mögliche Lösung besteht darin, vier Abtastpunkte zu verwenden, um fünf Abdeckungsgrade darzustellen: 0, <sup>1</sup> ⁄ <sub>4</sub> , <sup>2</sup> ⁄ <sub>4</sub> , <sup>3</sup> ⁄ <sub>4</sub> und 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br>  Die Qualität der Kanten des Dreiecks hat sich verbessert, aber nur fünf mögliche Abdeckungsstufen reichen oft nicht aus, und wir können leicht ein viel besseres Ergebnis erzielen.  Obwohl die Ansicht eines Pixels als kleines Quadrat in der Welt der Signalverarbeitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit Missbilligung betrachtet wird</a> , ist es in einigen Zusammenhängen ein nützliches Modell, mit dem wir die genaue Abdeckung eines Pixels anhand der Vektorgeometrie berechnen können.  Der Schnittpunkt einer Linie und eines Quadrats kann immer in ein <i>Trapez</i> und ein <i>Rechteck</i> zerlegt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="Bild"></div><br>  <i>Ein Liniensegment teilt ein Quadrat in ein Trapez und ein Rechteck</i> <br><br>  Sie können die Fläche beider Teile leicht berechnen, und ihre Summe geteilt durch die Fläche des Quadrats bestimmt den Prozentsatz der Pixelabdeckung.  Somit wird die Abdeckung als exakte Zahl mit beliebiger Genauigkeit berechnet.  In der unten gezeigten Demo wird diese Methode verwendet, um viel bessere Kanten zu rendern, die auch beim Ziehen eines Dreiecks glatt bleiben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br>  Wenn es um komplexere Formen geht, z. B. Ellipsen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beziers</a> , werden diese häufig in einfache gerade Liniensegmente unterteilt, mit denen Sie die Abdeckung mit der richtigen Genauigkeit berechnen können. <br><br>  Das Konzept der teilweisen Abdeckung ist entscheidend für das qualitativ hochwertige Rendern von Vektorgrafiken und vor allem für das Rendern von Text.  Wenn Sie einen Screenshot dieses Artikels machen und ihn sorgfältig prüfen, werden Sie feststellen, dass fast alle Kanten der Glyphen Pixel nur teilweise abdecken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>  <i>Teilabdeckung wird beim Rendern von Text aktiv verwendet</i> <br><br>  Wenn Sie die Deckkraft des Objekts haben und es mit einzelnen Pixeln bedecken, können Sie diese zu einem Wert kombinieren. <br><br><h1>  Alpha </h1><br>  Das Produkt aus der Opazität eines Objekts und seiner Pixelabdeckung heißt <em>Alpha</em> : <br><br><blockquote> <code> =  × </code> </blockquote> <br>  Ein Objekt mit einer Deckkraft von 60%, das 30% der Pixelfläche abdeckt, hat in diesem Pixel einen Alpha-Wert von 18%.  Wenn das Objekt transparent ist oder das Pixel nicht vollständig bedeckt, ist der Alpha-Wert in diesem Pixel natürlich 0. Nach der Multiplikation verschwinden die Unterschiede zwischen Opazität und Beschichtung, was in gewissem Sinne die Tatsache rechtfertigt, dass die Konzepte "Alpha" und "Opazität" als Synonyme verwendet werden. <br><br>  Alpha wird oft als vierter Kanal eines Bitmap-Bildes dargestellt.  Die üblichen Werte für Rot, Grün und Blau werden durch einen Alpha-Wert ergänzt, der vier RGBA-Werte bildet. <br><br>  Wenn es darum geht, Alpha-Werte im Speicher zu speichern, besteht die Versuchung, nur wenige Bits dafür zu verwenden.  Im Fall der Abdeckung der Pixel der Kanten von undurchsichtigen Objekten scheinen 4 oder sogar 3 Bits je nach Pixeldichte des Bildschirms völlig ausreichend zu sein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br>  Die Deckkraft wirkt sich jedoch auch auf den Alpha-Wert aus, sodass eine geringe Bittiefe in einigen Fällen katastrophal sein kann, wenn sich die Transparenz reibungslos ändert.  Das Bild unten zeigt einen Farbverlauf von undurchsichtigem Schwarz nach Weiß, der zeigt, dass eine geringe Bittiefe zu sehr starken Farbabweichungen führt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br>  Je mehr Bits, desto besser und am häufigsten verwendet Alpha 8 eine Bittiefe von 8, um der Genauigkeit der Farbkomponenten zu entsprechen, weshalb viele RGBA-Puffer 32 Bit pro Pixel belegen.  Es ist auch erwähnenswert, dass im Gegensatz zu Farbkomponenten, die häufig mit nichtlinearer Transformation codiert werden, Alpha linear gespeichert wird - der codierte Wert von 0,5 entspricht einem Alpha-Wert von 0,5. <br><br>  In Bezug auf Alpha haben wir alle anderen Farbkomponenten vollständig ignoriert, aber zusätzlich zum Blockieren der Hintergrundfarbe kann das Pixel selbst ein wenig Farbe hinzufügen.  Die Idee ist ganz einfach: Ein durchscheinendes rosa Objekt blockiert einen Teil der einfallenden Hintergrundbeleuchtung und sendet oder reflektiert ein wenig rosa Licht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br>  Beachten Sie, dass es sich <em>nicht</em> wie Buntglas verhält.  Glas blockiert einfach einen Teil der Hintergrundbeleuchtung mit unterschiedlicher Helligkeit.  Wenn Sie ein vollständig schwarzes Objekt durch rosa Glas betrachten, bleibt seine Schwärze erhalten, da das schwarze Objekt kein Licht emittiert und reflektiert.  Das durchscheinende rosa Objekt <em>fügt jedoch</em> sein eigenes Licht hinzu.  Wenn Sie es auf ein schwarzes Objekt legen, ist das Ergebnis rosa.  Ein gutes Analogon zu diesem Verhalten ist feines Material, das in der Luft schwebt, wie Dunst, Rauch, Nebel oder etwas farbiges Pulver. <br><br>  Das Rendern eines Alphakanals ist etwas schwieriger - ein perfekt transparentes Objekt ist per Definition unsichtbar. Um zwischen Objekten zu unterscheiden, müssen zwei Tricks angewendet werden.  Ein Schachbretthintergrund zeigt an, welche Teile des Bildes transparent sind.  Dieses Muster wird in vielen grafischen Anwendungen verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>  <i>Schachmuster zeigt transparente Figuren.</i> <br><br>  Die vier kleinen Quadrate unter dem Bild zeigen an, dass wir die roten, grünen, blauen und Alpha-Komponenten des Bildes sehen.  In einigen Fällen ist es nützlich, die Alphakanalwerte direkt anzuzeigen, und die einfachste Möglichkeit, sie anzuzeigen, ist die Verwendung von Graustufen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>  <i>Zeigen Sie RGB- und A-Werte auf verschiedenen Oberflächen an</i> <br><br>  Je heller der Grauton ist, desto höher ist der Alpha-Wert, dh reines Schwarz entspricht 0% Alpha und reines Weiß 100% Alpha.  Kleine Quadrate zeigen an, dass die RGB- und A-Komponenten des Bildes in zwei Teile unterteilt sind. <br><br>  Die Alpha-Komponente selbst ist nicht besonders nützlich, aber sie wird sehr wichtig, wenn wir über Compositing sprechen. <br><br><h1>  Einfaches Compositing </h1><br>  In einem Arbeitsgang können nur sehr wenige Effekte des 2D-Renderings implementiert werden. Um ein fertiges Ergebnis zu erzielen, verwenden wir einen <em>Compositing-</em> Prozess, bei dem verschiedene Bilder kombiniert werden.  Zum Beispiel kann eine einfache Schaltfläche "Abbrechen" erstellt werden, indem fünf separate Elemente zusammengesetzt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div><br>  <i>Zusammensetzen von Elementen für die Schaltfläche Abbrechen</i> <br><br>  Das Zusammensetzen erfolgt häufig in mehreren Schritten, in denen jeweils zwei Bilder kombiniert werden.  Das beim Zusammensetzen verwendete Vordergrundbild wird üblicherweise als <em>Quelle bezeichnet</em> .  Das beim Compositing verwendete Hintergrundbild, dem die Quelle überlagert ist, wird normalerweise als <em>Ziel bezeichnet</em> . <br><br>  Wir beginnen mit dem Compositing auf einem undurchsichtigen Hintergrund, da dies ein sehr häufiger Fall ist.  Alles, was Sie auf dem Bildschirm sehen, wird letztendlich durch Compositing an einem undurchsichtigen Ziel überlagert. <br><br>  Wenn der Alpha-Wert der Quelle 100% beträgt, ist die Quelle undurchsichtig und sollte das Ziel vollständig abdecken.  Wenn der Alpha-Wert 0% beträgt, ist die Quelle vollständig transparent und hat keinerlei Einfluss auf das Ziel.  Ein Alpha-Wert von 25% ermöglicht es dem Objekt, 25% seines Lichts zu emittieren und 75% des Lichts vom Hintergrund zu leiten, und so weiter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>  <i>Zusammenstellen einer lila Quelle mit unterschiedlichen Alpha-Werten zum gelben Ziel</i> <br><br>  Sie können bereits verstehen, was alles passieren wird - ein einfacher Fall von Alpha-Compositing auf einem undurchsichtigen Hintergrund - es ist nur eine lineare Interpolation zwischen den Ziel- und Quellfarben.  In der folgenden Grafik steuert der Schieberegler den Alpha-Wert der Quelle, und in den roten, grünen und blauen Grafiken werden die Werte der RGB-Komponenten angezeigt.  Das Ergebnis von <strong>R</strong> ist nur eine Mischung zwischen Quelle <strong>S</strong> und Ziel <strong>D</strong> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br>  Was hier passiert, kann durch die unten gezeigten Gleichungen beschrieben werden.  Wie zuvor bezeichnet der Index die Komponente, dh <sub>SA</sub> ist der Alpha-Wert in der Quelle und D <sub>G</sub> ist der grüne Wert im Ziel: <br><br><blockquote> <code>R <sub>R</sub> = S <sub>R</sub> × S <sub>A</sub> + D <sub>R</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>G</sub> = S <sub>G</sub> × S <sub>A</sub> + D <sub>G</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>B</sub> = S <sub>B</sub> × S <sub>A</sub> + D <sub>B</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  Die Gleichungen für die roten, grünen und blauen Komponenten sehen gleich aus. Sie können also einfach den <sub>RGB-</sub> Index verwenden und sie in einer Zeile kombinieren: <br><br><blockquote> <code>R <sub>RGB</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  Da das Ziel undurchsichtig ist und bereits das gesamte Hintergrundlicht blockiert, wissen wir außerdem, dass der Alpha-Wert des Ergebnisses immer 1 ist: <br><br><blockquote> <code>R <sub>A</sub> = 1</code> </blockquote> <br>  Das Zusammensetzen auf einem undurchsichtigen Hintergrund ist einfach, aber in seinen Fähigkeiten ziemlich begrenzt.  In vielen Fällen ist eine zuverlässigere Lösung erforderlich. <br><br><h1>  Zwischenpuffer </h1><br>  Das folgende Bild zeigt den zweistufigen Prozess des Zusammensetzens von drei verschiedenen Schichten mit den Bezeichnungen A, B und C. Das Symbol ⇨ bedeutet "durch Zusammensetzen überlagert": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>  <i>Das Ergebnis einer zweistufigen Zusammenstellung von drei Schichten</i> <br><br>  Zuerst überlagern wir B mit C, indem wir komponieren, und überlagern dann A mit ihnen, um das fertige Bild zu erhalten.  Im folgenden Beispiel werden wir die Dinge etwas anders machen.  Zuerst verbinden wir die beiden obersten Ebenen durch Zusammensetzen und überlagern dann das Ergebnis mit dem letzten Ziel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>  <i>Das Ergebnis einer zweistufigen Zusammenstellung von drei Schichten in unterschiedlicher Reihenfolge</i> <br><br>  Sie fragen sich wahrscheinlich, ob eine solche Situation in der Praxis auftritt, aber tatsächlich ist sie sehr häufig.  Viele nicht triviale Compositing-Operationen und Rendering-Effekte, wie z. B. Maskieren und Verwischen, erfordern das Durchlaufen eines Zwischenpuffers, der nur teilweise Compositing-Ergebnisse enthält.  Dieses Konzept hat unterschiedliche Namen: Offscreen-Durchgänge, Transparenzebenen oder Seitenpuffer, aber normalerweise basieren sie auf derselben Idee. <br><br>  Was für uns wichtiger ist, ist, dass fast <em>jedes</em> Bild mit Transparenz als Teilergebnis eines Renderings wahrgenommen werden kann, das später durch Zusammensetzen des letzten Ziels überlagert wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>  <i>Teilweise Zusammenstellung einer Schaltfläche in einer Zwischenablage</i> <br><br>  Wir müssen verstehen, wie das Zusammensetzen der durchscheinenden Bilder A und B durch ein Bild (A⇨B) mit derselben Farbe und Deckkraft ersetzt werden kann.  Beginnen wir mit der Berechnung des Alpha-Werts des endgültigen Puffers. <br><br><h1>  Alpha-Werte kombinieren </h1><br>  Es ist Ihnen vielleicht nicht klar, wie Sie die Deckkraft zweier Objekte kombinieren sollen, aber es ist einfacher, über diese Aufgabe zu sprechen, wenn wir stattdessen über Transparenz sprechen. <br><br>  Angenommen, eine bestimmte Lichtmenge tritt durch das erste Objekt und dann durch das zweite Objekt.  Wenn die Transparenz des ersten Objekts 80% beträgt, werden 80% des einfallenden Lichts durchgelassen.  In ähnlicher Weise lässt ein zweites Objekt mit 60% Transparenz 60% des Lichts durch, was 60% × 80% = 48% des ursprünglichen Lichts ergibt.  Sie können im Originalartikel mit Transparenz experimentieren.  Vergessen Sie nicht, dass die Schieberegler die <em>Transparenz</em> und nicht die Deckkraft von Objekten im Lichtweg steuern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br>  Wenn entweder das erste oder das zweite Objekt undurchsichtig ist, tritt natürlich kein Licht durch sie hindurch, selbst ein anderes ist vollständig transparent. <br><br>  Wenn Objekt D Transparenz D <sub>T</sub> hat und Objekt S Transparenz S <sub>T hat</sub> , ist die endgültige allgemeine Transparenz R <sub>T</sub> dieser beiden Objekte gleich ihrem Produkt: <br><br><blockquote>  R <sub>T</sub> = D <sub>T</sub> × S <sub>T.</sub> </blockquote><br>  Transparenz ist jedoch nur eine Einheit minus Alpha, sodass wir durch Substitution Folgendes erhalten: <br><br><blockquote>  1 - R <sub>A</sub> = (1 - D <sub>A</sub> ) × (1 - S <sub>A</sub> ) </blockquote><br>  Dieser Ausdruck kann erweitert werden in: <br><br><blockquote>  1 - R <sub>A</sub> = 1 - D <sub>A</sub> - S <sub>A</sub> + D <sub>A</sub> × S <sub>A.</sub> </blockquote><br>  Und vereinfachen Sie es so: <br><br><blockquote>  R <sub>A</sub> = DA + SA - DA × SA </blockquote><br>  Es kann auf einen von zwei ähnlichen Typen reduziert werden: <br><br><blockquote>  R <sub>A</sub> = SA + DA × (1 - SA) <br><br>  R <sub>A</sub> = DA + SA × (1 - DA) </blockquote><br>  Bald werden wir sehen, dass die zweite häufiger verwendet wird.  Es ist auch interessant festzustellen, dass der resultierende Alpha-Wert nicht von der relativen Reihenfolge der Objekte abhängt - die Deckkraft der resultierenden Pixel ist dieselbe, selbst wenn Sie die Quelle und das Ziel vertauschen.  Das ist sehr logisch.  Das Licht, das durch zwei Objekte fällt, sollte auf dieselbe Weise von jeder Seite des Sterns, von vorne oder von hinten, ausgeblendet werden. <br><br><h1>  Farbkombination </h1><br>  Die Berechnung von Alpha war nicht so schwierig. Versuchen wir also, die Berechnungen von RGB-Komponenten zu verstehen.  Das Quellbild hat die Farbe S <sub>RGB</sub> , aber seine Deckkraft S <sub>A</sub> zwingt nur das Produkt dieser beiden Werte in das Endergebnis: <br><br><blockquote>  S <sub>RGB</sub> × S <sub>A.</sub> </blockquote><br>  Das Zielbild hat die Farbe D <sub>RGB</sub> , die Opazität lässt es Licht emittieren D <sub>RGB</sub> × D <sub>A</sub> , jedoch wird ein Teil des Lichts durch die Opazität des Bildes S blockiert, so dass der gesamte Einfluss des Ziels gleich ist: <br><br><blockquote>  D <sub>RGB</sub> × DA × (1 - SA) </blockquote><br>  Der Gesamtbeitrag des Lichts von S und D entspricht ihrer Summe: <br><br><blockquote>  S <sub>RGB</sub> × SA + D <sub>RGB</sub> × DA × (1 - SA) </blockquote><br>  In ähnlicher Weise entspricht der Beitrag der zusammengeführten Ebenen ihrer Farbe mal ihrer Opazität: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A.</sub> </blockquote><br>  Wir möchten, dass diese beiden Werte übereinstimmen: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × DA × (1 - SA) </blockquote><br>  Was gibt uns die endgültigen Gleichungen: <br><br><blockquote>  R <sub>A</sub> = SA + DA × (1 - SA) <br><br>  R <sub>RGB</sub> = (S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> )) / R <sub>A.</sub> </blockquote><br>  Sehen Sie, wie kompliziert die zweite Gleichung ist!  Beachten Sie, dass wir durch den Alpha-Wert dividieren müssen, um die RGB-Werte des Ergebnisses zu erhalten.  Für die nächste Stufe des Zusammensetzens ist jedoch erneut eine Multiplikation mit dem Alpha-Wert erforderlich, da das Ergebnis der aktuellen Operation zur neuen Quelle oder zum neuen Ziel der nächsten Operation wird.  Es ist einfach hässlich. <br><br>  Kehren wir für eine Sekunde zur fast endgültigen Form von R <sub>RGB zurück</sub> : <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × DA × (1 - SA) </blockquote><br>  Quelle, Ziel <em>und</em> Ergebnis werden mit ihren Alpha-Komponenten multipliziert.  Dies lässt uns verstehen, dass die Farbe und das Alpha des Pixels „zusammen“ sein sollen. Daher müssen wir einen Schritt zurücktreten und die Art und Weise, wie wir Farbinformationen speichern, überdenken. <br><br><h1>  Vormultipliziertes Alpha </h1><br>  Denken Sie daran, dass wir über Opazität gesprochen haben - wenn das Objekt teilweise undurchsichtig ist, ist sein Beitrag zum Ergebnis auch teilweise.  Das Konzept des vormultiplizierten Alphas („Vormultiplikation mit Alpha“) setzt diese Idee um.  Die Werte der RGB-Komponenten werden, wie der Name schon sagt, mit der Alpha-Komponente vormultipliziert.  Beginnen wir mit Farbe ohne vorläufige Multiplikation: <br><br><blockquote>  (1,00, 0,80, 0,30, 0,40) </blockquote><br>  Die vorläufige Multiplikation mit Alpha ergibt Folgendes: <br><br><blockquote>  (0,40, 0,32, 0,12, 0,40) </blockquote><br>  Schauen wir uns mehrere Pixel gleichzeitig an.  Die folgende Abbildung zeigt, wie Farbinformationen gespeichert werden, ohne zuvor Alpha zu multiplizieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>  <i>RGB- und A-Informationen im Bild ohne vorherige Multiplikation</i> <br><br>  Beachten Sie, dass Bereiche, in denen Alpha 0 ist, beliebige RGB-Werte haben können, wie aus den grünen und blauen Störungen im Bild ersichtlich ist.  Bei der vorläufigen Multiplikation mit Alpha werden in den Farbinformationen auch Pixelopazitätswerte gespeichert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>  <i>RGB- und A-Informationen in einem vormultiplizierten Bild</i> <br><br>  Vormultipliziertes Alpha wird manchmal als assoziiertes Alpha bezeichnet, und nicht vormultipliziertes Alpha wird manchmal als gerades oder nicht assoziiertes Alpha bezeichnet. <br><br>  Wenn die Alpha-Komponente der Farbe 0 ist, setzt die vorläufige Multiplikation alle anderen Komponenten zurück, unabhängig von ihren Werten: <br><br><blockquote>  (0,0, 0,0, 0,0, 0,0) </blockquote><br>  Im Fall von vormultipliziertem Alpha gibt es nur <em>eine</em> vollständig transparente Farbe, und dies ist charmant. <br><br>  Die Vorteile dieser Verarbeitung von Farbkomponenten werden Ihnen nach und nach klar. Bevor wir jedoch zum Compositing-Beispiel zurückkehren, wollen wir uns ansehen, wie vormultipliziertes Alpha zur Lösung einiger anderer Rendering-Probleme beiträgt. <br><br><h2>  Filtern </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gaußsche Unschärfe</a> ist eine beliebte Methode, um einen interessanten defokussierten Hintergrund zu erstellen oder die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hohe Frequenz des</a> Hintergrundteils des Inhalts einiger UI-Elemente zu reduzieren.  Wie wir sehen werden, ist das Vormultiplizieren von Alpha entscheidend, um die richtige Unschärfe zu erzielen. <br><br>  Das Bild, das wir analysieren, wird erstellt, indem der Hintergrund mit 1% undurchsichtigem Blau gefüllt wird, über das ein undurchsichtiger roter Kreis gezogen wird.  Schauen wir uns zunächst ein Beispiel ohne vorläufige Multiplikation an.  Ich habe die RGB-Kanäle vom Alpha-Kanal getrennt, um zu verstehen, was los war.  Der Pfeil zeigt die Unschärfeoperation an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>  <i>Verwischen Sie den Inhalt ohne vorherige Multiplikation</i> <br><br>  Das fertige Ergebnis hat einen hässlichen blauen Heiligenschein.  Dies geschah, weil der blaue Hintergrund während der Unschärfe auf den roten Bereich sickerte und erst <em>dann</em> während des Zusammensetzens das Alpha-Gewicht hinzugefügt wurde. <br><br>  Wenn die Farben mit Alpha vormultipliziert werden, ist das Ergebnis korrekt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwischen von vormultiplizierten Inhalten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgrund der Vormultiplikation wird die blaue Farbe des Bildes auf 1% seiner ursprünglichen Stärke reduziert, sodass die Auswirkungen auf die Farben des unscharfen Kreises äußerst gering sind.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Rendern eines Bildes, dessen Pixel perfekt zum Ziel passen, ist eine einfache Aufgabe, da wir eine einfache Eins-zu-Eins-Zuordnung zwischen Samples durchführen müssen. </font><font style="vertical-align: inherit;">Ein Problem tritt auf, wenn es keine einfache Zuordnung gibt, beispielsweise aufgrund von Drehung, Skalierung oder Silbentrennung. </font><font style="vertical-align: inherit;">Die folgende Abbildung zeigt, dass die durch den roten Umriss angezeigten Pixel des gedrehten Bildes nicht mehr mit dem Ziel übereinstimmen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Bildorientierung und Zielpixel vor und nach der Drehung</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt viele Möglichkeiten, eine Farbe aus dem Bild auszuwählen, das in das Zielpixel geschrieben werden soll, und die einfachste davon ist die sogenannte Interpolation zum nächsten Nachbarn, bei der Als letztes Pixel wird einfach die nächstgelegene Probe in der Textur ausgewählt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Demonstration zeigt der rote Umriss die Bildposition im Ziel. Die rechte Seite zeigt die Positionen der Proben aus Sicht des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Durch Ziehen des Schiebereglers (im Originalartikel) können Sie das Viereck drehen und beobachten, wie die Samples Farben aus der Bitmap auswählen. Ich habe ein Pixel in Quelle und Ziel hervorgehoben, damit ihre Beziehung klarer wird:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Lösung ist sehr funktional und die Pixel haben eine ganzheitliche Farbe, aber die Qualität ist nicht akzeptabel. Es wäre besser, eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilineare Interpolation zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den gewichteten Durchschnitt der vier nächsten Pixel des abgetasteten Bildes berechnet:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert besser, aber die Kanten um die Rechtecke sehen nicht richtig aus. Der Inhalt der Pixel wird ohne Multiplikation zusammengeführt, da Alpha nach der Interpolation "angewendet" wird. Manchmal ist die empfohlene Lösung zum Zusammenführen der Farbe des richtigen Inhalts, die in dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstaunlichen Artikel von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adrian Correger [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Habré] gezeigt wird, </font><font style="vertical-align: inherit;">alles andere als </font><font style="vertical-align: inherit;">ideal - keine einzige Farbe in der Lücke zwischen dem roten und dem blauen Rechteck sieht richtig aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie alles im Bild mit vormultipliziertem Alpha und Compositing mit einer erweiterten Formel aussehen wird, die wir bald ableiten werden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach perfekt - wir haben alle Farbfusionen beseitigt und die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zähne sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nirgends zu sehen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letztendlich sind die mit Unschärfe und Interpolation verbundenen Probleme eng miteinander verbunden. </font><font style="vertical-align: inherit;">Jede Operation, die eine Kombination von durchscheinenden Farben erfordert, ohne zuvor die Farben mit Alpha zu multiplizieren, führt wahrscheinlich zu falschen Ergebnissen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das richtige Compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommen wir zurück zum Compositing. </font><font style="vertical-align: inherit;">Wir haben uns für eine fast abgeleitete Gleichung entschieden:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich Farben mit vormultipliziertem Alpha vorstellen, verschwinden alle diese unangenehmen Multiplikationen, da Alpha bereits Teil der Farbwerte ist. </font><font style="vertical-align: inherit;">Dann bekommen wir folgendes:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen wir uns die Alpha-Gleichung an: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Koeffizienten für die Kanäle Rot, Grün, Blau und Alpha sind gleich, sodass wir den gesamten Ausdruck mit einer Gleichung ausdrücken können und uns daran erinnern, dass jede Komponente dieselbe Operation durchläuft: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehen Sie, wie vormultipliziertes Alpha die Dinge einfach machte. </font><font style="vertical-align: inherit;">Wenn wir die Komponenten der Gleichung analysieren, sind sie alle vorhanden. </font><font style="vertical-align: inherit;">Die Operation </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maskiert einen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil des Hintergrundlichts und fügt ein neues Licht hinzu:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Mischvorgang wird als Source-Over, Souver oder einfach als normal bezeichnet und ist ohne Zweifel der häufigste Compositing-Modus. </font><font style="vertical-align: inherit;">Fast alles, was Sie auf meiner Website sehen, wird in diesem Modus gemischt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assoziativität </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Source-Over-Eigenschaft, die für vor Alpha-multiplizierte Farben ausgeführt wird, ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assoziativität</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Operation. </font><font style="vertical-align: inherit;">Dank ihm können wir in der komplexen Mischungsgleichung die Klammern völlig willkürlich platzieren. </font><font style="vertical-align: inherit;">Alle unten gezeigten Zusammensetzungen sind äquivalent:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (((A⇨B) ⇨C) ⇨D) ⇨E </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (A⇨B) ⇨ (C⇨ (D⇨E)) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = A⇨ (B⇨ (C⇨ (D⇨E))) )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Beweis dafür ist einfach genug, aber ich werde Sie nicht mit algebraischen Manipulationen belasten. </font><font style="vertical-align: inherit;">In der Praxis bedeutet dies, dass wir teilweise komplexe Zeichnungen rendern können, ohne befürchten zu müssen, dass die endgültige Komposition falsch aussieht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den allermeisten Fällen wird Alpha nur für das Compositing mithilfe von Source-Over verwendet, aber seine Vorteile enden hier nicht. </font><font style="vertical-align: inherit;">Alpha-Werte können auch für andere nützliche Rendering-Vorgänge verwendet werden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter-Duff-Compositing </font></font></h1><br>   1984          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“Compositing Digital Images”</a> .       premultiplied alpha     source-over,       -,    ,    .     <em></em> ,                . <br><br><h2> Over </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In zukünftigen Beispielen werden wir interaktive Demos verwenden, die die Funktionsweise verschiedener Mischmodi zeigen. </font><font style="vertical-align: inherit;">Das Zielbild ist das schwarze Symbol „Club“ und das Quellbild ist das rote Symbol „Würmer“. </font><font style="vertical-align: inherit;">Sie können das Herz über das Bild ziehen und beobachten, wie sich die überlappenden Formen unter verschiedenen Compositing-Operatoren verhalten. </font><font style="vertical-align: inherit;">Achten Sie auf die kleine Minikarte in der Ecke. </font><font style="vertical-align: inherit;">Einige Mischmodi sind sehr destruktiv und leicht zu verwechseln. </font><font style="vertical-align: inherit;">Die Minikarte zeigt immer das Ergebnis eines einfachen Source-Over-Compositing, was das Verständnis vereinfacht:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie zum Ziel-Over wechseln, werden Sie sofort feststellen, dass es einfach das Source-Over „umdreht“ - Ziel und Quelle werden in der Gleichung vertauscht, und das Ergebnis entspricht dem, was wir als Ziel als Quellbild betrachten. </font><font style="vertical-align: inherit;">Obwohl es redundant erscheint, ist der Ziel-Over-Operator äußerst nützlich, da Sie damit Objekte erstellen können, die sich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorhandenen Inhalten befinden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Source-Out- und Destination-Out-Anweisungen eignen sich hervorragend zum Stanzen von Löchern in Quelle oder Ziel: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Von diesen beiden Operatoren ist Destination-Out bequemer, da der Alphakanal zum Stanzen von Löchern in der Zielform verwendet wird. </font></font><br><br><h2>  In </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Source-In- und Ziel-In-Operatoren sind im Wesentlichen Maskierungsoperatoren: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= S × R D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= D × R S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie machen es ziemlich einfach, komplexe Schnittpunkte nichttrivialer Geometrie zu erstellen, ohne die relativ schwierig zu berechnenden Schnittpunkte von Vektorkonturen aufzulösen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Operatoren </font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ermöglichen es Ihnen, neue Inhalte mit vorhandenen zu überlagern, während Sie diese entlang des Zielpfads maskieren:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= S × R D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der exklusive OR-Operator ( </font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) speichert </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entweder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelle oder Ziel, und die entsprechenden Bereiche verschwinden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br><blockquote> R = S × (1 − D <sub>A</sub> ) + D × (1 − S <sub>A</sub> ) </blockquote><br><h2> Source, Destination, Clear </h2><br>       . <code>Source</code> ,   <code>copy</code> ,    source. , <code>destination</code>   source    <code>destination</code> .  <code>clear</code>   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br><blockquote> R = S </blockquote><br><blockquote> R = D </blockquote><br><blockquote> R = 0 </blockquote><br>    .   <code>clear</code>    ,     ,    .  ,    <code>source</code> <i> </i>   ,       ,       source. <br><br><h1> -   </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir uns mit einzelnen Operatoren befasst haben, wollen wir sehen, wie Sie sie kombinieren können. </font><font style="vertical-align: inherit;">Im folgenden Beispiel zeichnen wir ein Marine-Logo ohne Maskierung oder komplexe geometrische Formen. </font><font style="vertical-align: inherit;">Die blauen Umrisse zeigen die einfache Geometrie, die erstellt wird. </font><font style="vertical-align: inherit;">Sie können durch die Schritte gehen, indem Sie auf die rechte Seite des Bildes klicken, und zurückgehen, indem Sie auf die linke Seite klicken:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Natürlich sind wir keineswegs verpflichtet, Masken aufzugeben und Konturen zu schneiden, aber wir vergessen oft ein Werkzeug wie den Porter-Duff-Compositing-Modus, obwohl es viel einfacher ist, mit ihrer Hilfe einige visuelle Effekte zu erstellen. </font></font><br><br><h2>  Betreiber </h2><br>     -,   ,      . Source      F <sub>S</sub>    destination,    F <sub>D</sub> : <br><br><blockquote> R = S×F <sub>S</sub> + D×F <sub>D</sub> </blockquote><br> F <sub>S</sub>    0, 1, D <sub>A</sub>  1 − D <sub>A</sub> ,  F <sub>D</sub>    0, 1, S <sub>A</sub>  1 − S <sub>A</sub> .     source  destination    ,      ,     ,       .       : <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  0 </td><td>  1 </td><td> D <sub>A</sub> </td><td> 1 − D <sub>A</sub> </td></tr><tr><td>  0 </td><td>  klar </td><td> source </td><td> source-in </td><td> source-out </td></tr><tr><td>  1 </td><td> destination </td><td></td><td></td><td> destination-over </td></tr><tr><td> S <sub>A</sub> </td><td> destination-in </td><td></td><td></td><td> destination-atop </td></tr><tr><td> 1 − S <sub>A</sub> </td><td> destination-out </td><td> source-over </td><td> source-atop </td><td> xor </td></tr></tbody></table></div><br>       .          ,     . <br><br><h1>   </h1><br>          ,    F <sub>S</sub> ,  F <sub>D</sub>  1.     <code>plus</code> , <code>lighter</code>  <code>plus-lighter</code> : <br><br><blockquote> R = S + D </blockquote><br>     <em></em>  source  destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Bediener implementierte additive Beleuchtung</font></font><code><em>plus</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grün und Rot bilden korrekt Gelb, während Grün und Blau Cyan bilden. </font><font style="vertical-align: inherit;">Schwarz ist das Fehlen einer Operation, es ändert die Farbwerte in keiner Weise, da das Hinzufügen von Null zu einer Zahl nichts ändert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die drei verbleibenden Operatoren erhielten keine Namen, da sie nicht besonders nützlich sind. </font><font style="vertical-align: inherit;">Sie sind nur eine Kombination aus Maskieren und Mischen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erwähnenswert, dass vormultipliziertes Alpha es uns ermöglicht, den Operator auf </font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unerwartete Weise zu verwenden. </font><font style="vertical-align: inherit;">Schauen wir uns die Gleichung noch einmal an:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es uns gelingt, den Alpha-Wert in der Quelle gleich Null zu machen, können wir, wenn die RGB-Kanäle Werte ungleich Null enthalten, eine additive Beleuchtung erzielen, ohne den Operator zu verwenden </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additive Beleuchtung mit dem Operator implementiert</font></font><code><em>source-over</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass Sie hier vorsichtig sein müssen - die Werte werden nicht mehr korrekt mit Alpha multipliziert. In einigen Programmen kann es eine Optimierung geben, die das Mischen von Farben mit null Alpha vollständig vermeidet, während andere Programme die Vormultiplikation mit Alpha-Werten umkehren, einige Farboperationen ausführen und dann erneut mit Alpha multiplizieren können, wodurch die Farbkanäle vollständig zerstört werden. Es kann auch schwierig sein, Ressourcen in diesem Format zu exportieren. Wenn Sie also nicht die vollständige Kontrolle über die Rendering-Pipeline haben, sollten Sie sich an den Operator halten </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Elemente, die wir diskutieren, wurden bisher gut kombiniert. </font><font style="vertical-align: inherit;">Nehmen wir nun unsere rosa Brille ab und diskutieren einige Probleme, die bei der Arbeit mit Alpha-Compositing berücksichtigt werden müssen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gruppenopazität </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werfen wir einen Blick auf diese einfache Pillenzeichnung, die nur aus sechs Grundelementen besteht: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnen einer Pille mit einfachen Formen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir gebeten würden, eine Pille mit einer Deckkraft von 50% zu rendern, könnten wir versucht sein, die Deckkraft einfach in die Hälfte jeder Zeichenoperation aufzuteilen, aber dies würde sich als fehlerhafte Entscheidung herausstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerwartetes Ergebnis beim Rendern einer Pille mit halber Deckkraft.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um das richtige Ergebnis zu erzielen, können wir die Deckkraft eines Objekts nicht einfach auf jede seiner einzelnen Komponenten verteilen. </font><font style="vertical-align: inherit;">Wir müssen zuerst ein Objekt erstellen, es in eine Bitmap rendern und erst </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Deckkraft der Bitmap ändern und schließlich das Compositing durchführen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erwartetes Ergebnis beim Rendern einer Pille mit halber Deckkraft</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein weiterer Fall, der die Nützlichkeit des Konzepts des Renderns in einen Seitenpuffer demonstriert.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compositing-Abdeckung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Konvertieren einer geometrischen Abdeckung in einen einzelnen Alpha-Wert hat unangenehme Folgen. </font><font style="vertical-align: inherit;">Betrachten Sie den Fall, in dem zwei ideal übereinstimmende Kanten von Vektorgeometriefiguren, die in der folgenden Abbildung mit orangefarbenen und blauen Konturen dargestellt sind, in eine Bitmap gerendert werden. </font><font style="vertical-align: inherit;">In einer idealen Welt sollten die Ergebnisse ungefähr so ​​aussehen, da jedes Pixel vollständig geschlossen ist:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein ideales Rendering-Ergebnis mit der richtigen Abdeckung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir jedoch zuerst die orange Geometrie und dann die blaue Geometrie rendern, leckt im endgültigen Bild immer noch ein kleiner weißer Hintergrund in die Randpixel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis des zweistufigen Compositing</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobald die Beschichtung im Alpha-Kanal gespeichert ist, gehen alle geometrischen Informationen verloren und wir können sie in keiner Weise wiederherstellen. Die blaue Geometrie mischt sich einfach mit einem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalts des Puffers, weiß jedoch nicht, dass die durch die rötlichen Pixel dargestellte Geometrie mit dieser übereinstimmen muss. Dieses Problem macht sich insbesondere dann bemerkbar, wenn sich Geometrien präzise überlagern. Im Bild unten wird ein weißer Kreis über einen schwarzen gezeichnet. Dunkle Kanten sind erkennbar, obwohl beide Kreise </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau den gleichen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radius und </font><em><font style="vertical-align: inherit;">die gleiche</font></em><font style="vertical-align: inherit;"> Position haben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weißer Kreis über einem schwarzen Kreis</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Möglichkeit, dieses Problem zu beheben, besteht darin </font><font style="vertical-align: inherit;">, die Teilabdeckung der Pixel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht zu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnen und erheblich größere Puffer zu verwenden. Durch Rastern der Vektorgeometrie mit einer einfachen In / Out-Beschichtung und anschließendes Reduzieren der Skalierung des Ergebnisses auf die Größe des Originalbilds können Sie das erwartete Ergebnis erzielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für einen perfekten Vergleich der Renderqualität der Kanten des 8-Bit-Alpha-Kanals sollten die Puffer in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beiden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Richtungen </font><font style="vertical-align: inherit;">256-mal größer sein, dh </font><font style="vertical-align: inherit;">die Anzahl der Pixel sollte um 2 bis </font><sup><font style="vertical-align: inherit;">16</font></sup><font style="vertical-align: inherit;"> erhöht werden</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mal. </font><font style="vertical-align: inherit;">Wie wir oben gesehen haben, können Sie zwar die Bittiefe für Abdeckungswerte verringern, aber dennoch zufriedenstellende Ergebnisse erzielen, sodass Sie in der Praxis einen kleineren Maßstab verwenden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erwähnenswert, dass solche Probleme oft ohne die Verwendung großer Bitmaps relativ leicht vermieden werden können. </font><font style="vertical-align: inherit;">Anstatt beispielsweise zwei übereinanderliegende Kreise zu zeichnen, können Sie einfach zwei Quadrate übereinander zeichnen und </font><font style="vertical-align: inherit;">das Ergebnis </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maskieren, um einen Kreis zu bilden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lineare Werte </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihr Wissen über </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbräume</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktualisiert haben </font><font style="vertical-align: inherit;">, können Sie sich daran erinnern, dass die meisten von ihnen Farbwerte nicht linear codieren und eine vorläufige Linearisierung erforderlich ist, um die korrekten mathematischen Operationen auszuführen. </font><font style="vertical-align: inherit;">Wenn diese Phase abgeschlossen ist, ist das Ergebnis des Zusammensetzens wie folgt; </font><font style="vertical-align: inherit;">Achten Sie auf die schöne gelbliche Färbung der übereinanderliegenden Teile:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unscharfe rote Kreise, die durch Zusammensetzen auf einem grünen Hintergrund unter Verwendung linearer Werte überlagert werden.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In den meisten Fällen ist das Zusammensetzen jedoch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Fall </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Standardmethode für das Web und die meisten Grafikprogramme besteht darin, nichtlineare Werte direkt zu mischen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unscharfe rote Kreise, die von einem Komponisten auf einem grünen Hintergrund mit nichtlinearen Werten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> überlagert werden. Beachten Sie, dass die Bereiche, in denen sich Rot auf Grün überlagert, viel dunkler sind. </font><font style="vertical-align: inherit;">Sie sind alles andere als ideal, aber in einigen Fällen sind falsche Operationen tief verwurzelt im Verständnis, wie wir Farbe wahrnehmen. </font><font style="vertical-align: inherit;">Zum Beispiel sieht 50% undurchsichtiges Grau aus dem sRGB-Bereich genauso aus wie reines Schwarz mit 50% Deckkraft gemischt mit einem weißen Hintergrund:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammensetzen von zwei Farben auf weißem Hintergrund</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ohne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearisierung</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der folgenden Abbildung werden die sRGB-Farben der Quell- und Zielbilder linearisiert und dann zur Anzeige wieder in eine nichtlineare Codierung konvertiert. </font><font style="vertical-align: inherit;">So sollten diese Farben eigentlich aussehen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammensetzung von zwei Farben auf weißem Hintergrund</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearisierung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben eine Diskrepanz, die nicht unseren Erwartungen entspricht. </font><font style="vertical-align: inherit;">Die einzige Möglichkeit, mit dieser Methode eine visuelle Einheitlichkeit zu erzielen, besteht darin, alle Farben mit linearen Werten auszuwählen. Dies unterscheidet sich jedoch stark von dem, was jeder gewohnt ist. </font><font style="vertical-align: inherit;">50% Grau mit linearen Werten sieht auf 73,5% des sRGB-Speicherplatzes wie Grau aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus müssen Sie besonders vorsichtig sein, wenn Sie mit vormultipliziertem Alpha arbeiten. </font><font style="vertical-align: inherit;">Die Vormultiplikation muss mit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgeführt werden, d.h. </font><font style="vertical-align: inherit;">vor dem Codieren auf nichtlinear. </font><font style="vertical-align: inherit;">Aus diesem Grund endet der Linearisierungsschritt korrekt mit den korrekten linearen Werten, die zuvor mit Alpha multipliziert wurden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorvervielfachte Alpha- und Bittiefe </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz seiner großen Nützlichkeit für Compositing, Filterung und Interpolation ist vormultipliziertes Alpha keine „Silberkugel“ und hat seine Nachteile. </font><font style="vertical-align: inherit;">Am schwerwiegendsten ist die Verringerung der Bittiefe der Farben, die man sich vorstellen kann. </font><font style="vertical-align: inherit;">Stellen Sie sich eine 8-Bit-Codierung mit einem Wert von 150 vor, die mit Alpha 20% vormultipliziert wird. </font><font style="vertical-align: inherit;">Nach vorläufiger Multiplikation mit Alpha erhalten wir</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rund (150 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir das gleiche Verfahren mit einem Wert von 151 wiederholen, erhalten wir: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rund (151 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der codierte Wert bleibt trotz der unterschiedlichen Anfangswerte gleich. </font><font style="vertical-align: inherit;">Tatsächlich werden nach dem Multiplizieren mit Alpha die Werte von 148, 149, 150, 151 und 152 in 30 codiert, und der ursprüngliche Unterschied zwischen diesen fünf eindeutigen Farben geht verloren:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vormultiplikation mit Alpha von 20% reduziert die verschiedenen 8-Bit-Werte auf eins.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je kleiner das Alpha ist, desto zerstörerischer ist natürlich seine Wirkung. Von dem möglichen Bereich von 256 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ungefähr 4,3 Milliarden) verschiedener Kombinationen von 8-Bit-RGBA-Werten behalten nach vorläufiger Multiplikation mit Alpha nur 25,2% eine eindeutige Darstellung; Tatsächlich verlieren wir fast 2 Bits aus dem 32-Bit-Bereich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Farben zwischen verschiedenen Farbräumen umzuwandeln, ist es manchmal erforderlich, die vorläufige Multiplikation umzukehren, dh die Werte durch die Alpha-Komponente zu teilen, um die ursprüngliche Farbhelligkeit zu erhalten. Dieser Schritt ist erforderlich, da, wie oben erwähnt, die Codierung nicht linear durchgeführt wird. Das Vorhandensein einer Vormultiplikation verringert die Genauigkeit der Farbdarstellung, und die Konvertierungen zwischen Farbräumen können unvollständig sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Praxis ist die Reduzierung der Bittiefe selten wichtig, insbesondere beim Compositing. Je niedriger der Alpha-Wert, desto weniger sichtbar ist die Farbe und desto weniger Einfluss hat sie auf das Compositing. Wenn Sie pedantisch genaue Farboperationen anstreben, werden Sie letztendlich nicht deren 8-Bit-Darstellung verwenden - für diesen Zweck sind Formate viel besser geeignet</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleitkomma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusätzliche Lektüre </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Konzept des Alpha-Kanals wurde von den Pixar-Studio-Mitbegründern </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell entwickelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Smiths Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Alpha und die Geschichte des digitalen Compositing“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt die Geschichte der Erfindung und die Quellen des Namens „Alpha“ sowie die Entwicklung dieser Konzepte und die schrittweise Ersetzung des Konzepts der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Filmproduktion </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Bedeutung von Alpha zu verstehen, empfehle ich Ihnen dringend, Andrew Glassners </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Interpreting Alpha“ zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. Dieser Artikel bietet eine strenge, aber sehr leicht zugängliche mathematische Ableitung von Alpha als Maß für die Wechselwirkung zwischen Opazität und Abdeckung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine ausführliche Diskussion des vormultiplizierten Alphas kann in untersucht werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"GPUs bevorzugen Vormultiplikation" von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eric Haines. Der Artikel bietet nicht nur einen hervorragenden Überblick über die Probleme, die durch das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlen einer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorläufigen Multiplikation, insbesondere beim 3D-Rendering, </font><font style="vertical-align: inherit;">verursacht werden </font><font style="vertical-align: inherit;">, sondern enthält auch Links zu vielen anderen Artikeln zu diesem Thema.</font></font><br><br><h1>  Abschließend </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ursprünglich war dieser Artikel als Erklärung der Porter-Duff-Compositing-Operatoren gedacht, aber alle anderen Konzepte im Zusammenhang mit Alpha-Compositing erwiesen sich als so interessant, dass ich sie nicht übersehen konnte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was mir an Alpha am besten gefällt, ist, dass es nur eine zusätzliche Zahl ist, die RGB-Komponenten begleitet, aber gleichzeitig viele einzigartige Rendering-Funktionen bietet. </font><font style="vertical-align: inherit;">Alpha hat buchstäblich eine neue Chance in der langweiligen alten Welt des Compositing und 2D-Renderings geschaffen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das nächste Mal die glatten Kanten von Vektorformen sehen oder eine dunkle Überlagerung bemerken, die einige Teile der Benutzeroberfläche verdeckt, denken Sie an eine kleine, aber leistungsstarke Komponente, die alles möglich gemacht hat.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468067/">https://habr.com/ru/post/de468067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468057/index.html">Unix-ähnliche Betriebssystementwicklung - Multitasking und Systemaufrufe (7)</a></li>
<li><a href="../de468059/index.html">Meine zweite Woche mit Haiku: viele versteckte Diamanten und angenehme Überraschungen sowie einige Probleme</a></li>
<li><a href="../de468061/index.html">Cron unter Linux: Verlauf, Verwendung und Gerät</a></li>
<li><a href="../de468063/index.html">Angulareact</a></li>
<li><a href="../de468065/index.html">Mentale Produktmanagementmodelle für alle</a></li>
<li><a href="../de468071/index.html">Eduard Medwedew, CTO bei Tungsten Labs: „Wir sind so weit gewachsen, dass Technologie massiven Schaden anrichten kann.“</a></li>
<li><a href="../de468073/index.html">Andrei Terekhov: "Sie können so viel sagen, wie Sie möchten, dass Amerikaner besser sind, aber unser Auto bricht nie zusammen."</a></li>
<li><a href="../de468075/index.html">Die Verwendung von siamesischen neuronalen Netzen bei der Suche</a></li>
<li><a href="../de468077/index.html">Posit-Tests für Erwachsene. Spektralanalyse</a></li>
<li><a href="../de468079/index.html">Benutzerdefinierte Dimensionen in Google Analytics, die uns mehr als einmal gespeichert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>