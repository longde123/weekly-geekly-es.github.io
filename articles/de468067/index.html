<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üõÑ üë®üèº‚Äçüåæ So funktioniert Alpha Compositing üôãüèª üßëüèø‚Äçü§ù‚Äçüßëüèª ü§±üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transparenz scheint kein interessantes Thema zu sein. Das GIF-Format, mit dem einige Pixel durch den Hintergrund scheinen konnten, wurde vor √ºber 30 J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Alpha Compositing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="Bild"></div><br>  Transparenz scheint kein interessantes Thema zu sein.  Das GIF-Format, mit dem einige Pixel durch den Hintergrund scheinen konnten, wurde vor √ºber 30 Jahren ver√∂ffentlicht.  Nahezu jede in den letzten zwei Jahrzehnten ver√∂ffentlichte Grafikdesign-Anwendung unterst√ºtzt die Erstellung durchscheinender Inhalte.  Diese Konzepte sind l√§ngst nichts Neues mehr. <br><br>  In meinem Artikel m√∂chte ich zeigen, dass Transparenz in digitalen Bildern tats√§chlich viel interessanter ist, als es scheint - in dem, was wir f√ºr selbstverst√§ndlich halten, gibt es eine unsichtbare Tiefe und Sch√∂nheit. <br><a name="habracut"></a><br><h1>  Deckkraft </h1><br>  Wenn Sie jemals durch eine rosa Brille geschaut haben, k√∂nnen Sie etwas √Ñhnliches wie in der folgenden Abbildung sehen.  [Im Originalartikel sind viele Bilder interaktiv.] Versuchen Sie, die Brille zu bewegen, um zu sehen, wie sie sich auf das auswirkt, was durch sie sichtbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br>  Solche Brillen funktionieren wie folgt: Sie vermissen viel Rot, eine ordentliche Menge Blau und sehr wenig Gr√ºn.  Die Mathematik dieser Punkte kann in drei Gleichungen geschrieben werden.  Der Buchstabe <strong>R</strong> gibt das Ergebnis der Operation an, und der Buchstabe <strong>D</strong> beschreibt den Punkt, den wir betrachten.  RGB-Indizes geben rote, gr√ºne und blaue Komponenten an: <br><br><blockquote><code>R <sub>R</sub> = D <sub>R</sub> √ó 1.0 <br> R <sub>G</sub> = D <sub>G</sub> √ó 0.7 <br> R <sub>B</sub> = D <sub>B</sub> √ó 0.9</code> </blockquote> <br>  Dieses Buntglas √ºbertr√§gt rote, gr√ºne und blaue Komponenten des Hintergrunds mit unterschiedlichen St√§rken.  Mit anderen Worten, die <em>Transparenz einer</em> rosa Brille h√§ngt von der Farbe des einfallenden Lichts ab.  Im Allgemeinen kann die Transparenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Abh√§ngigkeit von der Wellenl√§nge des Lichts variieren.</a> In diesem vereinfachten Beispiel interessiert uns jedoch nur, wie sich Brillen auf die klassischen RGB-Komponenten auswirken. <br><br>  Die Simulation des Verhaltens gew√∂hnlicher Sonnenbrillen ist viel einfacher. Sie d√§mpfen das einfallende Licht normalerweise nur um einen gewissen Betrag: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br>  Diese Gl√§ser lassen nur 30% des Lichts durch.  Ihr Verhalten kann durch die folgenden Gleichungen beschrieben werden: <br><br><blockquote> <code>R <sub>R</sub> = D <sub>R</sub> √ó 0.3 <br> R <sub>G</sub> = D <sub>G</sub> √ó 0.3 <br> R <sub>B</sub> = D <sub>B</sub> √ó 0.3</code> </blockquote> <br>  Alle drei Farbkomponenten werden um den gleichen Wert reduziert - die Absorption des einfallenden Lichts ist gleich.  Wir k√∂nnen sagen, dass dunkle Brillen zu 30% transparent (undurchsichtig) oder zu 70% undurchsichtig sind.  <em>Die Deckkraft eines</em> Objekts bestimmt, wie viel Farbe es blockiert.  In der Computergrafik handelt es sich normalerweise um ein vereinfachtes Modell, bei dem nur ein Wert zur Beschreibung dieser Eigenschaft ben√∂tigt wird.  Die Opazit√§t kann r√§umlich variieren.  wie zum Beispiel eine Rauchs√§ule, die h√∂her und transparenter wird. <br><br>  In der realen Welt sind Objekte mit einer Deckkraft von 100% einfach undurchsichtig und lassen √ºberhaupt kein Licht durch.  Die Welt der digitalen Bilder ist etwas anders.  Es gibt Grenzf√§lle, in denen selbst feste undurchsichtige Objekte eine bestimmte Lichtmenge passieren. <br><br><h1>  Abdeckung </h1><br>  Vektorgrafiken befassen sich mit klaren und unendlich genauen Beschreibungen von Formen, die mithilfe von Punkten, Liniensegmenten, Bezier-Kurven und anderen mathematischen Grundelementen definiert wurden.  Wenn Sie Zahlen auf einem Computerbildschirm anzeigen m√ºssen, m√ºssen diese einwandfreien Entit√§ten in eine Bitmap gerastert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>  <i>Rasterisierung einer Vektorform zu einer Bitmap</i> <br><br>  Die primitivste Methode zum Rastern besteht darin, zu √ºberpr√ºfen, wo sich die Pixelprobe befindet - innerhalb oder au√üerhalb der Vektorform.  In den folgenden Beispielen k√∂nnen Sie das Dreieck ziehen. In einer vergr√∂√üerten Ansicht sind die Bewegungen genauer.  Ein blauer Umriss zeigt die urspr√ºngliche Vektorgeometrie an.  Wie Sie sehen k√∂nnen, sieht die Leiter an den R√§ndern des Dreiecks h√§sslich aus und flackert beim Verschieben der Geometrie stark: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br>  Der Nachteil dieses Ansatzes besteht darin, dass wir nur eine Pr√ºfung f√ºr jedes angezeigte Pixel durchf√ºhren und die Ergebnisse auf einen von zwei m√∂glichen Werten diskretisiert werden - innen oder au√üen. <br><br>  Sie k√∂nnen die Vektorgeometrie mehrmals pro Pixel abtasten, um eine gro√üe Abstufung der Schritte zu erhalten und zu entscheiden, dass einige Pixel nur <em>teilweise</em> geschlossen sind.  Eine m√∂gliche L√∂sung besteht darin, vier Abtastpunkte zu verwenden, um f√ºnf Abdeckungsgrade darzustellen: 0, <sup>1</sup> ‚ÅÑ <sub>4</sub> , <sup>2</sup> ‚ÅÑ <sub>4</sub> , <sup>3</sup> ‚ÅÑ <sub>4</sub> und 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br>  Die Qualit√§t der Kanten des Dreiecks hat sich verbessert, aber nur f√ºnf m√∂gliche Abdeckungsstufen reichen oft nicht aus, und wir k√∂nnen leicht ein viel besseres Ergebnis erzielen.  Obwohl die Ansicht eines Pixels als kleines Quadrat in der Welt der Signalverarbeitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit Missbilligung betrachtet wird</a> , ist es in einigen Zusammenh√§ngen ein n√ºtzliches Modell, mit dem wir die genaue Abdeckung eines Pixels anhand der Vektorgeometrie berechnen k√∂nnen.  Der Schnittpunkt einer Linie und eines Quadrats kann immer in ein <i>Trapez</i> und ein <i>Rechteck</i> zerlegt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="Bild"></div><br>  <i>Ein Liniensegment teilt ein Quadrat in ein Trapez und ein Rechteck</i> <br><br>  Sie k√∂nnen die Fl√§che beider Teile leicht berechnen, und ihre Summe geteilt durch die Fl√§che des Quadrats bestimmt den Prozentsatz der Pixelabdeckung.  Somit wird die Abdeckung als exakte Zahl mit beliebiger Genauigkeit berechnet.  In der unten gezeigten Demo wird diese Methode verwendet, um viel bessere Kanten zu rendern, die auch beim Ziehen eines Dreiecks glatt bleiben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br>  Wenn es um komplexere Formen geht, z. B. Ellipsen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beziers</a> , werden diese h√§ufig in einfache gerade Liniensegmente unterteilt, mit denen Sie die Abdeckung mit der richtigen Genauigkeit berechnen k√∂nnen. <br><br>  Das Konzept der teilweisen Abdeckung ist entscheidend f√ºr das qualitativ hochwertige Rendern von Vektorgrafiken und vor allem f√ºr das Rendern von Text.  Wenn Sie einen Screenshot dieses Artikels machen und ihn sorgf√§ltig pr√ºfen, werden Sie feststellen, dass fast alle Kanten der Glyphen Pixel nur teilweise abdecken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>  <i>Teilabdeckung wird beim Rendern von Text aktiv verwendet</i> <br><br>  Wenn Sie die Deckkraft des Objekts haben und es mit einzelnen Pixeln bedecken, k√∂nnen Sie diese zu einem Wert kombinieren. <br><br><h1>  Alpha </h1><br>  Das Produkt aus der Opazit√§t eines Objekts und seiner Pixelabdeckung hei√üt <em>Alpha</em> : <br><br><blockquote> <code> =  √ó </code> </blockquote> <br>  Ein Objekt mit einer Deckkraft von 60%, das 30% der Pixelfl√§che abdeckt, hat in diesem Pixel einen Alpha-Wert von 18%.  Wenn das Objekt transparent ist oder das Pixel nicht vollst√§ndig bedeckt, ist der Alpha-Wert in diesem Pixel nat√ºrlich 0. Nach der Multiplikation verschwinden die Unterschiede zwischen Opazit√§t und Beschichtung, was in gewissem Sinne die Tatsache rechtfertigt, dass die Konzepte "Alpha" und "Opazit√§t" als Synonyme verwendet werden. <br><br>  Alpha wird oft als vierter Kanal eines Bitmap-Bildes dargestellt.  Die √ºblichen Werte f√ºr Rot, Gr√ºn und Blau werden durch einen Alpha-Wert erg√§nzt, der vier RGBA-Werte bildet. <br><br>  Wenn es darum geht, Alpha-Werte im Speicher zu speichern, besteht die Versuchung, nur wenige Bits daf√ºr zu verwenden.  Im Fall der Abdeckung der Pixel der Kanten von undurchsichtigen Objekten scheinen 4 oder sogar 3 Bits je nach Pixeldichte des Bildschirms v√∂llig ausreichend zu sein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br>  Die Deckkraft wirkt sich jedoch auch auf den Alpha-Wert aus, sodass eine geringe Bittiefe in einigen F√§llen katastrophal sein kann, wenn sich die Transparenz reibungslos √§ndert.  Das Bild unten zeigt einen Farbverlauf von undurchsichtigem Schwarz nach Wei√ü, der zeigt, dass eine geringe Bittiefe zu sehr starken Farbabweichungen f√ºhrt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br>  Je mehr Bits, desto besser und am h√§ufigsten verwendet Alpha 8 eine Bittiefe von 8, um der Genauigkeit der Farbkomponenten zu entsprechen, weshalb viele RGBA-Puffer 32 Bit pro Pixel belegen.  Es ist auch erw√§hnenswert, dass im Gegensatz zu Farbkomponenten, die h√§ufig mit nichtlinearer Transformation codiert werden, Alpha linear gespeichert wird - der codierte Wert von 0,5 entspricht einem Alpha-Wert von 0,5. <br><br>  In Bezug auf Alpha haben wir alle anderen Farbkomponenten vollst√§ndig ignoriert, aber zus√§tzlich zum Blockieren der Hintergrundfarbe kann das Pixel selbst ein wenig Farbe hinzuf√ºgen.  Die Idee ist ganz einfach: Ein durchscheinendes rosa Objekt blockiert einen Teil der einfallenden Hintergrundbeleuchtung und sendet oder reflektiert ein wenig rosa Licht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br>  Beachten Sie, dass es sich <em>nicht</em> wie Buntglas verh√§lt.  Glas blockiert einfach einen Teil der Hintergrundbeleuchtung mit unterschiedlicher Helligkeit.  Wenn Sie ein vollst√§ndig schwarzes Objekt durch rosa Glas betrachten, bleibt seine Schw√§rze erhalten, da das schwarze Objekt kein Licht emittiert und reflektiert.  Das durchscheinende rosa Objekt <em>f√ºgt jedoch</em> sein eigenes Licht hinzu.  Wenn Sie es auf ein schwarzes Objekt legen, ist das Ergebnis rosa.  Ein gutes Analogon zu diesem Verhalten ist feines Material, das in der Luft schwebt, wie Dunst, Rauch, Nebel oder etwas farbiges Pulver. <br><br>  Das Rendern eines Alphakanals ist etwas schwieriger - ein perfekt transparentes Objekt ist per Definition unsichtbar. Um zwischen Objekten zu unterscheiden, m√ºssen zwei Tricks angewendet werden.  Ein Schachbretthintergrund zeigt an, welche Teile des Bildes transparent sind.  Dieses Muster wird in vielen grafischen Anwendungen verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>  <i>Schachmuster zeigt transparente Figuren.</i> <br><br>  Die vier kleinen Quadrate unter dem Bild zeigen an, dass wir die roten, gr√ºnen, blauen und Alpha-Komponenten des Bildes sehen.  In einigen F√§llen ist es n√ºtzlich, die Alphakanalwerte direkt anzuzeigen, und die einfachste M√∂glichkeit, sie anzuzeigen, ist die Verwendung von Graustufen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>  <i>Zeigen Sie RGB- und A-Werte auf verschiedenen Oberfl√§chen an</i> <br><br>  Je heller der Grauton ist, desto h√∂her ist der Alpha-Wert, dh reines Schwarz entspricht 0% Alpha und reines Wei√ü 100% Alpha.  Kleine Quadrate zeigen an, dass die RGB- und A-Komponenten des Bildes in zwei Teile unterteilt sind. <br><br>  Die Alpha-Komponente selbst ist nicht besonders n√ºtzlich, aber sie wird sehr wichtig, wenn wir √ºber Compositing sprechen. <br><br><h1>  Einfaches Compositing </h1><br>  In einem Arbeitsgang k√∂nnen nur sehr wenige Effekte des 2D-Renderings implementiert werden. Um ein fertiges Ergebnis zu erzielen, verwenden wir einen <em>Compositing-</em> Prozess, bei dem verschiedene Bilder kombiniert werden.  Zum Beispiel kann eine einfache Schaltfl√§che "Abbrechen" erstellt werden, indem f√ºnf separate Elemente zusammengesetzt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div><br>  <i>Zusammensetzen von Elementen f√ºr die Schaltfl√§che Abbrechen</i> <br><br>  Das Zusammensetzen erfolgt h√§ufig in mehreren Schritten, in denen jeweils zwei Bilder kombiniert werden.  Das beim Zusammensetzen verwendete Vordergrundbild wird √ºblicherweise als <em>Quelle bezeichnet</em> .  Das beim Compositing verwendete Hintergrundbild, dem die Quelle √ºberlagert ist, wird normalerweise als <em>Ziel bezeichnet</em> . <br><br>  Wir beginnen mit dem Compositing auf einem undurchsichtigen Hintergrund, da dies ein sehr h√§ufiger Fall ist.  Alles, was Sie auf dem Bildschirm sehen, wird letztendlich durch Compositing an einem undurchsichtigen Ziel √ºberlagert. <br><br>  Wenn der Alpha-Wert der Quelle 100% betr√§gt, ist die Quelle undurchsichtig und sollte das Ziel vollst√§ndig abdecken.  Wenn der Alpha-Wert 0% betr√§gt, ist die Quelle vollst√§ndig transparent und hat keinerlei Einfluss auf das Ziel.  Ein Alpha-Wert von 25% erm√∂glicht es dem Objekt, 25% seines Lichts zu emittieren und 75% des Lichts vom Hintergrund zu leiten, und so weiter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>  <i>Zusammenstellen einer lila Quelle mit unterschiedlichen Alpha-Werten zum gelben Ziel</i> <br><br>  Sie k√∂nnen bereits verstehen, was alles passieren wird - ein einfacher Fall von Alpha-Compositing auf einem undurchsichtigen Hintergrund - es ist nur eine lineare Interpolation zwischen den Ziel- und Quellfarben.  In der folgenden Grafik steuert der Schieberegler den Alpha-Wert der Quelle, und in den roten, gr√ºnen und blauen Grafiken werden die Werte der RGB-Komponenten angezeigt.  Das Ergebnis von <strong>R</strong> ist nur eine Mischung zwischen Quelle <strong>S</strong> und Ziel <strong>D</strong> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br>  Was hier passiert, kann durch die unten gezeigten Gleichungen beschrieben werden.  Wie zuvor bezeichnet der Index die Komponente, dh <sub>SA</sub> ist der Alpha-Wert in der Quelle und D <sub>G</sub> ist der gr√ºne Wert im Ziel: <br><br><blockquote> <code>R <sub>R</sub> = S <sub>R</sub> √ó S <sub>A</sub> + D <sub>R</sub> √ó (1 ‚àí S <sub>A</sub> ) <br> <br> R <sub>G</sub> = S <sub>G</sub> √ó S <sub>A</sub> + D <sub>G</sub> √ó (1 ‚àí S <sub>A</sub> ) <br> <br> R <sub>B</sub> = S <sub>B</sub> √ó S <sub>A</sub> + D <sub>B</sub> √ó (1 ‚àí S <sub>A</sub> )</code> </blockquote> <br>  Die Gleichungen f√ºr die roten, gr√ºnen und blauen Komponenten sehen gleich aus. Sie k√∂nnen also einfach den <sub>RGB-</sub> Index verwenden und sie in einer Zeile kombinieren: <br><br><blockquote> <code>R <sub>RGB</sub> = S <sub>RGB</sub> √ó S <sub>A</sub> + D <sub>RGB</sub> √ó (1 ‚àí S <sub>A</sub> )</code> </blockquote> <br>  Da das Ziel undurchsichtig ist und bereits das gesamte Hintergrundlicht blockiert, wissen wir au√üerdem, dass der Alpha-Wert des Ergebnisses immer 1 ist: <br><br><blockquote> <code>R <sub>A</sub> = 1</code> </blockquote> <br>  Das Zusammensetzen auf einem undurchsichtigen Hintergrund ist einfach, aber in seinen F√§higkeiten ziemlich begrenzt.  In vielen F√§llen ist eine zuverl√§ssigere L√∂sung erforderlich. <br><br><h1>  Zwischenpuffer </h1><br>  Das folgende Bild zeigt den zweistufigen Prozess des Zusammensetzens von drei verschiedenen Schichten mit den Bezeichnungen A, B und C. Das Symbol ‚á® bedeutet "durch Zusammensetzen √ºberlagert": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>  <i>Das Ergebnis einer zweistufigen Zusammenstellung von drei Schichten</i> <br><br>  Zuerst √ºberlagern wir B mit C, indem wir komponieren, und √ºberlagern dann A mit ihnen, um das fertige Bild zu erhalten.  Im folgenden Beispiel werden wir die Dinge etwas anders machen.  Zuerst verbinden wir die beiden obersten Ebenen durch Zusammensetzen und √ºberlagern dann das Ergebnis mit dem letzten Ziel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>  <i>Das Ergebnis einer zweistufigen Zusammenstellung von drei Schichten in unterschiedlicher Reihenfolge</i> <br><br>  Sie fragen sich wahrscheinlich, ob eine solche Situation in der Praxis auftritt, aber tats√§chlich ist sie sehr h√§ufig.  Viele nicht triviale Compositing-Operationen und Rendering-Effekte, wie z. B. Maskieren und Verwischen, erfordern das Durchlaufen eines Zwischenpuffers, der nur teilweise Compositing-Ergebnisse enth√§lt.  Dieses Konzept hat unterschiedliche Namen: Offscreen-Durchg√§nge, Transparenzebenen oder Seitenpuffer, aber normalerweise basieren sie auf derselben Idee. <br><br>  Was f√ºr uns wichtiger ist, ist, dass fast <em>jedes</em> Bild mit Transparenz als Teilergebnis eines Renderings wahrgenommen werden kann, das sp√§ter durch Zusammensetzen des letzten Ziels √ºberlagert wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>  <i>Teilweise Zusammenstellung einer Schaltfl√§che in einer Zwischenablage</i> <br><br>  Wir m√ºssen verstehen, wie das Zusammensetzen der durchscheinenden Bilder A und B durch ein Bild (A‚á®B) mit derselben Farbe und Deckkraft ersetzt werden kann.  Beginnen wir mit der Berechnung des Alpha-Werts des endg√ºltigen Puffers. <br><br><h1>  Alpha-Werte kombinieren </h1><br>  Es ist Ihnen vielleicht nicht klar, wie Sie die Deckkraft zweier Objekte kombinieren sollen, aber es ist einfacher, √ºber diese Aufgabe zu sprechen, wenn wir stattdessen √ºber Transparenz sprechen. <br><br>  Angenommen, eine bestimmte Lichtmenge tritt durch das erste Objekt und dann durch das zweite Objekt.  Wenn die Transparenz des ersten Objekts 80% betr√§gt, werden 80% des einfallenden Lichts durchgelassen.  In √§hnlicher Weise l√§sst ein zweites Objekt mit 60% Transparenz 60% des Lichts durch, was 60% √ó 80% = 48% des urspr√ºnglichen Lichts ergibt.  Sie k√∂nnen im Originalartikel mit Transparenz experimentieren.  Vergessen Sie nicht, dass die Schieberegler die <em>Transparenz</em> und nicht die Deckkraft von Objekten im Lichtweg steuern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br>  Wenn entweder das erste oder das zweite Objekt undurchsichtig ist, tritt nat√ºrlich kein Licht durch sie hindurch, selbst ein anderes ist vollst√§ndig transparent. <br><br>  Wenn Objekt D Transparenz D <sub>T</sub> hat und Objekt S Transparenz S <sub>T hat</sub> , ist die endg√ºltige allgemeine Transparenz R <sub>T</sub> dieser beiden Objekte gleich ihrem Produkt: <br><br><blockquote>  R <sub>T</sub> = D <sub>T</sub> √ó S <sub>T.</sub> </blockquote><br>  Transparenz ist jedoch nur eine Einheit minus Alpha, sodass wir durch Substitution Folgendes erhalten: <br><br><blockquote>  1 - R <sub>A</sub> = (1 - D <sub>A</sub> ) √ó (1 - S <sub>A</sub> ) </blockquote><br>  Dieser Ausdruck kann erweitert werden in: <br><br><blockquote>  1 - R <sub>A</sub> = 1 - D <sub>A</sub> - S <sub>A</sub> + D <sub>A</sub> √ó S <sub>A.</sub> </blockquote><br>  Und vereinfachen Sie es so: <br><br><blockquote>  R <sub>A</sub> = DA + SA - DA √ó SA </blockquote><br>  Es kann auf einen von zwei √§hnlichen Typen reduziert werden: <br><br><blockquote>  R <sub>A</sub> = SA + DA √ó (1 - SA) <br><br>  R <sub>A</sub> = DA + SA √ó (1 - DA) </blockquote><br>  Bald werden wir sehen, dass die zweite h√§ufiger verwendet wird.  Es ist auch interessant festzustellen, dass der resultierende Alpha-Wert nicht von der relativen Reihenfolge der Objekte abh√§ngt - die Deckkraft der resultierenden Pixel ist dieselbe, selbst wenn Sie die Quelle und das Ziel vertauschen.  Das ist sehr logisch.  Das Licht, das durch zwei Objekte f√§llt, sollte auf dieselbe Weise von jeder Seite des Sterns, von vorne oder von hinten, ausgeblendet werden. <br><br><h1>  Farbkombination </h1><br>  Die Berechnung von Alpha war nicht so schwierig. Versuchen wir also, die Berechnungen von RGB-Komponenten zu verstehen.  Das Quellbild hat die Farbe S <sub>RGB</sub> , aber seine Deckkraft S <sub>A</sub> zwingt nur das Produkt dieser beiden Werte in das Endergebnis: <br><br><blockquote>  S <sub>RGB</sub> √ó S <sub>A.</sub> </blockquote><br>  Das Zielbild hat die Farbe D <sub>RGB</sub> , die Opazit√§t l√§sst es Licht emittieren D <sub>RGB</sub> √ó D <sub>A</sub> , jedoch wird ein Teil des Lichts durch die Opazit√§t des Bildes S blockiert, so dass der gesamte Einfluss des Ziels gleich ist: <br><br><blockquote>  D <sub>RGB</sub> √ó DA √ó (1 - SA) </blockquote><br>  Der Gesamtbeitrag des Lichts von S und D entspricht ihrer Summe: <br><br><blockquote>  S <sub>RGB</sub> √ó SA + D <sub>RGB</sub> √ó DA √ó (1 - SA) </blockquote><br>  In √§hnlicher Weise entspricht der Beitrag der zusammengef√ºhrten Ebenen ihrer Farbe mal ihrer Opazit√§t: <br><br><blockquote>  R <sub>RGB</sub> √ó R <sub>A.</sub> </blockquote><br>  Wir m√∂chten, dass diese beiden Werte √ºbereinstimmen: <br><br><blockquote>  R <sub>RGB</sub> √ó R <sub>A</sub> = S <sub>RGB</sub> √ó S <sub>A</sub> + D <sub>RGB</sub> √ó DA √ó (1 - SA) </blockquote><br>  Was gibt uns die endg√ºltigen Gleichungen: <br><br><blockquote>  R <sub>A</sub> = SA + DA √ó (1 - SA) <br><br>  R <sub>RGB</sub> = (S <sub>RGB</sub> √ó S <sub>A</sub> + D <sub>RGB</sub> √ó D <sub>A</sub> √ó (1 - S <sub>A</sub> )) / R <sub>A.</sub> </blockquote><br>  Sehen Sie, wie kompliziert die zweite Gleichung ist!  Beachten Sie, dass wir durch den Alpha-Wert dividieren m√ºssen, um die RGB-Werte des Ergebnisses zu erhalten.  F√ºr die n√§chste Stufe des Zusammensetzens ist jedoch erneut eine Multiplikation mit dem Alpha-Wert erforderlich, da das Ergebnis der aktuellen Operation zur neuen Quelle oder zum neuen Ziel der n√§chsten Operation wird.  Es ist einfach h√§sslich. <br><br>  Kehren wir f√ºr eine Sekunde zur fast endg√ºltigen Form von R <sub>RGB zur√ºck</sub> : <br><br><blockquote>  R <sub>RGB</sub> √ó R <sub>A</sub> = S <sub>RGB</sub> √ó S <sub>A</sub> + D <sub>RGB</sub> √ó DA √ó (1 - SA) </blockquote><br>  Quelle, Ziel <em>und</em> Ergebnis werden mit ihren Alpha-Komponenten multipliziert.  Dies l√§sst uns verstehen, dass die Farbe und das Alpha des Pixels ‚Äûzusammen‚Äú sein sollen. Daher m√ºssen wir einen Schritt zur√ºcktreten und die Art und Weise, wie wir Farbinformationen speichern, √ºberdenken. <br><br><h1>  Vormultipliziertes Alpha </h1><br>  Denken Sie daran, dass wir √ºber Opazit√§t gesprochen haben - wenn das Objekt teilweise undurchsichtig ist, ist sein Beitrag zum Ergebnis auch teilweise.  Das Konzept des vormultiplizierten Alphas (‚ÄûVormultiplikation mit Alpha‚Äú) setzt diese Idee um.  Die Werte der RGB-Komponenten werden, wie der Name schon sagt, mit der Alpha-Komponente vormultipliziert.  Beginnen wir mit Farbe ohne vorl√§ufige Multiplikation: <br><br><blockquote>  (1,00, 0,80, 0,30, 0,40) </blockquote><br>  Die vorl√§ufige Multiplikation mit Alpha ergibt Folgendes: <br><br><blockquote>  (0,40, 0,32, 0,12, 0,40) </blockquote><br>  Schauen wir uns mehrere Pixel gleichzeitig an.  Die folgende Abbildung zeigt, wie Farbinformationen gespeichert werden, ohne zuvor Alpha zu multiplizieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>  <i>RGB- und A-Informationen im Bild ohne vorherige Multiplikation</i> <br><br>  Beachten Sie, dass Bereiche, in denen Alpha 0 ist, beliebige RGB-Werte haben k√∂nnen, wie aus den gr√ºnen und blauen St√∂rungen im Bild ersichtlich ist.  Bei der vorl√§ufigen Multiplikation mit Alpha werden in den Farbinformationen auch Pixelopazit√§tswerte gespeichert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>  <i>RGB- und A-Informationen in einem vormultiplizierten Bild</i> <br><br>  Vormultipliziertes Alpha wird manchmal als assoziiertes Alpha bezeichnet, und nicht vormultipliziertes Alpha wird manchmal als gerades oder nicht assoziiertes Alpha bezeichnet. <br><br>  Wenn die Alpha-Komponente der Farbe 0 ist, setzt die vorl√§ufige Multiplikation alle anderen Komponenten zur√ºck, unabh√§ngig von ihren Werten: <br><br><blockquote>  (0,0, 0,0, 0,0, 0,0) </blockquote><br>  Im Fall von vormultipliziertem Alpha gibt es nur <em>eine</em> vollst√§ndig transparente Farbe, und dies ist charmant. <br><br>  Die Vorteile dieser Verarbeitung von Farbkomponenten werden Ihnen nach und nach klar. Bevor wir jedoch zum Compositing-Beispiel zur√ºckkehren, wollen wir uns ansehen, wie vormultipliziertes Alpha zur L√∂sung einiger anderer Rendering-Probleme beitr√§gt. <br><br><h2>  Filtern </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gau√üsche Unsch√§rfe</a> ist eine beliebte Methode, um einen interessanten defokussierten Hintergrund zu erstellen oder die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hohe Frequenz des</a> Hintergrundteils des Inhalts einiger UI-Elemente zu reduzieren.  Wie wir sehen werden, ist das Vormultiplizieren von Alpha entscheidend, um die richtige Unsch√§rfe zu erzielen. <br><br>  Das Bild, das wir analysieren, wird erstellt, indem der Hintergrund mit 1% undurchsichtigem Blau gef√ºllt wird, √ºber das ein undurchsichtiger roter Kreis gezogen wird.  Schauen wir uns zun√§chst ein Beispiel ohne vorl√§ufige Multiplikation an.  Ich habe die RGB-Kan√§le vom Alpha-Kanal getrennt, um zu verstehen, was los war.  Der Pfeil zeigt die Unsch√§rfeoperation an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>  <i>Verwischen Sie den Inhalt ohne vorherige Multiplikation</i> <br><br>  Das fertige Ergebnis hat einen h√§sslichen blauen Heiligenschein.  Dies geschah, weil der blaue Hintergrund w√§hrend der Unsch√§rfe auf den roten Bereich sickerte und erst <em>dann</em> w√§hrend des Zusammensetzens das Alpha-Gewicht hinzugef√ºgt wurde. <br><br>  Wenn die Farben mit Alpha vormultipliziert werden, ist das Ergebnis korrekt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwischen von vormultiplizierten Inhalten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgrund der Vormultiplikation wird die blaue Farbe des Bildes auf 1% seiner urspr√ºnglichen St√§rke reduziert, sodass die Auswirkungen auf die Farben des unscharfen Kreises √§u√üerst gering sind.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Rendern eines Bildes, dessen Pixel perfekt zum Ziel passen, ist eine einfache Aufgabe, da wir eine einfache Eins-zu-Eins-Zuordnung zwischen Samples durchf√ºhren m√ºssen. </font><font style="vertical-align: inherit;">Ein Problem tritt auf, wenn es keine einfache Zuordnung gibt, beispielsweise aufgrund von Drehung, Skalierung oder Silbentrennung. </font><font style="vertical-align: inherit;">Die folgende Abbildung zeigt, dass die durch den roten Umriss angezeigten Pixel des gedrehten Bildes nicht mehr mit dem Ziel √ºbereinstimmen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Bildorientierung und Zielpixel vor und nach der Drehung</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt viele M√∂glichkeiten, eine Farbe aus dem Bild auszuw√§hlen, das in das Zielpixel geschrieben werden soll, und die einfachste davon ist die sogenannte Interpolation zum n√§chsten Nachbarn, bei der Als letztes Pixel wird einfach die n√§chstgelegene Probe in der Textur ausgew√§hlt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Demonstration zeigt der rote Umriss die Bildposition im Ziel. Die rechte Seite zeigt die Positionen der Proben aus Sicht des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Durch Ziehen des Schiebereglers (im Originalartikel) k√∂nnen Sie das Viereck drehen und beobachten, wie die Samples Farben aus der Bitmap ausw√§hlen. Ich habe ein Pixel in Quelle und Ziel hervorgehoben, damit ihre Beziehung klarer wird:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese L√∂sung ist sehr funktional und die Pixel haben eine ganzheitliche Farbe, aber die Qualit√§t ist nicht akzeptabel. Es w√§re besser, eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilineare Interpolation zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den gewichteten Durchschnitt der vier n√§chsten Pixel des abgetasteten Bildes berechnet:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert besser, aber die Kanten um die Rechtecke sehen nicht richtig aus. Der Inhalt der Pixel wird ohne Multiplikation zusammengef√ºhrt, da Alpha nach der Interpolation "angewendet" wird. Manchmal ist die empfohlene L√∂sung zum Zusammenf√ºhren der Farbe des richtigen Inhalts, die in dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstaunlichen Artikel von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adrian Correger [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Habr√©] gezeigt wird, </font><font style="vertical-align: inherit;">alles andere als </font><font style="vertical-align: inherit;">ideal - keine einzige Farbe in der L√ºcke zwischen dem roten und dem blauen Rechteck sieht richtig aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie alles im Bild mit vormultipliziertem Alpha und Compositing mit einer erweiterten Formel aussehen wird, die wir bald ableiten werden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach perfekt - wir haben alle Farbfusionen beseitigt und die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√§hne sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nirgends zu sehen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letztendlich sind die mit Unsch√§rfe und Interpolation verbundenen Probleme eng miteinander verbunden. </font><font style="vertical-align: inherit;">Jede Operation, die eine Kombination von durchscheinenden Farben erfordert, ohne zuvor die Farben mit Alpha zu multiplizieren, f√ºhrt wahrscheinlich zu falschen Ergebnissen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das richtige Compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommen wir zur√ºck zum Compositing. </font><font style="vertical-align: inherit;">Wir haben uns f√ºr eine fast abgeleitete Gleichung entschieden:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich Farben mit vormultipliziertem Alpha vorstellen, verschwinden alle diese unangenehmen Multiplikationen, da Alpha bereits Teil der Farbwerte ist. </font><font style="vertical-align: inherit;">Dann bekommen wir folgendes:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen wir uns die Alpha-Gleichung an: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Koeffizienten f√ºr die Kan√§le Rot, Gr√ºn, Blau und Alpha sind gleich, sodass wir den gesamten Ausdruck mit einer Gleichung ausdr√ºcken k√∂nnen und uns daran erinnern, dass jede Komponente dieselbe Operation durchl√§uft: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehen Sie, wie vormultipliziertes Alpha die Dinge einfach machte. </font><font style="vertical-align: inherit;">Wenn wir die Komponenten der Gleichung analysieren, sind sie alle vorhanden. </font><font style="vertical-align: inherit;">Die Operation </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maskiert einen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil des Hintergrundlichts und f√ºgt ein neues Licht hinzu:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Mischvorgang wird als Source-Over, Souver oder einfach als normal bezeichnet und ist ohne Zweifel der h√§ufigste Compositing-Modus. </font><font style="vertical-align: inherit;">Fast alles, was Sie auf meiner Website sehen, wird in diesem Modus gemischt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assoziativit√§t </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Source-Over-Eigenschaft, die f√ºr vor Alpha-multiplizierte Farben ausgef√ºhrt wird, ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assoziativit√§t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Operation. </font><font style="vertical-align: inherit;">Dank ihm k√∂nnen wir in der komplexen Mischungsgleichung die Klammern v√∂llig willk√ºrlich platzieren. </font><font style="vertical-align: inherit;">Alle unten gezeigten Zusammensetzungen sind √§quivalent:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (((A‚á®B) ‚á®C) ‚á®D) ‚á®E </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (A‚á®B) ‚á® (C‚á® (D‚á®E)) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = A‚á® (B‚á® (C‚á® (D‚á®E))) )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Beweis daf√ºr ist einfach genug, aber ich werde Sie nicht mit algebraischen Manipulationen belasten. </font><font style="vertical-align: inherit;">In der Praxis bedeutet dies, dass wir teilweise komplexe Zeichnungen rendern k√∂nnen, ohne bef√ºrchten zu m√ºssen, dass die endg√ºltige Komposition falsch aussieht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den allermeisten F√§llen wird Alpha nur f√ºr das Compositing mithilfe von Source-Over verwendet, aber seine Vorteile enden hier nicht. </font><font style="vertical-align: inherit;">Alpha-Werte k√∂nnen auch f√ºr andere n√ºtzliche Rendering-Vorg√§nge verwendet werden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter-Duff-Compositing </font></font></h1><br>   1984          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄúCompositing Digital Images‚Äù</a> .       premultiplied alpha     source-over,       -,    ,    .     <em></em> ,                . <br><br><h2> Over </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In zuk√ºnftigen Beispielen werden wir interaktive Demos verwenden, die die Funktionsweise verschiedener Mischmodi zeigen. </font><font style="vertical-align: inherit;">Das Zielbild ist das schwarze Symbol ‚ÄûClub‚Äú und das Quellbild ist das rote Symbol ‚ÄûW√ºrmer‚Äú. </font><font style="vertical-align: inherit;">Sie k√∂nnen das Herz √ºber das Bild ziehen und beobachten, wie sich die √ºberlappenden Formen unter verschiedenen Compositing-Operatoren verhalten. </font><font style="vertical-align: inherit;">Achten Sie auf die kleine Minikarte in der Ecke. </font><font style="vertical-align: inherit;">Einige Mischmodi sind sehr destruktiv und leicht zu verwechseln. </font><font style="vertical-align: inherit;">Die Minikarte zeigt immer das Ergebnis eines einfachen Source-Over-Compositing, was das Verst√§ndnis vereinfacht:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S √ó (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie zum Ziel-Over wechseln, werden Sie sofort feststellen, dass es einfach das Source-Over ‚Äûumdreht‚Äú - Ziel und Quelle werden in der Gleichung vertauscht, und das Ergebnis entspricht dem, was wir als Ziel als Quellbild betrachten. </font><font style="vertical-align: inherit;">Obwohl es redundant erscheint, ist der Ziel-Over-Operator √§u√üerst n√ºtzlich, da Sie damit Objekte erstellen k√∂nnen, die sich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorhandenen Inhalten befinden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Source-Out- und Destination-Out-Anweisungen eignen sich hervorragend zum Stanzen von L√∂chern in Quelle oder Ziel: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S √ó (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Von diesen beiden Operatoren ist Destination-Out bequemer, da der Alphakanal zum Stanzen von L√∂chern in der Zielform verwendet wird. </font></font><br><br><h2>  In </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Source-In- und Ziel-In-Operatoren sind im Wesentlichen Maskierungsoperatoren: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= S √ó R D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= D √ó R S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie machen es ziemlich einfach, komplexe Schnittpunkte nichttrivialer Geometrie zu erstellen, ohne die relativ schwierig zu berechnenden Schnittpunkte von Vektorkonturen aufzul√∂sen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Operatoren </font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erm√∂glichen es Ihnen, neue Inhalte mit vorhandenen zu √ºberlagern, w√§hrend Sie diese entlang des Zielpfads maskieren:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= S √ó R D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S √ó (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D √ó S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der exklusive OR-Operator ( </font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) speichert </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entweder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelle oder Ziel, und die entsprechenden Bereiche verschwinden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br><blockquote> R = S √ó (1 ‚àí D <sub>A</sub> ) + D √ó (1 ‚àí S <sub>A</sub> ) </blockquote><br><h2> Source, Destination, Clear </h2><br>       . <code>Source</code> ,   <code>copy</code> ,    source. , <code>destination</code>   source    <code>destination</code> .  <code>clear</code>   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br><blockquote> R = S </blockquote><br><blockquote> R = D </blockquote><br><blockquote> R = 0 </blockquote><br>    .   <code>clear</code>    ,     ,    .  ,    <code>source</code> <i> </i>   ,       ,       source. <br><br><h1> -   </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir uns mit einzelnen Operatoren befasst haben, wollen wir sehen, wie Sie sie kombinieren k√∂nnen. </font><font style="vertical-align: inherit;">Im folgenden Beispiel zeichnen wir ein Marine-Logo ohne Maskierung oder komplexe geometrische Formen. </font><font style="vertical-align: inherit;">Die blauen Umrisse zeigen die einfache Geometrie, die erstellt wird. </font><font style="vertical-align: inherit;">Sie k√∂nnen durch die Schritte gehen, indem Sie auf die rechte Seite des Bildes klicken, und zur√ºckgehen, indem Sie auf die linke Seite klicken:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nat√ºrlich sind wir keineswegs verpflichtet, Masken aufzugeben und Konturen zu schneiden, aber wir vergessen oft ein Werkzeug wie den Porter-Duff-Compositing-Modus, obwohl es viel einfacher ist, mit ihrer Hilfe einige visuelle Effekte zu erstellen. </font></font><br><br><h2>  Betreiber </h2><br>     -,   ,      . Source      F <sub>S</sub>    destination,    F <sub>D</sub> : <br><br><blockquote> R = S√óF <sub>S</sub> + D√óF <sub>D</sub> </blockquote><br> F <sub>S</sub>    0, 1, D <sub>A</sub>  1 ‚àí D <sub>A</sub> ,  F <sub>D</sub>    0, 1, S <sub>A</sub>  1 ‚àí S <sub>A</sub> .     source  destination    ,      ,     ,       .       : <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  0 </td><td>  1 </td><td> D <sub>A</sub> </td><td> 1 ‚àí D <sub>A</sub> </td></tr><tr><td>  0 </td><td>  klar </td><td> source </td><td> source-in </td><td> source-out </td></tr><tr><td>  1 </td><td> destination </td><td></td><td></td><td> destination-over </td></tr><tr><td> S <sub>A</sub> </td><td> destination-in </td><td></td><td></td><td> destination-atop </td></tr><tr><td> 1 ‚àí S <sub>A</sub> </td><td> destination-out </td><td> source-over </td><td> source-atop </td><td> xor </td></tr></tbody></table></div><br>       .          ,     . <br><br><h1>   </h1><br>          ,    F <sub>S</sub> ,  F <sub>D</sub>  1.     <code>plus</code> , <code>lighter</code>  <code>plus-lighter</code> : <br><br><blockquote> R = S + D </blockquote><br>     <em></em>  source  destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Bediener implementierte additive Beleuchtung</font></font><code><em>plus</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√ºn und Rot bilden korrekt Gelb, w√§hrend Gr√ºn und Blau Cyan bilden. </font><font style="vertical-align: inherit;">Schwarz ist das Fehlen einer Operation, es √§ndert die Farbwerte in keiner Weise, da das Hinzuf√ºgen von Null zu einer Zahl nichts √§ndert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die drei verbleibenden Operatoren erhielten keine Namen, da sie nicht besonders n√ºtzlich sind. </font><font style="vertical-align: inherit;">Sie sind nur eine Kombination aus Maskieren und Mischen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erw√§hnenswert, dass vormultipliziertes Alpha es uns erm√∂glicht, den Operator auf </font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unerwartete Weise zu verwenden. </font><font style="vertical-align: inherit;">Schauen wir uns die Gleichung noch einmal an:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D √ó (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es uns gelingt, den Alpha-Wert in der Quelle gleich Null zu machen, k√∂nnen wir, wenn die RGB-Kan√§le Werte ungleich Null enthalten, eine additive Beleuchtung erzielen, ohne den Operator zu verwenden </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additive Beleuchtung mit dem Operator implementiert</font></font><code><em>source-over</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass Sie hier vorsichtig sein m√ºssen - die Werte werden nicht mehr korrekt mit Alpha multipliziert. In einigen Programmen kann es eine Optimierung geben, die das Mischen von Farben mit null Alpha vollst√§ndig vermeidet, w√§hrend andere Programme die Vormultiplikation mit Alpha-Werten umkehren, einige Farboperationen ausf√ºhren und dann erneut mit Alpha multiplizieren k√∂nnen, wodurch die Farbkan√§le vollst√§ndig zerst√∂rt werden. Es kann auch schwierig sein, Ressourcen in diesem Format zu exportieren. Wenn Sie also nicht die vollst√§ndige Kontrolle √ºber die Rendering-Pipeline haben, sollten Sie sich an den Operator halten </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Elemente, die wir diskutieren, wurden bisher gut kombiniert. </font><font style="vertical-align: inherit;">Nehmen wir nun unsere rosa Brille ab und diskutieren einige Probleme, die bei der Arbeit mit Alpha-Compositing ber√ºcksichtigt werden m√ºssen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gruppenopazit√§t </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werfen wir einen Blick auf diese einfache Pillenzeichnung, die nur aus sechs Grundelementen besteht: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnen einer Pille mit einfachen Formen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir gebeten w√ºrden, eine Pille mit einer Deckkraft von 50% zu rendern, k√∂nnten wir versucht sein, die Deckkraft einfach in die H√§lfte jeder Zeichenoperation aufzuteilen, aber dies w√ºrde sich als fehlerhafte Entscheidung herausstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerwartetes Ergebnis beim Rendern einer Pille mit halber Deckkraft.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um das richtige Ergebnis zu erzielen, k√∂nnen wir die Deckkraft eines Objekts nicht einfach auf jede seiner einzelnen Komponenten verteilen. </font><font style="vertical-align: inherit;">Wir m√ºssen zuerst ein Objekt erstellen, es in eine Bitmap rendern und erst </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Deckkraft der Bitmap √§ndern und schlie√ülich das Compositing durchf√ºhren:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erwartetes Ergebnis beim Rendern einer Pille mit halber Deckkraft</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein weiterer Fall, der die N√ºtzlichkeit des Konzepts des Renderns in einen Seitenpuffer demonstriert.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compositing-Abdeckung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Konvertieren einer geometrischen Abdeckung in einen einzelnen Alpha-Wert hat unangenehme Folgen. </font><font style="vertical-align: inherit;">Betrachten Sie den Fall, in dem zwei ideal √ºbereinstimmende Kanten von Vektorgeometriefiguren, die in der folgenden Abbildung mit orangefarbenen und blauen Konturen dargestellt sind, in eine Bitmap gerendert werden. </font><font style="vertical-align: inherit;">In einer idealen Welt sollten die Ergebnisse ungef√§hr so ‚Äã‚Äãaussehen, da jedes Pixel vollst√§ndig geschlossen ist:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein ideales Rendering-Ergebnis mit der richtigen Abdeckung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir jedoch zuerst die orange Geometrie und dann die blaue Geometrie rendern, leckt im endg√ºltigen Bild immer noch ein kleiner wei√üer Hintergrund in die Randpixel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis des zweistufigen Compositing</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobald die Beschichtung im Alpha-Kanal gespeichert ist, gehen alle geometrischen Informationen verloren und wir k√∂nnen sie in keiner Weise wiederherstellen. Die blaue Geometrie mischt sich einfach mit einem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalts des Puffers, wei√ü jedoch nicht, dass die durch die r√∂tlichen Pixel dargestellte Geometrie mit dieser √ºbereinstimmen muss. Dieses Problem macht sich insbesondere dann bemerkbar, wenn sich Geometrien pr√§zise √ºberlagern. Im Bild unten wird ein wei√üer Kreis √ºber einen schwarzen gezeichnet. Dunkle Kanten sind erkennbar, obwohl beide Kreise </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau den gleichen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radius und </font><em><font style="vertical-align: inherit;">die gleiche</font></em><font style="vertical-align: inherit;"> Position haben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wei√üer Kreis √ºber einem schwarzen Kreis</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine M√∂glichkeit, dieses Problem zu beheben, besteht darin </font><font style="vertical-align: inherit;">, die Teilabdeckung der Pixel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht zu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnen und erheblich gr√∂√üere Puffer zu verwenden. Durch Rastern der Vektorgeometrie mit einer einfachen In / Out-Beschichtung und anschlie√üendes Reduzieren der Skalierung des Ergebnisses auf die Gr√∂√üe des Originalbilds k√∂nnen Sie das erwartete Ergebnis erzielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr einen perfekten Vergleich der Renderqualit√§t der Kanten des 8-Bit-Alpha-Kanals sollten die Puffer in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beiden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Richtungen </font><font style="vertical-align: inherit;">256-mal gr√∂√üer sein, dh </font><font style="vertical-align: inherit;">die Anzahl der Pixel sollte um 2 bis </font><sup><font style="vertical-align: inherit;">16</font></sup><font style="vertical-align: inherit;"> erh√∂ht werden</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mal. </font><font style="vertical-align: inherit;">Wie wir oben gesehen haben, k√∂nnen Sie zwar die Bittiefe f√ºr Abdeckungswerte verringern, aber dennoch zufriedenstellende Ergebnisse erzielen, sodass Sie in der Praxis einen kleineren Ma√üstab verwenden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch erw√§hnenswert, dass solche Probleme oft ohne die Verwendung gro√üer Bitmaps relativ leicht vermieden werden k√∂nnen. </font><font style="vertical-align: inherit;">Anstatt beispielsweise zwei √ºbereinanderliegende Kreise zu zeichnen, k√∂nnen Sie einfach zwei Quadrate √ºbereinander zeichnen und </font><font style="vertical-align: inherit;">das Ergebnis </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maskieren, um einen Kreis zu bilden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lineare Werte </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihr Wissen √ºber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbr√§ume</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktualisiert haben </font><font style="vertical-align: inherit;">, k√∂nnen Sie sich daran erinnern, dass die meisten von ihnen Farbwerte nicht linear codieren und eine vorl√§ufige Linearisierung erforderlich ist, um die korrekten mathematischen Operationen auszuf√ºhren. </font><font style="vertical-align: inherit;">Wenn diese Phase abgeschlossen ist, ist das Ergebnis des Zusammensetzens wie folgt; </font><font style="vertical-align: inherit;">Achten Sie auf die sch√∂ne gelbliche F√§rbung der √ºbereinanderliegenden Teile:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unscharfe rote Kreise, die durch Zusammensetzen auf einem gr√ºnen Hintergrund unter Verwendung linearer Werte √ºberlagert werden.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In den meisten F√§llen ist das Zusammensetzen jedoch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Fall </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Standardmethode f√ºr das Web und die meisten Grafikprogramme besteht darin, nichtlineare Werte direkt zu mischen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unscharfe rote Kreise, die von einem Komponisten auf einem gr√ºnen Hintergrund mit nichtlinearen Werten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºberlagert werden. Beachten Sie, dass die Bereiche, in denen sich Rot auf Gr√ºn √ºberlagert, viel dunkler sind. </font><font style="vertical-align: inherit;">Sie sind alles andere als ideal, aber in einigen F√§llen sind falsche Operationen tief verwurzelt im Verst√§ndnis, wie wir Farbe wahrnehmen. </font><font style="vertical-align: inherit;">Zum Beispiel sieht 50% undurchsichtiges Grau aus dem sRGB-Bereich genauso aus wie reines Schwarz mit 50% Deckkraft gemischt mit einem wei√üen Hintergrund:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammensetzen von zwei Farben auf wei√üem Hintergrund</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ohne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearisierung</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der folgenden Abbildung werden die sRGB-Farben der Quell- und Zielbilder linearisiert und dann zur Anzeige wieder in eine nichtlineare Codierung konvertiert. </font><font style="vertical-align: inherit;">So sollten diese Farben eigentlich aussehen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammensetzung von zwei Farben auf wei√üem Hintergrund</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearisierung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben eine Diskrepanz, die nicht unseren Erwartungen entspricht. </font><font style="vertical-align: inherit;">Die einzige M√∂glichkeit, mit dieser Methode eine visuelle Einheitlichkeit zu erzielen, besteht darin, alle Farben mit linearen Werten auszuw√§hlen. Dies unterscheidet sich jedoch stark von dem, was jeder gewohnt ist. </font><font style="vertical-align: inherit;">50% Grau mit linearen Werten sieht auf 73,5% des sRGB-Speicherplatzes wie Grau aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus m√ºssen Sie besonders vorsichtig sein, wenn Sie mit vormultipliziertem Alpha arbeiten. </font><font style="vertical-align: inherit;">Die Vormultiplikation muss mit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgef√ºhrt werden, d.h. </font><font style="vertical-align: inherit;">vor dem Codieren auf nichtlinear. </font><font style="vertical-align: inherit;">Aus diesem Grund endet der Linearisierungsschritt korrekt mit den korrekten linearen Werten, die zuvor mit Alpha multipliziert wurden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorvervielfachte Alpha- und Bittiefe </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz seiner gro√üen N√ºtzlichkeit f√ºr Compositing, Filterung und Interpolation ist vormultipliziertes Alpha keine ‚ÄûSilberkugel‚Äú und hat seine Nachteile. </font><font style="vertical-align: inherit;">Am schwerwiegendsten ist die Verringerung der Bittiefe der Farben, die man sich vorstellen kann. </font><font style="vertical-align: inherit;">Stellen Sie sich eine 8-Bit-Codierung mit einem Wert von 150 vor, die mit Alpha 20% vormultipliziert wird. </font><font style="vertical-align: inherit;">Nach vorl√§ufiger Multiplikation mit Alpha erhalten wir</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rund (150 √ó 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir das gleiche Verfahren mit einem Wert von 151 wiederholen, erhalten wir: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rund (151 √ó 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der codierte Wert bleibt trotz der unterschiedlichen Anfangswerte gleich. </font><font style="vertical-align: inherit;">Tats√§chlich werden nach dem Multiplizieren mit Alpha die Werte von 148, 149, 150, 151 und 152 in 30 codiert, und der urspr√ºngliche Unterschied zwischen diesen f√ºnf eindeutigen Farben geht verloren:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vormultiplikation mit Alpha von 20% reduziert die verschiedenen 8-Bit-Werte auf eins.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je kleiner das Alpha ist, desto zerst√∂rerischer ist nat√ºrlich seine Wirkung. Von dem m√∂glichen Bereich von 256 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ungef√§hr 4,3 Milliarden) verschiedener Kombinationen von 8-Bit-RGBA-Werten behalten nach vorl√§ufiger Multiplikation mit Alpha nur 25,2% eine eindeutige Darstellung; Tats√§chlich verlieren wir fast 2 Bits aus dem 32-Bit-Bereich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Farben zwischen verschiedenen Farbr√§umen umzuwandeln, ist es manchmal erforderlich, die vorl√§ufige Multiplikation umzukehren, dh die Werte durch die Alpha-Komponente zu teilen, um die urspr√ºngliche Farbhelligkeit zu erhalten. Dieser Schritt ist erforderlich, da, wie oben erw√§hnt, die Codierung nicht linear durchgef√ºhrt wird. Das Vorhandensein einer Vormultiplikation verringert die Genauigkeit der Farbdarstellung, und die Konvertierungen zwischen Farbr√§umen k√∂nnen unvollst√§ndig sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Praxis ist die Reduzierung der Bittiefe selten wichtig, insbesondere beim Compositing. Je niedriger der Alpha-Wert, desto weniger sichtbar ist die Farbe und desto weniger Einfluss hat sie auf das Compositing. Wenn Sie pedantisch genaue Farboperationen anstreben, werden Sie letztendlich nicht deren 8-Bit-Darstellung verwenden - f√ºr diesen Zweck sind Formate viel besser geeignet</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleitkomma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zus√§tzliche Lekt√ºre </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Konzept des Alpha-Kanals wurde von den Pixar-Studio-Mitbegr√ºndern </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell entwickelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Smiths Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûAlpha und die Geschichte des digitalen Compositing‚Äú</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt die Geschichte der Erfindung und die Quellen des Namens ‚ÄûAlpha‚Äú sowie die Entwicklung dieser Konzepte und die schrittweise Ersetzung des Konzepts der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Filmproduktion </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Bedeutung von Alpha zu verstehen, empfehle ich Ihnen dringend, Andrew Glassners </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûInterpreting Alpha‚Äú zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. Dieser Artikel bietet eine strenge, aber sehr leicht zug√§ngliche mathematische Ableitung von Alpha als Ma√ü f√ºr die Wechselwirkung zwischen Opazit√§t und Abdeckung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine ausf√ºhrliche Diskussion des vormultiplizierten Alphas kann in untersucht werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"GPUs bevorzugen Vormultiplikation" von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eric Haines. Der Artikel bietet nicht nur einen hervorragenden √úberblick √ºber die Probleme, die durch das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlen einer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorl√§ufigen Multiplikation, insbesondere beim 3D-Rendering, </font><font style="vertical-align: inherit;">verursacht werden </font><font style="vertical-align: inherit;">, sondern enth√§lt auch Links zu vielen anderen Artikeln zu diesem Thema.</font></font><br><br><h1>  Abschlie√üend </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urspr√ºnglich war dieser Artikel als Erkl√§rung der Porter-Duff-Compositing-Operatoren gedacht, aber alle anderen Konzepte im Zusammenhang mit Alpha-Compositing erwiesen sich als so interessant, dass ich sie nicht √ºbersehen konnte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was mir an Alpha am besten gef√§llt, ist, dass es nur eine zus√§tzliche Zahl ist, die RGB-Komponenten begleitet, aber gleichzeitig viele einzigartige Rendering-Funktionen bietet. </font><font style="vertical-align: inherit;">Alpha hat buchst√§blich eine neue Chance in der langweiligen alten Welt des Compositing und 2D-Renderings geschaffen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das n√§chste Mal die glatten Kanten von Vektorformen sehen oder eine dunkle √úberlagerung bemerken, die einige Teile der Benutzeroberfl√§che verdeckt, denken Sie an eine kleine, aber leistungsstarke Komponente, die alles m√∂glich gemacht hat.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468067/">https://habr.com/ru/post/de468067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468057/index.html">Unix-√§hnliche Betriebssystementwicklung - Multitasking und Systemaufrufe (7)</a></li>
<li><a href="../de468059/index.html">Meine zweite Woche mit Haiku: viele versteckte Diamanten und angenehme √úberraschungen sowie einige Probleme</a></li>
<li><a href="../de468061/index.html">Cron unter Linux: Verlauf, Verwendung und Ger√§t</a></li>
<li><a href="../de468063/index.html">Angulareact</a></li>
<li><a href="../de468065/index.html">Mentale Produktmanagementmodelle f√ºr alle</a></li>
<li><a href="../de468071/index.html">Eduard Medwedew, CTO bei Tungsten Labs: ‚ÄûWir sind so weit gewachsen, dass Technologie massiven Schaden anrichten kann.‚Äú</a></li>
<li><a href="../de468073/index.html">Andrei Terekhov: "Sie k√∂nnen so viel sagen, wie Sie m√∂chten, dass Amerikaner besser sind, aber unser Auto bricht nie zusammen."</a></li>
<li><a href="../de468075/index.html">Die Verwendung von siamesischen neuronalen Netzen bei der Suche</a></li>
<li><a href="../de468077/index.html">Posit-Tests f√ºr Erwachsene. Spektralanalyse</a></li>
<li><a href="../de468079/index.html">Benutzerdefinierte Dimensionen in Google Analytics, die uns mehr als einmal gespeichert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>