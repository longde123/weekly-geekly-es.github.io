<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ∂Ô∏è üßöüèø üóº Crear un generador de rompecabezas procesal üë®‚Äç‚öïÔ∏è ü•ü ‚è∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n describe el generador de niveles para mi juego de rompecabezas Linjat . Se puede leer una publicaci√≥n sin preparaci√≥n, pero es m√°s f√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear un generador de rompecabezas procesal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Esta publicaci√≥n describe el generador de niveles para mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego de</a> rompecabezas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linjat</a> .  Se puede leer una publicaci√≥n sin preparaci√≥n, pero es m√°s f√°cil de asimilar si juegas en varios niveles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publiqu√© el</a> c√≥digo fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en github</a> ;  todo lo discutido en el art√≠culo est√° en el <code>src/main.cc</code> <br><br>  Ejemplo de plan postal: <br><br><ul><li>  Linjat es un juego de l√≥gica en el que debes cerrar todos los n√∫meros y puntos de la cuadr√≠cula con l√≠neas. </li><li>  Los acertijos se generan mediante procedimientos mediante una combinaci√≥n de solucionador, generador y optimizador. </li><li>  Solver intenta resolver los acertijos de la manera en que lo har√≠a una persona, y asigna a cada acertijo una calificaci√≥n de inter√©s. </li><li>  El generador de rompecabezas est√° dise√±ado para que sea posible cambiar f√°cilmente una parte del rompecabezas (n√∫mero) y, al mismo tiempo, todas las dem√°s partes (puntos) cambian para que el rompecabezas permanezca solucionable. </li><li>  El optimizador de rompecabezas resuelve repetidamente los niveles y genera nuevas variaciones de las m√°s interesantes que se encuentran en este momento. </li></ul><br><h3>  Las reglas </h3><br>  Para entender c√≥mo funciona el generador de niveles, desafortunadamente, necesitas entender las reglas del juego.  Afortunadamente, son muy simples.  El rompecabezas consiste en una cuadr√≠cula que contiene cuadrados vac√≠os, n√∫meros y puntos.  Un ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  El objetivo del jugador es dibujar una l√≠nea vertical u horizontal a trav√©s de cada uno de los n√∫meros, sujeto a tres condiciones: <br><br><ul><li>  Una l√≠nea a trav√©s de un n√∫mero debe tener la misma longitud que el n√∫mero. </li><li>  Las l√≠neas no pueden cruzarse. </li><li>  Todos los puntos deben cerrarse con l√≠neas. </li></ul><br>  Soluci√≥n de ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  ¬°Hurra!  El dise√±o del juego est√° listo, la interfaz de usuario est√° implementada y ahora lo √∫nico que queda es encontrar varios cientos de acertijos buenos.  Y para tales juegos, por lo general, no tiene sentido intentar crear tales rompecabezas manualmente.  Este es un trabajo de computadora. <br><a name="habracut"></a><br><h3>  Requisitos </h3><br>  ¬øQu√© hace que el rompecabezas de este juego sea bueno?  Me inclino a creer que los juegos de rompecabezas se pueden dividir en dos categor√≠as.  Hay juegos en los que exploras un espacio de estado complejo de principio a fin (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sokoban</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rush Hour</a> ), y en los que puede no ser obvio qu√© estados existen en el juego.  Y hay juegos en los que todos los estados se conocen desde el principio, y gradualmente formamos el espacio de estados utilizando el proceso de eliminaci√≥n de los innecesarios (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sudoku</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Picross</a> ).  Mi juego definitivamente cae en la segunda categor√≠a. <br><br>  Los jugadores tienen requisitos muy diferentes para estos diferentes tipos de rompecabezas.  En el segundo caso, esperan que el rompecabezas solo pueda resolverse por deducci√≥n, y que nunca necesitar√°n regresar / adivinar / prueba y error <sup>[0]</sup> <sup>[1]</sup> . <br><br>  No es suficiente saber si un rompecabezas solo se puede resolver mediante la l√≥gica.  Adem√°s, necesitamos entender de alguna manera lo buenos que son los rompecabezas creados.  De lo contrario, la mayor√≠a de los niveles ser√°n solo escorias triviales.  En una situaci√≥n ideal, este principio tambi√©n podr√≠a usarse para crear una curva de progreso suave, de modo que a medida que el jugador avanza en el juego, los niveles gradualmente se vuelven m√°s dif√≠ciles. <br><br><h3>  Solucionador </h3><br>  El primer paso para cumplir con estos requisitos es crear un solucionador de juegos optimizado para este prop√≥sito.  El solucionador de retroceso le permite determinar de forma r√°pida y precisa si el rompecabezas es solucionable;  Adem√°s, se puede modificar para determinar si la soluci√≥n es √∫nica.  Pero no puede dar una idea de lo complicado que es realmente el rompecabezas, porque la gente los resuelve de manera diferente.  El solucionador debe imitar el comportamiento humano. <br><br>  ¬øC√≥mo resuelve una persona este rompecabezas?  Aqu√≠ hay un par de movimientos obvios que ense√±a el tutorial del juego: <br><br><ul><li>  Si se puede llegar a un punto desde un solo n√∫mero, entonces para cerrar un punto necesita dibujar una l√≠nea desde ese n√∫mero.  En este ejemplo, se puede llegar al punto solo desde los tres, pero no desde los cuatro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  Y esto lleva a esta situaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Si la l√≠nea no cabe en una direcci√≥n, entonces debe colocarse en otra.  En el ejemplo anterior, los cuatro ya no se pueden colocar verticalmente, por lo que sabemos que ser√° horizontal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Si se sabe que la l√≠nea de longitud X debe estar en una posici√≥n determinada (vertical / horizontal) y no hay suficiente espacio vac√≠o para colocar una l√≠nea de X celdas vac√≠as en ambos lados, entonces debe cubrir varios cuadrados en el medio.  Si los cuatro fueran tres en el ejemplo que se muestra arriba, entonces no sabr√≠amos si se extiende hacia la derecha o hacia la izquierda.  Pero sabr√≠amos que la l√≠nea debe cubrir dos cuadrados medios: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Un razonamiento similar es la base del juego.  El jugador busca formas de estirar una peque√±a l√≠nea y luego examina el campo nuevamente, porque puede darle informaci√≥n para llegar a otra conclusi√≥n l√≥gica.  Crear un solucionador que siga estas reglas ser√° suficiente para determinar <i>si una</i> persona puede resolver el rompecabezas sin retroceder. <br><br>  Sin embargo, esto no nos dice nada sobre la complejidad o el inter√©s del nivel.  Adem√°s de la capacidad de soluci√≥n, de alguna manera necesitamos cuantificar la complejidad. <br><br>  Una primera idea obvia para la funci√≥n de calificaci√≥n: cuantos m√°s movimientos necesites para resolver el rompecabezas, m√°s dif√≠cil ser√°.  Esta es probablemente una buena m√©trica en otros juegos, pero la m√≠a, muy probablemente, es m√°s importante que la cantidad de movimientos permitidos que tiene un jugador.  Si un jugador puede sacar 10 conclusiones l√≥gicas, lo m√°s probable es que encuentre una de ellas muy r√°pidamente.  Si solo hay un movimiento correcto, tomar√° m√°s tiempo. <br><br>  Es decir, como primera aproximaci√≥n, necesitamos que el √°rbol de decisi√≥n sea profundo y estrecho: existe una larga dependencia de los movimientos de principio a fin, y en cada momento solo hay un peque√±o n√∫mero de formas de ascender en la cadena <sup>[2]</sup> . <br><br>  ¬øC√≥mo determinamos el ancho y la profundidad de un √°rbol?  Una soluci√≥n √∫nica para el rompecabezas y la evaluaci√≥n del √°rbol creado no dar√° una respuesta exacta.  El orden exacto en el que se realizan los movimientos afecta la forma del √°rbol.  Necesitamos considerar todas las soluciones posibles y hacer con ellas algo como la optimizaci√≥n para los mejores y peores casos.  Estoy familiarizado con la t√©cnica de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda aproximada de gr√°ficos de b√∫squeda en juegos de rompecabezas</a> , pero para este proyecto quer√≠a crear un solucionador de un solo paso, y no una b√∫squeda exhaustiva.  Debido a la fase de optimizaci√≥n, trat√© de asegurarme de que el tiempo de ejecuci√≥n del solucionador no se midiera en segundos, sino en milisegundos. <br><br>  Decid√≠ no hacerlo.  En cambio, mi solucionador en realidad no hace un movimiento a la vez, sino que resuelve el rompecabezas en capas: tomando un estado, encuentra todos los movimientos v√°lidos que se pueden hacer.  Luego aplica todos estos movimientos al mismo tiempo y comienza de nuevo en un nuevo estado.  El n√∫mero de capas y el n√∫mero m√°ximo de movimientos encontrados en una capa se usan como valores aproximados de la profundidad y el ancho del √°rbol de b√∫squeda en su conjunto. <br><br>  Aqu√≠ se explica c√≥mo resolver uno de los acertijos dif√≠ciles con este modelo.  Las l√≠neas punteadas son l√≠neas extendidas en esta capa del solucionador, las l√≠neas continuas son aquellas que no han cambiado.  Las l√≠neas verdes tienen la longitud correcta, las rojas a√∫n no est√°n completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  El siguiente problema es que todos los movimientos realizados por el jugador son iguales.  Lo que enumeramos al comienzo de esta secci√≥n es solo sentido com√∫n.  Aqu√≠ hay un ejemplo de una regla de deducci√≥n m√°s compleja, cuya b√∫squeda requerir√° un poco m√°s de reflexi√≥n.  Considere el siguiente campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Los puntos en C y D pueden estar cubiertos solo por los cinco y los cuatro del medio (y ni un solo n√∫mero puede cubrir ambos puntos al mismo tiempo).  Esto significa que los cuatro en el medio deben cubrir uno de los dos puntos y, por lo tanto, no se pueden usar para cubrir A. Por lo tanto, el punto A debe cerrar los cuatro en la esquina inferior izquierda. <br><br>  Obviamente, ser√≠a una tonter√≠a considerar esta cadena de razonamiento igual a la simple conclusi√≥n "este punto solo puede ser alcanzado desde este n√∫mero".  ¬øEs posible dar m√°s peso a estas reglas m√°s complejas en la funci√≥n de evaluaci√≥n?  Desafortunadamente, en un solucionador basado en capas, esto no es posible, porque no se garantiza que encuentre una soluci√≥n al costo m√°s bajo.  Este no es solo un problema te√≥rico: en la pr√°ctica, a menudo sucede que parte del campo puede resolverse mediante un argumento complejo √∫nico o mediante una cadena de movimientos mucho m√°s simples.  De hecho, un solucionador basado en capas encuentra la ruta m√°s corta y no la menos costosa, y esto no puede reflejarse en la funci√≥n de evaluaci√≥n. <br><br>  Como resultado, tom√© esta decisi√≥n: cambi√© el solucionador para que cada capa constara de un solo tipo de razonamiento.  El algoritmo omite las reglas de razonamiento en un orden aproximado de complejidad.  Si la regla encuentra algunos movimientos, se aplican y la iteraci√≥n finaliza, y la siguiente iteraci√≥n comienza la lista desde el principio. <br><br>  Luego, a la decisi√≥n se le asigna una evaluaci√≥n: a cada capa se le asignan costos en funci√≥n de una regla que se utiliz√≥ en ella.  Esto todav√≠a no garantiza que la soluci√≥n sea la m√°s econ√≥mica, pero si los pesos se seleccionan correctamente, el algoritmo al menos no encontrar√° una soluci√≥n costosa si es barata. <br><br>  Adem√°s, es muy parecido a la forma en que las personas resuelven acertijos.  Primero intentan encontrar soluciones f√°ciles y comienzan a mover activamente sus cerebros solo si no hay movimientos simples. <br><br><h3>  Generador </h3><br>  La secci√≥n anterior determin√≥ si un nivel particular era bueno o malo.  Pero esto no es suficiente, a√∫n necesitamos generar niveles de alguna manera para que el solucionador pueda evaluarlos.  Es muy poco probable que un mundo generado aleatoriamente tenga soluci√≥n, por no mencionar interesante. <br><br>  La idea principal (de ninguna manera es nueva) es el uso alternativo del solucionador y el generador.  Comencemos con un rompecabezas, que probablemente no se pueda resolver: simplemente coloque de dos a cinco n√∫meros en cuadrados aleatorios de la celda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  Solver funciona hasta que pueda desarrollarse m√°s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Luego, el generador agrega m√°s informaci√≥n al rompecabezas en forma de un punto, despu√©s de lo cual la ejecuci√≥n del solucionador contin√∫a. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  En este caso, el punto agregado al solucionador no es suficiente para un mayor desarrollo.  Luego, el generador continuar√° agregando nuevos puntos hasta que satisfaga al solucionador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  Y luego el solucionador contin√∫a su trabajo habitual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Este proceso contin√∫a hasta que se resuelva el rompecabezas o hasta que quede m√°s informaci√≥n para agregar (por ejemplo, cuando cada celda que se puede alcanzar desde el n√∫mero ya contiene un punto). <br><br>  Este m√©todo solo funciona si la nueva informaci√≥n agregada no puede hacer que ninguna de las conclusiones hechas anteriormente sea incorrecta.  Esto ser√≠a dif√≠cil de hacer al agregar n√∫meros a la cuadr√≠cula <sup>[3]</sup> .  Pero agregar nuevos puntos al campo tiene esta propiedad;  al menos para las reglas de razonamiento que uso en este programa. <br><br>  ¬øD√≥nde deber√≠a agregar puntos el algoritmo?  Al final, decid√≠ agregarlos al espacio vac√≠o, que se puede cerrar en el estado inicial con tantas l√≠neas como sea posible, de modo que cada punto busque dar la menor informaci√≥n posible.  No intent√© colocar espec√≠ficamente el punto en el lugar donde ser√≠a √∫til para avanzar en la resoluci√≥n del rompecabezas en el momento en que el solucionador se atasca.  Esto crea un efecto muy conveniente: la mayor√≠a de los puntos al comienzo del rompecabezas parecen completamente in√∫tiles, lo que hace que el rompecabezas sea m√°s dif√≠cil de lo que realmente es.  Si todo esto son muchos movimientos obvios que un jugador puede hacer, pero por alguna raz√≥n, ninguno de ellos no funciona correctamente.  Como resultado, result√≥ que el generador de rompecabezas se comporta un poco como un cerdo. <br><br>  Este proceso no siempre crea una soluci√≥n, pero es bastante r√°pido (aproximadamente 50-100 milisegundos), por lo que para generar un nivel, simplemente puede repetirlo varias veces.  Desafortunadamente, generalmente crea rompecabezas mediocres.  Desde el principio, hay demasiados movimientos obvios, el campo se llena muy r√°pidamente y el √°rbol de decisi√≥n resulta ser poco profundo. <br><br><h3>  Optimizador </h3><br>  El proceso descrito anteriormente cre√≥ rompecabezas mediocres.  En la √∫ltima etapa, uso estos niveles como base para el proceso de optimizaci√≥n.  Funciona de la siguiente manera. <br><br>  El optimizador crea un grupo que contiene hasta 10 opciones de rompecabezas.  El grupo se inicializa con un nuevo rompecabezas aleatorio generado.  En cada iteraci√≥n, el optimizador selecciona un rompecabezas del grupo y realiza su mutaci√≥n. <br><br>  La mutaci√≥n elimina todos los puntos y luego cambia ligeramente los n√∫meros (es decir, disminuye / aumenta el valor de un n√∫mero seleccionado al azar o mueve el n√∫mero a otra celda de la cuadr√≠cula).  Puede aplicar varias mutaciones al campo al mismo tiempo.  Luego ejecutamos el solucionador en el modo de generaci√≥n de nivel especial descrito en la secci√≥n anterior.  Agrega suficientes puntos al rompecabezas para que pueda resolverse nuevamente. <br><br>  Despu√©s de eso, comenzamos el solucionador nuevamente, esta vez en modo normal.  Durante esta ejecuci√≥n, el solucionador monitorea a) la profundidad del √°rbol de decisi√≥n, b) la frecuencia de la necesidad de diferentes tipos de reglas, c) el ancho del √°rbol de decisi√≥n en diferentes momentos.  El rompecabezas se eval√∫a seg√∫n los criterios descritos anteriormente.  La funci√≥n de evaluaci√≥n prefiere soluciones profundas y estrechas, y los niveles de mayor complejidad tambi√©n agregan m√°s peso a los acertijos en los que se requieren reglas de razonamiento m√°s complejas. <br><br>  Luego se agrega un nuevo rompecabezas a la piscina.  Si el grupo contiene m√°s de 10 acertijos, se descarta lo peor. <br><br>  Este proceso se repite varias veces (aproximadamente 10,000-50000 iteraciones me llevaron).  Despu√©s de eso, la versi√≥n mejor calificada del rompecabezas se guarda en la base de datos de nivel de rompecabezas.  As√≠ es como se ve el progreso del mejor rompecabezas en una ejecuci√≥n de optimizaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Intent√© usar otras formas de estructurar la optimizaci√≥n.  En una versi√≥n, se us√≥ el recocido simulado; otros fueron algoritmos gen√©ticos con varias operaciones de cruce.  Ninguna de las soluciones funcion√≥ tan bien como un algoritmo ingenuo con un conjunto de opciones que regresan a la cima. <br><br><h3>  Soluci√≥n √∫nica √∫nica </h3><br>  Cuando un rompecabezas tiene una soluci√≥n √∫nica y √∫nica, surge una dificultad interesante.  ¬øEs posible permitir que el jugador asuma que hay una soluci√≥n y sacar conclusiones basadas en esto?  ¬øSer√≠a justo si el generador de rompecabezas sugiriera que el jugador lo hiciera? <br><br>  En una publicaci√≥n en HackerNews, dije que hay cuatro opciones para abordar esta situaci√≥n: <br><br><ul><li>  Declare la unicidad de la soluci√≥n desde el principio y obligue al generador a crear niveles que requieran este tipo de razonamiento.  Esta es una mala decisi√≥n porque complica la comprensi√≥n de las reglas.  Y generalmente estos son los detalles que la gente olvida. </li><li>  No garantice la singularidad de una decisi√≥n: potencialmente tenga muchas decisiones y tome todas ellas.  De hecho, esto no resuelve el problema, sino que lo aleja. </li><li>  Simplemente asuma que este es un evento muy raro, que en la pr√°ctica no es importante.  (Esta es la soluci√≥n que se utiliz√≥ en la implementaci√≥n inicial). </li><li>  Cambie el generador de rompecabezas para que no genere rompecabezas en los que el conocimiento de la singularidad de la soluci√≥n ayudar√≠a.  (Probablemente la soluci√≥n correcta, pero requiere trabajo adicional). </li></ul><br>  Inicialmente, eleg√≠ la √∫ltima opci√≥n, y ese fue un terrible error.  Result√≥ que tom√© en cuenta solo una forma en que la singularidad de la soluci√≥n condujo a la fuga de informaci√≥n, y en realidad es bastante raro.  Pero hay otros;  De hecho, uno de ellos estaba presente en todos los niveles que gener√© y a menudo condujo al hecho de que la soluci√≥n se volvi√≥ trivial.  Por lo tanto, en mayo de 2019, cambi√© los modos Hard y Expert usando la tercera opci√≥n. <br><br>  El caso m√°s molesto es un deuce con una l√≠nea discontinua en este campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  ¬øPor qu√© un jugador astuto puede llegar a tal conclusi√≥n?  Un deuce puede cubrir cualquiera de los cuatro cuadrados vecinos.  Ninguno de ellos tiene puntos, por lo que no tienen que estar cubiertos por una l√≠nea.  Y el cuadro de abajo no tiene superposiciones con ning√∫n otro n√∫mero.  Si hay una √∫nica soluci√≥n, entonces este deber√≠a ser el caso cuando otros n√∫meros cubren los tres cuadrados restantes, y los dos cierran el cuadrado debajo de √©l. <br><br>  La soluci√≥n es agregar algunos puntos m√°s al reconocer estos casos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Otro caso com√∫n es un gui√≥n con una l√≠nea de puntos en este campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Los cuadrados a la izquierda y arriba de los dos no son diferentes.  Ninguno de ellos tiene un punto, y ninguno puede ser alcanzado desde ning√∫n otro n√∫mero.  Cualquier soluci√≥n en la que un deuce cubra el cuadrado superior tendr√° una soluci√≥n correspondiente en la que cerrar√° el cuadrado izquierdo, y viceversa.  Si hubiera una √∫nica soluci√≥n √∫nica, entonces esta no podr√≠a ser, y el deuce deber√≠a haber cubierto el cuadrado inferior. <br><br>  Decid√≠ este tipo de caso de la forma "si duele, entonces no lo toques".  Solver aplic√≥ esta regla en una etapa temprana de la lista de prioridades y asign√≥ a tales movimientos un gran peso negativo.  Los acertijos con esta caracter√≠stica generalmente son descartados por el optimizador, y los pocos restantes se descartan en la etapa de la selecci√≥n final de niveles para el juego publicado. <br><br>  Esta no es una lista completa. Durante las pruebas de juego con una b√∫squeda deliberada de errores, encontr√© muchas otras reglas para soluciones √∫nicas.  Pero la mayor√≠a de ellos parec√≠an raros y eran suficientes para encontrar, por lo que no simplificaron mucho el juego.  Si alguien resuelve el acertijo usando tal razonamiento, entonces no lo culpar√© a ellos. <br><br><h3>  Conclusi√≥n </h3><br>  Inicialmente, el juego se desarroll√≥ como un experimento en la generaci√≥n procesal de acertijos.  El dise√±o y el generador del juego iban de la mano, por lo que las t√©cnicas en s√≠ mismas son dif√≠ciles de aplicar directamente a otros juegos. <br><br>  La pregunta a la que no tengo respuesta: ¬øse ha justificado la inversi√≥n de tales esfuerzos en la generaci√≥n procesal?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los comentarios de los jugadores sobre el dise√±o del nivel fueron muy controvertidos. En comentarios positivos, generalmente se dec√≠a que siempre se siente alg√∫n truco complicado en los rompecabezas. En la mayor√≠a de las cr√≠ticas negativas, me escribieron que el juego carece de un gradiente de complejidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a tengo un par de acertijos en su infancia, y me gust√≥ tanto el generador que probablemente utilizo un enfoque de procedimiento similar para ellos. Solo cambiar√© una cosa: desde el principio realizar√© pruebas de juego activas con la b√∫squeda de errores.</font></font><br><br><h3>  Notas </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] O, al menos, me pareci√≥ a m√≠. Pero cuando vi a los jugadores en vivo, casi la mitad de ellos solo hizo conjeturas y luego los iteraron. Oh bien </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Los lectores de mi art√≠culo tambi√©n deber√≠an leer el art√≠culo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solucionando Buscaminas y haci√©ndolo mejor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Aclarar√© que la profundidad / estrechez de un √°rbol es una m√©trica que consider√© importante para mi juego, y no para todos los otros acertijos. Por ejemplo, hay un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buen argumento de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que el rompecabezas de la Hora Punta es interesante si tiene varios caminos para resolver casi, pero no exactamente la misma longitud. Pero sucedi√≥ porque Rush Hour es un juego para encontrar la soluci√≥n m√°s corta, y no cualquier soluci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Excluyendo la adici√≥n de unidades. </font><font style="vertical-align: inherit;">No hab√≠a puntos en la primera versi√≥n del rompecabezas, y el plan era que el generador agregara unidades si fuera necesario. </font><font style="vertical-align: inherit;">Pero eso parec√≠a demasiado restrictivo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452090/">https://habr.com/ru/post/452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452076/index.html">Rompiendo el navegador UC</a></li>
<li><a href="../452078/index.html">Reserva de Kubernetes: existe</a></li>
<li><a href="../452082/index.html">Flujo flexible de actualizaciones en la aplicaci√≥n: acelerar el proceso de actualizaci√≥n de aplicaciones en Android</a></li>
<li><a href="../452086/index.html">Qu√© hay en mi p√≠xel para ti: crear nanop√≠xeles usando metasuperficies de plasm√≥n</a></li>
<li><a href="../452088/index.html">Reconocimiento de carreteras mediante segmentaci√≥n sem√°ntica.</a></li>
<li><a href="../452092/index.html">Actualizaciones en la aplicaci√≥n: acelerar las actualizaciones de aplicaciones de Android</a></li>
<li><a href="../452094/index.html">.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a. Parte 1</a></li>
<li><a href="../452098/index.html">Registros del desarrollador front-end Habr: refactor y reflex</a></li>
<li><a href="../452102/index.html">Juego de fotos para quienes gustan de los drones: brevemente sobre AirSelfie 2</a></li>
<li><a href="../452106/index.html">Invitamos a los oradores a la reuni√≥n de verano de bricolaje el 16 de junio de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>