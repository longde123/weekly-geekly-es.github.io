<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌞 👩🏾‍🤝‍👨🏽 👲🏼 FreePBX 配置Asterisk，以通过电子邮件通知队列中未接来电 👩🏼‍🤝‍👨🏻 🏊 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IP ATC Asterisk是功能强大的IP电话处理器。 为Asterisk创建的基于Web的FreePBX基于界面的界面大大简化了配置并降低了登录阈值。 
 如果您能提出与IP电话相关的某种任务，那么几乎可以肯定，它可以在Asterisk中实现。 但是请确保您需要坚韧和耐力。 

 我们面临着设...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FreePBX 配置Asterisk，以通过电子邮件通知队列中未接来电</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463829/"><img src="https://habrastorage.org/webt/ke/dl/08/kedl08qszm8sgw39uk2zteenbja.png" alt="图片"><br>  IP ATC Asterisk是功能强大的IP电话处理器。 为Asterisk创建的基于Web的FreePBX基于界面的界面大大简化了配置并降低了登录阈值。 <br> 如果您能提出与IP电话相关的某种任务，那么几乎可以肯定，它可以在Asterisk中实现。 但是请确保您需要坚韧和耐力。 <br><br> 我们面临着设置未接来电的电子邮件通知的任务。 更准确地说，是通过电子邮件通知有关入局排队的情况，但没有人（来自业务代表）已应答此入局呼叫。 <br><br> 令人惊讶的是，我们在FreePBX中找不到任何常规工具来解决此问题。 我将讨论如何在削减开支的情况下解决这个问题。 <br><a name="habracut"></a><br>  <b>前言</b> <br><br> 在“直接”解决问题之前，我们当然在Internet上搜索信息，但是没有找到交钥匙解决方案（也许它们看起来很差，但是您可以做什么...）。 <br><br> 直接在Asterisk中的工作技能并不像我们想要的那样多，因此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>提出的解决方案没有被完全理解，因此被放弃了。 <br><br> 我喜欢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>提出的解决方案，尽管没有用。 因此，他们强调在[ext-queue]的背景下，必须在Asterisk中工作。 并且由于我们在Freepbx中工作，因此我们需要在配置文件“ extensions_override_freepbx.conf”中工作。 我们注意到在hangupcall事件（通话结束）之前“捕获未接来电”很方便。 <br> 阅读完<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>的讨论后，我们想到了需要为队列中的所有代理过滤CDR中的“ Disposition”变量。 阅读完<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>信息后，便形成了非常具体的步骤来解决该任务。 <br><br>  <b>我们有什么：</b> <br><br> 有使用星号13.12.1。的FreePBX 13.0.197。 操作系统版本SHMZ 6.6版（最终版）。 该发行版基于CentOS。 <br><br> 星号配置了IVR（语音菜单），可将传入呼叫分散到不同的队列（队列）中。 代理（代理）被分配给每个队列，即代理。 <br><br>  <b>理论</b> <br><br>  <b>星号发生了什么</b> <br><br> 当来电到达星号时，该呼叫转到IVR。 呼叫者通过按电话上的特定号码进行选择，然后输入特定队列。 此后，队列中的所有空闲代理会同时收到呼叫。 <br><br> 为了更好地了解当前发生的情况以及接下来发生的情况，我们转向Report CDR（图1）。 <br><br><img src="https://habrastorage.org/webt/sv/qg/86/svqg86ls1ot8x4lcl5syw7oq3w0.png" alt="图片"><br>  <i>图1</i> <br><br> 当来电进入队列时，对于所有座席，如果座席当时不忙，变量“ Disposition”的值将等于“ NO ANSWER”。 变量“ Disposition”可以采用其他值（请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://asterisk-pbx.ru/wiki/asterisk/cf/cdr</a> ），但值“ ANSWERED”除外。 并且在座席之一应答来电时，此座席的“ Disposition”变量的值等于“ ANSWERED”。 <br> 从报告CDR中，您可以注意到，当呼叫排队时（在“应用程序”列中，该值变为“队列”），然后所有事件都以相同的“唯一身份”（“系统”列）出现。 <br><br>  <b>CDR简介</b> <br><br> 重要的是要了解什么是CDR，以及在CDR的什么点输入我们在报告CDR中观察到的数据。 相对于操作系统，CDR是Asterisk在其中记录详细的呼叫报告的数据库（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://asterisk-pbx.ru/wiki/asterisk/cf/cdr</a> ）。 在我们的例子中，这是一个名为asteriskcdrdb的数据库，位于mysql中。 根据经验，我们发现有关具有特定“唯一身份”呼叫的数据不是在事件发生后立即输入asteriskcdrdb，而是在hangupcall事件（呼叫结束）之后输入。 <br><br>  <b>解决方案的原理</b> <br><br> 由于我们对bash的了解多于对Asterisk的了解，因此主要思想如下。 在hangupcall事件之前，请调用bash脚本。 将3个参数传递给此脚本。 第一个参数是“ uniqueid”，以过滤从CDR接收的数据。 第二个参数是“ CALLERID（num）”（呼叫者的号码），用于知道要回叫的人。 第三个参数是“ NODEST”（队列号），已接到该呼叫，以便知道发生了什么问题，并且向谁发送未接来电的电子邮件通知。 <br>  bash脚本应连接到mysql中的asteriskcdrdb数据库，并使用特定的“ uniqueid”获取“ Disposition”变量的所有值。 从获得的数据中，必须排除以下值：“无应答”，“忙”，“失败”，“未知”。 结果，要么保留“ ANSWERED”（接听），要么接听来电，要么根本不接听。 <br><br> 此外，如果未接来电，脚本应发送电子邮件通知。 <br> 展望未来，我注意到一个重要的观点。 星号顺序执行命令，等待命令执行（通常是合乎逻辑的）。 在执行hangupcall命令之前，我们将调用bash脚本。 因此，在直接执行脚本的那一刻，关于我们要查找的唯一标识的信息尚未输入CDR。 为了解决这个问题，我们将使用“＆”参数调用bash脚本，以便Asterisk立即进入下一步，即hangupcall。 在bash脚本的内部，一开始，我们将设置一个小的时间延迟，以使Asterisk有时间输入CDR中我们感兴趣的“唯一queque”数据。 <br><br>  <b>练习</b> <br><br> 在继续配置Asterisk并创建bash脚本之前，您需要配置电子邮件通知的发送。 为此，我们将使用postfix实用程序。 <br><br>  <b>后缀设置</b> <br><br> 我们在Yandex中有一个邮件域“ lucky.ru”。 我们将在smtp-client模式下配置postfix，并从asterisk@lucky.ru帐户发送信件。 <br> 解决方案来自此处： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.dmosk.ru/miniinstruktions.php?mini=postfix-over-yandex</a> 。 <br><br> 首先安装/更新/检查软件包： <br><br><pre><code class="bash hljs">yum install postfix yum install mailx yum install cyrus-sasl cyrus-sasl-lib cyrus-sasl-plain</code> </pre> <br> 我们不会覆盖主要的postfix配置文件“ /etc/postfix/main.cf”，而是将其备份： <br><br><pre> <code class="bash hljs">cp /etc/postfix/main.cf /etc/postfix/main.cf.sav</code> </pre> <br> 我们编辑文件“ /etc/postfix/main.cf”，并将其转换为以下格式： <br><br><pre> <code class="bash hljs">nano /etc/postfix/main.cf <span class="hljs-comment"><span class="hljs-comment">##################### relayhost = smtp_sasl_auth_enable = yes smtp_sasl_password_maps = hash:/etc/postfix/private/sasl_passwd smtp_sasl_security_options = noanonymous smtp_sasl_type = cyrus smtp_sasl_mechanism_filter = login smtp_sender_dependent_authentication = yes sender_dependent_relayhost_maps = hash:/etc/postfix/private/sender_relay smtp_generic_maps = hash:/etc/postfix/generic smtp_tls_CAfile = /etc/postfix/ca.pem smtp_use_tls = yes smtputf8_autodetect_classes = all #####################</span></span></code> </pre> <br> 并非注释“ /etc/postfix/main.cf”中的每一行。 某些行中的注释不是由解析器确定的，而是传递给处理，这会导致错误。 最好拒绝此文件中的注释。 您可以通过在下一个窗口中运行“ tail -f / var / log / messages”进行试验。 <br><br> 我将标记为“ smtputf8_autodetect_classes = all”。 该条目默认包括utf-8，它使您可以在字母正文和主题行中使用西里尔字母，而无需进行其他操作（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.postfix.org/SMTPUTF8_README.html</a> ）。 <br><br> 为配置文件创建目录： <br><br><pre> <code class="bash hljs">mkdir /etc/postfix/private</code> </pre> <br> 我们编辑文件“ / etc / postfix / private / sender_relay”。 在其中，您需要指定使用我们的邮件域时需要引用的smtp服务器： <br><br><pre> <code class="bash hljs">nano /etc/postfix/private/sender_relay <span class="hljs-comment"><span class="hljs-comment">##################### @lucky.ru smtp.yandex.ru #####################</span></span></code> </pre> <br> 我们编辑文件“ / etc / postfix / private / sasl_passwd”。 在其中，我们将指示用于发送信件的电子邮件地址，以及该帐户的用户名和密码（我们通过冒号指定用户名和密码）： <br><br><pre> <code class="bash hljs">nano /etc/postfix/private/sasl_passwd <span class="hljs-comment"><span class="hljs-comment">##################### asterisk@lucky.ru asterisk@lucky.ru:password_asterisk #####################</span></span></code> </pre> <br> 编辑文件/ etc / postfix / generic。 在其中，我们将写下替换寄出地址的规则（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://wiki.merionet.ru/ip-telephoniya/30/postfix-nastrojka-otpravki-pochty-v-asterisk/</a> ）： <br><br><pre> <code class="bash hljs">nano /etc/postfix/generic <span class="hljs-comment"><span class="hljs-comment">##################### root asterisk@lucky.ru root@localhost asterisk@lucky.ru root@localhost.localdomain asterisk@lucky.ru root@freepbx asterisk@lucky.ru root@freepbx.localdomain asterisk@lucky.ru root@asterisk asterisk@lucky.ru root@asterisk.localdomain asterisk@lucky.ru asterisk asterisk@lucky.ru asterisk@localhost asterisk@lucky.ru asterisk@localhost.localdomain asterisk@lucky.ru asterisk@freepbx asterisk@lucky.ru asterisk@freepbx.localdomain asterisk@lucky.ru asterisk@asterisk asterisk@lucky.ru asterisk@asterisk.localdomain asterisk@lucky.ru root@localdomain.localdomain asterisk@lucky.ru #####################</span></span></code> </pre> <br> 初始外发地址取决于“ / etc / hosts”和“ / etc / hostname”的内容，以及发送信件的用户名。 也就是说，尽管事实上我们使用smtp客户端并从asterisk@lucky.ru发送信件，但后缀将最初将“其自身内容”替换为发件人的地址，并且应使用此配置文件中的规则进行更正。 <br><br> 我将列出我的/ etc / hosts文件的内容： <br><br><pre> <code class="bash hljs">cat /etc/hosts <span class="hljs-comment"><span class="hljs-comment">##################### 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 asterisk.localdomain 127.0.0.1 localhost.localdomain localhost ::1 asterisk localhost localhost6 #####################</span></span></code> </pre> <br> 服务器必须具有任何域（句点后的值），这一点很重要，因为邮件实用程序会在“ / etc / hosts”中“查找”域名，如果没有立即“查找”该域名，它将继续执行几分钟，然后然后才发信。 也就是说，如果未注册域，则该信件将延迟几分钟才能离开。 <br><br> 我将列出我的/ etc / hostname文件的内容： <br><br><pre> <code class="bash hljs">cat /etc/hostname <span class="hljs-comment"><span class="hljs-comment">##################### asterisk #####################</span></span></code> </pre> <br> 接下来，您需要将创建的配置文件传输到索引数据库，为此，请运行以下命令： <br><br><pre> <code class="bash hljs">postmap /etc/postfix/generic &amp;&amp; postmap /etc/postfix/private/{sasl_passwd,sender_relay}</code> </pre> <br> 接下来，我们需要下载smtp.yandex.ru证书并将其放置在服务器上，为此，请运行以下命令： <br><br><pre> <code class="bash hljs">openssl s_client -starttls smtp -crlf -connect smtp.yandex.ru:25 &gt; /etc/postfix/ca.pem</code> </pre> <br> 但是在屏幕上出现技术信息后，团队将“继续挂起”。 按Ctrl + C终止它。 <br><br> 现在，从结果文件中手动删除所有垃圾，仅保留证书。 您应该得到这样的内容： <br><br><pre> <code class="bash hljs">nano /etc/postfix/ca.pem <span class="hljs-comment"><span class="hljs-comment">##################### -----BEGIN CERTIFICATE----- MIIGazCCBVOgAwIBAgIQcUU9mJXW4OUs5Gf0JfLtsjANBgkqhkiG9w0BAQsFADBf ... nRG0DfdqYIuPGApFORYe -----END CERTIFICATE----- #####################</span></span></code> </pre> <br> 最后，重新启动后缀： <br><br><pre> <code class="bash hljs">service postfix restart</code> </pre> <br> 我们发送一封测试信： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span> | mail -s <span class="hljs-string"><span class="hljs-string">" "</span></span> admin@lucky.ru</code> </pre> <br>  admin@lucky.ru-目标地址 <br><br> 这样就完成了posfix配置。 <br><br>  <b>编写bash脚本</b> <br><br> 创建一个用于存储bash脚本的目录（这里有人喜欢的地方）： <br><br><pre> <code class="bash hljs">mkdir /home/asterisk/scripts</code> </pre> <br> 创建一个bash脚本文件： <br><br><pre> <code class="bash hljs">touch /home/asterisk/scripts/noanswer.sh</code> </pre> <br> 我们授予脚本文件执行权限： <br><br><pre> <code class="bash hljs">chmod +x /home/asterisk/scripts/noanswer.sh</code> </pre> <br> 如果对文件的权限存有疑问，那么在调试过程中，您可以授予对该文件的完全访问权限。 但这是“不安全的”。 <br><br><pre> <code class="bash hljs">chmod 777 /home/asterisk/scripts/noanswer.sh</code> </pre> <br>  bash脚本的文本： <br><br><pre> <code class="bash hljs">nano /home/asterisk/scripts/noanswer.sh <span class="hljs-comment"><span class="hljs-comment">##################### #!/bin/bash sleep 7 res_sql="SELECT disposition FROM cdr WHERE uniqueid = '$1'" answer=`mysql -u freepbxuser -pPassword_freepbxuser -D asteriskcdrdb -B -N -e "$res_sql" | grep -E -v "NO ANSWER|BUSY|FAILED|UNKNOWN" | head -n 1` error_kod=0 if [ "$answer" != "ANSWERED" ] then case $3 in 68800) address="big_boss@lucky.ru" subject="  " ;; 63100) address="debian@lucky.ru" subject="  linux debian" ;; 63200) address="windows@lucky.ru" subject="  windows" ;; 63300) address="freebsd@lucky.ru" subject="  freebsd" ;; 63400) address="ubuntu@lucky.ru" subject="  linux ubuntu" ;; 63500) address="centos@lucky.ru" subject="  linux centos" ;; *) address="admin@lucky.ru" error_kod=1 ;; esac case $error_kod in 0) echo "    $2,  $subject." | mail -s "   $2" $address echo "   $address   $2,  $subject. uid=$1" | mail -s "   $2" admin@lucky.ru ;; 1) echo "   $2.  . uid=$1" | mail -s "   $2" admin@lucky.ru ;; esac fi #####################</span></span></code> </pre> <br> 脚本的简要分析： <br>  “睡眠7”： <br><br> 这是我之前写的相同的时间延迟。 我们有7秒的延迟。 虽然，我认为，一秒钟就足够了。 <br><br><pre> <code class="sql hljs">«res_sql="<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> disposition <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cdr <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> uniqueid = <span class="hljs-string"><span class="hljs-string">'$1'</span></span><span class="hljs-string"><span class="hljs-string">"»:</span></span></code> </pre> <br> 为了方便起见，我们将mysql中的查询放入一个单独的变量中。 <br><br> 接下来，我们在mysql中发出一个请求，并过滤结果输出。 我们删除了除“ ANSWERED”以外的所有选项。 如果有多个“ ANSWERED”值，则只应保留一个。 最后，在变量“ answer”中，我们得到“ ANSWERED”或“”。 <br> 如果答案变量的值不等于ANSWERED，则这是未接来电。 根据队列号，使用大小写运算符，我们将设置必须向其发送电子邮件通知的地址以及该消息中的内容（消息的可变部分）。 <br><br> 以下是在Asterisk中设置队列但未在脚本中描述时的选项。 在这种情况下，admin @ lucky.ru将收到一封信，指出脚本不知道该队列。 <br><br> 如果描述了队列，则目的地信和重复的信将发送到admin@lucky.ru，指示“唯一”，以便在必要时可以跟踪此呼叫上的事件。 <br><br> 脚本结束。 <br><br> 我注意到，要连接到mysql，我们使用了我们预先识别的用户名和密码。 在FreePBX中，为了找出mysql中的Asterisk用户登录名，请运行以下命令： <br><br><pre> <code class="bash hljs">cat /etc/amportal.conf | grep AMPDBUSER</code> </pre> <br> 并且为了找出在MySQL的Asterisk用户的密码，请运行以下命令： <br><br><pre> <code class="bash hljs">cat /etc/amportal.conf | grep AMPDBPASS</code> </pre> <br>  <b>配置星号</b> <br><br> 我们使用FreePBX。  FreePBX具有不同类型的配置文件（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://asterisk-pbx.ru/wiki/freepbx/files</a> ），其中有一些是重新设计后由FreePBX覆盖的，而另一些则未被覆盖（称为自定义）。为用户。 <br><br> 我们将使用配置文件“ extensions_override_freepbx.conf”，因为它是定制类型的。 <br><br> 首先，确保在文件“ /etc/asterisk/extensions.conf”中连接了文件“ extensions_override_freepbx.conf”。 为此，请执行以下命令： <br><br><pre> <code class="bash hljs">cat /etc/asterisk/extensions.conf | grep extensions_override_freepbx.conf <span class="hljs-comment"><span class="hljs-comment">##################### #include extensions_override_freepbx.conf #####################</span></span></code> </pre> <br> 编辑文件“ /etc/asterisk/extensions_override_freepbx.conf”，并将其转换为以下格式： <br><br><pre> <code class="bash hljs">nano /etc/asterisk/extensions_override_freepbx.conf <span class="hljs-comment"><span class="hljs-comment">##################### [ext-queues] exten =&gt; h,1,System(/home/asterisk/scripts/noanswer.sh ${CDR(uniqueid)} ${CALLERID(num)} ${NODEST} &amp;) exten =&gt; h,2,Macro(hangupcall,) #####################</span></span></code> </pre> <br> 如我先前所写，结尾处必须有“＆”符号。 因为我们将直接从mysql数据库中使用带有CDR数据的bash脚本，并且仅在执行“ exten =&gt; h，2，Macro（hangupcall，）”之后将此数据输入mysql，所以我们不必等待bash脚本完成，然后继续进行Asterisk中的下一步。  bash脚本本身必须在执行其主要部分之前包含时间延迟。 <br><br> 为了使配置文件“ /etc/asterisk/extensions_override_freepbx.conf”中的更改生效，您需要使用以下命令重新启动Asterisk内核： <br><br><pre> <code class="bash hljs">/usr/sbin/asterisk -rx <span class="hljs-string"><span class="hljs-string">"core restart now"</span></span></code> </pre> <br> 创建bash脚本后需要执行此操作。 <br><br>  <b>结论</b> <br><br> 这可能是Asterisk中“捕获未接来电”的第1001条方法。 在评论中分享您如何解决此问题。 您认为可以改进/重做/优化什么。 我们将对建设性想法表示感谢。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463829/">https://habr.com/ru/post/zh-CN463829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463817/index.html">20位产品经理和所有最多的多维矩阵结构。 与Skyeng的对话</a></li>
<li><a href="../zh-CN463819/index.html">PostgreSQL锁：2.字符串锁</a></li>
<li><a href="../zh-CN463821/index.html">AMO，Bitrix，1C等：如何选择从哪里开始？</a></li>
<li><a href="../zh-CN463823/index.html">Rust 1.37.0版本：配置文件引导的优化，未命名的常量和货物供应商</a></li>
<li><a href="../zh-CN463825/index.html">Google表格项目管理工具</a></li>
<li><a href="../zh-CN463831/index.html">俄罗斯的IT教育有什么问题</a></li>
<li><a href="../zh-CN463833/index.html">关于阻滞剂的小型调查</a></li>
<li><a href="../zh-CN463835/index.html">危险的物联网：业务威胁和解决方案</a></li>
<li><a href="../zh-CN463839/index.html">博物馆数据艺术。 Lunolet和苏联计算器</a></li>
<li><a href="../zh-CN463845/index.html">电报是谁？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>