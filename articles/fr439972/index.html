<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè´ ‚ñ∂Ô∏è ‚ô®Ô∏è io_submit: une alternative √† epoll dont vous n'avez jamais entendu parler ü§òüèΩ üç† ‚úçüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, l'attention de l'auteur a √©t√© attir√©e par un article sur LWN sur une nouvelle interface de noyau pour l'interrogation. Il pr√©sente le nouve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>io_submit: une alternative √† epoll dont vous n'avez jamais entendu parler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/439972/"><img src="https://habrastorage.org/webt/sq/pn/nd/sqpnnd88db_ax0ark-6wxrqkobc.jpeg"><br><br>  R√©cemment, l'attention de l'auteur a √©t√© attir√©e par un article sur LWN sur une nouvelle interface de noyau pour l'interrogation.  Il pr√©sente le nouveau m√©canisme d'interrogation dans l'API Linux AIO (une interface pour la gestion des fichiers asynchrones), qui a √©t√© ajout√© √† la version 4.18 du noyau.  L'id√©e est assez int√©ressante: l'auteur du patch sugg√®re d'utiliser l'API Linux AIO pour travailler avec le r√©seau. <br><br>  Mais attendez un instant!  Apr√®s tout, Linux AIO a √©t√© cr√©√© pour fonctionner avec les E / S asynchrones d'un disque √† l'autre!  Les fichiers sur le disque ne sont pas les m√™mes que les connexions r√©seau.  Est-il m√™me possible d'utiliser l'API Linux AIO pour la mise en r√©seau? <br><br>  Il s'av√®re que oui, c'est possible!  Cet article explique comment utiliser les points forts de l'API Linux AIO pour cr√©er des serveurs r√©seau plus rapides et meilleurs. <br><br>  Mais commen√ßons par expliquer ce qu'est Linux AIO. <br><a name="habracut"></a><br><h1>  Introduction √† Linux AIO </h1><br>  Linux AIO fournit des E / S disque √† disque asynchrones pour les logiciels utilisateur. <br><br>  Historiquement, sous Linux, toutes les op√©rations sur disque √©taient bloqu√©es.  Si vous appelez <code>open()</code> , <code>read()</code> , <code>write()</code> ou <code>fsync()</code> , le flux s'arr√™te jusqu'√† ce que les m√©tadonn√©es apparaissent dans le cache disque.  Ce n'est g√©n√©ralement pas un probl√®me.  Si vous n'avez pas beaucoup d'op√©rations d'E / S et suffisamment de m√©moire, les appels syst√®me rempliront progressivement le cache et tout fonctionnera assez rapidement. <br><br>  Les performances des op√©rations d'E / S diminuent lorsque leur nombre est suffisamment important, par exemple dans les cas avec des bases de donn√©es et des proxys.  Pour de telles applications, il est inacceptable d'arr√™ter tout le processus pour attendre un appel syst√®me <code>read()</code> . <br><br>  Pour r√©soudre ce probl√®me, les applications peuvent utiliser trois m√©thodes: <br><br><ol><li>  Utilisez des pools de threads et des fonctions de blocage d'appels sur des threads s√©par√©s.  C'est ainsi que POSIX AIO fonctionne dans la glibc (ne le confondez pas avec Linux AIO).  Pour plus d'informations, voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation IBM</a> .  C'est ainsi que nous avons r√©solu le probl√®me dans Cloudflare: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous utilisons le pool de threads</a> pour appeler <code>read()</code> et <code>open()</code> . <br></li><li>  R√©chauffez le cache disque avec <code>posix_fadvise(2)</code> et esp√©rez le meilleur. <br></li><li>  Utilisez Linux AIO en conjonction avec le syst√®me de fichiers XFS, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouvrant des fichiers avec l'indicateur O_DIRECT</a> et en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©vitant les probl√®mes non document√©s</a> . <br></li></ol><br>  Cependant, aucune de ces m√©thodes n'est id√©ale.  M√™me Linux AIO, lorsqu'il est utilis√© sans r√©fl√©chir, peut √™tre bloqu√© dans l'appel <code>io_submit()</code> .  Cela a √©t√© r√©cemment mentionn√© dans un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur LWN</a> : <br><blockquote>  ¬´L'interface d'E / S asynchrone Linux a beaucoup de critiques et peu de partisans, mais la plupart des gens en attendent au moins de l'asynchronisme.  En fait, l'op√©ration AIO peut √™tre bloqu√©e dans le noyau pour un certain nombre de raisons dans des situations o√π le thread appelant ne peut pas se le permettre. ¬ª </blockquote>  Maintenant que nous connaissons les faiblesses de l'API Linux AIO, regardons ses points forts. <br><br><h2>  Un programme simple utilisant Linux AIO </h2><br>  Pour utiliser Linux AIO, vous devez d'abord <a href="">d√©terminer vous-m√™me les cinq appels syst√®me n√©cessaires</a> - la glibc ne les fournit pas. <br><br><ol><li>  Vous devez d'abord appeler <code>io_setup()</code> pour initialiser la structure <code>aio_context</code> .  Le noyau retournera un pointeur opaque sur la structure. <br></li><li>  Apr√®s cela, vous pouvez appeler <code>io_submit()</code> pour ajouter le vecteur des ¬´blocs de contr√¥le d'E / S¬ª √† la file d'attente de traitement sous la forme d'une structure struct iocb. <br></li><li>  Maintenant, enfin, nous pouvons appeler <code>io_getevents()</code> et en attendre une r√©ponse sous la forme d'un vecteur de structures <code>io_event</code> - les r√©sultats de chacun des blocs iocb. <br></li></ol><br>  Il y a huit commandes que vous pouvez utiliser dans iocb.  Deux commandes pour la lecture, deux pour l'√©criture, deux options fsync et la commande POLL, qui a √©t√© ajout√©e dans la version 4.18 du noyau (la huiti√®me commande est NOOP): <br><br><pre> <code class="plaintext hljs">IOCB_CMD_PREAD = 0, IOCB_CMD_PWRITE = 1, IOCB_CMD_FSYNC = 2, IOCB_CMD_FDSYNC = 3, IOCB_CMD_POLL = 5,   /* from 4.18 */ IOCB_CMD_NOOP = 6, IOCB_CMD_PREADV = 7, IOCB_CMD_PWRITEV = 8,</code> </pre> <br>  <a href=""><code> iocb</code></a> , qui est pass√©e √† la fonction <code>io_submit</code> , est assez grande et con√ßue pour fonctionner avec le disque.  Voici sa version simplifi√©e: <br><br><pre> <code class="plaintext hljs">struct iocb { __u64 data;           /* user data */ ... __u16 aio_lio_opcode; /* see IOCB_CMD_ above */ ... __u32 aio_fildes;     /* file descriptor */ __u64 aio_buf;        /* pointer to buffer */ __u64 aio_nbytes;     /* buffer size */ ... }</code> </pre> <br>  La structure <code>io_event</code> compl√®te <code>io_event</code> par <code>io_getevents</code> : <br><br><pre> <code class="plaintext hljs">struct io_event { __u64  data; /* user data */ __u64  obj; /* pointer to request iocb */ __s64  res; /* result code for this event */ __s64  res2; /* secondary result */ };</code> </pre><br>  <b>Un exemple.</b>  Un programme simple qui lit le fichier / etc / passwd √† l'aide de l'API Linux AIO: <br><br><pre> <code class="plaintext hljs">fd = open("/etc/passwd", O_RDONLY); aio_context_t ctx = 0; r = io_setup(128, &amp;ctx); char buf[4096]; struct iocb cb = {.aio_fildes = fd,                 .aio_lio_opcode = IOCB_CMD_PREAD,                 .aio_buf = (uint64_t)buf,                 .aio_nbytes = sizeof(buf)}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); struct io_event events[1] = {{0}}; r = io_getevents(ctx, 1, 1, events, NULL); bytes_read = events[0].res; printf("read %lld bytes from /etc/passwd\n", bytes_read);</code> </pre> <br>  Les sources compl√®tes sont bien s√ªr <a href="">disponibles sur GitHub</a> .  Voici la sortie strace de ce programme: <br><br><pre> <code class="plaintext hljs">openat(AT_FDCWD, "/etc/passwd", O_RDONLY) io_setup(128, [0x7f4fd60ea000]) io_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}]) io_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</code> </pre> <br>  Tout s'est bien pass√©, mais la lecture √† partir du disque n'√©tait pas asynchrone: l'appel io_submit a √©t√© bloqu√© et a fait tout le travail, la fonction <code>io_getevents</code> ex√©cut√©e instantan√©ment.  Nous pourrions essayer de lire de mani√®re asynchrone, mais cela n√©cessite l'indicateur O_DIRECT, avec lequel les op√©rations sur disque contournent le cache. <br><br>  Illustrons mieux comment <code>io_submit</code> verrouille sur des fichiers normaux.  Voici un exemple similaire qui montre la sortie de strace suite √† la lecture d'un bloc de 1 Go depuis <code>/dev/zero</code> : <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \   = 1 &lt;0.738380&gt; io_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \   = 1 &lt;0.000015&gt;</code> </pre> <br>  Le noyau a pass√© 738 ms sur un appel <code>io_submit</code> et seulement 15 ns sur <code>io_getevents</code> .  Il se comporte de la m√™me mani√®re avec les connexions r√©seau - tout le travail est effectu√© par <code>io_submit</code> . <br><br><img src="https://habrastorage.org/webt/e6/kw/kf/e6kwkfffjb-qvsfqgfdyl2ibmaq.jpeg"><br>  <a href="">Photo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helix84</a> CC / BY-SA / 3.0 <br><br><h2>  Linux AIO et r√©seau </h2><br>  L'impl√©mentation <code>io_submit</code> assez conservatrice: si le descripteur de fichier transmis n'a pas √©t√© ouvert avec l'indicateur O_DIRECT, la fonction bloque simplement et ex√©cute l'action sp√©cifi√©e.  Dans le cas des connexions r√©seau, cela signifie que: <br><br><ul><li>  pour bloquer les connexions, IOCV_CMD_PREAD attendra un paquet de r√©ponse; <br></li><li>  pour les connexions non bloquantes, IOCB_CMD_PREAD renverra le code -11 (EAGAIN). <br></li></ul><br>  La m√™me s√©mantique est √©galement utilis√©e dans l'appel syst√®me normal de <code>read()</code> , nous pouvons donc dire que io_submit lorsque vous travaillez avec des connexions r√©seau n'est pas plus intelligent que les bons anciens appels <code>read() / write()</code> . <br><br>  Il est important de noter que les requ√™tes <code>iocb</code> ex√©cut√©es s√©quentiellement par le noyau. <br><br>  Malgr√© le fait que Linux AIO ne nous aidera pas avec les op√©rations asynchrones, il peut √™tre utilis√© pour combiner les appels syst√®me en lots. <br><br>  Si le serveur Web doit envoyer et recevoir des donn√©es √† partir de centaines de connexions r√©seau, l'utilisation d' <code>io_submit</code> peut √™tre une excellente id√©e, car elle √©vite des centaines d'appels d'envoi et de r√©ception.  Cela am√©liorera les performances - le passage de l'espace utilisateur au noyau et vice versa n'est pas gratuit, en particulier apr√®s l'introduction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mesures de lutte contre Spectre et Meltdown</a> . <br><br><table><tbody><tr><td></td><td align="center">  <b>Un tampon</b> <br></td><td align="center">  <b>Tampons multiples</b> <br></td></tr><tr><td>  Un descripteur de fichier <br></td><td>  lire () <br></td><td>  readv () <br></td></tr><tr><td>  Descripteurs de fichiers multiples <br></td><td>  io_submit + IOCB_CMD_PREAD <br></td><td>  io_submit + IOCB_CMD_PREADV <br></td></tr></tbody></table><br>  Pour illustrer le regroupement des appels syst√®me en paquets √† l'aide de <code>io_submit</code> √©crivons un petit programme qui envoie des donn√©es d'une connexion TCP √† une autre.  Dans sa forme la plus simple (sans Linux AIO), il ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">while True: d = sd1.read(4096) sd2.write(d)</code> </pre> <br>  Nous pouvons exprimer la m√™me fonctionnalit√© via Linux AIO.  Le code dans ce cas sera comme ceci: <br><br><pre> <code class="plaintext hljs">struct iocb cb[2] = {{.aio_fildes = sd2,                     .aio_lio_opcode = IOCB_CMD_PWRITE,                     .aio_buf = (uint64_t)&amp;buf[0],                     .aio_nbytes = 0},                    {.aio_fildes = sd1,                    .aio_lio_opcode = IOCB_CMD_PREAD,                    .aio_buf = (uint64_t)&amp;buf[0],                    .aio_nbytes = BUF_SZ}}; struct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]}; while(1) { r = io_submit(ctx, 2, list_of_iocb); struct io_event events[2] = {}; r = io_getevents(ctx, 2, 2, events, NULL); cb[0].aio_nbytes = events[1].res; }</code> </pre> <br>  Ce code ajoute deux t√¢ches √† <code>io_submit</code> : d'abord une demande d'√©criture vers <code>sd2</code> , puis une demande de lecture depuis sd1.  Apr√®s lecture, le code corrige la taille du tampon d'√©criture et r√©p√®te la boucle depuis le d√©but.  Il y a une astuce: la premi√®re fois qu'une √©criture se produit avec un tampon de taille 0. Ceci est n√©cessaire car nous avons la possibilit√© de combiner √©criture + lecture en un <code>io_submit</code> appel <code>io_submit</code> (mais pas lecture + √©criture). <br><br>  Ce code est-il plus rapide que <code>read()</code> / <code>write()</code> normal?  Pas encore.  Les deux versions utilisent deux appels syst√®me: lecture + √©criture et io_submit + io_getevents.  Mais, heureusement, le code peut √™tre am√©lior√©. <br><br><h2>  Se d√©barrasser des io_getevents </h2><br>  Au moment de l'ex√©cution <code>io_setup()</code> noyau alloue plusieurs pages de m√©moire pour le processus.  Voici √† quoi ressemble ce bloc de m√©moire dans / proc // maps: <br><br><pre> <code class="plaintext hljs">marek:~$ cat /proc/`pidof -s aio_passwd`/maps ... 7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted) ...</code> </pre> <br>  Le bloc de m√©moire [aio] (12 Ko dans ce cas) a √©t√© allou√© <code>io_setup</code> .  Il est utilis√© pour le tampon circulaire o√π les √©v√©nements sont stock√©s.  Dans la plupart des cas, il n'y a aucune raison d'appeler <code>io_getevents</code> - les donn√©es de fin d'√©v√©nement peuvent √™tre obtenues √† partir du tampon en anneau sans avoir besoin de passer en mode noyau.  Voici la version corrig√©e du code: <br><br><pre> <code class="plaintext hljs">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,                struct io_event *events, struct timespec *timeout) {   int i = 0;   struct aio_ring *ring = (struct aio_ring*)ctx;   if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {       goto do_syscall;   }   while (i &lt; max_nr) {       unsigned head = ring-&gt;head;       if (head == ring-&gt;tail) {           /* There are no more completions */           break;       } else {           /* There is another completion to reap */           events[i] = ring-&gt;events[head];           read_barrier();           ring-&gt;head = (head + 1) % ring-&gt;nr;           i++;       }   }   if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {       /* Requested non blocking operation. */       return 0;   }   if (i &amp;&amp; i &gt;= min_nr) {       return i;   } do_syscall:   return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout); }</code> </pre> <br>  La version compl√®te du code est disponible <a href="">sur GitHub</a> .  L'interface de ce tampon en anneau est peu document√©e; l'auteur a adapt√© le code du <a href="">projet axboe / fio</a> . <br><br>  Apr√®s cette modification, notre version du code utilisant Linux AIO ne n√©cessite qu'un seul appel syst√®me dans une boucle, ce qui le rend un peu plus rapide que le code d'origine utilisant lecture + √©criture. <br><br><img src="https://habrastorage.org/webt/xq/er/7t/xqer7tve9zpg23gh2zfjjl_bb-i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Photo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Train Photos</a> CC / BY-SA / 2.0 <br><br><h2>  Alternative √† Epoll </h2><br>  Avec l'ajout de IOCB_CMD_POLL √† la version 4.18 du noyau, il est devenu possible d'utiliser <code>io_submit</code> en remplacement de select / poll / epoll.  Par exemple, ce code attendra des donn√©es d'une connexion r√©seau: <br><br><pre> <code class="plaintext hljs">struct iocb cb = {.aio_fildes = sd,                 .aio_lio_opcode = IOCB_CMD_POLL,                 .aio_buf = POLLIN}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); r = io_getevents(ctx, 1, 1, events, NULL);</code> </pre><br>  <a href="">Code complet</a> .  Voici sa sortie strace: <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \   = 1 &lt;0.000015&gt; io_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \   = 1 &lt;1.000377&gt;</code> </pre> <br>  Comme vous pouvez le voir, cette fois, l'asynchronie a fonctionn√©: io_submit ex√©cut√© instantan√©ment et <code>io_getevents</code> bloqu√©s pendant une seconde, en attente de donn√©es.  Cela peut √™tre utilis√© √† la place de l'appel syst√®me <code>epoll_wait()</code> . <br><br>  De plus, travailler avec <code>epoll</code> n√©cessite g√©n√©ralement l'utilisation des appels syst√®me epoll_ctl.  Et les d√©veloppeurs d'applications essaient d'√©viter les appels fr√©quents √† cette fonction - pour comprendre les raisons, il suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lire les</a> indicateurs EPOLLONESHOT et EPOLLET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le manuel</a> .  En utilisant io_submit pour interroger les connexions, vous pouvez √©viter ces difficult√©s et les appels syst√®me suppl√©mentaires.  Ajoutez simplement les connexions au vecteur iocb, appelez io_submit une fois et attendez l'ex√©cution.  Tout est tr√®s simple. <br><br><h2>  R√©sum√© </h2><br>  Dans cet article, nous avons couvert l'API Linux AIO.  Cette API a √©t√© initialement con√ßue pour fonctionner avec le disque, mais elle fonctionne √©galement avec les connexions r√©seau.  Cependant, contrairement aux appels r√©guliers en lecture () + √©criture (), l'utilisation de io_submit vous permet de regrouper les appels syst√®me et ainsi d'augmenter les performances. <br><br>  √Ä partir de la version 4.18 du noyau, <code>io_submit  io_getevents</code> dans le cas de connexions r√©seau peuvent √™tre utilis√©s pour les √©v√©nements de la forme POLLIN et POLLOUT.  C'est une alternative √† <code>epoll()</code> . <br><br>  Je peux imaginer un service r√©seau qui utilise uniquement <code>io_submit  io_getevents</code> au lieu de l'ensemble standard de lecture, √©criture, epoll_ctl et epoll_wait.  Dans ce cas, le regroupement des appels syst√®me dans <code>io_submit</code> peut donner un gros avantage, un tel serveur serait beaucoup plus rapide. <br><br>  Malheureusement, m√™me apr√®s les r√©centes am√©liorations apport√©es √† l'API Linux AIO, les discussions sur son utilit√© se poursuivent.  Il est bien connu que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Linus le d√©teste</a> : <br><br><blockquote>  ¬´L'AIO est un terrible exemple de conception √† hauteur de genou, o√π la principale excuse est:¬´ d'autres personnes moins talentueuses ont propos√© cela, nous devons donc nous conformer √† la compatibilit√© afin que les d√©veloppeurs de bases de donn√©es (qui sont rarement de bon go√ªt) puissent l'utiliser. ¬ª  Mais AIO a toujours √©t√© tr√®s, tr√®s tordu. ¬ª </blockquote><br>  Plusieurs tentatives ont √©t√© faites pour cr√©er une meilleure interface pour regrouper les appels et l'asynchronie, mais elles n'avaient pas de vision commune.  Par exemple, l' <a href="">ajout</a> r√©cent <a href="">de sendto (MSG_ZEROCOPY)</a> permet un transfert de donn√©es v√©ritablement asynchrone, mais ne pr√©voit pas de regroupement.  <code>io_submit</code> pr√©voit le regroupement, mais pas l'asynchronie.  Pire encore, il existe actuellement trois fa√ßons de fournir des √©v√©nements asynchrones sur Linux: signaux, <code>io_getevents</code> et MSG_ERRQUEUE. <br><br>  Dans tous les cas, il est formidable qu'il existe de nouvelles fa√ßons d'acc√©l√©rer le travail des services r√©seau. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439972/">https://habr.com/ru/post/fr439972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439962/index.html">Nous travaillons avec Atlassian Service Desk, nous tirons le meilleur parti du plug-in Riada Insight - un rapport de la r√©union du groupe d'utilisateurs Atlassian</a></li>
<li><a href="../fr439964/index.html">Vuln√©rabilit√© Runc CVE-2019-5736 dans un h√¥te</a></li>
<li><a href="../fr439966/index.html">Analyseur simple pour les op√©rations arithm√©tiques</a></li>
<li><a href="../fr439968/index.html">Espace de g√©n√©ration et espace d'opportunit√©</a></li>
<li><a href="../fr439970/index.html">Rapport sur les probl√®mes et l'accessibilit√© d'Internet en 2018-2019</a></li>
<li><a href="../fr439974/index.html">Transformation agile personnelle: un parcours flexible vers la productivit√©</a></li>
<li><a href="../fr439976/index.html">Node.js sera-t-il toujours plus lent que Golang?</a></li>
<li><a href="../fr439978/index.html">Docker d'apprentissage, Partie 2: Termes et concepts</a></li>
<li><a href="../fr439980/index.html">Apprendre Docker, Partie 3: Fichiers Dockerfile</a></li>
<li><a href="../fr439982/index.html">Tutoriel React, Partie 16: La quatri√®me phase de travail sur une application TODO, Traitement des √©v√©nements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>