<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‹ğŸ½ â˜¸ï¸ ğŸ• Kami memompa React hooks menggunakan FRP â˜¹ï¸ ğŸ‘¨ğŸ¾â€ğŸš€ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah menguasai kaitnya, banyak pengembang Bereaksi mengalami euforia, akhirnya mendapatkan toolkit sederhana dan nyaman yang memungkinkan Anda untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memompa React hooks menggunakan FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Setelah menguasai kaitnya, banyak pengembang Bereaksi mengalami euforia, akhirnya mendapatkan toolkit sederhana dan nyaman yang memungkinkan Anda untuk mengimplementasikan tugas dengan kode yang jauh lebih sedikit.  Tetapi apakah ini berarti bahwa standar useState dan useReducer hook yang ditawarkan di luar kotak adalah semua yang kita butuhkan untuk mengelola keadaan? </p><br><p>  Menurut pendapat saya, dalam bentuk mentah mereka, penggunaannya tidak terlalu nyaman, mereka lebih mungkin dianggap sebagai dasar untuk membangun kait manajemen negara yang benar-benar nyaman.  Bereaksi pengembang sendiri sangat mendorong pengembangan kait kustom, jadi mengapa tidak melakukannya?  Di bawah potongan, kita akan melihat contoh yang sangat sederhana dan dapat dimengerti tentang apa yang salah dengan kait biasa dan bagaimana kait itu dapat ditingkatkan, sedemikian rupa sehingga mereka sepenuhnya menolak untuk menggunakannya dalam bentuk murni mereka. </p><a name="habracut"></a><br><p>  Ada bidang tertentu untuk input, syarat, nama.  Dan ada tombol dengan mengklik di mana kita harus membuat permintaan ke server dengan nama yang dimasukkan (pencarian tertentu).  Tampaknya akan lebih mudah?  Namun, solusinya masih jauh dari jelas.  Implementasi naif pertama: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  Apa yang salah di sini?  Jika pengguna, memasukkan sesuatu di bidang, mengirim formulir dua kali, hanya permintaan pertama yang akan bekerja untuk kami, karena  pada permintaan klik kedua tidak akan berubah dan useEffect tidak akan berfungsi.  Jika kita membayangkan bahwa aplikasi kita adalah layanan pencarian tiket, dan pengguna dapat mengirim formulir berkali-kali tanpa membuat perubahan, maka implementasi seperti itu tidak akan berhasil bagi kita!  Menggunakan nama sebagai ketergantungan untuk useEffect juga tidak dapat diterima, jika tidak formulir akan segera dikirim ketika teks berubah.  Nah, Anda harus menunjukkan kecerdikan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Sekarang, dengan setiap klik, kami akan mengubah arti permintaan menjadi sebaliknya, yang akan mencapai perilaku yang diinginkan.  Ini adalah kruk yang sangat kecil dan tidak bersalah, tetapi membuat kodenya agak membingungkan untuk dipahami.  Mungkin sekarang Anda merasa bahwa saya mengisap masalah dari jari saya dan meningkatkan skalanya.  Nah, untuk menjawab apakah itu benar atau tidak, Anda perlu membandingkan kode ini dengan implementasi lain yang menawarkan pendekatan yang lebih ekspresif. </p><br><p>  Mari kita lihat contoh ini pada level teoretis menggunakan abstraksi thread.  Sangat mudah untuk menggambarkan status antarmuka pengguna.  Jadi, kami memiliki dua aliran: data dimasukkan ke dalam bidang teks (nama $), dan aliran klik pada tombol kirim formulir (klik $).  Dari mereka kita perlu membuat aliran permintaan gabungan ketiga ke server. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Inilah perilaku yang perlu kita capai.  Setiap aliran memiliki dua aspek: nilai yang dimilikinya, dan titik waktu di mana nilai mengalir melaluinya.  Dalam berbagai situasi, kita mungkin membutuhkan satu atau beberapa aspek, atau keduanya.  Anda dapat membandingkan ini dengan ritme dan harmoni dalam musik.  Aliran yang hanya memerlukan waktu respons juga disebut sinyal. </p><br><p>  Dalam kasus kami, klik $ adalah sinyal murni: tidak masalah nilai mana yang mengalir melaluinya (tidak ditentukan / benar / Peristiwa / apa pun), penting hanya ketika ini terjadi.  Nama kasus $ <br>  sebaliknya: perubahannya sama sekali tidak memerlukan perubahan apa pun dalam sistem, tetapi kita mungkin perlu maknanya di beberapa titik.  Dan dari dua aliran ini kita perlu membuat yang ketiga, mengambil dari yang pertama kali, dari yang kedua. </p><br><p>  Dalam hal Rxjs, kami memiliki operator yang hampir siap pakai untuk ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Namun, penggunaan praktis dari Rx dalam Bereaksi bisa sangat merepotkan.  Pilihan yang lebih cocok adalah pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mrr</a> , yang dibangun di atas prinsip fungsional-reaktif yang sama dengan Rx, tetapi secara khusus diadaptasi untuk digunakan dengan Bereaksi pada prinsip "reaktivitas total" dan dihubungkan sebagai pengait. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Antarmuka useMrr mirip dengan useState atau useReducer: ia mengembalikan objek keadaan (nilai semua utas) dan penyetel untuk memasukkan nilai ke dalam utas.  Tetapi di dalam semuanya sedikit berbeda: setiap bidang negara (= aliran), kecuali untuk yang kami beri nilai langsung dari peristiwa DOM, dijelaskan oleh fungsi dan daftar utas induk, perubahan yang akan menyebabkan anak dihitung ulang.  Dalam hal ini, nilai-nilai dari thread induk akan diganti ke dalam fungsi.  Jika kita hanya ingin mendapatkan nilai streaming, tetapi tidak menanggapi perubahannya, maka kita menulis "minus" di depan nama, seperti dalam kasus nama. </p><br><p>  Kami mendapat perilaku yang diinginkan, pada intinya, dalam satu baris.  Tapi ini bukan hanya singkatnya.  Mari kita bandingkan hasil yang diperoleh secara lebih rinci, dan pertama-tama berkenaan dengan parameter seperti keterbacaan dan kejelasan kode yang dihasilkan. </p><br><p>  Di mrr, Anda hampir dapat sepenuhnya memisahkan "logika" dari "templat": Anda tidak harus menulis penangan imperatif kompleks di BEJ.  Semuanya sangat deklaratif: kita hanya memetakan peristiwa DOM ke aliran yang sesuai, praktis tanpa konversi (untuk bidang input, nilai e.target.value diekstraksi secara otomatis, kecuali jika Anda menentukan sebaliknya), dan sudah dalam struktur useMrr kami menggambarkan bagaimana aliran dasar terbentuk anak perusahaan.  Jadi, dalam kasus transformasi data sinkron dan asinkron, kita selalu dapat dengan mudah melacak bagaimana nilai kita terbentuk. </p><br><p>  Dibandingkan dengan Px: kami bahkan tidak harus menggunakan operator tambahan: jika, sebagai akibatnya, fungsi mrr menerima janji, ia akan secara otomatis menunggu hingga diselesaikan dan memasukkan data yang diterima ke dalam aliran.  Juga, bukannya withLatestFrom, kami menggunakan <br>  mendengarkan pasif (tanda minus), yang lebih nyaman.  Bayangkan bahwa selain nama kita perlu mengirim bidang lain.  Kemudian di mrr kita akan menambahkan aliran mendengarkan pasif: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Dan di Rx Anda harus memahat satu lagi denganLestestFrom dengan peta, atau pertama-tama gabungkan nama dan nama keluarga menjadi satu aliran. </p><br><p>  Tetapi kembali ke kait dan mrr.  Catatan dependensi yang lebih mudah dibaca, yang selalu menunjukkan bagaimana data dibentuk, mungkin merupakan salah satu keuntungan utama.  Antarmuka useEffect saat ini pada dasarnya tidak memungkinkan untuk merespons aliran sinyal, itulah sebabnya <br>  Saya harus datang dengan tikungan yang berbeda. </p><br><p>  Poin lain adalah bahwa opsi kait biasa membawa rendering tambahan.  Jika pengguna hanya mengklik tombol, ini belum memerlukan perubahan apa pun pada UI yang perlu dibuat reaksi.  Namun, render akan dipanggil.  Dalam varian dengan mrr, status yang dikembalikan hanya akan diperbarui ketika respons dari server telah tiba.  Menyimpan pada pertandingan, katamu?  Yah, mungkin.  Tetapi bagi saya pribadi, prinsip "menyerahkan kembali diri Anda dalam situasi yang tidak dapat dipahami", yang merupakan dasar dari kait dasar, menyebabkan penolakan. </p><br><p>  Render tambahan berarti formasi penangan acara yang baru.  Ngomong-ngomong, di sini kait biasa semuanya buruk.  Tidak hanya penangan yang penting, mereka juga harus dilahirkan kembali setiap kali mereka memberikan.  Dan tidak mungkin menggunakan caching sepenuhnya di sini, karena  banyak penangan harus dikunci ke variabel komponen internal.  Penangan mrr lebih bersifat deklaratif, dan caching sudah terintegrasi dalam mrr: set ('name') akan dihasilkan hanya satu kali, dan akan diganti dari cache untuk render selanjutnya. </p><br><p>  Dengan peningkatan basis kode, penangan imperatif dapat menjadi lebih rumit.  Katakanlah kita juga perlu menunjukkan jumlah pengiriman formulir yang dilakukan oleh pengguna. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  Tidak terlihat cantik.  Tentu saja Anda dapat menjadikan pawang sebagai fungsi terpisah di dalam komponen.  Keterbacaan akan meningkat, tetapi masalah regenerasi fungsi dengan masing-masing render akan tetap, serta masalah imperatifitas.  Pada dasarnya, ini adalah kode prosedural biasa, meskipun ada kepercayaan luas bahwa React API secara bertahap berubah menuju pendekatan fungsional. </p><br><p>  Bagi mereka yang skala masalahnya kelihatannya berlebihan, saya dapat menjawab bahwa, misalnya, pengembang Bereaksi sendiri sadar akan masalah generasi penangan yang berlebihan, segera membantu kami menawarkan penopang dalam bentuk useCallback. </p><br><p>  Di mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Alternatif yang lebih nyaman adalah useReducer, memungkinkan Anda untuk meninggalkan keharusan penangan.  Tetapi masalah penting lainnya tetap ada: kurangnya bekerja dengan sinyal (karena efek yang sama akan menyebabkan efek samping), serta keterbacaan terburuk selama konversi asinkron (dengan kata lain, lebih sulit untuk melacak hubungan antara bidang-bidang toko, karena penggunaan yang sama. )  Jika di mrr grafik ketergantungan antara bidang negara (utas) langsung terlihat jelas, di kait Anda harus menjalankan mata sedikit ke atas dan ke bawah. </p><br><p>  Juga, berbagi useState dan useReducer dalam komponen yang sama sangat tidak nyaman (sekali lagi akan ada penangan imperatif kompleks yang akan mengubah sesuatu dalam useState <br>  dan mengirimkan tindakan), karena itu, kemungkinan besar, sebelum mengembangkan komponen, Anda harus menerima satu atau opsi lain. </p><br><p>  Tentu saja, pertimbangan semua aspek masih bisa dilanjutkan.  Agar tidak melampaui ruang lingkup artikel, saya akan menyentuh beberapa poin kurang penting secara penuh. </p><br><p>  Logging terpusat, debug.  Karena di mrr semua stream terkandung dalam satu hub, untuk debugging cukup untuk menambahkan satu flag: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Setelah itu, semua perubahan pada aliran akan ditampilkan di konsol.  Untuk mengakses seluruh status (mis., Nilai saat ini dari semua utas), ada kondisi $ pseudo-stream: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Dengan demikian, jika Anda perlu atau jika Anda sangat terbiasa dengan gaya editorial, Anda dapat menulis dengan gaya editor di mrr, mengembalikan nilai bidang baru berdasarkan peristiwa dan seluruh keadaan sebelumnya.  Tetapi sebaliknya (menulis di useReducer atau editor dalam gaya mrr) tidak akan berfungsi, karena kurangnya reaktivitas di dalamnya. </p><br><p>  Bekerjalah dengan waktu.  Ingat dua aspek aliran: makna dan waktu respons, harmoni dan ritme?  Jadi, bekerja dengan yang pertama di kait biasa cukup sederhana dan nyaman, tetapi dengan yang kedua - tidak.  Dengan bekerja seiring waktu, maksud saya adalah pembentukan aliran anak, yang "ritme" -nya berbeda dari orangtua.  Ini terutama semua jenis filter, debown, trotl, dll.  Semua ini kemungkinan besar harus Anda laksanakan sendiri.  Di mrr, Anda dapat menggunakan pernyataan siap pakai di luar kotak.  Tuan-tuan mengatur mrr lebih rendah daripada berbagai operator Rx, tetapi memiliki penamaan yang lebih intuitif. </p><br><p>  Interaksi antar komponen.  Saya ingat bahwa di Editor itu dianggap praktik yang baik untuk membuat hanya satu cerita.  Jika kita menggunakan useReducer di banyak komponen, <br>  Mungkin ada masalah dengan organisasi interaksi antara para pihak.  Pada mrr, flow dapat dengan bebas "mengalir" dari satu komponen ke komponen lainnya baik ke atas atau ke bawah hierarki, tetapi ini tidak akan menimbulkan masalah karena pendekatan deklaratif.  Lebih detail <br>  topik ini, serta fitur-fitur lain dari API mrr, dijelaskan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktor + FRP dalam Bereaksi</a> </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p>  Kait reaksi baru sangat bagus dan menyederhanakan kehidupan kita, tetapi kait tersebut memiliki beberapa kelemahan yang dapat diperbaiki oleh kait tujuan umum tingkat tinggi (manajemen negara).  UseMrr dari pustaka mrr fungsional-reaktif diusulkan dan dianggap demikian. </p><br><p>  Masalah dan solusinya: </p><br><ul><li>  penghitungan ulang data yang tidak perlu pada setiap render (dalam mrr tidak ada karena reaktivitas berbasis push) </li><li>  rendering tambahan saat perubahan status tidak memerlukan perubahan UI </li><li>  keterbacaan kode yang buruk dengan konversi asinkron (dibandingkan dengan yang sinkron).  Dalam mrr, kode asinkron tidak kalah dengan sinkron dalam keterbacaan dan ekspresif.  Sebagian besar masalah yang dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terbaru tentang useEffect</a> pada mrr pada dasarnya tidak mungkin </li><li>  penangan imperatif yang tidak selalu dapat di-cache (di mrr mereka di-cache secara otomatis, hampir selalu dapat di-cache, deklaratif) </li><li>  menggunakan useState dan useReducer pada saat yang sama dapat membuat kode canggung </li><li>  kurangnya alat untuk mengubah aliran dari waktu ke waktu (debounce, throttle, kondisi balapan) </li></ul><br><p>  Pada banyak titik, orang dapat berargumen bahwa mereka dapat diselesaikan dengan kait kustom.  Tetapi inilah tepatnya yang diusulkan, tetapi alih-alih implementasi yang berbeda, untuk setiap tugas yang terpisah, solusi holistik, yang konsisten diusulkan. </p><br><p>  Banyak masalah menjadi terlalu akrab bagi kita untuk dikenali dengan jelas.  Misalnya, konversi asinkron selalu terlihat lebih rumit dan membingungkan daripada yang sinkron, dan kaitan dalam pengertian ini tidak lebih buruk daripada pendekatan sebelumnya (eds, dll.).  Untuk mewujudkan ini sebagai masalah, Anda harus terlebih dahulu melihat pendekatan lain yang menawarkan solusi yang lebih baik. </p><br><p>  Artikel ini dimaksudkan untuk tidak memaksakan pandangan tertentu, tetapi lebih untuk menarik perhatian pada masalah tersebut.  Saya yakin ada solusi lain atau sedang dibuat yang bisa menjadi alternatif yang layak, tetapi belum menjadi dikenal luas.  API Cache React yang akan datang juga dapat membuat perbedaan besar.  Saya akan senang kritik dan diskusi di komentar. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mereka yang</a> tertarik juga dapat menonton presentasi tentang topik ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kyivj</a> pada 28 Maret. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445214/">https://habr.com/ru/post/id445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445204/index.html">Konversi aliran dari basis data Firebird 2.5 ke format ODS12 (Firebird 3.0)</a></li>
<li><a href="../id445206/index.html">Kurangi waktu henti saat meningkatkan Zimbra</a></li>
<li><a href="../id445208/index.html">Tingkat Kematangan TI Perusahaan</a></li>
<li><a href="../id445210/index.html">Koloni Cryptocurrency</a></li>
<li><a href="../id445212/index.html">NetBIOS ada di tangan seorang hacker</a></li>
<li><a href="../id445220/index.html">AMD Radeon VII: Chip High-End (Bagian 3)</a></li>
<li><a href="../id445222/index.html">Dapatkan tawaran dalam 1 hari untuk tim backend pada Hari Kosmonautika</a></li>
<li><a href="../id445226/index.html">Pengembangan roket yang mampu mencapai bulan akan menelan biaya Rusia 740 miliar rubel</a></li>
<li><a href="../id445228/index.html">Kriptografi di Jawa. Kelas Mac</a></li>
<li><a href="../id445230/index.html">Pendaftaran untuk konferensi IT II untuk pemula SMARTRHINO-2019 dimulai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>