<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèø üç≠ üíπ Un exemple de calcul de la r√©action du signal √† l'aide de la transform√©e de Fourier dans MATLAB üíÖüèº ‚òùüèΩ üë©üèº‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la r√©solution des probl√®mes de transmission de donn√©es √† travers des lignes repr√©sent√©es par des caract√©ristiques de fr√©quence, des transform√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un exemple de calcul de la r√©action du signal √† l'aide de la transform√©e de Fourier dans MATLAB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416497/">  Lors de la r√©solution des probl√®mes de transmission de donn√©es √† travers des lignes repr√©sent√©es par des caract√©ristiques de fr√©quence, des transform√©es de Fourier sont appliqu√©es - le transfert de signaux du domaine temporel vers le domaine fr√©quentiel et vice versa.  L'environnement MATLAB dispose d'un ensemble complet de fonctions pour r√©soudre de tels probl√®mes.  Dans ce travail, un exemple de calcul dans MATLAB la r√©action d'un signal transmis √† travers une ligne dont la caract√©ristique est mesur√©e √† des fr√©quences qui ne co√Øncident pas avec la fr√©quence de transfert de donn√©es est analys√©.  J'esp√®re que cet exemple facilitera la compr√©hension des fonctionnalit√©s de la technologie de conversion de signal dans l'environnement MATLAB. <br><br><h3>  Condition de t√¢che </h3><br>  Il est n√©cessaire de d√©terminer la modification de la forme du signal num√©rique binaire passant par le filtre et la ligne de signal.  Le signal est d√©fini par l'amplitude et la vitesse de transmission.  Le filtre de second ordre, normalis√© √† la fr√©quence de transfert de donn√©es, est d√©fini par des constantes de temps.  La fonction de transfert de la ligne de signal est repr√©sent√©e par la r√©ponse en fr√©quence mesur√©e sous forme complexe. <br><br>  L'environnement utilis√© pour calculer et afficher les donn√©es est MATLAB R2015a. <br>  Les relations suivantes publi√©es sur le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.StatEye.org</a> pour la version de la m√©thode GUI StatEye 3.0 [1, 2, 3] ont √©t√© prises comme exemple des donn√©es initiales. <br><br>  D√©bit bps = 10,3125 Gbit / s.  Les constantes de temps du filtre de second ordre normalis√© sont les m√™mes; leur r√©ciproque est ¬æ de la fr√©quence de transmission des donn√©es.  La ligne de signal est repr√©sent√©e par une r√©ponse en fr√©quence.  La caract√©ristique a √©t√© mesur√©e au canal f = 0,006495: 0,0012475: 20 GHz.  Le nombre sp√©cifi√© de points d'√©chantillonnage de la transform√©e de Fourier: points = 2 ^ 13. <br><a name="habracut"></a><br>  La figure 1 montre les r√©sultats du transfert, de la s√©quence et du traitement des donn√©es discut√©s dans cet article.  La transition du domaine temporel au domaine fr√©quentiel et vice versa est effectu√©e √† l'aide de l'algorithme de transformation de Fourier rapide (FFT). <br><img src="https://habrastorage.org/webt/ex/c8/fw/exc8fwf3_bfcnnczjnoo_qdj43q.png" alt="image"><br>  <i>Figure 1. Canal de donn√©es.</i>  <i>Signal d'entr√©e iSignal.Tx, signal de sortie du filtre iSignal.Filter_out, ligne de signal de sortie iSignal.Rx.</i>  <i>Les caract√©ristiques montr√©es dans le diagramme sont discut√©es ci-dessous.</i> <br><br><h3>  S√©quence de calcul </h3><br>  Dans ce travail, les principaux calculs sont effectu√©s dans le domaine fr√©quentiel.  Pour cela, le signal d'origine du domaine temporel est transf√©r√© vers le domaine fr√©quentiel √† l'aide de la transform√©e de Fourier, en multipliant les caract√©ristiques spectrales du signal, du filtre et de la ligne de signal, le signal de sortie du chemin est trouv√©, qui est transf√©r√© du domaine fr√©quentiel au domaine temporel par la transform√©e de Fourier inverse. <br><br>  Le taux de transfert de donn√©es est deux fois plus √©lev√© que la fr√©quence √† laquelle les donn√©es sont transmises.  La fr√©quence maximale de la ligne de signal mesur√©e max (channel.f) = 20 GHz.  √Ä cette fr√©quence, les donn√©es peuvent √™tre transmises √† une vitesse de 40 Gbit / s (comme 2 * max (channel.f)). <br><br>  Le d√©bit de transfert de donn√©es maximal, qui ne d√©passe pas le d√©bit de transmission maximal sur la ligne de signal de 40 Gbit / s et un d√©bit de transmission multiple bps = 10,3125 Gbit / s, est fmax = 30,9375 Gbit / s, la multiplicit√© N = 3 (N = fmax / bps).  En outre, fmax est utilis√© comme fr√©quence limite pour calculer la r√©ponse du signal en utilisant la transform√©e de Fourier. <br><br><h3>  Traduction du signal d'entr√©e dans le domaine fr√©quentiel </h3><br>  Discr√©tion temporelle pour construire le signal d'entr√©e (bit de donn√©es) dans le domaine temporel Ts = 1 / fmax;  Ts = 3,232e-11 s.  Normalis√© par rapport √† la dur√©e du signal, l'√©chelle de temps se compose de 2 ^ 13 points (points), l'√©chelle comprend le tableau suivant de points temps = bps / Ts. * (1: points).  Un signal unique discret √† un taux de transmission de bps = 10,3125 Gbit / s et une quantification avec une p√©riode Ts = 1 / fmax se compose de trois points dans la plage de 10 √† 11 unit√©s de temps normalis√©.  Un signal d'amplitude unitaire peut √™tre g√©n√©r√© n'importe o√π ailleurs sur la chronologie, mais il est pr√©f√©rable de prendre du recul par rapport aux bords pour voir pleinement l'arri√®re-plan et le processus de transition du signal de sortie.  Un signal d'impulsion (bit de donn√©es) construit √† l'aide des commandes MATLAB suivantes est illustr√© √† la figure 2. <br><br><pre><code class="matlab hljs">iSignal.Tx(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(time,<span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>; t0 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>)); t1 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>)); iSignal.Tx(t0:t1) = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/qf/df/ec/qfdfec6aehsjzwgjgenqazdh82y.png" alt="image"><br>  <i>Figure 2. Signal d'impulsion d'entr√©e iSignal.Tx, bit de donn√©es.</i> <br><br>  La traduction du signal iSignal.Tx dans le domaine fr√©quentiel est effectu√©e par les fonctions FFT suivantes. <br><br><pre> <code class="matlab hljs">iSignal.shiftedPSD = fft(iSignal.Tx); iSignal.PSD = fftshift(iSignal.shiftedPSD);</code> </pre> <br>  La fonction de transformation de Fourier fft construit un spectre sym√©trique du signal dans les r√©gions de fr√©quences positives et n√©gatives, dont la fr√©quence maximale est au centre du spectre (voir figure 3).  La fonction fftshift restaure le spectre en d√©calant vers le centre la fr√©quence z√©ro du signal comme indiqu√© sur la figure 4. <br><br>  La r√©solution de la fr√©quence du spectre est fs = fmax / points;  Les fr√©quences du spectre varient de -fmax / 2 √† fmax / 2-fs et sont √©gales √† f = -fmax / 2: fs: fmax / 2-fs; <br><br><img src="https://habrastorage.org/webt/ho/8s/sb/ho8ssbopxofj9awqb5rudr9i4ks.png" alt="image"><br>  <i>Figure 3. R√©ponse en amplitude du spectre d√©cal√© du signal iSignal.Tx obtenu en utilisant la FFT.</i> <br><br><img src="https://habrastorage.org/webt/gr/hn/lc/grhnlcgd4yp6lhei-wwiqw_ui0c.png" alt="image"><br>  <i>Figure 4. R√©ponse en amplitude du spectre reconstruit du signal iSignal.Tx repr√©sent√© sur la figure 3. 2 ^ 13 √©chantillons sont pr√©sent√©s.</i>  <i>Le compte moyen √† 4097 correspond √† une fr√©quence nulle.</i>  <i>Les fr√©quences n√©gatives sont situ√©es sur le c√¥t√© gauche (de 1 √† 4096 points), et la r√©gion des fr√©quences positives sur le c√¥t√© droit (de 4098 √† 8192 points).</i> <br><br><h3>  Fonction de transfert du filtre passe-bas normalis√© </h3><br>  Dans cet exemple, la fonction de transfert du filtre de second ordre a la forme <br><br><img src="https://habrastorage.org/webt/bz/ov/pt/bzovptea80xq-lyjjgayndllj98.png" alt="image"><br>  o√π T1 et T2 sont des constantes de temps de filtrage.  Les fr√©quences 1 / T1 sont √©gales et 1 / T2 sont fix√©es par rapport √† la fr√©quence √† laquelle les donn√©es sont transmises: 1 / T1 = 1 / T2 = 0,75 * bps (bps = 10,3125 Gbit / s). <br><br>  Bande passante de filtre normalis√©e <br><br><pre> <code class="matlab hljs">f_nrm =fmax/bps/points.*(-points/<span class="hljs-number"><span class="hljs-number">2</span></span>:points/<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>).</code> </pre> <br>  Op√©ratrice <br><br><pre> <code class="matlab hljs">s = f_nrm .* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>;</code> </pre> <br>  La caract√©ristique amplitude-phase du filtre normalis√© pour les fr√©quences positives et n√©gatives normalis√©es par rapport √† la fr√©quence de transmission du signal est repr√©sent√©e sur la figure 5. La caract√©ristique logarithmique amplitude-fr√©quence du filtre est repr√©sent√©e sur la figure 6. <br><br><img src="https://habrastorage.org/webt/ct/32/rj/ct32rjkglsoalv2s9lq9sdc41xy.png" alt="image"><br>  <i>Figure 5. La caract√©ristique amplitude-phase d'un filtre normalis√©</i> <br><br><img src="https://habrastorage.org/webt/fa/zp/x5/fazpx5t-iptrisubkndxs-aizes.png" alt="image"><br>  <i>Figure 6. R√©ponse en fr√©quence amplitude-phase logarithmique d'un filtre normalis√©.</i>  <i>La ligne pointill√©e bleue montre la position de la fr√©quence du filtre avec une valeur de 0,75 de la fr√©quence √† laquelle les donn√©es sont transmises.</i>  <i>A cette fr√©quence (1 / T1 = 1 / T2), le coefficient de transmission du filtre de second ordre est de -6 d√©cibels.</i>  <i>La ligne pointill√©e rouge indique la fr√©quence unitaire √† laquelle les donn√©es sont transmises.</i> <br><br><h3>  Traduction des r√©sultats de mesure de ligne de signal en type de fonction de transfert </h3><br>  La caract√©ristique d'amplitude-phase mesur√©e de la ligne de signal comprend 1599 √©chantillons dans la bande jusqu'√† 20 GHz avec un pas fixe de 12,475 MHz.  Il contient les valeurs de fr√©quence suivantes: channel.f = 0,006495: 0,0012475: 20 GHz.  Initialement, la ligne de signal √©tait repr√©sent√©e par une caract√©ristique √† quatre bornes.  Cette caract√©ristique a √©t√© transform√©e et est utilis√©e dans l'exemple comme une fonction complexe unidimensionnelle. <br><br>  Les fr√©quences caract√©ristiques de la ligne de signal obtenues √† la suite de la mesure ne co√Øncident pas avec les fr√©quences du spectre du signal d'entr√©e qui sont des multiples de la fr√©quence de transmission des donn√©es.  De plus, le spectre de ligne de signal ne contient que des fr√©quences positives et ne contient pas de fr√©quences dans la r√©gion z√©ro.  Le spectre du signal d'entr√©e contient des fr√©quences positives, nulles et n√©gatives. <br>  Pour convertir les caract√©ristiques de la ligne de signal en une fonction de transfert - une caract√©ristique dont les fr√©quences co√Øncident avec les fr√©quences du spectre du signal d'entr√©e, les √©tapes suivantes sont prises. <br><br>  1. Le calcul de l'amplitude des caract√©ristiques de la ligne √† fr√©quence nulle en l'extrapolant.  Pour cela, √† partir de dix points de la caract√©ristique d'amplitude les plus proches de la fr√©quence z√©ro, on trouve les coefficients d'un polyn√¥me lin√©aire qui se rapprochent de la caract√©ristique d'amplitude: <br><br><pre> <code class="matlab hljs">[a] = polyfit(channel.f(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Le deuxi√®me coefficient polynomial trouv√© est √©gal √† l'amplitude de la caract√©ristique √† fr√©quence nulle: <br><br><pre> <code class="matlab hljs">channel.dc = a(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  2. La r√©ponse de phase √† fr√©quence nulle est prise √©gale √† z√©ro. <br><br><pre> <code class="matlab hljs">channel.dcPhase = <span class="hljs-number"><span class="hljs-number">0.00</span></span>;</code> </pre> <br>  3. Le recalcul des caract√©ristiques d'amplitude channel.abs et phase channel.phase de la ligne de signal avec des valeurs √† fr√©quence nulle est effectu√© sur la fr√©quence du spectre du signal d'entr√©e (f = -fmax / 2: fmax / points: fmax / 2-fmax / points) avec extrapolation des caract√©ristiques √† zone de fr√©quences nulles et n√©gatives: <br><br><pre> <code class="matlab hljs">ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dc channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.phase = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dcPhase <span class="hljs-built_in"><span class="hljs-built_in">unwrap</span></span>(channel.phase)], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.s = ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> .* <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(+<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>.*ichannel.phase); ichannel.tf = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ichannel.s) + <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">imag</span></span>(ichannel.s) .* <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(f);</code> </pre> <br>  La fonction de transfert obtenue - la r√©ponse en fr√©quence amplitude-phase du canal dans la r√©gion des basses fr√©quences est illustr√©e √† la figure 7. Les caract√©ristiques amplitude-fr√©quence de la ligne de signal mesur√©e et la fonction de transfert calcul√©e dans les gammes de fr√©quences compl√®tes sont illustr√©es √† la figure 8. Les m√™mes caract√©ristiques dans l'espace des phases sont illustr√©es √† la figure 9. <br><br><img src="https://habrastorage.org/webt/u0/wm/sl/u0wmslmlvtgejybmkwlmg-qwxcg.png" alt="image"><br>  <i>Figure 7. La fonction de transfert de la ligne de signal dans la r√©gion des basses fr√©quences.</i>  <i>Les points rouges et bleus indiquent respectivement les caract√©ristiques discr√®tes d'amplitude et de phase.</i>  <i>La r√©ponse en amplitude est indiqu√©e en d√©cibels, la phase en radians.</i>  <i>La ligne rose marque la fr√©quence la plus basse de la caract√©ristique mesur√©e de la ligne de signal.</i>  <i>Le coefficient de transmission √† fr√©quence nulle est de 0,992.</i> <br><br><img src="https://habrastorage.org/webt/4o/q5/yd/4oq5ydmnjdijeopyumfiir0nlia.png" alt="image"><br>  <i>Figure 8. R√©ponse en fr√©quence de la ligne de signal.</i>  <i>Les points bleus indiquent les donn√©es complexes de la ligne mesur√©e.</i>  <i>La d√©pendance sym√©trique calcul√©e du gain de la ligne de signal aux fr√©quences du spectre du signal d'entr√©e est surlign√©e en rouge.</i>  <i>Dans la r√©gion de fr√©quence nulle, cette caract√©ristique est illustr√©e √† la figure 7.</i> <br><br><img src="https://habrastorage.org/webt/nx/zp/xo/nxzpxosf_rti2d2-zdny6p-qbrw.png" alt="image"><br>  <i>Figure 9. Caract√©ristiques de fr√©quence amplitude-phase de la ligne de donn√©es mesur√©e et son spectre normalis√©.</i> <br><br><h3>  Calcul de la r√©ponse du signal </h3><br>  La r√©ponse (r√©ponse √† l'effet d'entr√©e) dans le domaine fr√©quentiel est obtenue en multipliant le spectre du signal par le produit des fonctions de transfert des √©l√©ments qui relient la r√©action au signal d'entr√©e.  Dans notre cas, le signal passe √† travers le filtre et la ligne de signal. <br>  La transform√©e de Fourier inverse ifft est utilis√©e pour transf√©rer le signal du domaine fr√©quentiel vers le domaine temporel. <br><br>  La sortie du filtre dans le domaine temporel iSignal.Filter_out est calcul√©e comme suit: <br><br><pre> <code class="matlab hljs">TransFunction.PSD = iSignal.PSD .* Filter.PSD_Tx; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  Le signal de sortie de la ligne iSignal.Rx est √©gal au produit du spectre du signal d'entr√©e et des fonctions de transfert du filtre et de la ligne de signal avec le transfert ult√©rieur du signal re√ßu du domaine fr√©quentiel vers le domaine temporel. <br><br><pre> <code class="matlab hljs">TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  La r√©ponse du filtre √† l'impulsion id√©ale d'entr√©e et la r√©ponse du canal sont illustr√©es √† la figure 10. <br><br><img src="https://habrastorage.org/webt/ta/fh/0b/tafh0btf_ayq9wcxrowembxxbdk.png" alt="image"><br>  <i>Figure 10. Sortie du filtre (graphique rouge) et sortie de la ligne de donn√©es (graphique vert).</i>  <i>Signal d'entr√©e du filtre - une seule impulsion est repr√©sent√©e sur la figure 2. L'entr√©e de ligne de signal est le signal de sortie du filtre.</i> <br><br><h3>  Application.  Code m MATLAB d'occasion </h3><br><div class="spoiler">  <b class="spoiler_title">Annonce</b> <div class="spoiler_text"><pre> <code class="matlab hljs">clear all <span class="hljs-comment"><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Ini data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% bps = 1.03125e+10; FilterParam = [0.75 0.75]; points = 2^13; load('channel'); N = floor(max(channel.f)*2/bps); fmax = N*bps; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Signal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % normalise all the scales for the bit rate time = bps/fmax .* (1:points); iSignal.Tx(1:size(time,2)) = 0; t0 = max(find(time&lt;=10)); t1 = max(find(time&lt;11)); iSignal.Tx(t0:t1) = 1.0; figure plot(time(1:t1+10), iSignal.Tx(1:t1+10),'b'); hold on plot(time(1:t1+10), iSignal.Tx(1:t1+10),'xb'); grid on xlabel('Normalised Time, tick Ts = 1/fmax'); ylabel('Normalised Amplitude'); title(['Pulse, data bit']); iSignal.shiftedPSD = fft(iSignal.Tx); figure plot(abs(iSignal.shiftedPSD),'c'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fft(iSignal.Tx))']); iSignal.PSD = fftshift(iSignal.shiftedPSD); figure plot(abs(iSignal.PSD),'r'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fftshift(fft(iSignal.Tx)))']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Filter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f_nrm =fmax/bps/points.*(-points/2:points/2-1); s = f_nrm .* j; Filter_PSD = 1 ./(1 + s/FilterParam(1)) ./ (1 + s/FilterParam(2)); figure [AX,H1,H2] = plotyy (f_nrm, abs(Filter_PSD), f_nrm, phase(Filter_PSD)); hold(AX(1)); hold(AX(2)); set(H1,'LineWidth',2); grid(AX(2),'on'); xlabel('Normalised Frequency (Hz)'); set(get(AX(1),'Ylabel'),'String','Gain'); set(get(AX(2),'Ylabel'),'String','Phase, rad'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); figure plot_handles_Filter = plot(f_nrm(points/2 + 1:points), 20*log10(abs(Filter_PSD(points/2 + 1:points))), 'r', 'linewidth', 2); hold on stem_handles_br = stem(1, 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; 1))))), '-.ro'); hold on stem_handles_c = stem(FilterParam, [20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(1)))))) 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(2))))))], '-.bo'); grid legend_handles = [plot_handles_Filter, stem_handles_br(1), stem_handles_c(1)]; legend(legend_handles, 'transfer function', 'filter attenuation at normalised baud rate', 'filter attenuation at normalised cutoff frequency', 3); xlabel('Normalised Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Channel %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % create negative frequencies, convert data to complex value, taking care about negative frequency channel.abs = abs(channel.s); channel.phase = angle(channel.s); %channel.s = channel.abs .* exp(+j.*channel.phase); [a] = polyfit(channel.f(1:10), channel.abs(1:10), 1); channel.dc = a(2); channel.dcPhase = 0.00; fs = fmax/points; % frequency step f = -fmax/2:fs:fmax/2-fs; % frequency matrix % create new data structure with linearly interpolated data ichannel.abs = interp1([0 channel.f], [channel.dc channel.abs], abs(f), 'linear', 'extrap'); ichannel.phase = interp1([0 channel.f], [channel.dcPhase unwrap(channel.phase)], abs(f), 'linear', 'extrap'); % correct for negative frequencies ichannel.s = ichannel.abs .* exp(+j.*ichannel.phase); ichannel.tf = real(ichannel.s) + j*imag(ichannel.s) .* sign(f); figure disp_points = 2*round(channel.f(1)/fs); stem_handles_br = stem(channel.f(1), angle(ichannel.tf(max(find(f &lt; channel.f(1))))), '-.mo'); hold on plot_abs = plot(f(points/2-disp_points:points/2+disp_points), 20*log10(abs(ichannel.tf(points/2-disp_points:points/2+disp_points))), '.r', 'linewidth', 3); hold on plot_phase = plot(f(points/2-disp_points:points/2+disp_points), angle(ichannel.tf(points/2-disp_points:points/2+disp_points)), '.b', 'linewidth', 3); grid legend_handles = [plot_abs, plot_phase, stem_handles_br(1)]; legend(legend_handles, 'absolute value (dB)', 'phase (rad)', 'min data freq', 3); xlabel('Relative Frequency (Hz)'); ylabel('Magnitude'); title(sprintf('dc extrapolation. dc trans function=%4.3f, dc phase=%4.3f rad', abs(ichannel.tf(points/2+1)), angle(ichannel.tf(points/2+1)))); figure plot(channel.f, 20*log10(channel.abs), '.r', 'linewidth', 3); hold on plot(f, 20*log10(ichannel.abs), 'g'); grid on legend('Measured Data', 'Interpolated Data', 3); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Chnnel interpolated Data : ']); figure plot3(channel.f, real(channel.s), imag(channel.s),'r'); hold on plot3(f, real(ichannel.tf), imag(ichannel.tf),'g'); grid on legend('Measured Data', 'Interpolated Data'); xlabel('Frequency in Hz'); ylabel('Re(fwd transfer)'); zlabel('Im(fwd transfer)'); title(['Chnnel interpolated Data : ']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Response %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % filter Output TransFunction.PSD = iSignal.PSD .* Filter_PSD; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = real(ifft(TransFunction.shiftedPSD)); % pass through channel TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = real(ifft(TransFunction.shiftedPSD)); figure plot(time, iSignal.Filter_out,'r'); hold on [max_Tx, time_maxTx] = max(iSignal.Filter_out); [min_Tx, time_minTx] = min(iSignal.Filter_out); [max_Rx, time_maxRx] = max(iSignal.Rx); dtime_p5= round((time_maxRx - time_maxTx)*time(1) -1); plot(time - dtime_p5, iSignal.Rx,'g'); hold on plot(time, iSignal.Filter_out,'rx'); axis([(time_maxTx*time(1) - 3) (time_maxTx*time(1) + 5) (min_Tx-0.15) (max_Tx+0.1)]) grid on legend('Filter out','Rx', 2); xlabel('Normalised Time'); ylabel('Normalised Amplitude'); title(sprintf('Transmit pulse (Tx) max= %4.3f; Response (Rx) max (h0)= %4.3f', max(iSignal.Filter_out), max(iSignal.Rx)));</span></span></code> </pre><br></div></div><br><h3>  Liste bibliographique </h3><br>  1. IEEE802.3ap.  10.3125Gbps NRZ Simulation Results Using "StatEye" and "Signal to Interference Model" on Cascaded Channel Components.  Shannon Sawyer et Charles Moore / Agilent Technologies.  24 janvier 2005 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.ieee802.org/3/ap/public/jan05/sawyer_01_0105.pdf</a> <br><br>  2. Qu'est-ce que StatEye.  Groupe de travail IEEE 803.3ap.  16 septembre 2004 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.ieee802.org/3/ap/public/signal_adhoc/ghiasi_01_0904.pdf</a> <br><br>  3. Accord Stat Eye / IBM.  Steve Anderson.  Xilinx, Inc.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.ieee802.org/3/ap/public/nov04/anderson_01_1104.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416497/">https://habr.com/ru/post/fr416497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416487/index.html">Radio Astron f√™te ses 7 ans</a></li>
<li><a href="../fr416489/index.html">La vie extraterrestre: sur la correction de l'√©quation de Drake et du grand filtre</a></li>
<li><a href="../fr416491/index.html">Activiti - Moteur de processus m√©tier</a></li>
<li><a href="../fr416493/index.html">Lancer SIIG MiniSys S286</a></li>
<li><a href="../fr416495/index.html">SamsPcbGuide Partie 6: Tra√ßage des lignes de signal. Mod√®les de perte et de diaphonie</a></li>
<li><a href="../fr416501/index.html">√âcrivez-moi un serveur GraphQL en C #</a></li>
<li><a href="../fr416505/index.html">Nous √©crivons une machine virtuelle de pile sur Rust'e</a></li>
<li><a href="../fr416507/index.html">Comment v√©rifier la fiabilit√© du centre de donn√©es: 3 points principaux auxquels vous devez faire attention</a></li>
<li><a href="../fr416511/index.html">Les erreurs les plus courantes dans votre code React que vous faites (√©ventuellement)</a></li>
<li><a href="../fr416513/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 260 (2 juillet - 8 juillet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>