<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦏 🤞🏼 🔚 Python dan klien HTTP cepat 👨🏾‍🔬 ☎️ 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, jika Anda menulis semacam aplikasi Python, maka kemungkinan besar Anda harus melengkapinya dengan fungsi klien HTTP yang dapat berkomunikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python dan klien HTTP cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  Saat ini, jika Anda menulis semacam aplikasi Python, maka kemungkinan besar Anda harus melengkapinya dengan fungsi klien HTTP yang dapat berkomunikasi dengan server HTTP.  Di mana-mana API REST telah menjadikan alat HTTP fitur yang disegani dalam proyek perangkat lunak yang tak terhitung jumlahnya.  Itu sebabnya setiap programmer perlu memiliki pola yang bertujuan mengatur kerja optimal dengan koneksi HTTP. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Ada banyak klien HTTP untuk Python.  Yang paling umum di antara mereka, dan, selain itu, yang mudah dikerjakan, bisa disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> .  Saat ini, pelanggan ini adalah standar de facto. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Koneksi Permanen</font> </h2><br>  Optimalisasi pertama yang dipertimbangkan ketika bekerja dengan HTTP adalah menggunakan koneksi persisten ke server web.  Koneksi persisten telah menjadi standar sejak HTTP 1.1, tetapi banyak aplikasi masih tidak menggunakannya.  Kelemahan ini mudah dijelaskan, karena mengetahui bahwa ketika menggunakan pustaka <code>requests</code> dalam mode sederhana (misalnya, menggunakan metode <code>get</code> ), koneksi ke server ditutup setelah menerima respons dari itu.  Untuk menghindari hal ini, aplikasi perlu menggunakan objek <code>Session</code> , yang memungkinkan penggunaan kembali koneksi terbuka: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Koneksi disimpan di kumpulan koneksi (standarnya adalah 10 koneksi secara default).  Ukuran kolam dapat disesuaikan: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  Menggunakan kembali koneksi TCP untuk mengirim beberapa permintaan HTTP memberi aplikasi banyak manfaat kinerja: <br><br><ul><li>  Mengurangi beban pada prosesor dan mengurangi kebutuhan untuk RAM (karena fakta bahwa koneksi lebih sedikit terbuka pada saat yang sama). </li><li>  Mengurangi keterlambatan saat menjalankan permintaan yang datang satu demi satu (tidak ada prosedur jabat tangan TCP). </li><li>  Pengecualian dapat dibuang tanpa waktu tambahan untuk menutup koneksi TCP. </li></ul><br>  HTTP 1.1 juga mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pipelining</a> permintaan.  Ini memungkinkan Anda untuk mengirim beberapa permintaan dalam koneksi yang sama tanpa menunggu respons terhadap permintaan yang sebelumnya dikirim (yaitu, mengirim permintaan dalam "paket").  Sayangnya, pustaka <code>requests</code> tidak mendukung fitur ini.  Namun, permintaan pemipaan mungkin tidak secepat memprosesnya secara paralel.  Dan, selain itu, patut untuk memperhatikan hal ini: balasan untuk permintaan "paket" harus dikirim oleh server dalam urutan yang sama dengan saat ia menerima permintaan ini.  Hasilnya bukan skema pemrosesan permintaan yang paling efisien berdasarkan pada prinsip FIFO ("masuk pertama, keluar pertama" - "pertama datang, pertama pergi"). <br><br><h2>  <font color="#3AC1EF">Pemrosesan query paralel</font> </h2><br>  <code>requests</code> juga memiliki kelemahan serius lainnya.  Ini adalah perpustakaan yang sinkron.  Metode panggilan seperti <code>requests.get("http://example.org")</code> memblokir program hingga respons server HTTP penuh diterima.  Fakta bahwa aplikasi harus menunggu dan tidak melakukan apa pun dapat dianggap sebagai minus dari skema interaksi dengan server.  Apakah mungkin membuat program melakukan sesuatu yang bermanfaat, bukan hanya menunggu? <br><br>  Aplikasi yang dirancang dengan cerdas dapat mengurangi masalah ini dengan menggunakan kumpulan thread, mirip dengan yang disediakan oleh <code>concurrent.futures</code> .  Ini memungkinkan Anda untuk memparalelkan permintaan HTTP dengan cepat: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Pola yang sangat berguna ini diterapkan di pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan-berjangka</a> .  Pada saat yang sama, penggunaan objek <code>Session</code> transparan bagi pengembang: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Secara default, pekerja dengan dua utas dibuat, tetapi program dapat dengan mudah mengatur nilai ini dengan meneruskan argumen <code>FuturSession</code> atau bahkan pelaksana sendiri ke objek <code>FuturSession</code> .  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Bekerja tidak sinkron dengan permintaan</font> </h2><br>  Seperti yang telah disebutkan, pustaka <code>requests</code> sepenuhnya sinkron.  Ini mengarah ke pemblokiran aplikasi sambil menunggu respons dari server, yang mempengaruhi kinerja dengan buruk.  Salah satu solusi untuk masalah ini adalah dengan menjalankan permintaan HTTP di utas terpisah.  Tetapi penggunaan utas merupakan beban tambahan pada sistem.  Selain itu, ini berarti pengenalan skema pemrosesan data paralel ke dalam program, yang tidak cocok untuk semua orang. <br><br>  Dimulai dengan Python 3.5, fitur bahasa standar termasuk pemrograman asinkron menggunakan <code>asyncio</code> .  Pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://aio">aiohttp</a> menyediakan pengembang dengan klien HTTP asinkron berdasarkan <code>asyncio</code> .  Pustaka ini memungkinkan aplikasi untuk mengirim serangkaian permintaan dan terus bekerja.  Pada saat yang sama, untuk mengirim permintaan lain, Anda tidak perlu menunggu respons terhadap permintaan yang dikirim sebelumnya.  Tidak seperti pipelining permintaan HTTP, <code>aiohttp</code> mengirimkan permintaan secara paralel menggunakan beberapa koneksi.  Ini menghindari "masalah FIFO" yang dijelaskan di atas.  Inilah yang menggunakan <code>aiohttp</code> seperti: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Semua pendekatan yang dijelaskan di atas (menggunakan <code>Session</code> , aliran, <code>concurrent.futures</code> atau <code>asyncio</code> ) menawarkan berbagai cara untuk mempercepat klien HTTP. <br><br><h2>  <font color="#3AC1EF">Performa</font> </h2><br>  Kode berikut adalah contoh di mana klien HTTP mengirim permintaan ke server <code>httpbin.org</code> .  Server mendukung API yang dapat, antara lain, mensimulasikan sistem yang membutuhkan waktu lama untuk menanggapi permintaan (dalam hal ini, 1 detik).  Di sini, semua teknik yang dibahas di atas diterapkan dan kinerjanya diukur: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Berikut adalah hasil yang diperoleh setelah memulai program ini: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Berikut adalah bagan hasil. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Hasil studi tentang kinerja berbagai metode untuk membuat permintaan HTTP</font></i> <br><br>  Tidak mengherankan bahwa skema eksekusi query tersinkronisasi yang paling sederhana ternyata paling lambat.  Intinya di sini adalah bahwa di sini kueri dieksekusi satu per satu, tanpa menggunakan kembali koneksi.  Akibatnya, dibutuhkan 12 detik untuk menyelesaikan 10 kueri. <br><br>  Menggunakan objek <code>Session</code> , dan, sebagai akibatnya, menggunakan kembali koneksi, menghemat 8% dari waktu.  Ini sudah sangat bagus, dan untuk mencapai ini sangat sederhana.  Siapa pun yang peduli dengan kinerja harus menggunakan setidaknya objek <code>Session</code> . <br><br>  Jika sistem dan program Anda memungkinkan Anda untuk bekerja dengan utas, maka ini adalah alasan yang bagus untuk berpikir tentang menggunakan utas untuk memparalelkan permintaan.  Streaming, bagaimanapun, membuat beberapa beban tambahan pada sistem, mereka, dengan demikian, tidak "bebas".  Mereka harus dibuat, dijalankan, Anda harus menunggu penyelesaian pekerjaan mereka. <br><br>  Jika Anda ingin menggunakan klien HTTP asinkron cepat, maka kecuali Anda menulis pada versi Python yang lebih lama, Anda harus memberi perhatian paling serius pada <code>aiohttp</code> .  Ini adalah solusi tercepat, terukur terbaik.  Itu mampu menangani ratusan permintaan bersamaan. <br><br>  Alternatif untuk <code>aiohttp</code> , bukan alternatif yang sangat baik adalah mengelola ratusan utas secara paralel. <br><br><h2>  <font color="#3AC1EF">Pemrosesan Data Stream</font> </h2><br>  Optimalisasi lain untuk bekerja dengan sumber daya jaringan, yang mungkin berguna dalam hal meningkatkan kinerja aplikasi, adalah menggunakan data streaming.  Skema pemrosesan permintaan standar terlihat seperti ini: aplikasi mengirim permintaan, setelah itu badan permintaan ini dimuat dalam sekali jalan.  Parameter <code>stream</code> , yang mendukung pustaka <code>requests</code> , serta atribut <code>content</code> pustaka <code>aiohttp</code> , memungkinkan Anda untuk menjauh dari skema ini. <br><br>  Berikut tampilan organisasi pemrosesan data streaming menggunakan <code>requests</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  Berikut cara streaming data menggunakan <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  Menghilangkan kebutuhan akan pemuatan instan dari konten respons penuh adalah penting dalam kasus di mana Anda perlu mencegah kemungkinan kemungkinan alokasi ratusan megabyte memori yang tidak berguna.  Jika program tidak membutuhkan akses ke jawaban secara keseluruhan, jika ia dapat bekerja dengan masing-masing fragmen jawaban, maka mungkin lebih baik menggunakan metode streaming pekerjaan dengan permintaan.  Misalnya, jika Anda akan menyimpan data dari respons server terhadap file, maka membaca dan menulisnya dalam bagian-bagian akan jauh lebih efisien dalam hal penggunaan memori daripada membaca seluruh badan respons, mengalokasikan sejumlah besar memori dan kemudian menulis semuanya ke disk. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Saya harap pembicaraan saya tentang berbagai cara untuk mengoptimalkan operasi klien HTTP akan membantu Anda memilih yang paling sesuai dengan aplikasi Python Anda. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda masih tahu cara lain untuk mengoptimalkan pekerjaan dengan permintaan HTTP di aplikasi Python, silakan bagikan. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472858/">https://habr.com/ru/post/id472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472848/index.html">Refleksi tentang karier di bidang TI</a></li>
<li><a href="../id472850/index.html">Profesi atau Kehidupan: Menangkan Kursus Netologi Jika Anda Tidak Takut</a></li>
<li><a href="../id472852/index.html">GitLab membuat perubahan untuk pengguna produk cloud dan komersial</a></li>
<li><a href="../id472854/index.html">Profiling Unity UI: Siapa yang merusak Batching Saya?</a></li>
<li><a href="../id472856/index.html">Bagaimana saya membuat layanan kontrol kualitas dari tabel dan stik</a></li>
<li><a href="../id472860/index.html">Cascading cache invalidation. Bagian 1</a></li>
<li><a href="../id472862/index.html">Cascading cache invalidation. Bagian 2</a></li>
<li><a href="../id472866/index.html">Jimat untuk komunikasi yang stabil</a></li>
<li><a href="../id472868/index.html">Manajemen server telepon: Klien seluler RUVDS</a></li>
<li><a href="../id472870/index.html">Mengapa Agile terhenti tanpa mengubah arsitektur dan alat pengembangan - presentasi konferensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>