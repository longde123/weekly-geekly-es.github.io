<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèæ ‚ñ´Ô∏è üöÅ Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Parte 3 üö© ü§¥üèΩ ü¶Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy veremos dos lugares m√°s donde pbrt pasa mucho tiempo analizando escenas de la caricatura de Disney "Moana" . Veamos si ser√° posible mejorar la pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417913/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg" alt="imagen"></div><br>  Hoy veremos dos lugares m√°s donde pbrt pasa mucho tiempo analizando escenas de la caricatura de Disney <em>"Moana"</em> .  Veamos si ser√° posible mejorar la productividad aqu√≠.  Esto concluye con lo que es prudente hacer en pbrt-v3.  En otra publicaci√≥n, me ocupar√© de hasta d√≥nde podemos llegar si abandonamos la prohibici√≥n de los cambios.  En este caso, el c√≥digo fuente ser√° demasiado diferente del sistema descrito en el libro <em>Representaci√≥n basada</em> en la <em>f√≠sica</em> . <br><br><h2>  Optimizaci√≥n del analizador </h2><br>  Despu√©s de las mejoras de rendimiento introducidas en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , la proporci√≥n de tiempo dedicado al analizador pbrt, y tan importante desde el principio, naturalmente aument√≥ a√∫n m√°s.  Actualmente, el analizador al inicio se pasa la mayor parte del tiempo. <br><br>  Finalmente reun√≠ mi fuerza e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implement√© un tokenizador y analizador escrito manualmente</a> para escenas pbrt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El formato de los archivos de escena pbrt es</a> bastante simple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizar</a> : si no tiene en cuenta las l√≠neas citadas, los tokens est√°n separados por espacios, y la gram√°tica es muy sencilla (nunca es necesario mirar hacia adelante m√°s de un token), pero su propio analizador todav√≠a tiene mil l√≠neas de c√≥digo que necesita escribir y depurar  Me ayud√≥ a poder probarlo en muchas escenas;  Despu√©s de solucionar problemas t√©cnicos obvios, continu√© trabajando hasta que logr√© procesar exactamente las mismas im√°genes que antes: no deber√≠a haber ninguna diferencia en los p√≠xeles debido a la sustituci√≥n del analizador.  En esta etapa, estaba absolutamente seguro de que todo se hizo correctamente. <br><a name="habracut"></a><br>  Trat√© de hacer que la nueva versi√≥n sea lo m√°s eficiente posible, sometiendo los archivos de entrada a <code>mmap()</code> tanto como sea posible y usando la nueva implementaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>std::string_view</code></a> de C ++ 17 para minimizar la creaci√≥n de copias de cadenas a partir del contenido del archivo.  Adem√°s, dado que <code>strtod()</code> tom√≥ mucho tiempo en las trazas anteriores, escrib√≠ <a href=""><code> parseNumber()</code></a> con especial cuidado: los enteros de un solo d√≠gito y los enteros regulares se procesan por separado, y en el caso est√°ndar cuando se compila pbrt para usar flotantes de 32 bits , us√≥ <code>strtof()</code> lugar de <code>strtod()</code> <sup>1</sup> . <br><br>  En el proceso de crear una implementaci√≥n del nuevo analizador, ten√≠a un poco de miedo de que el analizador anterior fuera m√°s r√°pido: al final, flex y bison se han desarrollado y optimizado durante muchos a√±os.  No pude averiguar de antemano si se desperdiciar√≠a todo el tiempo escribiendo una nueva versi√≥n hasta que la completara y la hiciera funcionar correctamente. <br><br>  Para mi alegr√≠a, nuestro propio analizador result√≥ ser una gran victoria: la generalizaci√≥n de flex y bison redujo tanto el rendimiento que la nueva versi√≥n los super√≥ f√°cilmente.  Gracias al nuevo analizador, el tiempo de lanzamiento disminuy√≥ a 13 min 21 s, es decir, ¬°se aceler√≥ otras 1,5 veces!  Una ventaja adicional era que ahora era posible eliminar todo el soporte de flex y bison del sistema de compilaci√≥n pbrt.  Siempre ha sido un dolor de cabeza, especialmente en Windows, donde la mayor√≠a de las personas no lo tienen instalado de forma predeterminada. <br><br><h2>  Gesti√≥n de estado de gr√°ficos </h2><br>  Despu√©s de acelerar significativamente el analizador, surgi√≥ un nuevo detalle molesto: en esta etapa, aproximadamente el 10% del tiempo de configuraci√≥n se gast√≥ en las funciones <code>pbrtAttributeBegin()</code> y <code>pbrtAttributeEnd()</code> , y la mayor parte de este tiempo se asign√≥ y liber√≥ memoria din√°mica.  Durante la primera ejecuci√≥n, que tom√≥ 35 minutos, estas funciones tomaron solo alrededor del 3% del tiempo de ejecuci√≥n, por lo que podr√≠an ignorarse.  Pero con la optimizaci√≥n siempre es as√≠: cuando comienzas a deshacerte de los grandes problemas, los peque√±os se vuelven m√°s importantes. <br><br>  La descripci√≥n de la escena pbrt se basa en el estado jer√°rquico del gr√°fico, que indica la transformaci√≥n actual, el material actual, etc.  En √©l, puede tomar instant√°neas del estado actual ( <code>pbrtAttributeBegin()</code> ), realizar cambios antes de agregar una nueva geometr√≠a a la escena y luego volver al estado original ( <code>pbrtAttributeEnd()</code> ). <br><br>  El estado de los gr√°ficos se almacena en una estructura con un nombre inesperado ... <code>GraphicsState</code> .  Para almacenar copias de objetos <code>GraphicsState</code> en la pila de estados gr√°ficos guardados, <code>std::vector</code> .  Mirando a los miembros de <code>GraphicsState</code> , podemos asumir la fuente de los problemas: tres <code>std::map</code> , desde nombres hasta instancias de texturas y materiales: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Float&gt;&gt;&gt; floatTextures; std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt;&gt; spectrumTextures; std::map&lt;std::string, std::shared_ptr&lt;MaterialInstance&gt;&gt; namedMaterials; };</span></span></code> </pre> <br>  Al examinar estos archivos de escena, descubr√≠ que la mayor√≠a de los casos de guardar y restaurar el estado de los gr√°ficos se realizan en estas l√≠neas: <br><br><pre> <code class="cpp hljs">AttributeBegin ConcatTransform [<span class="hljs-number"><span class="hljs-number">0.981262</span></span> <span class="hljs-number"><span class="hljs-number">0.133695</span></span> <span class="hljs-number"><span class="hljs-number">-0.138749</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">-0.067901</span></span> <span class="hljs-number"><span class="hljs-number">0.913846</span></span> <span class="hljs-number"><span class="hljs-number">0.400343</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">0.180319</span></span> <span class="hljs-number"><span class="hljs-number">-0.383420</span></span> <span class="hljs-number"><span class="hljs-number">0.905800</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">11.095301</span></span> <span class="hljs-number"><span class="hljs-number">18.852249</span></span> <span class="hljs-number"><span class="hljs-number">9.481399</span></span> <span class="hljs-number"><span class="hljs-number">1.000000</span></span>] ObjectInstance <span class="hljs-string"><span class="hljs-string">"archivebaycedar0001_mod"</span></span> AttributeEnd</code> </pre> <br>  En otras palabras, actualiza la transformaci√≥n actual e instancia el objeto;  no se realizan cambios en el contenido de estos <code>std::map</code> .  Crear una copia completa de ellos, asignar nodos de √°rbol rojo-negro, aumentar los recuentos de referencias para punteros comunes, asignar espacio y copiar cadenas, es casi siempre una p√©rdida de tiempo.  Todo esto se libera al restaurar el estado anterior de los gr√°ficos. <br><br>  <code>std::shared_ptr</code> cada uno de estos mapas con el puntero <code>std::shared_ptr</code> para mapear e implement√© el enfoque de copia en escritura, en el que la copia dentro del bloque de inicio / fin de un atributo ocurre solo cuando es necesario cambiar su contenido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El cambio</a> no fue particularmente dif√≠cil, pero redujo el tiempo de lanzamiento en m√°s de un minuto, lo que nos dio 12 min 20 s de procesamiento antes del inicio del renderizado, nuevamente una aceleraci√≥n de 1.08 veces. <br><br><h2>  ¬øQu√© pasa con el tiempo de renderizado? </h2><br>  Un lector atento notar√° que hasta ahora no he dicho nada sobre el tiempo de representaci√≥n.  Para mi sorpresa, result√≥ ser bastante tolerable incluso fuera de la caja: pbrt puede renderizar im√°genes de escenas de calidad cinematogr√°fica con varios cientos de muestras por p√≠xel en doce n√∫cleos de procesador durante un per√≠odo de dos a tres horas.  Por ejemplo, esta imagen, una de las m√°s lentas, renderizada en 2 horas 51 minutos 36 segundos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg"></div><br>  <i>Dunas de Moana renderizadas por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pbrt-v3</a> con una resoluci√≥n de 2048x858 a 256 muestras por p√≠xel.</i>  <i>El tiempo total de representaci√≥n en una instancia de Google Compute Engine con 12 n√∫cleos / 24 subprocesos con una frecuencia de 2 GHz y la √∫ltima versi√≥n de pbrt-v3 fue de 2 horas 51 minutos 36 segundos.</i> <br><br>  En mi opini√≥n, esto parece un indicador sorprendentemente razonable.  Estoy seguro de que las mejoras a√∫n son posibles, y un estudio cuidadoso de los lugares en los que se pasa la mayor parte del tiempo revelar√° muchas cosas "interesantes", pero hasta ahora no hay razones especiales para ello. <br><br>  Al perfilar, result√≥ que aproximadamente el 60% del tiempo de renderizado se gast√≥ en la intersecci√≥n de los rayos con los objetos (la mayor√≠a de las operaciones se realizaron sin pasar por BVH), y el 25% se gast√≥ buscando texturas ptex.  Estas proporciones son similares a los indicadores de escenas m√°s simples, por lo que a primera vista no hay nada obviamente problem√°tico aqu√≠.  (Sin embargo, estoy seguro de que Embree podr√° rastrear estos rayos en un poco menos de tiempo). <br><br>  Desafortunadamente, la escalabilidad paralela no es tan buena.  Por lo general, veo que el 1400% de los recursos de la CPU se gastan en renderizado, en comparaci√≥n con el ideal del 2400% (en 24 CPU virtuales en Google Compute Engine).  Parece que el problema est√° relacionado con conflictos durante bloqueos en ptex, pero a√∫n no lo he investigado con m√°s detalle.  Es muy probable que pbrt-v3 no calcule la diferencia de rayos para los rayos indirectos en el rastreador de rayos;  a su vez, tales haces siempre obtienen acceso al nivel de texturas MIP m√°s detallado, lo que no es muy √∫til para el almacenamiento en cach√© de texturas. <br><br><h2>  Conclusi√≥n (para pbrt-v3) </h2><br>  Habiendo corregido la gesti√≥n del estado de los gr√°ficos, me encontr√© con un l√≠mite, despu√©s del cual no se hicieron evidentes progresos adicionales sin realizar cambios significativos en el sistema;  todo el resto tom√≥ mucho tiempo y tuvo poco que ver con la optimizaci√≥n.  Por lo tanto, me detendr√© en esto, al menos con respecto a pbrt-v3. <br><br>  En general, el progreso fue serio: el tiempo de lanzamiento antes del renderizado disminuy√≥ de 35 minutos a 12 minutos y 20 segundos, es decir, la aceleraci√≥n total fue de 2,83 veces.  Adem√°s, gracias al trabajo inteligente con el cach√© de conversi√≥n, el uso de memoria ha disminuido de 80 GB a 69 GB.  Todos estos cambios est√°n disponibles ahora si est√° sincronizando con la √∫ltima versi√≥n de pbrt-v3 (o si lo ha hecho en los √∫ltimos meses). Y entendemos cu√°n basura es la memoria <code>Primitive</code> para esta escena;  descubrimos c√≥mo guardar otros 18 GB de memoria, pero no lo implementamos en pbrt-v3. <br><br>  Esto es en lo que se gastan estos 12 min 20 s despu√©s de todas nuestras optimizaciones: <br><br><table><thead><tr><th>  Funci√≥n / Operaci√≥n </th><th>  Porcentaje de tiempo de ejecuci√≥n </th></tr></thead><tbody><tr><td>  Build BVH </td><td>  34% </td></tr><tr><td>  An√°lisis (excepto <code>strtof()</code> ) </td><td>  21% </td></tr><tr><td> <code>strtof()</code> </td> <td>  20% </td></tr><tr><td>  Cach√© de conversi√≥n </td><td>  7% </td></tr><tr><td>  Leer archivos PLY </td><td>  6% </td></tr><tr><td>  Asignaci√≥n de memoria din√°mica </td><td>  5% </td></tr><tr><td>  Inversi√≥n de conversi√≥n </td><td>  2% </td></tr><tr><td>  Gesti√≥n de estado de gr√°ficos </td><td>  2% </td></tr><tr><td>  Otros </td><td>  3% </td></tr></tbody></table><br>  En el futuro, la mejor opci√≥n para mejorar el rendimiento ser√° una multiproceso a√∫n mayor de la etapa de lanzamiento: casi todo durante el an√°lisis de la escena es de un solo subproceso;  Nuestro primer objetivo m√°s natural es construir un BVH.  Tambi√©n ser√° interesante analizar cosas como leer archivos PLY y generar BVH para instancias individuales de objetos y ejecutarlos de forma as√≠ncrona en segundo plano, mientras que el an√°lisis se realizar√° en el hilo principal. <br><br>  En alg√∫n momento, ver√© si hay implementaciones m√°s r√°pidas de <code>strtof()</code> ;  pbrt usa solo lo que proporciona el sistema.  Sin embargo, debe tener cuidado con la elecci√≥n de los reemplazos que no se prueban muy a fondo: analizar los valores flotantes es uno de esos aspectos de los que el programador debe estar completamente seguro. <br><br>  Tambi√©n parece atractivo reducir a√∫n m√°s la carga en el analizador: todav√≠a tenemos 17 GB de archivos de entrada de texto para analizar.  Podemos agregar soporte de codificaci√≥n binaria para archivos de entrada pbrt (posiblemente similar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enfoque RenderMan</a> ), pero tengo sentimientos encontrados acerca de esta idea;  La capacidad de abrir y modificar archivos de descripci√≥n de escena en un editor de texto es bastante √∫til, y me preocupa que a veces la codificaci√≥n binaria confunda a los estudiantes que usan pbrt en el proceso de aprendizaje.  Este es uno de esos casos en los que la soluci√≥n correcta para pbrt puede diferir de las soluciones para una representaci√≥n comercial de un nivel de producci√≥n. <br><br>  Fue muy interesante hacer un seguimiento de todas estas optimizaciones y comprender mejor varias soluciones.  Result√≥ que pbrt tiene suposiciones inesperadas que interfieren con la escena de este nivel de complejidad.  Todo esto es un gran ejemplo de lo importante que es para una amplia comunidad de investigadores de acceso tener acceso a escenas de producci√≥n reales con un alto grado de complejidad;  Nuevamente le agradezco a Disney por el tiempo dedicado a procesar esta escena y ponerla en el dominio p√∫blico. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pr√≥ximo art√≠culo</a> , analizaremos aspectos que pueden mejorar a√∫n m√°s el rendimiento si permitimos que pbrt realice cambios m√°s radicales. <br><br><h2>  Nota </h2><br><ol><li>  En el sistema Linux en el que estaba probando, <code>strtof()</code> no <code>strtof()</code> m√°s r√°pido que <code>strtod()</code> .  Es de destacar que en OS X <code>strtod()</code> aproximadamente dos veces m√°s r√°pido, lo cual es completamente il√≥gico.  Por razones pr√°cticas, segu√≠ usando <code>strtof()</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417913/">https://habr.com/ru/post/es417913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417901/index.html">C√≥mo comenzamos a hacer largas reuniones incre√≠bles y por qu√© esto ya no es un mal universal</a></li>
<li><a href="../es417903/index.html">Revisi√≥n de c√≥digo caso 1</a></li>
<li><a href="../es417905/index.html">11 maneras (no) de ser v√≠ctima de pirater√≠a en Kubernetes</a></li>
<li><a href="../es417909/index.html">¬øPor qu√© necesitas Splunk? Anal√≠tica de aplicaciones</a></li>
<li><a href="../es417911/index.html">Dise√±o continuo en desarrollo: metodolog√≠a y principio</a></li>
<li><a href="../es417915/index.html">C√≥mo jugar un compa√±ero de cuarto</a></li>
<li><a href="../es417917/index.html">ASC'18: Persistencia y entrenamiento regular como una forma de alcanzar la meta.</a></li>
<li><a href="../es417919/index.html">Modelado de vibraci√≥n y ruido en la caja de cambios de un autom√≥vil</a></li>
<li><a href="../es417927/index.html">Cyber ‚Äã‚ÄãBattle en PHDays o C√≥mo piratear infraestructura urbana en 30 horas</a></li>
<li><a href="../es417929/index.html">Extracto del libro "Un d√≠a en la vida del cerebro. Neurobiolog√≠a de la conciencia desde el amanecer hasta el anochecer "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>