<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏾 ▫️ 🚁 Optimización de la representación de una escena de la caricatura de Disney "Moana". Parte 3 🚩 🤴🏽 🦂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy veremos dos lugares más donde pbrt pasa mucho tiempo analizando escenas de la caricatura de Disney "Moana" . Veamos si será posible mejorar la pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimización de la representación de una escena de la caricatura de Disney "Moana". Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417913/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg" alt="imagen"></div><br>  Hoy veremos dos lugares más donde pbrt pasa mucho tiempo analizando escenas de la caricatura de Disney <em>"Moana"</em> .  Veamos si será posible mejorar la productividad aquí.  Esto concluye con lo que es prudente hacer en pbrt-v3.  En otra publicación, me ocuparé de hasta dónde podemos llegar si abandonamos la prohibición de los cambios.  En este caso, el código fuente será demasiado diferente del sistema descrito en el libro <em>Representación basada</em> en la <em>física</em> . <br><br><h2>  Optimización del analizador </h2><br>  Después de las mejoras de rendimiento introducidas en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior</a> , la proporción de tiempo dedicado al analizador pbrt, y tan importante desde el principio, naturalmente aumentó aún más.  Actualmente, el analizador al inicio se pasa la mayor parte del tiempo. <br><br>  Finalmente reuní mi fuerza e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementé un tokenizador y analizador escrito manualmente</a> para escenas pbrt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El formato de los archivos de escena pbrt es</a> bastante simple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizar</a> : si no tiene en cuenta las líneas citadas, los tokens están separados por espacios, y la gramática es muy sencilla (nunca es necesario mirar hacia adelante más de un token), pero su propio analizador todavía tiene mil líneas de código que necesita escribir y depurar  Me ayudó a poder probarlo en muchas escenas;  Después de solucionar problemas técnicos obvios, continué trabajando hasta que logré procesar exactamente las mismas imágenes que antes: no debería haber ninguna diferencia en los píxeles debido a la sustitución del analizador.  En esta etapa, estaba absolutamente seguro de que todo se hizo correctamente. <br><a name="habracut"></a><br>  Traté de hacer que la nueva versión sea lo más eficiente posible, sometiendo los archivos de entrada a <code>mmap()</code> tanto como sea posible y usando la nueva implementación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>std::string_view</code></a> de C ++ 17 para minimizar la creación de copias de cadenas a partir del contenido del archivo.  Además, dado que <code>strtod()</code> tomó mucho tiempo en las trazas anteriores, escribí <a href=""><code> parseNumber()</code></a> con especial cuidado: los enteros de un solo dígito y los enteros regulares se procesan por separado, y en el caso estándar cuando se compila pbrt para usar flotantes de 32 bits , usó <code>strtof()</code> lugar de <code>strtod()</code> <sup>1</sup> . <br><br>  En el proceso de crear una implementación del nuevo analizador, tenía un poco de miedo de que el analizador anterior fuera más rápido: al final, flex y bison se han desarrollado y optimizado durante muchos años.  No pude averiguar de antemano si se desperdiciaría todo el tiempo escribiendo una nueva versión hasta que la completara y la hiciera funcionar correctamente. <br><br>  Para mi alegría, nuestro propio analizador resultó ser una gran victoria: la generalización de flex y bison redujo tanto el rendimiento que la nueva versión los superó fácilmente.  Gracias al nuevo analizador, el tiempo de lanzamiento disminuyó a 13 min 21 s, es decir, ¡se aceleró otras 1,5 veces!  Una ventaja adicional era que ahora era posible eliminar todo el soporte de flex y bison del sistema de compilación pbrt.  Siempre ha sido un dolor de cabeza, especialmente en Windows, donde la mayoría de las personas no lo tienen instalado de forma predeterminada. <br><br><h2>  Gestión de estado de gráficos </h2><br>  Después de acelerar significativamente el analizador, surgió un nuevo detalle molesto: en esta etapa, aproximadamente el 10% del tiempo de configuración se gastó en las funciones <code>pbrtAttributeBegin()</code> y <code>pbrtAttributeEnd()</code> , y la mayor parte de este tiempo se asignó y liberó memoria dinámica.  Durante la primera ejecución, que tomó 35 minutos, estas funciones tomaron solo alrededor del 3% del tiempo de ejecución, por lo que podrían ignorarse.  Pero con la optimización siempre es así: cuando comienzas a deshacerte de los grandes problemas, los pequeños se vuelven más importantes. <br><br>  La descripción de la escena pbrt se basa en el estado jerárquico del gráfico, que indica la transformación actual, el material actual, etc.  En él, puede tomar instantáneas del estado actual ( <code>pbrtAttributeBegin()</code> ), realizar cambios antes de agregar una nueva geometría a la escena y luego volver al estado original ( <code>pbrtAttributeEnd()</code> ). <br><br>  El estado de los gráficos se almacena en una estructura con un nombre inesperado ... <code>GraphicsState</code> .  Para almacenar copias de objetos <code>GraphicsState</code> en la pila de estados gráficos guardados, <code>std::vector</code> .  Mirando a los miembros de <code>GraphicsState</code> , podemos asumir la fuente de los problemas: tres <code>std::map</code> , desde nombres hasta instancias de texturas y materiales: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Float&gt;&gt;&gt; floatTextures; std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt;&gt; spectrumTextures; std::map&lt;std::string, std::shared_ptr&lt;MaterialInstance&gt;&gt; namedMaterials; };</span></span></code> </pre> <br>  Al examinar estos archivos de escena, descubrí que la mayoría de los casos de guardar y restaurar el estado de los gráficos se realizan en estas líneas: <br><br><pre> <code class="cpp hljs">AttributeBegin ConcatTransform [<span class="hljs-number"><span class="hljs-number">0.981262</span></span> <span class="hljs-number"><span class="hljs-number">0.133695</span></span> <span class="hljs-number"><span class="hljs-number">-0.138749</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">-0.067901</span></span> <span class="hljs-number"><span class="hljs-number">0.913846</span></span> <span class="hljs-number"><span class="hljs-number">0.400343</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">0.180319</span></span> <span class="hljs-number"><span class="hljs-number">-0.383420</span></span> <span class="hljs-number"><span class="hljs-number">0.905800</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">11.095301</span></span> <span class="hljs-number"><span class="hljs-number">18.852249</span></span> <span class="hljs-number"><span class="hljs-number">9.481399</span></span> <span class="hljs-number"><span class="hljs-number">1.000000</span></span>] ObjectInstance <span class="hljs-string"><span class="hljs-string">"archivebaycedar0001_mod"</span></span> AttributeEnd</code> </pre> <br>  En otras palabras, actualiza la transformación actual e instancia el objeto;  no se realizan cambios en el contenido de estos <code>std::map</code> .  Crear una copia completa de ellos, asignar nodos de árbol rojo-negro, aumentar los recuentos de referencias para punteros comunes, asignar espacio y copiar cadenas, es casi siempre una pérdida de tiempo.  Todo esto se libera al restaurar el estado anterior de los gráficos. <br><br>  <code>std::shared_ptr</code> cada uno de estos mapas con el puntero <code>std::shared_ptr</code> para mapear e implementé el enfoque de copia en escritura, en el que la copia dentro del bloque de inicio / fin de un atributo ocurre solo cuando es necesario cambiar su contenido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El cambio</a> no fue particularmente difícil, pero redujo el tiempo de lanzamiento en más de un minuto, lo que nos dio 12 min 20 s de procesamiento antes del inicio del renderizado, nuevamente una aceleración de 1.08 veces. <br><br><h2>  ¿Qué pasa con el tiempo de renderizado? </h2><br>  Un lector atento notará que hasta ahora no he dicho nada sobre el tiempo de representación.  Para mi sorpresa, resultó ser bastante tolerable incluso fuera de la caja: pbrt puede renderizar imágenes de escenas de calidad cinematográfica con varios cientos de muestras por píxel en doce núcleos de procesador durante un período de dos a tres horas.  Por ejemplo, esta imagen, una de las más lentas, renderizada en 2 horas 51 minutos 36 segundos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg"></div><br>  <i>Dunas de Moana renderizadas por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pbrt-v3</a> con una resolución de 2048x858 a 256 muestras por píxel.</i>  <i>El tiempo total de representación en una instancia de Google Compute Engine con 12 núcleos / 24 subprocesos con una frecuencia de 2 GHz y la última versión de pbrt-v3 fue de 2 horas 51 minutos 36 segundos.</i> <br><br>  En mi opinión, esto parece un indicador sorprendentemente razonable.  Estoy seguro de que las mejoras aún son posibles, y un estudio cuidadoso de los lugares en los que se pasa la mayor parte del tiempo revelará muchas cosas "interesantes", pero hasta ahora no hay razones especiales para ello. <br><br>  Al perfilar, resultó que aproximadamente el 60% del tiempo de renderizado se gastó en la intersección de los rayos con los objetos (la mayoría de las operaciones se realizaron sin pasar por BVH), y el 25% se gastó buscando texturas ptex.  Estas proporciones son similares a los indicadores de escenas más simples, por lo que a primera vista no hay nada obviamente problemático aquí.  (Sin embargo, estoy seguro de que Embree podrá rastrear estos rayos en un poco menos de tiempo). <br><br>  Desafortunadamente, la escalabilidad paralela no es tan buena.  Por lo general, veo que el 1400% de los recursos de la CPU se gastan en renderizado, en comparación con el ideal del 2400% (en 24 CPU virtuales en Google Compute Engine).  Parece que el problema está relacionado con conflictos durante bloqueos en ptex, pero aún no lo he investigado con más detalle.  Es muy probable que pbrt-v3 no calcule la diferencia de rayos para los rayos indirectos en el rastreador de rayos;  a su vez, tales haces siempre obtienen acceso al nivel de texturas MIP más detallado, lo que no es muy útil para el almacenamiento en caché de texturas. <br><br><h2>  Conclusión (para pbrt-v3) </h2><br>  Habiendo corregido la gestión del estado de los gráficos, me encontré con un límite, después del cual no se hicieron evidentes progresos adicionales sin realizar cambios significativos en el sistema;  todo el resto tomó mucho tiempo y tuvo poco que ver con la optimización.  Por lo tanto, me detendré en esto, al menos con respecto a pbrt-v3. <br><br>  En general, el progreso fue serio: el tiempo de lanzamiento antes del renderizado disminuyó de 35 minutos a 12 minutos y 20 segundos, es decir, la aceleración total fue de 2,83 veces.  Además, gracias al trabajo inteligente con el caché de conversión, el uso de memoria ha disminuido de 80 GB a 69 GB.  Todos estos cambios están disponibles ahora si está sincronizando con la última versión de pbrt-v3 (o si lo ha hecho en los últimos meses). Y entendemos cuán basura es la memoria <code>Primitive</code> para esta escena;  descubrimos cómo guardar otros 18 GB de memoria, pero no lo implementamos en pbrt-v3. <br><br>  Esto es en lo que se gastan estos 12 min 20 s después de todas nuestras optimizaciones: <br><br><table><thead><tr><th>  Función / Operación </th><th>  Porcentaje de tiempo de ejecución </th></tr></thead><tbody><tr><td>  Build BVH </td><td>  34% </td></tr><tr><td>  Análisis (excepto <code>strtof()</code> ) </td><td>  21% </td></tr><tr><td> <code>strtof()</code> </td> <td>  20% </td></tr><tr><td>  Caché de conversión </td><td>  7% </td></tr><tr><td>  Leer archivos PLY </td><td>  6% </td></tr><tr><td>  Asignación de memoria dinámica </td><td>  5% </td></tr><tr><td>  Inversión de conversión </td><td>  2% </td></tr><tr><td>  Gestión de estado de gráficos </td><td>  2% </td></tr><tr><td>  Otros </td><td>  3% </td></tr></tbody></table><br>  En el futuro, la mejor opción para mejorar el rendimiento será una multiproceso aún mayor de la etapa de lanzamiento: casi todo durante el análisis de la escena es de un solo subproceso;  Nuestro primer objetivo más natural es construir un BVH.  También será interesante analizar cosas como leer archivos PLY y generar BVH para instancias individuales de objetos y ejecutarlos de forma asíncrona en segundo plano, mientras que el análisis se realizará en el hilo principal. <br><br>  En algún momento, veré si hay implementaciones más rápidas de <code>strtof()</code> ;  pbrt usa solo lo que proporciona el sistema.  Sin embargo, debe tener cuidado con la elección de los reemplazos que no se prueban muy a fondo: analizar los valores flotantes es uno de esos aspectos de los que el programador debe estar completamente seguro. <br><br>  También parece atractivo reducir aún más la carga en el analizador: todavía tenemos 17 GB de archivos de entrada de texto para analizar.  Podemos agregar soporte de codificación binaria para archivos de entrada pbrt (posiblemente similar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enfoque RenderMan</a> ), pero tengo sentimientos encontrados acerca de esta idea;  La capacidad de abrir y modificar archivos de descripción de escena en un editor de texto es bastante útil, y me preocupa que a veces la codificación binaria confunda a los estudiantes que usan pbrt en el proceso de aprendizaje.  Este es uno de esos casos en los que la solución correcta para pbrt puede diferir de las soluciones para una representación comercial de un nivel de producción. <br><br>  Fue muy interesante hacer un seguimiento de todas estas optimizaciones y comprender mejor varias soluciones.  Resultó que pbrt tiene suposiciones inesperadas que interfieren con la escena de este nivel de complejidad.  Todo esto es un gran ejemplo de lo importante que es para una amplia comunidad de investigadores de acceso tener acceso a escenas de producción reales con un alto grado de complejidad;  Nuevamente le agradezco a Disney por el tiempo dedicado a procesar esta escena y ponerla en el dominio público. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">próximo artículo</a> , analizaremos aspectos que pueden mejorar aún más el rendimiento si permitimos que pbrt realice cambios más radicales. <br><br><h2>  Nota </h2><br><ol><li>  En el sistema Linux en el que estaba probando, <code>strtof()</code> no <code>strtof()</code> más rápido que <code>strtod()</code> .  Es de destacar que en OS X <code>strtod()</code> aproximadamente dos veces más rápido, lo cual es completamente ilógico.  Por razones prácticas, seguí usando <code>strtof()</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417913/">https://habr.com/ru/post/es417913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417901/index.html">Cómo comenzamos a hacer largas reuniones increíbles y por qué esto ya no es un mal universal</a></li>
<li><a href="../es417903/index.html">Revisión de código caso 1</a></li>
<li><a href="../es417905/index.html">11 maneras (no) de ser víctima de piratería en Kubernetes</a></li>
<li><a href="../es417909/index.html">¿Por qué necesitas Splunk? Analítica de aplicaciones</a></li>
<li><a href="../es417911/index.html">Diseño continuo en desarrollo: metodología y principio</a></li>
<li><a href="../es417915/index.html">Cómo jugar un compañero de cuarto</a></li>
<li><a href="../es417917/index.html">ASC'18: Persistencia y entrenamiento regular como una forma de alcanzar la meta.</a></li>
<li><a href="../es417919/index.html">Modelado de vibración y ruido en la caja de cambios de un automóvil</a></li>
<li><a href="../es417927/index.html">Cyber ​​Battle en PHDays o Cómo piratear infraestructura urbana en 30 horas</a></li>
<li><a href="../es417929/index.html">Extracto del libro "Un día en la vida del cerebro. Neurobiología de la conciencia desde el amanecer hasta el anochecer "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>