<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏ ‚è¨ üçí Creando un juego para Game Boy, Parte 2 üÖæÔ∏è ü§Ωüèª üëêüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unas semanas, decid√≠ trabajar en un juego para Game Boy, cuya creaci√≥n me dio un gran placer. Su nombre de trabajo es Aqua and Ashes. El juego ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creando un juego para Game Boy, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436918/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="imagen"></div><br>  Hace unas semanas, decid√≠ trabajar en un juego para Game Boy, cuya creaci√≥n me dio un gran placer.  Su nombre de trabajo es Aqua and Ashes.  El juego tiene c√≥digo abierto y est√° publicado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  La parte anterior del art√≠culo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  Sprites fant√°sticos y d√≥nde viven </h2><br>  En la √∫ltima parte, termin√© de renderizar varios sprites en la pantalla.  Esto se hizo de una manera muy arbitraria y ca√≥tica.  De hecho, tuve que indicar en el c√≥digo qu√© y d√≥nde quiero mostrar.  Esto hizo que la creaci√≥n de animaci√≥n fuera casi imposible, pas√≥ mucho tiempo de CPU y soporte de c√≥digo complicado.  Necesitaba una mejor manera. <br><br>  Espec√≠ficamente, necesitaba un sistema en el que simplemente pudiera iterar el n√∫mero de animaci√≥n, el n√∫mero de fotograma y el temporizador para cada animaci√≥n individual.  Si tuviera que cambiar la animaci√≥n, simplemente cambiar√≠a la animaci√≥n y restablecer√≠a el contador de cuadros.  El procedimiento de animaci√≥n realizado en cada cuadro simplemente debe elegir los sprites apropiados para mostrar y lanzarlos en la pantalla sin ning√∫n esfuerzo de mi parte. <br><a name="habracut"></a><br>  Y result√≥ que esta tarea est√° pr√°cticamente resuelta.  Lo que estaba buscando se llama <em>mapeo de sprites</em> .  Los mapas de sprites son estructuras de datos que (en t√©rminos generales) contienen una lista de sprites.  Cada mapa de sprites contiene todos los sprites para representar un solo objeto.  Tambi√©n se asocian con ellos los <em>mapas de animaci√≥n (mapeos de animaci√≥n)</em> , que son listas de mapas de sprites con informaci√≥n sobre c√≥mo hacer un bucle. <br><br>  Es muy divertido que en mayo, agregu√© un editor de mapas de animaci√≥n al editor de mapas de sprites listo para juegos de Sonic de 16 bits sobre Sonic.  (√âl est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , puedes estudiarlo) Todav√≠a no est√° completo, porque es bastante duro, dolorosamente lento e inc√≥modo de usar.  Pero desde un punto de vista t√©cnico, funciona.  Y <em>me</em> parece que es bastante genial ... (Una de las razones de la aspereza fue que literalmente trabaj√© por primera vez con el marco de JavaScript). Sonic es un juego antiguo, por lo que es ideal como base para mi juego nuevo y antiguo. <br><br><h2>  Formato de tarjeta Sonic 2 </h2><br>  Ten√≠a la intenci√≥n de usar el editor en Sonic 2 porque quer√≠a crear un truco para Genesis.  Sonic 1 y 3K son b√°sicamente lo mismo, pero para no complicarme, me limitar√© a la historia de la segunda parte. <br><br>  Primero, veamos los mapas de sprites.  Aqu√≠ hay un sprite de Tails bastante t√≠pico, parte de la animaci√≥n de parpadeo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  La consola Genesis crea sprites un poco diferente.  El mosaico de Genesis (la mayor√≠a de los programadores lo llaman "patr√≥n") es 8x8, al igual que en Game Boy.  El sprite consiste en un rect√°ngulo de hasta 4x4 fichas, muy parecido al modo sprite 8x16 en Game Boy, pero m√°s flexible.  El truco aqu√≠ es que en la memoria estos mosaicos deben estar uno al lado del otro.  Los desarrolladores de Sonic 2 quer√≠an reutilizar la mayor cantidad de mosaicos posible para un marco de Tails parpadeante de un marco de Tails permanente.  Por lo tanto, Tails se divide en 2 sprites de hardware, que consisten en fichas de 3x2, una para la cabeza y la otra para el cuerpo.  Se muestran en la figura a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  La parte superior de este cuadro de di√°logo son los atributos del sprite de hardware.  Contiene su posici√≥n con respecto al punto de partida (los n√∫meros negativos est√°n cortados; de hecho, estos son -16 y -12 para el primer sprite y -12 para el segundo), el mosaico inicial utilizado en VRAM, el ancho y la altura del sprite, as√≠ como varios bits de estado para Imagen de espejo de sprite y paleta. <br><br>  Los mosaicos se muestran en la parte inferior a medida que se cargan de la ROM a la VRAM.  No hay suficiente espacio para almacenar todos los sprites de Tails en VRAM, por lo que los mosaicos necesarios deben copiarse en la memoria en cada fotograma.  Se llaman <em>se√±ales de carga de patr√≥n din√°mico</em> .  Sin embargo, si bien podemos omitirlos, porque son casi independientes de los mapas de sprites y, por lo tanto, pueden agregarse f√°cilmente m√°s adelante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  En cuanto a la animaci√≥n, todo aqu√≠ es un poco m√°s f√°cil.  Un mapa de animaci√≥n en Sonic es una lista de mapas de sprites con dos metadatos: el valor de la velocidad y la acci√≥n que se tomar√° una vez que finalice la animaci√≥n.  Las tres acciones m√°s utilizadas son: un bucle sobre todos los fotogramas, un bucle sobre los √∫ltimos N fotogramas o una transici√≥n a una animaci√≥n completamente diferente (por ejemplo, al cambiar de una animaci√≥n de un Sonic de pie a una animaci√≥n de sus impacientes golpes con el pie).  Hay un par de comandos que especifican banderas internas en la memoria de los objetos, pero no muchos objetos los usan.  (Ahora se me ocurri√≥ que puede establecer el bit en la RAM del objeto a un valor cuando se repite la animaci√≥n. Esto ser√° √∫til para efectos de sonido y otras cosas). <br><br>  Si observa el c√≥digo <a href="">desmontado de Sonic 1</a> (el c√≥digo de Sonic 2 es demasiado grande para vincularlo), notar√° que el enlace a las animaciones no est√° hecho por ninguna ID.  Cada objeto recibe una lista de animaciones y el √≠ndice de animaci√≥n se almacena en la memoria.  Para representar una animaci√≥n espec√≠fica, el juego toma un √≠ndice, lo busca en la lista de animaciones y luego lo muestra.  Esto hace que el trabajo sea un poco m√°s f√°cil, ya que no necesita escanear animaciones para encontrar la que necesita. <br><br><h2>  Limpiamos la sopa de las estructuras. </h2><br>  Veamos los tipos de tarjetas: <br><br><ol><li>  Mapas de sprites: una lista de sprites que consta de un mosaico inicial, el n√∫mero de mosaicos, la posici√≥n, el estado de reflexi√≥n (el sprite se refleja o no) y una paleta. </li><li>  DPLC: una lista de mosaicos de ROM que deben cargarse en VRAM.  Cada art√≠culo en un DPLC consta de un mosaico inicial y una longitud;  cada art√≠culo se coloca en VRAM despu√©s del √∫ltimo. </li><li>  Mapas de animaci√≥n: una lista de animaciones que consiste en una lista de mapas de sprites, valores de velocidad y acciones de ciclo. </li><li>  Lista de animaci√≥n: una lista de punteros a la acci√≥n de cada animaci√≥n. </li></ol><br>  Dado que estamos trabajando con Game Boy, se pueden hacer algunas simplificaciones.  Sabemos que en los mapas de sprites en un sprite de 8x16 siempre habr√° dos mosaicos.  Sin embargo, todo lo dem√°s debe ser preservado.  Por ahora, podemos abandonar completamente DPLC y simplemente almacenar todo en VRAM.  Esta es una soluci√≥n temporal, pero, como dije, este problema ser√° f√°cil de resolver.  Finalmente, podemos descartar el valor de la velocidad si suponemos que cada animaci√≥n funciona a la misma velocidad. <br><br>  Comencemos a descubrir c√≥mo implementar un sistema similar en mi juego. <br><br>  ¬°Consulte con commit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2e5e5b7</a> ! <br><br>  Comencemos con los mapas de sprites.  Cada elemento en el mapa debe reflejar OAM (Object Attribute Memory - sprite VRAM) y, por lo tanto, un simple loop y memcpy ser√°n suficientes para mostrar el objeto.  Perm√≠tame recordarle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un elemento en OAM consiste en Y, X, un mosaico inicial y un byte de atributo</a> .  Solo necesito crear una lista de ellos.  Utilizando el pseudo-operador ensamblado EQU, prepar√© el byte de atributo de antemano para tener un nombre legible para cada combinaci√≥n posible de atributos.  (Puede notar que en la confirmaci√≥n anterior, reemplac√© el mosaico Y / X en las tarjetas. Esto sucedi√≥ porque le√≠ las especificaciones de OAM sin prestar atenci√≥n. Tambi√©n agregu√© un contador de sprites para saber cu√°nto tiempo deber√≠a durar el ciclo). <br><br>  Notar√°s que el cuerpo y la cola del zorro polar se almacenan por separado.  Si se almacenaran juntos, entonces habr√≠a <em>mucha</em> redundancia, porque cada animaci√≥n tendr√≠a que duplicarse para cada estado de cola.  Y la escala de redundancia aumentar√≠a r√°pidamente.  En Sonic 2, el mismo problema surgi√≥ con Tails.  Lo resolvieron all√≠, haciendo que Tails Tails sea un objeto separado con su propio estado de animaci√≥n y temporizador.  No quiero hacer esto porque no trato de resolver el problema de mantener la posici√≥n correcta de la cola en relaci√≥n con el zorro. <br><br>  Resolv√≠ el problema a trav√©s de mapas de animaci√≥n.  Si miras mi mapa de animaci√≥n (√∫nico), entonces hay tres piezas de metadatos en √©l.  Muestra la cantidad de tarjetas de animaci√≥n, as√≠ que s√© cu√°ndo terminar√°n.  (En Sonic, se verifica que la siguiente animaci√≥n no sea v√°lida, similar al concepto de cero byte en l√≠neas C. Una soluci√≥n de Sonic libera el caso, pero agrega una comparaci√≥n que funcionar√≠a en mi contra). Por supuesto, todav√≠a hay una acci√≥n de bucle.  (Convert√≠ el circuito de Sonic de 2 bytes en un n√∫mero de 1 byte en el que el bit 7 es el bit de modo). Pero tambi√©n tengo el n√∫mero <em>de tarjetas de sprites</em> , pero no estaba en Sonic.  Tener varios mapas de sprites por cuadro de animaci√≥n me permite reutilizar animaciones en varias animaciones, lo que, en mi opini√≥n, ahorrar√° mucho espacio precioso.  Tambi√©n puede notar que las animaciones est√°n duplicadas para cada direcci√≥n.  Esto se debe a que los mapas para cada direcci√≥n son diferentes y debe agregarlos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="imagen"></div><br><h2>  Bailando con registros </h2><br>  Consulte <a href="">este archivo</a> en 1713848. <br><br>  Comencemos dibujando un solo sprite en la pantalla.  Entonces, confieso, ment√≠.  Perm√≠tame recordarle que no podemos grabar en la pantalla fuera de VBlank.  Y todo este proceso es demasiado largo para encajarlo en VBlank.  Por lo tanto, necesitamos registrar el √°rea de memoria que asignaremos para DMA.  Al final, no cambia nada, es importante grabar en el lugar correcto. <br><br>  Comencemos a contar registros.  El procesador GBZ80 tiene 6 registros, de A a E, H y L. H y L son registros especiales, por lo que son muy adecuados para realizar iteraciones desde la memoria.  (Como se usan juntos, se llaman HL). En un c√≥digo de operaci√≥n, puedo escribir en la direcci√≥n de memoria contenida en HL y agregarle uno.  Esto es dif√≠cil de manejar.  Puede usarlo como fuente o como destino.  Lo utilic√© como direcciones, y la combinaci√≥n de registros BC como fuente, porque era m√°s conveniente.  Solo tenemos A, D y E. Necesito registrar A para operaciones matem√°ticas y similares.  ¬øPara qu√© se puede usar DE?  Uso D como contador de bucle y E como espacio de trabajo.  Y aqu√≠ es donde terminaron los registros. <br><br>  Digamos que tenemos 4 sprites.  Establecemos el registro D (contador de ciclos) en 4, el registro HL (destino), la direcci√≥n del b√∫fer OAM y BC (la fuente) la ubicaci√≥n en ROM donde se almacenan nuestras tarjetas.  Ahora me gustar√≠a llamar a memcpy.  Sin embargo, surge un peque√±o problema.  ¬øRecuerdas las coordenadas X e Y?  Se indican en relaci√≥n con el punto de partida, el centro del objeto se utiliza para colisiones y similares.  Si los grabamos tal cual, entonces cada objeto se mostrar√≠a en la esquina superior izquierda de la pantalla.  Esto no nos conviene.  Para solucionar esto, necesitamos agregar las coordenadas X e Y del objeto a X e Y del sprite. <br><br>  Nota breve: hablo de "objetos", pero no te expliqu√© este concepto.  Un objeto es simplemente un conjunto de atributos asociados con un objeto en un juego.  Los atributos son una posici√≥n, velocidad, direcci√≥n.  descripci√≥n del art√≠culo, etc.  Hablo de esto porque necesito extraer datos de X e Y de estos objetos. Para hacer esto, necesitamos un tercer conjunto de registros que se√±alen el lugar en la RAM de los objetos donde se encuentran las coordenadas.  Y luego necesitamos almacenar X e Y en alg√∫n lugar. Lo mismo se aplica a la direcci√≥n, porque nos ayuda a determinar en qu√© direcci√≥n miran los sprites.  Adem√°s, necesitamos renderizar <em>todos los</em> objetos, por lo que tambi√©n necesitan un contador de bucles.  ¬°Y todav√≠a no hemos llegado a las animaciones!  Todo se descontrola r√°pidamente ... <br><br><h2>  Revisi√≥n de decisiones </h2><br>  Entonces, estoy corriendo demasiado adelante.  Volvamos y pensemos en cada dato que necesito rastrear y d√≥nde escribirlo. <br><br>  Para comenzar, dividamos esto en "pasos".  Cada paso solo debe recibir datos para el siguiente, con la excepci√≥n del √∫ltimo que realiza la copia. <br><br><ol><li>  Objeto (bucle): descubre si el objeto debe procesarse y lo procesa. </li><li>  Lista de animaciones: determina qu√© animaci√≥n mostrar.  Tambi√©n obtiene los atributos de un objeto. </li><li>  Animaci√≥n (bucle): determina qu√© lista de mapas usar y representa cada mapa a partir de ella. </li><li>  Mapa (ciclo): recorre iterativamente cada sprite en la lista de sprites </li><li>  Sprite: copia los atributos de sprite en el b√∫fer OAM </li></ol><br>  Para cada una de las etapas, he enumerado las variables que necesitan, los roles que desempe√±an y los lugares donde almacenarlas.  Esta tabla se parece a esto. <br><br><table><tbody><tr><th>  Descripci√≥n </th><th>  Tama√±o </th><th>  Etapa </th><th>  Uso </th><th>  De donde </th><th>  Lugar </th><th>  A donde </th></tr><tr><td>  Tamp√≥n OAM </td><td>  2 </td><td>  Sprite </td><td>  Puntero </td><td>  Hl </td><td>  Hl </td><td></td></tr><tr><td>  Fuente del mapa </td><td>  2 </td><td>  Sprite </td><td>  Puntero </td><td>  BC </td><td>  BC </td><td></td></tr><tr><td>  Byte actual </td><td>  1 </td><td>  Sprite </td><td>  Espacio de trabajo </td><td>  Fuente del mapa </td><td>  E </td><td></td></tr><tr><td>  X </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td>  Y </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Inicio del mapa de animaci√≥n. </td><td>  2 </td><td>  Mapa de sprites </td><td>  Puntero </td><td>  Stack3 </td><td>  DE </td><td></td></tr><tr><td>  Fuente del mapa </td><td>  2 </td><td>  Mapa de sprites </td><td>  Puntero </td><td>  [DE] </td><td>  BC </td><td></td></tr><tr><td>  Sprites restantes </td><td>  1 </td><td>  Mapa de sprites </td><td>  Rascarse </td><td>  Fuente del mapa </td><td>  D </td><td></td></tr><tr><td>  Tamp√≥n OAM </td><td>  1 </td><td>  Mapa de sprites </td><td>  Puntero </td><td>  Hl </td><td>  Hl </td><td>  Pila1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  Inicio del mapa de animaci√≥n. </td><td>  2 </td><td>  Animaci√≥n </td><td>  Espacio de trabajo </td><td>  BC / Stack3 </td><td>  BC </td><td>  Stack3 </td></tr><tr><td>  Tarjetas restantes </td><td>  1 </td><td>  Animaci√≥n </td><td>  Espacio de trabajo </td><td>  Inicio de animaci√≥n </td><td>  Hiram </td><td></td></tr><tr><td>  Numero total de tarjetas </td><td>  1 </td><td>  Animaciones </td><td>  Variable </td><td>  Inicio de animaci√≥n </td><td>  Hiram </td><td></td></tr><tr><td>  Direcci√≥n de objeto </td><td>  1 </td><td>  Animaci√≥n </td><td>  Variable </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Tarjetas por cuadro </td><td>  1 </td><td>  Animaci√≥n </td><td>  Variable </td><td>  Inicio de animaci√≥n </td><td>  NO UTILIZADO !!! </td><td></td></tr><tr><td>  N√∫mero de marco </td><td>  1 </td><td>  Animaci√≥n </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td>  Puntero del mapa </td><td>  2 </td><td>  Animaci√≥n </td><td>  Puntero </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  BC </td><td>  DE </td></tr><tr><td>  Tamp√≥n OAM </td><td>  2 </td><td>  Animaci√≥n </td><td>  Puntero </td><td>  Pila1 </td><td>  Hl </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Inicio de la mesa de animaci√≥n. </td><td>  2 </td><td>  Lista de animaciones </td><td>  Espacio de trabajo </td><td>  Conjunto duro </td><td>  DE </td><td></td></tr><tr><td>  Fuente de objeto </td><td>  2 </td><td>  Lista de animaciones </td><td>  Puntero </td><td>  Hl </td><td>  Hl </td><td>  Stack2 </td></tr><tr><td>  N√∫mero de marco </td><td>  1 </td><td>  Lista de animaciones </td><td>  Variable </td><td>  Fuente de objeto </td><td>  Hiram </td><td></td></tr><tr><td>  N√∫mero de animaci√≥n </td><td>  1 </td><td>  Lista de animaciones </td><td>  Espacio de trabajo </td><td>  Fuente de objeto </td><td>  Un </td><td></td></tr><tr><td>  Objeto X </td><td>  1 </td><td>  Lista de objetos </td><td>  Variable </td><td>  Fuente de objeto </td><td>  Hiram </td><td></td></tr><tr><td>  Objeto Y </td><td>  1 </td><td>  Lista de animaciones </td><td>  Variable </td><td>  Fuente de objeto </td><td>  Hiram </td><td></td></tr><tr><td>  Direcci√≥n de objeto </td><td>  1 </td><td>  Lista de animaciones </td><td>  Variable </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  Inicio del mapa de animaci√≥n. </td><td>  2 </td><td>  Lista de animaciones </td><td>  Puntero </td><td>  [Tabla de animaci√≥n + Anima #] </td><td>  BC </td><td></td></tr><tr><td>  Tamp√≥n OAM </td><td>  2 </td><td>  Lista de animaciones </td><td>  Puntero </td><td>  DE </td><td>  Pila1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Fuente de objeto </td><td>  2 </td><td>  Ciclo de objetos </td><td>  Poste indicador </td><td>  Hard Set / Stack2 </td><td>  Hl </td><td></td></tr><tr><td>  Objetos restantes </td><td>  1 </td><td>  Ciclo de objetos </td><td>  Variable </td><td>  Calculado </td><td>  B </td><td></td></tr><tr><td>  Campo de bit activo de un objeto </td><td>  1 </td><td>  Ciclo de objetos </td><td>  Variable </td><td>  Calculado </td><td>  C </td><td></td></tr><tr><td>  Tamp√≥n OAM </td><td>  2 </td><td>  Ciclo de objetos </td><td>  Puntero </td><td>  Conjunto duro </td><td>  DE </td><td></td></tr></tbody></table><br>  Si, muy confuso.  Para ser completamente honesto, hice esta tabla solo para publicaci√≥n, para explicar m√°s claramente, pero ya ha comenzado a ser √∫til.  Tratar√© de explicarlo. Comencemos desde el final y lleguemos al principio.  Ver√° todos los datos con los que empiezo: la fuente del objeto, el b√∫fer OAM y las variables de bucle precalculadas.  En cada ciclo, comenzamos con esto y solo esto, excepto que la fuente del objeto se actualiza en cada ciclo. <br><br>  Para cada objeto que renderizamos, es necesario definir la animaci√≥n mostrada.  Mientras hacemos esto, tambi√©n podemos guardar los atributos X, Y, Cuadro # y Direcci√≥n antes de incrementar el puntero del objeto al siguiente objeto y guardarlos en la pila para recuperarlos al salir.  Usamos el n√∫mero de animaci√≥n en combinaci√≥n con la tabla de animaci√≥n codificada en el c√≥digo para determinar d√≥nde comienza el mapa de animaci√≥n.  (Aqu√≠ simplifico, suponiendo que cada objeto tiene la misma tabla de animaci√≥n. Esto me limita a 256 animaciones por juego, pero es poco probable que supere este valor). Tambi√©n podemos escribir un b√∫fer OAM para guardar algunos registros. <br><br>  Despu√©s de extraer el mapa de animaci√≥n, necesitamos encontrar d√≥nde se encuentra la lista de mapas de sprites para un cuadro y direcci√≥n determinados, as√≠ como cu√°ntos mapas necesita renderizar.  Puede notar que no se utiliza la variable de tarjeta por cuadro.  Sucedi√≥ porque no pens√© y establec√≠ el valor constante 2. Necesito arreglarlo.  Tambi√©n necesitamos extraer el b√∫fer OAM de la pila.  Tambi√©n puede notar una falta total de control del ciclo.  Se realiza en un subprocedimiento separado, mucho m√°s simple, que le permite deshacerse del malabarismo con los registros. <br><br>  Despu√©s de eso, todo se vuelve bastante simple.  Un mapa es un conjunto de sprites, por lo que los rodeamos en un bucle y dibujamos en funci√≥n de las coordenadas X e Y almacenadas. Sin embargo, de nuevo guardamos el puntero OAM al final de la lista de sprites para que el siguiente mapa comience donde terminamos. <br><br>  ¬øCu√°l fue el resultado final de todo esto?  Exactamente igual que antes: un zorro polar agitando su cola en la oscuridad.  Pero agregar nuevas animaciones o sprites ahora es mucho m√°s f√°cil.  En la siguiente parte, hablar√© sobre fondos complejos y desplazamiento de paralaje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="imagen"></div><br><h2>  Parte 4. Fondo de paralaje </h2><br>  Perm√≠tame recordarle que, en la etapa actual, tenemos sprites animados sobre un fondo negro s√≥lido.  Si no planeo hacer un juego de arcade de los 70, entonces esto claramente no ser√° suficiente.  Necesito alg√∫n tipo de imagen de fondo. <br><br>  En la primera parte, cuando dibujaba gr√°ficos, tambi√©n cre√© varios mosaicos de fondo.  Es hora de usarlos.  Tendremos tres tipos de baldosas "b√°sicas" (cielo, hierba y tierra) y dos baldosas de transici√≥n.  Todos ellos est√°n cargados en VRAM y listos para usar.  Ahora solo tenemos que escribirlos en segundo plano. <br><br><h2>  Antecedentes </h2><br>  Los fondos de Game Boy se almacenan en la memoria en una matriz de 32x32 de mosaicos de 8x8.  Cada 32 bytes corresponde a una l√≠nea de mosaicos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  Hasta ahora, planeo repetir la misma <em>columna de</em> mosaicos en todo el espacio de 32x32.  Esto es genial, pero crea un peque√±o problema: tendr√© que configurar <em>cada</em> mosaico 32 veces seguidas.  Ser√° mucho tiempo para escribir. <br><br>  Instintivamente, decid√≠ usar el comando REPT para agregar 32 bytes / l√≠nea, y luego usar memcpy para copiar el fondo en VRAM. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  Sin embargo, esto significar√° que debe asignar 256 bytes para un solo fondo, lo cual es bastante.  Este problema se exacerba si recuerda que copiar un mapa de fondo creado previamente con memcpy no le permitir√° agregar otros tipos de columnas (por ejemplo, compuertas, obst√°culos) sin una complejidad significativa y un mont√≥n de ROM de cartuchos desperdiciados. <br><br>  Entonces, en cambio, decid√≠ configurar una sola columna de la siguiente manera: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  y luego use un bucle simple para copiar cada elemento en esta lista 32 veces.  (vea <a href=""><code> LoadGFX</code> archivo <code> LoadGFX</code> de commit 739986a</a> .) <br><br>  La conveniencia de este enfoque es que luego puedo agregar una cola para escribir algo como esto: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  Si decido representar BGMAP_overview, dibujar√° 1 columna de LeftGoal, despu√©s de lo cual habr√° 30 columnas de Field y 1 columna de RightGoal.  Si <code>BGMAP_overview</code> est√° en RAM, entonces puedo cambiarlo sobre la marcha dependiendo de la posici√≥n de la c√°mara en X. <br><br><h2>  C√°mara y posici√≥n </h2><br>  Oh si, la c√°mara.  Este es un concepto importante del que a√∫n no he hablado.  Aqu√≠ estamos tratando con una multitud de coordenadas, as√≠ que antes de hablar sobre la c√°mara, primero analizaremos todo esto. <br><br>  Necesitamos trabajar con dos sistemas de coordenadas.  El primero son las <em>coordenadas de</em> la <em>pantalla</em> .  Esta es un √°rea de 256x256 que puede estar contenida en la VRAM de la consola Game Boy.  Podemos desplazar la parte visible de la pantalla dentro de estos 256x256, pero cuando vamos m√°s all√° de los bordes, colapsamos. <br><br>  En ancho, necesito m√°s de 256 p√≠xeles, as√≠ que agrego <em>coordenadas mundiales</em> , que en este juego tendr√°n dimensiones de 65536x256.  (No necesito altura adicional en Y, porque el juego tiene lugar en un campo plano). Este sistema est√° completamente separado del sistema de coordenadas de la pantalla.  Toda la f√≠sica y las colisiones deben realizarse en coordenadas mundiales, porque de lo contrario los objetos colisionar√°n con objetos en otras pantallas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Comparaci√≥n de pantalla y coordenadas mundiales</i> <br><br>  Dado que las posiciones de todos los objetos est√°n representadas en coordenadas mundiales, deben convertirse en coordenadas de pantalla antes de renderizar.  En el extremo izquierdo del mundo, las coordenadas mundiales coinciden con las coordenadas de la pantalla.  Si necesitamos mostrar cosas a la derecha en la pantalla, entonces debemos tomar todo en coordenadas mundiales y moverlo a la izquierda para que est√©n en las coordenadas de la pantalla. <br><br>  Para hacer esto, estableceremos la variable "c√°mara X", que se define como el borde izquierdo de la pantalla en el mundo.  Por ejemplo, si la <code>camera X</code> es 1000, entonces podemos ver las coordenadas mundiales 1000-1192, porque la pantalla visible tiene un ancho de 192 p√≠xeles. <br><br>  Para procesar los objetos, simplemente tomamos su posici√≥n en X (por ejemplo, 1002), restamos la posici√≥n de la c√°mara igual a 1000 y dibujamos el objeto en la posici√≥n dada por la diferencia (en nuestro caso, 2).  Para un fondo que <em>no</em> est√° en las coordenadas mundiales, pero que ya se describe en las coordenadas de la pantalla, establecemos la posici√≥n igual al byte inferior de la variable <code>camera X</code> de la <code>camera X</code> .  Gracias a esto, el fondo se desplazar√° hacia la izquierda y hacia la derecha con la c√°mara. <br><br><h2>  Paralaje </h2><br>  El sistema que creamos parece bastante plano.  Cada capa de fondo se mueve a la misma velocidad.  No se siente tridimensional, y necesitamos arreglarlo. <br><br>  Una forma simple de agregar simulaci√≥n 3D se llama desplazamiento de paralaje.  Imagine que conduce por una carretera y est√° muy cansado.  El Game Boy se ha quedado sin bater√≠as y debes mirar por la ventana del autom√≥vil.  Si miras el suelo a tu lado, ver√°s.  que se mueve a una velocidad de 70 millas por hora.  Sin embargo, si observa los campos en la distancia, parecer√° que se mueven mucho m√°s lentamente.  Y si nos fijamos en las monta√±as muy distantes, parece que apenas se mueven. <br><br>  Podemos simular este efecto con tres hojas de papel.  Si dibuja una cadena monta√±osa en una hoja, el campo en la segunda y el camino en la tercera, y col√≥quelos uno encima del otro de esta manera.  para que cada capa sea visible, ser√° una imitaci√≥n de lo que vemos desde la ventana del autom√≥vil.  Si queremos mover el "auto" hacia la izquierda, entonces movemos la hoja superior (con el camino) hacia la derecha, la siguiente est√° un poco a la derecha y la √∫ltima a la derecha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  Sin embargo, al implementar dicho sistema en Game Boy, surge un peque√±o problema.  La consola solo tiene una capa de fondo.  Esto es similar al hecho de que solo tenemos una hoja de papel.  No puede crear un efecto de paralaje con solo una hoja de papel.  ¬øO es posible? <br><br><h2>  H-blank </h2><br>  La pantalla de Game Boy se representa l√≠nea por l√≠nea.  Como resultado de emular el comportamiento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los televisores CRT antiguos,</a> hay un ligero retraso entre cada l√≠nea.  ¬øQu√© pasa si podemos usarlo de alguna manera?  Resulta que Game Boy tiene una interrupci√≥n de hardware especial espec√≠ficamente para este prop√≥sito. <br><br>  Similar a la interrupci√≥n VBlank, que sol√≠amos esperar constantemente hasta el final del cuadro para grabar en VRAM, hay una interrupci√≥n HBlank.  Al establecer el bit 6 del registro en <code>$FF41</code> , encender la interrupci√≥n <code>LCD STAT</code> y escribir el n√∫mero de l√≠nea en <code>$FF45</code> , podemos decirle a Game Boy que inicie la interrupci√≥n <code>LCD STAT</code> cuando est√© a punto de dibujar la l√≠nea especificada (y cuando est√° en su HBlank). <br><br>  Durante este tiempo, podemos cambiar cualquier variable VRAM.  No es <em>mucho</em> tiempo, por lo que no podemos cambiar m√°s que un par de registros, pero a√∫n tenemos algunas posibilidades.  Queremos cambiar el registro de desplazamiento horizontal a <code>$FF43</code> .  En este caso, todo en la pantalla debajo de la l√≠nea especificada se mover√° una cierta cantidad de desplazamiento, creando un efecto de paralaje. <br><br>  Si vuelve al ejemplo de la monta√±a, puede notar un problema potencial.  ¬°Las monta√±as, las nubes y las flores no son l√≠neas planas!  No podemos mover la l√≠nea seleccionada hacia arriba y hacia abajo durante el proceso de renderizado;  si lo elegimos, entonces permanece igual al menos hasta el pr√≥ximo HBlank.  Es decir, solo podemos cortar en l√≠neas rectas. <br><br>  Para resolver este problema, tenemos que hacerlo un poco m√°s inteligentes.  Podemos declarar alguna l√≠nea en el fondo como una l√≠nea que nada puede cruzar, lo que significa cambiar los modos de los objetos arriba y abajo, y el jugador no podr√° notar nada.  Por ejemplo, aqu√≠ es donde est√°n estas l√≠neas en la escena con la monta√±a. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Aqu√≠ hice rodajas justo encima y debajo de la monta√±a.  Todo, desde la parte superior hasta la primera l√≠nea, se mueve lentamente, todo hasta la segunda l√≠nea se mueve a una velocidad promedio, y todo debajo de esta l√≠nea se mueve r√°pidamente.  Este es un truco simple pero inteligente.  Y al conocerlo, puedes notarlo en muchos juegos retro, principalmente para Genesis / Mega Drive, pero tambi√©n en otras consolas.  Uno de los ejemplos m√°s obvios es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte de la cueva</a> de Mickey Mania.  Puede notar que las estalagmitas y las estalactitas en el fondo est√°n separadas <em>exactamente a lo</em> largo de una l√≠nea horizontal con un borde negro obvio entre las capas. <br><br>  Me di cuenta de lo mismo en mi pasado.  Sin embargo, hay un truco.  Suponga que el primer plano se mueve a una velocidad que coincide con el movimiento de la c√°mara, y la velocidad del fondo es un tercio del movimiento de p√≠xeles de la c√°mara, es decir, el fondo se mueve como un tercio del primer plano.  Pero, por supuesto, un tercio del p√≠xel no existe.  Por lo tanto, necesito mover el fondo un p√≠xel por cada tres p√≠xeles de movimiento. <br><br>  Si trabaj√≥ con computadoras capaces de realizar c√°lculos matem√°ticos, tomar√≠a la posici√≥n de la c√°mara, la dividir√≠a entre 3 y convertir√≠a este valor en un desplazamiento de fondo.  Desafortunadamente, Game Boy no es capaz de hacer la divisi√≥n, sin mencionar el hecho de que la divisi√≥n del programa es un proceso muy lento y doloroso.  Agregar un dispositivo para dividir (o multiplicar) a una CPU d√©bil para una consola de entretenimiento port√°til en los a√±os 80 no parec√≠a ser un paso rentable, por lo que tenemos que inventar otra forma. <br><br>  En el c√≥digo, hice lo siguiente: en lugar de leer la posici√≥n de la c√°mara desde una variable, exig√≠ que aumentara o disminuyera.  Gracias a esto, con cada tercer incremento, puedo realizar un incremento de la posici√≥n de fondo, y con cada primer incremento, un incremento de la posici√≥n de primer plano.  Esto complica un poco el desplazamiento a una posici√≥n desde el otro borde del campo (la forma m√°s f√°cil es simplemente restablecer las posiciones de las capas despu√©s de una cierta transici√≥n), pero nos salva de la necesidad de dividirnos. <br><br><h2>  Resultado </h2><br>  Despu√©s de <em>todo esto,</em> obtuve lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  Para un juego en Game Boy, esto es realmente genial.  Hasta donde yo s√©, no todos tienen el desplazamiento de paralaje implementado de esta manera. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436918/">https://habr.com/ru/post/es436918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436908/index.html">6 formas de ocultar datos en una aplicaci√≥n de Android</a></li>
<li><a href="../es436910/index.html">Consejos para crear flujos de trabajo personalizados en GitLab CI</a></li>
<li><a href="../es436912/index.html">Tendencias de CRM 2019: divertido de leer, peligroso de creer</a></li>
<li><a href="../es436914/index.html">Problemas de crecimiento de inicio - Monitoreo</a></li>
<li><a href="../es436916/index.html">VShard - escala horizontal en Tarantool</a></li>
<li><a href="../es436920/index.html">Transpilador PAS2JS de Pascal a JavaScript: incompatible con Delphi y soluciones alternativas</a></li>
<li><a href="../es436922/index.html">Optimizaci√≥n del tiempo de inicio de Prometheus 2.6.0 con pprof</a></li>
<li><a href="../es436924/index.html">Algunas palabras sobre la organizaci√≥n de competiciones de rob√≥tica</a></li>
<li><a href="../es436926/index.html">H√©roes de la autenticaci√≥n de dos factores, o c√≥mo "caminar en la piel de los dem√°s"</a></li>
<li><a href="../es436928/index.html">WebRTC: a√∫n m√°s f√°cil (EasyRTC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>