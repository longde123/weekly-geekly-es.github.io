<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔧 💜 🧙🏾 Ein weiteres DSL zur Validierung ⏯️ 💿 👂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe kürzlich ein kleines Juwel für Validierungen geschrieben und möchte Ihnen die Implementierung mitteilen. 


 Ideen, die bei der Erstellung de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiteres DSL zur Validierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479600/"><p>  Ich habe kürzlich ein kleines Juwel für Validierungen geschrieben und möchte Ihnen die Implementierung mitteilen. </p><br><p>  Ideen, die bei der Erstellung der Bibliothek verfolgt wurden: </p><br><ul><li>  Einfachheit </li><li>  Mangel an Magie </li><li>  Leicht zu erlernen </li><li>  Die Möglichkeit der Anpassung und ein Minimum an Einschränkungen. </li></ul><br><p>  Fast alle diese Punkte hängen mit der Einfachheit zusammen.  Die endgültige Implementierung ist unglaublich klein, daher nehme ich mir nicht viel Zeit für Sie. </p><br><p>  Den Quellcode finden Sie <a href="">hier</a> . </p><a name="habracut"></a><br><h1 id="arhitektura">  Architektur </h1><br><p>  Anstatt das übliche DSL mit Klassen- und Blockmethoden zu verwenden, habe ich beschlossen, die Daten zu verwenden. <br>  Anstelle des üblichen deklarativen Imperativs (haha, verstehen Sie, ja? "Deklarativen Imperativ") wandelt DSL, wie zum Beispiel in Dry, einfach einige Daten in einen Validator um.  Dies bedeutet auch, dass diese Bibliothek (theoretisch) in anderen dynamischen Sprachen (z. B. Python) implementiert werden kann, nicht unbedingt sogar objektorientiert. </p><br><p> Ich habe den letzten Absatz gelesen und verstanden, dass ich ein Durcheinander geschrieben habe.  Ich bitte um Entschuldigung.  Zuerst werde ich einige Definitionen geben und dann ein Beispiel geben. </p><br><h3 id="opredeleniya">  Definitionen </h3><br><p>  Die gesamte Bibliothek basiert auf drei einfachen Konzepten: <em>Validator</em> , Blueprint und <em>Transformation</em> . </p><br><ul><li>  Der Validator ist, wofür die Bibliothek ist.  Ein Objekt, das prüft, ob etwas unseren Anforderungen entspricht. </li><li>  Ein Schema besteht einfach aus beliebigen Daten, die andere Daten beschreiben (der Zweck unserer Validierung). </li><li> Eine Transformation ist eine Funktion <code>t(b, f)</code> , die eine Schaltung und das Objekt, das diese Funktion aufruft (Factory), aufnimmt und entweder eine andere Schaltung oder einen Validator zurückgibt. <br>  Übrigens ist das Wort "Umwandlung" in der Mathematik ein Synonym für das Wort "Funktion" (jedenfalls in dem Buch, das ich an der Universität gelesen habe). </li></ul><br><p>  Die Fabrik macht formal Folgendes: </p><br><ul><li>  Für eine Menge von Transformationen <code>T1, T2, ..., Tn</code> wird eine Zusammensetzung <code>Ta(Tb(Tc(...)))</code> (die Reihenfolge ist beliebig). </li><li>  Die resultierende Komposition wird zyklisch auf die Schaltung angewendet, bis das Ergebnis vom Argument abweicht. </li></ul><br><p>  Es erinnert mich an eine Turingmaschine.  Am Ausgang sollten wir einen Validator (oder eine anonyme Funktion) bekommen.  Alles andere bedeutet, dass das Schema und / oder die Transformationen falsch sind. </p><br><h3 id="primer">  Beispiel </h3><br><p>  Auf reddit gab ein Mann in Dry ein Beispiel: </p><br><pre> <code class="ruby hljs">user_schema = Dry::Schema.Params <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> required(<span class="hljs-symbol"><span class="hljs-symbol">:id</span></span>).value(<span class="hljs-symbol"><span class="hljs-symbol">:integer</span></span>) required(<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span>).value(<span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>) required(<span class="hljs-symbol"><span class="hljs-symbol">:age</span></span>).value(<span class="hljs-symbol"><span class="hljs-symbol">:integer</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">included_in?:</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">150</span></span>) required(<span class="hljs-symbol"><span class="hljs-symbol">:favourite_food</span></span>).value(array[<span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>]) required(<span class="hljs-symbol"><span class="hljs-symbol">:dog</span></span>).maybe <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> hash <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> required(<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span>).value(<span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>) required(<span class="hljs-symbol"><span class="hljs-symbol">:age</span></span>).value(<span class="hljs-symbol"><span class="hljs-symbol">:integer</span></span>) optional(<span class="hljs-symbol"><span class="hljs-symbol">:breed</span></span>).maybe(<span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> user_schema.call(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>, ...).success?</code> </pre> <br><p>  Wie Sie sehen, wird Magie in Form von <code>required(..).value</code> und Methoden wie <code>#array</code> . </p><br><p>  Vergleichen Sie mit meinem Beispiel: </p><br><pre> <code class="ruby hljs">is_valid_user = StValidation.build( <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> Integer, <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> String, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> -&gt;(x) { x.is_a?(Integer) &amp;&amp; (<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">150</span></span>).cover?(x) }, <span class="hljs-symbol"><span class="hljs-symbol">favourite_food:</span></span> [String], <span class="hljs-symbol"><span class="hljs-symbol">dog:</span></span> Set[NilClass, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> String, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> Integer, <span class="hljs-symbol"><span class="hljs-symbol">breed:</span></span> Set[NilClass, String] }] ) is_valid_user.call(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">'John'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>, ...)</code> </pre> <br><ol><li>  Ein Hash wird verwendet, um einen Hash zu beschreiben.  Werte werden zur Beschreibung von Werten verwendet (Klassen, Arrays, Mengen, anonyme Funktionen).  Keine magischen Methoden ( <code>#build</code> nicht berücksichtigt, da es sich nur um eine Abkürzung handelt). </li><li>  Der endgültige Validierungswert ist kein komplexes Objekt, sondern einfach wahr / falsch, worüber wir uns letztendlich Gedanken machen.  Dies ist kein Vorteil, sondern eine Vereinfachung. </li><li>  In Dry unterscheidet sich der externe Hash geringfügig vom internen.  Auf der externen Ebene wird die Methode <code>Schema.Params</code> und innerhalb von <code>#hash</code> . </li><li>  (Bonus) In meinem Fall muss das validierte Objekt kein Hash sein und es ist keine spezielle Syntax erforderlich: <code>is_int = StValidation.build(Integer)</code> . <br>  Jedes Element der Schaltung selbst ist eine Schaltung.  Ein Hash ist ein Beispiel für ein komplexes Schema (d. H. Ein Schema, das aus anderen Schemata besteht). </li></ol><br><h1 id="struktura">  Struktur </h1><br><p>  Das ganze Juwel besteht aus einer kleinen Anzahl von Teilen: </p><br><ul><li>  <code>StValidation</code> (Modul) <code>StValidation</code> </li><li>  Die Factory, die für die Generierung von Validatoren verantwortlich ist, ist <code>StValidation::ValidatorFactory</code> . </li><li>  Abstract Validator <code>StValidation::AbstractValidator</code> , eigentlich eine Schnittstelle. </li><li>  Die Gruppe der grundlegenden Validatoren, die ich in die grundlegende "Syntax" im Modul " <code>StValidation::Validators</code> </li><li>  Zwei Methoden des Hauptmoduls zur Vereinfachung und Kombination aller anderen Elemente: <br><ul><li>  <code>StValidation.build</code> - Verwenden eines Standardsatzes von Transformationen </li><li>  <code>StValidation.with_extra_transformations</code> - Verwenden einer Standardmenge von Transformationen, aber Erweitern. </li></ul></li></ul><br><h1 id="standartnyy-dsl">  Standard DSL </h1><br><p>  Ich habe die folgenden Elemente in mein eigenes DSL aufgenommen: </p><br><ul><li>  Klasse - Überprüft den Typ eines Objekts (z. B. Ganzzahl). <br>  Der einfachste Validator in meiner Syntax, abgesehen von der anonymen Funktion und den Nachkommen von AbstractValidator, den Grundelementen des Generators. </li><li>  Die Menge ist die Vereinigung von Schemata.  Beispiel: <code>Set[Integer, -&gt;(x) { x.nil? }]</code>  <code>Set[Integer, -&gt;(x) { x.nil? }]</code> . <br>  Überprüft, ob das Objekt mindestens einem der <em>Schemata entspricht</em> .  Sogar die Klasse selbst heißt <code>UnionValidator</code> . <br>  Das einfachste Beispiel ist ein zusammengesetzter Validator. </li><li>  Ein Array ist ein Beispiel: <code>[Integer]</code> . <br>  Überprüft, ob das Objekt ein Array ist und ob alle seine Elemente einem bestimmten <em>Schema entsprechen</em> . </li><li>  Ein Hash ist dasselbe, nur für Hashes.  Zusätzliche Schlüssel sind nicht erlaubt. </li></ul><br><p>  Die Transformationen sehen folgendermaßen aus: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_transformations</span></span></span><span class="hljs-function"> [ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bp, _factory)</span></span></span></span> { bp.is_a?(Class) ? class_validator(bp) : bp }, -&gt;(bp, factory) { bp.is_a?(Set) ? union_validator(bp, factory) : bp }, -&gt;(bp, factory) { bp.is_a?(Hash) ? hash_validator(bp, factory) : bp }, -&gt;(bp, factory) { bp.is_a?(Array) &amp;&amp; bp.size == <span class="hljs-number"><span class="hljs-number">1</span></span> ? array_validator(bp[<span class="hljs-number"><span class="hljs-number">0</span></span>], factory) : bp } ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_validator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(klass)</span></span></span></span> Validators::ClassValidator.new(klass) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union_validator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(blueprint, factory)</span></span></span></span> Validators::UnionValidator.new(blueprint, factory) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre> <br><p>  Nirgendwo ist es einfacher, oder? </p><br><h1 id="oshibki-i-explain">  Fehler und #erklären </h1><br><p>  Für mich persönlich besteht der Hauptzweck von Validierungen darin, zu überprüfen, ob ein Objekt gültig ist.  Warum es nicht gültig ist, ist eine Nebenfrage. <br>  Es ist jedoch hilfreich zu verstehen, warum etwas nicht gültig ist.  Zu diesem <code>#explain</code> ich der Validator-Schnittstelle die Methode <code>#explain</code> hinzugefügt. </p><br><p>  Im Wesentlichen sollte es dasselbe tun wie die Validierung, aber das zurückgeben, was speziell falsch ist. <br>  Im Allgemeinen kann die Validierung selbst ( <code>#call</code> ) als Sonderfall von <code>#explain</code> , indem nur überprüft wird, ob das <code>#explain</code> Ergebnis leer ist. </p><br><p>  Eine solche Validierung ist jedoch langsamer (dies ist jedoch nicht wichtig). </p><br><p>  Weil  Anonyme Prädikatfunktionen hüllen sich in den Nachkommen von <code>AbstractValidator</code> , haben auch die Methode <code>#explain</code> und geben einfach an, wo die Funktion definiert ist. </p><br><p>  Beim Schreiben von benutzerdefinierten Validatoren kann <code>#explain</code> beliebig komplex und intelligent sein. </p><br><h1 id="kastomizaciya">  Anpassung </h1><br><p>  Meine "Syntax" ist nicht in das Herz der Bibliothek integriert und daher nicht erforderlich.  (Siehe <code>StValidation.build</code> ). </p><br><p>  Versuchen wir es mit einer einfacheren DSL, die nur Zahlen, Zeichenfolgen und Arrays enthält: </p><br><pre> <code class="ruby hljs">validator_factory = StValidation::ValidatorFactory.new( [ -&gt; (blueprint, <span class="hljs-number"><span class="hljs-number">_</span></span>) { blueprint == <span class="hljs-symbol"><span class="hljs-symbol">:int</span></span> ? -&gt;(x) { x.is_a?(Integer) } : blueprint }, -&gt; (blueprint, <span class="hljs-number"><span class="hljs-number">_</span></span>) { blueprint == <span class="hljs-symbol"><span class="hljs-symbol">:str</span></span> ? -&gt;(x) { x.is_a?(String) } : blueprint }, lambda <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|blueprint, factory|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> blueprint <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> blueprint.is_a?(Array) inner_validators = blueprint.map { <span class="hljs-params"><span class="hljs-params">|b|</span></span> factory.build(b) } -&gt;(x) { x.is_a?(Array) &amp;&amp; inner_validators.zip(x).all? { <span class="hljs-params"><span class="hljs-params">|v, e|</span></span> v.call(e) } } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ] ) is_int = validator_factory.build(<span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>) is_int.call(<span class="hljs-string"><span class="hljs-string">'123'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ==&gt; false is_int_pair = validator_factory.build([:int, :int]) is_int_pair.call([1, 2]) # ==&gt; true is_int_pair.call([1, '2']) # ==&gt; false</span></span></code> </pre> <br><p>  Entschuldigen Sie den etwas verwirrenden Code.  Im Wesentlichen überprüft das Array in diesem Fall die Einhaltung des Index. </p><br><h1 id="itog">  Zusammenfassung </h1><br><p>  Aber nicht er.  Ich bin nur stolz auf diese technische Lösung und wollte sie demonstrieren :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479600/">https://habr.com/ru/post/de479600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479586/index.html">Der Efros Config Inspector bietet auch denjenigen Vorteile, die ihn nicht verwenden</a></li>
<li><a href="../de479588/index.html">Java Digest für den 10. Dezember</a></li>
<li><a href="../de479590/index.html">Top 10 App-Entwicklungsunternehmen im Jahr 2020</a></li>
<li><a href="../de479592/index.html">Wie erreichen Sie Ihre Ziele?</a></li>
<li><a href="../de479598/index.html">Katze und Hund füttern den Roboter</a></li>
<li><a href="../de479602/index.html">Was ist das vollständige Genom und warum wird es benötigt?</a></li>
<li><a href="../de479618/index.html">Postgres Pro Standard 12.1 veröffentlicht</a></li>
<li><a href="../de479620/index.html">Umgekehrte Logik</a></li>
<li><a href="../de479622/index.html">So funktioniert der Prototyp anonymer Transaktionen in der Waves-Blockchain</a></li>
<li><a href="../de479624/index.html">Postgres-Profi-Gendar Oleg Bartunov informiert Faride Roslovets über PostgreSQL und das Geschäft in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>