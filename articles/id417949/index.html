<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 ⛹🏽 🤘🏾 Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 4.2 🕺 🙅🏾 🚵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ringkasan bagian sebelumnya 
 Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 4.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417949/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Kami melanjutkan petualangan." width="300" height="350" align="left"><h3>  Ringkasan bagian sebelumnya </h3><br>  Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menulis implementasi sendiri dari pustaka C ++ 11 standar di atas pustaka C ++ 98 / C ++ 03 yang disertakan dengan kompiler. <br><br>  <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> diimplementasikan, dan juga, setelah mempertimbangkan semua definisi non-standar dan fitur kompiler, informasi muncul tentang fungsi yang didukung oleh kompiler saat ini.  Implementasinya sendiri dari <b>nullptr disertakan</b> , yang dipilih pada tahap kompilasi. <br><br>  Waktunya telah tiba untuk <b>type_traits</b> dan semua "keajaiban templat khusus" ini.  Pada bagian pertama, kami memeriksa implementasi templat sederhana dari pustaka standar, tetapi sekarang kami akan membahas lebih dalam. <br><br>  Tautan ke GitHub dengan hasil untuk hari ini untuk yang tidak sabar dan yang bukan pembaca: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komitmen dan kritik yang membangun dipersilahkan</a></b> </blockquote><br>  Kelanjutan pencelupan di dunia "templat ajaib" C ++. <br><a name="habracut"></a><br><h4>  Daftar isi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 1. Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 3. Menemukan implementasi nullptr yang sempurna</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1 Kita mulai dari yang kecil</a> <br>  .... <b>4.2 Tentang berapa banyak kesalahan ajaib yang dikompilasi oleh log untuk kita</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3 Pointer dan semuanya</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.4 Apa lagi yang diperlukan untuk pustaka templat</a> <br>  Bab 5 <br>  ... <br><br><h3>  Bab 4. Templat "sihir" C ++.  Lanjutan </h3><br><h4>  4.2 Tentang berapa banyak kesalahan ajaib yang dikompilasi oleh log </h4><br>  Di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> bab ini, templat <b>type_traits</b> dasar diperkenalkan, tetapi beberapa lagi tidak ada untuk set lengkap. <br><br>  Sebagai contoh, <i>templat is_integral</i> dan <i>is_floating_point benar</i> -benar diperlukan, yang sebenarnya sangat sepele didefinisikan - melalui spesialisasi templat untuk setiap jenis <i>bawaan</i> .  Pertanyaan di sini hanya muncul dengan tipe "besar" yang <b>panjang</b> .  Faktanya adalah bahwa tipe ini sebagai bawaan muncul dalam standar bahasa C ++ hanya dari versi 11.  Dan akan masuk akal untuk mengasumsikan bahwa semuanya datang untuk memeriksa versi standar C ++ (yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara unik sulit ditentukan</a> ), tetapi tidak ada di sana. <br><br><img src="https://habrastorage.org/webt/dx/16/xq/dx16xqz_rvfqcoffnocx80dae_w.jpeg" alt="gambar" width="320" height="190" align="left">  Karena, sejak 1999, standar bahasa C99 C ada di mana tipe <b>int panjang</b> dan tanpa tanda <b>lama</b> telah ada (sejak 1999!), Dan karena bahasa C ++ berusaha mempertahankan kompatibilitas dengan C murni, banyak kompiler (yang biasanya dicampur C / C ++) baru saja menambahkannya sebagai tipe fundamental bahkan sebelum standar C ++ 03 dirilis.  Artinya, situasinya adalah bahwa tipe bawaan sebenarnya (dari C), tetapi tidak dijelaskan dalam standar C ++ dan tidak boleh ada di sana.  Dan itu menambah sedikit kebingungan pada implementasi perpustakaan standar.  Tapi mari kita lihat kodenya: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;float&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;long double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> detail::_is_floating_point&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_cv&lt;_Tp&gt;::type&gt; { };</code> </pre> <br>  Semuanya jelas dengan kode di atas - kami mengkhususkan template untuk tipe floating-point yang diperlukan, dan, setelah "membersihkan" jenis pengubah, kami mengatakan "ya" atau "tidak" untuk jenis yang diteruskan kepada kami.  Baris berikutnya adalah tipe integer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;bool&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;wchar_t&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned short int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned long int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> LLONG_MAX template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; struct _is_integral_impl&lt;unsigned long long int&gt; : public true_type {}; #endif template&lt;&gt; struct _is_integral_impl&lt;signed char&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;short int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;long int&gt; : public true_type {}; #ifdef LLONG_MAX template&lt;&gt; struct _is_integral_impl&lt;long long int&gt; : public true_type {}; #endif template &lt;class _Tp&gt; struct _is_integral : public _is_integral_impl&lt;_Tp&gt; {}; template&lt;&gt; struct _is_integral&lt;char16_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;char32_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;int64_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;uint64_t&gt; : public true_type {}; } template &lt;class _Tp&gt; struct is_integral : public detail::_is_integral&lt;typename remove_cv&lt;_Tp&gt;::type&gt; { };</span></span></span></span></code> </pre><br>  Di sini Anda perlu berhenti sebentar dan berpikir.  Untuk tipe integer "lama" seperti <b>int</b> , <b>bool</b> , dll.  kami melakukan spesialisasi yang sama dengan <i>is_floating_point</i> .  Untuk tipe " <b>lama" int panjang panjang</b> dan pasangannya yang tidak ditandatangani, kami mendefinisikan kelebihan hanya jika ada <b>definisi</b> LLONG_MAX, yang didefinisikan dalam C ++ 11 (sebagai standar C ++ pertama yang kompatibel dengan C99), dan harus didefinisikan dalam file header <b>climits</b> sebagai maksimum sejumlah besar yang cocok dengan objek bertipe <b>long panjang int</b> .  <b>Climits</b> juga memiliki beberapa definisi makro (untuk jumlah sekecil mungkin dan setara yang tidak ditandatangani), tetapi saya memutuskan untuk menggunakan makro ini, yang tidak penting.  Yang penting adalah bahwa, tidak seperti dorongan, dalam implementasi ini tipe "besar" dari C tidak akan didefinisikan sebagai konstanta integer, meskipun mereka (mungkin) ada dalam kompiler.  Yang lebih penting adalah tipe <b>char16_t</b> dan <b>char32_t</b> , yang juga diperkenalkan di C ++ 11, tetapi mereka tidak dikirimkan di C99 (mereka muncul secara bersamaan dengan C ++ di standar C11), dan oleh karena itu, dalam standar lama, definisi mereka dapat hanya melalui alias tipe (misalnya <b>typedef</b> <i>short char16_t</i> , tetapi lebih lanjut tentang itu nanti).  Jika demikian, agar spesialisasi Templat untuk menangani situasi dengan benar ketika jenis ini terpisah (built-in) dan ketika mereka didefinisikan melalui <b>typedef</b> , diperlukan satu lapis <i>detail</i> spesialisasi templat lagi <i>:: _ is_integral</i> . <br><br><blockquote>  Fakta yang menarik adalah bahwa dalam beberapa kompiler lama, tipe "besar" C-pemalu ini tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstan secara integral</a> .  Apa yang dapat dipahami dan bahkan dimaafkan, karena jenis ini non-standar untuk C ++ hingga 11 standar, dan umumnya tidak boleh ada.  Tetapi yang sulit untuk dipahami adalah bahwa tipe-tipe ini dalam kompiler C ++ terbaru dari kreativitas Embarcadero (Embarcadero C ++ Builder), yang seharusnya didukung oleh C ++ 11, masih <b>merupakan konstanta yang</b> tidak <b>terpisahkan</b> dalam rakitan 32-bit mereka (seperti 20 tahun yang lalu) maka itu Borland masih benar).  Rupanya karena ini, termasuk, sebagian besar pustaka C ++ 11 standar tidak ada di majelis 32-bit ini (#include ratio? Chrono? Will cost).  Embarcadero tampaknya telah memutuskan untuk memaksa era 64-bit dengan moto: “Apakah Anda ingin C ++ 11 atau standar yang lebih baru?  Bangun program 64-bit (dan hanya bunyi, kompiler kami tidak bisa)! ” <br></blockquote><br>  Setelah menyelesaikan proses dengan jenis dasar bahasa, kami memperkenalkan beberapa pola yang lebih sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">Pola sederhana</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">detail</span></span></span><span class="hljs-class">:</span></span>:void_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">&lt;true, _Tp&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class">&lt;_Tp, _Tp&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type<span class="hljs-comment"><span class="hljs-comment">//specialization { }; template &lt;class _Tp&gt; struct is_const : public false_type { }; template &lt;class _Tp&gt; struct is_const&lt;const _Tp&gt; : public true_type { }; template &lt;class _Tp&gt; struct is_const&lt;const volatile _Tp&gt; : public true_type { }; /// is_volatile template&lt;class&gt; struct is_volatile : public false_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;volatile _Tp&gt; : public true_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;const volatile _Tp&gt; : public true_type { };</span></span></code> </pre><br></div></div><br>  Hanya fakta bahwa templat berspesialisasi untuk semua pengubah tipe ( <b>volatile</b> dan <b>const volatile</b> misalnya) yang perlu diperhatikan di sini, karena  beberapa kompiler cenderung “kehilangan” salah satu pengubah ketika memperluas templat. <br><br>  Secara terpisah, saya menyoroti implementasi <i>is_signed</i> dan <i>is_unsigned</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sign_unsign_chooser</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signed_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cat_base</span></span></span><span class="hljs-class"> :</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, Val&gt; { <span class="hljs-comment"><span class="hljs-comment">// base class for type predicates }; template&lt;&gt; struct _sign_unsign_chooser&lt;true&gt;//integral { template&lt;class _Tp&gt; struct _signed : public _cat_base&lt;_signed_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public _cat_base&lt;_unsigned_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; }; template&lt;&gt; struct _sign_unsign_chooser&lt;false&gt;//floating point { template&lt;class _Tp&gt; struct _signed : public is_floating_point&lt;_Tp&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public false_type { }; }; } template&lt;class T&gt; struct is_signed { // determine whether T is a signed type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _signed&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_signed::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; template&lt;class T&gt; struct is_unsigned { // determine whether T is an unsigned type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _unsigned&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_unsigned::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br>  Ketika menerapkan bagian ini, saya memasuki pertempuran yang tidak setara dengan Borland C ++ Builder 6.0, yang tidak ingin membuat dua templat ini pewaris dari <i>integral_constant</i> , yang akhirnya menghasilkan lusinan kesalahan kompiler internal yang “meniru” perilaku <i>integral_constant</i> untuk templat ini.  Di sini, mungkin bernilai lebih untuk melawan dan datang dengan apa yang alat penghapusan jenis <i>is_ * un * ditandatangani: integral_constant</i> melalui template, tapi saya ditunda sampai masalah tidak prioritas.  Yang menarik di bagian kode di atas adalah bagaimana pada waktu kompilasi ditentukan bahwa jenisnya tidak ditandatangani / ditandatangani.  Untuk memulainya, semua jenis non-integer <i>ditandai</i> dan bagi mereka templat pergi ke cabang khusus yang terpisah <i>_sign_unsign_chooser</i> dengan argumen templat <b>false</b> , yang pada gilirannya selalu mengembalikan <i>nilai ==</i> <b>false</b> untuk semua jenis kecuali tipe floating-point standar (mereka selalu masuk karena alasan yang jelas, jadi <i>_signed :: value</i> akan <b>benar</b> ).  Untuk tipe bilangan bulat, sederhana, namun menghibur, pemeriksaan dilakukan.  Di sini kita menggunakan fakta bahwa untuk tipe integer yang tidak ditandatangani, ketika angka menurun dan kemudian melewati minimum (0 jelas), terjadi overflow dan nomor memperoleh nilai maksimum yang mungkin. <br><br>  Fakta ini sudah diketahui, dan juga fakta bahwa untuk tipe yang ditandatangani melimpah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah perilaku yang tidak terdefinisi</a> dan Anda harus memperhatikannya (sesuai standar, Anda tidak dapat mengurangi variabel <b>int</b> kurang dari <b>INT_MIN</b> dan berharap bahwa sebagai hasil dari luapan Anda akan mendapatkan <b>INT_MAX</b> , bukan 42 atau hard disk yang diformat. ) <br><br>  Kami menulis <i>_Tp (-1) &lt;_Tp (0)</i> untuk memeriksa tipe "sign" menggunakan fakta ini, kemudian untuk tipe unsigned -1 "mentransformasikan" melalui overflow ke jumlah maksimum dari tipe ini, sementara untuk tipe yang ditandatangani perbandingan seperti itu akan dilakukan tanpa overflow, dan -1 akan dibandingkan dengan 0. <br><br>  Dan yang terakhir untuk hari ini, tetapi jauh dari "trik" terakhir di perpustakaan saya adalah penerapan <i>alignment_of</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_trick</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; _Tp t; _alignment_of_trick(); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A &lt; S ? A : S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;A, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;0, S&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> _MSC_VER &gt; 1400 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// // With MSVC both the build in __alignof operator // and following logic gets things wrong from time to time // Using a combination of the two seems to make the most of a bad job: // static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), __alignof(_Tp) &gt;::value); #else static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), sizeof(_Tp) &gt;::value); #endif typedef integral_constant&lt;std::size_t, std::size_t(_alignment_of_impl::value)&gt; type; private: typedef intern::type_traits_asserts check; typedef typename check::alignment_of_type_can_not_be_zero_assert&lt; _alignment_of_impl::value != 0 &gt;:: alignment_of_type_can_not_be_zero_assert_failed check1; // if you are there means aligment of type passed can not be calculated or compiler can not handle this situation (sorry, nothing can be done there) }; // borland compilers seem to be unable to handle long double correctly, so this will do the trick: struct _long_double_wrapper{ long double value; }; } template &lt;class _Tp&gt; struct alignment_of: public detail::_alignment_of_impl&lt;_Tp&gt;::type {}; template &lt;class _Tp&gt; struct alignment_of&lt;_Tp&amp;&gt;: public alignment_of&lt;_Tp*&gt; {}; template&lt;&gt; struct alignment_of&lt;long double&gt;: public alignment_of&lt;detail::_long_double_wrapper&gt; {};</span></span></span></span></code> </pre><br><blockquote>  Microsoft sekali lagi unggul di sini dengan Visual Studio mereka, yang bahkan memiliki built-in makro non-standar <b>built</b> -in makro, masih menghasilkan hasil yang salah ketika menggunakannya. <br><br><div class="spoiler">  <b class="spoiler_title">Penjelasan dari dorongan</b> <div class="spoiler_text">  Pengguna Visual C ++ harus mencatat bahwa MSVC memiliki beragam definisi "penyelarasan".  Sebagai contoh, pertimbangkan kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>; assert(boost::alignment_of&lt;<span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>&gt;::value % <span class="hljs-number"><span class="hljs-number">8</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a1; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a1 % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Dalam kode ini, meskipun boost :: alignment_of &lt;align_t&gt; melaporkan bahwa align_t memiliki perataan 8-byte, pernyataan akhir akan gagal untuk build 32-bit karena a1 tidak disejajarkan pada batas 8 byte.  Perhatikan bahwa jika kita menggunakan MSVC intrinsik __alignof di tempat boost :: alignment_of kita masih akan mendapatkan hasil yang sama.  Bahkan untuk persyaratan penyelarasan MSVC (dan janji) hanya benar-benar berlaku untuk penyimpanan dinamis, dan bukan tumpukan. <br></div></div><br></blockquote><br>  Biarkan saya mengingatkan Anda apa yang harus dilakukan <i>std :: alignment_of</i> template - mengembalikan nilai yang mewakili persyaratan untuk penempatan elemen jenis ini di memori.  Jika sedikit terganggu, unsur setiap jenis adalah apa yang lokasi memori, dan jika array adalah (hunian) terus menerus, maka, misalnya, kelas mungkin menjadi "lubang" antara unsur-unsur kelas anggota <b><b>(struct</b></b> kelas <b>sizeof</b> <i><b>{Char</b></i> <i>a;}</i> kemungkinan besar tidak akan sama dengan 1, meskipun ada 1 byte dari semua yang ada di dalamnya, karena kompiler akan menyelaraskannya ke 1 + 3 byte selama proses optimasi). <br><br>  Sekarang mari kita lihat kodenya lagi.  Kami mendeklarasikan struktur <i>_alignment_of_trick</i> , di mana kami menempatkan elemen tipe yang diperiksa dengan “indent” dalam memori 1 byte.  Dan periksa perataan dengan hanya mengurangi ukuran jenis yang diperiksa dari ukuran struktur yang dihasilkan.  Yaitu, jika kompiler memutuskan untuk "menempel" ruang kosong antara elemen dari tipe yang diperiksa dan karakter sebelumnya, maka kita mendapatkan nilai alignment tipe dalam struktur. <br><br>  Juga di sini pernyataan statis pertama kali ditemui sebagai tipe.  Mereka dinyatakan sebagai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> intern { <span class="hljs-comment"><span class="hljs-comment">// since we have no static_assert in pre-C++11 we just compile-time assert this way: struct type_traits_asserts { template&lt;bool&gt; struct make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct not_allowed_arithmetic_type_assert; template&lt;bool&gt; struct alignment_of_type_can_not_be_zero_assert; }; template&lt;&gt; struct type_traits_asserts::make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::not_allowed_arithmetic_type_assert&lt;true&gt; { typedef bool not_allowed_arithmetic_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::alignment_of_type_can_not_be_zero_assert&lt;true&gt; { typedef bool alignment_of_type_can_not_be_zero_assert_failed; }; }</span></span></code> </pre><br>  Bahkan, template khusus ini diperlukan untuk mengganti <b>static_assert</b> dari C ++ 11, yang terletak di dalam definisi kelas.  <b>Penegasan</b> seperti itu lebih ringan dan sangat terspesialisasi daripada penerapan <b>STATIC_ASSERT secara</b> umum dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab 2</a> , dan memungkinkan Anda untuk tidak menyeret file header <b>core.h</b> ke dalam <b>type_traits</b> . <br><br><img src="https://habrastorage.org/webt/ky/ra/ey/kyraeyyd384lkegmbcap1xfwday.jpeg" alt="gambar" width="330" height="200" align="left">  Banyak pola?  Akan ada lebih banyak!  Kita akan membahas hal ini untuk saat ini, karena kisah yang menarik tentang menggabungkan pemrograman template dengan teknologi SFINAE, serta mengapa saya harus menulis generator kode kecil, akan berlanjut. <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417949/">https://habr.com/ru/post/id417949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417939/index.html">Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 4 dan 5</a></li>
<li><a href="../id417941/index.html">Di mana air dalam ketel menghilang?</a></li>
<li><a href="../id417943/index.html">Serverless and React 2: Sleight of Hand dan No Fraud</a></li>
<li><a href="../id417945/index.html">Alat apa yang dimiliki probe surya Parker</a></li>
<li><a href="../id417947/index.html">Visualisasi data untuk proyek web Anda</a></li>
<li><a href="../id417951/index.html">Menulis Kode Java Ramah Kotlin</a></li>
<li><a href="../id417953/index.html">Tren dalam mendesain FPGA. Terjemahan</a></li>
<li><a href="../id417955/index.html">Bagaimana menjadi perancang antarmuka. Keterampilan yang diperlukan dan alat yang kuat yang tidak kita ketahui</a></li>
<li><a href="../id417957/index.html">Buka webinar Mekanisme Kontainer Linux</a></li>
<li><a href="../id417959/index.html">10 tips desain antarmuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>