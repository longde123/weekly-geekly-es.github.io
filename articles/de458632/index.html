<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚀 🍍 💅🏻 Wirklich tippen vue 🤦 🧒🏿 👉🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="inb4: Dies ist kein weiteres "Einrichten" eines neuen Projekts mit Vue- und TypeScript-Tutorial. Lassen Sie uns etwas tiefer in komplexere Themen eint...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wirklich tippen vue</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458632/"><p><img src="https://habrastorage.org/getpro/habr/post_images/a40/231/bed/a40231bed05774dd1df04164e93e8026.png" alt="Logo"></p><br><p>  inb4: Dies ist kein weiteres "Einrichten" eines neuen Projekts mit Vue- und TypeScript-Tutorial.  Lassen Sie uns etwas tiefer in komplexere Themen eintauchen! </p><br><p> <code>typescript</code> ist fantastisch.  <code>Vue</code> ist großartig.  Kein Zweifel, dass viele Leute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versuchen, sie zusammen zu bündeln</a> .  Aus verschiedenen Gründen ist es jedoch schwierig, Ihre <code>Vue</code> App <strong>wirklich</strong> <code>Vue</code> .  Lassen Sie uns herausfinden, was die Probleme sind und was getan werden kann, um sie zu lösen (oder zumindest die Auswirkungen zu minimieren). </p><a name="habracut"></a><br><h2 id="tldr">  TLDR </h2><br><p>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese wunderbare Vorlage</a> mit <code>Nuxt</code> , <code>Vue</code> , <code>Vuex</code> und <code>jest</code> vollständig getippt.  Installieren Sie es einfach und alles wird für Sie abgedeckt.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Dokumenten</a> . </p><br><p>  Und wie gesagt, ich werde Sie aus drei Gründen nicht durch die Grundeinstellungen führen: </p><br><ol><li>  Es gibt viele existierende Tutorials darüber </li><li>  Es gibt viele Tools, die Sie mit einem einzigen Klick <code>Nuxt</code> wie <code>Nuxt</code> und <code>vue-cli</code> mit <code>typescript</code> Plugin </li><li>  Wir haben bereits eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>wemake-vue-template</code></a> in der jedes Setup, über das ich sprechen werde, bereits behandelt wird </li></ol><br><h2 id="component-typings">  Komponententypen </h2><br><p>  Die erste gebrochene Erwartung, wenn Sie mit <code>Vue</code> und <code>typescript</code> und nachdem Sie Ihre Klassenkomponenten bereits eingegeben haben, ist, dass die Tags <code>&lt;template&gt;</code> und <code>&lt;style&gt;</code> immer noch nicht eingegeben werden.  Lassen Sie mich Ihnen ein Beispiel zeigen: </p><br><pre> <code class="plaintext hljs">&lt;template&gt; &lt;h1 :class="$style.headr"&gt; Hello, {{ usr }}! &lt;/h1&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import Vue from 'vue' import Component from 'vue-class-component' import { Prop } from 'vue-property-decorator' @Component({}) export default class HelloComponent extends Vue { @Prop() user!: string } &lt;/script&gt; &lt;style module&gt; .header { /* ... */ } &lt;/style&gt;</code> </pre> <br><p>  Ich habe hier zwei Tippfehler gemacht: <code>{{ usr }}</code> anstelle von <code>{{ user }}</code> und <code>$style.headr</code> anstelle von <code>$style.header</code> .  Wird mich <code>typescript</code> vor diesen Fehlern bewahren?  Nein, das wird es nicht. </p><br><p>  Was kann getan werden, um das Problem zu beheben?  Nun, es gibt mehrere Hacks. </p><br><h3 id="typing-the-template">  Vorlage eingeben </h3><br><p>  Sie können <code>Vetur</code> mit der Option <code>vetur.experimental.templateInterpolationService</code> , um Ihre Vorlagen zu überprüfen.  Ja, dies ist nur eine Editor-basierte Prüfung und kann noch nicht im CI verwendet werden.  Das <code>Vetur</code> Team arbeitet jedoch hart daran, eine CLI bereitzustellen, die dies ermöglicht.  Verfolgen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Originalausgabe,</a> falls Sie interessiert sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/139/fed/5f7/139fed5f76fa602b3e61b00696242fcb.png" alt="Vetur"></p><br><p>  Die zweite Option sind zwei Schreib-Snapshot-Tests mit <code>jest</code> .  Es werden viele vorlagenbasierte Fehler abgefangen.  Und es ist recht günstig in der Wartung. </p><br><p>  Die Kombination dieser beiden Tools bietet Ihnen eine schöne Entwicklererfahrung mit schnellem Feedback und einer zuverlässigen Möglichkeit, Fehler im CI zu erkennen. </p><br><h3 id="typing-styles">  Schreibstile </h3><br><p>  Die Eingabe von <code>css-module</code> wird auch von mehreren externen Tools abgedeckt: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typings-for-css-modules-loader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Module-Typoskript-Lader</a> </li></ul><br><p>  Die Hauptidee dieser Tools besteht darin, <code>.d.ts</code> <code>css-module</code> <code>.d.ts</code> und daraus <code>.d.ts</code> Deklarationsdateien zu erstellen.  Dann werden Ihre Stile vollständig eingegeben.  Es ist immer noch nicht für <code>Nuxt</code> oder <code>Vue</code> implementiert, aber Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Problem</a> auf Fortschritt <code>Nuxt</code> . </p><br><p>  Ich persönlich verwende jedoch keines dieser Tools in meinen Projekten.  Sie könnten für Projekte mit großen Codebasen und vielen Stilen nützlich sein, aber ich kann nur Schnappschüsse. </p><br><p>  Styleguides mit visuellen Regressionstests helfen ebenfalls sehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>@storybook/addon-storyshots</code></a> ist ein schönes Beispiel für diese Technik. </p><br><h2 id="vuex">  Vuex </h2><br><p>  Das nächste große Ding ist <code>Vuex</code> .  Es hat einige eingebaute Komplexität für die Eingabe: </p><br><pre> <code class="plaintext hljs">const result: Promise&lt;number&gt; = this.$store.dispatch('action_name', { payload: 1 })</code> </pre> <br><p>  Das Problem ist, dass <code>'action_name'</code> möglicherweise nicht vorhanden ist, andere Argumente <code>'action_name'</code> oder einen anderen Typ <code>'action_name'</code> .  Das erwarten Sie nicht für eine vollständig typisierte App. </p><br><p>  Was sind die vorhandenen Lösungen? </p><br><h3 id="vuex-class">  Vuex-Klasse </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>vuex-class</code></a> ist eine Reihe von Dekoratoren, die einen einfachen Zugriff Ihrer klassenbasierten Komponenten auf die <code>Vuex</code> Interna ermöglichen. </p><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist jedoch nicht sicher geschrieben,</a> da es die Zustandsarten, Getter, Mutationen und Aktionen nicht beeinträchtigen kann. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9c5/4d7/6c4/9c54d76c4b105c9f58fe5d2e21dedd00.png" alt="Vuex-Klasse"></p><br><p>  Natürlich können Sie Arten von Eigenschaften manuell mit Anmerkungen versehen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/817/54b/472/81754b4724279ffbd0b0d4b38a0f289c.png" alt="Vuex-Klasse kommentiert"></p><br><p>  Aber was werden Sie tun, wenn sich die tatsächliche Art Ihres Zustands, Ihrer Getter, Mutationen oder Aktionen ändert?  Sie haben eine versteckte Typinkongruenz. </p><br><h3 id="vuex-simple">  vuex-einfach </h3><br><p>  <code>vuex-simple</code> hilft uns <code>vuex-simple</code> .  Es bietet tatsächlich eine völlig andere Möglichkeit, Ihren <code>Vuex</code> Code zu schreiben, und das macht ihn typsicher.  Werfen wir einen Blick darauf: </p><br><pre> <code class="plaintext hljs">import { Action, Mutation, State, Getter } from 'vuex-simple' class MyStore { // State @State() public comments: CommentType[] = [] // Getters @Getter() public get hasComments (): boolean { return Boolean(this.comments &amp;&amp; this.comments.length &gt; 0) } // Mutations @Mutation() public setComments (payload: CommentType[]): void { this.comments = updatedComments } // Actions @Action() public async fetchComments (): Promise&lt;CommentType[]&gt; { // Calling some API: const commentsList = await api.fetchComments() this.setComments(commentsList) // typed mutation return commentsList } }</code> </pre><br><p>  Später kann dieses typisierte Modul wie <code>Vuex</code> in Ihrem <code>Vuex</code> registriert werden: </p><br><pre> <code class="plaintext hljs">import Vue from 'vue' import Vuex from 'vuex' import { createVuexStore } from 'vuex-simple' import { MyStore } from './store' Vue.use(Vuex) // Creates our typed module instance: const instance = new MyStore() // Returns valid Vuex.Store instance: export default createVuexStore(instance)</code> </pre> <br><p>  Jetzt haben wir eine 100% native <code>Vuex.Store</code> Instanz und alle darin enthaltenen <code>Vuex.Store</code> .  Um diesen typisierten Speicher in der Komponente zu verwenden, können wir nur eine Codezeile schreiben: </p><br><pre> <code class="plaintext hljs">import Vue from 'vue' import Component from 'nuxt-class-component' import { useStore } from 'vuex-simple' import MyStore from './store' @Component({}) export default class MyComponent extends Vue { // That's all we need! typedStore: MyStore = useStore(this.$store) // Demo: will be typed as `Comment[]`: comments = typedStore.comments }</code> </pre> <br><p>  Jetzt haben wir <code>Vuex</code> eingegeben, das sicher in unserem Projekt verwendet werden kann. <br>  Wenn wir etwas in unserer Geschäftsdefinition ändern, wird es automatisch auf die Komponenten übertragen, die dieses Geschäft verwenden.  Wenn etwas ausfällt, wissen wir es so schnell wie möglich. </p><br><p>  Es gibt auch verschiedene Bibliotheken, die dasselbe tun, aber unterschiedliche APIs haben.  Wählen Sie, was am besten zu Ihnen passt. </p><br><h2 id="api-calls">  API-Aufrufe </h2><br><p>  Wenn wir <code>Vuex</code> richtig eingerichtet haben, müssen wir es mit Daten füllen. <br>  Schauen wir uns noch einmal unsere Aktionsdefinition an: </p><br><pre> <code class="plaintext hljs">@Action() public async fetchComments (): Promise&lt;CommentType[]&gt; { // Calling some API: const commentsList = await api.fetchComments() // ... return commentsList }</code> </pre> <br><p>  Wie können wir wissen, dass es wirklich eine Liste von <code>CommentType</code> und nicht eine einzelne <code>number</code> oder eine Reihe von <code>AuthorType</code> Instanzen <code>AuthorType</code> ? </p><br><p>  Wir können den Server nicht steuern.  Und der Server könnte tatsächlich den Vertrag brechen.  Oder wir können einfach die falsche <code>api</code> Instanz übergeben, einen Tippfehler in der URL machen oder was auch immer. </p><br><p>  Wie können wir sicher sein?  Wir können die Laufzeit eingeben!  Lassen Sie mich Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>io-ts</code></a> vorstellen: </p><br><pre> <code class="plaintext hljs">import * as ts from 'io-ts' export const Comment = ts.type({ 'id': ts.number, 'body': ts.string, 'email': ts.string, }) // Static TypeScript type, that can be used as a regular `type`: export type CommentType = ts.TypeOf&lt;typeof Comment&gt;</code> </pre> <br><p>  Was machen wir hier? </p><br><ol><li>  Wir definieren eine Instanz von <code>ts.type</code> mit Feldern, die zur Laufzeit überprüft werden müssen, wenn wir eine Antwort vom Server erhalten </li><li>  Wir definieren einen statischen Typ, der für Anmerkungen ohne zusätzliche Boilerplate verwendet werden soll </li></ol><br><p>  Und später können wir es unsere <code>api</code> Aufrufe verwenden: </p><br><pre> <code class="plaintext hljs">import * as ts from 'io-ts' import * as tPromise from 'io-ts-promise' public async fetchComments (): Promise&lt;CommentType[]&gt; { const response = await axios.get('comments') return tPromise.decode(ts.array(Comment), response.data) }</code> </pre> <br><p>  Mit Hilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>io-ts-promise</code></a> können wir ein <code>Promise</code> in einem fehlgeschlagenen Zustand zurückgeben, wenn die Antwort vom Server nicht mit einem <code>ts.array(Comment)</code> Typ <code>ts.array(Comment)</code> .  Es funktioniert wirklich wie eine Validierung. </p><br><pre> <code class="plaintext hljs">fetchComments() .then((data) =&gt; /* ... */ .catch(/* Happens with both request failure and incorrect response type */)</code> </pre> <br><p>  Darüber hinaus ist die Annotation vom Rückgabetyp mit der <code>.decode</code> Methode <code>.decode</code> .  Und Sie können dort keinen zufälligen Unsinn machen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5f1/010/a62/5f1010a62b6226e93fa115828e8bc838.png" alt="io-ts"></p><br><p>  Durch die Kombination von Laufzeit- und statischen Überprüfungen können wir sicher sein, dass unsere Anforderungen nicht aufgrund der Typinkongruenz fehlschlagen. <br>  Um jedoch zu 100% sicher zu sein, dass alles funktioniert, würde ich die Verwendung vertragsbasierter Tests empfehlen: Schauen Sie sich als Beispiel den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>pact</code></a> an.  Und überwachen Sie Ihre App mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Sentry</code></a> . </p><br><h2 id="vue-router">  Vue Router </h2><br><p>  Das nächste Problem ist, dass <code>this.$router.push({ name: 'wrong!' })</code> Funktioniert nicht so, wie wir es wollen. </p><br><p>  Ich würde sagen, dass es ideal wäre, vom Compiler gewarnt zu werden, dass wir in die falsche Richtung routen und diese Route nicht existiert. <br>  Das ist aber nicht möglich.  Und es kann nicht viel getan werden: Es gibt viele dynamische Routen, Regex, Fallbacks, Berechtigungen usw., die irgendwann brechen können.  Die einzige Möglichkeit besteht darin, dies jeweils zu testen <code>this.$router</code> Aufruf in Ihrer App. </p><br><h2 id="vue-test-utils">  vue-test-utils </h2><br><p>  Apropos Tests Ich habe keine Ausreden, ganz zu schweigen von <code>@vue/test-utils</code> , die auch Probleme beim Tippen haben. </p><br><p>  Wenn wir versuchen, unsere neue glänzende Komponente mit der <code>typedStore</code> Eigenschaft zu testen, werden wir feststellen, dass wir dies gemäß dem <code>typescript</code> nicht tun können: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa4/826/3a5/aa48263a5f9a278f2e9a0d5220fc75f0.png" alt="vue-test-utils"></p><br><p>  Warum passiert das?  Dies liegt daran <code>mount()</code> Aufruf von <code>mount()</code> nichts über den Typ Ihrer Komponente weiß, da alle Komponenten standardmäßig den Typ <code>VueConstructor&lt;Vue&gt;</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a0/cb5/ad5/2a0cb5ad5afb75d3ad811faf1a209cd4.png" alt="Vue-Konstruktor"></p><br><p>  Hierher kommen alle Probleme.  Was kann getan werden? <br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>vuetype</code></a> , um <code>YouComponent.vue.d.ts</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>vuetype</code></a> zu erstellen, die Ihren Tests den genauen Typ der <code>YouComponent.vue.d.ts</code> Komponente mitteilen. </p><br><p>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Problem auch</a> für den Fortschritt verfolgen. </p><br><p>  Aber ich mag diese Idee nicht.  Dies sind Tests, sie können fehlschlagen.  Keine große Sache. <br>  Deshalb <code>(wrapper.vm as any).whatever</code> ich mich an <code>(wrapper.vm as any).whatever</code> .  Das spart mir viel Zeit, um Tests zu schreiben.  Aber verdirbt Developer Experience ein wenig. </p><br><p>  Treffen Sie hier Ihre eigene Entscheidung: </p><br><ul><li>  Verwenden <code>vuetype</code> gesamten <code>vuetype</code> </li><li>  Wenden Sie es teilweise auf die wichtigsten Komponenten mit der größten Anzahl von Tests an und aktualisieren Sie es regelmäßig </li><li>  Verwenden Sie <code>any</code> als Fallback </li></ul><br><h2 id="conclusion">  Fazit </h2><br><p>  Die durchschnittliche Unterstützung für <code>typescript</code> im <code>Vue</code> Ökosystem hat in den letzten Jahren zugenommen: </p><br><ul><li>  <code>Nuxt</code> zuerst <code>nuxt-ts</code> eingeführt und <code>nuxt-ts</code> nun standardmäßig <code>ts</code> Builds aus </li><li>  <code>Vue@3</code> bietet eine verbesserte <code>typescript</code> Unterstützung </li><li>  Weitere Apps und Plugins von Drittanbietern bieten Typdefinitionen </li></ul><br><p>  Aber es ist im Moment produktionsbereit.  Dies sind nur Dinge, die verbessert werden müssen!  Das Schreiben von typsicherem <code>Vue</code> Code verbessert Ihre Entwicklererfahrung erheblich und ermöglicht es Ihnen, sich auf die wichtigen Dinge zu konzentrieren, während Sie das schwere Heben dem Compiler überlassen. </p><br><p>  Was sind Ihre bevorzugten Hacks und Tools zum Eingeben von <code>Vue</code> Apps?  Lassen Sie es uns im Kommentarbereich diskutieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458632/">https://habr.com/ru/post/de458632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458614/index.html">Erstellen eines Reactive UsePosition () - Hooks zum Abrufen und Verfolgen von Browserkoordinaten</a></li>
<li><a href="../de458622/index.html">Automatisierung für die Kleinsten. Teil eins (der nach Null liegt). Netzwerkvirtualisierung</a></li>
<li><a href="../de458624/index.html">Wie wir gelernt haben, Texte auf Leinwand zu zeichnen</a></li>
<li><a href="../de458626/index.html">StealthWatch: Grundkonzepte und Mindestanforderungen. Teil 1</a></li>
<li><a href="../de458630/index.html">Eine kleine Geschichte der Entwicklung Ihres Spiels auf reinem Windows Forms + C # in meinen 16 Jahren</a></li>
<li><a href="../de458634/index.html">"Sei nicht böse" oder was Facebook vor uns verbirgt</a></li>
<li><a href="../de458636/index.html">Videobänder von mitap DevLeads aus dem Büro von Tutu.ru.</a></li>
<li><a href="../de458638/index.html">Intel oneAPI Project: viele Architekturen, eine API</a></li>
<li><a href="../de458640/index.html">Einen langen Strich finden</a></li>
<li><a href="../de458642/index.html">Theorie statt Heuristik: Als Frontend-Entwickler besser werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>