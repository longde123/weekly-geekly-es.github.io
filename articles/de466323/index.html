<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶‚Äçüë¶ üë®üèø‚Äç‚öïÔ∏è üë≤ Wir erstellen ein tragbares Plattformspiel auf dem Cortex M0 + Mikrocontroller üòÜ üñêüèæ ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 (Links zum Quellcode und zum KiCAD-Projekt finden Sie am Ende des Artikels.) 

 Obwohl wir in der 8-Bit-√Ñra geboren wurden, war unser ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir erstellen ein tragbares Plattformspiel auf dem Cortex M0 + Mikrocontroller</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br><h2>  Einf√ºhrung </h2><br>  <em>(Links zum Quellcode und zum KiCAD-Projekt finden Sie am Ende des Artikels.)</em> <br><br>  Obwohl wir in der 8-Bit-√Ñra geboren wurden, war unser erster Computer der Amiga 500. Dies ist eine gro√üartige 16-Bit-Maschine mit erstaunlicher Grafik und Sound, die sich hervorragend f√ºr Spiele eignet.  Platforming ist auf diesem Computer zu einem sehr beliebten Spielgenre geworden.  Viele von ihnen waren sehr farbenfroh und hatten ein sehr sanftes Parallaxen-Scrollen.  M√∂glich wurde dies durch talentierte Programmierer, die genial Amiga-Coprozessoren verwendeten, um die Anzahl der Bildschirmfarben zu erh√∂hen.  Schauen Sie sich zum Beispiel LionHeart an! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>  <i>L√∂wenherz auf Amiga.</i>  <i>Dieses statische Bild vermittelt nicht die Sch√∂nheit der Grafiken.</i> <br><br>  Seit den 90er Jahren hat sich die Elektronik stark ver√§ndert, und jetzt gibt es viele kleine Mikrocontroller, mit denen Sie erstaunliche Dinge erstellen k√∂nnen. <br><br>  Wir haben Plattformspiele schon immer geliebt, und heute k√∂nnen Sie f√ºr nur ein paar Dollar Raspberry Zero kaufen, Linux installieren und ‚Äûziemlich einfach‚Äú einen farbenfrohen Plattformer schreiben. <br><br>  Aber diese Aufgabe ist nichts f√ºr uns - wir wollen keine Spatzen aus einer Kanone schie√üen! <br><br>  Wir wollen Mikrocontroller mit begrenztem Speicher verwenden und kein leistungsf√§higes System auf einem Chip mit integrierter GPU!  Mit anderen Worten, wir wollen Schwierigkeiten! <br><a name="habracut"></a><br>  √úbrigens zu den M√∂glichkeiten des Videos: Einige Leute schaffen es, in ihren Projekten alle S√§fte aus dem AVR-Mikrocontroller herauszupressen (zum Beispiel im Uzebox- oder Craft-Projekt des lft-Entwicklers).  Um dies zu erreichen, zwingen uns die AVR-Mikrocontroller, in Assembler zu schreiben, und obwohl einige Spiele sehr gut sind, werden Sie auf schwerwiegende Einschr√§nkungen sto√üen, die es Ihnen nicht erlauben, ein Spiel im 16-Bit-Stil zu erstellen. <br><br>  Aus diesem Grund haben wir uns f√ºr einen ausgewogeneren Mikrocontroller / eine ausgewogenere Karte entschieden, mit der wir Code vollst√§ndig in C schreiben k√∂nnen. <br><br>  Er ist nicht so m√§chtig wie Arduino Due, aber nicht so schwach wie Arduino Uno.  Interessanterweise bedeutet "F√§llig" "zwei" und "Uno" "eins".  Microsoft hat uns beigebracht, richtig zu z√§hlen (1, 2, 3, 95, 98, ME, 2000, XP, Vista, 7, 8, 10), und Arduino ist auch diesen Weg gegangen!  Wir werden den Arduino Zero verwenden, der in der Mitte zwischen 1 und 2 liegt! <br><br>  Ja, laut Arduino 1 &lt;0 &lt;2. <br><br>  Insbesondere interessieren wir uns nicht f√ºr das Board selbst, sondern f√ºr seine Prozessorserie.  Der Arduino Zero verf√ºgt √ºber einen Mikrocontroller der ATSAMD21-Serie mit Cortex M0 + (48 MHz), 256 KB Flash-Speicher und 32 KB RAM. <br><br>  Obwohl der 48-MHz-Cortex M0 + den alten 7-MHz-MC68000 in seiner Leistung deutlich √ºbertrifft, verf√ºgte der Amiga 500 √ºber 512 KB RAM, Hardware-Sprites, ein integriertes Dual-Game-Board und Blitter (eine DMA-basierte Bildblock√ºbertragungs-Engine mit einem integrierten pixelgenauen Kollisionserkennungssystem). und Transparenz) und Kupfer (ein Raster-Coprozessor, mit dem Sie Operationen mit Registern basierend auf der Sweep-Position ausf√ºhren k√∂nnen, um viele sehr sch√∂ne Effekte zu erzielen).  SAMD21 verf√ºgt nicht √ºber all diese Hardware (mit Ausnahme einer im Vergleich zu Blitter DMA recht einfachen), daher wird viel programmgesteuert gerendert. <br><br>  Wir wollen folgende Parameter erreichen: <br><br><ul><li>  Aufl√∂sung 160 x 128 Pixel auf einem 1,8-Zoll-SPI-Display. </li><li>  Grafiken mit 16 Bit pro Pixel; </li><li>  Die h√∂chste Bildrate.  Mindestens 25 fps bei 12 MHz SPI oder 40 fps bei 24 MHz; </li><li>  doppeltes Spielfeld mit Parallaxen-Scrolling; </li><li>  alles ist in C geschrieben. Kein Assembler-Code; </li><li>  Pixelgenaue Erkennung von Kollisionen; </li><li>  Bildschirm√ºberlagerung. </li></ul><br>  Es scheint ziemlich schwierig zu sein, diese Ziele zu erreichen.  Es ist, besonders wenn wir den Code auf asm ablehnen! <br><br>  Bei 16-Bit-Farben erfordert eine Bildschirmgr√∂√üe von 160 √ó 128 Pixel beispielsweise 40 KB f√ºr den Bildschirmpuffer, aber wir haben nur 32 KB RAM!  Und wir brauchen immer noch Parallaxen-Scrollen auf einem doppelten Spielfeld und vielem mehr mit einer Frequenz von mindestens 25/40 fps! <br><br>  Aber nichts ist f√ºr uns unm√∂glich, oder? <br><br>  Wir verwenden Tricks und integrierte Funktionen von ATSAMD21!  Als "Hardware" nehmen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uChip</a> , das im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Itaca Store erh√§ltlich ist</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>  <i>uChip: das Herzst√ºck unseres Projekts!</i> <br><br>  Es hat die gleichen Eigenschaften wie das Arduino Zero, ist aber viel kleiner und auch billiger als das urspr√ºngliche Arduino Zero (ja, Sie k√∂nnen ein gef√§lschtes Arduino Zero f√ºr 10 USD bei AliExpress kaufen ... aber wir m√∂chten auf dem Original aufbauen).  Auf diese Weise k√∂nnen wir eine kleine tragbare Konsole erstellen.  Sie k√∂nnen dieses Projekt fast m√ºhelos f√ºr Arduino Zero anpassen, nur das Ergebnis ist ziemlich umst√§ndlich. <br><br>  Wir haben auch ein kleines Testboard erstellt, das eine tragbare Konsole f√ºr die Armen implementiert.  Details unten! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br>  Wir werden das Arduino-Framework nicht verwenden.  Es ist nicht gut geeignet, um Ger√§te zu optimieren und zu verwalten.  (Und reden wir nicht √ºber die IDE!) <br><br>  In diesem Artikel werden wir beschreiben, wie wir zur endg√ºltigen Version des Spiels gekommen sind, und alle verwendeten Optimierungen und Kriterien beschreiben.  Das Spiel selbst ist noch nicht vollst√§ndig, es fehlen Sound, Level usw.  Es kann jedoch als Ausgangspunkt f√ºr viele verschiedene Arten von Spielen verwendet werden! <br><br>  Dar√ºber hinaus gibt es auch ohne Assembler noch viele weitere Optimierungsm√∂glichkeiten! <br><br>  Also, lasst uns unsere Reise beginnen! <br><br><h2>  Schwierigkeiten </h2><br>  Tats√§chlich hat das Projekt zwei komplexe Aspekte: Timings und Speicher (sowohl RAM als auch Speicher). <br><br><h3>  Die Erinnerung </h3><br>  Beginnen wir mit der Erinnerung.  Anstatt ein gro√ües Bild zu speichern, verwenden wir zun√§chst Kacheln.  Wenn Sie die meisten Plattformer sorgf√§ltig analysieren, werden Sie feststellen, dass sie aus einer kleinen Anzahl grafischer Elemente (Kacheln) erstellt werden, die viele Male wiederholt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>  <i>Turrican 2 auf Amiga.</i>  <i>Eines der besten Plattformspiele aller Zeiten.</i>  <i>Sie k√∂nnen die Kacheln darin leicht sehen!</i> <br><br>  Die Welt / Ebene scheint dank verschiedener Kombinationen von Kacheln vielf√§ltig.  Dies spart viel Speicher auf dem Laufwerk, l√∂st jedoch nicht das Problem eines gro√üen Bildpuffers. <br><br>  Der zweite Trick, den wir verwenden, ist aufgrund der relativ gro√üen Rechenleistung von uC und des Vorhandenseins von DMA m√∂glich!  Anstatt alle Rahmendaten im RAM zu speichern (und warum wird dies ben√∂tigt?), Erstellen wir in jedem Bild eine Szene von Grund auf neu.  Insbesondere werden wir weiterhin Puffer verwenden, die jedoch so in einen horizontalen Block von Datengrafiken mit einer H√∂he von 16 Pixeln passen. <br><br><h3>  Timings - CPU </h3><br>  Wenn ein Ingenieur etwas erstellen muss, pr√ºft er zun√§chst, ob dies m√∂glich ist.  Nat√ºrlich haben wir diesen Test gleich zu Beginn durchgef√ºhrt! <br><br>  Wir ben√∂tigen also mindestens 25 fps auf einem Bildschirm mit 160 √ó 128 Pixel.  Das sind 512.000 Pixel / s.  Da der Mikrocontroller mit einer Frequenz von 48 MHz arbeitet, haben wir mindestens 93 Taktzyklen pro Pixel.  Dieser Wert sinkt auf 58 Zyklen, wenn wir 40 fps anstreben. <br><br>  Tats√§chlich kann unser Mikrocontroller bis zu 2 Pixel gleichzeitig verarbeiten, da jedes Pixel 16 Bit ben√∂tigt und der ATSAMD21 √ºber einen internen 32-Bit-Bus verf√ºgt, dh die Leistung ist noch besser! <br><br>  Ein Wert von 93 Taktzyklen sagt uns, dass die Aufgabe vollst√§ndig machbar ist!  Tats√§chlich k√∂nnen wir daraus schlie√üen, dass die CPU allein alle Rendering-Aufgaben ohne DMA ausf√ºhren kann.  Dies trifft h√∂chstwahrscheinlich zu, insbesondere wenn Sie mit Assembler arbeiten.  Der Code wird jedoch sehr schwer zu handhaben sein.  Und in C muss es sehr optimiert werden!  Tats√§chlich ist Cortex M0 + nicht so C-freundlich wie Cortex M3 und es fehlen viele Anweisungen (es wird nicht einmal mit nachfolgenden / Vorinkrementen / Dekrementen geladen / gespeichert!), Die mit zwei oder mehr einfachen Anweisungen implementiert werden m√ºssen. <br><br>  Mal sehen, was wir tun m√ºssen, um zwei Spielfelder zu zeichnen (vorausgesetzt, wir kennen bereits die x- und y-Koordinaten usw.). <br><br><ul><li>  Berechnen Sie die Position des Vordergrundpixels im Flash-Speicher. </li><li>  Holen Sie sich den Pixelwert. </li><li>  Wenn es transparent ist, berechnen Sie die Position des Hintergrundpixels im Blitz. </li><li>  Holen Sie sich den Pixelwert. </li><li>  Berechnen Sie den Zielort. </li><li>  Pixel im Puffer speichern. </li></ul><br>  Dar√ºber hinaus sollten f√ºr jedes Sprite, das in den Puffer gelangen kann, die folgenden Operationen ausgef√ºhrt werden: <br><br><ul><li>  Berechnen Sie die Position eines Sprite-Pixels im Flash-Speicher. </li><li>  Abrufen des Pixelwerts. </li><li>  Wenn es nicht transparent ist, berechnen Sie den Speicherort des Zielpuffers. </li><li>  Speichern eines Pixels im Puffer. </li></ul><br>  Alle diese Operationen werden nicht nur nicht als einzelner ASM-Befehl implementiert, sondern jeder ASM-Befehl erfordert zwei Zyklen beim Zugriff auf RAM / Flash-Speicher. <br><br>  Dar√ºber hinaus verf√ºgen wir noch nicht √ºber eine Gameplay-Logik (die gl√ºcklicherweise etwas Zeit in Anspruch nimmt, da sie einmal pro Frame berechnet wird), Kollisionserkennung, Pufferverarbeitung und Anweisungen, die zum Senden von Daten √ºber SPI erforderlich sind. <br><br>  Hier ist zum Beispiel der Pseudocode dessen, was wir tun m√ºssen (im Moment gehen wir davon aus, dass das Spiel nicht gescrollt wird und das Spielfeld einen konstanten Farbhintergrund hat!) Nur f√ºr den Vordergrund. <br><br>  Lassen Sie cameraY und cameraX die Koordinaten der oberen linken Ecke des Displays in der Spielwelt sein. <br><br>  XTilepos und yTilepos seien die Position der aktuellen Kachel auf der Karte. <br><br><pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is a rightward shift of 4 bits. yTilepos = cameraY / 16; destBufferAddress = &amp;buffer[0][0]; for tile = 0...9 nTile = gameMap[yTilepos][xTilepos]; tileDataAddress = &amp;tileData[nTile]; xTilepos = xTilepos + 1; for y = 0‚Ä¶15 for x = 0‚Ä¶15 pixel = *tileDataAddress; tileDataAddress = tileDataAddress + 1; *destBufferAddress = pixel; destBufferAddress = destBufferAddress + 1; next destBufferAddress = destBufferAddress + 144; // point to next row next destBufferAddress = destBufferAddress ‚Äì ( 160 * 16 - 16); // now point to the position where the next tile will be saved. next</span></span></code> </pre> <br>  Die Anzahl von Befehlen f√ºr 2560 Pixel (160 √ó 16) betr√§gt ungef√§hr 16 KB, d.h.  6 pro Pixel.  Tats√§chlich k√∂nnen Sie zwei Pixel gleichzeitig zeichnen.  Dies halbiert die tats√§chliche Anzahl von Befehlen pro Pixel, dh die Anzahl von Befehlen auf hoher Ebene pro Pixel betr√§gt ungef√§hr 3. Einige dieser Befehle auf hoher Ebene werden jedoch entweder in zwei oder mehr Assembler-Befehle unterteilt oder erfordern mindestens zwei Zyklen, um abgeschlossen zu werden, da sie zugreifen in die Erinnerung.  Au√üerdem haben wir nicht in Betracht gezogen, die CPU-Pipeline aufgrund von Spr√ºngen und Wartezust√§nden f√ºr den Flash-Speicher zur√ºckzusetzen.  Ja, wir sind noch weit von den 58-93 Zyklen entfernt, aber wir m√ºssen immer noch den Hintergrund des Spielfelds und der Sprites ber√ºcksichtigen. <br><br>  Obwohl wir sehen, dass das Problem auf einer CPU gel√∂st werden kann, wird DMA viel schneller sein.  Der direkte Speicherzugriff l√§sst noch mehr Platz f√ºr Bildschirm-Sprites oder bessere Grafikeffekte (zum Beispiel k√∂nnen wir Alpha-Blending implementieren). <br><br>  Wir werden sehen, dass wir zum Konfigurieren des DMA f√ºr jede Kachel weniger als 100 C-Anweisungen ben√∂tigen, d. H. Weniger als 0,5 pro Pixel!  Nat√ºrlich muss DMA immer noch die gleiche Anzahl von √úbertragungen im Speicher ausf√ºhren, aber das Adressinkrement und die √úbertragung werden ohne Eingreifen der CPU ausgef√ºhrt, die etwas anderes tun kann (z. B. Berechnen und Rendern von Sprites). <br><br>  Unter Verwendung des SysTick-Timers haben wir herausgefunden, dass die Zeit, die erforderlich ist, um den DMA f√ºr den gesamten Block vorzubereiten und dann den DMA abzuschlie√üen, ungef√§hr 12.000 Taktzyklen betr√§gt.  Hinweis: Taktzyklen!  Keine hochrangigen Anweisungen!  Die Anzahl von Zyklen ist f√ºr nur 2560 Pixel ziemlich hoch, d.h.  1.280 32-Bit-W√∂rter.  Tats√§chlich erhalten wir ungef√§hr 10 Zyklen pro 32-Bit-Wort.  Sie m√ºssen jedoch die Zeit ber√ºcksichtigen, die zur Vorbereitung des DMA erforderlich ist, sowie die Zeit, die der DMA ben√∂tigt, um √úbertragungsdeskriptoren aus dem RAM zu laden (die im Wesentlichen Zeiger und die Anzahl der √ºbertragenen Bytes enthalten).  Dar√ºber hinaus gibt es immer eine Art Speicherbuswechsel (damit die CPU ohne Daten nicht im Leerlauf steht), und der Flash-Speicher erfordert mindestens einen Wartezustand. <br><br><h3>  Timings - SPI </h3><br>  Ein weiterer Engpass ist SPI.  Reichen 12 MHz f√ºr 25 fps aus?  Die Antwort lautet ja: 12 MHz entsprechen etwa 36 Bildern pro Sekunde.  Wenn wir 24 MHz verwenden, wird sich das Limit verdoppeln! <br><br>  Die technischen Daten des Displays und des Mikrocontrollers besagen √ºbrigens, dass die maximale SPI-Geschwindigkeit 15 bzw. 12 MHz betr√§gt.  Wir haben getestet und sichergestellt, dass es problemlos auf 24 MHz erh√∂ht werden kann, zumindest in der von uns ben√∂tigten ‚ÄûRichtung‚Äú (der Mikrocontroller schreibt auf das Display). <br><br>  Wir werden das beliebte 1,8-Zoll-SPI-Display verwenden.  Wir haben sichergestellt, dass sowohl ILI9163 als auch ST7735 normal mit einer Frequenz von 12 MHz arbeiten (mindestens mit 12 MHz. Es wird √ºberpr√ºft, dass der ST7735 mit einer Frequenz von bis zu 24 MHz arbeitet).  Wenn Sie dieselbe Anzeige wie im Lernprogramm ‚ÄûAbspielen von Videos auf Arduino Uno‚Äú verwenden m√∂chten, empfehlen wir, diese zu √§ndern, falls Sie in Zukunft SD-Unterst√ºtzung hinzuf√ºgen m√∂chten.  Wir verwenden die SD-Kartenversion, damit wir viel Platz f√ºr andere Elemente wie Sound oder zus√§tzliche Pegel haben. <br><br><h2>  Grafik </h2><br>  Wie bereits erw√§hnt, verwendet das Spiel Kacheln.  Jedes Level besteht aus Kacheln, die sich gem√§√ü der Tabelle wiederholen, die wir "gameMap" genannt haben.  Wie gro√ü wird jede Fliese sein?  Die Gr√∂√üe jeder Kachel wirkt sich stark auf den Speicherverbrauch, die Details und die Flexibilit√§t aus (und, wie wir sp√§ter sehen werden, auch auf die Geschwindigkeit).  Zu gro√üe Kacheln erfordern die Erstellung einer neuen Kachel f√ºr jede kleine Variation, die wir ben√∂tigen.  Dies nimmt viel Platz auf dem Laufwerk ein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>  <i>Zwei Kacheln mit einer Gr√∂√üe von 32 √ó 32 Pixel (links und in der Mitte), die sich in einem kleinen Teil unterscheiden (der obere rechte Teil des Pixels ist 16 √ó 16).</i>  <i>Daher m√ºssen wir zwei verschiedene Kacheln mit einer Gr√∂√üe von 32 √ó 32 Pixel speichern.</i>  <i>Wenn wir eine 16 √ó 16-Pixel-Kachel (rechts) verwenden, m√ºssen wir nur zwei 16 √ó 16-Kacheln speichern (eine vollst√§ndig wei√üe Kachel und eine Kachel rechts).</i>  <i>Bei Verwendung von 16 √ó 16-Kacheln erhalten wir jedoch 4 Kartenelemente.</i> <br><br>  Es sind jedoch weniger Kacheln pro Bildschirm erforderlich, was die Geschwindigkeit erh√∂ht (siehe unten) und die Gr√∂√üe der Karte (d. H. Die Anzahl der Zeilen und Spalten in der Tabelle) jeder Ebene verringert.  Zu kleine Kacheln verursachen das gegenteilige Problem.  Kartentabellen werden gr√∂√üer und die Geschwindigkeit wird langsamer.  Nat√ºrlich werden wir keine dummen Entscheidungen treffen.  W√§hlen Sie beispielsweise Kacheln mit einer Gr√∂√üe von 17 √ó 31 Pixel aus.  Unser treuer Freund - Grad zwei!  Die Gr√∂√üe 16 √ó 16 ist fast die ‚Äûgoldene Regel‚Äú, sie wird in vielen Spielen verwendet und wir werden sie w√§hlen! <br><br>  Unser Bildschirm hat eine Gr√∂√üe von 160 √ó 128.  Mit anderen Worten, wir ben√∂tigen 10 √ó 8 Kacheln pro Bildschirm, d.h.  80 Eintr√§ge in der Tabelle.  F√ºr eine gro√üe Ebene von 10 √ó 10-Bildschirmen (oder 100 √ó 1-Bildschirmen) sind nur 8.000 Datens√§tze erforderlich (16 KB, wenn wir 16 Bit f√ºr die Aufzeichnung verwenden. Sp√§ter werden wir zeigen, warum wir uns f√ºr die Aufnahme von 16 Bit entschieden haben). <br><br>  Vergleichen Sie dies mit der Speicherkapazit√§t, die wahrscheinlich von einem gro√üen Bild auf dem gesamten Bildschirm belegt wird: 40 KB * 100 = 4 MB!  Das ist verr√ºckt! <br><br>  Lassen Sie uns √ºber das Rendering-System sprechen. <br><br>  Jeder Rahmen sollte enthalten (in Zeichnungsreihenfolge): <br><br><ul><li>  Hintergrundgrafiken (R√ºckspielfeld) </li><li>  das Level-Diagramm selbst (Vordergrund). </li><li>  Sprites </li><li>  Text / Top-Overlay. </li></ul><br>  Insbesondere werden wir nacheinander die folgenden Operationen ausf√ºhren: <br><br><ol><li>  Zeichnungshintergrund + Vordergrund (Kacheln) </li><li>  Zeichnen von durchscheinenden Kacheln + Sprites + Overlay </li><li>  Senden von Daten per SPI. </li></ol><br>  Hintergrund und vollst√§ndig undurchsichtige Kacheln werden von DMA gezeichnet.  Eine vollst√§ndig undurchsichtige Kachel ist eine Kachel, in der keine transparenten Pixel vorhanden sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>  <i>Teilweise transparente Fliese (links) und vollst√§ndig undurchsichtig (rechts).</i>  <i>In einer teilweise transparenten Kachel sind einige Pixel (unten links) transparent, und daher ist durch diesen Bereich ein Hintergrund sichtbar.</i> <br><br>  Teiltransparente Kacheln, Sprites und Overlays k√∂nnen von DMA nicht effektiv gerendert werden.  Tats√§chlich kopiert das ATSAMD21-Chip-DMA-System einfach die Daten und pr√ºft im Gegensatz zum Blitter des Amiga-Computers nicht die Transparenz (festgelegt durch den Farbwert).  Alle teilweise transparenten Elemente werden von der CPU gezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br>  Die Daten werden dann mit DMA an das Display √ºbertragen. <br><br><h3>  Pipeline erstellen </h3><br>  Wie Sie sehen, wird es viel Zeit in Anspruch nehmen, wenn wir diese Operationen nacheinander in einem Puffer ausf√ºhren.  W√§hrend DMA ausgef√ºhrt wird, ist die CPU nur besetzt, wenn auf den Abschluss des DMA gewartet wird!  Dies ist ein schlechter Weg, um eine Grafik-Engine zu implementieren.  Wenn DMA Daten an ein SPI-Ger√§t sendet, wird au√üerdem nicht die gesamte Bandbreite genutzt.  Selbst wenn SPI mit einer Frequenz von 24 MHz arbeitet, werden Daten nur mit einer Frequenz von 3 MHz √ºbertragen, was ziemlich klein ist.  Mit anderen Worten, DMA ist nicht voll ausgesch√∂pft: DMA kann andere Aufgaben ausf√ºhren, ohne wirklich an Leistung zu verlieren. <br><br>  Aus diesem Grund haben wir die Pipeline implementiert, die die Idee der doppelten Pufferung entwickelt (wir verwenden drei Puffer!).  Am Ende werden Operationen nat√ºrlich immer nacheinander ausgef√ºhrt.  CPU und DMA f√ºhren jedoch gleichzeitig unterschiedliche Aufgaben aus, ohne sich (insbesondere) gegenseitig zu beeinflussen. <br><br>  Folgendes passiert gleichzeitig: <br><br><ul><li>  Der Puffer wird verwendet, um Hintergrunddaten unter Verwendung des DMA 1-Kanals zu zeichnen; </li><li>  In einem anderen Puffer (der zuvor mit Hintergrunddaten gef√ºllt war) zeichnet die CPU Sprites und teilweise transparente Kacheln. </li><li>  Dann wird ein anderer Puffer (der einen vollst√§ndigen horizontalen Datenblock enth√§lt) verwendet, um Daten √ºber SPI √ºber den DMA-Kanal 0 an die Anzeige zu senden. Nat√ºrlich war der Puffer, der zum Senden von Daten √ºber SPI verwendet wurde, zuvor mit Sprites gef√ºllt, w√§hrend der SPI den vorherigen Block und w√§hrend ein anderer Puffer sendete mit Fliesen gef√ºllt. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br><h3>  DMA </h3><br>  Das ATSAMD21-Chip-DMA-System ist nicht mit Blitter vergleichbar, verf√ºgt jedoch √ºber eigene n√ºtzliche Funktionen.  Dank DMA k√∂nnen wir trotz doppelter Wettbewerbsbedingungen eine sehr hohe Bildwiederholfrequenz erzielen. <br><br>  Die Konfiguration der DMA-√úbertragung wird im RAM in ‚ÄûDMA-Deskriptoren‚Äú gespeichert und teilt dem DMA mit, wie und wo die aktuelle √úbertragung durchgef√ºhrt werden soll.  Diese Deskriptoren k√∂nnen miteinander verbunden werden: Wenn eine Verbindung besteht (d. H. Es gibt keinen Nullzeiger), erh√§lt der DMA nach Abschluss der √úbertragung automatisch den n√§chsten Deskriptor.  Durch die Verwendung mehrerer Deskriptoren kann DMA "komplexe √úbertragungen" durchf√ºhren, die n√ºtzlich sind, wenn beispielsweise der Quellpuffer eine Folge nicht zusammenh√§ngender Segmente zusammenh√§ngender Bytes ist.  Das Abrufen und Schreiben von Deskriptoren dauert jedoch einige Zeit, da Sie 16 Byte Deskriptor aus dem RAM speichern / laden m√ºssen. <br><br>  DMA kann mit Daten unterschiedlicher L√§nge arbeiten: Bytes, Halbw√∂rter (16 Bit) und W√∂rter (32 Bit).  In der Spezifikation wird diese L√§nge als "Schlaggr√∂√üe" bezeichnet.  F√ºr SPI sind wir gezwungen, die Byte√ºbertragung zu verwenden (obwohl die aktuelle REVD-Spezifikation besagt, dass die ATSAMD21-SERCOM-Chips √ºber FIFO verf√ºgen, das laut Microchip 32-Bit-Daten akzeptieren kann. Tats√§chlich scheint es, dass sie kein FIFO haben. In der REVD-Spezifikation wird ebenfalls erw√§hnt SERCOM CTRLC-Register, das sowohl in den Header-Dateien als auch im Abschnitt zur Registerbeschreibung fehlt. Gl√ºcklicherweise verf√ºgt ATSAMD21 im Gegensatz zu AVR zumindest √ºber ein gepuffertes √úbertragungsdatenregister, sodass keine √úbertragungspausen auftreten!).  Zum Zeichnen von Kacheln verwenden wir nat√ºrlich 32 Bit.  Auf diese Weise k√∂nnen Sie zwei Pixel pro Takt kopieren.  Der ATSAMD21-DMA-Chip erm√∂glicht es auch jedem Quellschlag, die Quell- oder Zieladresse um eine feste Anzahl von Schlaggr√∂√üen zu erh√∂hen. <br><br>  Diese beiden Aspekte sind sehr wichtig und bestimmen die Art und Weise, wie wir Kacheln zeichnen. <br><br>  Erstens w√ºrden wir den Durchsatz unseres Systems halbieren, wenn wir ein Pixel pro Takt (16 Bit) rendern w√ºrden.  Wir k√∂nnen nicht die volle Bandbreite ablehnen! <br><br>  Wenn wir jedoch zwei Pixel pro Schlag zeichnen, kann das Spielfeld nur eine gerade Anzahl von Pixeln scrollen, was zu einer gleichm√§√üigen Bewegung f√ºhrt.  Um dies zu handhaben, k√∂nnen Sie einen Puffer verwenden, der zwei oder mehr Pixel gr√∂√üer ist.  Beim Senden von Daten an das Display verwenden wir den richtigen Versatz (0 oder 1 Pixel), je nachdem, ob wir die ‚ÄûKamera‚Äú um eine gerade oder ungerade Anzahl von Pixeln bewegen m√ºssen. <br><br>  Der Einfachheit halber reservieren wir jedoch Platz f√ºr 11 vollst√§ndige Kacheln (160 + 16 Pixel) und nicht f√ºr 160 + 2 Pixel.  Dieser Ansatz hat einen gro√üen Vorteil: Wir m√ºssen nicht die Empf√§ngeradresse jedes DMA-Deskriptors berechnen und aktualisieren (dies w√ºrde mehrere Anweisungen erfordern, was zu zu vielen Berechnungen pro Kachel f√ºhren k√∂nnte).  Nat√ºrlich werden wir nur die minimale Anzahl von Pixeln zeichnen, dh nicht mehr als 162. Ja, am Ende werden wir aus Gr√ºnden der Geschwindigkeit und Einfachheit ein wenig zus√§tzlichen Speicher (unter Ber√ºcksichtigung von drei Puffern, dies sind ungef√§hr 1500 Bytes) ausgeben.  Sie k√∂nnen auch weitere Optimierungen durchf√ºhren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br>  Alle 16-Zeilen-Blockpuffer (ohne Deskriptoren) sind in dieser GIF-Animation sichtbar.  Rechts wird angezeigt, was tats√§chlich angezeigt wird.  Die ersten 32 Bilder werden in GIF angezeigt, wobei wir in jedem Bild 1 Pixel nach rechts verschieben.  Der schwarze Bereich des Puffers ist der Teil, der nicht aktualisiert wird, und sein Inhalt bleibt einfach von fr√ºheren Operationen erhalten.  Wenn der Bildschirm eine ungerade Anzahl von Frames scrollt, wird ein 162 Pixel breiter Bereich in den Puffer gezeichnet.  Die erste und letzte Spalte (die in der Animation hervorgehoben sind) werden jedoch verworfen.  Wenn der Bildlaufwert ein Vielfaches von 16 Pixeln ist, beginnen die Zeichenoperationen im Puffer in der ersten Spalte (x = 0). <br><br>  Was ist mit vertikalem Scrollen? <br><br>  Wir werden uns damit befassen, nachdem wir eine Methode zum Speichern von Kacheln im Flash-Speicher gezeigt haben. <br><br><h3>  So lagern Sie Fliesen </h3><br>  Ein naiver Ansatz (der zu uns passen w√ºrde, wenn wir nur √ºber die CPU rendern w√ºrden) w√§re, die Kacheln als Folge von Pixelfarben im Flash-Speicher zu speichern.  Das erste Pixel der ersten Zeile, das zweite usw. bis zum sechzehnten.  Dann speichern wir das erste Pixel der zweiten Zeile, das zweite und so weiter. <br><br>  Warum ist eine solche Entscheidung naiv?  Denn in diesem Fall kann DMA nur 16 Pixel pro DMA-Deskriptor rendern!  Daher ben√∂tigen wir 16 Deskriptoren, von denen jeder 4 + 4 Speicherzugriffsoperationen ben√∂tigt (dh um 32 Bytes zu √ºbertragen - 8 Speicherleseoperationen + 8 Speicherschreiboperationen - DMA muss 4 weitere Lesevorg√§nge + 4 Schreibvorg√§nge ausf√ºhren).  Das ist ziemlich ineffizient! <br><br>  Tats√§chlich kann DMA f√ºr jeden Deskriptor die Quell- und Zieladressen nur um eine feste Anzahl von W√∂rtern erh√∂hen.  Nach dem Kopieren der ersten Zeile der Kachel in den Puffer sollte die Empf√§ngeradresse nicht um 1 Wort erh√∂ht werden, sondern um einen Wert, der auf die n√§chste Zeile des Puffers zeigt.  Dies ist nicht m√∂glich, da jeder √úbertragungsdeskriptor nur das Schwebungs√ºbertragungsinkrement angibt, das nicht ge√§ndert werden kann. <br><br>  Es ist viel schlauer, die ersten beiden Pixel jeder Zeile der Kachel nacheinander zu senden, dh die Pixel 0 und 1 der Zeile 0, die Pixel 0 und 1 der Zeile 1 usw. bis zu den Pixeln 0 und 1 der Zeile 15. Dann senden wir die Pixel 2 und 3 der Zeile 0 und so weiter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>  <i>Wie wird eine Fliese gelagert?</i> <br><br>  In der obigen Abbildung bezeichnet jede Zahl die Reihenfolge, in der das 16-Bit-Pixel im Kachelarray gespeichert ist. <br><br>  Dies kann mit einem Deskriptor geschehen, aber wir brauchen zwei Dinge: <br><br><ul><li>  Kacheln sollten so gespeichert werden, dass beim Inkrementieren der Quelle um ein Wort immer auf die richtigen Pixelpositionen gezeigt wird.  Mit anderen Worten, wenn (r, c) ein Pixel in Zeile r und Spalte c ist, m√ºssen wir die Pixel (0,0) (0,1) (1,0) (1,1) (2,0) nacheinander speichern (2.1) ... (15.0) (15.1) (0.2) (0.3) (1.2) (1.3) ... </li><li>  Der Puffer sollte 256 Pixel breit sein (nicht 160) </li></ul><br>  Das erste Ziel ist sehr einfach zu erreichen: √Ñndern Sie einfach die Reihenfolge der Daten. Dies kann beim Exportieren von Grafiken in Datei c erfolgen (siehe Abbildung oben). <br><br>  Das zweite Problem kann gel√∂st werden, da Sie mit DMA die Empf√§ngeradresse nach jedem Schlag um 512 Byte erh√∂hen k√∂nnen.  Dies hat zwei Konsequenzen: <br><br><ul><li>  Wir k√∂nnen keine Daten mit einem einzigen Deskriptor √ºber einen SPI-Block senden.  Dies ist kein sehr ernstes Problem, da wir am Ende einen Deskriptor durch 160 Pixel lesen.  Die Auswirkungen auf die Leistung sind minimal. </li><li>  Der Block muss eine Gr√∂√üe von 256 * 2 * 16 Bytes = 8 KB haben, und es wird viel "unbenutzter Speicherplatz" darin sein. </li></ul><br>  Dieser Raum kann jedoch weiterhin beispielsweise f√ºr Deskriptoren verwendet werden. <br><br>  Tats√§chlich ist jeder Deskriptor 16 Byte gro√ü.  Wir ben√∂tigen mindestens 10 * 8 (und tats√§chlich 11 * 8!) Deskriptoren f√ºr Kacheln und 16 Deskriptoren f√ºr SPI. <br><br>  Deshalb ist die Geschwindigkeit umso h√∂her, je mehr Kacheln vorhanden sind.  Wenn wir beispielsweise eine 32 x 32-Kachel verwenden w√ºrden, w√ºrden wir weniger Deskriptoren pro Bildschirm ben√∂tigen (320 statt 640).  Dies w√ºrde die Verschwendung von Ressourcen reduzieren. <br><br><h3>  Datenblock anzeigen </h3><br>  Der Blockpuffer, die Deskriptoren und andere Daten werden in einem Strukturtyp gespeichert, den wir displayBlock_t genannt haben. <br><br>  displayBlock ist ein Array von 16 displayLineData_t-Elementen.  DisplayLine-Daten enthalten 176 Pixel plus 80 W√∂rter.  In diesen 80 W√∂rtern speichern wir Anzeigedeskriptoren oder andere n√ºtzliche Anzeigedaten (unter Verwendung von union). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br>  Da wir 16 Zeilen haben, verwendet jede Kachel an Position X die ersten 8 DMA-Deskriptoren (0 bis 7) der X-Zeilen. Da wir maximal 11 Kacheln haben (die Anzeigelinie ist 176 Pixel breit), verwenden die Kacheln nur die ersten DMA-Deskriptoren 11 Datenzeilen.  Die Deskriptoren 8‚Äì9 aller Zeilen und die Deskriptoren 0‚Äì9 der Zeilen 11‚Äì15 sind frei. <br><br>  Von diesen werden die Deskriptoren 8 und 9 der Zeilen 0..7 f√ºr SPI verwendet. <br><br>  Deskriptoren 0..9 Zeilen 11-15 (bis zu 50 Deskriptoren, obwohl wir nur 48 davon verwenden werden) werden f√ºr das Hintergrundspielfeld verwendet. <br><br>  Die folgende Abbildung zeigt ihre Struktur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br><h3>  Hintergrundspielfeld </h3><br>  Hintergrundspielfeld wird anders gehandhabt.  Wenn wir einen reibungslosen Bildlauf ben√∂tigen, m√ºssen wir zun√§chst zum Zwei-Pixel-Format zur√ºckkehren, da Vordergrund und Hintergrund mit unterschiedlichen Geschwindigkeiten scrollen.  Daher ist der Beat zur H√§lfte abgeschlossen.  Obwohl dies ein Nachteil in Bezug auf die Geschwindigkeit ist, erleichtert dieser Ansatz die Integration.  Wir haben nur noch eine kleine Anzahl von Deskriptoren, daher k√∂nnen keine kleinen Kacheln verwendet werden.  Um die Arbeit zu vereinfachen und schnell Parallaxe hinzuzuf√ºgen, werden wir au√üerdem lange ‚ÄûSektoren‚Äú verwenden. <br><br>  Der Hintergrund wird nur gezeichnet, wenn mindestens ein teilweise transparentes Pixel vorhanden ist.  Dies bedeutet, dass der Hintergrund gezeichnet wird, wenn nur eine transparente Kachel vorhanden ist.  Dies ist nat√ºrlich eine Verschwendung von Bandbreite, aber es vereinfacht alles. <br><br>  Vergleichen Sie die Hintergrund- und Frontspielfelder: <br><br><ul><li>  Im Hintergrund werden Sektoren verwendet, bei denen es sich um lange Kacheln handelt, die "naiv" gespeichert sind. </li><li>  Der Hintergrund hat eine eigene Karte, die sich jedoch horizontal wiederholt.  Dadurch wird weniger Speicher ben√∂tigt. </li><li>  Hintergrund hat Parallaxe f√ºr jeden Sektor. </li></ul><br><h3>  Frontspielfeld </h3><br>  Wie gesagt, in jedem Block haben wir bis zu 11 Kacheln (10 vollst√§ndige Kacheln oder 9 vollst√§ndige Kacheln und 2 Teildateien).  Jede dieser Kacheln wird gezeichnet, wenn sie nicht als transparent markiert sind.  Wenn es nicht vollst√§ndig undurchsichtig ist, wird es der Liste hinzugef√ºgt, die sp√§ter beim Rendern von Sprites analysiert wird. <br><br><h3>  Wir verbinden zwei Spielfelder miteinander </h3><br>  Die Deskriptoren des Hintergrundspielfelds (die immer berechnet werden) und des Frontspielfelds bilden eine sehr lange verkn√ºpfte Liste.  Der erste Teil zeichnet ein Hintergrundspielfeld.  Der zweite Teil zeichnet Kacheln √ºber den Hintergrund.  Die L√§nge des zweiten Teils kann variabel sein, da die DMA-Deskriptoren von teilweise transparenten Kacheln von der Liste ausgeschlossen sind.  Wenn der Block nur undurchsichtige Kacheln enth√§lt, wird DMA wie folgt konfiguriert.  direkt vom ersten Deskriptor der ersten Kachel zu beginnen. <br><br><h3>  Sprites und Fliesen mit Transparenz </h3><br>  Fliesen mit Transparenz und Sprites werden fast gleich verarbeitet.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Kachel- / Sprite-Pixelanalyse wird durchgef√ºhrt. </font><font style="vertical-align: inherit;">Wenn es schwarz ist, ist es transparent und daher √§ndert sich die Hintergrundkachel nicht. </font><font style="vertical-align: inherit;">Wenn es nicht schwarz ist, wird das Hintergrundpixel durch ein Sprite / Kachel-Pixel ersetzt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertikales Scrollen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Arbeiten mit horizontalem Bildlauf zeichnen wir bis zu 11 Kacheln, auch wenn beim Zeichnen von 11 Kacheln die ersten und letzten nur teilweise gezeichnet werden. </font><font style="vertical-align: inherit;">Ein solches teilweises Rendern ist m√∂glich, da jeder Deskriptor zwei Spalten der Kachel zeichnet, sodass wir den Anfang und das Ende der verkn√ºpften Liste leicht festlegen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit vertikalem Scrollen arbeiten, m√ºssen wir sowohl das Empf√§ngerregister als auch das √úbertragungsvolumen berechnen. </font><font style="vertical-align: inherit;">Sie m√ºssen mehrmals pro Frame eingestellt werden. </font><font style="vertical-align: inherit;">Um diese Aufregung zu vermeiden, k√∂nnen wir einfach bis zu 9 vollst√§ndige Bl√∂cke pro Frame zeichnen (8, wenn das Scrollen ein Vielfaches von 16 ist).</font></font><br><br><h2>  Ausr√ºstung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gesagt, das Herz des Systems ist uChip. </font><font style="vertical-align: inherit;">Was ist mit dem Rest? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Diagramm! </font><font style="vertical-align: inherit;">Einige Aspekte davon sind erw√§hnenswert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schl√ºssel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Verwendung von E / A zu optimieren, verwenden wir einen kleinen Trick. </font><font style="vertical-align: inherit;">Wir werden 4 Sensorbusse L1-L4 und ein gemeinsames LC-Kabel haben. </font><font style="vertical-align: inherit;">1 und 0 werden abwechselnd an den gemeinsamen Draht angelegt. Dementsprechend werden die Sensorbusse abwechselnd mit Hilfe interner Pull-up-Widerst√§nde nach unten oder oben gezogen. </font><font style="vertical-align: inherit;">Zwischen jedem der Schl√ºsselbusse und einem gemeinsamen Bus sind zwei Schl√ºssel verbunden. </font><font style="vertical-align: inherit;">Mit diesen beiden Tasten ist eine Diode in Reihe geschaltet. </font><font style="vertical-align: inherit;">Jede dieser Dioden wird in die entgegengesetzte Richtung geschaltet, so dass jedes Mal nur eine Taste "gelesen" wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es keinen eingebauten Tastaturcontroller gibt (und kein eingebauter Tastaturcontroller diese interessante Methode verwendet), werden zu Beginn jedes Frames schnell acht Tasten abgefragt. Da die Eing√§nge nach oben und unten gezogen werden m√ºssen, k√∂nnen (und wollen) wir keine externen Widerst√§nde verwenden, daher m√ºssen wir integrierte Widerst√§nde verwenden, die einen ziemlich hohen Widerstand (60 kOhm) haben k√∂nnen. Dies bedeutet, dass Sie, wenn der gemeinsame Bus den Status √§ndert und die Datenbusse ihren Aufw√§rts- / Abw√§rts-Pull-Status √§ndern, eine gewisse Verz√∂gerung einf√ºgen m√ºssen, damit der eingebaute Up / Down-Pull-Up-Widerstand den Vertrag √§ndert und die Streukapazit√§t auf den gew√ºnschten Wert einstellt. Aber wir wollen nicht warten! Daher versetzen wir den gemeinsamen Bus in einen hochohmigen Zustand (damit es keine Meinungsverschiedenheiten gibt) und √§ndern zuerst die Sensorbusse auf die logischen Werte 1 oder 0,vor√ºbergehend als Ausgabe konfigurieren. Sp√§ter werden sie durch Ziehen nach oben oder unten als Eingabe konfiguriert. Da der Ausgangswiderstand in der Gr√∂√üenordnung von zehn Ohm liegt, √§ndert sich der Zustand in wenigen Nanosekunden, dh wenn der Sensorbus zur√ºck zum Eingang schaltet, befindet er sich bereits im gew√ºnschten Zustand. Danach schaltet der gemeinsame Bus mit entgegengesetzter Polarit√§t auf den Ausgang.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies verbessert die Scan-Geschwindigkeit erheblich und macht keine Verz√∂gerungen / Anweisungen √ºberfl√ºssig. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SPI-Verbindung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die SD und das Display so verbunden, dass sie miteinander kommunizieren, ohne Daten an den ATSAMD21 zu √ºbertragen. </font><font style="vertical-align: inherit;">Dies kann n√ºtzlich sein, wenn Sie das Video abspielen m√∂chten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Widerst√§nde zwischen MISO und MOSI sollten niedrig sein. </font><font style="vertical-align: inherit;">Wenn sie zu gro√ü sind, funktioniert der SPI nicht, da das Signal zu schwach ist.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimierung und Weiterentwicklung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der gr√∂√üten Probleme ist die Verwendung von RAM. Drei Bl√∂cke belegen jeweils 8 KB, so dass nur 8 KB pro Stapel und andere Variablen √ºbrig bleiben. Im Moment haben wir nur 1,3 KB freien RAM + 4 KB Stapel (4 KB pro Stapel - das ist eine Menge, vielleicht werden wir es reduzieren). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen jedoch Bl√∂cke mit einer H√∂he von nicht 16, sondern 8 Pixel verwenden. Dies erh√∂ht die Verschwendung von Ressourcen f√ºr DMA-Deskriptoren, halbiert jedoch fast die vom Blockpuffer belegte Speichermenge (beachten Sie, dass sich die Anzahl der Deskriptoren nicht √§ndert, wenn wir weiterhin 16 √ó 16-Kacheln verwenden, sodass wir die Struktur des Blocks √§ndern m√ºssen). Dies kann ungef√§hr 7,5 KB RAM freigeben, was sehr n√ºtzlich ist, um Funktionen wie eine modifizierbare Karte mit Geheimnissen oder das Hinzuf√ºgen von Sound zu implementieren (obwohl Sound auch mit 1 KB RAM hinzugef√ºgt werden kann).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Problem ist das Sprite, aber diese √Ñnderung ist viel einfacher durchzuf√ºhren und Sie ben√∂tigen nur die Funktion createNextFrameScene (). Tats√§chlich erstellen wir im RAM ein riesiges Array mit dem Status aller Sprites. Anschlie√üend berechnen wir f√ºr jedes Sprite, ob sich seine Position im Bereich des Bildschirms befindet, animieren es und f√ºgen es der Rendering-Liste hinzu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen k√∂nnen Sie eine Optimierung durchf√ºhren. In gameMap k√∂nnen Sie beispielsweise nicht nur den Wert der Kachel speichern, sondern auch ein Flag, das die Transparenz der Kachel anzeigt, die im Editor festgelegt wurde. Auf diese Weise k√∂nnen wir schnell pr√ºfen, ob die Kachel gerendert werden soll: DMA oder CPU. Deshalb haben wir 16-Bit-Datens√§tze f√ºr die Kachelkarte verwendet. Wenn wir davon ausgehen, dass wir einen Satz von 256 Kacheln haben (im Moment haben wir weniger als 128 Kacheln, aber im Flash-Speicher ist gen√ºgend Speicherplatz vorhanden, um neue hinzuzuf√ºgen), gibt es 7 freie Bits, die f√ºr andere Zwecke verwendet werden k√∂nnen. Drei dieser sieben Bits k√∂nnen verwendet werden, um anzuzeigen, ob ein Sprite / Objekt gespeichert wird.</font></font> Zum Beispiel: <br><br> <code>0b000 =    <br> 0b001 =  <br> 0b010 =  <br> 0b011 =  <br> 0b100 =  <br> 0b101 =  <br> 0b110 =  <br> 0b111 =    , ,   .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann k√∂nnen Sie eine Bit-Tabelle im RAM erstellen, in der jedes Bit bedeutet, ob (zum Beispiel ein Feind) erkannt wird / ob (zum Beispiel ein Bonus) aufgenommen wird / ob ein bestimmtes Objekt aktiviert ist (Schalter). </font><font style="vertical-align: inherit;">Bei einer Ebene von 10 √ó 10 Bildschirmen erfordert dies 8000 Bits, d.h. </font><font style="vertical-align: inherit;">1 KB RAM. </font><font style="vertical-align: inherit;">Das Bit wird zur√ºckgesetzt, wenn ein Feind erkannt oder ein Bonus abgeholt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In createNextFrameScene () m√ºssen wir die Bits √ºberpr√ºfen, die den Kacheln im aktuell sichtbaren Bereich entsprechen. </font><font style="vertical-align: inherit;">Wenn sie einen Wert von 1 haben:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dies ein Bonus ist, f√ºgen Sie ihn einfach der Liste der Sprites zum Rendern hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies ein Feind ist, erstellen Sie ein dynamisches Sprite und setzen Sie die Flagge zur√ºck. </font><font style="vertical-align: inherit;">Im n√§chsten Frame enth√§lt die Szene ein dynamisches Sprite, bis der Feind den Bildschirm verl√§sst oder get√∂tet wird.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Ansatz hat Nachteile. </font></font><br><br><ol><li> -,           (       ).      . </li><li> -,       80  ,  ,    .      ,            32 .          ,   ¬´/¬ª (      ¬´¬ª, ..        0!).           ¬´¬ª,          ¬´¬ª (           ). </li><li> -,      .       (    ),     .  ,      . </li><li> -,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   ! </li><li>     ,          (,    Unreal Tournament   ,        ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir Sprites jedoch viel effizienter speichern und verarbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Technik ist jedoch f√ºr die "Spielelogik" relevanter als f√ºr die Grafik-Engine des Spiels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht werden wir diese Funktion in Zukunft implementieren.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir hoffen, Ihnen hat dieser Einf√ºhrungsartikel gefallen. Wir m√ºssen noch viele weitere Aspekte erl√§utern, die in zuk√ºnftigen Artikeln behandelt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Zwischenzeit k√∂nnen Sie den vollst√§ndigen Quellcode des Spiels herunterladen! Wenn es Ihnen gef√§llt, k√∂nnen Sie den K√ºnstler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finanziell </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">unterst√ºtzen</font></a><font style="vertical-align: inherit;"> , der alle Grafiken </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">gezeichnet</font></a><font style="vertical-align: inherit;"> und der Welt kostenlos zur Verf√ºgung gestellt hat. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir akzeptieren auch Spenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel ist noch nicht beendet. Wir m√∂chten Sound, viele Ebenen, Objekte, mit denen Sie interagieren k√∂nnen, und dergleichen hinzuf√ºgen. Sie k√∂nnen Ihre eigenen Modifikationen erstellen! Wir hoffen, neue Spiele mit neuen Grafiken und Levels zu sehen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bald werden wir einen Karteneditor ver√∂ffentlichen, aber im Moment ist es zu rudiment√§r, um ihn der Community zu zeigen!</font></font><br><br><h2>  Video </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Hinweis: Aufgrund der schlechten Beleuchtung wurde das Video mit einer viel niedrigeren Bildrate aufgenommen! In K√ºrze werden wir das Video aktualisieren, damit Sie die volle Geschwindigkeit auf 40 fps sch√§tzen k√∂nnen!) </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dankbarkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grafiken des Spiels (und die auf einigen Bildern gezeigten Kacheln) stammen aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kostenlosen Asset ‚ÄûSunny Land‚Äú, das von ansimuz erstellt wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herunterladbare Materialien </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode des Projekts ist gemeinfrei, dh er wird kostenlos zur Verf√ºgung gestellt. </font><font style="vertical-align: inherit;">Wir teilen es in der Hoffnung, dass es jemandem n√ºtzlich sein wird. </font><font style="vertical-align: inherit;">Wir garantieren nicht, dass es aufgrund eines Fehlers im Code keine Probleme gibt! </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schematische Darstellung </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KiCad- </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt Atmel Studio 7-Projekt (Quelle)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466323/">https://habr.com/ru/post/de466323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466307/index.html">Wie gestalte ich SCS?</a></li>
<li><a href="../de466311/index.html">SLS Workshop 6. September</a></li>
<li><a href="../de466315/index.html">@ Pythonetc-Zusammenstellung, August 2019</a></li>
<li><a href="../de466317/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, August 2019</a></li>
<li><a href="../de466319/index.html">Deal: VMware kauft Cloud-basierten Start</a></li>
<li><a href="../de466329/index.html">Elektronische Karte der Weinherstellung in Russland. Design und Inhalt</a></li>
<li><a href="../de466333/index.html">So arrangieren Sie einen Arbeitsplatz f√ºr sich</a></li>
<li><a href="../de466335/index.html">Erstellen einer Slack-Anwendung mit 8base-Funktionen</a></li>
<li><a href="../de466337/index.html">Welche Farbe hat deine Funktion?</a></li>
<li><a href="../de466339/index.html">Wie in Microsoft SQL Server Daten von Google Analytics mit R abrufen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>