<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 🔮 🚞 Entitas gaya DDD dengan Entity Framework Core 💈 🍼 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah tentang bagaimana menerapkan prinsip-prinsip Domain-Driven Design (DDD) untuk kelas yang dipetakan oleh Entity Framework Core (EF C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entitas gaya DDD dengan Entity Framework Core</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432410/">  Artikel ini adalah tentang bagaimana menerapkan prinsip-prinsip Domain-Driven Design (DDD) untuk kelas yang dipetakan oleh Entity Framework Core (EF Core) ke database, dan mengapa ini mungkin berguna. <br><br><h3>  TLDR </h3><br>  Ada banyak keuntungan dari pendekatan DDD, tetapi yang utama adalah bahwa DDD mentransfer kode buat / modifikasi operasi di dalam kelas entitas.  Ini secara signifikan mengurangi kemungkinan pengembang salah paham / menafsirkan aturan untuk membuat, menginisialisasi, dan menggunakan instance kelas. <br><a name="habracut"></a><br><ol><li>  Buku Eric Evans dan pidatonya tidak memiliki banyak informasi mengenai hal ini: </li><li>  Memberikan pelanggan dengan model sederhana untuk mendapatkan objek (kelas) persisten dan mengelola siklus hidup mereka. </li><li>  Kelas entitas Anda harus secara eksplisit menyatakan apakah mereka dapat diubah, bagaimana, dan dengan aturan apa. </li><li> Dalam DDD ada konsep agregat.  Agregat adalah pohon entitas terkait.  Menurut aturan DDD, pekerjaan dengan agregat harus dilakukan melalui "akar agregasi" (esensi akar pohon). </li></ol><br>  Eric menyebutkan repositori dalam pidatonya.  Saya tidak merekomendasikan menerapkan repositori dengan EF Core, karena EF sudah mengimplementasikan repositori dan unit pola kerja per se.  Saya akan bercerita lebih banyak tentang ini di artikel terpisah, “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah layak menggunakan repositori dengan EF Core</a> ?” <br><br><h3>  Entitas gaya DDD </h3><br>  Saya akan mulai dengan menunjukkan kode entitas dalam gaya DDD dan kemudian membandingkannya dengan bagaimana entitas dengan EF Core biasanya dibuat toko buku (versi Amazon yang sangat disederhanakan. ”Struktur basis data ditunjukkan pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e3/03d/4be/7e303d4bea08c1f34afa0d9848a2ff72.png" alt="gambar"><br><br>  Empat tabel pertama mewakili segala sesuatu tentang buku: buku itu sendiri, penulisnya, ulasan.  Dua tabel di bawah ini digunakan dalam kode logika bisnis.  Topik ini dijelaskan secara rinci dalam artikel terpisah. <br><blockquote>  Semua kode untuk artikel ini telah diunggah ke gudang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GenericBizRunner di GitHub</a> .  Selain kode perpustakaan GenericBizRunner, ada contoh lain dari aplikasi Core ASP.NET yang menggunakan GenericBizRunner untuk bekerja dengan logika bisnis.  Lebih lanjut tentang ini ditulis dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan untuk bekerja dengan logika bisnis dan Entity Framework Core</a> ." </blockquote>  Dan di sini adalah kode entitas yang sesuai dengan struktur basis data. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Book</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PromotionalTextLength = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BookId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//… all other properties have a private set //These are the DDD aggregate propties: Reviews and AuthorLinks public IEnumerable&lt;Review&gt; Reviews =&gt; _reviews?.ToList(); public IEnumerable&lt;BookAuthor&gt; AuthorsLink =&gt; _authorsLink?.ToList(); //private, parameterless constructor used by EF Core private Book() { } //public constructor available to developer to create a new book public Book(string title, string description, DateTime publishedOn, string publisher, decimal price, string imageUrl, ICollection&lt;Author&gt; authors) { //code left out } //now the methods to update the book's properties public void UpdatePublishedOn(DateTime newDate)… public IGenericErrorHandler AddPromotion(decimal newPrice, string promotionalText)… public void RemovePromotion()… //now the methods to update the book's aggregates public void AddReview(int numStars, string comment, string voterName, DbContext context)… public void RemoveReview(Review review)… }</span></span></code> </pre> <br>  Apa yang harus dicari: <br><br><ol><li>  Baris 5: mengatur akses ke semua properti entitas yang dinyatakan pribadi.  Ini berarti bahwa data dapat dimodifikasi baik menggunakan konstruktor, atau menggunakan metode publik yang dijelaskan nanti dalam artikel ini. </li><li>  Baris 9 dan 10. Koleksi terkait (agregat yang sama dari DDD) menyediakan akses publik ke IEnumerable &lt;T&gt;, bukan ICollection &lt;T&gt;.  Ini berarti Anda tidak dapat menambah atau menghapus item dari koleksi secara langsung.  Anda harus menggunakan metode khusus dari kelas Buku. </li><li>  Jalur 13. EF Core membutuhkan konstruktor tanpa parameter, tetapi dapat memiliki akses pribadi.  Ini berarti bahwa kode aplikasi lain tidak akan dapat memotong inisialisasi dan membuat instance kelas menggunakan konstruktor tanpa parameter (komentar seorang penerjemah. Kecuali tentu saja Anda membuat entitas menggunakan refleksi saja) </li><li>  Baris 16-20: Satu-satunya cara Anda dapat membuat instance kelas Buku adalah dengan menggunakan konstruktor publik.  Konstruktor ini berisi semua informasi yang diperlukan untuk menginisialisasi objek.  Dengan demikian, objek dijamin dalam keadaan valid. </li><li>  Baris 23-25: Baris ini berisi metode untuk mengubah keadaan buku. </li><li>  Baris 28-29: Metode ini memungkinkan Anda mengubah entitas terkait (agregat) </li></ol><br>  Metode pada baris 23-39, saya akan terus memanggil "metode yang menyediakan akses."  Metode-metode ini adalah satu-satunya cara untuk mengubah properti dan hubungan dalam suatu entitas.  Intinya adalah bahwa kelas Buku "ditutup."  Ini dibuat melalui konstruktor khusus dan hanya dapat dimodifikasi sebagian melalui metode khusus dengan nama yang sesuai.  Pendekatan ini menciptakan kontras yang tajam dengan pendekatan standar untuk membuat / memodifikasi entitas di EF Core, di mana semua entitas mengandung konstruktor default kosong dan semua properti dinyatakan publik.  Pertanyaan selanjutnya adalah, mengapa pendekatan pertama lebih baik? <br><br><h3>  Perbandingan Pembuatan Entitas </h3><br>  Mari kita bandingkan kode untuk memperoleh data pada beberapa buku dari json dan membuat instance kelas-kelas Buku berdasarkan basisnya. <br><br><h3>  a.  Pendekatan standar </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>) (bookInfoJson.saleInfoListPriceAmount ?? DefaultBookPrice) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Book { Title = bookInfoJson.title, Description = bookInfoJson.description, PublishedOn = DecodePubishDate(bookInfoJson.publishedDate), Publisher = bookInfoJson.publisher, OrgPrice = price, ActualPrice = price, ImageUrl = bookInfoJson.imageLinksThumbnail }; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; book.AuthorsLink = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BookAuthor&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> author <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bookInfoJson.authors) { book.AuthorsLink.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BookAuthor { Book = book, Author = authorDict[author], Order = i++ }); }</code> </pre><br><h3>  b.  Gaya DDD </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> authors = bookInfoJson.authors.Select(x =&gt; authorDict[x]).ToList(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Book(bookInfoJson.title, bookInfoJson.description, DecodePubishDate(bookInfoJson.publishedDate), bookInfoJson.publisher, ((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>?)bookInfoJson.saleInfoListPriceAmount) ?? DefaultBookPrice, bookInfoJson.imageLinksThumbnail, authors);</code> </pre><br>  Kode konstruktor kelas buku <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Book</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description, DateTime publishedOn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> publisher, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageUrl, ICollection&lt;Author&gt; authors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(title)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(title)); Title = title; Description = description; PublishedOn = publishedOn; Publisher = publisher; ActualPrice = price; OrgPrice = price; ImageUrl = imageUrl; _reviews = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;Review&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (authors == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !authors.Any()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( <span class="hljs-string"><span class="hljs-string">"You must have at least one Author for a book"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(authors)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> order = <span class="hljs-number"><span class="hljs-number">0</span></span>; _authorsLink = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;BookAuthor&gt;( authors.Select(a =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BookAuthor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, a, order++))); }</code> </pre><br>  Apa yang harus dicari: <br><br><ol><li>  Baris 1-2: konstruktor memaksa Anda untuk melewatkan semua data yang diperlukan untuk inisialisasi yang tepat. </li><li>  Baris 5, 6, dan 17-9: Kode ini berisi beberapa pemeriksaan untuk aturan bisnis.  Dalam kasus khusus ini, pelanggaran aturan dianggap sebagai kesalahan dalam kode, oleh karena itu, dalam kasus pelanggaran, pengecualian akan dilemparkan.  Jika pengguna dapat memperbaiki kesalahan ini, mungkin saya akan menggunakan pabrik statis yang mengembalikan Status &lt;T&gt; (penerjemah komentar. Saya akan menggunakan Opsi &lt;T&gt; atau Hasil &lt;T&gt;, sebagai nama yang lebih umum).  Status adalah jenis yang mengembalikan daftar kesalahan. </li><li>  Baris 21-23: Penjilidan BookAuthor dibuat di konstruktor.  Konstruktor BookAuthor dapat dideklarasikan dengan tingkat akses internal.  Dengan cara ini kita bisa mencegah terciptanya hubungan di luar DAL. </li></ol><br>  Seperti yang mungkin Anda perhatikan, jumlah kode untuk membuat entitas kurang lebih sama dalam kedua kasus.  Jadi mengapa gaya DDD lebih baik?  Gaya DDD lebih baik karena: <br><br><ol><li>  Mengontrol akses.  Perubahan properti yang tidak disengaja dikecualikan.  Setiap perubahan terjadi melalui konstruktor atau metode publik dengan nama yang sesuai.  Jelas apa yang terjadi. </li><li>  Sesuai dengan KERING (jangan ulangi diri Anda sendiri).  Anda mungkin perlu membuat instance Buku di beberapa tempat.  Kode tugas ada di konstruktor dan Anda tidak perlu mengulanginya di beberapa tempat. </li><li>  Menyembunyikan kompleksitas.  Kelas Buku memiliki dua properti: ActualPrice dan OrgPrice.  Kedua nilai ini harus sama ketika membuat buku baru.  Dalam pendekatan standar, setiap pengembang harus mengetahui hal ini.  Dalam pendekatan DDD, cukup bagi pengembang kelas Buku untuk mengetahuinya.  Selebihnya akan belajar tentang aturan ini karena secara eksplisit ditulis dalam konstruktor. </li><li>  Menyembunyikan pembuatan agregat.  Dalam pendekatan standar, pengembang harus secara manual membuat instance dari BookAuthor.  Dalam gaya DDD, kompleksitas ini dienkapsulasi untuk kode panggilan. </li><li>  Mengizinkan properti memiliki akses tulis pribadi </li><li>  Salah satu alasan untuk menggunakan DDD adalah untuk mengunci entitas, mis.  Jangan berikan kemampuan untuk mengubah properti secara langsung.  Mari kita bandingkan operasi perubahan dengan dan tanpa DDD. </li></ol><br><h3>  Perbandingan Perubahan Properti </h3><br>  Eric Evans menyebut salah satu keunggulan utama entitas gaya DDD sebagai berikut: "Mereka mengkomunikasikan keputusan desain tentang akses objek". <br><blockquote>  Catatan  penerjemah.  Ungkapan aslinya sulit diterjemahkan ke dalam bahasa Rusia.  Dalam hal ini, keputusan desain adalah keputusan yang dibuat tentang bagaimana perangkat lunak harus bekerja.  Ini berarti bahwa keputusan telah didiskusikan dan dikonfirmasi.  Kode dengan konstruktor yang menginisialisasi entitas dan metode dengan nama yang benar yang mencerminkan makna operasi secara eksplisit memberi tahu pengembang bahwa penugasan nilai-nilai tertentu dibuat dengan maksud, dan bukan karena kesalahan, dan bukan keinginan pengembang lain atau detail implementasi. </blockquote>  Saya mengerti frasa ini sebagai berikut. <br><br><ol><li>  Jelaskan bagaimana cara memodifikasi data dalam suatu entitas dan data apa yang harus diubah bersama. </li><li>  Jelaskan saat Anda tidak boleh memodifikasi data tertentu dalam entitas. </li></ol>  Mari kita bandingkan dua pendekatan.  Contoh pertama sederhana, dan yang kedua lebih rumit. <br><br><h3>  1. Perubahan tanggal publikasi </h3><br>  Misalkan kita ingin bekerja dulu dengan konsep buku dan baru kemudian menerbitkannya.  Pada saat penulisan draft, perkiraan tanggal publikasi diatur, yang sangat mungkin akan berubah selama proses pengeditan.  Untuk menyimpan tanggal publikasi, kami akan menggunakan properti PublishedOn. <br><br><h3>  a.  Entitas dengan Properti Publik </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = context.Find&lt;Book&gt;(dto.BookId); book.PublishedOn = dto.PublishedOn; context.SaveChanges();</code> </pre><br><h3>  b.  Entitas gaya DDD </h3><br>  Dalam gaya DDD, setter properti dinyatakan pribadi, jadi kami akan menggunakan metode akses khusus. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = context.Find&lt;Book&gt;(dto.BookId); book.UpdatePublishedOn( dto.PublishedOn); context.SaveChanges();</code> </pre><br>  Dua kasus ini hampir sama.  Versi DDD bahkan sedikit lebih lama.  Namun masih ada perbedaan.  Dalam gaya DDD, Anda tahu pasti bahwa tanggal publikasi dapat diubah karena ada metode dengan nama yang jelas.  Anda juga tahu bahwa Anda tidak dapat mengubah penerbit karena properti Publisher tidak memiliki metode yang tepat untuk berubah.  Informasi ini akan berguna bagi setiap programmer yang bekerja dengan kelas buku. <br><br><h3>  2. Kelola diskon untuk buku </h3><br>  Syarat lain adalah kita harus bisa mengelola diskon.  Diskon terdiri dari harga baru dan komentar, misalnya, "50% sebelum akhir minggu ini!" <br><br>  Implementasi aturan ini sederhana, tetapi tidak terlalu jelas. <br><br><ol><li>  Properti OrgPrice adalah harga tanpa diskon. </li><li>  ActualPrice - Harga saat buku dijual.  Jika diskon tersebut valid, maka harga saat ini akan berbeda dari OrgHarga dengan ukuran diskon.  Jika tidak, maka nilai properti akan sama. </li><li>  Properti PromotionText harus mengandung teks diskon jika diskon diterapkan atau nol jika diskon saat ini tidak diterapkan. </li></ol><br>  Aturannya cukup jelas bagi orang yang menerapkannya.  Namun, untuk pengembang lain, katakanlah, kembangkan UI untuk menambahkan diskon.  Menambahkan metode AddPromotion dan RemovePromotion ke kelas entitas menyembunyikan detail implementasi.  Sekarang pengembang lain memiliki metode publik dengan nama yang sesuai.  Semantik penggunaan metode jelas. <br><br>  Lihatlah penerapan metode AddPromotion dan RemovePromotion. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IGenericErrorHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPromotion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newPrice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> promotionalText</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> status = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericErrorHandler(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(promotionalText)) { status.AddError( <span class="hljs-string"><span class="hljs-string">"You must provide some text to go with the promotion."</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(PromotionalText)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } ActualPrice = newPrice; PromotionalText = promotionalText; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; }</code> </pre><br>  Apa yang harus dicari: <br><br><ol><li>  Baris 4-10: menambahkan komentar PromotionalText diperlukan.  Metode memeriksa apakah teks tidak kosong.  Karena  Pengguna dapat memperbaiki kesalahan ini. Metode ini mengembalikan daftar kesalahan untuk diperbaiki. </li><li>  Baris 12, 13: metode ini menetapkan nilai properti sesuai dengan implementasi yang telah dipilih pengembang.  Pengguna metode AddPromotion tidak harus mengetahuinya.  Untuk menambahkan diskon, cukup tulis: </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = context.Find&lt;Book&gt;(dto.BookId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> status = book.AddPromotion(newPrice, promotionText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!status.HasErrors) context.SaveChanges(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status;</code> </pre><br>  Metode RemovePromotion jauh lebih sederhana: itu tidak melibatkan penanganan kesalahan.  Oleh karena itu, nilai pengembaliannya batal. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemovePromotion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ActualPrice = OrgPrice; PromotionalText = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br>  Dua contoh ini sangat berbeda satu sama lain.  Pada contoh pertama, mengubah properti PublishOn sangat sederhana sehingga implementasi standar baik-baik saja.  Dalam contoh kedua, detail implementasi tidak jelas bagi seseorang yang belum bekerja dengan kelas Buku.  Dalam kasus kedua, gaya DDD dengan metode akses khusus menyembunyikan detail implementasi dan membuat kehidupan pengembang lain lebih mudah.  Juga, dalam contoh kedua, kode tersebut berisi logika bisnis.  Meskipun jumlah logikanya kecil, kami dapat menyimpannya secara langsung dalam metode akses dan mengembalikan daftar kesalahan jika metode tersebut tidak digunakan dengan benar. <br><br><h3>  3. Bekerja dengan Ulasan agregat - koleksi properti </h3><br>  DDD menawarkan untuk bekerja dengan unit hanya melalui root.  Dalam kasus kami, properti Ulasan menimbulkan masalah.  Bahkan jika setter dinyatakan pribadi, pengembang masih dapat menambah atau menghapus objek menggunakan metode add and remove, atau bahkan memanggil metode hapus untuk menghapus seluruh koleksi.  Di sini, fitur EF Core baru, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bidang dukungan,</a> akan membantu kami. <br><br>  Bidang dukungan memungkinkan pengembang untuk merangkum koleksi nyata dan menyediakan akses publik ke tautan antarmuka &lt;n&gt; IEnumerable.  Antarmuka IEnumerable &lt;T&gt; tidak menyediakan metode tambah, hapus, atau hapus.  Dalam kode di bawah ini adalah contoh menggunakan bidang dukungan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Book</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;Review&gt; _reviews; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;Review&gt; Reviews =&gt; _reviews?.ToList(); <span class="hljs-comment"><span class="hljs-comment">//… rest of code not shown }</span></span></code> </pre><br>  Agar ini berfungsi, Anda harus memberi tahu EF Core bahwa ketika membaca dari database, Anda harus menulis ke bidang pribadi, bukan milik umum.  Kode konfigurasi ditunjukkan di bawah ini. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnModelCreating</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ModelBuilder modelBuilder</span></span></span><span class="hljs-function">)</span></span> { modelBuilder.Entity&lt;Book&gt;() .FindNavigation(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Book.Reviews)) .SetPropertyAccessMode(PropertyAccessMode.Field); <span class="hljs-comment"><span class="hljs-comment">//… other non-review configurations left out }</span></span></code> </pre><br>  Untuk bekerja dengan ulasan, saya menambahkan dua metode: AddReview dan RemoveReview ke kelas buku.  Metode AddReview lebih menarik.  Ini kodenya: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddReview</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numStars, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comment, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> voterName, DbContext context = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_reviews != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _reviews.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Review(numStars, comment, voterName)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(context), <span class="hljs-string"><span class="hljs-string">"You must provide a context if the Reviews collection isn't valid."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Entry(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).IsKeySet) { context.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Review(numStars, comment, voterName, BookId)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"Could not add a new review."</span></span>); } }</code> </pre><br>  Apa yang harus dicari: <br><br><ol><li>  Baris 4-7: Saya sengaja tidak menginisialisasi bidang ¢ dalam konstruktor tanpa parameter pribadi yang digunakan EF Core saat memuat entitas dari basis data.  Ini memungkinkan kode saya untuk menentukan apakah koleksi dimuat menggunakan metode .Include (p =&gt; p.Reviews).  Di konstruktor publik, saya menginisialisasi bidang, sehingga NRE tidak akan terjadi ketika bekerja dengan entitas yang dibuat. </li><li>  Baris 8-12: Jika koleksi Ulasan tidak dimuat, kode harus menggunakan DbContext untuk menginisialisasi. </li><li>  Baris 13-16: Jika buku itu berhasil dibuat dan berisi ID, maka saya menggunakan teknik lain untuk menambahkan ulasan: Saya cukup menginstal kunci asing dalam instance dari kelas Review dan menulisnya ke database.  Ini dijelaskan secara lebih rinci di bagian 3.4.5 dari buku saya. </li><li>  Baris 19: Jika kita di sini, maka ada semacam masalah dengan logika kodenya.  Jadi saya melemparkan pengecualian. </li></ol><br>  Saya telah merancang semua metode akses saya untuk kasus terbalik di mana hanya entitas root dimuat.  Cara memperbarui unit ini berdasarkan kebijaksanaan metode.  Anda mungkin perlu memuat entitas tambahan. <br><br><h3>  Kesimpulan </h3><br>  Untuk membuat entitas dalam gaya DDD dengan EF Core, Anda harus mematuhi aturan berikut: <br><br><ol><li>  Buat konstruktor publik untuk membuat instance kelas yang diinisialisasi dengan benar.  Jika kesalahan dapat terjadi selama proses pembuatan yang dapat dikoreksi oleh pengguna, buat objek tidak menggunakan konstruktor publik, tetapi menggunakan metode pabrik yang mengembalikan Status &lt;T&gt;, di mana T adalah tipe entitas yang sedang dibuat </li><li>  Semua properti adalah properti setter.  Yaitu  semua properti hanya-baca di luar kelas. </li><li>  Untuk properti navigasi koleksi, deklarasikan bidang dukungan, dan jenis properti publik menyatakan IEnumerable &lt;T&gt;.  Ini akan mencegah pengembang lain mengubah koleksi tidak terkendali. </li><li>  Alih-alih setter publik, buat metode publik untuk semua operasi perubahan objek yang diizinkan.  Metode-metode ini harus kembali batal jika operasi tidak dapat gagal dengan kesalahan yang dapat diperbaiki pengguna atau Status &lt;T&gt; jika mereka bisa. </li><li>  Ruang lingkup masalah kewajiban entitas.  Saya pikir yang terbaik adalah membatasi entitas untuk mengubah kelas itu sendiri dan kelas lain di dalam agregat, tetapi tidak di luar.  Aturan validasi harus dibatasi untuk memeriksa kebenaran penciptaan dan perubahan status entitas.  Yaitu  Saya tidak memeriksa aturan bisnis seperti saldo stok.  Ada kode logika bisnis khusus untuk ini. </li><li>  Metode perubahan negara harus mengasumsikan bahwa hanya akar agregasi yang dimuat.  Jika suatu metode perlu memuat data lain, ia harus mengurusnya sendiri. </li><li>  Metode perubahan negara harus mengasumsikan bahwa hanya akar agregasi yang dimuat.  Jika suatu metode perlu memuat data lain, ia harus mengurusnya sendiri.  Pendekatan ini menyederhanakan penggunaan entitas oleh pengembang lain. </li></ol><br><h3>  Pro dan kontra entitas DDD saat bekerja dengan EF Core </h3><br>  Saya suka pendekatan kritis terhadap pola atau arsitektur apa pun.  Inilah yang saya pikirkan tentang menggunakan entitas DDD. <br><br><h3>  Pro </h3><br><ol><li>  Menggunakan metode khusus untuk mengubah keadaan adalah pendekatan yang lebih bersih.  Ini jelas merupakan solusi yang baik, hanya karena metode yang disebutkan dengan benar mengungkapkan niat kode jauh lebih baik dan memperjelas apa yang bisa dan tidak bisa diubah.  Selain itu, metode dapat mengembalikan daftar kesalahan jika pengguna dapat memperbaikinya. </li><li>  Mengubah agregat hanya melalui root juga berfungsi dengan baik </li><li>  Detail hubungan satu-ke-banyak antara kelas Buku dan Tinjauan sekarang disembunyikan bagi pengguna.  Enkapsulasi adalah prinsip dasar OOP. </li><li>  Menggunakan konstruktor khusus memungkinkan Anda memastikan bahwa entitas dibuat dan dijamin diinisialisasi dengan benar. </li><li>  Memindahkan kode inisialisasi ke konstruktor secara signifikan mengurangi kemungkinan bahwa pengembang tidak menafsirkan dengan benar bagaimana kelas harus diinisialisasi. </li></ol><br><h3>  Cons </h3><br><ol><li>  Pendekatan saya berisi dependensi pada implementasi EF Core. </li><li>  Beberapa orang bahkan menyebutnya anti-pola.  Masalahnya adalah bahwa sekarang entitas model subjek bergantung pada kode akses database.  Dalam hal DDD, ini buruk.  Saya menyadari bahwa jika saya tidak melakukan ini, saya harus mengandalkan penelepon untuk mengetahui apa yang harus dimuat.  Pendekatan ini mematahkan prinsip pemisahan keprihatinan. </li><li>  DDD memaksa Anda untuk menulis lebih banyak kode. </li></ol><br>  Apakah benar-benar layak untuk kasus sederhana, seperti memperbarui tanggal penerbitan buku? <br>  Seperti yang Anda lihat, saya suka pendekatan DDD.  Namun, saya perlu waktu untuk menyusunnya dengan benar, tetapi saat ini pendekatannya telah diselesaikan dan saya menerapkannya dalam proyek yang sedang saya kerjakan.  Saya sudah berhasil mencoba gaya ini dalam proyek-proyek kecil dan saya puas, tetapi semua pro dan kontra belum ditemukan ketika saya menggunakannya dalam proyek-proyek besar. <br><br>  Keputusan saya untuk mengizinkan penggunaan kode spesifik EFCore dalam argumen metode entitas model entitas tidaklah sederhana.  Saya mencoba untuk mencegah hal ini, tetapi pada akhirnya saya sampai pada kesimpulan bahwa kode panggilan harus memuat banyak properti navigasi.  Dan jika ini tidak dilakukan, maka perubahan itu tidak akan diterapkan tanpa kesalahan (terutama dalam hubungan satu-ke-satu).  Ini tidak dapat saya terima, jadi saya mengizinkan penggunaan EF Core di dalam beberapa metode (tetapi bukan konstruktor). <br><br>  Sisi buruk lainnya adalah bahwa DDD memaksa Anda untuk menulis lebih banyak kode secara signifikan untuk operasi CRUD.  Saya masih tidak yakin apakah akan terus makan kaktus dan menulis metode terpisah untuk semua properti, atau dalam beberapa kasus layak untuk menjauh dari Puritanisme radikal.  Saya tahu bahwa hanya ada kereta dan truk kecil CRUD yang membosankan, yang lebih mudah untuk ditulis secara langsung.  Hanya bekerja pada proyek nyata akan menunjukkan mana yang lebih baik. <br><br><h3>  Aspek DDD lainnya yang tidak dibahas dalam artikel ini </h3><br>  Artikelnya ternyata terlalu panjang, jadi saya akan berakhir di sini.  Tapi, ini berarti masih banyak material yang dirahasiakan.  Saya sudah menulis tentang sesuatu, tentang sesuatu yang akan saya tulis dalam waktu dekat.  Inilah yang tersisa ke laut: <br><br><ol><li>  <b>Logika bisnis dan DDD.</b>  Saya telah menggunakan konsep DDD dalam kode logika bisnis selama beberapa tahun dan, menggunakan fitur-fitur baru EF Core, saya berharap bahwa saya dapat mentransfer beberapa logika ke kode entitas.  Baca artikel "Lagi tentang Arsitektur Lapisan Logika Bisnis dengan Kerangka Entitas (Core dan v6)" </li><li>  <b>DDD dan pola repositori.</b>  Eric Evans merekomendasikan menggunakan repositori untuk abstrak akses data.    ,    «»   EF Core –  .  Mengapa   -  . </li><li> <b> DBContext' /   (bounded contexts).</b>          DbContext'. ,   BookContext      Book        OrderContext,   . ,  « »  ,      .         ,         . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode untuk artikel ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori GenericBizRunner di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Repositori ini berisi contoh aplikasi Core ASP.NET dengan metode akses khusus untuk memodifikasi kelas Buku. </font><font style="vertical-align: inherit;">Anda dapat mengkloning repositori dan menjalankan aplikasi secara lokal. </font><font style="vertical-align: inherit;">Ia menggunakan Sqlite dalam memori sebagai basis data, sehingga harus dijalankan pada infrastruktur apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkembangan senang!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432410/">https://habr.com/ru/post/id432410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi434978/index.html">पेश है HealthKit</a></li>
<li><a href="../id432400/index.html">CS: GO sekarang gratis</a></li>
<li><a href="../id432402/index.html">Hai SDM, di mana suvenir saya?</a></li>
<li><a href="../id432404/index.html">Cadangan untuk Linux tidak menulis surat</a></li>
<li><a href="../id432408/index.html">Intisari Fintech: persiapan untuk memutuskan hubungan bank kecil dari Visa dan Mastercard, kalkulator pensiun dan tidak hanya</a></li>
<li><a href="../id432412/index.html">Highload ++: Cara membantu sistem ERP mengatasi 500.000 permintaan per detik</a></li>
<li><a href="../id432414/index.html">Rahasia Lama untuk Debugging Cepat: Animasi Kode Sumber</a></li>
<li><a href="../id432416/index.html">Jenis Tanggungan - Masa Depan Bahasa Pemrograman</a></li>
<li><a href="../id432418/index.html">Mengurai ekspresi lambda di Jawa</a></li>
<li><a href="../id432420/index.html">Pengantar Git Merge dan Git Rebase: Mengapa dan Kapan Menggunakannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>