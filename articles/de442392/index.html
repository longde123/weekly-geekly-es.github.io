<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏻 🧔🏿 🈚️ NodeJS-Protokollierung richtig gemacht 👨🏽‍🎤 🖖🏼 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was nervt Sie am meisten, wenn Sie daran denken, sich bei NodeJS anzumelden? Wenn Sie mich fragen, werde ich sagen, dass es an Industriestandards für ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NodeJS-Protokollierung richtig gemacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442392/"><p><img src="https://habrastorage.org/webt/5a/em/fo/5aemfoyk841-ll_xjint9es2kao.jpeg"></p><br><p> Was nervt Sie am meisten, wenn Sie daran denken, sich bei NodeJS anzumelden?  Wenn Sie mich fragen, werde ich sagen, dass es an Industriestandards für die Erstellung von Trace-IDs mangelt.  In diesem Artikel werden wir einen Überblick darüber geben, wie wir diese Trace-IDs erstellen können (dh wir werden kurz untersuchen, wie die Fortsetzung des lokalen Speichers, auch bekannt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CLS,</a> funktioniert) und uns eingehend damit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen</a> , wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proxy verwenden können</a> , damit es mit JEDEM Logger funktioniert. </p><a name="habracut"></a><br><h2 id="why-is-it-even-a-problem-to-have-a-trace-id-for-each-request-in-nodejs">  Warum ist es überhaupt ein Problem, für jede Anforderung in NodeJS eine Ablaufverfolgungs-ID zu haben? </h2><br><p>  Nun, auf Plattformen, die Multithreading verwenden und für jede Anforderung einen neuen Thread erzeugen.  Es gibt einen so genannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-lokalen Speicher, auch bekannt als TLS</a> , der es ermöglicht, beliebige Daten für alles innerhalb eines Threads verfügbar zu halten.  Wenn Sie dazu über eine native API verfügen, ist es ziemlich trivial, für jede Anforderung eine zufällige ID zu generieren. Fügen Sie diese in TLS ein und verwenden Sie sie später in Ihrem Controller oder Dienst.  Also, was ist mit NodeJS los? <br>  Wie Sie wissen, ist NodeJS eine Single-Thread-Plattform (die nicht mehr wirklich stimmt, da wir jetzt Mitarbeiter haben, aber das ändert nichts am Gesamtbild), die TLS überflüssig macht.  Anstatt verschiedene Threads zu betreiben, führt NodeJS verschiedene Rückrufe innerhalb desselben Threads aus (es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">große Reihe von Artikeln</a> zur Ereignisschleife in NodeJS, wenn Sie interessiert sind), und NodeJS bietet uns die Möglichkeit, diese Rückrufe eindeutig zu identifizieren und ihre Beziehungen zueinander zu verfolgen . </p><br><p>  Früher (v0.11.11) hatten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">addAsyncListener, mit</a> dem wir asynchrone Ereignisse verfolgen konnten.  Darauf aufbauend baute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forrest Norvell</a> die erste Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continuation Local Storage, auch bekannt als CLS</a> .  Wir werden diese Implementierung von CLS nicht behandeln, da wir als Entwickler diese API bereits in Version 0.12 entfernt haben. </p><br><p>  Bis NodeJS 8 hatten wir keine offizielle Möglichkeit, eine Verbindung zur asynchronen Ereignisverarbeitung von NodeJS herzustellen.  Und schließlich hat uns NodeJS 8 die Leistung gewährt, die wir über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">async_hooks</a> verloren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> (wenn Sie async_hooks besser verstehen möchten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> ).  Dies bringt uns zur modernen async_hooks-basierten Implementierung von CLS - cls-hooked. </p><br><h2 id="cls-overview">  CLS-Übersicht </h2><br><p>  Hier ist ein vereinfachter Ablauf der Funktionsweise von CLS: </p><br><p><img src="https://habrastorage.org/webt/ix/xe/wj/ixxewjdn0xn7r5feuvgdl1vnjow.jpeg"></p><br><p>  Lassen Sie es uns Schritt für Schritt aufschlüsseln: </p><br><ol><li>  Angenommen, wir haben einen typischen Webserver.  Zuerst müssen wir einen CLS-Namespace erstellen.  Einmal für die gesamte Lebensdauer unserer Anwendung. </li><li>  Zweitens müssen wir eine Middleware konfigurieren, um für jede Anforderung einen neuen CLS-Kontext zu erstellen.  Nehmen wir der Einfachheit halber an, dass diese Middleware nur ein Rückruf ist, der beim Empfang einer neuen Anforderung aufgerufen wird. </li><li>  Wenn also eine neue Anfrage eintrifft, rufen wir diese Rückruffunktion auf. </li><li>  Innerhalb dieser Funktion erstellen wir einen neuen CLS-Kontext (eine der Möglichkeiten ist die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Run-</a> API-Aufrufs). </li><li>  Zu diesem Zeitpunkt fügt CLS den neuen Kontext anhand der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktuellen Ausführungs-ID</a> in eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextkarte ein</a> . </li><li> Jeder CLS-Namespace verfügt über eine <code>active</code> Eigenschaft.  Zu diesem Zeitpunkt weist CLS dem Kontext <code>active</code> zu. </li><li>  Innerhalb des Kontexts rufen wir eine asynchrone Ressource auf, beispielsweise fordern wir einige Daten aus der Datenbank an.  Wir übergeben einen Rückruf an den Anruf, der ausgeführt wird, sobald die Anforderung an die Datenbank abgeschlossen ist. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> asynchrone <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">init-</a> Hook wird für einen neuen asynchronen Betrieb ausgelöst.  Es fügt den aktuellen Kontext der Karte der Kontexte nach asynchroner ID hinzu (betrachten Sie ihn als Kennung der neuen asynchronen Operation). </li><li>  Da unser erster Rückruf keine Logik mehr enthält, wird er beendet und beendet unsere erste asynchrone Operation. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachdem der</a> asynchrone Hook für den ersten Rückruf ausgelöst wurde.  Der aktive Kontext im Namespace wird auf <code>undefined</code> (dies ist nicht immer der Fall, da möglicherweise mehrere verschachtelte Kontexte vorhanden sind, im einfachsten Fall jedoch). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Zerstörungshaken</a> wird für die erste Operation abgefeuert.  Der Kontext wird durch seine asynchrone ID aus unserer Kontextkarte entfernt (entspricht der aktuellen Ausführungs-ID unseres ersten Rückrufs). </li><li>  Die Anforderung an die Datenbank ist abgeschlossen und unser zweiter Rückruf steht kurz vor dem Auslösen. </li><li>  Zu diesem Zeitpunkt kommt der asynchrone Hook ins Spiel.  Die aktuelle Ausführungs-ID entspricht der asynchronen ID der zweiten Operation (Datenbankanforderung).  Es setzt die <code>active</code> Eigenschaft des Namespace auf den Kontext, der durch seine aktuelle Ausführungs-ID gefunden wird.  Es ist der Kontext, den wir zuvor erstellt haben. </li><li>  Jetzt führen wir unseren zweiten Rückruf durch.  Führen Sie eine Geschäftslogik aus.  Innerhalb dieser Funktion können wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jeden Wert per Schlüssel</a> vom CLS abrufen und er wird alles zurückgeben, was er durch den Schlüssel in dem zuvor erstellten Kontext findet. </li><li>  Unter der Annahme, dass die Verarbeitung der Anforderung beendet ist, gibt unsere Funktion zurück. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nachdem der</a> asynchrone Hook für den zweiten Rückruf ausgelöst wurde.  Es setzt den aktiven Kontext im Namespace auf <code>undefined</code> . </li><li>  <code>destroy</code> wird für die zweite asynchrone Operation ausgelöst.  Es entfernt unseren Kontext von der Karte der Kontexte durch seine asynchrone ID und lässt ihn absolut leer. </li><li>  Da wir keine Verweise mehr auf das Kontextobjekt haben, gibt unser Garbage Collector den damit verbundenen Speicher frei. </li></ol><br><p>  Es ist eine vereinfachte Version dessen, was unter der Haube vor sich geht, deckt jedoch alle wichtigen Schritte ab.  Wenn Sie tiefer graben möchten, können Sie sich den <a href="">Quellcode</a> ansehen.  Es sind weniger als 500 Zeilen. </p><br><h2 id="generating-trace-ids">  Trace-IDs generieren </h2><br><p>  Sobald wir ein umfassendes Verständnis von CLS haben, überlegen wir, wie wir es zu unserem eigenen Wohl nutzen können.  Eine <code>traceID</code> besteht darin, eine Middleware zu erstellen, die jede Anforderung in einen Kontext <code>traceID</code> , eine zufällige Kennung generiert und diese über die Schlüssel- <code>traceID</code> in CLS <code>traceID</code> .  Später, innerhalb eines unserer Millionen Controller und Services, konnten wir diese Kennung von CLS erhalten. </p><br><p>  Für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express könnte</a> diese Middleware folgendermaßen aussehen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsNamespace = cls.createNamespace(<span class="hljs-string"><span class="hljs-string">'app'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req and res are event emitters. We want to access CLS context inside of their event callbacks clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() clsNamespace.run(() =&gt; { clsNamespace.set('traceID', traceID) next() }) }</span></span></code> </pre> <br><p>  Dann könnten wir in unserem Controller die Trace-ID wie folgt generieren lassen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'traceID'</span></span>) }</code> </pre> <br><p>  Diese Trace-ID wird nur dann verwendet, wenn wir sie unseren Protokollen hinzufügen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fügen</a> wir es unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winston hinzu</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { createLogger, format, transports } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'winston'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTraceId = printf(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = info.message <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'taceID'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traceID) { message = <span class="hljs-string"><span class="hljs-string">`[TraceID: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${traceID}</span></span></span><span class="hljs-string">]: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = createLogger({ <span class="hljs-attr"><span class="hljs-attr">format</span></span>: addTraceId, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> transports.Console()], })</code> </pre> <br><p>  Wenn alle Logger Formatierer in Form von Funktionen unterstützen würden (viele von ihnen tun dies aus gutem Grund nicht), würde dieser Artikel nicht existieren.  Wie würde man meinem geliebten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pino</a> eine Trace-ID hinzufügen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stellvertreter</a> zur Rettung! </p><br><h2 id="combining-proxy-and-cls">  Proxy und CLS kombinieren </h2><br><p>  Proxy ist ein Objekt, das unser ursprüngliches Objekt umschließt und es uns ermöglicht, sein Verhalten in bestimmten Situationen zu überschreiben.  Die Liste dieser Situationen (sie werden eigentlich als Fallen bezeichnet) ist begrenzt, und Sie können sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> das gesamte Set ansehen, aber wir sind nur an Fallen interessiert.  Es bietet uns die Möglichkeit, den Zugriff auf Immobilien abzufangen.  Wenn wir ein Objekt <code>const a = { prop: 1 }</code> und es in einen Proxy <code>a.prop</code> können wir mit <code>get</code> trap alles zurückgeben, was wir für <code>a.prop</code> wollen. </p><br><p>  Die Idee ist also, für jede Anforderung eine zufällige Trace-ID zu generieren und einen <a href="">untergeordneten Pino-Logger</a> mit der Trace-ID zu erstellen und in CLS abzulegen.  Dann könnten wir unseren ursprünglichen Logger mit einem Proxy umschließen, der alle Protokollierungsanforderungen an den untergeordneten Logger in CLS umleitet, wenn einer gefunden wird, und ansonsten den ursprünglichen Logger weiter verwendet. </p><br><p>  In diesem Szenario könnte unser Proxy folgendermaßen aussehen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = pino() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loggerCls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(logger, { get(target, property, receiver) { <span class="hljs-comment"><span class="hljs-comment">// Fallback to our original logger if there is no child logger in CLS target = clsNamespace.get('loggerCls') || target return Reflect.get(target, property, receiver) }, })</span></span></code> </pre> <br><p>  Unsere Middleware würde sich in so etwas verwandeln: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req and res are event emitters. We want to access CLS context inside of their event callbacks clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() const loggerWithTraceId = logger.child({ traceID }) clsNamespace.run(() =&gt; { clsNamespace.set('loggerCls', loggerWithTraceId) next() }) }</span></span></code> </pre> <br><p>  Und wir könnten den Logger so verwenden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { loggerCls.info(<span class="hljs-string"><span class="hljs-string">'Long live rocknroll!'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Logs something like // {"level":30,"time":1551385666046,"msg":"Long live rocknroll!","pid":25,"hostname":"eb6a6c70f5c4","traceID":"9ba393f0-ec8c-4396-8092-b7e4b6f375b5","v":1} }</span></span></code> </pre> <br><h2 id="cls-proxifyhttpsgithubcomkeenondrumscls-proxify">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cls-proxify</a> </h2><br><p>  Basierend auf der obigen Idee wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleine Bibliothek namens cls-proxify</a> erstellt.  Es ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sofort in</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koa</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fastify</a> integriert. <br>  Dies gilt nicht nur für das ursprüngliche Objekt, sondern auch für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele andere</a> .  Es gibt also endlos mögliche Anwendungen.  Sie könnten Funktionsaufrufe, Klassenaufbau, so ziemlich alles vertreten!  Sie sind nur durch Ihre Vorstellungskraft begrenzt! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schauen Sie sich Live-Demos zur Verwendung mit Pino an und beschleunigen Sie, Pino und Express</a> . </p><br><p>  Hoffentlich haben Sie etwas Nützliches für Ihr Projekt gefunden.  Zögern Sie nicht, mir Ihr Feedback mitzuteilen!  Ich freue mich über Kritik und Fragen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442392/">https://habr.com/ru/post/de442392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442376/index.html">Einzelhandelsgrundstücksdichte</a></li>
<li><a href="../de442378/index.html">Ein Klick in der Benutzeroberfläche von Booking com kann einen Urlaub ruinieren oder warum ein funktionierendes Bewertungssystem wichtig ist</a></li>
<li><a href="../de442380/index.html">Chaos sortieren</a></li>
<li><a href="../de442384/index.html">Erweiterung der Funktionalität des Standard-Audiosystems</a></li>
<li><a href="../de442386/index.html">Thymeleaf: Dialektlayout + Spring Boot 2</a></li>
<li><a href="../de442396/index.html">Digitale Veranstaltungen in Moskau vom 04. bis 10. März</a></li>
<li><a href="../de442402/index.html">Das Wichtigste. Integration mit externen Diensten</a></li>
<li><a href="../de442404/index.html">Das Wichtigste. Integration mit externen Diensten (Teil 2)</a></li>
<li><a href="../de442406/index.html">Fintech Digest: Kostenlose Überweisungen im SBP-System, die Anfälligkeit von Banken für Angriffe und andere Nachrichten</a></li>
<li><a href="../de442408/index.html">Die Universalmaschine zur Durchführung von DIY-Tests, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>