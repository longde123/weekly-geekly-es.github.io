<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍⚖️ 🏚️ 👲🏾 Développement de programmes Python extrêmement rapides 👐🏽 👯 🍇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les ennemis de Python disent toujours que l'une des raisons pour lesquelles ils ne veulent pas utiliser ce langage est que Python est lent. Mais le fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de programmes Python extrêmement rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483678/">  Les ennemis de Python disent toujours que l'une des raisons pour lesquelles ils ne veulent pas utiliser ce langage est que Python est lent.  Mais le fait qu'un certain programme, quel que soit le langage de programmation utilisé, puisse être considéré comme rapide ou lent, dépend beaucoup du développeur qui l'a écrit, de ses connaissances et de la capacité à créer du code optimisé et performant. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483678/"><img src="https://habrastorage.org/webt/mr/w_/bl/mrw_bl18nmxvnmxgkcrg6nyguoo.jpeg"></a> <br><br>  L'auteur de l'article, que nous publions aujourd'hui, propose de prouver que ceux qui appellent Python lent ont tort.  Il veut parler de la façon d'améliorer les performances des programmes Python et de les rendre très rapides. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mesure du temps et profilage</font> </h2><br>  Avant de commencer à optimiser un code, vous devez d'abord savoir quelles parties de celui-ci ralentissent l'ensemble du programme.  Parfois, un goulot d'étranglement peut être évident, mais si le programmeur ne sait pas où il se trouve, il peut profiter de certaines opportunités pour l'identifier. <br><br>  Vous trouverez ci-dessous le code du programme, que j'utiliserai à des fins de démonstration.  Il est extrait de la documentation Python.  Ce code élève <code>e</code> à la puissance de <code>x</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># slow_program.py from decimal import * def exp(x):    getcontext().prec += 2    i, lasts, s, fact, num = 0, 0, 1, 1, 1    while s != lasts:        lasts = s        i += 1        fact *= i        num *= x        s += num / fact    getcontext().prec -= 2    return +s exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">La façon la plus simple de «profiler» le code</font> </h2><br>  Pour commencer, envisagez la façon la plus simple de profiler votre code.  Pour ainsi dire, «profilage pour les paresseux».  Elle consiste à utiliser la commande de <code>time</code> Unix: <br><br><pre> <code class="python hljs">~ $ time python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py real <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">058</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">050</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0,<span class="hljs-number"><span class="hljs-number">008</span></span>s</code> </pre> <br>  Un tel profilage pourrait bien donner au programmeur des informations utiles - dans le cas où il aurait besoin de mesurer le temps d'exécution de l'ensemble du programme.  Mais ce n'est généralement pas suffisant. <br><br><h2>  <font color="#3AC1EF">La méthode de profilage la plus précise</font> </h2><br>  À l'autre extrémité du spectre des méthodes de profilage de code se trouve l'outil <code>cProfile</code> , qui donne, certes, trop d'informations au programmeur: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> -m cProfile -s time slow_program.py         <span class="hljs-number"><span class="hljs-number">1297</span></span> function calls (<span class="hljs-number"><span class="hljs-number">1272</span></span> primitive calls) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span> seconds   Ordered by: internal time   ncalls tottime percall cumtime percall filename:lineno(function)        <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">4</span></span>(exp)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.002</span></span>  <span class="hljs-number"><span class="hljs-number">0.002</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method _imp.create_dynamic}      <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.<span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method __new__ of type object at <span class="hljs-number"><span class="hljs-number">0x9d12c0</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">132</span></span>(__new__)       <span class="hljs-number"><span class="hljs-number">23</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> _weakrefset.py:<span class="hljs-number"><span class="hljs-number">36</span></span>(__init__)      <span class="hljs-number"><span class="hljs-number">245</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.getattr}        <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method marshal.loads}       <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">1233</span></span>(find_spec)      <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">196</span></span>(__subclasscheck__)       <span class="hljs-number"><span class="hljs-number">15</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method posix.stat}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.__build_class__}        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> __init__.py:<span class="hljs-number"><span class="hljs-number">357</span></span>(namedtuple)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">57</span></span>(_path_join)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">59</span></span>(&lt;listcomp&gt;)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">1</span></span>(&lt;module&gt;)</code> </pre> <br>  Ici, nous <code>cProfile</code> le script étudié à l'aide du module <code>cProfile</code> et utilisons l'argument <code>time</code> .  En conséquence, les lignes de sortie sont triées par heure interne ( <code>cumtime</code> ).  Cela nous donne beaucoup d'informations.  En fait, ce qui est indiqué ci-dessus ne représente qu'environ 10% de la sortie de <code>cProfile</code> . <br><br>  Après avoir analysé ces données, nous pouvons voir que la fonction <code>exp</code> est la raison du lent fonctionnement du programme (c'est une surprise!).  Après cela, nous pouvons faire du profilage de code en utilisant des outils plus précis. <br><br><h2>  <font color="#3AC1EF">L'étude des indicateurs de performance temporaires d'une fonction spécifique</font> </h2><br>  Nous connaissons maintenant la place du programme sur laquelle nous devons diriger notre attention.  Par conséquent, nous pouvons décider d'étudier la fonction lente sans profiler d'autres codes de programme.  Pour ce faire, vous pouvez utiliser un simple décorateur: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeit_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span>    @wraps(func)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        start = time.perf_counter() <span class="hljs-comment"><span class="hljs-comment">#       time.process_time()        func_return_val = func(*args, **kwargs)        end = time.perf_counter()        print('{0:&lt;10}.{1:&lt;8} : {2:&lt;8}'.format(func.__module__, func.__name__, end - start))        return func_return_val    return wrapper</span></span></code> </pre> <br>  Ce décorateur peut être appliqué à la fonction à explorer: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@timeit_wrapper def exp(x):    ... print('{0:&lt;10} {1:&lt;8} {2:^8}'.format('module', 'function', 'time')) exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br>  Maintenant, après le démarrage du programme, nous recevrons les informations suivantes: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py module   function time __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.003267502994276583</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.038535295985639095</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">11.728486061969306</span></span></code> </pre> <br>  Ici, il convient de prêter attention à l'heure exacte que nous prévoyons de mesurer.  Le package correspondant nous fournit des indicateurs tels que <code>time.perf_counter</code> et <code>time.process_time</code> .  La différence entre eux est que <code>perf_counter</code> renvoie une valeur absolue, qui inclut le temps pendant lequel le processus du programme Python ne s'exécute pas.  Cela signifie que cet indicateur peut être affecté par la charge sur l'ordinateur créée par d'autres programmes.  La <code>process_time</code> renvoie uniquement le temps utilisateur.  Il n'inclut pas l'heure système.  Cela nous donne uniquement des informations sur le temps d'exécution de notre processus. <br><br><h2>  <font color="#3AC1EF">Accélération du code</font> </h2><br>  Et maintenant pour la partie amusante.  Travaillons à accélérer le programme.  Je ne vais (pour la plupart) pas montrer ici toutes sortes de hacks, astuces et morceaux de code mystérieux qui résolvent comme par magie les problèmes de performances.  Je veux essentiellement parler d'idées et de stratégies communes qui, si elles sont utilisées, peuvent avoir un impact important sur les performances.  Dans certains cas, nous parlons d'une augmentation de 30% de la vitesse d'exécution du code. <br><br><h3>  <font color="#3AC1EF">▍Utilisez les types de données intégrés</font> </h3><br>  L'utilisation de types de données intégrés est une approche très évidente pour accélérer le code.  Les types de données intégrés sont extrêmement rapides, surtout si vous les comparez avec des types personnalisés comme des arbres ou des listes liées.  Le point ici est principalement que les mécanismes intégrés du langage sont implémentés en utilisant C. Si vous décrivez quelque chose en utilisant Python, vous ne pouvez pas atteindre le même niveau de performances. <br><br><h3>  <font color="#3AC1EF">▍Appliquer la mise en cache (mémorisation) avec lru_cache</font> </h3><br>  La mise en cache est une approche populaire pour améliorer les performances du code.  J'ai déjà <a href="https://martinheinz.dev/blog/4">écrit</a> à son sujet, mais je pense qu'il vaut la peine d'en parler ici: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-comment"><span class="hljs-comment">#   12   @functools.lru_cache(maxsize=12) def slow_func(x):    time.sleep(2) #       return x slow_func(1) # ...  2     slow_func(1) #    -   ! slow_func(3) # ...   2    </span></span></code> </pre> <br>  La fonction ci-dessus simule des calculs complexes en utilisant <code>time.sleep</code> .  Lorsqu'il est appelé pour la première fois avec le paramètre <code>1</code> , il attend 2 secondes et ne renvoie le résultat qu'après cela.  Lorsqu'elle est à nouveau appelée avec le même paramètre, il s'avère que le résultat de son travail est déjà mis en cache.  Le corps de la fonction dans cette situation n'est pas exécuté et le résultat est renvoyé immédiatement.  Vous trouverez ici des exemples de mise en cache plus proches de la réalité. <br><br><h3>  <font color="#3AC1EF">▍Utiliser des variables locales</font> </h3><br>  En appliquant des variables locales, nous prenons en compte la vitesse de recherche d'une variable dans chaque portée.  Je parle spécifiquement de "tous les domaines de visibilité", car ici je n'ai pas seulement en tête une comparaison de la vitesse de travail avec les variables locales et globales.  En fait, la différence de travail avec les variables est même observée, par exemple, entre les variables locales dans une fonction (la vitesse la plus élevée), les attributs au niveau de la classe (par exemple, <code>self.name</code> , c'est déjà plus lent) et les entités importées globales comme <code>time.time</code> (le plus lent de ces trois mécanismes). <br><br>  Vous pouvez améliorer les performances en utilisant les approches suivantes pour attribuer des valeurs qui peuvent sembler complètement inutiles et inutiles à une personne non informée: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  #1 class FastClass:    def do_stuff(self):        temp = self.value #           for i in range(10000):            ... #      `temp` #  #2 import random def fast_function():    r = random.random    for i in range(10000):        print(r()) #   `r()` ,     random.random()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Envelopper le code dans la fonction</font> </h3><br>  Ce conseil peut sembler contraire au bon sens, car lorsqu'une fonction est appelée, certaines données sont poussées sur la pile et le système subit une charge supplémentaire qui traite l'opération de retour de la fonction.  Cependant, cette recommandation est liée à la précédente.  Si vous venez de mettre tout votre code dans un fichier sans l'écrire en tant que fonction, il s'exécutera beaucoup plus lentement en raison de l'utilisation de variables globales.  Cela signifie que le code peut être accéléré en l'enveloppant simplement dans la fonction <code>main()</code> et en l'appelant une fois: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    ... <span class="hljs-comment"><span class="hljs-comment">#  ,     main()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Ne pas accéder aux attributs</font> </h3><br>  Un autre mécanisme qui peut ralentir un programme est l'opérateur point ( <code>.</code> ), Qui est utilisé pour accéder aux attributs des objets.  Cette instruction appelle une <code>__getattribute__</code> dictionnaire à l'aide de <code>__getattribute__</code> , ce qui <code>__getattribute__</code> un stress supplémentaire sur le système.  Comment limiter l'impact sur les performances de cette fonctionnalité Python? <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : import re def slow_func():    for i in range(10000):        re.findall(regex, line) # ! # : from re import findall def fast_func():    for i in range(10000):        findall(regex, line) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Méfiez-vous des chaînes</font> </h3><br>  Les opérations sur chaîne peuvent ralentir considérablement un programme si elles sont exécutées en boucle.  En particulier, nous parlons de formatage de chaînes à l'aide de <code>%s</code> et <code>.format()</code> .  Est-il possible de les remplacer par quelque chose?  Si vous regardez un <a href="https://twitter.com/raymondh/status/1205969258800275456">tweet</a> récent <a href="https://twitter.com/raymondh/status/1205969258800275456">de</a> Raymond Hettinger, vous pouvez voir que le seul mécanisme qui doit être utilisé dans de telles situations est les lignes f.  Il s'agit de la méthode de formatage de chaîne la plus lisible, concise et la plus rapide.  Voici, conformément à ce tweet, une liste de méthodes qui peuvent être utilisées pour travailler avec des chaînes - de la plus rapide à la plus lente: <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{s}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{t}</span></span></span><span class="hljs-string">'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ! s + ' ' + t ' '.join((s, t)) '%s %s' % (s, t) '{} {}'.format(s, t) Template('$s $t').substitute(s=s, t=t) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Sachez que les générateurs peuvent également fonctionner rapidement</font> </h3><br>  Les générateurs ne sont pas ces mécanismes qui, de par leur nature, sont rapides.  Le fait est qu'ils ont été créés pour effectuer des calculs «paresseux», ce qui fait gagner non pas du temps, mais de la mémoire.  Cependant, économiser de la mémoire peut accélérer l'exécution des programmes.  Comment est-ce possible?  Le fait est que lors du traitement d'un grand ensemble de données sans utiliser de générateurs (itérateurs), les données peuvent entraîner un débordement du cache L1 du processeur, ce qui ralentira considérablement le processus de recherche de valeurs en mémoire. <br><br>  En ce qui concerne les performances, il est très important de veiller à ce que le processeur puisse accéder rapidement aux données qu'il traite, afin qu'elles soient aussi proches que possible de celles-ci.  Et cela signifie que ces données doivent être placées dans le cache du processeur.  Cette question est abordée dans <a href="https://www.youtube.com/watch%3Fv%3DOSGv2VnC0go%26t%3D8m17s">cette</a> présentation par Raymond Hettinger. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  La première règle d'optimisation est que l'optimisation n'est pas nécessaire.  Mais si vous ne pouvez pas vous passer de l'optimisation, j'espère que les conseils que j'ai partagés vous y aideront. <br><br>  <b>Chers lecteurs!</b>  Comment abordez-vous l'optimisation des performances de votre code Python? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483678/">https://habr.com/ru/post/fr483678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483666/index.html">À propos de Volodya et de l'ozoniseur</a></li>
<li><a href="../fr483668/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 397 (6-12 janvier 2020)</a></li>
<li><a href="../fr483670/index.html">Tout ce que vous vouliez savoir sur l'adresse MAC</a></li>
<li><a href="../fr483674/index.html">Comment fonctionnent les réseaux de neurones binaires et pourquoi ils seront populaires en 2020</a></li>
<li><a href="../fr483676/index.html">Évaluation de l'efficacité et du coût de la mise en œuvre d'un système d'analyse marketing de bout en bout</a></li>
<li><a href="../fr483680/index.html">Défauts de programmation courants à éviter</a></li>
<li><a href="../fr483684/index.html">PHP Digest n ° 171 (1 - 13 janvier 2020)</a></li>
<li><a href="../fr483686/index.html">32 conseils pour un développeur web qui veut se dépasser au-dessus de lui en 2020</a></li>
<li><a href="../fr483688/index.html">Environ 30 fois plus de concurrence dans Node.js</a></li>
<li><a href="../fr483698/index.html">Comment LoRaWAN aide à construire un Internet des objets moderne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>