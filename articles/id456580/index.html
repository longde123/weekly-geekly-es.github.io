<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏼 👩🏼‍🤝‍👨🏽 🎫 Masa Depan Otonomi yang Mandiri 😦 ‼️ 🛫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menurut Anda siapa yang lebih baik mengkonfigurasi algoritma PostgreSQL - DBA atau ML? Dan jika yang kedua, maka sudah saatnya bagi kita untuk memikir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masa Depan Otonomi yang Mandiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/456580/"> Menurut Anda siapa yang lebih baik mengkonfigurasi algoritma PostgreSQL - DBA atau ML?  Dan jika yang kedua, maka sudah saatnya bagi kita untuk memikirkan apa yang harus dilakukan ketika mobil menggantikan kita.  Atau tidak akan sampai di situ, dan keputusan penting masih harus dibuat oleh orang-orang.  Mungkin, tingkat isolasi dan persyaratan untuk stabilitas transaksi harus tetap dengan administrator.  Tetapi indeks dapat segera dipercaya untuk menentukan mesin sendiri. <br><br><img src="https://habrastorage.org/webt/k-/46/k3/k-46k3vgk1dm-quvhgnjdldvbay.jpeg"><br><br>  Andy Pavlo di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> berbicara tentang DBMS masa depan, yang dapat Anda "sentuh" ​​sekarang.  Jika Anda melewatkan pidato ini atau lebih suka menerima informasi dalam bahasa Rusia - di bawah cut adalah terjemahan pidato. <br><br>  Ini akan tentang proyek Universitas Carnegie Mellon tentang penciptaan DBMS otonom.  Istilah "otonom" berarti sistem yang dapat secara otomatis menggunakan, mengkonfigurasi, mengkonfigurasi sendiri tanpa campur tangan manusia.  Diperlukan waktu sekitar sepuluh tahun untuk mengembangkan sesuatu seperti ini, tetapi itulah yang dilakukan Andy dan murid-muridnya.  Tentu saja, algoritma pembelajaran mesin diperlukan untuk membuat DBMS yang otonom, namun, dalam artikel ini kita akan fokus hanya pada sisi teknik dari topik.  Pertimbangkan cara mendesain perangkat lunak untuk membuatnya mandiri. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QEAMBtUWqPM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <strong>Tentang pembicara:</strong> Andy Pavlo, associate professor di Carnegie Mellon University, di bawah kepemimpinannya menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PelotonDB DBMS yang "dikelola sendiri"</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ottertune</a> , yang membantu menyempurnakan PostgreSQL dan konfigurasi MySQL menggunakan pembelajaran mesin.  Andy dan timnya sekarang menjadi pemimpin sejati dalam database yang dikelola sendiri. <br><br>  Alasan kami ingin membuat DBMS yang otonom sudah jelas.  Mengelola alat-alat DBMS ini adalah proses yang sangat mahal dan memakan waktu.  Gaji DBA rata-rata di Amerika Serikat adalah sekitar 89 ribu dolar per tahun.  Diterjemahkan ke dalam rubel, 5,9 juta rubel per tahun diperoleh.  Jumlah yang sangat besar ini Anda bayar orang hanya untuk mengawasi perangkat lunak Anda.  Sekitar 50% dari total biaya penggunaan database dibayar oleh pekerjaan administrator dan staf terkait. <br><br>  Ketika datang ke proyek yang sangat besar, seperti kita bahas di HighLoad ++ dan yang menggunakan puluhan ribu database, kompleksitas struktur mereka melampaui persepsi manusia.  Semua orang mendekati masalah ini secara dangkal dan mencoba mencapai kinerja maksimal dengan menginvestasikan upaya minimal dalam memperbaiki sistem. <br><br><blockquote>  Anda dapat menyimpan jumlah bulat jika Anda mengkonfigurasi DBMS di tingkat aplikasi dan lingkungan untuk memastikan kinerja maksimum. </blockquote><br><h2>  Database adaptif sendiri, 1970-1990 </h2><br>  Gagasan DBMS otonom bukanlah hal baru, sejarah mereka kembali ke tahun 1970-an, ketika database relasional pertama kali mulai dibuat.  Kemudian mereka disebut database self-adaptive (Self-Adaptive Databases), dan dengan bantuan mereka, mereka mencoba memecahkan masalah klasik dari desain basis data, di mana orang masih berjuang sampai hari ini.  Ini adalah pilihan indeks, partisi dan konstruksi skema database, serta penempatan data.  Pada saat itu, alat dikembangkan yang membantu administrator database menyebarkan DBMS.  Alat-alat ini, pada kenyataannya, bekerja seperti yang dilakukan rekan-rekan modern mereka saat ini. <br><br>  Administrator melacak permintaan yang dijalankan oleh aplikasi.  Mereka kemudian meneruskan tumpukan query ini ke algoritma tuning, yang membangun model internal tentang bagaimana aplikasi harus menggunakan database. <br><br>  Jika Anda membuat alat yang membantu Anda secara otomatis memilih indeks, maka buatlah bagan dari mana Anda bisa melihat seberapa sering setiap kolom diakses.  Kemudian meneruskan informasi ini ke algoritma pencarian, yang akan melihat melalui berbagai lokasi - akan mencoba untuk menentukan kolom mana yang dapat diindeks dalam database.  Algoritme akan menggunakan model biaya internal untuk menunjukkan bahwa yang satu ini akan memberikan kinerja yang lebih baik dibandingkan dengan indeks lainnya.  Kemudian algoritma akan memberikan saran tentang perubahan indeks apa yang harus dilakukan.  Pada saat ini, sudah waktunya untuk berpartisipasi dalam orang tersebut, mempertimbangkan proposal ini dan tidak hanya memutuskan apakah itu benar, tetapi juga memilih waktu yang tepat untuk pelaksanaannya. <br><br><img src="https://habrastorage.org/webt/gp/bz/wt/gpbzwtyv3yingx-qfyov_qao7i0.png"><br><br>  DBA harus tahu bagaimana aplikasi digunakan ketika ada penurunan aktivitas pengguna.  Misalnya, pada hari Minggu pukul 3:00 pagi, tingkat terendah dari permintaan basis data, sehingga saat ini Anda dapat memuat ulang indeks. <br><br>  Seperti yang saya katakan, semua alat desain waktu bekerja dengan cara yang sama - <strong>ini</strong> adalah <strong>masalah yang sangat lama</strong> .  Pengawas ilmiah dari pengawas ilmiah saya menulis artikel tentang pemilihan indeks otomatis pada tahun 1976. <br><br><h2>  Database self-tuning, 1990-2000 </h2><br>  Pada 1990-an, orang, pada kenyataannya, bekerja pada masalah yang sama, hanya namanya yang berubah dari database adaptif ke self-tuning. <br><br>  Algoritma menjadi sedikit lebih baik, alat menjadi sedikit lebih baik, tetapi pada tingkat tinggi mereka bekerja dengan cara yang sama seperti sebelumnya.  Satu-satunya perusahaan di garis depan pergerakan sistem self-tuning adalah Microsoft Research dengan proyek administrasi otomatis mereka.  Mereka mengembangkan solusi yang benar-benar luar biasa, dan pada akhir 90-an dan awal 00-an mereka sekali lagi mempresentasikan serangkaian rekomendasi untuk menyiapkan basis data mereka. <br><br>  Gagasan kunci yang diajukan Microsoft berbeda dari apa yang ada di masa lalu - alih-alih memiliki alat penyesuaian mendukung model mereka sendiri, mereka sebenarnya hanya menggunakan kembali model biaya pengoptimal permintaan untuk membantu menentukan manfaat dari satu indeks terhadap yang lain.  Jika Anda memikirkannya, itu masuk akal.  Ketika Anda perlu tahu apakah satu indeks benar-benar dapat mempercepat kueri, tidak masalah seberapa besar jika pengoptimal tidak memilihnya.  Oleh karena itu, pengoptimal digunakan untuk mencari tahu apakah ia benar-benar akan memilih sesuatu. <br><br><img src="https://habrastorage.org/webt/wx/tm/ae/wxtmae-qjlpvjydyrqmqhku0ac8.png"><br><br>  Pada tahun 2007, Microsoft Research menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> yang menetapkan retrospektif penelitian selama sepuluh tahun.  Dan itu mencakup dengan baik semua tugas kompleks yang muncul di setiap segmen jalan. <br><br>  Tugas lain yang telah disorot dalam era self-tuning database adalah <strong>bagaimana membuat penyesuaian otomatis ke regulator.</strong>  Pengontrol basis data adalah semacam parameter konfigurasi yang mengubah perilaku sistem basis data saat runtime.  Misalnya, parameter yang ada di hampir setiap basis data adalah ukuran buffer.  Atau, misalnya, Anda dapat mengelola pengaturan seperti kebijakan pemblokiran, frekuensi pembersihan disk, dan sejenisnya.  Karena peningkatan signifikan dalam kompleksitas regulator DBMS dalam beberapa tahun terakhir, topik ini menjadi relevan. <br><br>  Untuk menunjukkan betapa buruknya hal itu, saya akan memberikan ulasan yang dilakukan siswa saya setelah mempelajari banyak rilis PostgreSQL dan MySQL. <br><br><blockquote>  Selama 15 tahun terakhir, jumlah regulator di PostgreSQL telah meningkat 5 kali, dan untuk MySQL - 7 kali. </blockquote><br><img src="https://habrastorage.org/webt/mq/u7/y1/mqu7y1e6ntezta8e-jxj-wvf5t0.png"><br><br>  Tentu saja, tidak semua regulator benar-benar mengendalikan proses pelaksanaan tugas.  Beberapa, misalnya, berisi jalur file atau alamat jaringan, jadi hanya seseorang yang dapat mengonfigurasinya.  Tetapi beberapa dari mereka benar-benar dapat mempengaruhi kinerja.  Tidak ada orang yang bisa memegang begitu banyak di kepalanya. <br><br><h2>  Cloud DB, 2010–… </h2><br>  Selanjutnya kita menemukan diri kita di era 2010-an, di mana kita berada hingga hari ini.  Saya menyebutnya era basis data cloud.  Selama waktu ini, banyak pekerjaan telah dilakukan untuk mengotomatiskan penyebaran sejumlah besar database di cloud. <br><br>  Hal utama yang mengkhawatirkan penyedia cloud utama adalah bagaimana meng-host penyewa atau bermigrasi dari satu ke yang lain.  Bagaimana menentukan berapa banyak sumber daya yang dibutuhkan masing-masing penyewa, dan kemudian mencoba mendistribusikannya di antara alat berat untuk memaksimalkan produktivitas atau mencocokkan SLA dengan biaya minimal. <br><br>  Amazon, Microsoft dan Google menyelesaikan masalah ini, tetapi terutama di tingkat operasional.  Baru-baru ini, penyedia layanan cloud mulai berpikir tentang perlunya mengkonfigurasi sistem basis data individual.  Pekerjaan ini tidak terlihat oleh pengguna biasa, tetapi menentukan tingkat tinggi perusahaan. <br><br><blockquote>  Kesimpulan penelitian 40 tahun dari basis data dengan sistem otonom dan non-otonom, kita dapat menyimpulkan bahwa pekerjaan ini masih belum cukup. </blockquote><br>  Mengapa hari ini kita tidak dapat memiliki sistem pemerintahan sendiri yang benar-benar otonom?  Ada tiga alasan untuk ini. <br><br><img src="https://habrastorage.org/webt/sm/d0/eg/smd0ega2yn_5o-ywbdz3zod1yf0.png"><br><br>  Pertama, semua alat ini, kecuali untuk distribusi beban kerja dari penyedia layanan cloud, hanya bersifat <strong>saran</strong> .  Yaitu, berdasarkan opsi yang dihitung, seseorang harus membuat keputusan akhir yang subyektif, apakah proposal seperti itu benar.  Selain itu, perlu untuk mengamati operasi sistem untuk beberapa waktu untuk memutuskan apakah keputusan yang dibuat tetap benar ketika layanan berkembang.  Dan kemudian terapkan pengetahuan itu pada model pengambilan keputusan internal Anda sendiri di masa depan.  Ini bisa dilakukan untuk satu database, tetapi tidak untuk puluhan ribu. <br><br>  Masalah selanjutnya adalah bahwa <strong>tindakan apa pun hanyalah reaksi terhadap sesuatu</strong> .  Dalam semua contoh yang kami periksa, pekerjaan dilakukan dengan data tentang beban kerja sebelumnya.  Ada masalah, catatan tentang itu ditransfer ke instrumen, dan dia berkata: "Ya, saya tahu bagaimana menyelesaikan masalah ini."  Tetapi solusinya hanya menyangkut masalah yang sudah terjadi.  Alat ini tidak memprediksi peristiwa masa depan dan karenanya tidak menawarkan tindakan persiapan.  Seseorang dapat melakukan ini, dan melakukannya secara manual, tetapi alat tidak bisa. <br><br>  Alasan terakhir adalah bahwa tidak ada solusi yang <strong>ada transfer pengetahuan</strong> .  Inilah yang saya maksud: misalnya, mari kita ambil alat yang berfungsi dalam satu aplikasi pada instance database pertama, jika Anda meletakkannya di aplikasi lain yang sama pada instance database lain, itu bisa, berdasarkan pengetahuan yang diperoleh saat bekerja dengan database pertama data membantu mengatur basis data kedua.  Bahkan, semua alat mulai bekerja dari awal, mereka perlu mendapatkan kembali semua data tentang apa yang terjadi.  Manusia bekerja dengan cara yang sangat berbeda.  Jika saya tahu cara mengkonfigurasi satu aplikasi dengan cara tertentu, saya dapat melihat pola yang sama di aplikasi lain dan, mungkin, mengkonfigurasinya jauh lebih cepat.  Tetapi tidak satu pun dari algoritma ini, tidak satu pun dari alat ini yang masih bekerja dengan cara ini. <br><br>  Mengapa saya yakin ini saatnya untuk berubah?  Jawaban untuk pertanyaan ini hampir sama dengan pertanyaan mengapa super-array data atau pembelajaran mesin menjadi populer.  <strong>Peralatan menjadi kualitas yang lebih baik</strong> : sumber daya produksi meningkat, kapasitas penyimpanan tumbuh, kapasitas perangkat keras meningkat, yang mempercepat perhitungan untuk model pembelajaran mesin pembelajaran. <br><br>  Alat perangkat lunak canggih telah tersedia bagi kami.  Sebelumnya, Anda harus menjadi ahli dalam MATLAB atau aljabar linier tingkat rendah untuk menulis beberapa algoritma pembelajaran mesin.  Sekarang kami memiliki Torch dan Tenso Flow, yang membuat ML tersedia, dan, tentu saja, kami telah belajar untuk lebih memahami data.  Orang tahu jenis data apa yang mungkin diperlukan untuk pengambilan keputusan di masa depan, oleh karena itu mereka tidak membuang data sebanyak sebelumnya. <br><br>  Tujuan dari penelitian kami adalah untuk menutup lingkaran ini dalam DBMS otonom.  Kita dapat, seperti alat-alat sebelumnya, mengusulkan solusi, tetapi alih-alih mengandalkan orang tersebut - apakah solusinya tepat ketika Anda perlu menggunakannya secara spesifik - algoritma akan melakukan ini secara otomatis.  Dan kemudian dengan bantuan umpan balik, ia akan belajar dan menjadi lebih baik seiring waktu. <br><br>  Saya ingin berbicara tentang proyek yang saat ini kami kerjakan di Universitas Carnegie Mellon.  Di dalamnya, kami mendekati masalah dengan dua cara berbeda. <br><br>  Dalam yang pertama - OtterTune - kami mencari cara untuk menyempurnakan database, memperlakukannya sebagai kotak hitam.  Yaitu, cara untuk <strong>menyempurnakan DBMS yang ada</strong> tanpa mengendalikan bagian internal sistem dan hanya mengamati responsnya. <br><br>  Proyek Peloton adalah tentang <strong>menciptakan database baru dari awal</strong> , dari awal, mengingat fakta bahwa sistem harus bekerja secara mandiri.  Penyesuaian dan algoritme optimasi apa yang perlu ditetapkan - yang tidak dapat diterapkan pada sistem yang ada. <br><br>  Mari kita pertimbangkan kedua proyek secara berurutan. <br><br><h2>  Ottertune </h2><br>  Proyek penyesuaian sistem yang ada yang telah kami kembangkan disebut OtterTune. <br><br>  Bayangkan bahwa basis data dikonfigurasikan sebagai sebuah layanan.  Idenya adalah Anda mengunduh metrik runtime dari operasi basis data berat yang menghabiskan semua sumber daya, dan konfigurasi regulator yang direkomendasikan datang sebagai tanggapan, yang, menurut pendapat kami, akan meningkatkan produktivitas.  Ini dapat berupa waktu tunda, bandwidth, atau karakteristik lain apa pun yang Anda tentukan - kami akan mencoba menemukan opsi terbaik. <br><br><img src="https://habrastorage.org/webt/zq/wi/eb/zqwiebmj38ma58e37dycznrjamq.png"><br><br>  Hal utama yang baru dalam proyek OtterTune adalah <strong>kemampuan untuk menggunakan data dari sesi</strong> tuning <strong>sebelumnya</strong> dan meningkatkan efisiensi sesi berikutnya.  Sebagai contoh, ambil konfigurasi PostgreSQL, yang memiliki aplikasi yang belum pernah kita lihat sebelumnya.  Tetapi jika memiliki karakteristik tertentu atau menggunakan database dengan cara yang sama seperti database yang telah kita lihat di aplikasi kita, maka kita sudah tahu cara mengkonfigurasi aplikasi ini lebih efisien. <br><br>  Pada level yang lebih tinggi, algoritma pekerjaan adalah sebagai berikut. <br><br>  Katakanlah ada database target: PostgreSQL, MySQL, atau VectorWise.  Anda harus menginstal controller di domain yang sama, yang akan melakukan dua tugas. <br><br><img src="https://habrastorage.org/webt/fv/bu/e_/fvbue_hzhuwaq4zxkzyalcoxhke.png"><br><br>  Yang pertama dilakukan oleh apa yang disebut collector - alat yang mengumpulkan data tentang konfigurasi saat ini, mis.  metrik waktu eksekusi permintaan dari aplikasi ke database.  Data yang dikumpulkan oleh kolektor dimuat ke Tuning Manager, layanan tuning.  Tidak masalah jika database berfungsi secara lokal atau di cloud.  Setelah mengunduh, data disimpan dalam repositori internal kami sendiri, yang menyimpan semua sesi pengaturan pengujian yang pernah dibuat. <br><br>  Sebelum memberikan rekomendasi, Anda perlu melakukan dua langkah.  Pertama, Anda perlu melihat metrik runtime dan mencari tahu mana yang sebenarnya penting.  Contoh berikut menunjukkan metrik yang dikembalikan oleh MySQL tetapi <code>SHOW_GLOBAL_STATUS</code> pada InnoDB.  Tidak semuanya berguna untuk analisis kami.  Diketahui bahwa dalam pembelajaran mesin sejumlah besar data tidak selalu baik.  Karena dengan itu diperlukan lebih banyak data untuk memisahkan gandum dari sekam.  Seperti dalam kasus ini, <strong>penting untuk menyingkirkan entitas yang tidak terlalu penting</strong> . <br><br><img src="https://habrastorage.org/webt/qq/th/js/qqthjszvgbp7pp8m1q3d0ze2qge.png"><br><br>  Misalnya, ada dua metrik: <code>INNODB_BUFFER_POOL_BYTES_DATA</code> dan <code>INNODB_BUFFER_POOL_PAGES_DATA</code> .  Sebenarnya, ini adalah metrik yang sama, tetapi dalam unit yang berbeda.  Anda dapat melakukan analisis statistik, melihat bahwa metrik sangat berkorelasi, dan menyimpulkan bahwa menggunakan keduanya berlebihan untuk analisis.  Jika Anda membuang salah satunya, dimensi tugas belajar akan berkurang dan waktu untuk menerima jawaban akan berkurang. <br><br>  Pada tahap kedua, kami melakukan hal yang sama, hanya berkaitan dengan regulator.  <strong>Ada</strong> <strong>500 regulator</strong> <strong>di</strong> <strong>MySQL</strong> , dan, tentu saja, tidak semuanya benar-benar signifikan, tetapi aplikasi yang berbeda penting untuk aplikasi yang berbeda.  Penting untuk melakukan analisis statistik lain untuk mengetahui regulator mana yang benar-benar memengaruhi fungsi target. <br><br><img src="https://habrastorage.org/webt/g7/wz/h9/g7wzh9wquhh68lwkovxrnxdt8b0.png"><br><br>  Dalam contoh kami, kami menemukan bahwa ketiga <code>INNODB_BUFFER_POOL_SIZE</code> , <code>FLUSH_METHOD</code> dan <code>LOG_FILE_SIZE</code> memiliki dampak terbesar pada kinerja.  Mereka mengurangi waktu tunda untuk beban kerja transaksional. <br><br>  Ada poin menarik lain terkait dengan regulator.  Di tangkapan layar ada regulator bernama <code>TIMED_MUTEXES</code> .  Jika Anda merujuk pada dokumentasi kerja MySQL, pada bagian 45.7 itu akan diindikasikan bahwa regulator ini kedaluwarsa.  Tetapi <strong>algoritma pembelajaran mesin tidak dapat membaca dokumentasi</strong> , sehingga tidak mengetahuinya.  Dia tahu bahwa ada regulator yang bisa dinyalakan atau dimatikan, dan akan butuh waktu lama untuk memahami bahwa ini tidak mempengaruhi apa pun.  Tetapi Anda dapat membuat perhitungan di muka dan mengetahui bahwa regulator tidak melakukan apa-apa, dan jangan buang waktu untuk mengaturnya. <br><br>  Setelah analisis, data ditransfer ke algoritma konfigurasi kami menggunakan <strong>model proses Gaussian</strong> - metode yang agak lama.  Anda mungkin pernah mendengar pembelajaran yang mendalam, kami melakukan hal yang serupa, tetapi tanpa jaringan yang dalam.  Kami menggunakan <strong>GPflow</strong> , paket untuk bekerja dengan model proses Gaussian yang dikembangkan di Rusia berdasarkan TensorFlow.  Algoritme mengeluarkan rekomendasi yang harus meningkatkan fungsi objektif;  data ini ditransfer kembali ke agen instalasi yang bekerja di dalam pengontrol.  Agen menerapkan perubahan dengan melakukan reset - sayangnya, itu harus me-restart database - dan kemudian proses berulang kembali.  Beberapa metrik runtime lebih banyak dikumpulkan, ditransfer ke algoritma, analisis kemungkinan peningkatan dan peningkatan produktivitas dilakukan, rekomendasi dikeluarkan, dan seterusnya, lagi dan lagi. <br><br><img src="https://habrastorage.org/webt/nz/qb/xc/nzqbxcp2ja9jbdwnaeoggdya0fw.png"><br><br>  Fitur utama dari OtterTune adalah algoritma hanya memerlukan informasi tentang metrik runtime sebagai input.  Kami tidak perlu melihat data dan permintaan pengguna Anda.  Kami hanya perlu melacak operasi baca dan tulis.  Ini adalah argumen yang kuat - data milik Anda atau pelanggan Anda tidak akan diungkapkan kepada pihak ketiga.  Kami tidak perlu melihat permintaan apa pun, algoritme hanya berfungsi berdasarkan metrik runtime, karena memberikan rekomendasi untuk regulator, dan bukan untuk desain fisik. <br><br>  Mari kita lihat demo OtterTune.  Di situs web proyek, kami akan menjalankan Postgres 9.6 dan memuat sistem dengan tes TPC-C.  Mari kita mulai dengan konfigurasi PostgreSQL awal, yang digunakan ketika diinstal pada Ubuntu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0e/7s/5o/0e7s5ohwzj1g_lfw-lxmi6_ibjm.png"></div><br><br>  Pertama, jalankan tes TPC-C selama lima menit, kumpulkan metrik runtime yang diperlukan, unggah ke layanan OtterTune, dapatkan rekomendasi, terapkan perubahannya, lalu ulangi prosesnya.  Kami akan kembali ke sini nanti.  Sistem database berjalan di satu komputer, layanan Tensor Flow di komputer lain, dan memuat data di sini. <br><br><img src="https://habrastorage.org/webt/6h/9d/yx/6h9dyxfovr6efc8m-a-znaguzgo.png"><br><br>  Lima menit kemudian, kami me-refresh halaman (demonstrasi dari bagian hasil ini dimulai saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ).  Ketika kami pertama kali mulai, dalam konfigurasi default untuk PostgreSQL, ada 623 transaksi per detik.  Kemudian, setelah menerima rekomendasi dan menerapkan perubahan sekali, jumlah transaksi <strong>meningkat menjadi 2300 per detik</strong> .  Perlu diakui bahwa demonstrasi ini telah diluncurkan beberapa kali, sehingga sistem sudah memiliki satu set data yang dikumpulkan sebelumnya.  Itu sebabnya solusinya sangat cepat.  Apa yang akan terjadi jika sistem tidak memiliki data yang dikumpulkan sebelumnya?  Algoritma ini adalah semacam fungsi langkah-demi-langkah, dan secara bertahap akan mencapai tingkat ini. <br><br><img src="https://habrastorage.org/webt/4q/ke/g3/4qkeg3wsp7yfxom1mojcv2mafhq.png"><br><br>  Setelah beberapa waktu dan lima iterasi, hasil terbaik adalah 2600. Kami beralih dari 600 transaksi per detik, dan mampu mencapai nilai 2600. Penurunan kecil muncul karena algoritma memutuskan untuk mencoba cara berbeda menyesuaikan regulator setelah mencapai hasil yang baik.  Hasilnya adalah margin, jadi penurunan besar dalam kinerja tidak terjadi.  Setelah menerima hasil negatif, algoritma dikonfigurasi ulang dan mulai mencari cara regulasi lainnya. <br><br>  Kami menyimpulkan bahwa Anda tidak perlu takut memulai strategi yang buruk, karena algoritma akan menjelajahi ruang solusi dan mencoba berbagai konfigurasi untuk mencapai kondisi perjanjian SLA.  Meskipun Anda selalu dapat mengkonfigurasi layanan sehingga algoritme memilih hanya meningkatkan solusi.  Dan seiring waktu, Anda akan menerima semua hasil terbaik dan terbaik. <br><br>  Sekarang kembali ke topik pembicaraan kita.  Saya akan memberi tahu Anda tentang hasil yang ada dari sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> diterbitkan di Sigmod.  Kami mengkonfigurasi MySQL dan PostgreSQL untuk TPC-C menggunakan OtterTune, untuk meningkatkan throughput. <br><br>  Bandingkan konfigurasi DBMS ini, yang digunakan secara default saat instalasi pertama di Ubuntu.  Selanjutnya, jalankan beberapa skrip konfigurasi sumber terbuka yang bisa Anda dapatkan dari Percona dan beberapa perusahaan konsultan lain yang bekerja dengan PostgreSQL.  Skrip ini menggunakan prosedur heuristik, seperti aturan bahwa Anda harus menetapkan ukuran buffer tertentu untuk perangkat keras Anda.  Kami juga memiliki konfigurasi dari Amazon RDS, yang sudah memiliki preset Amazon untuk peralatan yang sedang Anda kerjakan.  Kemudian bandingkan ini dengan hasil secara manual menyiapkan DBA mahal, tetapi dengan ketentuan bahwa mereka memiliki 20 menit dan kemampuan untuk mengatur parameter apa pun yang Anda inginkan.  Dan langkah terakhir adalah meluncurkan OtterTune. <br><br><img src="https://habrastorage.org/webt/vb/oi/gg/vboigg_vly5yx81jkjs4zjslsqa.jpeg"><br><br>  Untuk MySQL, Anda dapat melihat bahwa konfigurasi default jauh di belakang, skrip bekerja sedikit lebih baik, RDS sedikit lebih baik.  Dalam hal ini, hasil terbaik ditunjukkan oleh administrator basis data - administrator MySQL terkemuka dari Facebook. <br><br>  <strong>OtterTune hilang dari manusia</strong> .  Tetapi kenyataannya adalah bahwa ada regulator tertentu yang menonaktifkan sinkronisasi pembersihan log, dan ini tidak penting untuk Facebook.  Namun, kami telah menolak akses ke regulator OtterTune ini karena algoritme tidak tahu apakah Anda setuju untuk kehilangan lima milidetik data terakhir.  Menurut pendapat kami, keputusan ini harus diambil oleh seseorang.  Mungkin Facebook setuju dengan kerugian seperti itu, kita tidak tahu ini.  Jika kita menyesuaikan regulator ini dengan cara yang sama, kita dapat bersaing dengan orang tersebut. <br><br><blockquote>  Contoh ini menunjukkan bagaimana kita mencoba bersikap konservatif karena keputusan akhir harus diambil oleh orang tersebut.  Karena ada aspek-aspek tertentu dari database yang algoritma ML tidak sadari. </blockquote><br>  Dalam kasus PostgreSQL, skrip konfigurasi berfungsi dengan baik.  RDS sedikit lebih buruk.  Tetapi, perlu dicatat bahwa indikator OtterTune dalam hal ini melampaui orang tersebut.  Histogram menunjukkan hasil yang diperoleh setelah database diatur oleh Wisconsin Senior PostgreSQL Expert Advisor.  Dalam contoh ini, OtterTune dapat menemukan keseimbangan optimal antara ukuran file log dan ukuran kumpulan buffer, menyeimbangkan jumlah memori yang digunakan oleh dua komponen ini dan memastikan kinerja terbaik. <br><br>  Kesimpulan utama adalah bahwa layanan OtterTune menggunakan algoritma dan pembelajaran mesin sedemikian rupa sehingga kami dapat mencapai kinerja yang sama atau lebih baik dibandingkan dengan DBA yang sangat, sangat mahal.  Dan ini tidak hanya berlaku untuk satu contoh dari basis data, kita dapat mengatur skala pekerjaan hingga puluhan ribu salinan, karena ini hanya perangkat lunak, hanya data. <br><br><h2>  Peloton </h2><br>  Proyek kedua yang ingin saya bicarakan disebut Peloton.  Ini adalah sistem data yang sama sekali baru yang kami bangun dari awal di Carnegie Mellon.  Kami menyebutnya DBMS yang dikelola sendiri. <br><br>  Idenya adalah untuk mengetahui perubahan apa yang menjadi lebih baik yang dapat dilakukan jika Anda mengontrol seluruh tumpukan perangkat lunak.  Cara membuat pengaturan lebih baik daripada yang dapat dilakukan OtterTune, karena pengetahuan tentang setiap fragmen sistem, tentang seluruh siklus program. <br><br><img src="https://habrastorage.org/webt/av/8g/13/av8g13hhckp7k2adftmzn7tlv5a.png"><br><br>  Cara kerjanya: kami mengintegrasikan <strong>komponen pembelajaran mesin dengan penguatan</strong> ke dalam sistem basis data, dan kami dapat mengamati semua aspek perilakunya pada saat runtime, dan kemudian memberikan rekomendasi.  Dan kami tidak terbatas pada rekomendasi untuk menyesuaikan regulator, seperti yang terjadi di layanan OtterTune, kami ingin melakukan seluruh rangkaian tindakan standar yang saya bicarakan sebelumnya: memilih indeks, memilih skema partisi, skala vertikal dan horizontal, dll. <br><br>  <em>Nama sistem</em> <em>Peloton kemungkinan akan berubah.</em>  <em>Saya tidak tahu caranya di Rusia, tetapi di AS, istilah "</em> <em>peloton" berarti "tanpa rasa takut" dan "selesai", dan dalam bahasa Prancis itu berarti "peleton".</em>  <em>Namun di AS ada perusahaan sepeda olahraga</em> <em>Peloton yang memiliki banyak uang.</em>  <em>Setiap kali disebutkan tentang mereka, misalnya, pembukaan toko baru, atau iklan baru di TV, semua teman saya menulis kepada saya: "Lihat, mereka mencuri ide Anda, mencuri nama Anda."</em>  <em>Iklan menunjukkan orang-orang cantik yang mengendarai sepeda olahraga mereka, dan kami tidak bisa bersaing dengan ini.</em>  <em>Dan baru-baru ini,</em> <em>Uber mengumumkan perencana sumber daya baru bernama</em> <em>Peloton, sehingga kami tidak lagi dapat menyebutnya sistem kami.</em>  <em>Tapi kami belum memiliki nama baru, jadi dalam cerita ini saya masih akan menggunakan versi nama saat ini.</em> <br><br>  Pertimbangkan bagaimana sistem ini bekerja pada level tinggi.  Sebagai contoh, ambil database target, saya ulangi, ini adalah perangkat lunak kami, ini yang kami kerjakan.  Kami mengumpulkan riwayat beban kerja yang sama dengan yang saya tunjukkan sebelumnya.  Perbedaannya adalah bahwa kita akan menghasilkan model peramalan yang memungkinkan kita untuk memprediksi siklus kerja di masa depan, seperti apa persyaratan beban kerja di masa depan.  Itu sebabnya kami menyebut sistem ini DBMS yang dikelola sendiri. <br><br><blockquote>  Ide dasar DBMS yang dikelola sendiri mirip dengan ide mobil dengan kontrol otomatis. </blockquote><br>  Sebuah kendaraan tak berawak terlihat di depannya dan dapat melihat apa yang ada di depannya di jalan, dapat memprediksi cara mencapai tujuannya.  Sistem database yang berdiri sendiri bekerja dengan cara yang sama.  Anda harus dapat melihat ke masa depan dan membuat kesimpulan tentang seperti apa beban kerjanya dalam seminggu atau satu jam.  Lalu kami meneruskan data prediksi ini ke komponen perencanaan - kami menyebutnya otak-berjalan di Tensor Flow. <br><br>  Proses ini menggemakan karya AlphaGo dari London sebagai bagian dari proyek Google Deep Mind, di tingkat atas semuanya bekerja dalam skenario yang sama: Monte Carlo mencari pohon, hasil pencarian adalah berbagai tindakan yang harus dilakukan untuk mencapai tujuan yang diinginkan. <br><br>  Algoritme berikut kira-kira menentukan skema operasi: <br><br><ul><li>  Data sumber adalah serangkaian tindakan yang diperlukan, misalnya, menghapus indeks, menambahkan indeks, penskalaan vertikal dan horizontal, dan sejenisnya. </li><li>  Urutan tindakan dihasilkan, yang pada akhirnya mengarah pada pencapaian fungsi tujuan maksimum. </li><li>  Semua kriteria kecuali yang pertama dibuang, dan perubahan diterapkan. </li><li>  Sistem melihat efek yang dihasilkan, kemudian proses berulang-ulang. </li></ul><br><img src="https://habrastorage.org/webt/lt/5u/te/lt5uteozlshw-wvgoc8eh2qaj5s.png"><br><br>  Jangan terus-menerus menggunakan metafora mobil tak berawak, tetapi itulah cara mereka bekerja.  Ini disebut horizon perencanaan. <br><br>  Setelah melihat cakrawala di jalan, kami menempatkan diri kami pada titik imajiner untuk dicapai, dan kemudian kami mulai merencanakan serangkaian tindakan untuk mencapai titik ini di cakrawala: mempercepat, memperlambat, belok kiri, belok kanan, dll.  Kemudian kami secara mental membuang semua tindakan kecuali yang pertama yang perlu dilakukan, lakukan, dan kemudian ulangi proses itu lagi.  UAV menjalankan algoritme seperti itu 30 kali per detik.  Untuk basis data, proses ini sedikit lebih lambat, tetapi idenya tetap sama. <br><br>  Kami memutuskan untuk membuat sistem database kami sendiri <strong>dari awal, daripada membangun sesuatu di atas</strong> <strong>PostgreSQL atau</strong> <strong>MySQL</strong> , karena, jujur ​​saja, mereka terlalu lambat dibandingkan dengan apa yang ingin kami lakukan.  PostgreSQL itu indah, saya suka dan menggunakannya di kursus universitas saya, tetapi butuh terlalu banyak waktu untuk membuat indeks, karena semua data berasal dari disk. <br><br>  Dalam analogi dengan mobil, DBMS otonom pada PostgreSQL dapat dibandingkan dengan gerbong tak berawak.  Truk akan dapat mengenali anjing di depan jalan dan mengelilinginya, tetapi tidak jika ia berlari ke jalan langsung di depan mobil.  Maka tabrakan tidak bisa dihindari, karena truk tidak cukup bermanuver.  Kami memutuskan untuk membuat sistem dari awal agar dapat menerapkan perubahan secepat mungkin dan mencari tahu apa konfigurasi yang benar. <br><br>  Sekarang kami telah memecahkan masalah pertama dan menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> tentang kombinasi pembelajaran yang mendalam dan regresi linier klasik untuk seleksi otomatis dan prediksi beban kerja. <br><br>  Tetapi ada masalah yang lebih besar, di mana kami belum memiliki solusi yang baik - <strong>katalog tindakan</strong> .  Pertanyaannya bukan bagaimana memilih tindakan, karena orang-orang dari Microsoft sudah melakukan ini.  Pertanyaannya adalah bagaimana menentukan apakah satu tindakan lebih baik daripada yang lain, dalam hal apa yang terjadi sebelum penempatan dan setelah penempatan.  Cara membalikkan tindakan jika indeks yang dibuat oleh perintah seseorang tidak optimal, bagaimana Anda dapat membatalkan tindakan ini dan menunjukkan alasan pembatalan.  Selain itu, ada sejumlah tugas lain dalam hal interaksi sistem kita sendiri dengan dunia luar, di mana kita belum memiliki solusi, tetapi kita sedang mengusahakannya. <br><br>  <em>Ngomong-ngomong, saya akan menceritakan kisah yang menghibur tentang perusahaan basis data yang terkenal.</em>  <em>Perusahaan ini memiliki alat pemilihan indeks otomatis, dan alat itu punya masalah.</em>  <em>Satu klien secara konstan membatalkan semua indeks yang direkomendasikan dan diterapkan oleh alat.</em>  <em>Pembatalan ini sering terjadi sehingga alat digantung.</em>  <em>Dia tidak tahu apa strategi perilaku selanjutnya, karena solusi apa pun yang ditawarkan kepada seseorang menerima penilaian negatif.</em>  <em>Ketika pengembang beralih ke klien dan bertanya: "Mengapa Anda membatalkan semua rekomendasi dan saran pada indeks?", Klien menjawab bahwa ia sama sekali tidak menyukai nama mereka.</em>  <em>Orang bodoh, tetapi Anda harus berurusan dengan mereka.</em>  <em>Dan untuk masalah ini, saya juga tidak punya solusi.</em> <br><br><h2>  Merancang DBMS yang otonom </h2><br>  Diberikan dua pendekatan berbeda untuk membuat sistem basis data otonom, mari kita bicara sekarang tentang bagaimana merancang DBMS sehingga otonom. <br><br>  Mari kita bahas tiga topik: <br><br><ul><li>  cara menyesuaikan regulator, </li><li>  cara mengumpulkan metrik internal, </li><li>  bagaimana merancang aksi. </li></ul><br>  Sekali lagi, kembali ke poin utama: sistem database harus memberikan informasi yang benar ke algoritma pembelajaran mesin untuk adopsi selanjutnya dari keputusan yang lebih baik.  Jumlah data tidak berguna yang kami kirimkan harus dikurangi untuk meningkatkan kecepatan penerimaan tanggapan. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sudah mengatakan bahwa regulator mana pun yang mengharuskan seseorang untuk membuat penilaian penilaian dalam komponen otonom harus ditandai sebagai dilarang. </font><font style="vertical-align: inherit;">Kita perlu menandai parameter ini di pengaturan </font></font><code>PG_SETTINGS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau file konfigurasi lainnya untuk mencegah algoritma mengakses pengontrol ini.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkenaan dengan parameter seperti jalur file, tingkat isolasi, persyaratan stabilitas transaksi, dll. </font><font style="vertical-align: inherit;">keputusan harus dibuat oleh manusia, bukan oleh algoritma.</font></font></blockquote><br>   ,          ,    , ,        . <br><br>   ,    ,     ,      . <br><br>     : <br><br><ul><li> <strong> </strong> .    ,      ,       . </li><li> <strong>      </strong> .     ,      ,     -1  0,     . </li><li> <strong>   </strong> ,     . ,     .     64- ,       0  2 <sup>64</sup> .          ,      . </li></ul><br>        ,    .     ,        10 ,         ,     10 .     ,        . <br><br>  -   ,    .  , ,   . ,     ,        ,        . <br><br>   ,       , ,    .        ,     .        ,  ,     ,  —     .      ,      . <br><br>  ,     ,     ,   .           ,      . <br><br> ,       ,      .        ,        :     ,    ,    ,   ,    .       -       Oracle,         ,       . <br><br><img src="https://habrastorage.org/webt/hp/7z/1p/hp7z1pthfae3wegk-k3jdbggzvs.png"><br><br> ,        ,            . <br><br>   ,     ,      .     ,  ,  ,     .   -   ,   ,   ,   .  :    PostgreSQL             ,            . <br><br><img src="https://habrastorage.org/webt/rb/mq/_x/rbmq_xap9pleuyrmfnrw2ofevbg.png"><br><br>       ,       ,      ,     . <br><br>   - ,   ,    ,         .  ,    ,       .    RocksDB,   MyRocks  MySQL. <br><br> RocksDB     .       ,        .  ,    ,      ,       .       RocksDB,      . <br><br><img src="https://habrastorage.org/webt/r4/i0/d8/r4i0d82qeejj7rhh1f6fftdd1ua.png"><br><br>    ,       ,    ,      ,  .  MyRocks       .      —      : <code>ROCKSDB_BITES_READ, ROCKSDB_BITES_WRITTEN</code> .      ,    ,      .   ,                .     ,        . <br><br><img src="https://habrastorage.org/webt/uh/dh/3z/uhdh3zbip3urg8cdphihobpsine.png"><br><br><blockquote> , ,      ,                 . </blockquote><br>       ,   ,   open source.          ,        . <br><br>    ,    ,  <strong>    </strong> .  MySQL  ,       .       ,    .         5 ,      10 ,        ,       .     5   ,     —      . <br><br>     ,          .          — PostgreSQL    . <br><br>  —    .   ,    . ,   ,     ,   ,        . <br><br>        .     ,        —       SLA.       ,     . <br><br>  ,     .   ,           .       ,      .   ,       . <br><br><img src="https://habrastorage.org/webt/8a/yg/zk/8aygzkmzaogstbgocmxpypcwpjq.png"><br><br> ,       -   ,     .     ,       ,  -  ,   . ,  ,    ,    —    ,     -, ,        . <br><br>    ,  ,      ,        . <br><br> ,         .  ,  ,     ,      ,    5-  .     downtime,        . <br><br>   ,       ,    ,   ,    ,           .  ,           ,     ,     ,    . <br><br><h2> Oracle autonomous database </h2><br>      <strong>  </strong> <strong>Oracle</strong> .  2017  Oracle ,        .  ,     Oracle,     ,  «  ,   Oracle   20 ». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/-f/-d/zo-f-daby9ck_ghomdje3fpny_8.png"></div><br><br> <em>    .  ,       , ,   ,    ,        .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  </em> <em>CIDR     ,     .     ,   : «,    ,    ,       . ,        ,     , </em> <em>Oracle       ?»      ,   —       .</em> <br><br> ,    ,      ,  Oracle.   ,      . <br><br> ,  <strong>  </strong> —   ,       ,       ,         - . <br><br>    — <strong> ,   </strong> .  ,    ,     ,      2000- .   ,  Oracle    ,     .      ,     :   ,    —      -      . <br><br>   ,      .     ,      ,     . <br><br>   — <strong>  </strong> .        ,      .     :      JOIN.        .           .         ,       .             . <br><br>        Oracle. Microsoft  2017   SQL Server,    .  IBM DB2   00-   ,   «LEO» —  .   ,  1970-,      Ingres.    ,        JOIN,    ,    .       . <br><br><blockquote>        ,     ,      . </blockquote><br>     ,   ,         .   ,    ,      . ,   ,  . <br><br>  ,     ,     —  ,     ,    ,      .  ,   ,  ,      .   ,    ,       ..,     . <br><br><blockquote> HighLoad++    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad++ Siberia</a>  .     ,    39   ,   ,    highload- -        . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad++</a>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> .           ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UseData Conf</a> —  16 ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,       . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456580/">https://habr.com/ru/post/id456580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456564/index.html">Daftar pengguna dengan kata sandi yang lemah di MS SQL</a></li>
<li><a href="../id456568/index.html">Pengembang sekarang diukur dalam tampilan dan pelanggan - dan itu salah</a></li>
<li><a href="../id456570/index.html">Jumat 21 Juni ini akan menjadi hari jadi DevConfX, 22 Juni kelas master eksklusif</a></li>
<li><a href="../id456572/index.html">Advergaming 40 tahun - retrospektif dari iklan video game</a></li>
<li><a href="../id456578/index.html">Konsep VueJS untuk pengembang backend - kelas master 22 Juni</a></li>
<li><a href="../id456582/index.html">Mengapa Internet masih online?</a></li>
<li><a href="../id456594/index.html">2 menit dengan goyangan pohon Webpack dan ekspor kembali</a></li>
<li><a href="../id456596/index.html">Mikrobiota. Bagaimana cara kerja pengujian?</a></li>
<li><a href="../id456600/index.html">Resep Nginx: otorisasi LDAP dengan captcha</a></li>
<li><a href="../id456602/index.html">Panduan untuk Menerapkan Langganan yang Dapat Diperbarui Secara Otomatis di Aplikasi iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>