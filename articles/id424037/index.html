<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 ⏏️ ⛰️ Tur singkat GraphQL 🍕 🚓 🕔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 


 Buku karya Alex Banks dan Eva Porsello, yang kami berikan untuk terjemahan beberapa hari yang lalu, akan membantu Anda sebagai penyimp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tur singkat GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/424037/">  Halo, Habr! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/02/xc/fq02xcxho24foozvi0yg3k35km4.jpeg"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku karya</a> Alex Banks dan Eva Porsello, yang kami berikan untuk terjemahan beberapa hari yang lalu, akan membantu Anda sebagai penyimpangan singkat ke dalam bahasa query GraphQL.  Buku penulis yang sama tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React dan Redux</a> menjadi buku terlaris yang sesungguhnya (kami sedang menunggu cetakan kelima dari percetakan).  Omong-omong, terima kasih kepada semua orang yang menunjukkan kepada kami ketidaktepatan dalam kode dan ketentuan;) kami membuat buku tentang teknologi yang begitu cepat usang terlalu cepat. <br><br>  Penulis artikel hari ini, Robin Viruch, juga mengerjakan sebuah buku tentang GraphQL dan perpustakaan untuk bahasa ini, dan dalam artikel hari ini ia menjelaskan secara singkat kelebihan dan karakteristik GraphQL sebagai alternatif untuk REST. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ud/um/yb/udumybonjvas4ywnznkpeedukpm.jpeg"><br><br>  Ketika datang ke permintaan jaringan antara aplikasi klien dan server, REST paling sering dipilih sebagai jembatan antara dunia klien dan server.  Dalam REST, segala sesuatu berkembang di sekitar gagasan "kita membutuhkan sumber daya yang dapat diakses dengan URL".  Anda dapat membaca sumber daya menggunakan <code>HTTP GET</code> , membuat sumber daya menggunakan permintaan <code>HTTP POST</code> , dan memperbarui dan menghapusnya menggunakan permintaan <code>HTTP PUT</code> dan <code>DELETE</code> .  Operasi ini disebut CRUD (Buat, Baca, Perbarui, Hapus).  Sumber daya dapat berupa konten apa pun yang diterima dari penulis, pengguna, atau diambil dari artikel.  Saat menggunakan REST, format transfer data tidak hardcode, tetapi paling sering JSON digunakan untuk tujuan ini.  Pada akhirnya, REST memungkinkan komunikasi antara aplikasi melalui protokol HTTP normal menggunakan URL dan metode HTTP. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    REST GET https://api.domain.com/authors/7 //   JSON { "id": "7", "name": "Robin Wieruch", "avatarUrl": "https://domain.com/authors/7", "firstName": "Robin", "lastName": "Wieruch" }</span></span></code> </pre> <br>  Meskipun REST tetap menjadi standar de facto cukup lama, dalam beberapa tahun terakhir teknologi lain yang dikembangkan oleh Facebook telah mendapatkan popularitas: itu disebut GraphQL.  Artikel ini, pengantar GraphQL, berbicara tentang pro dan kontra dari bahasa query ini. <br><br>  <b>Apa itu GraphQL?</b> <br><br>  Sebelum menyelam ke dalam diskusi tentang kekuatan dan kelemahan GraphQL, mari kita jawab pertanyaan berikut: apa itu GraphQL?  GraphQL adalah <b>bahasa permintaan</b> freeware <b>yang</b> dibuat oleh Facebook pada tahun 2012.  Bahkan sebelum mengirimkan produk ke open source, bahasa itu sudah digunakan di Facebook sebagai teknologi internal untuk bekerja dengan aplikasi mobile.  Mengapa dengan aplikasi seluler?  GraphQL dikembangkan sebagai alternatif arsitektur REST.  Ini memungkinkan klien hanya untuk meminta data yang diinginkan - tidak lebih, tidak kurang.  Pelanggan bertanggung jawab atas segalanya, yaitu Anda.  Dalam hal ini, kesulitan muncul dalam arsitektur REST, karena itu adalah antarmuka basis data yang menentukan informasi apa yang akan tersedia untuk setiap sumber daya di setiap URL.  Pengambilan sampel data tidak diminta di bagian klien.  Karena itu, frontend dalam hal apa pun harus meminta semua informasi tentang sumber daya, bahkan jika itu hanya memerlukan sebagian dari data ini.  Masalah ini disebut "re-sampling".  Dalam skenario terburuk, aplikasi klien harus membaca tidak hanya satu, tetapi banyak sumber daya, untuk akses yang diperlukan untuk melakukan banyak permintaan jaringan.  Hal ini menyebabkan tidak hanya pengambilan sampel ulang, tetapi juga permintaan seperti longsoran salju melalui jaringan.  Namun, memiliki bahasa query seperti GraphQL, yang digunakan tidak hanya di server, tetapi juga di sisi klien, klien memutuskan data apa yang dia butuhkan - dan untuk ini hanya mengirim satu permintaan ke server.  Ketika Facebook mengembangkan aplikasi seluler menggunakan bahasa GraphQL, adalah mungkin untuk secara drastis mengurangi beban jaringan, karena jauh lebih sedikit data yang mulai dikirim melalui itu. <br><br>  Facebook memposting spesifikasi GraphQL dan implementasi rujukannya di JavaScript untuk akses gratis.  Sejak itu, spesifikasi ini telah diimplementasikan dalam banyak bahasa pemrograman utama lainnya.  Selain itu, ekosistem yang telah berkembang di sekitar GraphQL tumbuh tidak hanya secara horizontal, menyebar ke bahasa pemrograman lain, tetapi juga secara vertikal (perpustakaan dibangun di atas GraphQL, misalnya, Apollo, Relay). <br><br>  GraphQL menyediakan jenis operasi berikut: permintaan (baca), ubah (tulis) atau berlangganan (baca terus-menerus).  Setiap operasi ini hanyalah string yang harus dirakit sesuai dengan spesifikasi bahasa query GraphQL.  Segera setelah operasi GraphQL tiba di aplikasi database dari aplikasi klien, itu dapat ditafsirkan dibandingkan dengan seluruh skema GraphQL yang terletak di backend dan diizinkan untuk aplikasi klien menggunakan data yang tersedia.  GraphQL berfungsi sama baiknya dengan lapisan jaringan apa pun (yang sering diatur melalui HTTP), serta dengan format muatan apa pun (seringkali JSON).  Dia juga sepenuhnya "tidak peduli" dengan arsitektur aplikasi (yang dalam kebanyakan kasus terdiri dari bagian klien dan antarmuka basis data).  Itu hanya bahasa query. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  GraphQL author(id: "7") { id name avatarUrl articles(limit: 2) { name urlSlug } } //   GraphQL { "data": { "author": { "id": "7", "name": "Robin Wieruch", "avatarUrl": "https://domain.com/authors/7", "articles": [ { "name": "The Road to learn React", "urlSlug": "the-road-to-learn-react" }, { "name": "React Testing Tutorial", "urlSlug": "react-testing-tutorial" } ] } } }</span></span></code> </pre> <br>  Seperti yang dapat Anda lihat, kueri sudah berlaku untuk banyak sumber daya (penulis, artikel), yang disebut bidang dalam GraphQL, dan hanya sekumpulan bidang bersarang khusus untuk bidang ini (nama, urlSlug untuk artikel), meskipun data lain dapat disediakan dalam skema data GraphQL itu sendiri Informasi (misalnya, untuk artikel - deskripsi, tanggal rilis).  Sedangkan dalam arsitektur REST, kita membutuhkan setidaknya dua permintaan kaskade untuk mengambil penulis dan artikel dari penulis ini, GraphQL memecahkan masalah ini dalam satu permintaan.  Selain itu, kueri hanya memilih bidang yang diperlukan, dan bukan seluruh entitas. <br><br>  Ini adalah inti dari GraphQL.  Dalam kasus di mana aplikasi server menyediakan skema GraphQL di mana ia mendefinisikan semua data yang tersedia dengan hierarki dan jenisnya, aplikasi klien hanya meminta data yang dibutuhkan. <br><br>  <b>Manfaat GraphQL</b> <br><br>  Berikut ini adalah manfaat utama menggunakan GraphQL dalam suatu aplikasi. <br><br>  <i><b>Sampling Data Deklaratif</b></i> <br><br>  Seperti yang Anda lihat, GraphQL menggunakan pengambilan sampel data deklaratif dalam kueri.  Klien memilih data, entitasnya dan semua bidang di antaranya ada berbagai hubungan, dan untuk semua ini satu permintaan diterapkan.  Klien memutuskan bidang mana yang diperlukan untuk UI ini.  Seringkali, Anda hampir dapat berbicara tentang pengambilan sampel data yang berorientasi UI.  Misalnya, ini adalah bagaimana Airbnb menggunakan GraphQL.  Mesin pencari Airbnb sering memberikan hasil untuk rumah, tayangan, dan kategori lainnya yang spesifik untuk area subjek tertentu.  Untuk mengekstrak semua data dalam sekali jalan, permintaan GraphQL dijalankan, hanya mengambil informasi yang pasti diperlukan di UI tertentu.  Pada akhirnya, pembagian tanggung jawab diatur secara sempurna dalam GraphQL: klien tahu tentang persyaratan data, server tahu tentang struktur data dan cara menyelesaikan data dari sumber yang ada (baik itu basis data, layanan mikro, API pihak ketiga). <br><br>  <i><b>Tidak ada pengambilan sampel ulang saat bekerja dengan GraphQL</b></i> <br><br>  Saat bekerja dengan GraphQL, tidak ada pemilihan ulang.  Sedangkan klien seluler cenderung melakukan pengambilan ulang menggunakan API yang sama dengan klien web dengan REST-API.  Dan ketika bekerja dengan GraphQL, klien seluler dan klien web dapat memilih kelompok bidang yang berbeda untuk dirinya sendiri, menggunakan GraphQL API yang sama.  Akibatnya, klien seluler dapat memilih lebih sedikit informasi, karena informasi yang tidak perlu mungkin tidak diperlukan pada layar kecil (tidak seperti monitor besar dari mana versi web aplikasi dilihat).  GraphQL meminimalkan jumlah data yang dikirim melalui jaringan, memilihnya secara selektif dan dipandu dalam hal ini terutama oleh kebutuhan aplikasi klien. <br><br>  <i><b>GraphQL untuk Bereaksi, Sudut, Node, dll.</b></i> <br><br>  GraphQL adalah solusi yang menjanjikan tidak hanya untuk Pengembang Bereaksi.  Biarlah Facebook yang mengalahkan GraphQL, dan di sisi klien, Facebook menggunakan React, pada kenyataannya, bahasa ini tidak terikat dengan solusi apa pun untuk frontend atau backend.  Implementasi referensi GraphQL ditulis dalam JavaScript, sehingga GraphQL dapat dikombinasikan dengan Angular, Vue, Express, Hapi, Koa dan perpustakaan JavaScript lainnya di bagian klien dan server.  Selain itu, ini tidak hanya berlaku untuk ekosistem JavaScript.  GraphQL meniru REST dalam satu aspek, karena menjadi populer: antarmuka GraphQL tidak tergantung pada bahasa pemrograman (bahasa permintaan) yang digunakan untuk mengomunikasikan dua objek (mis., Klien dan server).  Oleh karena itu, spesifikasinya dapat direproduksi dalam bahasa pemrograman apa pun. <br><br>  <i><b>Siapa yang menggunakan GraphQL?</b></i> <br><br>  Facebook telah menggunakan GraphQL sejak 2012, sebelum bahasa ini menjadi open source.  Facebook adalah kekuatan pendorong yang bertanggung jawab untuk mengembangkan spesifikasi GraphQL dan implementasi referensi dalam JavaScript.  Jadi, bekerja dengan GraphQL, Anda sudah berdiri di atas bahu raksasa.  Namun, perusahaan terkenal lainnya menggunakan bahasa ini dalam aplikasi mereka.  Mereka berinvestasi dalam ekosistem GraphQL, karena aplikasi modern sangat membutuhkan bahasa seperti itu.  Jadi, Anda akan didukung tidak hanya oleh Facebook, tetapi juga oleh perusahaan-perusahaan berikut: <br><br><ul><li>  GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> </li><li>  Shopify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coursera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yelp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wordpress</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kali baru york</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Samsara</a> </li><li>  dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> ... </li></ul><br>  Ketika Facebook mengembangkan GraphQL dan membuatnya tersedia untuk umum, perusahaan aplikasi seluler lain juga menghadapi masalah serupa.  Ini adalah bagaimana Netflix menciptakan proyek Falcor, yang dapat dianggap sebagai alternatif untuk GraphQL.  Yang sekali lagi menegaskan bahwa untuk aplikasi modern Anda membutuhkan solusi seperti GraphQL dan Falcor. <br><br>  <i><b>Satu Sumber Kebenaran</b></i> <br><br>  Dalam aplikasi GraphQL, kebenaran sesungguhnya ada: ini adalah skema GraphQL.  Itu dia - sumber pusat, yang menggambarkan semua data yang tersedia.  Sedangkan skema GraphQL biasanya didefinisikan di sisi server, klien dapat membaca (query) dan menulis (memodifikasi) data berdasarkan skema ini.  Dengan demikian, aplikasi server, pada intinya, menyediakan informasi komprehensif yang tersedia di server, dan sisi klien hanya menanyakan apa yang diperlukan dengan merumuskan pertanyaan dalam GraphQL, atau mengubah fragmen informasi kecil menggunakan perubahan pada GraphQL. <br><br>  <i><b>GraphQL mengikuti tren saat ini</b></i> <br><br>  GraphQL mengikuti tren saat ini dalam pengembangan aplikasi.  Anda hanya dapat memiliki satu aplikasi di backend, tetapi sering terjadi bahwa banyak klien berbeda menggunakan backend ini (klien web, perangkat seluler, jam tangan pintar ...) dan semuanya tergantung pada data yang disimpan dalam aplikasi backend.  Oleh karena itu, GraphQL dapat membantu tidak hanya membuat teman "kedua dunia", tetapi juga memenuhi persyaratan dari setiap klien (terkait, misalnya, menggunakan jaringan, hubungan data bersarang, memilih hanya data yang diperlukan) tanpa perlu membuat API khusus untuk setiap jenis klien. <br><br>  Di sisi lain, di server kita tidak dapat mengharapkan antarmuka internal tunggal, tetapi sekelompok layanan microser, yang masing-masing menyediakan fungsi spesifiknya sendiri.  Untuk kasus seperti itu skema GraphQL cocok, strukturnya sedemikian rupa sehingga dalam skema GraphQL seperti itu dimungkinkan untuk menggabungkan semua jenis fungsionalitas. <br><br>  <i><b>Bagaimana Jahitan Skema GraphQL</b></i> <br><br>  Berkat menjahit, Anda dapat membuat satu skema dari banyak skema lainnya.  Kapan saya bisa masuk ke dalam situasi ini?  Katakanlah backend Anda diimplementasikan menggunakan arsitektur microservice.  Setiap layanan mikro memproses logika bisnis dan data yang terkait dengan bidang subjek tertentu.  Oleh karena itu, setiap layanan mikro dapat menentukan skema GraphQL sendiri.  Setelah itu, Anda harus menjahitnya bersama untuk merakit salah satu dari semua skema, yang akan diakses oleh aplikasi klien.  Pada akhirnya, setiap layanan microser mungkin memiliki terminal GraphQL sendiri, dan satu gateway API GraphQL akan menggabungkan semua skema menjadi satu skema global untuk menyediakannya ke aplikasi klien. <br><br>  <i><b>Introspeksi GraphQL</b></i> <br><br>  Introspeksi GraphQL adalah kemampuan untuk mengekstrak skema GraphQL dengan GraphQL API.  Karena skema berisi semua informasi tentang semua data yang tersedia melalui GraphQL API, skema ini dapat digunakan dengan sangat sukses untuk pembuatan otomatis dokumentasi API.  Namun, masalahnya tidak terbatas pada mendokumentasikan API;  introspeksi juga dapat digunakan untuk mensimulasikan skema GraphQL pada aplikasi klien (untuk tujuan pengujian) atau untuk mengambil skema dari beberapa layanan mikro dan kemudian menjahitnya bersama-sama. <br><br>  <i><b>GraphQL Sangat Diketik</b></i> <br><br>  GraphQL adalah bahasa permintaan yang sangat diketik yang ditulis dalam Bahasa Definisi Skema ekspresif (SDL) untuk GraphQL.  Bahasa ini memiliki kelebihan yang sama dengan bahasa pemrograman yang diketik dengan kuat.  Ini kurang rentan kesalahan, dapat divalidasi pada waktu kompilasi dan dapat diandalkan untuk integrasi dengan fitur IDE / editor yang didukung seperti pelengkapan otomatis dan dukungan input. <br><br>  <i><b>Versi GraphQL</b></i> <br><br>  GraphQL tidak memiliki versi API seperti yang biasa kita gunakan di REST.  Di REST, adalah normal untuk menawarkan beberapa versi API yang sama (mis. Api.domain.com/v1/, api.domain.com/v2/), karena sumber daya atau strukturnya dapat berubah seiring waktu.  Di GraphQL, Anda bisa menerjemahkan API ke yang tidak direkomendasikan di tingkat bidang.  Oleh karena itu, klien menerima peringatan ketika mengakses bidang yang tidak direkomendasikan.  Setelah beberapa waktu, bidang yang tidak direkomendasikan dapat dikecualikan dari skema, maka tidak ada lagi klien yang akan menggunakannya.  Dengan demikian, API GraphQL dapat dikembangkan tanpa perlu versi. <br><br>  <i><b>Berkembangnya Ekosistem GraphQL</b></i> <br><br>  Ekosistem GraphQL tumbuh.  Ini bukan hanya tentang integrasi dengan editor dan IDE yang terkait dengan sifat GraphQL yang sangat diketik;  untuk GraphQL seperti itu, ada aplikasi baru yang lengkap.  Misalnya, Anda dapat memanggil Postman, yang digunakan saat bekerja dengan REST API, dan sekarang untuk tujuan yang sama, tetapi dengan GraphQL API, GraphiQL atau GraphQL Playground digunakan.  Ada juga berbagai perpustakaan untuk Anda, misalnya, Gatsby.js, generator situs web statis untuk Bereaksi yang menggunakan GraphQL.  Misalnya, Gatsby.js memungkinkan Anda untuk menulis mesin blog yang mengisi blog Anda dengan konten selama pembuatan melalui API GraphQL.  Karenanya, Anda juga akan memiliki CMS tanpa bagian klien (mis. GraphCMS) yang menyediakan konten (untuk blog) melalui GraphQL.  API  Namun, tidak hanya komponen teknologi yang berkembang di bidang ini.  Seiring jamur tumbuh setelah hujan, konferensi, mitaps, dan komunitas yang didedikasikan untuk GraphQL juga mudah ditemukan di dalamnya, buletin dan podcast. <br><br>  <i><b>Jika saya beralih ke GraphQL - apakah saya akan melakukan semuanya?</b></i> <br><br>  Menambahkan GraphQL ke tumpukan teknologi yang ada, kami, tentu saja, tidak masuk all-in.  Bermigrasi dari aplikasi back-end monolitik ke arsitektur layanan microsoft, yang paling penting adalah mengganti GraphQL API untuk layanan microsoft baru.  Memang, justru di hadapan banyak layanan microser Anda dan tim Anda dapat dengan aman mengimplementasikan gateway GraphQL, skema menjahit dan menggabungkannya menjadi satu skema global.  Tetapi gateway API dapat digunakan tidak hanya dengan layanan microser, tetapi juga dengan aplikasi REST monolitik.  Ini adalah bagaimana Anda dapat menggabungkan semua API Anda di satu gerbang dan bermigrasi ke GraphQL langkah demi langkah. <br><br>  <b>Kerugian dari GraphQL</b> <br><br>  Selanjutnya, kita membahas beberapa kelemahan yang terkait dengan penggunaan GraphQL. <br><br>  <i><b>Kompleksitas Permintaan GraphQL</b></i> <br><br>  Terkadang GraphQL digunakan secara tidak benar, saya mencoba menggantinya dengan database sisi server.  Tidak, itu tidak akan berhasil.  GraphQL hanyalah bahasa query.  Ketika di sisi server permintaan harus diselesaikan dengan data, biasanya ada implementasi GraphQL-independen yang menyediakan akses ke database.  GraphQL acuh tak acuh dalam hal ini.  Selain itu, GraphQL tidak menghilangkan hambatan kinerja ketika Anda perlu mengatasi banyak bidang (penulis, artikel, komentar) dalam satu permintaan.  Terlepas dari arsitektur tempat permintaan dibuat - RESTful atau GraphQL, Anda masih harus mengekstrak berbagai bidang dari sumbernya. <br><br>  Dengan demikian, kami akan memiliki masalah jika klien segera mengirim banyak permintaan ke kumpulan bidang yang disarangkan.  Seringkali, pengembang sisi klien tidak tahu berapa banyak permintaan basis data yang berbeda harus diproses dalam aplikasi server jika panggilan data massal dimulai.  Untuk kasus-kasus seperti itulah diperlukan suatu mekanisme (misalnya, kedalaman kueri maksimum, menimbang kompleksitas kueri, menghindari rekursi, kueri konstan) untuk mencegah aliran kueri yang terlalu mahal dari klien. <br><br>  <i><b>Batas kecepatan dalam GraphQL</b></i> <br><br>  Masalah lain adalah keterbatasan kecepatan.  Sementara di REST relatif sederhana untuk mengatakan "tidak lebih dari begitu banyak pertanyaan yang diizinkan per hari", sulit untuk merumuskan instruksi semacam itu untuk operasi GraphQL individu, karena tidak hanya ada operasi "mahal" dan "tidak mahal", tetapi juga banyak gradasi menengah.  Untuk kasus-kasus seperti itulah perusahaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyediakan API GraphQL publik menawarkan perhitungan batas kecepatannya sendiri</a> , sering kali dikurangi menjadi nilai maksimum yang disebutkan sebelumnya dari kedalaman kueri dan bobot kompleksitas kueri. <br><br>  <i><b>Caching GraphQL</b></i> <br><br>  Ketika bekerja dengan GraphQL, menerapkan cache yang disederhanakan jauh lebih rumit daripada di REST.  Saat bekerja dengan REST, kami mengakses sumber daya dengan URL dan, karenanya, dapat mengatur caching di tingkat sumber daya, karena URL sumber daya dapat berfungsi sebagai pengenalnya.  Dalam GraphQL, ini rumit karena semua kueri bisa berbeda, meskipun semua orang beroperasi pada objek yang sama.  Dalam satu permintaan, Anda dapat meminta nama penulis, dan permintaan berikutnya - tidak hanya nama penulis, tetapi juga alamat emailnya.  Untuk kasus-kasus seperti itu Anda akan membutuhkan cache lebih banyak kerawang di tingkat lapangan, dan tidak begitu mudah untuk mengimplementasikannya.  Namun, sebagian besar perpustakaan yang dibangun di atas GraphQL menawarkan mekanisme caching seperti itu langsung dari kotak. <br><br>  <b>Kenapa tidak REST?</b> <br><br> GraphQL –      REST,     .     REST –      GraphQL,      REST? <br>   REST  URL   ,       .     «»,   id,       ,   id.  GraphQL        ,       .  ,       ,      ,  GraphQL       ,   . <br><br>          ,    REST.        Airbnb.   ,       .        REST-,   REST-       .    , ,  GraphQL API,          GraphQL,      (,   ),      (.,   ). <br><br>   , GraphQL     ;   ,    ,    ,      .          GraphQL –    Facebook   ,  -. <br><br> ,    ,   REST –       .       ,             GraphQL. ,     GraphQL,        - . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424037/">https://habr.com/ru/post/id424037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424027/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 2</a></li>
<li><a href="../id424029/index.html">Dan lagi tentang kemalasan</a></li>
<li><a href="../id424031/index.html">Pemrograman reaktif dengan JAX-RS</a></li>
<li><a href="../id424033/index.html">Apa yang dilakukan Kotlin: wawancara dengan Andrei Breslav</a></li>
<li><a href="../id424035/index.html">2019 adalah tahun Intel berhenti</a></li>
<li><a href="../id424039/index.html">Kriptografi setelah pendaratan alien</a></li>
<li><a href="../id424041/index.html">Pengantar Singkat untuk Biologi Sel</a></li>
<li><a href="../id424043/index.html">Trik topi yang cerah. Ada tiga desa di Dobrovlyany di Ukraina. Dan ketiganya memiliki pembangkit listrik tenaga surya yang kuat</a></li>
<li><a href="../id424045/index.html">Beberapa trik terkadang diperlukan saat bekerja dengan git</a></li>
<li><a href="../id424049/index.html">Kami menyajikan buku "Harry Potter dan metode berpikir rasional" untuk Olimpiade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>