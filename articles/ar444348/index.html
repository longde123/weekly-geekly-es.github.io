<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌃 🎸 🏴‍☠️ كيف تختلف مكونات React الوظيفية عن المكونات القائمة على الفصل؟ 👉🏿 🔽 📌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كيف تختلف مكونات React الوظيفية عن المكونات القائمة على الفصل؟ لبعض الوقت الآن ، الإجابة التقليدية على هذا السؤال هي: "إن استخدام الفئات يسمح لك باستخ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف تختلف مكونات React الوظيفية عن المكونات القائمة على الفصل؟</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/" style=";text-align:right;direction:rtl">  كيف تختلف مكونات React الوظيفية عن المكونات القائمة على الفصل؟  لبعض الوقت الآن ، الإجابة التقليدية على هذا السؤال هي: "إن استخدام الفئات يسمح لك باستخدام عدد كبير من إمكانات المكونات ، على سبيل المثال ، الحالة".  الآن ، مع ظهور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الخطافات</a> ، لم تعد هذه الإجابة تعكس الحالة الحقيقية للأمور. <br><br>  ربما تكون قد سمعت أن أحد هذه الأنواع من المكونات لديه أداء أفضل من الآخر.  لكن أي واحد؟  معظم المعايير التي تختبر ذلك بها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عيوب</a> ، لذلك أود أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أستخلص النتائج</a> بناءً على نتائجها بحذر شديد.  يعتمد الأداء بشكل أساسي على ما يحدث في التعليمات البرمجية ، وليس على ما إذا كان يتم اختيار المكونات الوظيفية أو المكونات المستندة إلى الفصل لتنفيذ إمكانات معينة.  أظهرت دراستنا أن الفرق في الأداء بين أنواع مختلفة من المكونات لا يكاد يذكر.  ومع ذلك ، تجدر الإشارة إلى أن استراتيجيات التحسين المستخدمة للعمل معهم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تختلف</a> قليلاً. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br>  على أي حال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لا أوصي</a> بإعادة كتابة المكونات الموجودة باستخدام تقنيات جديدة إذا لم تكن هناك أسباب وجيهة لذلك ، وإذا كنت لا تمانع في أن تكون من بين أولئك الذين بدأوا في استخدام هذه التقنيات قبل أي شخص آخر.  لا تزال الخطافات تقنية جديدة (كما كانت مكتبة React في عام 2014) ، ولم يتم تضمين بعض "أفضل الممارسات" لتطبيقها في أدلة React. <br><a name="habracut"></a><br>  إلى أين أتينا أخيرًا؟  هل هناك أي اختلافات جوهرية بين المكونات الوظيفية في React والمكونات القائمة على الطبقات؟  بالطبع ، هناك مثل هذه الاختلافات.  هذه اختلافات في النموذج العقلي لاستخدام هذه المكونات.  في هذه المقالة سأنظر في الفرق الأكثر خطورة.  لقد كان موجودًا منذ ظهور المكونات الوظيفية في عام 2015 ، ولكن غالبًا ما يتم تجاهله.  يتكون في حقيقة أن المكونات الوظيفية تلتقط القيم المقدمة.  دعنا نتحدث عن ما يعنيه هذا حقا. <br><br>  تجدر الإشارة إلى أن هذه المادة لا تشكل محاولة لتقييم مكونات الأنواع المختلفة.  أصف الفرق بين نموذجي البرمجة في React.  إذا كنت ترغب في معرفة المزيد حول استخدام المكونات الوظيفية في ضوء الابتكارات ، فراجع قائمة الأسئلة والأجوبة على الروابط. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">ما هي ميزات رمز المكونات بناءً على الوظائف وعلى الفئات؟</font> </h2><br>  النظر في هذا المكون: <br><br><pre style=";text-align:right;direction:rtl"><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br>  يعرض زرًا ، يعمل بالضغط على وظيفة <code>setTimeout</code> محاكاة طلب شبكة ، ثم يعرض مربع رسالة لتأكيد العملية.  على سبيل المثال ، إذا تم تخزين " <code>props.user</code> <code>'Dan'</code> في <code>props.user</code> ، فسيتم عرض <code>'Followed Dan'</code> في نافذة الرسائل ، بعد ثلاث ثوانٍ. <br><br>  لاحظ أنه لا يهم ما إذا كان يتم استخدام وظائف السهم أو إعلانات الوظائف هنا.  <code>function handleClick()</code> النموذج <code>function handleClick()</code> بنفس الطريقة تمامًا. <br><br>  كيفية إعادة كتابة هذا المكون كصف؟  إذا قمت للتو بإعادة الكود الذي تم فحصه للتو ، وتحويله إلى رمز مكون بناءً على فصل دراسي ، فستحصل على ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  من المقبول عمومًا أن اثنين من أجزاء التعليمات البرمجية هذه متساويان.  وغالبًا ما يكون المطورون مجانيون تمامًا ، أثناء إعادة تشفير الكود ، يحولون بعضهم إلى الآخر ، دون التفكير في العواقب المحتملة. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">هذه القطع من الكود تبدو متكافئة</font></i> <br><br>  ومع ذلك ، هناك اختلاف بسيط بين مقتطفات الشفرة هذه.  نلقي نظرة فاحصة عليها.  انظر الفرق؟  على سبيل المثال ، لم أرها على الفور. <br><br>  علاوة على ذلك ، سننظر في هذا الاختلاف ، وبالتالي ، بالنسبة لأولئك الذين يرغبون في فهم جوهر ما يحدث بأنفسهم ، فهو مثال عملي على هذا الرمز. <br><br>  قبل المتابعة ، أود التأكيد على أن الاختلاف في السؤال لا علاقة له بخطافات React.  في الأمثلة السابقة ، بالمناسبة ، لا تستخدم حتى السنانير.  إنه يتعلق بالفرق بين الوظائف والطبقات في React.  وإذا كنت تخطط لاستخدام العديد من المكونات الوظيفية في تطبيقات React الخاصة بك ، فقد ترغب في فهم هذا الاختلاف. <br><br>  في الواقع ، سنقوم بتوضيح الفرق بين الوظائف والفئات من خلال مثال عن خطأ غالبًا ما يتم مواجهته في تطبيقات React. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">الخطأ الشائع في تطبيقات React.</font> </h2><br>  افتح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صفحة المثال</a> التي تعرض قائمة تسمح لك بتحديد ملفات تعريف المستخدمين ، واثنين من أزرار المتابعة التي يتم عرضها بواسطة <code>ProfilePageClass</code> و <code>ProfilePageClass</code> ، الوظيفية ، وعلى أساس الفئة ، يظهر رمزها أعلاه. <br><br>  حاول ، لكل من هذه الأزرار ، تنفيذ تسلسل الإجراءات التالي: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  انقر فوق الزر. </li><li style=";text-align:right;direction:rtl">  تغيير ملف التعريف المحدد قبل 3 ثوان تنقضي بعد النقر على الزر. </li><li style=";text-align:right;direction:rtl">  اقرأ النص المعروض في مربع الرسالة. </li></ol><br>  بعد القيام بذلك ، ستلاحظ الميزات التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عند النقر فوق الزر الذي شكله المكون الوظيفي مع ملف تعريف <code>Dan</code> المحدد ثم التبديل إلى ملف تعريف <code>Sophie</code> ، سيتم عرض <code>'Followed Dan'</code> في مربع الرسالة. </li><li style=";text-align:right;direction:rtl">  إذا كنت تفعل الشيء نفسه باستخدام زر مكون من مكون يستند إلى فصل <code>'Followed Sophie'</code> فسيتم عرض <code>'Followed Sophie'</code> . </li></ul><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">ميزات المكون المستندة إلى الفئة</font></i> <br><br>  في هذا المثال ، يكون سلوك المكون الوظيفي صحيحًا.  إذا اشتركت في ملف تعريف شخص ما ، ثم انتقلت إلى ملف تعريف آخر ، فلا ينبغي أن يشك مكوّن بلدي في ملفي الشخصي الذي اشتركت فيه.  من الواضح أن تنفيذ الآلية المعنية بناءً على استخدام الفصول يحتوي على خطأ (بالمناسبة ، يجب أن تصبح بالتأكيد مشتركًا في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صوفيا</a> ). <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">أسباب خلل مكون المستندة إلى فئة</font> </h2><br>  لماذا يتصرف المكون المستند إلى الفصل بهذه الطريقة؟  لفهم هذا ، دعونا نلقي نظرة على طريقة <code>showMessage</code> في <code>showMessage</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br>  هذه الطريقة تقرأ البيانات من <code>this.props.user</code> .  الخصائص في React غير قابلة للتغيير ، لذلك لا تتغير.  ومع ذلك ، <code>this</code> ، كما هو الحال دائمًا ، كيان قابل للتغيير. <br><br>  في الواقع ، يكمن الغرض من وجود <code>this</code> في الفصل في قدرة <code>this</code> على التغيير.  تنفذ مكتبة React نفسها <code>this</code> الطفرات بشكل دوري ، مما يسمح بالعمل مع أحدث الإصدارات من طريقة <code>render</code> وطرق دورة حياة المكون. <br><br>  نتيجةً لذلك ، إذا تمت إعادة عرض المكون الخاص بنا أثناء تنفيذ الطلب ، فسيتم تغيير <code>this.props</code> .  بعد ذلك ، <code>showMessage</code> طريقة <code>showMessage</code> بقراءة قيمة <code>user</code> من كيان <code>props</code> "الجديد جدًا". <br><br>  يسمح لك هذا بإجراء ملاحظة مثيرة للاهتمام فيما يتعلق بواجهات المستخدم.  إذا قلنا أن واجهة المستخدم ، من الناحية النظرية ، هي وظيفة للحالة الحالية للتطبيق ، فإن معالجات الأحداث جزء من نتائج العرض - تمامًا مثل نتائج العرض المرئية.  "ينتمي" معالجات الأحداث لدينا إلى عملية تقديم محددة إلى جانب خصائص وحالة محددة. <br><br>  ومع ذلك ، فإن جدولة مهلة يقرأ رد الاتصال <code>this.props</code> ينتهك هذا الاتصال.  <code>showMessage</code> showMessage ليس "مرتبطًا" بأي عملية تجسيد معينة ؛ ونتيجة لذلك ، "يفقد" الخصائص الصحيحة.  قراءة البيانات من <code>this</code> فواصل هذا الصدد. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">كيف ، عن طريق المكونات القائمة على الفصل ، لحل المشكلة؟</font> </h2><br>  تخيل أنه لا توجد مكونات وظيفية في React.  كيف إذن لحل هذه المشكلة؟ <br><br>  نحتاج إلى بعض الآلية "لاستعادة" الاتصال بين طريقة <code>render</code> بالخصائص الصحيحة واستدعاء showMessage ، الذي يقرأ البيانات من الخصائص.  يجب أن تكون هذه الآلية موجودة في مكان ما حيث يتم فقدان جوهر <code>props</code> مع البيانات الصحيحة. <br><br>  إحدى الطرق للقيام بذلك هي قراءة <code>this.props</code> مقدمًا في معالج الأحداث ، ثم تمرير ما تمت قراءته بوضوح إلى وظيفة رد الاتصال المستخدمة في <code>setTimeout</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  هذا النهج هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">العمل</a> .  لكن الإنشاءات الإضافية المستخدمة هنا ، بمرور الوقت ، ستؤدي إلى زيادة في حجم الكود وإلى زيادة احتمال حدوث أخطاء فيه.  ماذا لو كنا بحاجة إلى أكثر من خاصية واحدة؟  ماذا لو كنا بحاجة أيضا للعمل مع الدولة؟  إذا كانت طريقة <code>showMessage</code> طريقة أخرى وتقرأ هذه الطريقة <code>this.props.something</code> أو <code>this.state.something</code> ، <code>this.state.something</code> مجددًا نفس المشكلة.  ولكي نحلها ، يجب أن نمرر هذا <code>this.props</code> و <code>this.state</code> كحجج لجميع الأساليب التي تم استدعاؤها من <code>showMessage</code> . <br><br>  إذا كان هذا صحيحًا ، فسوف يدمر كل وسائل الراحة التي يوفرها استخدام المكونات على أساس الفصول الدراسية.  من الصعب تذكر حقيقة أنك تحتاج إلى التعامل مع الأساليب بهذه الطريقة ، فمن الصعب أتمتة ، نتيجة لذلك ، يوافق المطورون غالبًا ، بدلاً من استخدام أساليب مماثلة ، على وجود أخطاء في مشاريعهم. <br><br>  وبالمثل ، فإن تضمين رمز <code>alert</code> في <code>handleClick</code> لا يحل مشكلة أكثر عالمية.  نحتاج إلى هيكلة الكود بحيث يمكن تقسيمه إلى العديد من الطرق ، ولكن أيضًا حتى نتمكن من قراءة الخصائص والحالة التي تتوافق مع عملية العرض المرتبطة بمكالمة معينة.  هذه المشكلة ، بالمناسبة ، لا تنطبق حتى حصرا على رد الفعل.  يمكنك تشغيله في أي مكتبة لتطوير واجهات المستخدم ، مما يضع البيانات في كائنات قابلة للتغيير مثل <code>this</code> . <br><br>  ربما من أجل حل هذه المشكلة ، يمكنك ربط الطرق في <code>this</code> المنشئ؟ <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  لكن هذا لا يحل مشكلتنا.  تذكر أننا نقرأ البيانات من <code>this.props</code> فوات الأوان ، وليس في بناء الجملة المستخدمة!  ومع ذلك ، سيتم حل هذه المشكلة إذا كنا نعتمد على إغلاق JavaScript. <br><br>  غالبًا ما يحاول المطورون تجنب الإغلاق ، لأنه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ليس من السهل</a> التفكير في القيم التي لا يمكن أن تتغير مع مرور الوقت.  لكن الخصائص في React غير قابلة للتغيير!  (أو ، على الأقل ، ينصح بهذا بشدة).  يسمح لك هذا بالتوقف عن إدراك عمليات الإغلاق كشيء يمكن للمبرمج ، كما يقولون ، "إطلاق النار على قدمه". <br><br>  هذا يعني أنه في حالة "قفل" الخصائص أو حالة عملية تقديم معينة في الإغلاق ، يمكنك دائمًا الاعتماد عليها في عدم التغيير. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br>  كما ترون ، نحن هنا "استحوذنا" على الخصائص أثناء استدعاء طريقة العرض. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">الخصائص التي تم التقاطها بواسطة تقديم المكالمة</font></i> <br><br>  باستخدام هذا الأسلوب ، يتم ضمان أي رمز في طريقة <code>render</code> (بما في ذلك <code>showMessage</code> ) لرؤية الخصائص الملتقطة أثناء مكالمة معينة لهذه الطريقة.  نتيجة لذلك ، لن يكون بإمكان React منعنا من القيام بما نحتاج إليه. <br><br>  في طريقة <code>render</code> ، يمكنك وصف أكبر عدد تريده من الوظائف المساعدة وكلها ستكون قادرة على استخدام الخصائص والحالة "الملتقطة".  هذه هي الطريقة التي حل الإغلاقات مشكلتنا. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">تحليل الحل للمشكلة باستخدام الإغلاق</font> </h2><br>  ما وصلنا إليه للتو يسمح لنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بحل المشكلة</a> ، لكن هذا الرمز يبدو غريباً.  لماذا هناك حاجة لفئة على الإطلاق إذا تم الإعلان عن الوظائف داخل طريقة <code>render</code> ، وليس كطرق صفية؟ <br><br>  في الواقع ، يمكننا تبسيط هذا الرمز من خلال التخلص من "الصدفة" في شكل فئة تحيط بها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  هنا ، كما في المثال السابق ، يتم التقاط الخصائص في الوظيفة ، لأن React يمررها إليها كوسيطة.  على عكس <code>this</code> ، React لا <code>props</code> كائن <code>props</code> . <br><br>  يصبح هذا أكثر وضوحًا قليلاً إذا <code>props</code> تدمير <code>props</code> في إعلان الوظيفة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  عندما <code>ProfilePage</code> المكون الأصل <code>ProfilePage</code> مع خصائص أخرى ، سوف React استدعاء دالة <code>ProfilePage</code> .  ولكن معالج الأحداث الذي تم استدعاؤه بالفعل ينتمي إلى المكالمة السابقة لهذه الوظيفة ، وتستخدم هذه المكالمة قيمة <code>user</code> الخاصة به واستدعاء showMessage الخاص به ، والذي يقرأ هذه القيمة.  كل هذا لا يزال دون تغيير. <br><br>  هذا هو السبب في الإصدار <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأصلي</a> من مثالنا ، عند العمل مع مكون وظيفي ، لا يؤدي تغيير ملف تعريف آخر بعد النقر فوق الزر المقابل قبل عرض الرسالة إلى تغيير أي شيء.  إذا تم تحديد ملف تعريف <code>Sophie</code> قبل النقر فوق الزر ، فسيتم عرض <code>'Followed Sophie'</code> في نافذة الرسالة ، بغض النظر عما يحدث. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">باستخدام مكون وظيفي</font></i> <br><br>  هذا السلوك صحيح (قد ترغب أيضًا في الاشتراك في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Sunil بالمناسبة</a> ). <br><br>  الآن اكتشفنا الفرق الكبير بين الوظائف والطبقات في React.  كما ذكرنا سابقًا ، نحن نتحدث عن حقيقة أن المكونات الوظيفية تلتقط القيم.  الآن دعونا نتحدث عن السنانير. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">الغياب</font> </h2><br>  عند استخدام الخطافات ، يمتد مبدأ "التقاط القيم" إلى الحالة.  النظر في المثال التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> يمكنك تجربة معه <br><br>  على الرغم من أن هذا ليس مثالًا مثاليًا لواجهة تطبيق المراسلة ، فإن هذا المشروع يوضح نفس الفكرة: إذا أرسل المستخدم رسالة ، فلا ينبغي الخلط بين المكون والرسالة التي تم إرسالها.  يلتقط ثابت <code>message</code> لهذا المكون الوظيفي الحالة التي "تنتمي" للمكون الذي يجعل المستعرض معالج النقر للزر الذي يستدعيه.  نتيجة لذلك ، تخزن <code>message</code> ما كان في حقل الإدخال في وقت النقر فوق الزر <code>Send</code> . <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">مشكلة التقاط الخصائص والحالات عن طريق المكونات الوظيفية</font> </h2><br>  نحن نعلم أن المكونات الوظيفية في React ، بشكل افتراضي ، تلتقط الخصائص والحالة.  ولكن ماذا لو احتجنا إلى قراءة أحدث البيانات من الخصائص أو الحالات التي لا تنتمي إلى استدعاء دالة معين؟  ماذا لو أردنا " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قراءتها من المستقبل</a> "؟ <br><br>  في المكونات القائمة على الفصل ، يمكن القيام بذلك ببساطة عن طريق الإشارة إلى <code>this.props</code> أو <code>this.state</code> ، نظرًا لأن <code>this</code> كيان قابل للتغيير.  تغيير لها تشارك في رد الفعل.  يمكن أن تعمل المكونات الوظيفية أيضًا مع قيم قابلة للتغيير يتم مشاركتها بواسطة جميع المكونات.  تسمى هذه القيم <code>ref</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br>  ومع ذلك ، يحتاج مبرمج لإدارة هذه القيم بشكل مستقل. <br><br>  يلعب جوهر <code>ref</code> نفس <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">دور</a> حقول مثيل من الفصل.  هذا هو "مخرج الطوارئ" في عالم حتمية قابلة للتغيير.  قد تكون على دراية بمفهوم DOM DOM ، لكن هذه الفكرة أكثر عمومية.  يمكن مقارنتها بصندوق يستطيع فيه المبرمج وضع شيء ما. <br><br>  حتى خارجيا ، فإن بناء هذا الشكل. <code>this.something</code> يشبه صورة طبق الأصل من بناء <code>something.current</code> .  إنهم يمثلون نفس المفهوم. <br><br>  بشكل افتراضي ، لا يقوم React بإنشاء كيانات <code>ref</code> في المكونات الوظيفية لأحدث خاصية أو قيم الحالة.  في كثير من الحالات ، لن تحتاج إليها ، وسيكون إنشائها التلقائي مضيعة للوقت.  ومع ذلك ، يمكن تنظيم العمل معهم ، إذا لزم الأمر ، بمفردهم: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br>  إذا قرأنا <code>message</code> في <code>showMessage</code> ، <code>showMessage</code> الرسالة التي كانت في الحقل وقت النقر فوق الزر <code>Send</code> .  ولكن إذا كنت تقرأ <code>latestMessage.current</code> ، يمكنك الحصول على أحدث قيمة - حتى إذا واصلنا إدخال النص في الحقل بعد النقر فوق الزر " <code>Send</code> . <br><br>  يمكنك مقارنة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وهذه</a> الأمثلة من أجل تقييم الفرق بشكل مستقل.  قيمة <code>ref</code> هي وسيلة "لتفادي" توحيد التقديم ، وفي بعض الحالات قد تكون مفيدة للغاية. <br><br>  بشكل عام ، يجب تجنب قراءة أو كتابة قيم <code>ref</code> أثناء عملية التقديم لأن هذه القيم قابلة للتغيير.  ونحن نسعى جاهدين لجعل تقديم يمكن التنبؤ بها.  ومع ذلك ، إذا كنا بحاجة إلى الحصول على أحدث قيمة لشيء مخزّن في الخصائص أو في الحالة ، فإن تحديث قيمة <code>ref</code> يدويًا قد يكون مهمة شاقة.  يمكن أن يكون آليا باستخدام التأثير: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> مثال يستخدم هذا الرمز <br><br>  نقوم بتعيين قيمة داخل التأثير ، ونتيجة لذلك ، لن تتغير قيمة <code>ref</code> إلا بعد تحديث DOM.  هذا يضمن أن طفرة لدينا لا يعطل ميزات مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Time Slicing and Suspense</a> ، والتي تعتمد على استمرارية عمليات التقديم. <br><br>  في كثير من الأحيان لا يكون استخدام قيمة <code>ref</code> بهذه الطريقة.  عادة ما يكون التقاط الخصائص أو الحالات نمطًا أفضل بكثير لسلوك النظام القياسي.  ومع ذلك ، يمكن أن يكون هذا مناسبًا عند العمل مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واجهات برمجة التطبيقات الضرورية</a> ، مثل تلك التي تستخدم فترات أو اشتراكات.  تذكر أنه يمكنك العمل بهذه الطريقة مع أي قيمة - مع الخصائص ، مع المتغيرات المخزنة في الحالة ، مع كائن <code>props</code> بأكمله <code>props</code> أو حتى مع وظيفة. <br><br>  هذا النمط ، بالإضافة إلى ذلك ، قد يكون مفيدًا لأغراض التحسين.  على سبيل المثال ، عندما يتغير شيء مثل <code>useCallback</code> كثيرًا.  صحيح أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الحل المفضل هو</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">استخدام المخفض</a> . <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">النتائج</font> </h2><br>  في هذه المقالة ، نظرنا إلى أحد الأنماط الخاطئة لاستخدام المكونات المستندة إلى الفصل وتحدثنا عن كيفية حل هذه المشكلة بالإغلاق.  ومع ذلك ، قد تلاحظ أنه عند محاولة تحسين الخطافات عن طريق تحديد مجموعة من التبعيات ، فقد تواجه أخطاء تتعلق بالإغلاقات القديمة.  هل هذا يعني أن العيوب بحد ذاتها مشكلة.  لا أعتقد ذلك. <br><br>  كما هو موضح أعلاه ، فإن عمليات الإغلاق ، في الواقع ، تساعدنا في إصلاح المشكلات الصغيرة التي يصعب ملاحظتها.  كما أنها تسهل كتابة التعليمات البرمجية التي تعمل بشكل صحيح في نفس <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوقت</a> .  هذا ممكن بسبب حقيقة أن الخصائص والحالة التي تم تقديم هذا المكون بها "مكون" داخل المكون. <br><br>  في جميع الحالات التي رأيتها حتى الآن ، حدثت مشكلة "الإغلاقات القديمة" بسبب الافتراض الخاطئ بأن "الوظائف لا تتغير" ، أو أن "الخصائص تظل دائمًا كما هي".  آمل أنه بعد قراءة هذه المادة ، فأنت مقتنع بأن هذا ليس كذلك. <br><br>  وظائف "التقاط" خصائصها وحالتها - وبالتالي فهم أي وظائف هي في السؤال المهم أيضا.  هذا ليس خطأ ؛ إنه ميزة للمكونات الوظيفية.  لا ينبغي استبعاد الوظائف من "مجموعة التبعيات" للاستخدام أو <code>useCalback</code> ، على سبيل المثال.  (عادةً ما يكون الحل المناسب للمشكلة هو إما استخدام <code>useReducer</code> أو <code>useRef</code> . تحدثنا عن هذا أعلاه ، وسنقوم قريبًا بإعداد المواد التي ستكرس لاختيار النهج) <br><br>  إذا كانت معظم الشفرة في تطبيقاتنا تعتمد على مكونات وظيفية ، فهذا يعني أننا بحاجة إلى معرفة المزيد عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تحسين الشفرة</a> ، وما هي القيم التي قد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تتغير</a> مع مرور الوقت. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a>     : «  ,   ,    ,   ,    ,         ». <br><br>          .  ,        React    ,   .     ,    « »,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React —    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar444348/">https://habr.com/ru/post/ar444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar444338/index.html">التغليف في بيثون 3</a></li>
<li><a href="../ar444340/index.html">ميزات استخدام نوع البيانات Symbol في JavaScript</a></li>
<li><a href="../ar444342/index.html">تطوير تطبيقات JavaScript بسيطة وحديثة باستخدام Webpack وتقنيات الويب المتقدمة</a></li>
<li><a href="../ar444344/index.html">10 خطوات لمشروع بيثون الناجح</a></li>
<li><a href="../ar444346/index.html">GraphQL و Golang</a></li>
<li><a href="../ar444350/index.html">لسبب ما ، لا يبدأ MVP (الحد الأدنى من المنتج القابل للتطبيق)</a></li>
<li><a href="../ar444352/index.html">Kontur.Kampus: ندعوك إلى معسكر طلابي مجاني للتنمية الصناعية بالقرب من سان بطرسبرغ</a></li>
<li><a href="../ar444356/index.html">رد فعل البرنامج التعليمي الجزء 24: أشكال الدرس الثاني</a></li>
<li><a href="../ar444358/index.html">يمكن تعداده: كيفية الحصول على قيمة العمل</a></li>
<li><a href="../ar444360/index.html">الظلم Google Play كتجربة حياة جيدة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>