<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ¥Œ ğŸ‡ğŸ¿ Solusi kompleks untuk masalah sederhana layanan WEB HighLoad âœ–ï¸ ğŸ¬ ğŸ“¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tugas utama dari sistem WEB yang sangat dimuat adalah kemampuan untuk memproses sejumlah besar permintaan. Masalah ini dapat diselesaikan dengan berba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solusi kompleks untuk masalah sederhana layanan WEB HighLoad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424415/"><img src="https://habrastorage.org/webt/ml/qd/qi/mlqdqibdtdla5vfms90qpg9ydse.png"><br><br>  Tugas utama dari sistem WEB yang sangat dimuat adalah kemampuan untuk memproses sejumlah besar permintaan.  Masalah ini dapat diselesaikan dengan berbagai cara.  Dalam artikel ini, saya mengusulkan untuk mempertimbangkan metode yang tidak biasa untuk mengoptimalkan permintaan backend melalui teknologi range-range (rentang).  Yaitu, untuk mengurangi jumlah mereka tanpa kehilangan kualitas sistem melalui caching yang efisien. <br><a name="habracut"></a><br>  Untuk mulai dengan, saya mengusulkan untuk mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel di</a> mana teknologi pembukaan dengan contoh untuk S2S disajikan dengan sangat ringkas dan cerdas.  Lebih lanjut, disarankan untuk berkenalan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> pertama saya tentang penggunaan teknologi ini untuk mengoptimalkan pekerjaan dengan data pasar pada proyek pertukaran cryptocurrency. <br><br>  Pada artikel ini, saya ingin menunjukkan bahwa teknologi ini dapat digunakan secara lebih luas daripada yang diperlihatkan artikel pertama.  Biarkan saya mengingatkan Anda bahwa ada informasi perdagangan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BF%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B2%25D0%25B5%25D1%2587%25D0%25B8">lilin</a> ) yang diperoleh dengan rentang-permintaan untuk file statis, yang disiapkan terlebih dahulu oleh layanan khusus.  Sekarang, saya ingin mempertimbangkan permintaan untuk backend penuh menggunakan data pasar yang sama sebagai contoh, dan untuk lilin yang sama, tanpa kehilangan keuntungan utama. <br><br>  Jadi apa yang direncanakan untuk dicapai: <br><br><ol><li>  Optimalkan permintaan backend (kurangi jumlahnya); </li><li>  Tingkatkan kecepatan pengiriman konten ke pengguna akhir; </li><li>  Optimalkan lalu lintas. </li></ol><br>  Sekali lagi, saya tekankan bahwa teknologi jangkauan adalah standar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 2616</a> ).  Ini secara asli didukung oleh browser dan mereka dapat men-cache bagian yang diterima dari data.  Oleh karena itu, permintaan berikutnya dari browser, jika ada cache aktual dari bagian yang diminta, diterapkan pada klien tanpa mengganggu server Anda. <br><br>  Jika Anda menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CDN</a> antara klien dan server, Anda bisa mendapatkan lapisan caching yang kuat.  Dan jika dalam kasus pertama, caching akan terjadi untuk klien akhir yang spesifik, kemudian dipasangkan dengan CDN, Anda mendapatkan kesempatan untuk melakukan cache data untuk sekelompok klien akhir. <br><br>  Jadi, untuk membuat permintaan nyata ke server, permintaan harus mengatasi dua level caching, yang masing-masing mengurangi volume permintaan ke server tujuan.  Tentu saja, "redoubt" terakhir, di jalur permintaan, bisa menjadi server Anda dengan cache-nya. <br><br>  Dari fitur-fitur yang menggunakan teknologi jangkauan, Anda perlu mempertimbangkan bahwa ia bekerja dengan bagian-bagian byte.  Yaitu  dengan data biner.  Dan kami dapat meminta interval byte yang tepat.  Mereka harus merespons, masing-masing - dengan blok biner. <br><br>  Saya pikir cukup pengantar.  Mari kita beralih ke kasus khusus, dan sudah dengan contoh, kita akan mencari tahu bagaimana kita dapat menggunakan semua "kebahagiaan" ini dalam masalah tertentu - meminta lilin untuk interval tertentu dengan paparan yang diberikan. <br><br>  Sebagai permulaan, sebagai  kita perlu bekerja dengan struktur biner, mari kita enkode lilin kita.  Untuk ini kami ambil, misalnya, struktur berikut: <br><br><pre><code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">moment:</span></span> int32 /<span class="hljs-regexp"><span class="hljs-regexp">/   min: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   max: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   open: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   close: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   volume: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  average: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  </span></span></code> </pre> <br>  Dengan demikian, struktur kami akan menempati 52 byte.  Kami menganggapnya sebagai kuantum - blok biner minimum. <br><br>  Selanjutnya, kami mengimplementasikan pengontrol yang akan menerima permintaan GET dan menguraikan header rentang.  Dalam hal ini, kami akan menerjemahkan interval yang diminta ke dalam kuanta dengan pembagian sederhana tanpa sisa, mis.  misalnya, permintaan interval: <br><br> <code>Range: 5200-52000</code> <br> <br>  Kita harus menafsirkan dalam dimensi kuantum kita sebagai: <br><br> <code>Range: 100-1000</code> <br> <br>  Intinya, ini akan menjadi offset dan batas permintaan basis data kami. <br><br>  Dengan definisi eksposur yang sangat sederhana, kita bisa memasukkannya ke dalam url.  Sebagai contoh: <br><br> <code>/api/v1/candles/7m</code> <br> <br>  Yaitu  kami akan meminta lilin dengan pencahayaan 7 menit.  Secara alami, kami mengasumsikan bahwa parameter ini dapat diubah atas permintaan frontend. <br><br>  Sekarang, mengetahui eksposur yang diperlukan, jumlah lilin pertama dan jumlah lilin terakhir yang diminta oleh frontend, kita dapat menjalankan kueri yang sesuai dengan database. <br><br>  Secara umum, ini sangat mengingatkan pada masalah pagination klasik. <br><br>  Ada hal-hal kecil yang tersisa.  Setiap baris hasil kueri dikonversi menjadi struktur biner (kuantum yang sama) dan array biner yang dihasilkan ditampilkan sebagai hasil kueri, dan rentang konten dikembalikan ke header respons: <br><br> <code>Content-Range: [ ] / [[   ] * [ ]]</code> <br> <br>  Berhenti  Tetapi bagaimana depan dapat meminta interval waktu yang diinginkan, dan bahkan dalam interval byte?  Bagaimana dia tahu ada nomor lilin di sana?  Di sini juga, semuanya diciptakan.  Rentang mendukung offset relatif, mis. <br><br> <code>Range: -52</code> <br> <br>  Minta 52 byte dari akhir.  Yaitu  lilin terakhir.  Sekarang, mengetahui saat terakhir dari waktu lilin terakhir, mengetahui, dari jawaban, ukuran total "file", Anda dapat menghitung jumlah total lilin, dan dari sini menentukan interval byte untuk meminta paparan waktu yang diinginkan. <br><br>  Jika Anda tiba-tiba ingin mengajukan pertanyaan - mengapa kesulitan seperti itu?  Harap kembali ke sasaran Anda.  Teknologi ini "menutupi" kueri analitik ke database menjadi file biner untuk CDN dan browser.  Ini memungkinkan Anda untuk mentransfer sebagian besar permintaan berulang ke CDN dan klien akhir. <br><br>  Mungkin muncul pertanyaan lain - mengapa tidak menggunakan caching sederhana untuk permintaan GET?  Bagus  Mari kita perbaiki.  Jika kami menjalankan permintaan seperti itu di REST klasik: <br><br> <code>GET /api/v1/candles/7m?from=01-03-2018&amp;to=31-03-2018</code> <br> <br>  Kami akan mendapatkan cache unik untuk permintaan ini.  Dengan menjalankan kueri berikut: <br><br> <code>GET /api/v1/candles/7m?from=15-03-2018&amp;to=20-03-2018</code> <br> <br>  Kami akan mendapatkan cache unik lain ....  meskipun, perhatikan, permintaan kedua meminta data dimasukkan dalam respons yang pertama. <br><br>  Jadi, dalam hal implementasi yang diusulkan di atas (rentang), permintaan kedua tidak akan membentuk cache terpisah, tetapi akan menggunakan data yang sudah diterima dari permintaan pertama.  Dan itu tidak akan masuk ke server.  Dan ini, menghemat ukuran cache dan mengurangi jumlah panggilan ke server. <br><br>  Apakah ada kelemahan pada teknologi ini?  Ya  Mereka jelas: <br><br><ol><li>  Teknologi ini tidak cocok untuk perubahan data seiring waktu, karena  berdasarkan caching total. </li><li>  CDN CloudFlare hanya membuat cache file sepenuhnya.  Ini berarti bahwa jika klien akhir meminta interval, katakanlah, 1 hingga 100 byte, maka CloudFlare sebenarnya akan meminta seluruh file dari server.  Yaitu  dalam kasus kami, itu akan memuat semua lilin dengan eksposur tertentu.  Dia akan menaruhnya sendiri dan sudah akan mendistribusikannya sendiri.  Ini bahkan dapat dianggap sebagai nilai tambah, jika bukan karena pembatasan tempat.  Dan jika Anda dapat membentuk jawaban "berat", dan banyak parameter, maka ... Secara umum, jelas bahwa tempat itu akan berakhir.  Mungkin kami tidak dapat mengonfigurasinya dengan benar.  Namun sejauh ini hasilnya adalah sebagai berikut. </li><li>  Diperlukan untuk mengelola cache dengan bijak.  Ada mekanisme yang cukup untuk ini, tetapi mereka membutuhkan penyetelan. </li><li>  Frontend harus dapat mem-parsing data biner dan memiliki sesuatu ala dataset di papan untuk bekerja dengan berbagai permintaan. </li></ol><br>  Saya akan merumuskan kelayakan menerapkan strategi ini sebagai berikut - ketika Anda membutuhkannya, Anda akan mengerti.  Jika sekarang ada keraguan, ada baiknya tahu tentangnya, tapi jangan repot-repot. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424415/">https://habr.com/ru/post/id424415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424403/index.html">Buka webinar "Indeks"</a></li>
<li><a href="../id424407/index.html">Digital X-ray: dari alpha ke gamma</a></li>
<li><a href="../id424409/index.html">Tur foto Audiomania: bagian dua</a></li>
<li><a href="../id424411/index.html">Apa perbedaan suara antara bass penguat dan dinamis?</a></li>
<li><a href="../id424413/index.html">Ikhtisar Aplikasi 3D Elektronik</a></li>
<li><a href="../id424417/index.html">Roskomnadzor melaporkan hasil pertarungan tiga tahun melawan perompak</a></li>
<li><a href="../id424419/index.html">Apa yang terjadi ketika membuat wadah Flexbox?</a></li>
<li><a href="../id424421/index.html">Kesalahan Bisnis Internet Umum yang Dapat Anda Hindari</a></li>
<li><a href="../id424423/index.html">Google Chrome 69 secara otomatis masuk ke akun Anda dan tidak menghapus cookie Google saat membersihkan riwayat</a></li>
<li><a href="../id424425/index.html">Kami merilis proyek Java dengan Maven dengan cara baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>