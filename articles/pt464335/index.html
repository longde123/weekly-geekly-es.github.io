<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèª üñïüèΩ üõ°Ô∏è Testes de unidade no DBMS - como fazemos no Sportmaster, parte um ‚úåüèª üïµüèª üà≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Meu nome √© Maxim Ponomarenko e sou desenvolvedor da Sportmaster. Tenho 10 anos de experi√™ncia na √°rea de TI. Ele iniciou sua carreira em ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes de unidade no DBMS - como fazemos no Sportmaster, parte um</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/464335/">  Ol√° Habr! <br><br>  Meu nome √© Maxim Ponomarenko e sou desenvolvedor da Sportmaster.  Tenho 10 anos de experi√™ncia na √°rea de TI.  Ele iniciou sua carreira em testes manuais e depois mudou para o desenvolvimento de bancos de dados.  Nos √∫ltimos 4 anos, acumulando conhecimentos adquiridos em testes e desenvolvimento, participei da automa√ß√£o de testes no n√≠vel do DBMS. <br><br>  Fa√ßo parte da equipe Sportmaster h√° pouco mais de um ano e estou envolvido no desenvolvimento de testes automatizados em um dos principais projetos.  Em abril, os caras do Sportmaster Lab e eu conversamos em uma confer√™ncia em Krasnodar, meu relat√≥rio foi chamado de Testes de Unidade no DBMS e agora quero compartilh√°-lo com voc√™.  Como h√° muito texto, decidi dividir o relat√≥rio em duas postagens.  No primeiro, falaremos sobre autotestes e testes em geral; no segundo, abordarei nosso sistema de teste de unidade e os resultados de sua aplica√ß√£o. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/3_/bq/ny/3_bqnyzzwyxryj57cjiswfqguva.png"></a> <br><br>  A princ√≠pio, um pouco de teoria chata.  O que √© teste autom√°tico?  Este √© um teste realizado por software e, na TI moderna, √© cada vez mais utilizado no desenvolvimento de software.  Isso se deve ao fato de as empresas estarem crescendo, seus sistemas de informa√ß√£o estarem crescendo e, consequentemente, a quantidade de funcionalidades que precisam ser testadas.  A realiza√ß√£o de testes manuais est√° se tornando cada vez mais cara. <br><a name="habracut"></a><br>  Eu trabalhei para uma grande empresa, cujos lan√ßamentos s√£o lan√ßados a cada dois meses.  Ao mesmo tempo, um m√™s inteiro foi gasto em uma d√∫zia de testadores para verificar a funcionalidade com as m√£os.  Gra√ßas √† introdu√ß√£o da automa√ß√£o por uma pequena equipe de desenvolvedores, conseguimos reduzir o tempo de teste para 2 semanas em um ano e meio.  N√£o apenas aumentamos a velocidade dos testes, mas tamb√©m aumentamos sua qualidade.  Testes automatizados s√£o executados regularmente e sempre completam todo o curso dos testes inerentes a eles, ou seja, exclu√≠mos o fator humano. <br><br>  A TI moderna √© caracterizada pelo fato de que o desenvolvedor pode ser solicitado n√£o apenas a escrever o c√≥digo do produto, mas a escrever testes de unidade que verificam esse c√≥digo. <br><br>  Mas e se o seu sistema for baseado principalmente na l√≥gica do servidor?  N√£o h√° uma solu√ß√£o √∫nica e boas pr√°ticas no mercado.  Como regra, as empresas resolvem esse problema criando seu pr√≥prio sistema de teste auto-escrito.  Um sistema de teste automatizado e auto-escrito propriet√°rio foi criado em nosso projeto, e falarei sobre isso em meu relat√≥rio. <br><br><img src="https://habrastorage.org/webt/wy/aa/c-/wyaac--1ljrnkedj_vuu9g6g2x8.png" width="900"><br><br><h2>  Testando a lealdade </h2><br>  Primeiro, vamos falar sobre um projeto em que implantamos um sistema de teste automatizado.  Nosso projeto √© o sistema de fidelidade da Sportmaster (a prop√≥sito, j√° escrevemos sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste post</a> ). <br><br>  Se sua empresa for grande o suficiente, seu sistema de fidelidade ter√° tr√™s propriedades padr√£o: <br><br><ul><li>  Seu sistema estar√° muito carregado. </li><li>  Seu sistema conter√° processos de computa√ß√£o complexos. </li><li>  Seu sistema ser√° desenvolvido ativamente. </li></ul><br>  Vamos em ordem.  Sportmaster tem um grande n√∫mero de lojas que est√£o vendendo ativamente.  Naturalmente, o sistema de fidelidade √© um sistema altamente carregado.  E como o projeto √© usado ativamente, devemos fornecer os mais altos padr√µes de qualidade, porque qualquer erro no software √© muito dinheiro, reputa√ß√£o e outras perdas. <br><br>  Ao mesmo tempo, mais de cem promo√ß√µes diferentes funcionam no Sportmaster.  As a√ß√µes s√£o muito diferentes: existem commodities, cronometram para o dia da semana, est√£o vinculadas a uma loja em particular, h√° a√ß√µes no valor do cheque, h√° o n√∫mero de mercadorias.  Em geral, n√£o √© fraco.  Os clientes t√™m b√¥nus, existem c√≥digos promocionais que s√£o usados ‚Äã‚Äãnas compras.  Tudo isso leva ao fato de que o c√°lculo de qualquer ordem √© uma tarefa n√£o trivial. <br><br>  O algoritmo que implementa o processamento de pedidos √© realmente terr√≠vel e complicado.  E quaisquer altera√ß√µes neste algoritmo s√£o uma coisa bastante arriscada.  Parecia haver as menores mudan√ßas externas que poderiam levar a efeitos imprevis√≠veis.  Mas s√£o precisamente esses processos computacionais complexos, tanto mais que a implementa√ß√£o de funcionalidades cr√≠ticas √© o melhor candidato para automa√ß√£o.  Verificar dezenas de casos do mesmo tipo com as m√£os consome muito tempo.  E como o ponto de entrada para o processo permanece inalterado, uma vez descrito, voc√™ pode carimbar rapidamente os testes autom√°ticos e ter certeza da funcionalidade. <br><br>  Como nosso sistema √© usado ativamente, a empresa desejar√° algo novo de voc√™, atualizado e orientado para o cliente.  Em nosso sistema de fidelidade, os lan√ßamentos s√£o lan√ßados a cada dois meses.  Portanto, a cada dois meses, precisamos realizar uma regress√£o completa de todo o sistema.  Ao mesmo tempo, √© claro, como em qualquer TI moderna, o desenvolvimento n√£o vem imediatamente do desenvolvedor para a produ√ß√£o.  Ele se origina no circuito do desenvolvedor e, em seguida, passa sequencialmente no banco de testes, na libera√ß√£o, na aceita√ß√£o e somente depois est√° em produ√ß√£o.  Pelo menos nos circuitos de teste e libera√ß√£o, precisamos realizar uma regress√£o completa de todo o sistema. <br><br>  As propriedades descritas s√£o padr√£o para quase qualquer sistema de fidelidade.  Vamos falar sobre os recursos do nosso projeto. <br><br>  Tecnologicamente, 90% da l√≥gica do nosso sistema de fidelidade √© baseada em servidor e implementada no Oracle.  H√° um cliente exposto no Delphi, que executa a fun√ß√£o de um administrador do AWP.  Existem servi√ßos da Web expostos para aplicativos externos (como um site).  Portanto, √© muito l√≥gico que, se implantarmos um sistema de teste automatizado, faremos isso no Oracle. <br><br>  O sistema de fidelidade no Sportmaster existe h√° mais de 7 anos e foi criado por desenvolvedores √∫nicos ... O n√∫mero m√©dio de desenvolvedores em nosso projeto durante esses 7 anos foi de 3-4 pessoas.  Mas, no ano passado, nossa equipe cresceu significativamente e agora 10 pessoas est√£o trabalhando no projeto.  Ou seja, pessoas que n√£o est√£o familiarizadas com tarefas, processos e arquitetura t√≠picos v√™m ao projeto.  E h√° um risco maior de ignorarmos erros. <br><br>  O projeto √© caracterizado pela aus√™ncia de testadores dedicados como unidades de equipe.  √â claro que √© o teste, mas os analistas est√£o envolvidos no teste, al√©m de outras responsabilidades principais: comunicar-se com clientes comerciais, usu√°rios, elaborar requisitos de sistema etc.  etc ... Apesar de os testes serem realizados de maneira muito qualitativa (isso √© especialmente apropriado para mencionar, uma vez que um dos analistas pode chamar a aten√ß√£o neste relat√≥rio), ningu√©m cancelou a efic√°cia da especializa√ß√£o e concentra√ß√£o em uma coisa. <br><br>  Dado tudo o que foi dito acima, para melhorar a qualidade do produto emitido e reduzir o tempo de desenvolvimento, a id√©ia de automatizar os testes no projeto parece muito l√≥gica.  E em diferentes est√°gios da exist√™ncia do sistema de fidelidade, desenvolvedores individuais fizeram esfor√ßos para cobrir seu c√≥digo com testes de unidade.  Geralmente, era um processo bastante d√≠spar onde todos usavam sua arquitetura e m√©todos.  Os testes de unidade eram comuns para os resultados finais: os testes foram desenvolvidos, usados ‚Äã‚Äãpor algum tempo, empilhados em um armazenamento de arquivo com vers√£o, mas em algum momento eles pararam de iniciar e foram esquecidos.  Isso ocorreu principalmente pelo fato de os testes estarem mais vinculados a um artista espec√≠fico, e n√£o a um projeto. <br><br><h2>  UtPLSQL vem em socorro </h2><br><img src="https://habrastorage.org/webt/o-/l4/60/o-l460kfyehubgizartw4soydlo.png"><br><br>  Voc√™ sabe alguma coisa sobre Stephen Feuerstein? <br><br>  Esse √© um cara esperto que dedicou uma longa parte de sua carreira a trabalhar com Oracle e com PL / SQL, escreveu um n√∫mero bastante grande de trabalhos sobre esse t√≥pico.  Um livro bem conhecido dele √© chamado: ‚ÄúOracle PL / SQL.  Para profissionais. ‚Äù  √â Steven quem √© o propriet√°rio do desenvolvimento da solu√ß√£o utPLSQL ou, como √© o caso, da estrutura de Teste de Unidade para Oracle PL / SQL.  A solu√ß√£o utPLSQL foi criada em 2016, mas eles continuam trabalhando ativamente nela e lan√ßam novas vers√µes.  No momento do relat√≥rio, a vers√£o mais recente era de 24 de mar√ßo de 2019. <br>  O que √© isso?  Este √© um projeto de c√≥digo aberto separado.  Ele pesa alguns megabytes, levando em considera√ß√£o exemplos e documenta√ß√£o.  Fisicamente, √© um esquema separado no banco de dados ORACLE com um conjunto de pacotes e tabelas para organizar o teste de unidade.  A instala√ß√£o leva alguns segundos.  Um recurso distintivo do utPLSQL √© sua facilidade de uso. <br>  Globalmente, o utPLSQL √© um mecanismo para executar testes de unidade, nos quais um teste de unidade se refere a procedimentos em lote regulares do Oracle, cuja organiza√ß√£o segue determinadas regras.  Al√©m do lan√ßamento, o utPLSQL armazena um log de todas as suas execu√ß√µes de teste e tamb√©m h√° um sistema interno de relat√≥rios. <br><br>  Vejamos um exemplo de como √© o c√≥digo de teste de unidade implementado por esta t√©cnica. <br><br><img src="https://habrastorage.org/webt/ko/kr/jg/kokrjgtp4wb348t3wkbm9bryjnc.png"><br><br>  Portanto, a tela mostra o c√≥digo para a especifica√ß√£o padr√£o de um pacote com testes de unidade.  Quais s√£o os requisitos necess√°rios?  O pacote deve ter o prefixo utp_.  Todos os procedimentos com testes devem ter exatamente o mesmo prefixo.  O pacote deve conter dois procedimentos padr√£o: "utp_setup" e "utp_teardown".  O primeiro procedimento √© chamado reiniciando cada teste de unidade, o segundo - ap√≥s o in√≠cio. <br><br>  "Utp_setup", via de regra, prepara nosso sistema para executar um teste de unidade, por exemplo, cria dados de teste.  "Utp_teardown" - pelo contr√°rio, tudo retorna √†s configura√ß√µes originais e redefine os resultados do lan√ßamento. <br><br>  Aqui est√° um exemplo do teste de unidade mais simples, que verifica a normaliza√ß√£o do n√∫mero de telefone do cliente digitado para a apar√™ncia padr√£o do nosso sistema de fidelidade.  N√£o h√° padr√µes obrigat√≥rios para escrever procedimentos com testes de unidade.  Como regra, um m√©todo do sistema em teste √© chamado e o resultado retornado por esse m√©todo √© comparado com o de refer√™ncia.  √â importante que a compara√ß√£o entre o resultado de refer√™ncia e o resultado ocorra atrav√©s dos m√©todos utPLSQL padr√£o. <br><br>  Um teste de unidade pode ter qualquer n√∫mero de verifica√ß√µes.  Como voc√™ pode ver no exemplo, fazemos quatro chamadas consecutivas do m√©todo testado para normalizar o n√∫mero de telefone e, ap√≥s cada chamada, avaliamos o resultado.  Ao desenvolver um teste de unidade, √© preciso levar em considera√ß√£o que h√° verifica√ß√µes que n√£o afetam o sistema de nenhuma maneira e, ap√≥s algumas, √© necess√°rio reverter para o estado inicial do sistema. <br>  Por exemplo, no teste de unidade apresentado, simplesmente formatamos o n√∫mero de telefone de entrada, o que n√£o afeta o sistema de fidelidade. <br><br>  E se escrevermos testes de unidade usando o m√©todo de cria√ß√£o de um novo cliente, depois de cada verifica√ß√£o, um novo cliente ser√° criado no sistema, o que pode afetar o lan√ßamento subsequente do teste. <br><br><img src="https://habrastorage.org/webt/wy/q7/p9/wyq7p9dwwjh_ir0kq2uxc8xutsy.png"><br><br>  √â assim que os testes de unidade s√£o executados.  Existem duas op√ß√µes poss√≠veis de inicializa√ß√£o: iniciar todos os testes de unidade de um pacote espec√≠fico ou iniciar um teste de unidade espec√≠fico em um pacote espec√≠fico. <br><br><img src="https://habrastorage.org/webt/yd/a9/jm/yda9jm5ob7kcvcsjz9p_tplnvyo.png"><br><br>  Aqui est√° um exemplo de um sistema de relat√≥rio interno.  De acordo com os resultados do teste de unidade, o utPLSQL cria um pequeno relat√≥rio.  Nele, vemos o resultado de cada teste espec√≠fico e o resultado geral do teste de unidade. <br><br><h2>  6 regras de autoteste </h2><br>  Antes de come√ßar a criar um novo sistema para testes automatizados de um sistema de fidelidade, juntamente com a ger√™ncia, determinamos os princ√≠pios que nossos futuros testes autom√°ticos devem cumprir. <br><br><img src="https://habrastorage.org/webt/c_/tn/wg/c_tnwghfmcumhbuoq_q8osnv5wc.png"><br><br><ol><li>  Os testes autom√°ticos devem ser eficazes e devem ser ben√©ficos.  Temos desenvolvedores maravilhosos, sobre os quais devo dizer, porque um deles provavelmente ver√° este relat√≥rio e eles escrever√£o um c√≥digo maravilhoso.  Mas mesmo o c√≥digo maravilhoso deles n√£o √© perfeito e cont√©m, cont√©m e conter√° erros.  S√£o necess√°rios autotestes para encontrar esses erros.  Se n√£o √© assim, escrevemos autotestes ruins ou chegamos a uma √°rea morta que, em princ√≠pio, n√£o est√° sendo finalizada.  Nos dois casos, estamos fazendo algo errado, e nossa abordagem √© simplesmente sem sentido. </li><li>  Testes autom√°ticos devem ser usados.  N√£o faz sentido gastar muito tempo e esfor√ßo escrevendo um produto de software, adicionar seu reposit√≥rio e esquec√™-lo.  Os testes devem ser executados o mais regularmente poss√≠vel. </li><li>  Os autotestes devem funcionar de forma est√°vel.  Independentemente da hora do dia, do suporte de lan√ßamento ou de outras configura√ß√µes do sistema, a execu√ß√£o dos testes deve levar ao mesmo resultado.  Como regra, isso √© garantido pelo fato de que os autotestes funcionam com dados de teste especiais com configura√ß√µes fixas do sistema. </li><li>  Os testes autom√°ticos devem funcionar a uma velocidade aceit√°vel para o seu projeto.  Esse tempo √© determinado individualmente para cada sistema.  Algu√©m pode se dar ao luxo de trabalhar o dia inteiro e algu√©m se encaixa criticamente nos segundos.  Quais os padr√µes de velocidade que alcan√ßamos em nosso projeto, vou contar um pouco mais tarde. </li><li>  O desenvolvimento de autotestes deve ser flex√≠vel.  √â indesej√°vel recusar-se a testar qualquer funcionalidade simplesmente porque ainda n√£o o fizemos ou por outras convic√ß√µes.  O utPLSQL n√£o imp√µe nenhuma restri√ß√£o de desenvolvimento e o Oracle, em princ√≠pio, permite implementar uma variedade de coisas.  A maioria das tarefas tem uma solu√ß√£o, a √∫nica quest√£o √© tempo e esfor√ßo. </li><li>  Implanta√ß√£o.  Temos v√°rios estandes onde voc√™ precisa executar testes.  Em cada um dos estandes, um despejo de dados pode ser atualizado a qualquer momento.  √â necess√°rio realizar um projeto com autoteste, de forma a poder realizar sem problemas sua instala√ß√£o completa ou parcial. </li></ol><br><br>  E no segundo post, em alguns dias, vou contar o que fizemos e que resultados foram alcan√ßados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464335/">https://habr.com/ru/post/pt464335/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464317/index.html">Projeto Konbanwa</a></li>
<li><a href="../pt464325/index.html">Como o Scrumban une o melhor das metodologias Kanban e Scrum</a></li>
<li><a href="../pt464327/index.html">Compara√ß√£o do uso de mem√≥ria de diferentes GUIs do kit de ferramentas</a></li>
<li><a href="../pt464331/index.html">Benef√≠cios In√∫teis: S√≠ntese de Produtos Qu√≠micos Absorventes de UV a partir de Castanhas de Caju</a></li>
<li><a href="../pt464333/index.html">Acompanhamento do ciclo de vida dos usu√°rios sem alicate e fita isolante</a></li>
<li><a href="../pt464337/index.html">Como ignorar o captcha: rede neural no Tensorflow, Keras, python v num√©rico noisy captcha</a></li>
<li><a href="../pt464345/index.html">5 raz√µes para abrir uma startup de TI na Alemanha</a></li>
<li><a href="../pt464347/index.html">M√≥dulos de inje√ß√£o de depend√™ncia, JavaScript e ES6</a></li>
<li><a href="../pt464351/index.html">C√¢meras IP PoE, requisitos especiais e opera√ß√£o sem problemas - reunindo tudo</a></li>
<li><a href="../pt464353/index.html">1C: ERP VS 1C: KA 2.0. O que os fabricantes de alimentos devem escolher?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>