<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùé ‚õπüèø üõ•Ô∏è Utilisation de promesses en JavaScript üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üò≤ üë©üèª‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, nous publions des documents qui d'une mani√®re ou d'une autre se rapportent √† l'utilisation de promesses en JavaScript. 

 En voici ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de promesses en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  De temps en temps, nous publions des documents qui d'une mani√®re ou d'une autre se rapportent √† l'utilisation de promesses en JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">En voici quelques uns.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promesses dans ES6: Patterns et Anti-Patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript: m√©thodes de programmation asynchrones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript ES8 et transition vers async / attente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Async / Wait: 6 raisons d'oublier les promesses</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âchapper √† l'enfer asynchrone / attendre</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript ES6: √©crivez moins - faites plus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide des promesses pour ceux qui veulent comprendre</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception asynchrone / attente JavaScript: forces, pi√®ges et mod√®les d'utilisation</a> </div></div><br>  Pourquoi tant d'attention est-elle riv√©e aux promesses?  Nous pensons que le fait est que cette technologie est tr√®s demand√©e et qu'elle est assez difficile √† comprendre. <br><br>  Par cons√©quent, si vous souhaitez mieux comprendre les promesses, nous vous proposons une traduction du prochain article sur ce sujet.  Son auteur dit qu'il d√©veloppe Java et PHP depuis 10 ans, mais pendant tout ce temps, il a √©tudi√© avec int√©r√™t JavaScript.  R√©cemment, il a d√©cid√© de s'engager s√©rieusement dans JS, et les promesses sont devenues le premier sujet qui l'int√©ressait. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Nous pensons que ce mat√©riel sera int√©ressant pour les d√©veloppeurs d√©butants qui estiment que, m√™me s'ils utilisent des promesses, ils ne les comprennent pas assez bien.  Il est possible que l'histoire de quelqu'un qui regarde JavaScript avec un nouveau regard et veut expliquer aux autres ce qu'il a lui-m√™me compris, ne croyant pas que certaines choses soient compr√©hensibles par tout le monde et sans explication, aidera les d√©butants √† ma√Ætriser les m√©canismes JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript √† travers les yeux d'un d√©butant</font> </h2><br>  Quiconque commence √† √©crire en JavaScript peut ressentir ce qu'on appelle ¬´hors de propos¬ª.  Certains disent que JS est un langage de programmation synchrone, d'autres disent qu'il est asynchrone.  Un d√©butant entend parler du code qui bloque le thread principal et du code qui ne le bloque pas, des mod√®les de conception bas√©s sur des √©v√©nements, du cycle de vie des √©v√©nements, de la pile des appels de fonction, de la file d'attente des √©v√©nements et de leur ascension, des polyfills.  Il apprend qu'il existe des choses comme Babel, Angular, React, Vue et une myriade d'autres biblioth√®ques.  Si vous venez de vous reconna√Ætre dans un tel ¬´novice¬ª, ne vous en faites pas.  Vous n'√™tes ni le premier ni le dernier.  Il y a m√™me un terme pour cela - la soi-disant ¬´fatigue JavaScript¬ª.  Lucas F Costa en a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">parl√©</a> avec justesse: "La <i>fatigue JavaScript est quelque chose qui peut √™tre observ√© lorsque les gens utilisent des outils dont ils n'ont pas besoin pour r√©soudre des probl√®mes qu'ils n'ont pas</i> ." <br><br>  Mais ne parlons pas de tristes choses.  Ainsi, JavaScript est un langage de programmation synchrone qui, gr√¢ce au m√©canisme de rappel, vous permet d'appeler des fonctions de la m√™me mani√®re que dans les langages asynchrones. <br><br><h2>  <font color="#3AC1EF">Une histoire simple sur les promesses</font> </h2><br>  Le mot promesse se traduit par promesse.  Les objets de promesse dans la programmation, que nous appelons ¬´promesses¬ª, sont tr√®s similaires aux promesses habituelles que les gens se font dans la vraie vie.  Parlons donc d'abord de ces promesses. <br><br>  Sur Wikip√©dia, vous pouvez trouver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©finition</a> suivante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du</a> mot ¬´promesse¬ª: ¬´obligation, consentement de quelqu'un √† accomplir quelque chose ou, au contraire, √† ne pas faire¬ª.  Dans le dictionnaire d'Ozhegov, ¬´promesse¬ª est ¬´un engagement volontaire de faire quelque chose¬ª. <br><br>  Alors, que savons-nous des promesses? <br><br><ol><li>  Une promesse vous donne la garantie que quelque chose sera fait.  Peu importe qui fait exactement cela: celui qui a fait la promesse, ou quelqu'un d'autre, √† la demande de celui qui a fait la promesse.  Une promesse donne confiance en quelque chose, sur la base de cette confiance, celui qui a re√ßu la promesse peut, par exemple, faire des plans. </li><li>  Une promesse peut √™tre tenue ou non. </li><li>  Si la promesse est tenue, alors, par cons√©quent, vous vous attendez √† quelque chose que vous pouvez utiliser √† l'avenir pour effectuer des actions ou mettre en ≈ìuvre des plans. </li><li>  Si la promesse n'est pas tenue, alors vous voudrez savoir pourquoi celui qui l'a donn√©e n'a pas pu la r√©aliser.  Apr√®s avoir trouv√© la raison de ce qui s'est pass√© et vous serez s√ªr que la promesse n'a pas √©t√© tenue, vous pouvez penser √† ce qu'il faut faire ensuite, ou comment faire face √† la situation. </li><li>  Apr√®s qu'on vous ait promis quelque chose, tout ce que vous avez est une sorte de garantie.  Vous ne pouvez pas profiter imm√©diatement de ce qui vous a √©t√© promis.  Vous pouvez d√©terminer vous-m√™me ce que vous devez faire si la promesse est remplie (par cons√©quent, vous recevrez la promesse), et ce que vous devez faire si elle s'av√®re √™tre rompue (dans ce cas, vous connaissez la raison de ce qui s'est pass√©, et donc vous pouvez r√©fl√©chir √† un plan de sauvegarde des actions ) </li><li>  Il est probable que la personne qui a fait la promesse dispara√Ætra tout simplement.  Dans de tels cas, il est utile que la promesse soit li√©e √† une sorte de d√©lai.  Par exemple, si celui qui vous a fait la promesse n'appara√Æt pas dans 10 jours, vous pouvez supposer qu'il a eu des probl√®mes et qu'il a rompu la promesse.  Par cons√©quent, m√™me si celui qui a fait la promesse la remplit en 15 jours, cela n'aura pas d'importance, alors vous agissez d√©j√† sur le plan alternatif, sans compter sur la promesse. </li></ol><br>  Passez maintenant √† JavaScript. <br><br><h2>  <font color="#3AC1EF">Promesses JavaScript</font> </h2><br>  J'ai une r√®gle: lorsque je fais du JavaScript, je lis toujours la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> qui se trouve sur MDN.  Il me semble que cette ressource se compare favorablement aux autres en termes de sp√©cificit√© et de clart√© de pr√©sentation.  Par cons√©quent, tout en √©tudiant les promesses, je me suis familiaris√© avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mat√©riel</a> pertinent et j'ai exp√©riment√© le code afin de m'habituer aux nouvelles constructions syntaxiques. <br><br>  Afin de comprendre les promesses, vous devez faire face √† deux choses principales.  Le premier est la cr√©ation de promesses.  La seconde traite les r√©sultats renvoy√©s par les promesses.  Bien que la majeure partie du code que nous √©crivons vise √† travailler avec des promesses cr√©√©es, par exemple, par certaines biblioth√®ques, une compr√©hension compl√®te des m√©canismes de travail des promesses sera sans aucun doute utile.  De plus, pour un programmeur qui a d√©j√† une certaine exp√©rience, savoir comment cr√©er des promesses est tout aussi important que de savoir comment travailler avec elles. <br><br><h2>  <font color="#3AC1EF">Cr√©er des promesses</font> </h2><br>  Voici comment les promesses sont cr√©√©es: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  Le constructeur accepte une fonction qui effectue certaines actions, nous l'avons appel√©e ici <code>executor</code> .  Cette fonction prend deux param√®tres - <code>resolve</code> et <code>reject</code> , qui, √† leur tour, sont √©galement des fonctions.  Les promesses sont g√©n√©ralement utilis√©es pour effectuer des op√©rations asynchrones ou du code qui peut bloquer le thread principal, par exemple, celui qui fonctionne avec des fichiers, effectue des appels d'API, effectue des requ√™tes de base de donn√©es, traite les E / S, etc.  Le d√©marrage de telles op√©rations asynchrones est effectu√© dans la fonction <code>executor</code> .  Si l'op√©ration asynchrone s'est termin√©e avec succ√®s, le r√©sultat attendu de la promesse sera renvoy√© en appelant la fonction de <code>resolve</code> .  La situation dans laquelle cette fonction est appel√©e est d√©termin√©e par le cr√©ateur de la promesse.  De m√™me, lorsqu'une erreur se produit, des informations sur ce qui s'est produit sont renvoy√©es en appelant la fonction de <code>reject</code> . <br><br>  Maintenant que nous savons, en termes g√©n√©raux, comment cr√©er des promesses, nous allons cr√©er une promesse simple afin de mieux comprendre tout. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Voici ce que ce code affichera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise a un √©tat (PromiseStatus) et une valeur (PromiseValue)</font></i> <br><br>  Puisque notre promesse est instantan√©ment r√©solue, nous ne pouvons pas enqu√™ter sur son √©tat initial.  Par cons√©quent, cr√©ons une nouvelle promesse, qui, pour la r√©solution, a besoin de temps.  Pour ce faire, la m√©thode la plus simple consiste √† utiliser la fonction <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  Dans ce code, une promesse est cr√©√©e qui se r√©soudra certainement en 10 secondes.  Cela nous donne l'occasion d'examiner l'√©tat d'une promesse non autoris√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Promesse non r√©solue</font></i> <br><br>  Apr√®s 10 secondes, la promesse sera r√©solue.  Par cons√©quent, <code>PromiseStatus</code> et <code>PromiseValue</code> seront mis √† jour en cons√©quence.  Comme vous pouvez le voir, dans cet exemple, nous avons chang√© la fonction appel√©e lorsque la promesse a √©t√© r√©solue avec succ√®s, maintenant elle retourne non pas une cha√Æne ordinaire, mais un objet.  Cette op√©ration est effectu√©e afin de d√©montrer la capacit√© de renvoyer des structures de donn√©es complexes √† l'aide de la fonction de <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Promesse r√©solue apr√®s 10 secondes et retour d'un objet</font></i> <br><br>  Examinons maintenant la promesse, que nous avons d√©cid√© de ne pas autoriser, mais de rejeter.  Pour ce faire, nous modifions le code d√©j√† utilis√© dans le premier exemple. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Comme nous ne g√©rons pas la situation de rejet de la promesse, un message d'erreur sera affich√© dans la console du navigateur (Google Chrome est utilis√© ici).  Nous en parlerons plus loin ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Promesse refus√©e</font></i> <br><br>  Maintenant, apr√®s avoir analys√© les trois exemples, nous pouvons voir que trois valeurs diff√©rentes peuvent appara√Ætre dans <code>PromiseStatus</code> : en <code>pending</code> (en attente), <code>resolved</code> (r√©solution r√©ussie) et <code>rejected</code> (rejet).  Lorsqu'une promesse est cr√©√©e, dans <code>PromiseStatus</code> est en <code>pending</code> et dans <code>PromiseValue</code> n'est pas <code>undefined</code> .  Ces valeurs resteront jusqu'√† ce que la promesse soit r√©solue ou rejet√©e.  Lorsqu'une promesse est dans un √©tat <code>resolved</code> ou <code>rejected</code> , elle est appel√©e promesse <code>settled</code> .  Une telle promesse est pass√©e d'un √©tat d'attente √† un √©tat dans lequel elle a soit un √©tat <code>resolved</code> soit un √©tat <code>rejected</code> . <br><br>  Maintenant que nous avons appris comment les promesses sont cr√©√©es, nous pouvons parler de la fa√ßon de traiter ce qu‚Äôelles retournent.  Afin de comprendre cela, nous devons comprendre la structure de l'objet <code>Promise</code> . <br><br><h2>  <font color="#3AC1EF">Objet de promesse</font> </h2><br>  Selon la documentation MDN, un objet <code>Promise</code> est le r√©sultat de la r√©ussite ou de l'√©chec d'une op√©ration asynchrone. <br><br>  L'objet <code>Promise</code> poss√®de des m√©thodes statiques et des m√©thodes prototypes de l'objet.  Les m√©thodes statiques peuvent √™tre appel√©es sans cr√©er d'instance de l'objet et pour appeler les m√©thodes de prototype, vous avez besoin d'une instance de l'objet <code>Promise</code> .  N'oubliez pas que les m√©thodes statiques et r√©guli√®res renvoient des objets <code>Promise</code> .  Cela facilite le travail. <br><br><h3>  <font color="#3AC1EF">‚ñç Promettre des m√©thodes de prototypage d'objets</font> </h3><br>  Parlons d'abord des m√©thodes prototypes de l'objet <code>Promise</code> .  Il existe trois m√©thodes de ce type.  N'oubliez pas que ces m√©thodes peuvent √™tre appel√©es sur l'instance d'objet <code>Promise</code> et qu'elles renvoient elles-m√™mes les promesses.  Gr√¢ce √† toutes ces m√©thodes, vous pouvez affecter des gestionnaires qui r√©pondent aux changements de statut des promesses.  Comme nous l'avons d√©j√† vu, lorsqu'une promesse est cr√©√©e, elle est en <code>pending</code> .  Lorsqu'une promesse passe √† un √©tat <code>resolved</code> ou <code>rejected</code> , au moins l'une des m√©thodes suivantes sera appel√©e: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Voici un diagramme du fonctionnement de la promesse et des √©v√©nements qui ont conduit √† l'appel des <code>.catch</code> <code>.then</code> et <code>.catch</code> .  √âtant donn√© que ces m√©thodes retournent des objets <code>Promise</code> , leurs appels peuvent √™tre cha√Æn√©s, cela se refl√®te √©galement dans le diagramme.  Si la promesse utilise la m√©thode <code>.finally</code> , elle sera appel√©e lorsque la promesse passera √† l'√©tat <code>settled</code> , que la promesse ait √©t√© r√©solue ou rejet√©e avec succ√®s. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Plan de travail Promis (image prise √† <a href="">partir d'ici</a> )</font></i> <br><br>  Voici une petite histoire.  Vous √™tes √©tudiante et demandez √† votre m√®re de vous acheter un t√©l√©phone portable.  Elle dit: "Si nos √©conomies sont sup√©rieures au co√ªt du t√©l√©phone, je l'ach√®terai pour vous."  Racontez maintenant cette histoire en JavaScript. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Voici ce que ce code affichera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Maman n'a pas tenu sa promesse</font></i> <br><br>  Si nous modifions la valeur de la variable <code>momsSavings</code> √† 200 000, alors maman pourra acheter un cadeau pour son fils.  Dans ce cas, le code ci-dessus affichera les √©l√©ments suivants. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Maman a tenu une promesse</font></i> <br><br>  Imaginons maintenant que le code en question soit con√ßu comme une biblioth√®que, et nous utilisons cette biblioth√®que.  Parlons de l'utilisation efficace des <code>.catch</code> <code>.then</code> et <code>.catch</code> . <br><br>  √âtant donn√© que la m√©thode <code>.then</code> peut √™tre affect√©e √† la fois au gestionnaire <code>onFulfilled</code> , qui est appel√© lorsque la promesse est correctement r√©solue, et au gestionnaire <code>onRejected</code> , qui est appel√© lorsque la promesse est rejet√©e, au lieu d'utiliser les <code>.catch</code> <code>.then</code> et <code>.catch</code> , nous pouvons obtenir le m√™me effet avec une seule <code>.then</code> m√©thode.  Voici √† quoi cela pourrait ressembler: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Il s'agit d'un exemple de travail, mais afin d'√©viter la lisibilit√© du code, il est pr√©f√©rable d'utiliser les m√©thodes <code>.then</code> et <code>.catch</code> au lieu d'un <code>.then</code> universel. <br><br>  Pour que ces exemples soient ex√©cut√©s dans un navigateur, et sp√©cifiquement dans Google Chrome, j'ai essay√© d'√©viter les d√©pendances externes.  Afin de mieux comprendre ce que nous consid√©rerons plus tard, cr√©ons une fonction qui renvoie une promesse, dont la r√©solution ou le rejet se produit de mani√®re al√©atoire.  Cela nous permettra de d√©couvrir diff√©rents sc√©narios de travail avec des promesses.  Afin de comprendre les caract√©ristiques des fonctions asynchrones, nous allons d√©finir des retards al√©atoires dans nos promesses.  Puisque nous avons besoin de nombres al√©atoires, nous cr√©ons une fonction qui renvoie un nombre al√©atoire entre <code>x</code> et <code>y</code> .  Voici la fonction. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Cr√©ez maintenant une fonction qui renvoie des promesses.  <code>promiseTRRARNOSG</code> le <code>promiseTRRARNOSG</code> .  Le nom de cette fonction signifie <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , c'est-√†-dire qu'il s'agit d'un g√©n√©rateur de promesses r√©solues ou rejet√©es de mani√®re al√©atoire apr√®s un nombre al√©atoire de secondes.  Cette fonction cr√©era une promesse qui sera autoris√©e ou rejet√©e apr√®s une p√©riode de temps al√©atoire entre 2 et 10 secondes.  Afin d'autoriser ou de refuser au hasard une promesse, nous obtenons un nombre al√©atoire compris entre 1 et 10. Si ce nombre est sup√©rieur √† 5, la promesse sera autoris√©e, sinon, elle sera rejet√©e. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Ex√©cutez ce code dans la console du navigateur pour voir comment les promesses autoris√©es et rejet√©es se comportent.  Ensuite, nous verrons comment vous pouvez cr√©er de nombreuses promesses et v√©rifier les r√©sultats de leur mise en ≈ìuvre, en utilisant d'autres m√©canismes. <br><br><h3>  <font color="#3AC1EF">MethodsM√©thodes statiques d'un objet Promise</font> </h3><br>  Il existe quatre m√©thodes statiques d'un objet <code>Promise</code> . <br><br>  Voici deux m√©thodes - <code>Promise.reject(reason)</code> et <code>Promise.resolve(value)</code> , qui vous permettent de cr√©er, respectivement, des promesses rejet√©es et autoris√©es. <br><br>  Voici comment travailler avec la m√©thode <code>Promise.reject</code> , qui cr√©e des promesses rejet√©es. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Voici un exemple utilisant la m√©thode <code>Promise.resolve</code> qui cr√©e des promesses r√©solues avec succ√®s. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Il convient de noter qu'une promesse peut avoir plusieurs gestionnaires.  Par exemple, sur la base de l'exemple pr√©c√©dent, vous pouvez obtenir le code indiqu√© ci-dessous. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Voici ce qu'il affiche dans la console du navigateur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Utiliser plusieurs .then lorsque vous travaillez avec Promise</font></i> <br><br>  Les deux m√©thodes suivantes, <code>Promise.all</code> et <code>Promise.race</code> , sont con√ßues pour fonctionner avec des ensembles de promesses.  Si, pour r√©soudre un certain probl√®me, il est n√©cessaire de traiter plusieurs promesses, il est plus pratique de placer ces promesses dans un tableau, puis d'effectuer avec elles les actions n√©cessaires.  Afin de comprendre l'essence des m√©thodes consid√©r√©es ici, nous ne pourrons pas utiliser notre fonction pratique <code>promiseTRRARNOSG</code> , car le r√©sultat de son travail d√©pend trop de la volont√© du cas.  Il nous sera plus pratique d'utiliser quelque chose qui produit des promesses plus pr√©visibles, ce qui nous permettra de comprendre leur comportement.  Par cons√©quent, nous allons cr√©er deux nouvelles fonctions.  L'un d'eux ( <code>promiseTRSANSG</code> ) cr√©era des promesses qui sont r√©solues apr√®s <code>n</code> secondes, la seconde ( <code>promiseTRJANSG</code> ) - des promesses qui sont rejet√©es apr√®s <code>n</code> secondes. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Nous allons maintenant utiliser ces fonctions afin de comprendre les fonctionnalit√©s de la m√©thode <code>Promise.all</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç M√©thode Promise.all</font> </h3><br>  Dans la documentation MDN, vous pouvez d√©couvrir que la <code>Promise.all(iterable)</code> renvoie une promesse qui sera r√©solue lorsque toutes les promesses pass√©es en tant qu'argument <code>iterable</code> seront <code>iterable</code> , ou lorsque cet argument ne contient aucune promesse.  Cette promesse sera rejet√©e si l'une des promesses transf√©r√©es est rejet√©e. <br>  Regardons quelques exemples. <br><br><h4>  Exemple n ¬∞ 1 </h4><br>  Toutes les promesses seront autoris√©es ici.  Ce sc√©nario est le plus courant. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Voici ce que ce code affichera sur la console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Toutes les promesses autoris√©es</font></i> <br><br>  Apr√®s avoir analys√© les r√©sultats de cet exemple, deux observations importantes peuvent √™tre faites. <br><br>  Premi√®rement, la troisi√®me promesse, dont la r√©solution prend 2 secondes, est termin√©e avant la seconde, mais, comme le montre la sortie g√©n√©r√©e par le code, l'ordre des promesses dans le tableau est conserv√©. <br><br>  Deuxi√®mement, le code contient un temporisateur qui est utilis√© pour savoir combien de temps il faut pour ex√©cuter l'instruction <code>Promise.all</code> . <br><br>  Si les promesses √©taient ex√©cut√©es s√©quentiellement, le temps d'ex√©cution de cette instruction serait de 7 secondes (1 + 4 + 2).  Cependant, la minuterie nous informe que toute l'op√©ration a pris 4 secondes si nous arrondissons le r√©sultat.  C'est la preuve que toutes les promesses sont ex√©cut√©es en parall√®le. <br><br><h4>  Exemple n ¬∞ 2 </h4><br>  Consid√©rez maintenant la situation o√π il n'y a aucune promesse dans le tableau pass√© √† Promise.all.  Je pense que c'est le cas d'utilisation le moins courant pour cette fonctionnalit√©. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Voici la sortie que ce code va g√©n√©rer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Appelez Promise.all et passez un tableau ne contenant aucune promesse √† cette m√©thode</font></i> <br><br>  Puisqu'il n'y a aucune promesse dans le tableau, <code>Promise.all</code> presque instantan√©ment. <br><br><h4>  Exemple n ¬∞ 3 </h4><br>  Voyons maintenant ce qui se passe lorsque l'une des promesses pass√©es √† <code>Promise.all</code> est rejet√©e. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Comme vous pouvez le voir dans les r√©sultats d'ex√©cution de code ci-dessous, l'ex√©cution de <code>Promise.all</code> s'arr√™te apr√®s la premi√®re promesse rejet√©e avec la sortie du message que cette promesse donne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">L'ex√©cution s'arr√™te apr√®s la premi√®re promesse rejet√©e</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç M√©thode Promise.race</font> </h3><br>  MDN signale que la <code>Promise.race(iterable)</code> renvoie une promesse autoris√©e ou rejet√©e avec une valeur ou un motif de rejet apr√®s que l'une des promesses transmises est respectivement autoris√©e ou rejet√©e. <br><br>  Regardons des exemples de travail avec <code>Promise.race</code> . <br><br><h4>  Exemple n ¬∞ 1 </h4><br>  Il montre ce qui se passe lorsque l'une des promesses pass√©es √† <code>Promise.race</code> est r√©solue avant tout le monde. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  C'est ce qui arrive √† la console apr√®s avoir ex√©cut√© cet exemple. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, qui a r√©solu plus rapidement que tout le monde</font></i> <br><br>  Toutes les promesses ici sont r√©alis√©es en parall√®le.  La troisi√®me promesse est r√©solue apr√®s 2 secondes.  D√®s que cela se produit, la promesse retourn√©e par <code>Promise.race</code> est r√©solue. <br><br><h4>  Exemple n ¬∞ 2 </h4><br>  Consid√©rez maintenant la situation lorsque l'une des promesses pass√©es √† <code>Promise.race</code> est rejet√©e. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Apr√®s avoir ex√©cut√© cet exemple, les √©l√©ments suivants arriveront sur la console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Promesse rejet√©e avant tout le monde</font></i> <br><br>  Les promesses ici, comme dans les exemples pr√©c√©dents, sont effectu√©es en parall√®le.  La quatri√®me promesse est rejet√©e apr√®s 3 secondes.  D√®s que cela se produit, la promesse retourn√©e par <code>Promise.race</code> est rejet√©e. <br><br><h2>  <font color="#3AC1EF">Exemple g√©n√©ral et exp√©riences</font> </h2><br>  J'ai rassembl√© tous les exemples que nous avons consid√©r√©s dans ce document en un seul endroit, ce qui facilitera leur exp√©rimentation, pour explorer divers sc√©narios de travail avec des promesses.  Ce code est con√ßu pour √™tre ex√©cut√© dans un navigateur, donc ici nous n'utilisons aucun appel d'API, n'acc√©dons pas aux op√©rations sur les fichiers et ne travaillons pas avec les bases de donn√©es.  Bien que tout cela trouve une application dans le d√©veloppement de projets r√©els, je pense que travailler avec ces m√©canismes peut nous distraire de notre objectif principal - les promesses.  Et l'utilisation de fonctions simples qui simulent des retards donne des r√©sultats similaires et ne nous charge pas de d√©tails suppl√©mentaires. <br><br>  En explorant ces exemples vous-m√™me, vous pouvez exp√©rimenter avec le code, avec les valeurs des variables et √©tudier diff√©rents sc√©narios d'utilisation des promesses.  En particulier, vous pouvez utiliser une combinaison des <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> et <code>promiseTRRARNOSG</code> afin de simuler de nombreux sc√©narios d'utilisation des promesses, ce qui vous permet de mieux les comprendre.  En outre, notez que l'utilisation de la commande <code>console.time</code> vous permet de conna√Ætre le temps requis pour ex√©cuter un certain morceau de code et, par exemple, de savoir si les promesses sont ex√©cut√©es en parall√®le ou s√©quentiellement.  Voici un <a href="">lien</a> vers la page gist avec le code.  Et au fait, si vous le souhaitez, jetez un ≈ìil √† la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bluebird</a> , qui contient des m√©thodes int√©ressantes pour travailler avec des promesses. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Je vous propose une liste de r√®gles que j'adh√®re lorsque je travaille avec des promesses afin de les utiliser correctement. <br><br><ol><li>  Utilisez des promesses lorsque vous travaillez avec du code asynchrone ou bloquant. </li><li>  Pour g√©rer la situation de r√©solution r√©ussie d'une promesse, utilisez la m√©thode <code>.then</code> ; pour les cas o√π la promesse est rejet√©e, utilisez <code>.catch</code> . </li><li>  Utilisez les <code>.catch</code> <code>.then</code> et <code>.catch</code> dans toutes les promesses. </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Chers lecteurs!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418085/">https://habr.com/ru/post/fr418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418075/index.html">TOP 5 des choses qui peuvent √™tre imprim√©es sur une imprimante 3D [vid√©o]</a></li>
<li><a href="../fr418077/index.html">Accidents de ¬´ne pas regarder¬ª: une justification statistique du mode de fonctionnement du support technique 24/7</a></li>
<li><a href="../fr418079/index.html">Les langages de programmation les plus populaires - 2018</a></li>
<li><a href="../fr418081/index.html">Organisation de tests s√ªrs en production. Partie 1</a></li>
<li><a href="../fr418083/index.html">Serveur simple avec GraphQL au lieu de REST, impl√©mentation en java</a></li>
<li><a href="../fr418087/index.html">80% des caisses libre-service sont √† risque</a></li>
<li><a href="../fr418089/index.html">Pr√©sentation de la fraiseuse CNC SolidCraft</a></li>
<li><a href="../fr418091/index.html">Liste d'articles et de litt√©rature sur NAS</a></li>
<li><a href="../fr418093/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 3: Buffer Overflows: Exploits and Protection, Part 2</a></li>
<li><a href="../fr418095/index.html">√Ä propos de l'appareil de fonctionnalit√© de test int√©gr√©e dans Rust (traduction)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>