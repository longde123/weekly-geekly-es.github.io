<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❎ ⛹🏿 🛥️ Utilisation de promesses en JavaScript 🧑🏿‍🤝‍🧑🏽 😲 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, nous publions des documents qui d'une manière ou d'une autre se rapportent à l'utilisation de promesses en JavaScript. 

 En voici ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de promesses en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  De temps en temps, nous publions des documents qui d'une manière ou d'une autre se rapportent à l'utilisation de promesses en JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">En voici quelques uns.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promesses dans ES6: Patterns et Anti-Patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript: méthodes de programmation asynchrones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript ES8 et transition vers async / attente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Async / Wait: 6 raisons d'oublier les promesses</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Échapper à l'enfer asynchrone / attendre</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript ES6: écrivez moins - faites plus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide des promesses pour ceux qui veulent comprendre</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception asynchrone / attente JavaScript: forces, pièges et modèles d'utilisation</a> </div></div><br>  Pourquoi tant d'attention est-elle rivée aux promesses?  Nous pensons que le fait est que cette technologie est très demandée et qu'elle est assez difficile à comprendre. <br><br>  Par conséquent, si vous souhaitez mieux comprendre les promesses, nous vous proposons une traduction du prochain article sur ce sujet.  Son auteur dit qu'il développe Java et PHP depuis 10 ans, mais pendant tout ce temps, il a étudié avec intérêt JavaScript.  Récemment, il a décidé de s'engager sérieusement dans JS, et les promesses sont devenues le premier sujet qui l'intéressait. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Nous pensons que ce matériel sera intéressant pour les développeurs débutants qui estiment que, même s'ils utilisent des promesses, ils ne les comprennent pas assez bien.  Il est possible que l'histoire de quelqu'un qui regarde JavaScript avec un nouveau regard et veut expliquer aux autres ce qu'il a lui-même compris, ne croyant pas que certaines choses soient compréhensibles par tout le monde et sans explication, aidera les débutants à maîtriser les mécanismes JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript à travers les yeux d'un débutant</font> </h2><br>  Quiconque commence à écrire en JavaScript peut ressentir ce qu'on appelle «hors de propos».  Certains disent que JS est un langage de programmation synchrone, d'autres disent qu'il est asynchrone.  Un débutant entend parler du code qui bloque le thread principal et du code qui ne le bloque pas, des modèles de conception basés sur des événements, du cycle de vie des événements, de la pile des appels de fonction, de la file d'attente des événements et de leur ascension, des polyfills.  Il apprend qu'il existe des choses comme Babel, Angular, React, Vue et une myriade d'autres bibliothèques.  Si vous venez de vous reconnaître dans un tel «novice», ne vous en faites pas.  Vous n'êtes ni le premier ni le dernier.  Il y a même un terme pour cela - la soi-disant «fatigue JavaScript».  Lucas F Costa en a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">parlé</a> avec justesse: "La <i>fatigue JavaScript est quelque chose qui peut être observé lorsque les gens utilisent des outils dont ils n'ont pas besoin pour résoudre des problèmes qu'ils n'ont pas</i> ." <br><br>  Mais ne parlons pas de tristes choses.  Ainsi, JavaScript est un langage de programmation synchrone qui, grâce au mécanisme de rappel, vous permet d'appeler des fonctions de la même manière que dans les langages asynchrones. <br><br><h2>  <font color="#3AC1EF">Une histoire simple sur les promesses</font> </h2><br>  Le mot promesse se traduit par promesse.  Les objets de promesse dans la programmation, que nous appelons «promesses», sont très similaires aux promesses habituelles que les gens se font dans la vraie vie.  Parlons donc d'abord de ces promesses. <br><br>  Sur Wikipédia, vous pouvez trouver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">définition</a> suivante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du</a> mot «promesse»: «obligation, consentement de quelqu'un à accomplir quelque chose ou, au contraire, à ne pas faire».  Dans le dictionnaire d'Ozhegov, «promesse» est «un engagement volontaire de faire quelque chose». <br><br>  Alors, que savons-nous des promesses? <br><br><ol><li>  Une promesse vous donne la garantie que quelque chose sera fait.  Peu importe qui fait exactement cela: celui qui a fait la promesse, ou quelqu'un d'autre, à la demande de celui qui a fait la promesse.  Une promesse donne confiance en quelque chose, sur la base de cette confiance, celui qui a reçu la promesse peut, par exemple, faire des plans. </li><li>  Une promesse peut être tenue ou non. </li><li>  Si la promesse est tenue, alors, par conséquent, vous vous attendez à quelque chose que vous pouvez utiliser à l'avenir pour effectuer des actions ou mettre en œuvre des plans. </li><li>  Si la promesse n'est pas tenue, alors vous voudrez savoir pourquoi celui qui l'a donnée n'a pas pu la réaliser.  Après avoir trouvé la raison de ce qui s'est passé et vous serez sûr que la promesse n'a pas été tenue, vous pouvez penser à ce qu'il faut faire ensuite, ou comment faire face à la situation. </li><li>  Après qu'on vous ait promis quelque chose, tout ce que vous avez est une sorte de garantie.  Vous ne pouvez pas profiter immédiatement de ce qui vous a été promis.  Vous pouvez déterminer vous-même ce que vous devez faire si la promesse est remplie (par conséquent, vous recevrez la promesse), et ce que vous devez faire si elle s'avère être rompue (dans ce cas, vous connaissez la raison de ce qui s'est passé, et donc vous pouvez réfléchir à un plan de sauvegarde des actions ) </li><li>  Il est probable que la personne qui a fait la promesse disparaîtra tout simplement.  Dans de tels cas, il est utile que la promesse soit liée à une sorte de délai.  Par exemple, si celui qui vous a fait la promesse n'apparaît pas dans 10 jours, vous pouvez supposer qu'il a eu des problèmes et qu'il a rompu la promesse.  Par conséquent, même si celui qui a fait la promesse la remplit en 15 jours, cela n'aura pas d'importance, alors vous agissez déjà sur le plan alternatif, sans compter sur la promesse. </li></ol><br>  Passez maintenant à JavaScript. <br><br><h2>  <font color="#3AC1EF">Promesses JavaScript</font> </h2><br>  J'ai une règle: lorsque je fais du JavaScript, je lis toujours la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> qui se trouve sur MDN.  Il me semble que cette ressource se compare favorablement aux autres en termes de spécificité et de clarté de présentation.  Par conséquent, tout en étudiant les promesses, je me suis familiarisé avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matériel</a> pertinent et j'ai expérimenté le code afin de m'habituer aux nouvelles constructions syntaxiques. <br><br>  Afin de comprendre les promesses, vous devez faire face à deux choses principales.  Le premier est la création de promesses.  La seconde traite les résultats renvoyés par les promesses.  Bien que la majeure partie du code que nous écrivons vise à travailler avec des promesses créées, par exemple, par certaines bibliothèques, une compréhension complète des mécanismes de travail des promesses sera sans aucun doute utile.  De plus, pour un programmeur qui a déjà une certaine expérience, savoir comment créer des promesses est tout aussi important que de savoir comment travailler avec elles. <br><br><h2>  <font color="#3AC1EF">Créer des promesses</font> </h2><br>  Voici comment les promesses sont créées: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  Le constructeur accepte une fonction qui effectue certaines actions, nous l'avons appelée ici <code>executor</code> .  Cette fonction prend deux paramètres - <code>resolve</code> et <code>reject</code> , qui, à leur tour, sont également des fonctions.  Les promesses sont généralement utilisées pour effectuer des opérations asynchrones ou du code qui peut bloquer le thread principal, par exemple, celui qui fonctionne avec des fichiers, effectue des appels d'API, effectue des requêtes de base de données, traite les E / S, etc.  Le démarrage de telles opérations asynchrones est effectué dans la fonction <code>executor</code> .  Si l'opération asynchrone s'est terminée avec succès, le résultat attendu de la promesse sera renvoyé en appelant la fonction de <code>resolve</code> .  La situation dans laquelle cette fonction est appelée est déterminée par le créateur de la promesse.  De même, lorsqu'une erreur se produit, des informations sur ce qui s'est produit sont renvoyées en appelant la fonction de <code>reject</code> . <br><br>  Maintenant que nous savons, en termes généraux, comment créer des promesses, nous allons créer une promesse simple afin de mieux comprendre tout. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Voici ce que ce code affichera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise a un état (PromiseStatus) et une valeur (PromiseValue)</font></i> <br><br>  Puisque notre promesse est instantanément résolue, nous ne pouvons pas enquêter sur son état initial.  Par conséquent, créons une nouvelle promesse, qui, pour la résolution, a besoin de temps.  Pour ce faire, la méthode la plus simple consiste à utiliser la fonction <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  Dans ce code, une promesse est créée qui se résoudra certainement en 10 secondes.  Cela nous donne l'occasion d'examiner l'état d'une promesse non autorisée. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Promesse non résolue</font></i> <br><br>  Après 10 secondes, la promesse sera résolue.  Par conséquent, <code>PromiseStatus</code> et <code>PromiseValue</code> seront mis à jour en conséquence.  Comme vous pouvez le voir, dans cet exemple, nous avons changé la fonction appelée lorsque la promesse a été résolue avec succès, maintenant elle retourne non pas une chaîne ordinaire, mais un objet.  Cette opération est effectuée afin de démontrer la capacité de renvoyer des structures de données complexes à l'aide de la fonction de <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Promesse résolue après 10 secondes et retour d'un objet</font></i> <br><br>  Examinons maintenant la promesse, que nous avons décidé de ne pas autoriser, mais de rejeter.  Pour ce faire, nous modifions le code déjà utilisé dans le premier exemple. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Comme nous ne gérons pas la situation de rejet de la promesse, un message d'erreur sera affiché dans la console du navigateur (Google Chrome est utilisé ici).  Nous en parlerons plus loin ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Promesse refusée</font></i> <br><br>  Maintenant, après avoir analysé les trois exemples, nous pouvons voir que trois valeurs différentes peuvent apparaître dans <code>PromiseStatus</code> : en <code>pending</code> (en attente), <code>resolved</code> (résolution réussie) et <code>rejected</code> (rejet).  Lorsqu'une promesse est créée, dans <code>PromiseStatus</code> est en <code>pending</code> et dans <code>PromiseValue</code> n'est pas <code>undefined</code> .  Ces valeurs resteront jusqu'à ce que la promesse soit résolue ou rejetée.  Lorsqu'une promesse est dans un état <code>resolved</code> ou <code>rejected</code> , elle est appelée promesse <code>settled</code> .  Une telle promesse est passée d'un état d'attente à un état dans lequel elle a soit un état <code>resolved</code> soit un état <code>rejected</code> . <br><br>  Maintenant que nous avons appris comment les promesses sont créées, nous pouvons parler de la façon de traiter ce qu’elles retournent.  Afin de comprendre cela, nous devons comprendre la structure de l'objet <code>Promise</code> . <br><br><h2>  <font color="#3AC1EF">Objet de promesse</font> </h2><br>  Selon la documentation MDN, un objet <code>Promise</code> est le résultat de la réussite ou de l'échec d'une opération asynchrone. <br><br>  L'objet <code>Promise</code> possède des méthodes statiques et des méthodes prototypes de l'objet.  Les méthodes statiques peuvent être appelées sans créer d'instance de l'objet et pour appeler les méthodes de prototype, vous avez besoin d'une instance de l'objet <code>Promise</code> .  N'oubliez pas que les méthodes statiques et régulières renvoient des objets <code>Promise</code> .  Cela facilite le travail. <br><br><h3>  <font color="#3AC1EF">▍ Promettre des méthodes de prototypage d'objets</font> </h3><br>  Parlons d'abord des méthodes prototypes de l'objet <code>Promise</code> .  Il existe trois méthodes de ce type.  N'oubliez pas que ces méthodes peuvent être appelées sur l'instance d'objet <code>Promise</code> et qu'elles renvoient elles-mêmes les promesses.  Grâce à toutes ces méthodes, vous pouvez affecter des gestionnaires qui répondent aux changements de statut des promesses.  Comme nous l'avons déjà vu, lorsqu'une promesse est créée, elle est en <code>pending</code> .  Lorsqu'une promesse passe à un état <code>resolved</code> ou <code>rejected</code> , au moins l'une des méthodes suivantes sera appelée: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Voici un diagramme du fonctionnement de la promesse et des événements qui ont conduit à l'appel des <code>.catch</code> <code>.then</code> et <code>.catch</code> .  Étant donné que ces méthodes retournent des objets <code>Promise</code> , leurs appels peuvent être chaînés, cela se reflète également dans le diagramme.  Si la promesse utilise la méthode <code>.finally</code> , elle sera appelée lorsque la promesse passera à l'état <code>settled</code> , que la promesse ait été résolue ou rejetée avec succès. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Plan de travail Promis (image prise à <a href="">partir d'ici</a> )</font></i> <br><br>  Voici une petite histoire.  Vous êtes étudiante et demandez à votre mère de vous acheter un téléphone portable.  Elle dit: "Si nos économies sont supérieures au coût du téléphone, je l'achèterai pour vous."  Racontez maintenant cette histoire en JavaScript. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Voici ce que ce code affichera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Maman n'a pas tenu sa promesse</font></i> <br><br>  Si nous modifions la valeur de la variable <code>momsSavings</code> à 200 000, alors maman pourra acheter un cadeau pour son fils.  Dans ce cas, le code ci-dessus affichera les éléments suivants. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Maman a tenu une promesse</font></i> <br><br>  Imaginons maintenant que le code en question soit conçu comme une bibliothèque, et nous utilisons cette bibliothèque.  Parlons de l'utilisation efficace des <code>.catch</code> <code>.then</code> et <code>.catch</code> . <br><br>  Étant donné que la méthode <code>.then</code> peut être affectée à la fois au gestionnaire <code>onFulfilled</code> , qui est appelé lorsque la promesse est correctement résolue, et au gestionnaire <code>onRejected</code> , qui est appelé lorsque la promesse est rejetée, au lieu d'utiliser les <code>.catch</code> <code>.then</code> et <code>.catch</code> , nous pouvons obtenir le même effet avec une seule <code>.then</code> méthode.  Voici à quoi cela pourrait ressembler: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Il s'agit d'un exemple de travail, mais afin d'éviter la lisibilité du code, il est préférable d'utiliser les méthodes <code>.then</code> et <code>.catch</code> au lieu d'un <code>.then</code> universel. <br><br>  Pour que ces exemples soient exécutés dans un navigateur, et spécifiquement dans Google Chrome, j'ai essayé d'éviter les dépendances externes.  Afin de mieux comprendre ce que nous considérerons plus tard, créons une fonction qui renvoie une promesse, dont la résolution ou le rejet se produit de manière aléatoire.  Cela nous permettra de découvrir différents scénarios de travail avec des promesses.  Afin de comprendre les caractéristiques des fonctions asynchrones, nous allons définir des retards aléatoires dans nos promesses.  Puisque nous avons besoin de nombres aléatoires, nous créons une fonction qui renvoie un nombre aléatoire entre <code>x</code> et <code>y</code> .  Voici la fonction. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Créez maintenant une fonction qui renvoie des promesses.  <code>promiseTRRARNOSG</code> le <code>promiseTRRARNOSG</code> .  Le nom de cette fonction signifie <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , c'est-à-dire qu'il s'agit d'un générateur de promesses résolues ou rejetées de manière aléatoire après un nombre aléatoire de secondes.  Cette fonction créera une promesse qui sera autorisée ou rejetée après une période de temps aléatoire entre 2 et 10 secondes.  Afin d'autoriser ou de refuser au hasard une promesse, nous obtenons un nombre aléatoire compris entre 1 et 10. Si ce nombre est supérieur à 5, la promesse sera autorisée, sinon, elle sera rejetée. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Exécutez ce code dans la console du navigateur pour voir comment les promesses autorisées et rejetées se comportent.  Ensuite, nous verrons comment vous pouvez créer de nombreuses promesses et vérifier les résultats de leur mise en œuvre, en utilisant d'autres mécanismes. <br><br><h3>  <font color="#3AC1EF">MethodsMéthodes statiques d'un objet Promise</font> </h3><br>  Il existe quatre méthodes statiques d'un objet <code>Promise</code> . <br><br>  Voici deux méthodes - <code>Promise.reject(reason)</code> et <code>Promise.resolve(value)</code> , qui vous permettent de créer, respectivement, des promesses rejetées et autorisées. <br><br>  Voici comment travailler avec la méthode <code>Promise.reject</code> , qui crée des promesses rejetées. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Voici un exemple utilisant la méthode <code>Promise.resolve</code> qui crée des promesses résolues avec succès. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Il convient de noter qu'une promesse peut avoir plusieurs gestionnaires.  Par exemple, sur la base de l'exemple précédent, vous pouvez obtenir le code indiqué ci-dessous. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Voici ce qu'il affiche dans la console du navigateur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Utiliser plusieurs .then lorsque vous travaillez avec Promise</font></i> <br><br>  Les deux méthodes suivantes, <code>Promise.all</code> et <code>Promise.race</code> , sont conçues pour fonctionner avec des ensembles de promesses.  Si, pour résoudre un certain problème, il est nécessaire de traiter plusieurs promesses, il est plus pratique de placer ces promesses dans un tableau, puis d'effectuer avec elles les actions nécessaires.  Afin de comprendre l'essence des méthodes considérées ici, nous ne pourrons pas utiliser notre fonction pratique <code>promiseTRRARNOSG</code> , car le résultat de son travail dépend trop de la volonté du cas.  Il nous sera plus pratique d'utiliser quelque chose qui produit des promesses plus prévisibles, ce qui nous permettra de comprendre leur comportement.  Par conséquent, nous allons créer deux nouvelles fonctions.  L'un d'eux ( <code>promiseTRSANSG</code> ) créera des promesses qui sont résolues après <code>n</code> secondes, la seconde ( <code>promiseTRJANSG</code> ) - des promesses qui sont rejetées après <code>n</code> secondes. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Nous allons maintenant utiliser ces fonctions afin de comprendre les fonctionnalités de la méthode <code>Promise.all</code> . <br><br><h3>  <font color="#3AC1EF">▍ Méthode Promise.all</font> </h3><br>  Dans la documentation MDN, vous pouvez découvrir que la <code>Promise.all(iterable)</code> renvoie une promesse qui sera résolue lorsque toutes les promesses passées en tant qu'argument <code>iterable</code> seront <code>iterable</code> , ou lorsque cet argument ne contient aucune promesse.  Cette promesse sera rejetée si l'une des promesses transférées est rejetée. <br>  Regardons quelques exemples. <br><br><h4>  Exemple n ° 1 </h4><br>  Toutes les promesses seront autorisées ici.  Ce scénario est le plus courant. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Voici ce que ce code affichera sur la console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Toutes les promesses autorisées</font></i> <br><br>  Après avoir analysé les résultats de cet exemple, deux observations importantes peuvent être faites. <br><br>  Premièrement, la troisième promesse, dont la résolution prend 2 secondes, est terminée avant la seconde, mais, comme le montre la sortie générée par le code, l'ordre des promesses dans le tableau est conservé. <br><br>  Deuxièmement, le code contient un temporisateur qui est utilisé pour savoir combien de temps il faut pour exécuter l'instruction <code>Promise.all</code> . <br><br>  Si les promesses étaient exécutées séquentiellement, le temps d'exécution de cette instruction serait de 7 secondes (1 + 4 + 2).  Cependant, la minuterie nous informe que toute l'opération a pris 4 secondes si nous arrondissons le résultat.  C'est la preuve que toutes les promesses sont exécutées en parallèle. <br><br><h4>  Exemple n ° 2 </h4><br>  Considérez maintenant la situation où il n'y a aucune promesse dans le tableau passé à Promise.all.  Je pense que c'est le cas d'utilisation le moins courant pour cette fonctionnalité. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Voici la sortie que ce code va générer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Appelez Promise.all et passez un tableau ne contenant aucune promesse à cette méthode</font></i> <br><br>  Puisqu'il n'y a aucune promesse dans le tableau, <code>Promise.all</code> presque instantanément. <br><br><h4>  Exemple n ° 3 </h4><br>  Voyons maintenant ce qui se passe lorsque l'une des promesses passées à <code>Promise.all</code> est rejetée. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Comme vous pouvez le voir dans les résultats d'exécution de code ci-dessous, l'exécution de <code>Promise.all</code> s'arrête après la première promesse rejetée avec la sortie du message que cette promesse donne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">L'exécution s'arrête après la première promesse rejetée</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Méthode Promise.race</font> </h3><br>  MDN signale que la <code>Promise.race(iterable)</code> renvoie une promesse autorisée ou rejetée avec une valeur ou un motif de rejet après que l'une des promesses transmises est respectivement autorisée ou rejetée. <br><br>  Regardons des exemples de travail avec <code>Promise.race</code> . <br><br><h4>  Exemple n ° 1 </h4><br>  Il montre ce qui se passe lorsque l'une des promesses passées à <code>Promise.race</code> est résolue avant tout le monde. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  C'est ce qui arrive à la console après avoir exécuté cet exemple. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, qui a résolu plus rapidement que tout le monde</font></i> <br><br>  Toutes les promesses ici sont réalisées en parallèle.  La troisième promesse est résolue après 2 secondes.  Dès que cela se produit, la promesse retournée par <code>Promise.race</code> est résolue. <br><br><h4>  Exemple n ° 2 </h4><br>  Considérez maintenant la situation lorsque l'une des promesses passées à <code>Promise.race</code> est rejetée. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Après avoir exécuté cet exemple, les éléments suivants arriveront sur la console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Promesse rejetée avant tout le monde</font></i> <br><br>  Les promesses ici, comme dans les exemples précédents, sont effectuées en parallèle.  La quatrième promesse est rejetée après 3 secondes.  Dès que cela se produit, la promesse retournée par <code>Promise.race</code> est rejetée. <br><br><h2>  <font color="#3AC1EF">Exemple général et expériences</font> </h2><br>  J'ai rassemblé tous les exemples que nous avons considérés dans ce document en un seul endroit, ce qui facilitera leur expérimentation, pour explorer divers scénarios de travail avec des promesses.  Ce code est conçu pour être exécuté dans un navigateur, donc ici nous n'utilisons aucun appel d'API, n'accédons pas aux opérations sur les fichiers et ne travaillons pas avec les bases de données.  Bien que tout cela trouve une application dans le développement de projets réels, je pense que travailler avec ces mécanismes peut nous distraire de notre objectif principal - les promesses.  Et l'utilisation de fonctions simples qui simulent des retards donne des résultats similaires et ne nous charge pas de détails supplémentaires. <br><br>  En explorant ces exemples vous-même, vous pouvez expérimenter avec le code, avec les valeurs des variables et étudier différents scénarios d'utilisation des promesses.  En particulier, vous pouvez utiliser une combinaison des <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> et <code>promiseTRRARNOSG</code> afin de simuler de nombreux scénarios d'utilisation des promesses, ce qui vous permet de mieux les comprendre.  En outre, notez que l'utilisation de la commande <code>console.time</code> vous permet de connaître le temps requis pour exécuter un certain morceau de code et, par exemple, de savoir si les promesses sont exécutées en parallèle ou séquentiellement.  Voici un <a href="">lien</a> vers la page gist avec le code.  Et au fait, si vous le souhaitez, jetez un œil à la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bluebird</a> , qui contient des méthodes intéressantes pour travailler avec des promesses. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Je vous propose une liste de règles que j'adhère lorsque je travaille avec des promesses afin de les utiliser correctement. <br><br><ol><li>  Utilisez des promesses lorsque vous travaillez avec du code asynchrone ou bloquant. </li><li>  Pour gérer la situation de résolution réussie d'une promesse, utilisez la méthode <code>.then</code> ; pour les cas où la promesse est rejetée, utilisez <code>.catch</code> . </li><li>  Utilisez les <code>.catch</code> <code>.then</code> et <code>.catch</code> dans toutes les promesses. </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Chers lecteurs!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418085/">https://habr.com/ru/post/fr418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418075/index.html">TOP 5 des choses qui peuvent être imprimées sur une imprimante 3D [vidéo]</a></li>
<li><a href="../fr418077/index.html">Accidents de «ne pas regarder»: une justification statistique du mode de fonctionnement du support technique 24/7</a></li>
<li><a href="../fr418079/index.html">Les langages de programmation les plus populaires - 2018</a></li>
<li><a href="../fr418081/index.html">Organisation de tests sûrs en production. Partie 1</a></li>
<li><a href="../fr418083/index.html">Serveur simple avec GraphQL au lieu de REST, implémentation en java</a></li>
<li><a href="../fr418087/index.html">80% des caisses libre-service sont à risque</a></li>
<li><a href="../fr418089/index.html">Présentation de la fraiseuse CNC SolidCraft</a></li>
<li><a href="../fr418091/index.html">Liste d'articles et de littérature sur NAS</a></li>
<li><a href="../fr418093/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 3: Buffer Overflows: Exploits and Protection, Part 2</a></li>
<li><a href="../fr418095/index.html">À propos de l'appareil de fonctionnalité de test intégrée dans Rust (traduction)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>