<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüë® üö∞ üèπ Consola de juegos de bricolaje h√°galo usted mismo üôèüèº üí™üèø üòä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n es una introducci√≥n a mi proyecto de consolas de video de consola "caseras" hechas desde cero. Me inspiraron tanto las consolas retro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Consola de juegos de bricolaje h√°galo usted mismo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444006/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="imagen"></p><br><p>  Esta publicaci√≥n es una introducci√≥n a mi proyecto de consolas de video de consola "caseras" hechas desde cero.  Me inspiraron tanto las consolas retro como las muestras modernas, pero obtuve mi propia arquitectura.  Mis amigos me dec√≠an constantemente que deber√≠a hablar sobre mi proyecto y no hacer todo exclusivamente "por m√≠ mismo", as√≠ que aqu√≠ estoy publicando esta publicaci√≥n. </p><a name="habracut"></a><br><p>  <strong>Atenci√≥n, esta es una traducci√≥n.</strong> </p><br><h1 id="kak-vsyo-nachalos">  Como empez√≥ todo </h1><br><p>  Mi nombre es Sergio Vieira, crec√≠ en Portugal en los a√±os 80 y 90, tengo una larga nostalgia por los juegos retro, especialmente para las consolas de tercera y cuarta generaci√≥n. </p><br><p>  Hace unos a√±os, decid√≠ entender mejor la electr√≥nica e intentar hacer mi propio prefijo. </p><br><p>  De profesi√≥n, soy programador y no ten√≠a ninguna experiencia como ingeniero electr√≥nico, excepto por (y no deber√≠a considerarse) actualizaciones independientes de mi destkop. </p><br><p>  Aunque no ten√≠a ninguna experiencia, me dije "¬øpor qu√© no?", Compr√© varios libros, varios kits electr√≥nicos y comenc√© a estudiar en base a mis sentimientos sobre lo que val√≠a la pena estudiar. </p><br><p>  Quer√≠a hacer un prefijo similar a los que me ponen nost√°lgico, quer√≠a algo entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NES</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Super Nintendo</a> , o tal vez entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sega Master System</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mega Drive</a> . </p><br><p>  Estas consolas ten√≠an una CPU, un chip de video original (no se llamaban GPU en ese momento) y un chip de audio, a veces incorporado, y a veces externo. </p><br><p>  Los juegos se distribuyeron en cartuchos, que en general eran extensiones de hierro, a veces solo chips ROM, y a veces ten√≠an componentes adicionales. </p><br><p>  El plan original era hacer un prefijo con las siguientes caracter√≠sticas: </p><br><ul><li>  Sin emulaci√≥n, los juegos y programas deber√≠an funcionar en hardware real, no necesariamente el mismo de aquellos tiempos, pero lo suficientemente r√°pido para la tarea, y nada m√°s. </li><li>  Con una verdadera CPU retro. </li><li>  Con salida de TV anal√≥gica. </li><li>  Con sonido </li><li>  Con soporte de controlador dual </li><li>  Desplazamiento de becks y sprites de animaci√≥n. </li><li>  Con caracter√≠sticas para soportar juegos de plataformas como Mario y, por supuesto, todo tipo de otros juegos. </li><li>  Con la descarga de juegos y programas desde tarjetas SD. </li></ul><br><p>  Por qu√© las tarjetas SD, y no los cartuchos, bueno, b√°sicamente es mucho m√°s pr√°ctico, puedes copiarlas desde tu computadora.  Y los cartuchos significar√≠an, en primer lugar, m√°s hierro en el decodificador y, en segundo lugar, producir hierro para cada programa. </p><br><h1 id="proizvodstvo">  Producci√≥n </h1><br><h2 id="video-signal">  Se√±al de video </h2><br><p>  Lo primero que hice fue generar una se√±al de video. </p><br><p>  Cualquier consola del per√≠odo que tom√© como muestra ten√≠a varios chips gr√°ficos propietarios, lo que significa que todos ten√≠an especificaciones diferentes. <br>  Por esta raz√≥n, no quer√≠a usar un chip gr√°fico ya preparado, quer√≠a que mi consola tuviera especificaciones gr√°ficas √∫nicas.  Y como no pod√≠a hacer mi propio chip gr√°fico, y en ese momento todav√≠a no pod√≠a usar FPGA, decid√≠ limitarme a la generaci√≥n de una se√±al gr√°fica generada por software utilizando un microcontrolador de 8 bits y 20 megahercios. </p><br><p>  Esto no es demasiado, y solo es una soluci√≥n lo suficientemente poderosa para los gr√°ficos del nivel que me interesaba. </p><br><p>  Y as√≠, comenc√© a usar el microcontrolador Atmega644 a una pureza de 20 MHz para generar una se√±al de video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PAL</a> para el televisor.  Tuve que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superar</a> el protocolo PAL porque el chip en s√≠ no sabe c√≥mo hacerlo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="Prueba 1 de imageVPU"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="Prueba 2 de imageVPU"></p><br><p>  El microcontrolador produce un color de 8 bits (RGB332, 3 bits rojo, 3 bits verde y 2 azul) y el DAC pasivo lo convierte todo en RGB.  Afortunadamente en Portugal, casi todos los televisores est√°n equipados con un conector SCART y admiten entrada RGB. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  El subsistema gr√°fico correcto </h2><br><p>  Como el microcontrolador es bastante potente y decid√≠ usarlo exclusivamente para generar una se√±al de video (lo llam√© VPU - Unidad de procesamiento de video), decid√≠ organizar un doble buffer al mismo tiempo. </p><br><p>  Result√≥ que el segundo microcontrolador (PPU, unidad de procesamiento de imagen, chip Atmega1284 tambi√©n a 20 MHz) gener√≥ una imagen en el chip RAM 1 (lo llam√© VRAM1), y el primero envi√≥ el contenido del segundo chip (VRAM2) al televisor al mismo tiempo. </p><br><p>  Despu√©s de un cuadro, y dos cuadros en el sistema PAL son 1/25 de segundo, la VPU cambia las VRAM y se intercambian, la PPU genera una imagen en VRAM2, y la VPU descarga VRAM1 a la salida de TV. </p><br><p>  La tarjeta de video result√≥ ser muy complicada porque tuve que usar hardware externo para que ambos microcontroladores pudieran usar ambos m√≥dulos de memoria y acelerar el acceso a la RAM, ya que tambi√©n tiene golpes de bits, as√≠ que tuve que agregar 74 chips de la serie como contadores, selectores de l√≠nea, transceptores, etc. . </p><br><p>  El firmware para VPU y PPU tambi√©n result√≥ ser engorroso porque tuve que escribir mucho c√≥digo para obtener la m√°xima velocidad de los gr√°ficos.  Al principio todo fue escrito en ensamblador, luego parte fue reescrita en C. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  Como resultado, la PPU genera una imagen de 224x192 p√≠xeles, que luego se env√≠a al televisor a trav√©s de la VPU.  Puede encontrar baja la resoluci√≥n, pero en realidad es casi tanto como las consolas de la √©poca, generalmente 256x224.  Una resoluci√≥n ligeramente inferior, pero me permiti√≥ agregar m√°s funciones que el sistema logra calcular en un cuadro. </p><br><p>  Como en los viejos tiempos, PPU tiene su propia mec√°nica r√≠gida que debe poder usar.  El respaldo (respaldo) se representa a partir de caracteres de 8x8 p√≠xeles, tambi√©n llamados mosaicos.  Resulta que el tama√±o del fondo es de 28x24 mosaicos. </p><br><p>  Para que el respaldo se pueda desplazar suavemente, p√≠xel por p√≠xel, lo hice, hay 4 pantallas virtuales, cada una de 28x24 mosaicos que se almacenan secuencialmente en memoria y se envuelven entre s√≠, en la imagen es m√°s clara. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imagen de fondo"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imagen fondo virtual"></p><br><p>  En la parte superior del fondo, PPU puede representar 64 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sprites</a> que pueden tener 8 o 16 p√≠xeles de alto o ancho, es decir, 1, 2 o 4 mosaicos y tambi√©n se pueden voltear horizontal y / o verticalmente. </p><br><p>  En la parte superior de la parte posterior, tambi√©n puede renderizar una superposici√≥n con un tama√±o de mosaico de 28x6 b√∫fer, esto estaba destinado a renderizar HUD, puntajes para no interferir con los sprites principales y el desplazamiento de la parte posterior. </p><br><p>  Una caracter√≠stica "avanzada" es que el respaldo puede desplazarse no completamente, sino cada l√≠nea por separado, lo que permite todo tipo de efectos interesantes como pantallas divididas o casi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralaje</a> . </p><br><p>  Tambi√©n hay una tabla de atributos que le permite establecer cada mosaico en un valor de 0 a 3, y luego puede especificar una p√°gina de mosaicos para todos los mosaicos con un atributo o incrementar su valor simb√≥lico.  Esto es conveniente cuando hay partes de la copia de seguridad que deben cambiarse regularmente y la CPU no tiene que calcular cada mosaico individualmente, es suficiente decir algo como: "todos los mosaicos con el atributo 1, incrementa el valor num√©rico de tu personaje en 2", tales cosas pueden implementarse mediante diferentes t√©cnicas Observe, por ejemplo, en bloques de bloques en Mario donde el signo de interrogaci√≥n est√° animado o en juegos donde hay una cascada en la que todos los cuadros cambian constantemente creando el efecto de la ca√≠da del agua. </p><br><h2 id="cpu">  CPU </h2><br><p>  Cuando mi tarjeta de video funcion√≥, comenc√© a trabajar con la CPU como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zilog 80</a> para mi decodificador. </p><br><p>  Una de las razones por las que se eligi√≥ el Z80, bueno, adem√°s del hecho de que es una CPU retro genial, es su capacidad para abordar dos espacios de 16 bits, uno para memoria y el segundo para puertos de E / S, no menos legendario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6502</a> , por ejemplo, no puede , solo puede direccionar un espacio de 16 bits, y debe asignarlo a la memoria, as√≠ como a varios dispositivos externos, video, audio, joysticks, generador de n√∫meros aleatorios de hardware, etc.  Es m√°s conveniente tener dos espacios de direcciones, uno con hasta 64 kilobytes de c√≥digo y datos en la memoria y el segundo para acceder a dispositivos externos. </p><br><p>  Primero, conect√© la CPU a la EEPROM en la que se encontraba mi programa de prueba y tambi√©n lo conect√© a trav√©s del espacio de E / S al microcontrolador que instal√© para poder comunicarme con mi computadora a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RS232</a> y monitorear c√≥mo funcionaba la CPU y todo lo dem√°s.  Este microcontrolador Atmega324 que funciona a 20 MHz lo llamo IO MCU - unidad de microcontrolador de entrada / salida, es responsable de controlar el acceso a los controladores de juego (joysticks), lector de tarjetas SD, teclado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PS / 2</a> y comunicador a trav√©s de RS232. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="Junta 1 de imageCPU"></p><br><p>  La CPU se conecta a un chip de memoria de 128 kilobytes, de los cuales solo 56 kilobytes est√°n disponibles, esto por supuesto no tiene sentido, pero podr√≠a obtener solo chips de 128 o 32 kilobytes.  Result√≥ que la memoria consta de 8 kilobytes de ROM y 56 kilobytes de RAM. </p><br><p>  Despu√©s de eso, actualic√© el firmware de IO MCU usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta biblioteca</a> y obtuve soporte para lectores de tarjetas SD. </p><br><p>  Ahora la CPU podr√≠a revisar los directorios, ver qu√© hay en ellos, abrir y leer archivos.  Todo esto se hace escribiendo y leyendo direcciones espec√≠ficas en el espacio de E / S. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  Conecte la CPU a la PPU </h2><br><p>  Lo siguiente que he hecho es la conexi√≥n entre la CPU y la PPU.  Para hacer esto, apliqu√© una "soluci√≥n simple" que era comprar RAM de doble puerto, este es un chip RAM que se puede conectar directamente a dos buses diferentes.  Esto le permite deshacerse de chips adicionales como selectores de l√≠nea y, adem√°s, permite un acceso casi simult√°neo a la memoria desde ambos chips.  Otra PPU puede acceder directamente a la CPU en cada cuadro activando sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interrupciones no enmascarables</a> .  Resulta que la CPU recibe una interrupci√≥n en cada cuadro, lo cual es √∫til para varias tareas de temporizaci√≥n y para comprender cu√°ndo es el momento de hacer una actualizaci√≥n de gr√°ficos. </p><br><p>  Cada cuadro de interacci√≥n de la CPU, PPU y VPU se produce de acuerdo con el siguiente esquema: </p><br><ol><li>  La PPU copia informaci√≥n de la memoria PPU a la memoria interna. </li><li>  La PPU env√≠a una se√±al de interrupci√≥n a la CPU. </li><li>  Al mismo tiempo: <br><ul><li>  La CPU salta a la funci√≥n de interrupci√≥n y comienza a actualizar la memoria PPU con un nuevo estado de gr√°ficos.  El programa debe regresar desde la interrupci√≥n hasta el siguiente bloque. </li><li>  PPU renderiza una imagen basada en informaci√≥n previamente copiada a una de VRAM. </li><li>  VPU env√≠a una imagen desde otra VRAM a la salida de TV. </li></ul></li></ol><br><p>  Casi al mismo tiempo, comenc√© a admitir controladores de juegos, al principio quer√≠a usar los controladores de Nintendo, pero sus enchufes son propietarios y generalmente dif√≠ciles de encontrar, as√≠ que me decid√≠ por controladores de 6 botones compatibles con Mega Drive / Genesis, tienen enchufes DB-9 est√°ndar. que est√°n en todas partes </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  Escribiendo el primer juego real </h2><br><p>  En este momento, ya ten√≠a una CPU capaz de controlar PPU, trabajar con joysticks, leer tarjetas SD ... era hora de <a href="">escribir el primer juego</a> , por supuesto en el ensamblador Z80, me tom√≥ varios d√≠as de tiempo libre. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  Agregar gr√°ficos din√°micos </h2><br><p>  Todo estaba s√∫per, ten√≠a mi propia consola de juegos, pero esto no era suficiente para m√≠, porque en el juego ten√≠a que usar gr√°ficos cosidos en la memoria PPU y era imposible dibujar mosaicos para un juego espec√≠fico y solo se pod√≠a cambiar al actualizar la ROM.  Comenc√© a pensar en c√≥mo agregar m√°s memoria para que la CPU pudiera cargar caracteres para los mosaicos, y luego la PPU podr√≠a leerlo todo desde all√≠ y c√≥mo hacerlo m√°s f√°cil porque el prefijo ya era complicado y grande. </p><br><p>  Y se me ocurri√≥ lo siguiente: solo la PPU tendr√° acceso a esta nueva memoria, y la CPU cargar√° datos all√≠ a trav√©s de la PPU y, mientras este proceso de carga est√° en progreso, esta memoria no se puede usar para dibujar, pero ser√° posible extraerla de la ROM en este momento. </p><br><p>  Despu√©s del final de la carga, la CPU cambiar√° la memoria ROM interna a esta nueva memoria, a la que llam√© Character RAM (CHR-RAM) y, en este modo, la PPU comenzar√° a dibujar gr√°ficos din√°micos, esta probablemente no sea la mejor soluci√≥n, pero funciona.  Como resultado, se instal√≥ una nueva memoria de 128 kilobytes y puede almacenar 1024 caracteres de 8x8 p√≠xeles cada uno para el fondo y la misma cantidad de caracteres para los sprites. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  Y finalmente el sonido </h2><br><p>  Las manos alcanzaron el √∫ltimo sonido.  Al principio, quer√≠a un sonido como el de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uzebox</a> , es decir, que el microcontrolador genera 4 canales de sonido PWM. </p><br><p>  Sin embargo, result√≥ que puedo obtener f√°cilmente los chips antiguos y ped√≠ varios chips de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">s√≠ntesis FM</a> YM3438, estos tipos son totalmente compatibles con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YM2612</a> utilizado en Mega Drive / Genesis.  Al instalarlos, puede obtener m√∫sica Mega Drive de calidad y efectos de sonido producidos por el microcontrolador. </p><br><p>  Instal√© otro microcontrolador y lo llam√© SPU (Unidad de procesador de sonido), controla el YM3438 y puedo generar sonidos yo mismo.  La CPU lo controla a trav√©s de una memoria de doble puerto, esta vez solo pesa 2 kilobytes. </p><br><p>  Al igual que en la unidad gr√°fica, la unidad de sonido tiene 128 kilobytes de memoria para almacenar muestras de PCM y parches de sonido, la CPU carga datos en esta memoria accediendo a la SPU.  Result√≥ que la CPU le dice a la SPU que ejecute comandos desde esta memoria o actualiza los comandos para la SPU en cada cuadro. </p><br><p>  La CPU controla cuatro canales PWM a trav√©s de cuatro memorias intermedias circulares en la memoria de la SPU.  La SPU pasa por estos b√∫feres y ejecuta los comandos escritos en ellos.  Tambi√©n hay un b√∫fer para el chip de s√≠ntesis FM. </p><br><p>  En total, como en el gr√°fico, la interacci√≥n entre la CPU y la SPU va de acuerdo con el esquema: </p><br><ol><li>  La SPU copia datos de la SPU a la memoria interna. </li><li>  SPU est√° esperando una interrupci√≥n de PPU (esto es para sincronizaci√≥n) </li><li>  Al mismo tiempo <br><ul><li>  La CPU actualiza los b√∫feres de canal PWM y los b√∫feres de sintetizador FM. </li><li>  La SPU ejecuta comandos en memorias intermedias seg√∫n los datos en la memoria interna. </li><li>  Junto con todo esto, la SPU actualiza los sonidos PWM a una frecuencia de 16 kilohercios. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  Lo que sali√≥ al final </h1><br><p>  Despu√©s de que todos los bloques estuvieron listos, algunos fueron al tablero. <br>  Para el bloque de CPU, pude desarrollar y ordenar una PCB personalizada, no s√© si vale la pena para los otros m√≥dulos, creo que tuve mucha suerte de que mi PCB funcionara de inmediato. </p><br><p>  En el tablero ahora (hasta ahora) solo hay sonido. <br>  As√≠ es como se ve hoy: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  Arquitectura </h2><br><p>  El diagrama ilustra los componentes en cada bloque y c√≥mo interact√∫an entre s√≠.  Lo √∫nico que no se muestra es la se√±al de la PPU a la CPU en cada cuadro como una interrupci√≥n y la misma se√±al que va a la SPU. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="imageArquitectura"></p><br><ul><li>  CPU: Zilog Z80 a 10 MHz </li><li>  CPU-ROM: EEPROM de 8 KB, contiene el c√≥digo del gestor de arranque </li><li>  CPU-RAM: 128 KB de RAM (56 KB disponibles), c√≥digo y datos para programas / juegos </li><li>  IO MCU: Atmega324, es la interfaz entre la CPU y RS232, el teclado PS / 2, joysticks y el sistema de archivos de la tarjeta SD </li><li>  PPU-RAM: 4 kilobytes de memoria de doble puerto, memoria intermedia entre CPU y PPU </li><li>  CHR-RAM: 128 KB de RAM, almacena mosaicos din√°micos para respaldo (sustrato) y sprites (en caracteres de 8x8 p√≠xeles). </li><li>  VRAM1, VRAM2: 128 KB de RAM (43008 est√° realmente disponible), se usan para el framebuffer, escriben PPU y leen VPU de ellos. </li><li>  PPU (Unidad de procesamiento de im√°genes): Atmega1284, dibuja un marco en el framebuffer. </li><li>  VPU (Unidad de procesamiento de video): Atmega324, lee el framebuffer y genera se√±ales RGB y PAL y sincronizaci√≥n. </li><li>  SPU-RAM: RAM de doble puerto de 2 KB, sirve como interfaz entre la CPU y la SPU. </li><li>  SNDRAM: 128 KB de RAM, almacena parches PWM, muestras PCM y bloques de instrucciones para el sintetizador FM. </li><li>  YM3438: YM3438, chip de s√≠ntesis FM. </li><li>  SPU (Unidad de procesamiento de sonido): Atmega644, genera sonidos utilizando el principio de modulaci√≥n de ancho de pulso (PWM) y controla el YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Especificaciones finales </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  CPU Zilog Z80 de 8 bits a una frecuencia de 10Mhz. </li><li>  ROM de 8 KB para el gestor de arranque. </li><li>  56 KB de RAM. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Lectura de datos del lector de tarjetas SD FAT16 / FAT32. </li><li>  Leer / escribir en el puerto RS232. </li><li>  2 controladores de juegos compatibles con MegaDrive / Genesis. </li><li>  Teclado PS2. </li></ul><br><p>  <strong>Video:</strong> </p><br><ul><li>  Resoluci√≥n 224x192 p√≠xeles. </li><li>  25 cuadros por segundo (medio FPS de PAL). </li><li>  256 colores (RGB332). </li><li>  Fondo virtual 2x2 (448x384 p√≠xeles), con desplazamiento bidireccional basado en p√≠xeles, basado en cuatro p√°ginas de pantalla completa. </li><li>  64 sprites con un ancho y una altura de 8 o 16 p√≠xeles con la posibilidad de voltear tanto vertical como horizontalmente. </li><li>  El fondo y los sprites consisten en caracteres de 8x8 p√≠xeles cada uno. </li><li>  Memoria simb√≥lica de video de 1024 caracteres para el fondo y 1024 para sprites. </li><li>  64 desplazamiento horizontal independiente a lo largo de las l√≠neas establecidas </li><li>  8 desplazamientos verticales independientes a lo largo de las l√≠neas establecidas </li><li>  Superposici√≥n de 224x48 p√≠xeles con transparencia de clave de color opcional. </li><li>  Tabla de atributos de fondo. </li><li>  RGB y PAL compuesto a trav√©s del conector SCART. </li></ul><br><p>  <strong>Sonido:</strong> </p><br><ul><li>  PWM para 8 bits y 4 canales, con formas de onda integradas: cuadrada, senoidal, sierra, ruido, etc. </li><li>  Muestras de 8 bits y 8 kHz en uno de los canales PWM. </li><li>  Chip de s√≠ntesis FM YM3438 cargado con instrucciones a una frecuencia de 50 hertzios. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  Desarrollo para la consola. </h1><br><p>  Para la consola, se escribi√≥ un gestor de arranque.  El cargador de arranque se coloca en la CPU ROM y puede tomar hasta 8 kilobytes.  Utiliza los primeros 256 bytes de RAM.  El cargador es lo primero que ejecuta la CPU.  Es necesario para mostrar los programas ubicados en la tarjeta SD. </p><br><p>  Estos programas est√°n en archivos que contienen c√≥digo compilado y tambi√©n pueden contener gr√°ficos y sonido. </p><br><p>  Despu√©s de seleccionar un programa, se carga en la memoria de la CPU, la memoria CHR y la memoria SPU.  Despu√©s de lo cual se ejecuta el c√≥digo del programa.  El tama√±o m√°ximo del c√≥digo cargado en la consola es de 56 kilobytes, adem√°s de los primeros 256 bytes, y, por supuesto, debe tener en cuenta el espacio para la pila y los datos. <br>  Y este gestor de arranque y otros programas escritos para esta consola se crearon de la misma manera que se describe a continuaci√≥n. </p><br><h2 id="memoryio-mapping">  Mapeo de memoria / IO </h2><br><p>  Lo importante al desarrollar este prefijo es tener en cuenta c√≥mo la CPU accede a los diversos bloques y asignar correctamente el espacio de direcciones para la entrada de entrada y el espacio de direcciones de memoria. </p><br><p>  La CPU accede a la memoria de acceso aleatorio del cargador de arranque a trav√©s del espacio de direcciones de la memoria. </p><br><p>  Espacio de direcciones de memoria <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="Asignaci√≥n de im√°genes"></p><br><p>  Y a PPU-RAM, SPU-RAM e IO MCU a trav√©s del espacio de direcciones de E / S. </p><br><p>  Espacio de direcci√≥n de E / S <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="mapeo de imageIO"></p><br><p>  Como puede ver en la tabla, las direcciones para todos los dispositivos, IO MCU, PPU y SPU se asignan dentro del espacio de direcciones de E / S. </p><br><h2 id="upravlenie-ppu">  Gesti√≥n de PPU </h2><br><p>  De la informaci√≥n en la tabla se puede ver que para el control de PPU es necesario escribir en la memoria de PPU que est√° disponible en las direcciones 1000h-1FFFh en el espacio de direcciones de E / S. </p><br><p>  Asignaci√≥n de espacio de direcciones PPU </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="Asignaci√≥n de imagePPU"></p><br><p>  El estado de PPU puede tomar los siguientes valores: </p><br><ol><li>  Modo de gr√°ficos integrados </li><li>  Modo de gr√°ficos din√°micos (CHR-RAM) </li><li>  Modo de grabaci√≥n en memoria CHR </li><li>  La grabaci√≥n se completa, esperando la confirmaci√≥n del modo de la CPU </li></ol><br><p>  Aqu√≠, por ejemplo, c√≥mo puedes trabajar con sprites: <br>  El prefijo puede dibujar 64 sprites a la vez.      CPU    -   1004h-1143h (320 ),     5   (5 * 64 = 320): </p><br><ol><li>   ,     : Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  ,     (  ). </li><li>    (    ‚Äî ) </li><li>   X </li><li>   Y </li></ol><br><p> ,   ,    Active  1,    X  Y   ,  32/32       ,        . </p><br><p>         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por ejemplo, si necesitamos mostrar el n√∫mero de sprite 10, entonces la direcci√≥n ser√° 4145 (1004h + (5 x 9)), escriba el valor 1 para la activaci√≥n y las coordenadas, por ejemplo, x = 100 e y = 120, escriba el valor 100 en la direcci√≥n 4148 y direcci√≥n 4149 valor 120. </font></font></p><br><h2 id="ispolzuem-assembler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando ensamblador </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uno de los m√©todos de programaci√≥n para la consola es el ensamblador. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ hay un ejemplo de c√≥mo mostrar un sprite y animarlo para que se mueva y empuje los bordes de la pantalla. </font></font></p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>Usando lenguaje C</em></strong> </p><br><p>  Tambi√©n puede usar el lenguaje C, para esto necesitamos el compilador SDCC y algunas utilidades adicionales. </p><br><p>  El c√≥digo C puede ser m√°s lento, pero escribirlo es m√°s r√°pido y f√°cil. </p><br><p>  Aqu√≠ hay un ejemplo de c√≥digo que hace lo mismo que el c√≥digo de ensamblador anterior, usa una biblioteca que ayuda a realizar llamadas a PPU: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Gr√°ficos din√°micos </h2><br><p>  (En los gr√°ficos personalizados originales. Aprox. Por.) </p><br><p>  En la ROM del prefijo, se cosen 1 p√°gina de mosaicos para respaldo y otra p√°gina de sprites listos para usar), por defecto solo puede usar estos gr√°ficos fijos, pero puede cambiar a din√°mico. </p><br><p>  Mi objetivo era tal que todos los gr√°ficos necesarios en forma binaria se cargaron inmediatamente en la RAM de CHR, y el c√≥digo en el gestor de arranque desde la ROM puede hacer esto.  Para hacer esto, hice varias im√°genes del tama√±o correcto con diferentes s√≠mbolos √∫tiles: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="imagen de componentes de mosaico"></p><br><p>  Como la memoria de gr√°ficos din√°micos consta de 4 p√°ginas con 256 caracteres de 8x8 p√≠xeles cada una y 4 p√°ginas de los mismos caracteres para sprites, convert√≠ las im√°genes a formato PNG, borr√© las duplicadas: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="imagen de hoja de caracteres"></p><br><p>  Y luego us√≥ una herramienta auto escrita para traducirlo todo al formato binario RGB332 con bloques de 8x8. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="l√≠nea de comando imageGraphics"></p><br><p>  Como resultado, tenemos archivos con caracteres, donde todos los caracteres van secuencialmente uno tras otro y cada uno ocupa 64 bytes. </p><br><h2 id="zvuk">  Sonido </h2><br><p>  Muestras RAW de onda convertidas en muestras PCM de 8 bits y 8 kilohercios. </p><br><p>  Los parches para efectos de sonido en PWM y m√∫sica se escriben con instrucciones especiales. </p><br><p>  En cuanto al chip de s√≠ntesis Yamaha YM3438 FM, encontr√© un programa llamado DefleMask que produce m√∫sica sincronizada PAL para el chip Genesis YM2612, que es compatible con el YM3438. </p><br><p>  DefleMask exporta m√∫sica en formato VGM y la convierto con otra utilidad patentada en mi propio formato binario. </p><br><p>  Todos los archivos binarios de los tres tipos de sonido se combinan en un archivo binario, que mi gestor de arranque puede leer y cargar en la memoria de sonido RAM SDN. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="imagen de l√≠nea de comando"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Enlace al archivo final </h2><br><p>  El c√≥digo ejecutable binario, los gr√°ficos y el sonido se combinan en un solo archivo PRG.  El archivo PRG tiene un encabezado en el que se describe todo si hay datos de audio y gr√°ficos, cu√°nto ocupan y los datos en s√≠. </p><br><p>  Dicho archivo puede escribirse en una tarjeta SD, y el gestor de arranque de la consola lo considera y descarga todo en los lugares apropiados y lanza el c√≥digo ejecutable del programa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="l√≠nea de comando imagePRG"></p><br><h2 id="emulyator">  Emulador </h2><br><p>  Escrib√≠ un emulador de mi consola en C ++ usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wxWidgets</a> para que sea m√°s f√°cil desarrollarlo. </p><br><p>  La CPU es emulada por la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libz80</a> . </p><br><p>  Se han agregado caracter√≠sticas al emulador para la depuraci√≥n, puedo detenerlo en cualquier momento y hacer una depuraci√≥n paso a paso del ensamblador, hay una asignaci√≥n al c√≥digo fuente en C. si este lenguaje se us√≥ para el juego. </p><br><p>  Seg√∫n el gr√°fico, puedo mirar en la memoria de video, en las tablas de s√≠mbolos y en la memoria CHR misma. </p><br><p>  Aqu√≠ hay un ejemplo de un programa que se ejecuta en un emulador con las herramientas de depuraci√≥n activadas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="Demostraci√≥n de imagenEmulator"></p><br><h1 id="demka-programmirovaniya">  Demo de programaci√≥n </h1><br><p>  Estos videos fueron grabados con la c√°mara de un tel√©fono inteligente dirigida a la pantalla CRT del televisor, pido disculpas por la calidad de imagen imperfecta. </p><br><p>  El int√©rprete BASIC programable desde el teclado PS / 2, despu√©s del primer programa, muestro c√≥mo escribir directamente en la memoria PPU a trav√©s del espacio de direcciones de E / S activando y moviendo el sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Una demostraci√≥n de gr√°ficos, en este video, descarga program√°ticamente 64 sprites de 16x16, en el contexto de un fondo con desplazamiento din√°mico y una superposici√≥n que se mueve por debajo y por encima de los sprites: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La demostraci√≥n de sonido muestra las capacidades del sonido YM3438 y PWM, los datos de sonido de esta demostraci√≥n y la m√∫sica FM y los sonidos PWM juntos ocupan casi todos los 128 kilobytes de memoria de sonido disponibles. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, casi exclusivamente las caracter√≠sticas de fondo, la m√∫sica en el YM3438, los efectos de sonido en los parches PWM se utilizaron para los gr√°ficos. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  Este proyecto es realmente un sue√±o hecho realidad, he estado trabajando en √©l durante varios a√±os, con interrupciones, mirando mi tiempo libre, nunca pens√© que llegar√≠a tan lejos en la creaci√≥n de mi propia consola de videojuegos retro.  Naturalmente, no es perfecto, ciertamente no soy un experto en electr√≥nica, obviamente hab√≠a demasiados elementos en el decodificador, y sin duda podr√≠a hacerse mejor, y probablemente uno de los lectores solo est√° pensando en ello. </p><br><p>  Pero a√∫n as√≠, en el proceso de trabajar en este proyecto, aprend√≠ mucho sobre electr√≥nica, consolas de juegos y dise√±o de computadoras, lenguaje ensamblador y otras cosas interesantes, y lo m√°s importante, recib√≠ una gran satisfacci√≥n al jugar juegos que yo mismo escrib√≠ en hardware que yo mismo desarroll√©. y recogido. </p><br><p>  Tengo planes de hacer consolas / computadoras y m√°s.  En realidad, ya estoy haciendo un nuevo decodificador, est√° casi listo, y es un decodificador retro simplificado basado en una placa FPGA y varios componentes adicionales (en una cantidad mucho menor que en este proyecto, sin duda), la idea es ser mucho m√°s barata y m√°s repetible. </p><br><p>  Aunque escrib√≠ mucho sobre este proyecto aqu√≠, sin duda se puede discutir mucho m√°s, apenas mencion√© c√≥mo funciona el motor de sonido, c√≥mo interact√∫a la CPU con √©l y hay mucho m√°s que se puede hacer sobre el sistema gr√°fico y otras entradas / salidas y toda la consola Ser√≠a para contarlo. </p><br><p>  Mirando la reacci√≥n de los lectores, puedo escribir m√°s art√≠culos centrados en actualizaciones, detalles sobre bloques de prefijos individuales u otros proyectos. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Proyectos, sitios, canales de Youtube que me inspiraron y me ayudaron con conocimientos t√©cnicos: </h2><br><p>  Estos sitios / canales no solo me inspiraron, sino que tambi√©n me ayudaron a encontrar soluciones a problemas complejos que surgieron durante el trabajo en este proyecto. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uzebox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ben ryves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Retroleum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Z80.info</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EEVBlog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mec√°nica de juego retro</a> </li></ul><br><p>  Gracias por leer hasta aqu√≠.  :) </p><br><p>  Si tiene preguntas o comentarios, escriba los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentarios a continuaci√≥n</a> (Art√≠culo original en ingl√©s en Github. Aprox. Per.) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444006/">https://habr.com/ru/post/444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443996/index.html">Anuncio de TypeScript 3.4 RC</a></li>
<li><a href="../443998/index.html">Nuevo r√©cord mundial para calcular el n√∫mero de pi: 31,4 billones de caracteres</a></li>
<li><a href="../444000/index.html">Por d√≥nde empezar cuando se contrata personal por primera vez</a></li>
<li><a href="../444002/index.html">El primer asistente de voz "neutral en g√©nero" del mundo presentado en el SXSW IT Festival</a></li>
<li><a href="../444004/index.html">CLRium # 5: All-All-All sobre GC y m√°s. Peter y Mosc√∫</a></li>
<li><a href="../444010/index.html">.NET Core Container Images ahora publicadas en Microsoft Container Registry</a></li>
<li><a href="../444014/index.html">Microsoft abre Business School para aprender estrategias, cultura y responsabilidad de IA</a></li>
<li><a href="../444016/index.html">Logre m√°s con Microsoft Game Stack</a></li>
<li><a href="../444018/index.html">C√≥mo un cambio de configuraci√≥n de PostgreSQL mejora el rendimiento de la consulta lenta 50 veces</a></li>
<li><a href="../444020/index.html">Karting en la URSS: c√≥mo el hobby de los pilotos estadounidenses se convirti√≥ en un hobby masivo de bricolaje en la Uni√≥n Sovi√©tica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>