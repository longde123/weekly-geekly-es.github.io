<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤– ğŸ˜½ â›©ï¸ Memecahkan Crackme sederhana untuk Sega Mega Drive ğŸš· ğŸ§“ğŸ» ğŸš£ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya 





 Terlepas dari pengalaman hebat saya dalam membalikkan game untuk Sega Mega Drive , saya tidak pernah memutuskan untuk melakukanny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecahkan Crackme sederhana untuk Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Halo semuanya </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Terlepas dari pengalaman hebat saya dalam membalikkan game untuk <code>Sega Mega Drive</code> , saya tidak pernah memutuskan untuk melakukannya, dan mereka tidak menemukan saya di Internet.  Tapi, tempo hari ada crackie lucu yang ingin menyelesaikan.  Saya berbagi dengan Anda keputusan ... <a name="habracut"></a></p><br><h2 id="opisanie">  Deskripsi </h2><br><p>  Deskripsi tugas dan rum itu sendiri dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">diunduh di sini</a> . </p><br><p>  Terlepas dari kenyataan bahwa daftar sumber daya mengatakan Hydra, standar de facto di antara alat untuk debugging dan membalikkan game di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sega</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Smd Ida Tools</a> .  Ia memiliki semua yang Anda butuhkan untuk menyelesaikan creme ini: </p><br><ul><li>  Pemuat rum untuk Ida </li><li>  Debugger </li><li>  Lihat dan ubah memori RAM / VDP </li><li>  Menampilkan informasi yang hampir lengkap tentang VDP </li></ul><br><p>  Kami melepaskan rilis terbaru ke dalam plugin untuk Ide dan mulai melihat apa yang kami miliki. </p><br><h2 id="reshenie">  Solusi </h2><br><p>  Peluncuran game Shogi apa pun dimulai dengan eksekusi vektor <code>Reset</code> .  Pointer ke sana dapat ditemukan di DWORD kedua dari awal rum. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Kami melihat beberapa fungsi tidak dikenal mulai dari alamat <code>0x27A</code> .  Mari kita lihat apa yang ada di sana. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  Dari pengalaman saya sendiri, saya akan mengatakan bahwa ini biasanya terlihat seperti fungsi menunggu interupsi <code>VBLANK</code> selesai.  Mari kita lihat di mana lagi ada panggilan ke variabel <code>byte_FF0026</code> : </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Kita melihat bahwa bit nol hanya diatur dalam interupsi <code>VBLANK</code> .  Jadi kita memanggil variabel <code>vblank_ready</code> , dan fungsi tempat itu diperiksa adalah <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Selanjutnya, fungsi <code>sub_60E</code> dipanggil oleh kode.  Mari kita lihat apa yang ada di sana: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  Apa yang ditulis perintah pertama ke <code>VDP_CTRL</code> adalah perintah kontrol <code>VDP</code> .  Untuk mengetahui apa yang dia lakukan, kita berdiri di perintah ini dan tekan tombol <code>J</code> : </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Kita melihat bahwa entri dalam <code>CRAM</code> (tempat penyimpanan palet) diinisialisasi.  Ini berarti bahwa semua kode fungsi selanjutnya cukup menetapkan semacam palet awal.  Dengan demikian, fungsi ini bisa disebut <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Kami melihat bahwa beberapa perintah lagi ditransfer ke <code>VDP_CTRL</code> , lalu tekan lagi <code>J</code> dan temukan bahwa perintah ini menginisialisasi rekaman dalam memori video: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Selanjutnya, untuk memahami apa yang ditransfer ke memori video, tidak masuk akal.  Karena itu, kita cukup memanggil fungsi <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Hal yang hampir sama terjadi di sini seperti pada fungsi sebelumnya, oleh karena itu, tanpa masuk ke detail, kita cukup memanggil fungsi <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  Sudah ada lebih banyak kode.  Dan selain itu, fungsi lain disebut dalam fungsi ini.  Mari kita lihat di sana - di <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Kita melihat bahwa dalam register <code>D0</code> perintah untuk <code>VDP_CTRL</code> , di <code>D1</code> - nilai yang akan diisi <code>VRAM</code> , dan di <code>D2</code> dan <code>D3</code> - lebar dan tinggi isi (karena ternyata dua siklus: internal dan eksternal).  Panggil fungsi fill_vram_by_addr. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Kami kembali ke fungsi sebelumnya.  Setelah nilai dalam register <code>D0</code> dikirimkan sebagai perintah untuk <code>VDP_CTRL</code> , tekan tombol <code>J</code> pada nilai.  Kami mendapatkan: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Sekali lagi, dari pengalaman membalikkan game ke Sega, saya dapat mengatakan bahwa perintah ini menginisialisasi rekaman ubin pemetaan.  Alamat yang dimulai dari <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> dalam 90% kasus akan menjadi alamat daerah dengan pemetaan yang sama.  Apa itu pemetaan: <br>  ini adalah nilai yang dapat Anda tentukan tempat menampilkan ubin ini atau itu di layar (ubin adalah kuadrat <code>8x8</code> piksel). </p><br><p>  Jadi fungsinya bisa disebut sebagai <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  Perintah pertama menginisialisasi catatan di alamat <code>$F000</code> .  Satu catatan: di antara alamat " <em>pemetaan</em> ", masih ada wilayah di mana tabel sprite disimpan (ini adalah posisi mereka, ubin yang mereka tuju, dll.) Cari tahu wilayah mana yang bertanggung jawab atas apa yang dapat di-debug.  Tetapi untuk saat ini, kami tidak membutuhkan ini, jadi mari kita panggil saja fungsi <code>init_other_mappings</code> . </p><br><p>  Juga, kita melihat bahwa dalam fungsi ini dua variabel diinisialisasi: <code>word_FF000A</code> dan <code>word_FF000C</code> .  Dari pengalaman saya sendiri (ya, ia memutuskan) Saya akan mengatakan bahwa jika ada dua variabel yang berdekatan di ruang alamat dan terkait dengan pemetaan, maka dalam banyak kasus mereka akan menjadi koordinat dari beberapa objek (misalnya, sprite).  Karenanya, saya sarankan memanggil mereka <code>sprite_pos_x</code> dan <code>sprite_pos_y</code> .  Kesalahan dalam <code>x</code> dan <code>y</code> diizinkan sejak itu  selanjutnya di bawah debugging akan mudah diperbaiki. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Karena loop berjalan lebih jauh dalam kode, kita dapat mengasumsikan bahwa kita telah menyelesaikan inisialisasi dasar.  Sekarang Anda dapat melihat interupsi <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  Kami melihat bahwa dua variabel bertambah (yang aneh, dalam daftar tautan ke masing-masing variabel itu benar-benar kosong).  Tapi, karena mereka diperbarui sekali per frame, Anda dapat memanggil mereka <code>timer1</code> dan <code>timer2</code> . </p><br><p>  Selanjutnya, fungsi <code>sub_2FE</code> .  Mari kita lihat apa yang ada di sana: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  Dan di sana - bekerja dengan port <code>IO_CT1_DATA</code> (bertanggung jawab atas joystick pertama).  Alamat port dimuat ke register <code>A0</code> , dan diteruskan ke fungsi <code>sub_310</code> .  Kami pergi ke sana: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Pengalaman saya membantu saya lagi.  Jika Anda melihat kode yang berfungsi dengan joystick, dan dua variabel dalam memori, maka satu menyimpan <code>pressed keys</code> , dan yang kedua menahan <code>held keys</code> , yaitu.  cukup tekan dan tahan tombol.  Jadi mari kita sebut variabel-variabel ini: <code>pressed_keys</code> dan <code>held_keys</code> .  Dan kemudian fungsinya bisa disebut sebagai <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Sebut fungsinya sebagai <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Lingkaran handler </h2><br><p>  Sekarang semuanya terlihat jauh lebih jelas: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Jadi siklus ini merespons tombol yang ditekan, dan melakukan tindakan yang sesuai.  Mari kita pergi melalui masing-masing fungsi yang disebut dalam loop. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  Ada banyak kode.  Mari kita mulai dengan fungsi pertama bernama: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Dia tidak melakukan apa-apa - mungkin kelihatannya begitu awalnya.  Baru saja kembali dari fungsi saat ini adalah <code>rts</code> .  Tetapi, karena  hanya melompat ( <code>bsr</code> ) yang terjadi di atasnya, yang berarti <code>rts</code> akan mengembalikan kita ke loop handler.  Saya akan memanggil fungsi ini sebagai <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Selanjutnya, kita melihat panggilan ke variabel <code>word_FF000E</code> .  Ini tidak digunakan di mana pun kecuali untuk fungsi saat ini dan, pada awalnya, tujuannya tidak jelas bagi saya.  Tetapi, jika Anda melihat lebih dekat, kita dapat mengasumsikan bahwa variabel ini hanya diperlukan untuk penundaan kecil antara pemrosesan penekanan tombol.  ( <em>Ini sudah diimplementasikan dengan buruk dalam rum ini, tapi, saya pikir, tanpa variabel ini akan jauh lebih buruk</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  Selanjutnya, kami memiliki sejumlah besar kode yang entah bagaimana memproses <code>sprite_pos_y</code> dan <code>sprite_pos_y</code> , yang hanya dapat mengatakan satu hal - ini diperlukan untuk menampilkan sprite pilihan di sekitar karakter yang dipilih dalam alfabet. </p><br><p>  Jadi sekarang Anda dapat dengan aman memberi nama fungsi sebagai <code>update_selection</code> .  Mari kita lanjutkan. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  Kode memeriksa apakah bit dari beberapa tombol yang ditekan diatur, dan memanggil fungsi-fungsi tertentu.  Mari lihat mereka. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Semacam sihir perdukunan.  Pertama, <code>WORD</code> diambil dari variabel <code>word_FF0018</code> , lalu satu instruksi menarik dijalankan: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Perintah ini hanya melompat ke instruksi yang mengikutinya. </p><br><p>  Berikutnya adalah keajaiban lain: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  Nilai dalam register <code>D0</code> ditempatkan di bagian atas tumpukan.  Perlu dicatat bahwa, untuk Shogi, dan juga untuk beberapa <code>x86</code> , alamat pengirim dari fungsi ketika dipanggil diletakkan di atas tumpukan.  Dengan demikian, instruksi pertama menempatkan beberapa alamat di atas, dan yang kedua mengangkatnya dari stack dan membuat transisi di sepanjang itu.  <u>Trik bagus</u> . </p><br><p>  Sekarang Anda perlu memahami apa nilai ini dalam variabel, yang kemudian melewati.  Tapi pertama-tama, sebut saja variabel ini <code>jmp_addr</code> . </p><br><p>  Dan fungsinya akan disebut ini: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Cari tahu di mana variabel ini diisi.  Kami melihat daftar referensi: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  Hanya ada satu tempat untuk menulis ke variabel ini.  Mari kita lihat dia. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Di sini, tergantung pada koordinat sprite (ingat bahwa ini kemungkinan besar alamat karakter yang dipilih), nilai ini atau itu dimasukkan.  Kita melihat bagian kode berikut: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  Nilai yang ada digeser ke kanan oleh 4 bit, nilai baru ditempatkan di byte rendah, dan hasilnya dimasukkan ke dalam variabel lagi.  Secara teori, variabel <code>jmp_addr</code> kami menyimpan karakter yang bisa kita masukkan pada layar input kunci.  Perhatikan juga bahwa ukuran variabel adalah <code>WORD</code> . </p><br><p>  Bahkan, fungsi <code>sub_3A4</code> bisa disebut <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Sekarang kita hanya memiliki satu fungsi tersisa di loop, yang tidak dikenali.  Dan itu disebut <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  <code>update_jmp_addr</code> menyerupai kode fungsi <code>update_jmp_addr</code> , hanya pada akhirnya kita memiliki <code>sub_45E</code> fungsi <code>sub_45E</code> .  Mari lihat di sana. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Kita melihat bahwa nomor <code>#$4B1E2003</code> dimasukkan dalam register <code>D0</code> , yang kemudian dikirim ke <code>VDP_CTRL</code> , yang berarti bahwa kita sedang berurusan dengan perintah kontrol <code>VDP</code> lain.  Kami menekan <code>J</code> , kami menerima perintah catatan di wilayah dengan pemetaan <code>$Cxxx</code> . </p><br><p>  Selanjutnya, kode berfungsi dengan variabel <code>byte_FF0014</code> , yang tidak digunakan di mana pun kecuali fungsi saat ini.  Jika Anda melihat dari dekat bagaimana menggunakannya, Anda akan melihat bahwa jumlah maksimum yang dapat diinstal di dalamnya adalah <code>4</code> .  Saya memiliki asumsi bahwa ini adalah panjang saat ini dari kunci yang dimasukkan.  Mari kita periksa. </p><br><h4 id="zapuskaem-otladchik">  Jalankan debugger </h4><br><p>  Saya akan menggunakan debugger dari <code>Smd Ida Tools</code> , tetapi, pada kenyataannya, beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gens KMod</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gens ReRecording</a> akan cukup.  Yang paling utama adalah ada fitur dengan tampilan alamat di memori. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Teori saya telah dikonfirmasi.  Jadi <code>byte_FF0014</code> variabel sekarang dapat <code>key_length</code> . </p><br><p>  Ada variabel lain: <code>dword_FF0010</code> , yang juga hanya digunakan dalam fungsi saat ini, dan isinya, setelah menambahkan perintah awal di <code>D0</code> (ingat, ini adalah nomor <code>#$4B1E2003</code> ), dikirim ke <code>VDP_CTRL</code> .  Tanpa berpikir <code>add_to_vdp_cmd</code> , saya menamai variabel <code>add_to_vdp_cmd</code> . </p><br><p>  Jadi, apa fungsi ini lakukan?  Saya memiliki asumsi bahwa dia menggambar karakter yang dimasukkan.  Memeriksa ini sederhana - dengan meluncurkan debugger dan membandingkan status sebelum memanggil fungsi <code>sub_45E</code> dan setelah: </p><br><p>  Kepada: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Setelah: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  Saya benar - fungsi ini menggambar karakter yang dimasukkan.  Kami menyebutnya <code>do_draw_input_char</code> , dan fungsi yang memanggilnya ( <code>sub_414</code> ) adalah <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Apa sekarang? </h2><br><p>  Mari kita periksa sekarang bahwa variabel yang kita sebut <code>jmp_addr</code> benar-benar menyimpan kunci yang dimasukkan.  Kami akan menggunakan <code>Memory Watch</code> sama: </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Seperti yang Anda lihat, dugaan itu benar.  Apa yang ini berikan pada kita?  Kita bisa lompat ke alamat apa saja.  Tapi yang mana?  Dalam daftar fungsi, semua sudah beres: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Lalu saya baru saja mulai menggulir kode sampai saya menemukan ini: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  Mata terlatih melihat urutan <code>$4E, $75</code> pada akhir byte yang tidak terisi.  Ini adalah opcode dari instruksi <code>rts</code> , mis.  kembali dari fungsi.  Jadi byte yang tidak terisi ini dapat menjadi kode dari beberapa fungsi.  Mari kita coba menunjuk mereka sebagai kode, tekan <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Jelas, ini adalah kode fungsi.  Anda juga dapat menekan <code>P</code> di atasnya untuk membuat kode berfungsi.  Ingat nama ini: <code>sub_D3C</code> . </p><br><p>  Kemudian muncul pemikiran: bagaimana jika Anda menggunakan <code>sub_D3C</code> ?  Kedengarannya bagus, meskipun satu lompatan di sini jelas tidak akan cukup, karena  tidak ada lagi tautan ke variabel <code>word_FF0020</code> . </p><br><p>  Lalu sebuah pemikiran muncul di benak saya: bagaimana jika kita mencari kode yang tidak terisi lainnya?  Buka dialog <code>Binary search</code> (Alt + B), masukkan urutan <code>4E 75</code> di dalamnya, centang kotak <code>Find all occurrences</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Klik <code></code> untuk memulai pencarian, kami mendapatkan hasil berikut. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Setidaknya dua tempat lagi di rum mungkin berisi kode fungsi, Anda perlu memeriksanya.  Kami klik pada opsi pertama, gulir sedikit ke atas, dan sekali lagi kami melihat urutan byte yang tidak ditentukan.  Tunjukkan sebagai fungsi?  Ya!  Tekan <code>P</code> mana byte dimulai: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Keren!  Sekarang kita memiliki fungsi <code>sub_34C</code> .  Kami mencoba mengulangi hal yang sama dengan yang terakhir dari opsi yang ditemukan, dan ... kami mendapatkan mengecewakan.  Ada begitu banyak byte sebelum <code>4E 75</code> sehingga tidak jelas di mana fungsi dimulai.  Dan, jelas, tidak semua byte di atas adalah kode, karena  banyak byte duplikat. </p><br><h3 id="opredelyaem-nachalo-funkcii">  Tentukan awal fungsi </h3><br><p>  Akan lebih mudah bagi kita untuk menemukan awal fungsi jika kita menemukan di mana data berakhir.  Bagaimana cara melakukannya?  Sebenarnya sama sekali tidak rumit: </p><br><ol><li>  Kami memutar sebelum data dimulai (akan ada tautan ke mereka dari kode) </li><li>  Kami mengikuti tautan dan mencari siklus di mana ukuran data ini akan muncul </li><li>  Tandai array </li></ol><br><p>  Jadi, kami melakukan paragraf pertama ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... dan kami segera melihat bahwa dalam siklus dari array kami, 4 byte data disalin sekaligus (karena <code>move.l</code> ) ke <code>VDP_DATA</code> .  Selanjutnya kita melihat nomor <code>2047</code> .  Pada awalnya, mungkin terlihat bahwa ukuran akhir dari array adalah <code>2047 * 4</code> , tetapi loop berbasis <code>dbf</code> mengeksekusi <code>+1</code> iterasi lebih banyak, karena  Nilai perbandingan terakhir bukan <code>0</code> , tetapi <code>-1</code> . </p><br><p>  Total: ukuran array adalah <code>2048 * 4 = 8192</code> .  Nyatakan byte sebagai array.  Untuk melakukan ini, klik <code>*</code> dan tentukan ukurannya: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Kami memutar ke ujung array, dan kami melihat ada byte, yang persis byte dari kode: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Sekarang kita memiliki fungsi <code>sub_2D86</code> , dan kita memiliki segalanya untuk menyelesaikan celah ini!  Mari kita lihat apa fungsi yang baru dibuat. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  Dan itu hanya menempatkan nilai <code>#$4147</code> dalam register <code>D1</code> dan memanggil fungsi <code>sub_34C</code> .  Lihatlah dia. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  Kita melihat bahwa di sini nilai variabel <code>word_FF0020</code> .  Jika Anda melihat <code>jmp_addr</code> , kita akan melihat tempat lain di mana catatan dalam variabel ini terjadi, dan ini akan menjadi tempat di mana saya ingin melompati variabel <code>jmp_addr</code> .  Ini mengkonfirmasi firasat bahwa <code>sub_D3C</code> harus melompat ke <code>sub_D3C</code> . </p><br><p>  Tetapi apa yang terjadi selanjutnya terlalu malas untuk saya mengerti, jadi saya melemparkan rum ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GHIDRA</a> , menemukan fungsi ini, dan melihat kode yang diuraikan: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Kita melihat bahwa variabel dengan nama aneh <code>in_D1w</code> , dan juga variabel <code>DAT_00ff0020</code> , yang dengan alamatnya menyerupai <code>word_FF0020</code> disebutkan di <code>word_FF0020</code> . </p><br><p>  <code>in_D1w</code> memberitahu kita bahwa nilai ini diambil dari register <code>D1</code> , atau lebih tepatnya dari setengah WORD yang lebih muda, dan set register <code>D1</code> fungsi yang melewatinya.  Ingat <code>#$4147</code> ?  Jadi, Anda perlu menunjuk register ini sebagai argumen input ke fungsi. </p><br><p>  Untuk melakukan ini, di jendela dengan kode yang didekompilasi, klik kanan pada nama fungsi, dan pilih item menu <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Untuk menunjukkan bahwa fungsi mengambil argumen melalui register tertentu, yaitu, bukan dengan metode standar untuk konvensi panggilan saat ini, Anda perlu memeriksa <code>Use Custom Storage</code> dan klik pada ikon dengan tanda <u>tambah hijau</u> : </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Posisi untuk argumen input baru muncul.  Kami klik dua kali padanya, dan kami mendapatkan dialog yang menunjukkan jenis dan media argumen: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  Dalam kode yang didekompilasi, kita melihat bahwa <code>in_D1w</code> adalah tipe <code>ushort</code> , yang berarti kita akan menentukannya di bidang tipe.  Kemudian klik tombol <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Sebuah posisi akan muncul untuk menunjukkan medium dari argumen, kita perlu menentukan register <code>D1w</code> di <code>Location</code> , dan klik <code>OK</code> : </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  Kode yang didekompilasi akan berbentuk: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Kita <code>param_1</code> bahwa nilai <code>param_1</code> kita adalah konstan, diteruskan oleh fungsi panggilan dan sama dengan <code>#$4147</code> .  Lalu apa yang seharusnya menjadi nilai <code>DAT_00ff0020</code> ?  Kami mempertimbangkan: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Karena  <code>xor</code> - operasi dapat dibalik, semua angka konstan dapat saling bertengkar dan mendapatkan nilai variabel <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Ternyata nilai variabel harus <code>0x4553</code> .  Sepertinya saya sudah melihat tempat di mana nilai tersebut ditetapkan ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Kesimpulan dan keputusan </h2><br><p>  Kami sampai pada hasil berikut: </p><br><ol><li>  Pertama, Anda perlu melompat ke alamat <code>0x0D3C</code> , untuk ini Anda harus memasukkan kode <code>0D3C</code> </li><li>  Lompat ke fungsi di <code>0x2D86</code> , yang menetapkan nilai <code>D1</code> untuk mendaftar <code>#$4147</code> , untuk ini Anda harus memasukkan kode <code>2D86</code> </li></ol><br><p>  Secara eksperimental, kami menemukan tombol yang perlu ditekan untuk memeriksa kunci yang dimasukkan: <code>B</code>  Kami mencoba: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Terima kasih </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448500/">https://habr.com/ru/post/id448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448488/index.html">Ketakutan dan Membenci DevSecOps</a></li>
<li><a href="../id448490/index.html">Cara memulai transformasi DevOps</a></li>
<li><a href="../id448492/index.html">Apa itu DevOps</a></li>
<li><a href="../id448496/index.html">.NET Core di Linux, DevOps dengan menunggang kuda</a></li>
<li><a href="../id448498/index.html">"Russia 404": Seberapa banyak internet gratis yang tersisa untuk hidup</a></li>
<li><a href="../id448504/index.html">Mereka mengumpulkan untuk semua orang "Habrom" buku referensi "Oleh siapa itu diterbitkan ..." untuk paspor. Unduh untuk kesehatan</a></li>
<li><a href="../id448506/index.html">Matrix berusia 20 tahun: bagaimana Wachowski membuat cyberpunk, yang menentukan agenda untuk seluruh generasi</a></li>
<li><a href="../id448510/index.html">Acer in 2019: bagaimana jika Anda menghapus semua lalat dari laptop gaming</a></li>
<li><a href="../id448516/index.html">Evolusi atau buat basis untuk robot pada platform ARDUINO, dan kami menggerakkan sensor dan video ke komputer melalui smartphone</a></li>
<li><a href="../id448518/index.html">Bagaimana cara melihat lubang hitam?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>