<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏿 🙎🏻 🕵️ Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 1 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👬 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dua tahun lalu, saya menulis tentang teknik yang sekarang biasa disebut modul / pola nomodule. Aplikasinya memungkinkan Anda untuk menulis kode JavaSc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466537/"> Dua tahun lalu, saya menulis tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknik</a> yang sekarang biasa disebut modul / pola nomodule.  Aplikasinya memungkinkan Anda untuk menulis kode JavaScript menggunakan kemampuan ES2015 +, dan kemudian menggunakan bundler dan transpiler untuk membuat dua versi basis kode.  Salah satunya mengandung sintaksis modern (ini dimuat menggunakan struktur seperti <code>&lt;script type="module"&gt;</code> , dan yang kedua adalah sintaksis ES5 (ini dimuat menggunakan <code>&lt;script nomodule&gt;</code> ). Pola modul / nomodule memungkinkan pengiriman ke browser yang mendukung modul, kode jauh lebih sedikit daripada browser yang tidak mendukung fitur ini, sekarang pola ini didukung oleh sebagian besar kerangka kerja web dan alat baris perintah. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/sd/_p/je/sd_pjea-digdrv7bbr_b3n4wdtq.jpeg"></a> <br><br>  Sebelumnya, walaupun mempertimbangkan kemampuan untuk mengirim kode JavaScript modern ke produksi, dan meskipun sebagian besar browser mendukung modul, saya merekomendasikan pengumpulan kode dalam bundel. <br><a name="habracut"></a><br>  Mengapa  Terutama karena saya merasa memuat modul ke browser lambat.  Meskipun protokol terbaru, seperti HTTP / 2, secara teoritis mendukung pemuatan yang efisien dari banyak file, semua studi kinerja pada saat itu menyimpulkan bahwa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bundler</a> masih lebih efisien daripada menggunakan modul. <br><br>  Tetapi harus diakui bahwa studi tersebut tidak lengkap.  Kasus uji menggunakan modul yang dipelajari di dalamnya terdiri dari file kode sumber yang tidak dioptimalkan dan tidak diperkecil yang digunakan dalam produksi.  Tidak ada perbandingan bundel yang dioptimalkan dengan modul dengan skrip klasik yang dioptimalkan. <br><br>  Namun, jujur ​​saja, tidak ada cara optimal untuk menyebarkan modul pada saat itu.  Tetapi sekarang, berkat beberapa peningkatan modern dalam teknologi bundler, dimungkinkan untuk menyebarkan kode produksi dalam bentuk modul ES2015 menggunakan perintah impor statis dan dinamis, dan pada saat yang sama menerima kinerja lebih tinggi daripada yang dapat dicapai dengan menggunakan opsi yang tersedia, di mana modul tidak digunakan. <br><br>  Perlu dicatat bahwa pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> di mana materi asli diterbitkan, bagian pertama dari terjemahan yang kami terbitkan hari ini, modul-modul tersebut telah digunakan dalam produksi selama beberapa bulan. <br><br><h2>  <font color="#3AC1EF">Kesalahpahaman tentang modul</font> </h2><br>  Banyak orang yang saya ajak bicara menolak modul sama sekali, bahkan tidak menganggapnya sebagai salah satu opsi untuk aplikasi produksi skala besar.  Banyak dari mereka mengutip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran</a> yang telah saya sebutkan.  Yaitu, bagian itu, yang menyatakan bahwa modul tidak boleh digunakan dalam produksi, kecuali itu adalah pertanyaan tentang "aplikasi web kecil yang mencakup kurang dari 100 modul yang berbeda dalam pohon ketergantungan yang relatif" kecil "(yaitu - yang kedalamannya tidak melebihi 5 level). " <br><br>  Jika Anda pernah melihat ke direktori <code>node_modules</code> dari salah satu proyek Anda, maka Anda mungkin tahu bahwa bahkan sebuah aplikasi kecil dapat dengan mudah memiliki lebih dari 100 modul dependensi.  Saya ingin menawarkan Anda melihat berapa banyak modul yang tersedia di beberapa paket npm paling populer. <br><div class="scrollable-table"><table><tbody><tr><td>  Paket <br></td><td>  Jumlah modul <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">date-fns</a> <br></td><td>  729 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lodash-es</a> <br></td><td>  643 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rxjs</a> <br></td><td>  226 <br></td></tr></tbody></table></div><br>  Di sinilah kesalahpahaman utama tentang modul di-root.  Programmer percaya bahwa ketika menggunakan modul dalam produksi, mereka hanya memiliki dua opsi.  Yang pertama adalah untuk menyebarkan semua kode sumber dalam bentuk yang sudah ada (termasuk direktori <code>node_modules</code> ).  Yang kedua adalah tidak menggunakan modul sama sekali. <br><br>  Namun, jika Anda memperhatikan rekomendasi dari studi yang dikutip di atas, Anda akan menemukan bahwa tidak ada yang mengatakan bahwa memuat modul lebih lambat daripada memuat skrip biasa.  Tidak disebutkan bahwa modul tidak boleh digunakan sama sekali.  Itu hanya berbicara tentang fakta bahwa jika seseorang menyebarkan ratusan file modul yang tidak terinfeksi dalam produksi, Chrome tidak akan dapat memuatnya secepat satu bundel yang diperkecil.  Akibatnya, penelitian ini menyarankan untuk terus menggunakan bundler, kompiler, dan minifiers. <br><br>  Tapi tahukah Anda?  Faktanya adalah bahwa Anda dapat menggunakan semua ini dan menggunakan modul dalam produksi. <br><br>  Sebenarnya, modul adalah format yang harus kita perjuangkan untuk mengonversi kode, karena browser sudah tahu cara memuat modul (dan browser yang tidak bisa melakukan ini dapat memuat fallback menggunakan mekanisme nomodule).  Jika Anda melihat kode yang dihasilkan bundler paling populer, maka Anda akan menemukan banyak fragmen templat yang tujuannya hanya untuk memuat kode lain secara dinamis dan mengelola dependensi.  Tetapi semua ini tidak diperlukan jika kita hanya menggunakan modul dan ekspresi, <code>import</code> dan <code>export</code> . <br><br>  Untungnya, setidaknya salah satu bundler modern populer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rollup</a> ) mendukung modul dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data keluaran</a> .  Ini berarti Anda dapat memproses kode dengan bundler dan menggunakan modul dalam produksi (tanpa menggunakan fragmen templat untuk memuat kode).  Dan, karena Rollup memiliki implementasi yang luar biasa dari algoritma tree-shaking (yang terbaik yang pernah saya lihat di bundler), membangun program dalam bentuk modul menggunakan Rollup memungkinkan Anda untuk mendapatkan kode yang lebih kecil dari ukuran kode yang diperoleh saat menerapkan mekanisme lain yang tersedia saat ini. <br><br>  Perlu dicatat bahwa mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berencana untuk</a> menambahkan dukungan untuk modul di versi Parcel berikutnya.  Webpack belum mendukung modul sebagai format output, tetapi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> - diskusi yang berfokus pada masalah ini. <br><br>  Kesalahpahaman lain mengenai modul adalah bahwa beberapa orang percaya bahwa modul hanya dapat digunakan jika 100% dari ketergantungan proyek menggunakan modul.  Sayangnya (saya menganggapnya sangat menyesal), sebagian besar paket npm masih disiapkan untuk publikasi menggunakan format CommonJS (beberapa modul, bahkan yang ditulis menggunakan fitur ES2015, diterjemahkan ke dalam format CommonJS sebelum dipublikasikan ke npm)! <br><br>  Di sini, sekali lagi, saya ingin mencatat bahwa Rollup memiliki plugin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rollup-plugin-commonjs</a> ) yang mengambil kode sumber input yang ditulis menggunakan CommonJS dan mengubahnya menjadi kode ES2015.  Jelas, akan lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baik</a> jika format ketergantungan yang digunakan dari awal menggunakan format modul ES2015.  Tetapi jika beberapa dependensi tidak seperti itu, ini tidak mencegah Anda dari menyebarkan proyek menggunakan modul dalam produksi. <br><br>  Di bagian berikut artikel ini, saya akan menunjukkan kepada Anda bagaimana saya mengumpulkan proyek dalam bundel yang menggunakan modul (termasuk penggunaan impor dinamis dan pemisahan kode), saya akan berbicara tentang mengapa solusi seperti itu biasanya lebih produktif daripada skrip klasik, dan menunjukkan cara kerjanya dengan browser yang tidak mendukung modul. <br><br><h2>  <font color="#3AC1EF">Strategi Membangun Kode Optimal</font> </h2><br>  Membangun kode untuk produksi selalu merupakan upaya untuk menyeimbangkan pro dan kontra dari berbagai solusi.  Di satu sisi, pengembang ingin kode-nya dimuat dan dieksekusi secepat mungkin.  Di sisi lain, dia tidak ingin mengunduh kode yang tidak akan digunakan oleh pengguna proyek. <br><br>  Selain itu, pengembang perlu percaya bahwa kode mereka paling cocok untuk caching.  Masalah besar dari bundling kode adalah bahwa setiap perubahan dalam kode, bahkan satu baris yang diubah, menyebabkan pembatalan cache seluruh bundel.  Jika Anda menggunakan aplikasi yang terdiri dari ribuan modul kecil (disajikan persis dalam bentuk di mana mereka hadir dalam kode sumber), maka Anda dapat dengan aman membuat perubahan kecil pada kode dan pada saat yang sama tahu bahwa sebagian besar kode aplikasi akan di-cache .  Tetapi, seperti yang telah saya katakan, pendekatan pengembangan seperti itu mungkin dapat berarti bahwa memuat kode saat pertama kali Anda mengunjungi sumber daya mungkin memerlukan waktu lebih lama daripada menggunakan pendekatan yang lebih tradisional. <br><br>  Akibatnya, kami menghadapi tugas yang sulit, yaitu menemukan pendekatan yang tepat untuk memecah bundel menjadi beberapa bagian.  Kita perlu mencapai keseimbangan yang tepat antara kecepatan pemuatan material dan caching jangka panjangnya. <br><br>  Sebagian besar bundler, secara default, menggunakan teknik pemecahan kode berdasarkan pada perintah impor dinamis.  Tapi saya akan mengatakan bahwa membagi kode hanya dengan fokus pada impor dinamis tidak memungkinkan memecahnya menjadi fragmen yang cukup kecil.  Ini terutama berlaku untuk situs dengan banyak pengguna yang kembali (yaitu, dalam situasi di mana caching penting). <br><br>  Saya percaya bahwa kode harus dipecah menjadi fragmen sekecil mungkin.  Sebaiknya kurangi ukuran fragmen hingga jumlahnya bertambah banyak sehingga akan mempengaruhi kecepatan pengunduhan proyek.  Dan walaupun saya merekomendasikan kepada semua orang untuk melakukan analisis mereka sendiri tentang situasi tersebut, jika Anda yakin perhitungan perkiraan yang dibuat dalam penelitian yang saya sebutkan, saat memuat kurang dari 100 modul, tidak ada kelambatan yang terlihat dalam memuat.  Studi terpisah tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://medium.com/%40asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-">kinerja HTTP / 2</a> tidak mengungkapkan perlambatan proyek yang nyata saat mengunduh kurang dari 50 file.  Namun, mereka hanya menguji opsi di mana jumlah file adalah 1, 6, 50, dan 1000. Akibatnya, mungkin 100 file adalah nilai yang dapat Anda navigasikan dengan mudah tanpa takut kehilangan kecepatan unduh. <br><br>  Jadi, apa cara terbaik untuk secara agresif, tetapi tidak terlalu agresif membagi kode menjadi beberapa bagian?  Selain kode pemisahan berdasarkan perintah impor dinamis, saya akan menyarankan Anda untuk melihat lebih dekat pada kode pemisahan ke dalam paket npm.  Dengan pendekatan ini, apa yang diimpor ke proyek dari folder <code>node_modules</code> jatuh ke dalam fragmen terpisah dari kode selesai berdasarkan pada nama paket. <br><br><h2>  <font color="#3AC1EF">Pemisahan Paket</font> </h2><br>  Saya katakan di atas bahwa beberapa kemampuan modern dari bundler memungkinkan untuk mengatur skema kinerja tinggi untuk penggelaran proyek berbasis modul.  Apa yang saya bicarakan diwakili oleh dua fitur Rollup baru.  Yang pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan kode otomatis</a> melalui perintah <code>import()</code> dinamis <code>import()</code> (ditambahkan <a href="">dalam v1.0.0</a> ).  Opsi kedua adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan kode manual yang</a> dilakukan oleh program berdasarkan pilihan <code>manualChunks</code> (ditambahkan pada <a href="">v1.11.0</a> ). <br><br>  Berkat kedua fitur ini, sekarang sangat mudah untuk mengkonfigurasi proses build, di mana kode dibagi pada tingkat paket. <br><br>  Berikut ini adalah contoh konfigurasi yang menggunakan opsi <code>manualChunks</code> , berkat setiap modul yang diimpor dari <code>node_modules</code> masuk ke dalam bagian kode yang terpisah yang namanya sesuai dengan nama paket (secara teknis, nama direktori paket di folder <code>node_modules</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {  <span class="hljs-attr"><span class="hljs-attr">input</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">main</span></span>: <span class="hljs-string"><span class="hljs-string">'src/main.mjs'</span></span>,  },  <span class="hljs-attr"><span class="hljs-attr">output</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'build'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'esm'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">entryFileNames</span></span>: <span class="hljs-string"><span class="hljs-string">'[name].[hash].mjs'</span></span>,  },  manualChunks(id) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id.includes(<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>)) {      <span class="hljs-comment"><span class="hljs-comment">//   ,    `node_modules`.      //   - ,       .      const dirs = id.split(path.sep);      return dirs[dirs.lastIndexOf('node_modules') + 1];    }  }, }</span></span></code> </pre> <br>  Opsi <code>manualChunk</code> menerima fungsi yang menerima, sebagai argumen tunggal, jalur ke file modul.  Fungsi ini dapat mengembalikan nama string.  Apa yang dikembalikan akan menunjuk ke sebuah fragmen rakitan di mana modul saat ini harus ditambahkan.  Jika fungsi tidak mengembalikan apa pun, maka modul akan ditambahkan ke fragmen default. <br><br>  Pertimbangkan aplikasi yang mengimpor <code>cloneDeep()</code> , <code>debounce()</code> dan <code>find()</code> dari paket <code>lodash-es</code> .  Jika Anda menerapkan konfigurasi di atas saat membuat aplikasi ini, maka masing-masing modul ini (serta setiap modul <code>lodash</code> diimpor oleh modul-modul ini) akan ditempatkan dalam file output tunggal dengan nama seperti <code>npm.lodash-es.XXXX.mjs</code> (di sini <code>XXXX</code> unik modul file hash dalam fragmen <code>lodash-es</code> ). <br><br>  Di akhir file, Anda akan melihat ekspresi ekspor seperti berikut ini.  Harap dicatat bahwa ungkapan ini hanya berisi perintah ekspor untuk modul yang ditambahkan ke fragmen, dan tidak semua modul <code>lodash</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> {cloneDeep, debounce, find};</code> </pre> <br>  Kemudian, jika kode di salah satu fragmen lain menggunakan modul <code>lodash</code> ini (mungkin hanya metode <code>debounce()</code> ), dalam fragmen ini, di bagian atas mereka, akan ada ekspresi impor yang terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {debounce} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./npm.lodash.XXXX.mjs'</span></span>;</code> </pre> <br>  Semoga contoh ini menjelaskan pertanyaan tentang cara pemisahan kode manual di Rollup.  Selain itu, saya berpikir bahwa hasil pemisahan kode menggunakan ekspresi <code>import</code> dan <code>export</code> jauh lebih mudah dibaca dan dipahami daripada kode fragmen, yang pembentukannya menggunakan mekanisme non-standar yang hanya digunakan dalam bundler tertentu. <br><br>  Misalnya, sangat sulit untuk mencari tahu apa yang sedang terjadi di file berikutnya.  Ini adalah output dari salah satu proyek lama saya yang menggunakan webpack untuk membagi kode.  Hampir semua hal dalam kode ini tidak diperlukan di browser yang mendukung modul. <br><br><pre> <code class="javascript hljs">(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] || []).push([[<span class="hljs-string"><span class="hljs-string">"import1"</span></span>],{ <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> <span class="hljs-string"><span class="hljs-string">"tLzr"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*!*********************************!*\  !*** ./app/scripts/import-1.js ***!  \*********************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*! exports provided: import1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, __webpack_exports__, __webpack_require__</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; __webpack_require__.r(__webpack_exports__); <span class="hljs-comment"><span class="hljs-comment">/* harmony export (binding) */</span></span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string"><span class="hljs-string">"import1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> import1; }); <span class="hljs-comment"><span class="hljs-comment">/* harmony import */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-comment"><span class="hljs-comment">/*! ./dep-1 */</span></span> <span class="hljs-string"><span class="hljs-string">"6xPP"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> import1 = <span class="hljs-string"><span class="hljs-string">"imported: "</span></span> + _dep_1__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string"><span class="hljs-string">"dep1"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> }) }]);</code> </pre> <br><h2>  <font color="#3AC1EF">Bagaimana jika ada ratusan dependensi npm?</font> </h2><br>  Seperti yang saya katakan, saya percaya bahwa pemisahan tingkat kode pada tingkat paket biasanya memungkinkan pengembang untuk masuk ke posisi yang baik ketika pemisahan kode agresif, tetapi tidak terlalu agresif. <br><br>  Tentu saja, jika aplikasi Anda mengimpor modul dari ratusan paket npm yang berbeda, Anda masih bisa berada dalam situasi di mana browser tidak dapat memuat semuanya secara efektif. <br><br>  Namun, jika Anda benar-benar memiliki banyak dependensi npm, Anda tidak boleh sepenuhnya meninggalkan strategi ini untuk saat ini.  Ingatlah bahwa Anda mungkin tidak akan mengunduh semua dependensi npm di setiap halaman.  Karena itu, penting untuk mengetahui berapa banyak sebenarnya dependensi yang dimuat. <br><br>  Namun demikian, saya yakin bahwa ada beberapa aplikasi nyata yang memiliki banyak dependensi npm sehingga dependensi ini tidak dapat direpresentasikan sebagai fragmen yang terpisah.  Jika proyek Anda hanya itu - Saya akan merekomendasikan Anda mencari cara untuk mengelompokkan paket di mana kode di mana dengan probabilitas tinggi dapat berubah pada saat yang sama (seperti <code>react</code> dan <code>react-dom</code> ) karena <code>react-dom</code> cache fragmen dengan paket-paket ini juga akan dieksekusi pada saat bersamaan.  Kemudian saya akan menunjukkan contoh di mana semua dependensi Bereaksi dikelompokkan dalam <a href="">fragmen yang</a> sama. <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mendekati masalah pemisahan kode dalam proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466537/">https://habr.com/ru/post/id466537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466525/index.html">Apa itu tata letak iPhone PSD dan bagaimana menggunakannya?</a></li>
<li><a href="../id466527/index.html">Menguji fungsionalitas pengguna situs web dengan objek halaman Capybara</a></li>
<li><a href="../id466529/index.html">Jenis Kompilasi di JVM: Mengekspos Sesi Sihir Hitam</a></li>
<li><a href="../id466533/index.html">Pastilda: hasil</a></li>
<li><a href="../id466535/index.html">Memikirkan kembali deepClone</a></li>
<li><a href="../id466539/index.html">Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 2</a></li>
<li><a href="../id466541/index.html">Menggunakan DbTool untuk Menyemai Basis Data dalam Aplikasi .NET (Core)</a></li>
<li><a href="../id466543/index.html">Pinjaman Habr Weekly # 17 / Sberbank akan disetujui oleh AI - menakutkan, beriklan di produk sumber terbuka - diragukan</a></li>
<li><a href="../id466547/index.html">Selamat Hari Programmer</a></li>
<li><a href="../id466549/index.html">Prinsip umum pengoperasian QEMU-KVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>