<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍎 👩🏽‍🤝‍👨🏾 🚶🏻 Comment Dark déploie le code 50 ms 👨🏿‍🚀 👄 📘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Plus le processus de développement est rapide, plus la société technologique se développe rapidement. 


 Malheureusement, les applications modernes f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Dark déploie le code 50 ms</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/462027/"><p><img src="https://habrastorage.org/webt/o4/lk/bi/o4lkbi449pbpjqw84e0wt-tywlq.png"></p><br><p>  Plus le processus de développement est rapide, plus la société technologique se développe rapidement. </p><br><p>  Malheureusement, les applications modernes fonctionnent contre nous - nos systèmes doivent être mis à jour en temps réel et en même temps pour ne pas interférer avec qui que ce soit et ne pas entraîner de temps d'arrêt et d'interruptions.  Le déploiement dans de tels systèmes devient une tâche complexe et nécessite des pipelines de livraison continue complexes, même dans de petites équipes. </p><br><p>  Ces pipelines ont généralement une application étroite, fonctionnent lentement et ne sont pas fiables.  Les développeurs doivent d'abord les créer manuellement, puis les gérer, et les entreprises engagent souvent des équipes DevOps entières pour cela. </p><br><p>  La vitesse de développement dépend de la vitesse de ces pipelines.  Pour les meilleures équipes, le déploiement prend 5 à 10 minutes, mais il prend généralement beaucoup plus de temps et pour un déploiement, il prend plusieurs heures. </p><a name="habracut"></a><br><p>  Dans l'obscurité, cela prend 50 ms.  <em>Cinquante.</em>  <em>Millisecondes</em>  Dark est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une solution complète avec un langage de programmation, un éditeur et une infrastructure</a> spécialement conçus pour une livraison continue, et tous les aspects de Dark, y compris le langage lui-même, sont construits avec une vue de déploiement instantané sécurisé. </p><br><h3 id="pochemu-konveyery-nepreryvnoy-postavki-takie-medlennye">  Pourquoi les convoyeurs continus sont-ils si lents? </h3><br><p> Disons que nous avons une application Web Python et que nous avons déjà créé un pipeline de livraison continue merveilleux et moderne.  Pour un développeur qui est quotidiennement occupé par ce projet, le déploiement d'un changement mineur ressemblera à ceci: </p><br><h3 id="vnesenie-izmeneniy">  Apporter des changements </h3><br><ul><li>  Créer une nouvelle branche dans git </li><li>  Faire des changements derrière le commutateur de fonction </li><li>  Test unitaire pour vérifier les changements avec et sans interrupteur de fonction </li></ul><br><h3 id="pul-rekvest">  Demande de piscine </h3><br><ul><li>  Commit commit </li><li>  Publier des modifications dans un référentiel distant sur github </li><li>  Demande de piscine </li><li>  CI se construit automatiquement en arrière-plan </li><li>  Examen du code </li><li>  Quelques révisions supplémentaires, si nécessaire </li><li>  Fusionnez les modifications avec l'assistant git. </li></ul><br><h3 id="ci-vypolnyaetsya-na-mastere">  CI s'exécute sur l'assistant </h3><br><ul><li>  Définition des dépendances frontales via npm </li><li>  Création et optimisation des ressources HTML + CSS + JS </li><li>  Exécuter à l'extrémité avant des tests unitaires et fonctionnels </li><li>  Installer les dépendances Python depuis PyPI </li><li>  Exécuter dans le backend des tests unitaires et fonctionnels </li><li>  Test d'intégration aux deux extrémités </li><li>  Envoyer des ressources frontales à CDN </li><li>  Construire un conteneur pour un programme Python </li><li>  Envoi d'un conteneur au registre </li><li>  Mise à jour du manifeste Kubernetes </li></ul><br><h3 id="zamena-starogo-koda-novym">  Remplacement de l'ancien code par un nouveau </h3><br><ul><li>  Kubernetes lance plusieurs instances d'un nouveau conteneur </li><li>  Kubernetes attend que les instances deviennent opérationnelles </li><li>  Kubernetes ajoute des instances à l'équilibreur de charge HTTP </li><li>  Kubernetes attend que les anciennes instances cessent d'être utilisées </li><li>  Kubernetes arrête les anciennes instances </li><li>  Kubernetes répète ces opérations jusqu'à ce que de nouvelles instances remplacent toutes les anciennes </li></ul><br><h3 id="vklyuchenie-novogo-pereklyuchatelya-funkcii">  Allumez le nouveau commutateur de fonction </h3><br><ul><li>  Le nouveau code est inclus uniquement pour moi, pour m'assurer que tout va bien </li><li>  Un nouveau code est inclus pour 10% des utilisateurs; les mesures opérationnelles et commerciales sont suivies </li><li>  Un nouveau code est inclus pour 50% des utilisateurs; les mesures opérationnelles et commerciales sont suivies </li><li>  Le nouveau code est inclus pour 100% des utilisateurs, les mesures opérationnelles et commerciales sont suivies </li><li>  Enfin, vous répétez toute la procédure pour supprimer l'ancien code et basculer </li></ul><br><p>  Le processus dépend des outils, du langage et de l'utilisation des architectures orientées services, mais en termes généraux, il ressemble à ceci.  Je n'ai pas mentionné les déploiements de migration de base de données car cela nécessite une planification minutieuse, mais ci-dessous, je vais décrire comment Dark gère cela. </p><br><p>  Il existe de nombreux composants ici, et beaucoup d'entre eux peuvent facilement ralentir, planter, provoquer une concurrence temporaire ou faire tomber le système de travail. </p><br><p>  Et puisque ces pipelines sont presque toujours créés pour une occasion spéciale, il est difficile de s'y fier.  Beaucoup de gens ont des jours où le code ne peut pas être déployé, car il y a des problèmes dans le Dockerfile, l'une des dizaines de services en panne ou le bon spécialiste en vacances. </p><br><p>  Pire encore, bon nombre de ces étapes ne font rien du tout.  Nous en avions besoin auparavant lorsque nous avons déployé le code immédiatement pour les utilisateurs, mais nous avons maintenant des commutateurs pour le nouveau code, et ces processus sont divisés.  En conséquence, l'étape à laquelle le code est déployé (l'ancien est remplacé par le nouveau) est maintenant devenue un risque supplémentaire. </p><br><p>  Bien sûr, c'est un pipeline très réfléchi.  L'équipe qui l'a créé a pris du temps et de l'argent pour se déployer rapidement.  Les pipelines de déploiement sont généralement beaucoup plus lents et plus peu fiables. </p><br><h3 id="realizaciya-nepreryvnoy-postavki-v-dark">  Implémentation de la livraison continue dans l'obscurité </h3><br><p>  La livraison continue est si importante pour Dark que nous visons le temps en moins d'une seconde.  Nous avons parcouru toutes les étapes du pipeline pour supprimer tout ce qui n'était pas nécessaire et nous avons pensé au reste.  C'est ainsi que nous avons supprimé les étapes. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jessie Frazelle a</a> inventé le nouveau mot sans déploiement lors de la conférence Future of Software Development à Reykjavik </blockquote><p>  Nous avons immédiatement décidé que Dark serait basé sur le concept de «sans déploiement» (merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jesse Frazel</a> pour le néologisme).  Sans déploiement signifie que tout code est instantanément déployé et prêt à être utilisé en production.  Bien sûr, nous ne manquerons pas un code défectueux ou incomplet (je décrirai les principes de sécurité ci-dessous). </p><br><p>  Lors de la démonstration Dark, on nous a souvent demandé comment nous avions réussi à accélérer le déploiement.  Étrange question.  Les gens pensent probablement que nous avons mis au point une sorte de supertechnologie qui compare le code, le compile, l'emballe dans un conteneur, lance une machine virtuelle, lance un conteneur sur une machine froide et des trucs comme ça - et tout cela en 50 ms.  Ce n'est guère possible.  Mais nous avons créé un moteur de déploiement spécial, qui n'a pas besoin de tout cela. </p><br><p>  Dark lance des interprètes dans le cloud.  Supposons que vous écriviez du code dans une fonction ou un gestionnaire pour HTTP ou des événements.  Nous envoyons diff à l'arborescence de syntaxe abstraite (l'implémentation du code utilisé en interne par notre éditeur et nos serveurs) à nos serveurs, puis exécutons ce code lorsque les demandes sont reçues.  Le déploiement ressemble donc à un enregistrement modeste dans la base de données - instantané et élémentaire.  Le déploiement est si rapide car il inclut le strict minimum. </p><br><p>  À l'avenir, nous prévoyons de créer un compilateur d'infrastructure à partir de Dark, qui créera et exécutera l'infrastructure idéale pour des performances et une fiabilité élevées des applications.  Le déploiement instantané, bien sûr, ne va nulle part. </p><br><h2 id="bezopasnoe-razvertyvanie">  Déploiement sécurisé </h2><br><h3 id="strukturirovannyy-redaktor">  Éditeur structuré </h3><br><p>  Le code dans Dark est écrit dans l'éditeur Dark.  L'éditeur structuré ne fait pas d'erreurs de syntaxe.  En fait, Dark n'a même pas d'analyseur.  Au fur et à mesure que vous tapez, nous travaillons directement avec l'arbre de syntaxe abstraite (AST) comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paredit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sketch-n-Sketch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tofu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prune</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MPS</a> . </p><br><p>  Tout code incomplet dans Dark a une sémantique d'exécution valide, un peu comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les trous tapés dans Hazel</a> .  Par exemple, si vous modifiez un appel de fonction, nous conservons l'ancienne fonction jusqu'à ce que la nouvelle devienne utilisable. </p><br><p>  Chaque programme dans Dark a sa propre signification, donc le code incomplet n'interfère pas avec le travail fini. </p><br><h3 id="rezhimy-redaktirovaniya">  Modes d'édition </h3><br><p>  Vous écrivez du code dans Dark dans deux cas.  Premièrement: vous écrivez un nouveau code et êtes le seul utilisateur.  Par exemple, il se trouve dans le REPL, et les autres utilisateurs n'y auront jamais accès, ou c'est une nouvelle route HTTP à laquelle vous ne faites référence nulle part.  Vous pouvez travailler ici sans aucune précaution, et maintenant vous travaillez approximativement dans l'environnement de développement. </p><br><p>  Deuxième situation: le code est déjà utilisé.  Si le trafic passe par le code (fonctions, gestionnaires d'événements, bases de données, type), il faut faire attention.  Pour ce faire, nous bloquons tout le code utilisé et demandons l'utilisation d'outils plus structurés pour le modifier.  Je vais parler des outils structurels ci-dessous: des commutateurs de fonction pour HTTP et les gestionnaires d'événements, une puissante plate-forme de migration pour les bases de données et une nouvelle méthode de contrôle de version pour les fonctions et les types. </p><br><h3 id="pereklyuchateli-funkciy">  Commutateurs de fonction </h3><br><p>  Une façon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de supprimer la complexité supplémentaire</a> dans Dark est de résoudre plusieurs problèmes avec une seule solution.  Les commutateurs de fonction effectuent de nombreuses tâches différentes: remplacement de l'environnement de développement local, branches git, déploiement de code et, bien sûr, la publication traditionnelle lente et contrôlée de nouveau code. </p><br><p>  La création et le déploiement d'un commutateur de fonction se fait dans notre éditeur en une seule opération.  Il crée un espace vide pour le nouveau code et fournit des contrôles d'accès pour l'ancien et le nouveau code, ainsi que des boutons et des commandes pour une transition progressive vers le nouveau code ou son exclusion. </p><br><p>  Les commutateurs de fonction sont intégrés dans le langage sombre, et même les commutateurs incomplets accomplissent leur tâche - si la condition dans le commutateur n'est pas remplie, l'ancien code bloqué sera exécuté. </p><br><h3 id="sreda-razrabotki">  Environnement de développement </h3><br><p>  Les commutateurs de fonction remplacent l'environnement de développement local.  Aujourd'hui, il est difficile pour les équipes de s'assurer que tout le monde utilise les mêmes versions d'outils et de bibliothèques (formateurs de code, linters, gestionnaires de packages, compilateurs, préprocesseurs, outils de test, etc.) Avec Dark, vous n'avez pas besoin d'installer les dépendances localement, de contrôler l'installation locale de Docker ou prendre d'autres mesures pour assurer au moins un semblant d'égalité entre l'environnement de développement et la production.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étant donné qu'une telle égalité est encore impossible</a> , nous ne prétendrons même pas que nous nous y efforçons. </p><br><p>  Au lieu de créer un environnement local cloné, les commutateurs dans Dark créent un nouveau sandbox en production qui remplace l'environnement de développement.  À l'avenir, nous prévoyons également de créer un sandbox pour d'autres parties de l'application (par exemple, les clones de bases de données instantanées), bien que cela ne semble pas si important pour l'instant. </p><br><h3 id="vetki-i-razvertyvaniya">  Succursales et déploiements </h3><br><p>  Il existe maintenant plusieurs façons d'entrer un nouveau code dans les systèmes: les branches git, la phase de déploiement et les commutateurs de fonction.  Ils résolvent un problème dans différentes parties du flux de travail: git - aux étapes avant le déploiement, déploiement - au moment de la transition de l'ancien code au nouveau, et commutateurs de fonction - pour la libération contrôlée du nouveau code. </p><br><p>  Le moyen le plus efficace est les commutateurs de fonction (en même temps les plus faciles à comprendre et à utiliser).  Avec eux, vous pouvez abandonner complètement les deux autres méthodes.  Il est particulièrement utile de supprimer le déploiement - si nous utilisons de toute façon des commutateurs de fonction pour inclure le code, l'étape de transfert des serveurs vers le nouveau code ne crée que des risques inutiles. </p><br><p>  Git est difficile à utiliser, surtout pour les débutants, et il le limite vraiment, mais il a des branches pratiques.  Nous avons corrigé de nombreux défauts de git.  Dark est édité en temps réel et offre la possibilité de travailler ensemble dans le style de Google Docs, afin que vous n'ayez pas à envoyer de code et que vous puissiez moins souvent effectuer une relocalisation et une fusion. </p><br><p>  Les commutateurs de fonctionnalités sous-tendent le déploiement sécurisé.  Associés à des déploiements instantanés, ils vous permettent de tester rapidement des concepts en petits fragments à faible risque, au lieu d'appliquer un changement majeur susceptible de faire tomber le système. </p><br><h3 id="versionirovanie">  Versioning </h3><br><p>  Pour changer les fonctions et les types, nous utilisons le versioning.  Si vous souhaitez modifier une fonction, Dark crée une nouvelle version de cette fonction.  Ensuite, vous pouvez appeler cette version à l'aide du commutateur dans le gestionnaire HTTP ou d'événements.  (Si cette fonction est profondément dans le graphique d'appel, une nouvelle version de chaque fonction est créée dans le processus. Cela peut sembler trop, mais les fonctions n'interfèrent pas si vous ne les utilisez pas, donc vous ne le remarquerez même pas.) </p><br><p>  Pour les mêmes raisons, nous proposons des types de version.  Nous avons parlé de notre système de type en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un précédent post</a> . </p><br><p>  En fonction des versions et des types de versions, vous pouvez modifier progressivement l'application.  Vous pouvez vérifier que chaque gestionnaire individuel fonctionne avec la nouvelle version, vous n'avez pas besoin d'apporter immédiatement toutes les modifications aux applications (mais nous avons des outils pour le faire rapidement si vous le souhaitez). </p><br><p>  C'est beaucoup plus sûr que de déployer tout en une seule fois, comme c'est le cas actuellement. </p><br><h3 id="novye-versii-paketov-i-standartnaya-biblioteka">  Nouvelles versions de packages et bibliothèque standard </h3><br><p>  Lorsque vous mettez à jour un package dans Dark, nous ne remplaçons pas immédiatement l'utilisation de chaque fonction ou type dans la base de code entière.  Ce n'est pas sûr.  Le code continue d'utiliser la même version qu'il a utilisé et vous mettez à jour l'utilisation des fonctions et des types vers une nouvelle version pour chaque cas individuel à l'aide des commutateurs. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rh/t3/4w/rht34wyibolrgracbz88tnqqhg0.png"></a> <br>  <em>Une capture d'écran d'une partie d'un processus automatique dans Dark montrant deux versions de la fonction Dict :: get.</em>  <em>Dict :: get_v0 a renvoyé le type Any (ce que nous refusons) et Dict :: get_v1 a renvoyé le type Option.</em> </p><br><p>  Nous fournissons souvent une nouvelle fonctionnalité dans la bibliothèque standard et excluons les anciennes versions.  Les utilisateurs ayant d'anciennes versions dans le code y conserveront l'accès, mais les nouveaux utilisateurs ne pourront pas les obtenir.  Nous allons fournir des outils pour transférer les utilisateurs des anciennes versions vers les nouvelles en 1 étape, et à nouveau en utilisant des commutateurs de fonction. </p><br><p>  Dark offre également une opportunité unique: une fois que nous avons exécuté votre code de travail, nous pouvons tester les nouvelles versions nous-mêmes, en comparant la sortie des nouvelles et anciennes demandes pour vous informer des changements.  Par conséquent, les mises à jour de packages, qui sont souvent effectuées à l'aveugle (ou nécessitent des tests de sécurité rigoureux), posent beaucoup moins de risques et peuvent se produire automatiquement. </p><br><h3 id="novye-versii-dark">  Nouvelles versions sombres </h3><br><p>  La transition de Python 2 à Python 3 s'est étalée sur une décennie et reste toujours un problème.  Une fois que nous avons créé Dark pour une livraison continue, ces changements de langue doivent être pris en compte. </p><br><p>  Lorsque nous apportons de petites modifications à la langue, nous créons une nouvelle version de Dark.  L'ancien code reste dans l'ancienne version de Dark et le nouveau code est utilisé dans la nouvelle version.  Pour passer à la nouvelle version de Dark, vous pouvez utiliser les commutateurs ou versions de fonctions. </p><br><p>  Ceci est particulièrement utile étant donné que Dark est apparu récemment.  De nombreuses modifications apportées à la langue ou à la bibliothèque peuvent échouer.  La version progressive de la langue nous permet de faire des mises à jour mineures, c'est-à-dire que nous ne pouvons pas nous précipiter et reporter de nombreuses décisions sur la langue jusqu'à ce que nous ayons plus d'utilisateurs, et donc plus d'informations. </p><br><h3 id="migracii-baz-dannyh">  Migrations de bases de données </h3><br><p>  Il existe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">formule standard</a> pour une migration sécurisée des bases de données: </p><br><ul><li>  Réécrire le code pour prendre en charge les nouveaux et les anciens formats </li><li>  Convertissez toutes les données dans un nouveau format </li><li>  Supprimer l'ancien accès aux données </li></ul><br><p>  Par conséquent, la migration de la base de données est retardée et nécessite beaucoup de ressources.  Et nous accumulons des schémas obsolètes, car même des tâches simples, telles que la correction du nom d'une table ou d'une colonne, ne valent pas la peine. </p><br><p>  Dark a une plateforme de migration de base de données efficace qui (nous l'espérons) simplifiera tellement le processus que vous n'en aurez plus peur.  Tous les magasins de données dans Dark (paires clé-valeur ou tables de hachage persistantes) sont de type.  Pour migrer un entrepôt de données, il vous suffit de lui affecter un nouveau type et une fonction de restauration et de restauration pour convertir les valeurs entre les deux types. </p><br><p>  L'accès aux entrepôts de données dans Dark se fait via des noms de variable versionnés.  Par exemple, le magasin de données des utilisateurs s'appellerait initialement Users-v0.  Lorsqu'une nouvelle version avec un type différent est créée, le nom change en Users-v1.  Si les données sont enregistrées via Users-v0 et que vous y accédez via Users-v1, la fonction de substitution est appliquée.  Si les données sont enregistrées via Users-v1 et que vous y accédez via Users-v0, la fonction de restauration est utilisée. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ui/sl/wd/uislwdrfrvact0d1ts5icnk-4ka.png"></a> <br>  <em>Écran de migration de la base de données avec des noms de champs pour l'ancienne base de données, des expressions de restauration et de restauration, et des instructions pour activer la migration.</em> </p><br><p>  Utilisez les commutateurs de fonction pour router les appels vers Users-v0 vers Users-v1.  Vous pouvez effectuer ce gestionnaire HTTP à la fois pour réduire les risques, et les commutateurs fonctionnent également pour les utilisateurs individuels afin que vous puissiez vérifier que tout fonctionne comme prévu.  Lorsque Users-v0 n'est pas laissé, Dark convertit toutes les données restantes en arrière-plan de l'ancien format vers le nouveau.  Vous ne le remarquerez même pas. </p><br><h3 id="testirovanie">  Test </h3><br><p>  Dark est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage de programmation fonctionnel avec un typage statique</a> et des valeurs immuables; par conséquent, sa surface de test est nettement plus petite que les langages orientés objet avec un typage dynamique.  Mais vous devez toujours tester. <br>  Dans Dark, l'éditeur exécute automatiquement des tests unitaires en arrière-plan pour le code modifiable et, par défaut, exécute ces tests pour tous les commutateurs de fonction.  À l'avenir, nous voulons utiliser les types statiques pour flouer automatiquement le code pour trouver des bogues. </p><br><p>  De plus, Dark gère votre infrastructure en production, ce qui ouvre de nouvelles possibilités.  Nous enregistrons automatiquement les requêtes HTTP dans l'infrastructure Dark (pour l'instant, nous enregistrons toutes les requêtes, mais nous voulons ensuite passer à la récupération).  Nous testons de nouveaux codes sur eux et effectuons des tests unitaires, et si vous le souhaitez, vous pouvez facilement convertir des requêtes intéressantes en tests unitaires. </p><br><h3 id="ot-chego-my-izbavilis">  Ce dont nous nous sommes débarrassés </h3><br><p>  Comme nous n'avons pas de déploiement, mais qu'il existe des commutateurs de fonction, environ 60% du pipeline de déploiement reste à la mer.  Nous n'avons pas besoin de branches git ou de demandes de pool, de la création de ressources et de conteneurs backend, de l'envoi de ressources et de conteneurs aux registres ou aux étapes de déploiement dans Kubernetes. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gc/9e/g-/gc9eg-szouq0dtrxxr8jd6c6dyo.jpeg"></a> <br>  <em>Comparaison du pipeline de livraison continue standard (à gauche) et de l'approvisionnement continu de Dark (à droite).</em>  <em>Dans Dark, la livraison se compose de 6 étapes et d'un cycle, tandis que la version traditionnelle comprend 35 étapes et 3 cycles.</em> </p><br><p>  Dans Dark, il n'y a que 6 étapes et 1 cycle dans le déploiement (étapes répétées plusieurs fois), tandis que le pipeline d'approvisionnement continu moderne comprend 35 étapes et 3 cycles.  Dans Dark, les tests s'exécutent automatiquement et vous ne le voyez même pas;  les dépendances sont installées automatiquement;  tout ce qui concerne git ou github n'est plus nécessaire;  Il n'est pas nécessaire de collecter, tester et envoyer des conteneurs Docker;  Le déploiement de Kubernetes n'est plus nécessaire. </p><br><p>  Même les étapes restantes dans Dark sont devenues plus faciles.  Étant donné que les commutateurs de fonction peuvent être contrôlés en une seule action, vous n'avez pas à parcourir l'intégralité du pipeline de déploiement une deuxième fois pour supprimer l'ancien code. </p><br><p>  Nous avons simplifié la livraison du code autant que possible, réduisant le temps et les risques de livraison continue.  Nous avons également considérablement simplifié les mises à jour des packages, les migrations de bases de données, les tests, le contrôle de version, l'installation des dépendances, l'égalité entre l'environnement de développement et la production, et les mises à niveau rapides et sûres des versions linguistiques. </p><br><p>  Je réponds aux questions à ce sujet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HackerNews</a> . </p><br><p>  Pour en savoir plus sur l'appareil Dark, lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article Dark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivez-nous sur Twitter</a> (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moi</a> ), ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inscrivez-vous pour une version bêta et recevez des notifications des articles suivants</a> .  Si vous venez à StrangeLoop en septembre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">venez à notre lancement</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462027/">https://habr.com/ru/post/fr462027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462013/index.html">Historique des problèmes de migration du stockage Docker (racine Docker)</a></li>
<li><a href="../fr462015/index.html">Univers de reporting SAP</a></li>
<li><a href="../fr462021/index.html">Comment arrêter de faire la même chose</a></li>
<li><a href="../fr462023/index.html">Cascadeur: L'avenir de l'animation de jeux</a></li>
<li><a href="../fr462025/index.html">Modèle de données de réseau relationnel</a></li>
<li><a href="../fr462029/index.html">19 fonctionnalités utiles du fichier .htaccess</a></li>
<li><a href="../fr462031/index.html">Comme si vous lisiez les journaux!: Lancez Hotspot 2.0 sur le réseau Wi-Fi du métro</a></li>
<li><a href="../fr462033/index.html">La dernière cène des développeurs</a></li>
<li><a href="../fr462035/index.html">Python Vs R - Science des données</a></li>
<li><a href="../fr462041/index.html">Approches de segmentation mobile - Traduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>